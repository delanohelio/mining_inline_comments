{"pr_number": 3466, "pr_title": "Test/qinq final", "pr_createdAt": "2020-05-13T13:57:57Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3466", "timeline": [{"oid": "d559b319e86c135c9e631b4528596b1451b0e65e", "url": "https://github.com/telstra/open-kilda/commit/d559b319e86c135c9e631b4528596b1451b0e65e", "message": "test traffic for vlan/default/qinq flows at the same time", "committedDate": "2020-05-13T14:30:57Z", "type": "forcePushed"}, {"oid": "d3ecc3671ffa79d02c64c7ff09d0fe755f78ee62", "url": "https://github.com/telstra/open-kilda/commit/d3ecc3671ffa79d02c64c7ff09d0fe755f78ee62", "message": "test traffic for vlan/default/qinq flows at the same time", "committedDate": "2020-05-13T16:01:23Z", "type": "forcePushed"}, {"oid": "8e0a7192d2032a8a47cd6f1b301602f43cbd66c1", "url": "https://github.com/telstra/open-kilda/commit/8e0a7192d2032a8a47cd6f1b301602f43cbd66c1", "message": "add draft test for qinq+connecteDevices", "committedDate": "2020-05-14T14:11:25Z", "type": "forcePushed"}, {"oid": "89ad7619d759fad9248aadb78270261adfdf815d", "url": "https://github.com/telstra/open-kilda/commit/89ad7619d759fad9248aadb78270261adfdf815d", "message": "add draft test for qinq+connecteDevices", "committedDate": "2020-05-15T08:41:53Z", "type": "forcePushed"}, {"oid": "053a2ad50ac0c14d702c1aef1df0cd232c98f23b", "url": "https://github.com/telstra/open-kilda/commit/053a2ad50ac0c14d702c1aef1df0cd232c98f23b", "message": "adjust connectedDevices work with qinq and add test", "committedDate": "2020-05-15T14:44:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg1NzQ4Ng==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r425857486", "bodyText": "This is not really required, you will anyway fail at L1040 with almost the same message.  Of course the earlier the better, but at least provide a more specific assumption message here", "author": "rtretyak", "createdAt": "2020-05-15T14:54:38Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ConnectedDevicesSpec.groovy", "diffHunk": "@@ -1023,6 +1023,177 @@ srcDevices=#newSrcEnabled, dstDevices=#newDstEnabled\"() {\n         SwitchHelper.updateSwitchProperties(sw, initProps)\n     }\n \n+    @Unroll\n+    @Tags([TOPOLOGY_DEPENDENT])\n+    @IterationTag(tags = [HARDWARE], iterationNameRegex = /VXLAN/)\n+    def \"System detects devices for a qinq(iVlan=#vlanId oVlan=#innerVlanId) flow with lldp and arp enabled on the src switch\"() {\n+        assumeTrue(\"Devices+VXLAN problem https://github.com/telstra/open-kilda/issues/3199\",\n+                encapsulationType != FlowEncapsulationType.VXLAN)\n+\n+        given: \"Two switches connected to traffgen and they support enabled multiTable mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))", "originalCommit": "053a2ad50ac0c14d702c1aef1df0cd232c98f23b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU0MzIyOA==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r426543228", "bodyText": "agree, fixed\nchanged to \"Unable to find two active traffgens\"", "author": "andriidovhan", "createdAt": "2020-05-18T11:00:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg1NzQ4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg1ODQwOA==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r425858408", "bodyText": "extra line", "author": "rtretyak", "createdAt": "2020-05-15T14:55:52Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ConnectedDevicesSpec.groovy", "diffHunk": "@@ -1023,6 +1023,177 @@ srcDevices=#newSrcEnabled, dstDevices=#newDstEnabled\"() {\n         SwitchHelper.updateSwitchProperties(sw, initProps)\n     }\n \n+    @Unroll\n+    @Tags([TOPOLOGY_DEPENDENT])\n+    @IterationTag(tags = [HARDWARE], iterationNameRegex = /VXLAN/)\n+    def \"System detects devices for a qinq(iVlan=#vlanId oVlan=#innerVlanId) flow with lldp and arp enabled on the src switch\"() {\n+        assumeTrue(\"Devices+VXLAN problem https://github.com/telstra/open-kilda/issues/3199\",\n+                encapsulationType != FlowEncapsulationType.VXLAN)\n+\n+        given: \"Two switches connected to traffgen and they support enabled multiTable mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"A QinQ flow with enabled connected devices\"\n+        def tgService = traffExamProvider.get()\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.vlanId = vlanId\n+        flow.source.innerVlanId = innerVlanId\n+        flow.encapsulationType = encapsulationType\n+        flow.source.detectConnectedDevices.arp = true\n+        flow.source.detectConnectedDevices.lldp = true\n+", "originalCommit": "053a2ad50ac0c14d702c1aef1df0cd232c98f23b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU0MzM4MA==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r426543380", "bodyText": "fixed", "author": "andriidovhan", "createdAt": "2020-05-18T11:00:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg1ODQwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg2Mjg0NA==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r425862844", "bodyText": "This is a quite specific logic which I think is deserved to be reflected in the step description. I mean the fact that only outer vlan is shown in case of qinq", "author": "rtretyak", "createdAt": "2020-05-15T15:02:27Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ConnectedDevicesSpec.groovy", "diffHunk": "@@ -1023,6 +1023,177 @@ srcDevices=#newSrcEnabled, dstDevices=#newDstEnabled\"() {\n         SwitchHelper.updateSwitchProperties(sw, initProps)\n     }\n \n+    @Unroll\n+    @Tags([TOPOLOGY_DEPENDENT])\n+    @IterationTag(tags = [HARDWARE], iterationNameRegex = /VXLAN/)\n+    def \"System detects devices for a qinq(iVlan=#vlanId oVlan=#innerVlanId) flow with lldp and arp enabled on the src switch\"() {\n+        assumeTrue(\"Devices+VXLAN problem https://github.com/telstra/open-kilda/issues/3199\",\n+                encapsulationType != FlowEncapsulationType.VXLAN)\n+\n+        given: \"Two switches connected to traffgen and they support enabled multiTable mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"A QinQ flow with enabled connected devices\"\n+        def tgService = traffExamProvider.get()\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.vlanId = vlanId\n+        flow.source.innerVlanId = innerVlanId\n+        flow.encapsulationType = encapsulationType\n+        flow.source.detectConnectedDevices.arp = true\n+        flow.source.detectConnectedDevices.lldp = true\n+\n+\n+        and: \"Switches with turned 'on' multiTable property\"\n+        def initialSrcProps = enableMultiTableIfNeeded(true, swP.src.dpId)\n+        def initialDstProps = enableMultiTableIfNeeded(false, swP.dst.dpId)\n+\n+        when: \"Create a flow with connected devices\"\n+        flowHelperV2.addFlow(flow)\n+\n+        then: \"Flow and src/dst switches are valid\"\n+        def createdFlow = database.getFlow(flow.flowId)\n+        validateFlowAndSwitches(createdFlow)\n+\n+        and: \"LLDP meters must be installed\"\n+        validateLldpMeters(createdFlow, true)\n+        validateLldpMeters(createdFlow, false)\n+\n+        when: \"Devices send lldp and arp packets on each flow endpoint\"\n+        def srcLldpData = LldpData.buildRandom()\n+        def dstLldpData = LldpData.buildRandom()\n+        def srcArpData = ArpData.buildRandom()\n+        def dstArpData = ArpData.buildRandom()\n+        withPool {\n+            [[flow.source, srcLldpData, srcArpData], [flow.destination, dstLldpData, dstArpData]].eachParallel {\n+                endpoint, lldpData, arpData ->\n+                    new ConnectedDevice(tgService, topology.getTraffGen(endpoint.switchId),\n+                            [endpoint.vlanId, endpoint.innerVlanId]).withCloseable {\n+                        it.sendLldp(lldpData)\n+                        it.sendArp(arpData)\n+                    }\n+            }\n+        }\n+\n+        then: \"Getting connecting devices shows corresponding devices on src endpoint\"\n+        Wrappers.wait(WAIT_OFFSET) { //need some time for devices to appear\n+            verifyAll(northbound.getFlowConnectedDevices(flow.flowId)) {\n+                it.source.lldp.size() == 1\n+                it.source.arp.size() == 1\n+                it.destination.lldp.empty\n+                it.destination.arp.empty\n+                verifyEquals(it.source.lldp.first(), srcLldpData)\n+                verifyEquals(it.source.arp.first(), srcArpData)\n+            }\n+        }\n+\n+        and: \"Devices are registered on the src switch only\"\n+        verifyAll(northboundV2.getConnectedDevices(flow.source.switchId).ports) {\n+            it.size() == 1\n+            it[0].portNumber == flow.source.portNumber\n+            it[0].lldp.size() == 1\n+            it[0].lldp.first().flowId == flow.flowId\n+            it[0].lldp.first().vlan == (flow.source.vlanId ? flow.source.vlanId : innerVlanId)", "originalCommit": "053a2ad50ac0c14d702c1aef1df0cd232c98f23b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU0NTEzNQ==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r426545135", "bodyText": "actually it is not specific logic, it is a known issue\nI've added related comment about it\nit[0].lldp.first().vlan == (flow.source.vlanId ? flow.source.vlanId : innerVlanId) //due to issue 3475", "author": "andriidovhan", "createdAt": "2020-05-18T11:04:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg2Mjg0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg2Nzg1Nw==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r425867857", "bodyText": "What if flows is qnq but device sends one-vlan only?\nWhat if device only match qnq flow on outer vlan and not match on inner vlan, will it be registered per flow?", "author": "rtretyak", "createdAt": "2020-05-15T15:10:34Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ConnectedDevicesSpec.groovy", "diffHunk": "@@ -1023,6 +1023,177 @@ srcDevices=#newSrcEnabled, dstDevices=#newDstEnabled\"() {\n         SwitchHelper.updateSwitchProperties(sw, initProps)\n     }\n \n+    @Unroll\n+    @Tags([TOPOLOGY_DEPENDENT])\n+    @IterationTag(tags = [HARDWARE], iterationNameRegex = /VXLAN/)\n+    def \"System detects devices for a qinq(iVlan=#vlanId oVlan=#innerVlanId) flow with lldp and arp enabled on the src switch\"() {\n+        assumeTrue(\"Devices+VXLAN problem https://github.com/telstra/open-kilda/issues/3199\",\n+                encapsulationType != FlowEncapsulationType.VXLAN)\n+\n+        given: \"Two switches connected to traffgen and they support enabled multiTable mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"A QinQ flow with enabled connected devices\"\n+        def tgService = traffExamProvider.get()\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.vlanId = vlanId\n+        flow.source.innerVlanId = innerVlanId\n+        flow.encapsulationType = encapsulationType\n+        flow.source.detectConnectedDevices.arp = true\n+        flow.source.detectConnectedDevices.lldp = true\n+\n+\n+        and: \"Switches with turned 'on' multiTable property\"\n+        def initialSrcProps = enableMultiTableIfNeeded(true, swP.src.dpId)\n+        def initialDstProps = enableMultiTableIfNeeded(false, swP.dst.dpId)\n+\n+        when: \"Create a flow with connected devices\"\n+        flowHelperV2.addFlow(flow)\n+\n+        then: \"Flow and src/dst switches are valid\"\n+        def createdFlow = database.getFlow(flow.flowId)\n+        validateFlowAndSwitches(createdFlow)\n+\n+        and: \"LLDP meters must be installed\"\n+        validateLldpMeters(createdFlow, true)\n+        validateLldpMeters(createdFlow, false)\n+\n+        when: \"Devices send lldp and arp packets on each flow endpoint\"\n+        def srcLldpData = LldpData.buildRandom()\n+        def dstLldpData = LldpData.buildRandom()\n+        def srcArpData = ArpData.buildRandom()\n+        def dstArpData = ArpData.buildRandom()\n+        withPool {\n+            [[flow.source, srcLldpData, srcArpData], [flow.destination, dstLldpData, dstArpData]].eachParallel {\n+                endpoint, lldpData, arpData ->\n+                    new ConnectedDevice(tgService, topology.getTraffGen(endpoint.switchId),\n+                            [endpoint.vlanId, endpoint.innerVlanId]).withCloseable {\n+                        it.sendLldp(lldpData)\n+                        it.sendArp(arpData)\n+                    }\n+            }\n+        }\n+\n+        then: \"Getting connecting devices shows corresponding devices on src endpoint\"\n+        Wrappers.wait(WAIT_OFFSET) { //need some time for devices to appear\n+            verifyAll(northbound.getFlowConnectedDevices(flow.flowId)) {\n+                it.source.lldp.size() == 1\n+                it.source.arp.size() == 1\n+                it.destination.lldp.empty\n+                it.destination.arp.empty\n+                verifyEquals(it.source.lldp.first(), srcLldpData)\n+                verifyEquals(it.source.arp.first(), srcArpData)\n+            }\n+        }\n+\n+        and: \"Devices are registered on the src switch only\"\n+        verifyAll(northboundV2.getConnectedDevices(flow.source.switchId).ports) {\n+            it.size() == 1\n+            it[0].portNumber == flow.source.portNumber\n+            it[0].lldp.size() == 1\n+            it[0].lldp.first().flowId == flow.flowId\n+            it[0].lldp.first().vlan == (flow.source.vlanId ? flow.source.vlanId : innerVlanId)\n+            verifyEquals(it[0].lldp.first(), srcLldpData)\n+            it[0].arp.size() == 1\n+            it[0].arp.first().flowId == flow.flowId\n+            it[0].arp.first().vlan == (flow.source.vlanId ? flow.source.vlanId : innerVlanId)\n+            verifyEquals(it[0].arp.first(), srcArpData)\n+        }\n+        northboundV2.getConnectedDevices(flow.destination.switchId).ports.empty\n+\n+        and: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+        def flowIsDeleted = true\n+\n+        and: \"Delete action removed all rules and meters\"\n+        Wrappers.wait(WAIT_OFFSET) {\n+            validateSwitchHasNoFlowRulesAndMeters(swP.src.dpId)\n+        }\n+\n+        cleanup: \"Restore initial switch properties\"\n+        !flowIsDeleted && flowHelperV2.deleteFlow(flow.flowId)\n+        initialSrcProps && restoreSwitchProperties(swP.src.dpId, initialSrcProps)\n+        initialDstProps && restoreSwitchProperties(swP.dst.dpId, initialDstProps)\n+        srcLldpData && database.removeConnectedDevices(swP.src.dpId)\n+\n+        where:\n+        vlanId | innerVlanId | encapsulationType\n+        0      | 200         | FlowEncapsulationType.TRANSIT_VLAN\n+        100    | 200         | FlowEncapsulationType.TRANSIT_VLAN\n+        0      | 200         | FlowEncapsulationType.VXLAN\n+        100    | 200         | FlowEncapsulationType.VXLAN\n+    }\n+\n+    @Unroll\n+    @Tags([SMOKE_SWITCHES])\n+    def \"Able to detect devices on a qinq single-switch different-port flow\"() {\n+        given: \"A flow between different ports on the same switch\"\n+        def sw = topology.activeTraffGens*.switchConnected.first() ?:\n+                assumeTrue(\"No suiting switches found\", false)\n+        def initialProps = enableMultiTableIfNeeded(true, sw.dpId)\n+\n+        def flow = flowHelperV2.singleSwitchFlow(sw)\n+        flow.source.detectConnectedDevices.lldp = true\n+        flow.source.detectConnectedDevices.arp = true\n+        flow.source.vlanId = vlanId\n+        flow.source.innerVlanId = innerVlanId\n+        flow.encapsulationType = encapsulationType\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Device connects to src endpoint and send lldp and arp packets\"\n+        def lldpData = LldpData.buildRandom()\n+        def arpData = ArpData.buildRandom()\n+        new ConnectedDevice(traffExamProvider.get(), topology.getTraffGen(sw.dpId),\n+                [flow.source.vlanId, flow.source.innerVlanId]).withCloseable {\n+            it.sendLldp(lldpData)\n+            it.sendArp(arpData)\n+        }\n+\n+        then: \"LLDP and ARP connected devices are recognized and saved\"\n+        Wrappers.wait(WAIT_OFFSET) { //need some time for devices to appear\n+            verifyAll(northbound.getFlowConnectedDevices(flow.flowId)) {\n+                it.source.lldp.size() == 1\n+                it.source.arp.size() == 1\n+                it.destination.lldp.empty\n+                it.destination.arp.empty\n+                verifyEquals(it.source.lldp[0], lldpData)\n+                verifyEquals(it.source.arp[0], arpData)\n+            }\n+        }\n+\n+        and: \"Devices are registered on the switch\"\n+        verifyAll(northboundV2.getConnectedDevices(flow.source.switchId).ports) {\n+            it.size() == 1\n+            it[0].portNumber == flow.source.portNumber\n+            it[0].lldp.size() == 1\n+            it[0].lldp.first().flowId == flow.flowId\n+            it[0].lldp.first().vlan == (flow.source.vlanId ? flow.source.vlanId : innerVlanId)\n+            verifyEquals(it[0].lldp.first(), lldpData)\n+            it[0].arp.size() == 1\n+            it[0].arp.first().flowId == flow.flowId\n+            it[0].arp.first().vlan == (flow.source.vlanId ? flow.source.vlanId : innerVlanId)\n+            verifyEquals(it[0].arp.first(), arpData)\n+        }\n+\n+        cleanup: \"Restore initial switch properties\"\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        initialProps && restoreSwitchProperties(sw.dpId, initialProps)\n+        sw && database.removeConnectedDevices(sw.dpId)\n+\n+        where:\n+        vlanId | innerVlanId | encapsulationType\n+        0      | 200         | FlowEncapsulationType.TRANSIT_VLAN\n+        100    | 200         | FlowEncapsulationType.TRANSIT_VLAN\n+        0      | 200         | FlowEncapsulationType.VXLAN\n+        100    | 200         | FlowEncapsulationType.VXLAN\n+    }\n+", "originalCommit": "053a2ad50ac0c14d702c1aef1df0cd232c98f23b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU2ODM2MQ==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r426568361", "bodyText": "devices won't be registred.\nadded relevant test \"System doesn't detect devices only if vlan match with outerVlan of qinq flow\"", "author": "andriidovhan", "createdAt": "2020-05-18T11:50:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg2Nzg1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg3MjM1NA==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r425872354", "bodyText": "I understand the purpose, but this change will disable this test for the foreseeable future, since we are not using multitable for now. On the other hand, it is kinda regression, so it's your call", "author": "rtretyak", "createdAt": "2020-05-15T15:17:13Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/DefaultFlowV2Spec.groovy", "diffHunk": "@@ -28,13 +28,16 @@ class DefaultFlowV2Spec extends HealthCheckSpecification {\n \n     @Tidy\n     @Tags([SMOKE_SWITCHES])\n-    def \"Systems allows to pass traffic via default and vlan flow when they are on the same port\"() {\n+   def \"Systems allows to pass traffic via default/vlan and qinq flow when they are on the same port\"() {\n         given: \"At least 3 traffGen switches\"\n         def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n         assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 2) as boolean)\n \n         when: \"Create a vlan flow\"\n         def (Switch srcSwitch, Switch dstSwitch) = allTraffGenSwitches\n+        assumeTrue( \"MultiTable more should be enabled on the src and dst switches\",\n+        (northbound.getSwitchProperties(srcSwitch.dpId).multiTable &&\n+            northbound.getSwitchProperties(dstSwitch.dpId).multiTable))", "originalCommit": "053a2ad50ac0c14d702c1aef1df0cd232c98f23b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU5NTI5OQ==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r426595299", "bodyText": "decided: enable multiTable mode during test", "author": "andriidovhan", "createdAt": "2020-05-18T12:40:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg3MjM1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg3MzcxMQ==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r425873711", "bodyText": "?", "author": "rtretyak", "createdAt": "2020-05-15T15:19:17Z", "path": "src-java/testing/test-library/src/main/java/org/openkilda/testing/service/traffexam/TraffExamServiceImpl.java", "diffHunk": "@@ -343,14 +344,16 @@ public void destroy() throws Exception {\n     }\n \n     @Override\n-    public Address allocateFreeAddress(Host host, int vlan) throws OperationalException, Inet4ValueException {\n+    public Address allocateFreeAddress(Host host, List<Vlan> vlan) throws OperationalException, Inet4ValueException {\n         Inet4Network subnet;\n         try {\n             subnet = addressPool.allocate();\n         } catch (Inet4ValueException e) {\n             throw new OperationalException(\"Unable to allocate subnet for exam. There is no more addresses available.\");\n         }\n-        return assignAddress(host, new Address(subnet.address(1), subnet.getPrefix(), new Vlan(vlan)));\n+        return assignAddress(host, new Address(subnet.address(1), subnet.getPrefix(), vlan\n+//                Collections.singletonList(new Vlan(vlan))", "originalCommit": "053a2ad50ac0c14d702c1aef1df0cd232c98f23b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY4NTQzOQ==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r426685439", "bodyText": "my bad,\ndeleted", "author": "andriidovhan", "createdAt": "2020-05-18T14:53:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg3MzcxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg3NzIyMw==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r425877223", "bodyText": "I'd rather said 'vlanIds' instead of innerVlanIds, because you actually verify both", "author": "rtretyak", "createdAt": "2020-05-15T15:24:54Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/QinQFlowSpec.groovy", "diffHunk": "@@ -0,0 +1,888 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.functionaltests.extension.tags.Tag.TOPOLOGY_DEPENDENT\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.SwitchHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+class QinQFlowSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Unroll\n+    def \"System allows to manipulate with QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"Two switches connected to traffgen and enabled multiTable mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            } && it.paths.size() > 2\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a protected QinQ flow\"\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        flow.allocateProtectedPath = true\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"", "originalCommit": "053a2ad50ac0c14d702c1aef1df0cd232c98f23b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU5ODY3Mw==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r426598673", "bodyText": "fixed", "author": "andriidovhan", "createdAt": "2020-05-18T12:46:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg3NzIyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg3ODgxNw==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r425878817", "bodyText": "Is this whole block of rule verifications is really required and is it not fully covered with below traffic check? If yes, then move 'expectedSharedRulesDst' and 'expectedSharedRulesSrc' to the 'where' block", "author": "rtretyak", "createdAt": "2020-05-15T15:27:20Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/QinQFlowSpec.groovy", "diffHunk": "@@ -0,0 +1,888 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.functionaltests.extension.tags.Tag.TOPOLOGY_DEPENDENT\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.SwitchHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+class QinQFlowSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Unroll\n+    def \"System allows to manipulate with QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"Two switches connected to traffgen and enabled multiTable mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            } && it.paths.size() > 2\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a protected QinQ flow\"\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        flow.allocateProtectedPath = true\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        /** System doesn't allow to create a flow with innerVlan and without vlan at the same time.\n+         * for e.g.: when you create a flow with the following params:\n+         * vlan == 0 and innerVlan != 0,\n+         * then flow will be created with vlan != 0 and innerVlan == 0\n+         */\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Shared rule of flow is installed\"\n+        def srcSwSharedRulesAmount = northbound.getSwitchRules(swP.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        def dstSwSharedRulesAmount = northbound.getSwitchRules(swP.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        if (srcInnerVlanId > 0 || srcVlanId > 0) {\n+            assert srcSwSharedRulesAmount == 1\n+        } else {\n+            assert srcSwSharedRulesAmount == 0\n+        }\n+        if (dstInnerVlanId > 0 || dstVlanId > 0) {\n+            assert dstSwSharedRulesAmount == 1\n+        } else {\n+            assert dstSwSharedRulesAmount == 0\n+        }", "originalCommit": "053a2ad50ac0c14d702c1aef1df0cd232c98f23b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU5OTc4Mg==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r426599782", "bodyText": "To tell the truth I had mixed feelings about verifying this rule.\nThe block is deleted", "author": "andriidovhan", "createdAt": "2020-05-18T12:48:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg3ODgxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4MTE1Mw==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r425881153", "bodyText": "I don't follow. change to v2? It is already v2", "author": "rtretyak", "createdAt": "2020-05-15T15:31:13Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/QinQFlowSpec.groovy", "diffHunk": "@@ -0,0 +1,888 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.functionaltests.extension.tags.Tag.TOPOLOGY_DEPENDENT\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.SwitchHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+class QinQFlowSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Unroll\n+    def \"System allows to manipulate with QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"Two switches connected to traffgen and enabled multiTable mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            } && it.paths.size() > 2\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a protected QinQ flow\"\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        flow.allocateProtectedPath = true\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        /** System doesn't allow to create a flow with innerVlan and without vlan at the same time.\n+         * for e.g.: when you create a flow with the following params:\n+         * vlan == 0 and innerVlan != 0,\n+         * then flow will be created with vlan != 0 and innerVlan == 0\n+         */\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Shared rule of flow is installed\"\n+        def srcSwSharedRulesAmount = northbound.getSwitchRules(swP.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        def dstSwSharedRulesAmount = northbound.getSwitchRules(swP.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        if (srcInnerVlanId > 0 || srcVlanId > 0) {\n+            assert srcSwSharedRulesAmount == 1\n+        } else {\n+            assert srcSwSharedRulesAmount == 0\n+        }\n+        if (dstInnerVlanId > 0 || dstVlanId > 0) {\n+            assert dstSwSharedRulesAmount == 1\n+        } else {\n+            assert dstSwSharedRulesAmount == 0\n+        }\n+\n+        and: \"The flow allows traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def examQinQFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow1 = pathHelper.getInvolvedSwitches(\n+                pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        )\n+        involvedSwitchesFlow1.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        when: \"Create a flow without QinQ on the same port\"\n+        // it is not working with APIv1, flows are invalid; change to v2 when 3432 is merged", "originalCommit": "053a2ad50ac0c14d702c1aef1df0cd232c98f23b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjYwNjQ1MA==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r426606450", "bodyText": "it works fine via v2\nalso it should work fine via v1 when v1 is moved to h&s", "author": "andriidovhan", "createdAt": "2020-05-18T12:58:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4MTE1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4MzIxOA==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r425883218", "bodyText": "say sth about vlans, it is really crucial here", "author": "rtretyak", "createdAt": "2020-05-15T15:34:48Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/QinQFlowSpec.groovy", "diffHunk": "@@ -0,0 +1,888 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.functionaltests.extension.tags.Tag.TOPOLOGY_DEPENDENT\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.SwitchHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+class QinQFlowSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Unroll\n+    def \"System allows to manipulate with QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"Two switches connected to traffgen and enabled multiTable mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            } && it.paths.size() > 2\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a protected QinQ flow\"\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        flow.allocateProtectedPath = true\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        /** System doesn't allow to create a flow with innerVlan and without vlan at the same time.\n+         * for e.g.: when you create a flow with the following params:\n+         * vlan == 0 and innerVlan != 0,\n+         * then flow will be created with vlan != 0 and innerVlan == 0\n+         */\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Shared rule of flow is installed\"\n+        def srcSwSharedRulesAmount = northbound.getSwitchRules(swP.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        def dstSwSharedRulesAmount = northbound.getSwitchRules(swP.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        if (srcInnerVlanId > 0 || srcVlanId > 0) {\n+            assert srcSwSharedRulesAmount == 1\n+        } else {\n+            assert srcSwSharedRulesAmount == 0\n+        }\n+        if (dstInnerVlanId > 0 || dstVlanId > 0) {\n+            assert dstSwSharedRulesAmount == 1\n+        } else {\n+            assert dstSwSharedRulesAmount == 0\n+        }\n+\n+        and: \"The flow allows traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def examQinQFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow1 = pathHelper.getInvolvedSwitches(\n+                pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        )\n+        involvedSwitchesFlow1.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        when: \"Create a flow without QinQ on the same port\"", "originalCommit": "053a2ad50ac0c14d702c1aef1df0cd232c98f23b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjYwNjc3Nw==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r426606777", "bodyText": "fixed", "author": "andriidovhan", "createdAt": "2020-05-18T12:59:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4MzIxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4NDAxOA==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r425884018", "bodyText": "please be more specific, the update here is pretty unorthodox", "author": "rtretyak", "createdAt": "2020-05-15T15:36:04Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/QinQFlowSpec.groovy", "diffHunk": "@@ -0,0 +1,888 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.functionaltests.extension.tags.Tag.TOPOLOGY_DEPENDENT\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.SwitchHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+class QinQFlowSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Unroll\n+    def \"System allows to manipulate with QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"Two switches connected to traffgen and enabled multiTable mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            } && it.paths.size() > 2\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a protected QinQ flow\"\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        flow.allocateProtectedPath = true\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        /** System doesn't allow to create a flow with innerVlan and without vlan at the same time.\n+         * for e.g.: when you create a flow with the following params:\n+         * vlan == 0 and innerVlan != 0,\n+         * then flow will be created with vlan != 0 and innerVlan == 0\n+         */\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Shared rule of flow is installed\"\n+        def srcSwSharedRulesAmount = northbound.getSwitchRules(swP.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        def dstSwSharedRulesAmount = northbound.getSwitchRules(swP.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        if (srcInnerVlanId > 0 || srcVlanId > 0) {\n+            assert srcSwSharedRulesAmount == 1\n+        } else {\n+            assert srcSwSharedRulesAmount == 0\n+        }\n+        if (dstInnerVlanId > 0 || dstVlanId > 0) {\n+            assert dstSwSharedRulesAmount == 1\n+        } else {\n+            assert dstSwSharedRulesAmount == 0\n+        }\n+\n+        and: \"The flow allows traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def examQinQFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow1 = pathHelper.getInvolvedSwitches(\n+                pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        )\n+        involvedSwitchesFlow1.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        when: \"Create a flow without QinQ on the same port\"\n+        // it is not working with APIv1, flows are invalid; change to v2 when 3432 is merged\n+        def flow2 = flowHelperV2.randomFlow(swP).tap {\n+            it.source.portNumber = flow.source.portNumber\n+            it.source.vlanId = flow.source.vlanId + 1\n+            it.destination.portNumber = flow.destination.portNumber\n+            it.destination.vlanId = flow.destination.vlanId + 1\n+        }\n+        flowHelperV2.addFlow(flow2)\n+\n+        then: \"Both existing flows are valid\"\n+        [flow.flowId, flow2.flowId].each {\n+            northbound.validateFlow(it).each { assert it.asExpected }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow2 = pathHelper.getInvolvedSwitches(pathHelper.convert(northbound.getFlowPath(flow2.flowId)))\n+        def involvedSwitchesforBothFlows = (involvedSwitchesFlow1 + involvedSwitchesFlow2).unique { it.dpId }\n+        involvedSwitchesforBothFlows.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        and: \"Both flows are pingable\"\n+        [flow.flowId, flow2.flowId].each {\n+            verifyAll(northbound.pingFlow(it, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        then: \"Both flows allow traffic\"\n+        def examSimpleFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow2), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse, examSimpleFlow.forward, examSimpleFlow.reverse]\n+                    .eachParallel { direction ->\n+                        def resources = traffExam.startExam(direction)\n+                        direction.setResources(resources)\n+                        assert traffExam.waitExam(direction).hasTraffic()\n+                    }\n+        }\n+\n+        when: \"Update the QinQ flow\"", "originalCommit": "053a2ad50ac0c14d702c1aef1df0cd232c98f23b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjYxMTQ2Nw==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r426611467", "bodyText": "done(\"Update the QinQ flow(outer/inner vlans)\")", "author": "andriidovhan", "createdAt": "2020-05-18T13:06:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4NDAxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4NDg0OA==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r425884848", "bodyText": "please rename flow -> qnqflow, flow2 -> nonQnqFlow or sth similar", "author": "rtretyak", "createdAt": "2020-05-15T15:37:32Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/QinQFlowSpec.groovy", "diffHunk": "@@ -0,0 +1,888 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.functionaltests.extension.tags.Tag.TOPOLOGY_DEPENDENT\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.SwitchHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+class QinQFlowSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Unroll\n+    def \"System allows to manipulate with QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"Two switches connected to traffgen and enabled multiTable mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            } && it.paths.size() > 2\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a protected QinQ flow\"\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        flow.allocateProtectedPath = true\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        /** System doesn't allow to create a flow with innerVlan and without vlan at the same time.\n+         * for e.g.: when you create a flow with the following params:\n+         * vlan == 0 and innerVlan != 0,\n+         * then flow will be created with vlan != 0 and innerVlan == 0\n+         */\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Shared rule of flow is installed\"\n+        def srcSwSharedRulesAmount = northbound.getSwitchRules(swP.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        def dstSwSharedRulesAmount = northbound.getSwitchRules(swP.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        if (srcInnerVlanId > 0 || srcVlanId > 0) {\n+            assert srcSwSharedRulesAmount == 1\n+        } else {\n+            assert srcSwSharedRulesAmount == 0\n+        }\n+        if (dstInnerVlanId > 0 || dstVlanId > 0) {\n+            assert dstSwSharedRulesAmount == 1\n+        } else {\n+            assert dstSwSharedRulesAmount == 0\n+        }\n+\n+        and: \"The flow allows traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def examQinQFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow1 = pathHelper.getInvolvedSwitches(\n+                pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        )\n+        involvedSwitchesFlow1.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        when: \"Create a flow without QinQ on the same port\"\n+        // it is not working with APIv1, flows are invalid; change to v2 when 3432 is merged\n+        def flow2 = flowHelperV2.randomFlow(swP).tap {", "originalCommit": "053a2ad50ac0c14d702c1aef1df0cd232c98f23b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjYwNTgyMw==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r426605823", "bodyText": "agree, done\nflow -> qinqflow, flow2 -> vlanFlow", "author": "andriidovhan", "createdAt": "2020-05-18T12:57:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4NDg0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg5ODUzNA==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r425898534", "bodyText": "Nah. too many, we can't afford this for such a long-running scenario. While pairwising you should consider that src and dst for us are basically equal entities. I think it can be reduced to\n        srcVlanId | srcInnerVlanId | dstVlanId | dstInnerVlanId\n        0         | 1              | 1         | 0   \n       1          | 1              | 2        | 1\n\n1row: [noVlan,Vlan] tested on src, [vlan,noVlan] tested on dst, tested transition between src/dst outer: noVlan->Vlan, inner: vlan ->noVlan\n2row: [vlan,sameVlan] tested on src, [vlan,otherVlan] tested on dst, tested transition between src/dst outer: vlan->sameVlan, inner: vlan ->otherVlan\nWe can further debate on 0-0-0-0 and 1-1-1-1\nUpdate operation does not really update anything for them and actual cases are already covered, but I don't mind having one/both of these additional 2 iterations for the sake of traffic check, maybe as low_pro...or not have them, your call", "author": "rtretyak", "createdAt": "2020-05-15T16:00:38Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/QinQFlowSpec.groovy", "diffHunk": "@@ -0,0 +1,888 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.functionaltests.extension.tags.Tag.TOPOLOGY_DEPENDENT\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.SwitchHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+class QinQFlowSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Unroll\n+    def \"System allows to manipulate with QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"Two switches connected to traffgen and enabled multiTable mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            } && it.paths.size() > 2\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a protected QinQ flow\"\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        flow.allocateProtectedPath = true\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        /** System doesn't allow to create a flow with innerVlan and without vlan at the same time.\n+         * for e.g.: when you create a flow with the following params:\n+         * vlan == 0 and innerVlan != 0,\n+         * then flow will be created with vlan != 0 and innerVlan == 0\n+         */\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Shared rule of flow is installed\"\n+        def srcSwSharedRulesAmount = northbound.getSwitchRules(swP.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        def dstSwSharedRulesAmount = northbound.getSwitchRules(swP.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        if (srcInnerVlanId > 0 || srcVlanId > 0) {\n+            assert srcSwSharedRulesAmount == 1\n+        } else {\n+            assert srcSwSharedRulesAmount == 0\n+        }\n+        if (dstInnerVlanId > 0 || dstVlanId > 0) {\n+            assert dstSwSharedRulesAmount == 1\n+        } else {\n+            assert dstSwSharedRulesAmount == 0\n+        }\n+\n+        and: \"The flow allows traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def examQinQFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow1 = pathHelper.getInvolvedSwitches(\n+                pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        )\n+        involvedSwitchesFlow1.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        when: \"Create a flow without QinQ on the same port\"\n+        // it is not working with APIv1, flows are invalid; change to v2 when 3432 is merged\n+        def flow2 = flowHelperV2.randomFlow(swP).tap {\n+            it.source.portNumber = flow.source.portNumber\n+            it.source.vlanId = flow.source.vlanId + 1\n+            it.destination.portNumber = flow.destination.portNumber\n+            it.destination.vlanId = flow.destination.vlanId + 1\n+        }\n+        flowHelperV2.addFlow(flow2)\n+\n+        then: \"Both existing flows are valid\"\n+        [flow.flowId, flow2.flowId].each {\n+            northbound.validateFlow(it).each { assert it.asExpected }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow2 = pathHelper.getInvolvedSwitches(pathHelper.convert(northbound.getFlowPath(flow2.flowId)))\n+        def involvedSwitchesforBothFlows = (involvedSwitchesFlow1 + involvedSwitchesFlow2).unique { it.dpId }\n+        involvedSwitchesforBothFlows.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        and: \"Both flows are pingable\"\n+        [flow.flowId, flow2.flowId].each {\n+            verifyAll(northbound.pingFlow(it, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        then: \"Both flows allow traffic\"\n+        def examSimpleFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow2), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse, examSimpleFlow.forward, examSimpleFlow.reverse]\n+                    .eachParallel { direction ->\n+                        def resources = traffExam.startExam(direction)\n+                        direction.setResources(resources)\n+                        assert traffExam.waitExam(direction).hasTraffic()\n+                    }\n+        }\n+\n+        when: \"Update the QinQ flow\"\n+        def updateResponse = flowHelperV2.updateFlow(flow.flowId, flow.tap {\n+            flow.source.vlanId = flow2.source.vlanId\n+            flow.source.innerVlanId = flow2.destination.vlanId\n+            flow.destination.vlanId = flow2.destination.vlanId\n+            flow.destination.innerVlanId = flow2.source.vlanId\n+        })\n+\n+        then: \"Update response contains correct info about innerVlanIds\"\n+        with(updateResponse) {\n+            it.source.vlanId == flow2.source.vlanId\n+            it.source.innerVlanId == flow2.destination.vlanId\n+            it.destination.vlanId == flow2.destination.vlanId\n+            it.destination.innerVlanId == flow2.source.vlanId\n+        }\n+\n+        and: \"Flow is really updated\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == flow2.source.vlanId\n+            it.source.innerVlanId == flow2.destination.vlanId\n+            it.destination.vlanId == flow2.destination.vlanId\n+            it.destination.innerVlanId == flow2.source.vlanId\n+        }\n+\n+        then: \"Both existing flows are still valid and pingable\"\n+        [flow.flowId, flow2.flowId].each {\n+            northbound.validateFlow(it).each { assert it.asExpected }\n+        }\n+\n+        [flow.flowId, flow2.flowId].each {\n+            verifyAll(northbound.pingFlow(it, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        when: \"Delete the flows\"\n+        [flow.flowId, flow2.flowId].each { flowHelperV2.deleteFlow(it) }\n+\n+        then: \"Flows rules are deleted\"\n+        involvedSwitchesforBothFlows.each { sw ->\n+            Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+                assert northbound.getSwitchRules(sw.dpId).flowEntries*.cookie.sort() == sw.defaultCookies.sort()\n+            }\n+        }\n+\n+        and: \"Shared rule of flow is deleted\"\n+        [swP.src.dpId, swP.dst.dpId].each { swId ->\n+            assert northbound.getSwitchRules(swId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+            }.empty\n+        }\n+\n+        where:\n+        srcVlanId | srcInnerVlanId | dstVlanId | dstInnerVlanId\n+        0         | 0              | 0         | 0\n+        10        | 20             | 30        | 40\n+        10        | 10             | 10        | 10\n+        10        | 0              | 0         | 40\n+        0         | 20             | 30        | 0\n+        10        | 20             | 0         | 0\n+        0         | 0              | 30        | 40\n+        10        | 20             | 30        | 0\n+        0         | 20             | 30        | 40", "originalCommit": "053a2ad50ac0c14d702c1aef1df0cd232c98f23b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjYzNTkxMg==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r426635912", "bodyText": "this amount of test was requested by @surabujin\nreason: src/dst endpoints are processed by different part of code", "author": "andriidovhan", "createdAt": "2020-05-18T13:43:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg5ODUzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5MDc5Ng==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r426690796", "bodyText": "yes, it was me how have requested an \"extended\" set of VLAN cases. And yes, there are too many chances to mess with different flow directions in code. I can't insist on testing this on the func-tests level, but still, I would not recommend relying on the same behaviour for different flow sides.", "author": "surabujin", "createdAt": "2020-05-18T15:00:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg5ODUzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDM1NzA1Mg==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r430357052", "bodyText": "Let's do whatever set we need while the feature is in development, but I don't think we can afford dragging so many permutations to daily jobs. After we stabilize with testing qnq we should review this set or at least mark less valuable variations as low_prio. Otherwise, this only test will consume most of our execution time. Also, we can later consider moving most permutations to a lighter test which is not doing 2 updates + 3 traffexam sessions per each iteration", "author": "rtretyak", "createdAt": "2020-05-26T11:57:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg5ODUzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkxMzE0Nw==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r425913147", "bodyText": "same", "author": "rtretyak", "createdAt": "2020-05-15T16:26:32Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/QinQFlowSpec.groovy", "diffHunk": "@@ -0,0 +1,888 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.functionaltests.extension.tags.Tag.TOPOLOGY_DEPENDENT\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.SwitchHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+class QinQFlowSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Unroll\n+    def \"System allows to manipulate with QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"Two switches connected to traffgen and enabled multiTable mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            } && it.paths.size() > 2\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a protected QinQ flow\"\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        flow.allocateProtectedPath = true\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        /** System doesn't allow to create a flow with innerVlan and without vlan at the same time.\n+         * for e.g.: when you create a flow with the following params:\n+         * vlan == 0 and innerVlan != 0,\n+         * then flow will be created with vlan != 0 and innerVlan == 0\n+         */\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Shared rule of flow is installed\"\n+        def srcSwSharedRulesAmount = northbound.getSwitchRules(swP.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        def dstSwSharedRulesAmount = northbound.getSwitchRules(swP.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        if (srcInnerVlanId > 0 || srcVlanId > 0) {\n+            assert srcSwSharedRulesAmount == 1\n+        } else {\n+            assert srcSwSharedRulesAmount == 0\n+        }\n+        if (dstInnerVlanId > 0 || dstVlanId > 0) {\n+            assert dstSwSharedRulesAmount == 1\n+        } else {\n+            assert dstSwSharedRulesAmount == 0\n+        }\n+\n+        and: \"The flow allows traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def examQinQFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow1 = pathHelper.getInvolvedSwitches(\n+                pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        )\n+        involvedSwitchesFlow1.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        when: \"Create a flow without QinQ on the same port\"\n+        // it is not working with APIv1, flows are invalid; change to v2 when 3432 is merged\n+        def flow2 = flowHelperV2.randomFlow(swP).tap {\n+            it.source.portNumber = flow.source.portNumber\n+            it.source.vlanId = flow.source.vlanId + 1\n+            it.destination.portNumber = flow.destination.portNumber\n+            it.destination.vlanId = flow.destination.vlanId + 1\n+        }\n+        flowHelperV2.addFlow(flow2)\n+\n+        then: \"Both existing flows are valid\"\n+        [flow.flowId, flow2.flowId].each {\n+            northbound.validateFlow(it).each { assert it.asExpected }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow2 = pathHelper.getInvolvedSwitches(pathHelper.convert(northbound.getFlowPath(flow2.flowId)))\n+        def involvedSwitchesforBothFlows = (involvedSwitchesFlow1 + involvedSwitchesFlow2).unique { it.dpId }\n+        involvedSwitchesforBothFlows.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        and: \"Both flows are pingable\"\n+        [flow.flowId, flow2.flowId].each {\n+            verifyAll(northbound.pingFlow(it, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        then: \"Both flows allow traffic\"\n+        def examSimpleFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow2), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse, examSimpleFlow.forward, examSimpleFlow.reverse]\n+                    .eachParallel { direction ->\n+                        def resources = traffExam.startExam(direction)\n+                        direction.setResources(resources)\n+                        assert traffExam.waitExam(direction).hasTraffic()\n+                    }\n+        }\n+\n+        when: \"Update the QinQ flow\"\n+        def updateResponse = flowHelperV2.updateFlow(flow.flowId, flow.tap {\n+            flow.source.vlanId = flow2.source.vlanId\n+            flow.source.innerVlanId = flow2.destination.vlanId\n+            flow.destination.vlanId = flow2.destination.vlanId\n+            flow.destination.innerVlanId = flow2.source.vlanId\n+        })\n+\n+        then: \"Update response contains correct info about innerVlanIds\"\n+        with(updateResponse) {\n+            it.source.vlanId == flow2.source.vlanId\n+            it.source.innerVlanId == flow2.destination.vlanId\n+            it.destination.vlanId == flow2.destination.vlanId\n+            it.destination.innerVlanId == flow2.source.vlanId\n+        }\n+\n+        and: \"Flow is really updated\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == flow2.source.vlanId\n+            it.source.innerVlanId == flow2.destination.vlanId\n+            it.destination.vlanId == flow2.destination.vlanId\n+            it.destination.innerVlanId == flow2.source.vlanId\n+        }\n+\n+        then: \"Both existing flows are still valid and pingable\"\n+        [flow.flowId, flow2.flowId].each {\n+            northbound.validateFlow(it).each { assert it.asExpected }\n+        }\n+\n+        [flow.flowId, flow2.flowId].each {\n+            verifyAll(northbound.pingFlow(it, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        when: \"Delete the flows\"\n+        [flow.flowId, flow2.flowId].each { flowHelperV2.deleteFlow(it) }\n+\n+        then: \"Flows rules are deleted\"\n+        involvedSwitchesforBothFlows.each { sw ->\n+            Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+                assert northbound.getSwitchRules(sw.dpId).flowEntries*.cookie.sort() == sw.defaultCookies.sort()\n+            }\n+        }\n+\n+        and: \"Shared rule of flow is deleted\"\n+        [swP.src.dpId, swP.dst.dpId].each { swId ->\n+            assert northbound.getSwitchRules(swId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+            }.empty\n+        }\n+\n+        where:\n+        srcVlanId | srcInnerVlanId | dstVlanId | dstInnerVlanId\n+        0         | 0              | 0         | 0\n+        10        | 20             | 30        | 40\n+        10        | 10             | 10        | 10\n+        10        | 0              | 0         | 40\n+        0         | 20             | 30        | 0\n+        10        | 20             | 0         | 0\n+        0         | 0              | 30        | 40\n+        10        | 20             | 30        | 0\n+        0         | 20             | 30        | 40\n+    }\n+\n+    @Unroll\n+    def \"System allows to create a single switch QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"A switch with enabled multiTable mode\"\n+        def sw = topology.activeSwitches.find { northbound.getSwitchProperties(it.dpId).multiTable } ?:\n+                assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a single switch QinQ flow\"\n+        def flow = flowHelperV2.singleSwitchFlow(sw)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Shared rule of flow is installed\"\n+        def expectedAmoutOfSharedRule = 0\n+        if (srcInnerVlanId > 0 || srcVlanId > 0) {\n+            expectedAmoutOfSharedRule += 1\n+        }\n+        if (dstInnerVlanId > 0 || dstVlanId > 0) {\n+            expectedAmoutOfSharedRule += 1\n+        }\n+        northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size() == expectedAmoutOfSharedRule", "originalCommit": "053a2ad50ac0c14d702c1aef1df0cd232c98f23b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjYxNTE0OA==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r426615148", "bodyText": "this block is deleted", "author": "andriidovhan", "createdAt": "2020-05-18T13:12:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkxMzE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkxMzIzNA==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r425913234", "bodyText": "same", "author": "rtretyak", "createdAt": "2020-05-15T16:26:43Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/QinQFlowSpec.groovy", "diffHunk": "@@ -0,0 +1,888 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.functionaltests.extension.tags.Tag.TOPOLOGY_DEPENDENT\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.SwitchHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+class QinQFlowSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Unroll\n+    def \"System allows to manipulate with QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"Two switches connected to traffgen and enabled multiTable mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            } && it.paths.size() > 2\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a protected QinQ flow\"\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        flow.allocateProtectedPath = true\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        /** System doesn't allow to create a flow with innerVlan and without vlan at the same time.\n+         * for e.g.: when you create a flow with the following params:\n+         * vlan == 0 and innerVlan != 0,\n+         * then flow will be created with vlan != 0 and innerVlan == 0\n+         */\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Shared rule of flow is installed\"\n+        def srcSwSharedRulesAmount = northbound.getSwitchRules(swP.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        def dstSwSharedRulesAmount = northbound.getSwitchRules(swP.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        if (srcInnerVlanId > 0 || srcVlanId > 0) {\n+            assert srcSwSharedRulesAmount == 1\n+        } else {\n+            assert srcSwSharedRulesAmount == 0\n+        }\n+        if (dstInnerVlanId > 0 || dstVlanId > 0) {\n+            assert dstSwSharedRulesAmount == 1\n+        } else {\n+            assert dstSwSharedRulesAmount == 0\n+        }\n+\n+        and: \"The flow allows traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def examQinQFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow1 = pathHelper.getInvolvedSwitches(\n+                pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        )\n+        involvedSwitchesFlow1.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        when: \"Create a flow without QinQ on the same port\"\n+        // it is not working with APIv1, flows are invalid; change to v2 when 3432 is merged\n+        def flow2 = flowHelperV2.randomFlow(swP).tap {\n+            it.source.portNumber = flow.source.portNumber\n+            it.source.vlanId = flow.source.vlanId + 1\n+            it.destination.portNumber = flow.destination.portNumber\n+            it.destination.vlanId = flow.destination.vlanId + 1\n+        }\n+        flowHelperV2.addFlow(flow2)\n+\n+        then: \"Both existing flows are valid\"\n+        [flow.flowId, flow2.flowId].each {\n+            northbound.validateFlow(it).each { assert it.asExpected }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow2 = pathHelper.getInvolvedSwitches(pathHelper.convert(northbound.getFlowPath(flow2.flowId)))\n+        def involvedSwitchesforBothFlows = (involvedSwitchesFlow1 + involvedSwitchesFlow2).unique { it.dpId }\n+        involvedSwitchesforBothFlows.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        and: \"Both flows are pingable\"\n+        [flow.flowId, flow2.flowId].each {\n+            verifyAll(northbound.pingFlow(it, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        then: \"Both flows allow traffic\"\n+        def examSimpleFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow2), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse, examSimpleFlow.forward, examSimpleFlow.reverse]\n+                    .eachParallel { direction ->\n+                        def resources = traffExam.startExam(direction)\n+                        direction.setResources(resources)\n+                        assert traffExam.waitExam(direction).hasTraffic()\n+                    }\n+        }\n+\n+        when: \"Update the QinQ flow\"\n+        def updateResponse = flowHelperV2.updateFlow(flow.flowId, flow.tap {\n+            flow.source.vlanId = flow2.source.vlanId\n+            flow.source.innerVlanId = flow2.destination.vlanId\n+            flow.destination.vlanId = flow2.destination.vlanId\n+            flow.destination.innerVlanId = flow2.source.vlanId\n+        })\n+\n+        then: \"Update response contains correct info about innerVlanIds\"\n+        with(updateResponse) {\n+            it.source.vlanId == flow2.source.vlanId\n+            it.source.innerVlanId == flow2.destination.vlanId\n+            it.destination.vlanId == flow2.destination.vlanId\n+            it.destination.innerVlanId == flow2.source.vlanId\n+        }\n+\n+        and: \"Flow is really updated\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == flow2.source.vlanId\n+            it.source.innerVlanId == flow2.destination.vlanId\n+            it.destination.vlanId == flow2.destination.vlanId\n+            it.destination.innerVlanId == flow2.source.vlanId\n+        }\n+\n+        then: \"Both existing flows are still valid and pingable\"\n+        [flow.flowId, flow2.flowId].each {\n+            northbound.validateFlow(it).each { assert it.asExpected }\n+        }\n+\n+        [flow.flowId, flow2.flowId].each {\n+            verifyAll(northbound.pingFlow(it, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        when: \"Delete the flows\"\n+        [flow.flowId, flow2.flowId].each { flowHelperV2.deleteFlow(it) }\n+\n+        then: \"Flows rules are deleted\"\n+        involvedSwitchesforBothFlows.each { sw ->\n+            Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+                assert northbound.getSwitchRules(sw.dpId).flowEntries*.cookie.sort() == sw.defaultCookies.sort()\n+            }\n+        }\n+\n+        and: \"Shared rule of flow is deleted\"\n+        [swP.src.dpId, swP.dst.dpId].each { swId ->\n+            assert northbound.getSwitchRules(swId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+            }.empty\n+        }\n+\n+        where:\n+        srcVlanId | srcInnerVlanId | dstVlanId | dstInnerVlanId\n+        0         | 0              | 0         | 0\n+        10        | 20             | 30        | 40\n+        10        | 10             | 10        | 10\n+        10        | 0              | 0         | 40\n+        0         | 20             | 30        | 0\n+        10        | 20             | 0         | 0\n+        0         | 0              | 30        | 40\n+        10        | 20             | 30        | 0\n+        0         | 20             | 30        | 40\n+    }\n+\n+    @Unroll\n+    def \"System allows to create a single switch QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"A switch with enabled multiTable mode\"\n+        def sw = topology.activeSwitches.find { northbound.getSwitchProperties(it.dpId).multiTable } ?:\n+                assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a single switch QinQ flow\"\n+        def flow = flowHelperV2.singleSwitchFlow(sw)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Shared rule of flow is installed\"\n+        def expectedAmoutOfSharedRule = 0\n+        if (srcInnerVlanId > 0 || srcVlanId > 0) {\n+            expectedAmoutOfSharedRule += 1\n+        }\n+        if (dstInnerVlanId > 0 || dstVlanId > 0) {\n+            expectedAmoutOfSharedRule += 1\n+        }\n+        northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size() == expectedAmoutOfSharedRule\n+\n+        and: \"Involved switches pass switch validation\"\n+        with(pathHelper.getInvolvedSwitches(pathHelper.convert(northbound.getFlowPath(flow.flowId)))) {\n+            def validationInfo = northbound.validateSwitch(it.dpId)\n+            validationInfo.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            validationInfo.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        }\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+\n+        then: \"Flow rules are deleted\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+            assert northbound.getSwitchRules(sw.dpId).flowEntries*.cookie.sort() == sw.defaultCookies.sort()\n+        }\n+        northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.empty\n+\n+        where:\n+        srcVlanId | srcInnerVlanId | dstVlanId | dstInnerVlanId\n+        0         | 0              | 0         | 0\n+        10        | 20             | 30        | 40\n+        10        | 10             | 10        | 10\n+        10        | 0              | 0         | 40\n+        0         | 20             | 30        | 0\n+        10        | 20             | 0         | 0\n+        0         | 0              | 30        | 40\n+        10        | 20             | 30        | 0\n+        0         | 20             | 30        | 40", "originalCommit": "053a2ad50ac0c14d702c1aef1df0cd232c98f23b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkxNDEwNA==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r425914104", "bodyText": "it's tidy", "author": "rtretyak", "createdAt": "2020-05-15T16:28:11Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/QinQFlowSpec.groovy", "diffHunk": "@@ -0,0 +1,888 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.functionaltests.extension.tags.Tag.TOPOLOGY_DEPENDENT\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.SwitchHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+class QinQFlowSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Unroll\n+    def \"System allows to manipulate with QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"Two switches connected to traffgen and enabled multiTable mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            } && it.paths.size() > 2\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a protected QinQ flow\"\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        flow.allocateProtectedPath = true\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        /** System doesn't allow to create a flow with innerVlan and without vlan at the same time.\n+         * for e.g.: when you create a flow with the following params:\n+         * vlan == 0 and innerVlan != 0,\n+         * then flow will be created with vlan != 0 and innerVlan == 0\n+         */\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Shared rule of flow is installed\"\n+        def srcSwSharedRulesAmount = northbound.getSwitchRules(swP.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        def dstSwSharedRulesAmount = northbound.getSwitchRules(swP.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        if (srcInnerVlanId > 0 || srcVlanId > 0) {\n+            assert srcSwSharedRulesAmount == 1\n+        } else {\n+            assert srcSwSharedRulesAmount == 0\n+        }\n+        if (dstInnerVlanId > 0 || dstVlanId > 0) {\n+            assert dstSwSharedRulesAmount == 1\n+        } else {\n+            assert dstSwSharedRulesAmount == 0\n+        }\n+\n+        and: \"The flow allows traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def examQinQFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow1 = pathHelper.getInvolvedSwitches(\n+                pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        )\n+        involvedSwitchesFlow1.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        when: \"Create a flow without QinQ on the same port\"\n+        // it is not working with APIv1, flows are invalid; change to v2 when 3432 is merged\n+        def flow2 = flowHelperV2.randomFlow(swP).tap {\n+            it.source.portNumber = flow.source.portNumber\n+            it.source.vlanId = flow.source.vlanId + 1\n+            it.destination.portNumber = flow.destination.portNumber\n+            it.destination.vlanId = flow.destination.vlanId + 1\n+        }\n+        flowHelperV2.addFlow(flow2)\n+\n+        then: \"Both existing flows are valid\"\n+        [flow.flowId, flow2.flowId].each {\n+            northbound.validateFlow(it).each { assert it.asExpected }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow2 = pathHelper.getInvolvedSwitches(pathHelper.convert(northbound.getFlowPath(flow2.flowId)))\n+        def involvedSwitchesforBothFlows = (involvedSwitchesFlow1 + involvedSwitchesFlow2).unique { it.dpId }\n+        involvedSwitchesforBothFlows.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        and: \"Both flows are pingable\"\n+        [flow.flowId, flow2.flowId].each {\n+            verifyAll(northbound.pingFlow(it, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        then: \"Both flows allow traffic\"\n+        def examSimpleFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow2), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse, examSimpleFlow.forward, examSimpleFlow.reverse]\n+                    .eachParallel { direction ->\n+                        def resources = traffExam.startExam(direction)\n+                        direction.setResources(resources)\n+                        assert traffExam.waitExam(direction).hasTraffic()\n+                    }\n+        }\n+\n+        when: \"Update the QinQ flow\"\n+        def updateResponse = flowHelperV2.updateFlow(flow.flowId, flow.tap {\n+            flow.source.vlanId = flow2.source.vlanId\n+            flow.source.innerVlanId = flow2.destination.vlanId\n+            flow.destination.vlanId = flow2.destination.vlanId\n+            flow.destination.innerVlanId = flow2.source.vlanId\n+        })\n+\n+        then: \"Update response contains correct info about innerVlanIds\"\n+        with(updateResponse) {\n+            it.source.vlanId == flow2.source.vlanId\n+            it.source.innerVlanId == flow2.destination.vlanId\n+            it.destination.vlanId == flow2.destination.vlanId\n+            it.destination.innerVlanId == flow2.source.vlanId\n+        }\n+\n+        and: \"Flow is really updated\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == flow2.source.vlanId\n+            it.source.innerVlanId == flow2.destination.vlanId\n+            it.destination.vlanId == flow2.destination.vlanId\n+            it.destination.innerVlanId == flow2.source.vlanId\n+        }\n+\n+        then: \"Both existing flows are still valid and pingable\"\n+        [flow.flowId, flow2.flowId].each {\n+            northbound.validateFlow(it).each { assert it.asExpected }\n+        }\n+\n+        [flow.flowId, flow2.flowId].each {\n+            verifyAll(northbound.pingFlow(it, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        when: \"Delete the flows\"\n+        [flow.flowId, flow2.flowId].each { flowHelperV2.deleteFlow(it) }\n+\n+        then: \"Flows rules are deleted\"\n+        involvedSwitchesforBothFlows.each { sw ->\n+            Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+                assert northbound.getSwitchRules(sw.dpId).flowEntries*.cookie.sort() == sw.defaultCookies.sort()\n+            }\n+        }\n+\n+        and: \"Shared rule of flow is deleted\"\n+        [swP.src.dpId, swP.dst.dpId].each { swId ->\n+            assert northbound.getSwitchRules(swId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+            }.empty\n+        }\n+\n+        where:\n+        srcVlanId | srcInnerVlanId | dstVlanId | dstInnerVlanId\n+        0         | 0              | 0         | 0\n+        10        | 20             | 30        | 40\n+        10        | 10             | 10        | 10\n+        10        | 0              | 0         | 40\n+        0         | 20             | 30        | 0\n+        10        | 20             | 0         | 0\n+        0         | 0              | 30        | 40\n+        10        | 20             | 30        | 0\n+        0         | 20             | 30        | 40\n+    }\n+\n+    @Unroll\n+    def \"System allows to create a single switch QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"A switch with enabled multiTable mode\"\n+        def sw = topology.activeSwitches.find { northbound.getSwitchProperties(it.dpId).multiTable } ?:\n+                assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a single switch QinQ flow\"\n+        def flow = flowHelperV2.singleSwitchFlow(sw)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Shared rule of flow is installed\"\n+        def expectedAmoutOfSharedRule = 0\n+        if (srcInnerVlanId > 0 || srcVlanId > 0) {\n+            expectedAmoutOfSharedRule += 1\n+        }\n+        if (dstInnerVlanId > 0 || dstVlanId > 0) {\n+            expectedAmoutOfSharedRule += 1\n+        }\n+        northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size() == expectedAmoutOfSharedRule\n+\n+        and: \"Involved switches pass switch validation\"\n+        with(pathHelper.getInvolvedSwitches(pathHelper.convert(northbound.getFlowPath(flow.flowId)))) {\n+            def validationInfo = northbound.validateSwitch(it.dpId)\n+            validationInfo.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            validationInfo.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        }\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+\n+        then: \"Flow rules are deleted\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+            assert northbound.getSwitchRules(sw.dpId).flowEntries*.cookie.sort() == sw.defaultCookies.sort()\n+        }\n+        northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.empty\n+\n+        where:\n+        srcVlanId | srcInnerVlanId | dstVlanId | dstInnerVlanId\n+        0         | 0              | 0         | 0\n+        10        | 20             | 30        | 40\n+        10        | 10             | 10        | 10\n+        10        | 0              | 0         | 40\n+        0         | 20             | 30        | 0\n+        10        | 20             | 0         | 0\n+        0         | 0              | 30        | 40\n+        10        | 20             | 30        | 0\n+        0         | 20             | 30        | 40\n+    }\n+\n+    @Tags(TOPOLOGY_DEPENDENT)", "originalCommit": "053a2ad50ac0c14d702c1aef1df0cd232c98f23b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjYxNjQ4Nw==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r426616487", "bodyText": "fixed", "author": "andriidovhan", "createdAt": "2020-05-18T13:14:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkxNDEwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkxNDQ3NQ==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r425914475", "bodyText": "good", "author": "rtretyak", "createdAt": "2020-05-15T16:28:48Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/QinQFlowSpec.groovy", "diffHunk": "@@ -0,0 +1,888 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.functionaltests.extension.tags.Tag.TOPOLOGY_DEPENDENT\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.SwitchHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+class QinQFlowSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Unroll\n+    def \"System allows to manipulate with QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"Two switches connected to traffgen and enabled multiTable mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            } && it.paths.size() > 2\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a protected QinQ flow\"\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        flow.allocateProtectedPath = true\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        /** System doesn't allow to create a flow with innerVlan and without vlan at the same time.\n+         * for e.g.: when you create a flow with the following params:\n+         * vlan == 0 and innerVlan != 0,\n+         * then flow will be created with vlan != 0 and innerVlan == 0\n+         */\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Shared rule of flow is installed\"\n+        def srcSwSharedRulesAmount = northbound.getSwitchRules(swP.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        def dstSwSharedRulesAmount = northbound.getSwitchRules(swP.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        if (srcInnerVlanId > 0 || srcVlanId > 0) {\n+            assert srcSwSharedRulesAmount == 1\n+        } else {\n+            assert srcSwSharedRulesAmount == 0\n+        }\n+        if (dstInnerVlanId > 0 || dstVlanId > 0) {\n+            assert dstSwSharedRulesAmount == 1\n+        } else {\n+            assert dstSwSharedRulesAmount == 0\n+        }\n+\n+        and: \"The flow allows traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def examQinQFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow1 = pathHelper.getInvolvedSwitches(\n+                pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        )\n+        involvedSwitchesFlow1.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        when: \"Create a flow without QinQ on the same port\"\n+        // it is not working with APIv1, flows are invalid; change to v2 when 3432 is merged\n+        def flow2 = flowHelperV2.randomFlow(swP).tap {\n+            it.source.portNumber = flow.source.portNumber\n+            it.source.vlanId = flow.source.vlanId + 1\n+            it.destination.portNumber = flow.destination.portNumber\n+            it.destination.vlanId = flow.destination.vlanId + 1\n+        }\n+        flowHelperV2.addFlow(flow2)\n+\n+        then: \"Both existing flows are valid\"\n+        [flow.flowId, flow2.flowId].each {\n+            northbound.validateFlow(it).each { assert it.asExpected }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow2 = pathHelper.getInvolvedSwitches(pathHelper.convert(northbound.getFlowPath(flow2.flowId)))\n+        def involvedSwitchesforBothFlows = (involvedSwitchesFlow1 + involvedSwitchesFlow2).unique { it.dpId }\n+        involvedSwitchesforBothFlows.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        and: \"Both flows are pingable\"\n+        [flow.flowId, flow2.flowId].each {\n+            verifyAll(northbound.pingFlow(it, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        then: \"Both flows allow traffic\"\n+        def examSimpleFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow2), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse, examSimpleFlow.forward, examSimpleFlow.reverse]\n+                    .eachParallel { direction ->\n+                        def resources = traffExam.startExam(direction)\n+                        direction.setResources(resources)\n+                        assert traffExam.waitExam(direction).hasTraffic()\n+                    }\n+        }\n+\n+        when: \"Update the QinQ flow\"\n+        def updateResponse = flowHelperV2.updateFlow(flow.flowId, flow.tap {\n+            flow.source.vlanId = flow2.source.vlanId\n+            flow.source.innerVlanId = flow2.destination.vlanId\n+            flow.destination.vlanId = flow2.destination.vlanId\n+            flow.destination.innerVlanId = flow2.source.vlanId\n+        })\n+\n+        then: \"Update response contains correct info about innerVlanIds\"\n+        with(updateResponse) {\n+            it.source.vlanId == flow2.source.vlanId\n+            it.source.innerVlanId == flow2.destination.vlanId\n+            it.destination.vlanId == flow2.destination.vlanId\n+            it.destination.innerVlanId == flow2.source.vlanId\n+        }\n+\n+        and: \"Flow is really updated\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == flow2.source.vlanId\n+            it.source.innerVlanId == flow2.destination.vlanId\n+            it.destination.vlanId == flow2.destination.vlanId\n+            it.destination.innerVlanId == flow2.source.vlanId\n+        }\n+\n+        then: \"Both existing flows are still valid and pingable\"\n+        [flow.flowId, flow2.flowId].each {\n+            northbound.validateFlow(it).each { assert it.asExpected }\n+        }\n+\n+        [flow.flowId, flow2.flowId].each {\n+            verifyAll(northbound.pingFlow(it, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        when: \"Delete the flows\"\n+        [flow.flowId, flow2.flowId].each { flowHelperV2.deleteFlow(it) }\n+\n+        then: \"Flows rules are deleted\"\n+        involvedSwitchesforBothFlows.each { sw ->\n+            Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+                assert northbound.getSwitchRules(sw.dpId).flowEntries*.cookie.sort() == sw.defaultCookies.sort()\n+            }\n+        }\n+\n+        and: \"Shared rule of flow is deleted\"\n+        [swP.src.dpId, swP.dst.dpId].each { swId ->\n+            assert northbound.getSwitchRules(swId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+            }.empty\n+        }\n+\n+        where:\n+        srcVlanId | srcInnerVlanId | dstVlanId | dstInnerVlanId\n+        0         | 0              | 0         | 0\n+        10        | 20             | 30        | 40\n+        10        | 10             | 10        | 10\n+        10        | 0              | 0         | 40\n+        0         | 20             | 30        | 0\n+        10        | 20             | 0         | 0\n+        0         | 0              | 30        | 40\n+        10        | 20             | 30        | 0\n+        0         | 20             | 30        | 40\n+    }\n+\n+    @Unroll\n+    def \"System allows to create a single switch QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"A switch with enabled multiTable mode\"\n+        def sw = topology.activeSwitches.find { northbound.getSwitchProperties(it.dpId).multiTable } ?:\n+                assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a single switch QinQ flow\"\n+        def flow = flowHelperV2.singleSwitchFlow(sw)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Shared rule of flow is installed\"\n+        def expectedAmoutOfSharedRule = 0\n+        if (srcInnerVlanId > 0 || srcVlanId > 0) {\n+            expectedAmoutOfSharedRule += 1\n+        }\n+        if (dstInnerVlanId > 0 || dstVlanId > 0) {\n+            expectedAmoutOfSharedRule += 1\n+        }\n+        northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size() == expectedAmoutOfSharedRule\n+\n+        and: \"Involved switches pass switch validation\"\n+        with(pathHelper.getInvolvedSwitches(pathHelper.convert(northbound.getFlowPath(flow.flowId)))) {\n+            def validationInfo = northbound.validateSwitch(it.dpId)\n+            validationInfo.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            validationInfo.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        }\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+\n+        then: \"Flow rules are deleted\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+            assert northbound.getSwitchRules(sw.dpId).flowEntries*.cookie.sort() == sw.defaultCookies.sort()\n+        }\n+        northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.empty\n+\n+        where:\n+        srcVlanId | srcInnerVlanId | dstVlanId | dstInnerVlanId\n+        0         | 0              | 0         | 0\n+        10        | 20             | 30        | 40\n+        10        | 10             | 10        | 10\n+        10        | 0              | 0         | 40\n+        0         | 20             | 30        | 0\n+        10        | 20             | 0         | 0\n+        0         | 0              | 30        | 40\n+        10        | 20             | 30        | 0\n+        0         | 20             | 30        | 40\n+    }\n+\n+    @Tags(TOPOLOGY_DEPENDENT)\n+    def \"System doesn't allow to create a QinQ flow when a switch supports multi table mode but it is disabled\"() {\n+        given: \"A switch pair with disabled multi table mode at least on the one switch\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].any { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+        def initSrcSwProps = northbound.getSwitchProperties(swP.src.dpId)\n+        SwitchHelper.updateSwitchProperties(swP.src, initSrcSwProps.jacksonCopy().tap {\n+            it.multiTable = false\n+        })\n+        when: \"Try to create a QinQ flow when at least on switch doesn't support multi table mode\"\n+\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.innerVlanId = 4093\n+        flow.destination.innerVlanId = 3904\n+        northboundV2.addFlow(flow)\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        exc.responseBodyAsString.to(MessageError).errorMessage == \"Could not create flow\"\n+\n+        cleanup: \"Revert system to original state\"\n+        northbound.updateSwitchProperties(swP.src.dpId, initSrcSwProps)\n+        Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+            assert northbound.getSwitchRules(swP.src.dpId).flowEntries*.cookie.sort() == swP.src.defaultCookies.sort()\n+        }\n+        SwitchHelper.updateSwitchProperties(swP.src, initSrcSwProps)\n+    }\n+\n+    @Unroll\n+    def \"System doesn't allow to create a QinQ flow with incorrect innerVlanIds\\\n+(src:#srcInnerVlanId, dst:#dstInnerVlanId)\"() {\n+        when: \"Try to create a QinQ flow with incorrect innerVlanId\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        northboundV2.addFlow(flow)\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        exc.responseBodyAsString.to(MessageError).errorMessage == \"Invalid request payload\"\n+\n+        where:\n+        srcInnerVlanId | dstInnerVlanId\n+        4096           | 10\n+        10             | -1", "originalCommit": "053a2ad50ac0c14d702c1aef1df0cd232c98f23b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkyMDYwMg==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r425920602", "bodyText": "can be tidy", "author": "rtretyak", "createdAt": "2020-05-15T16:38:58Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/QinQFlowSpec.groovy", "diffHunk": "@@ -0,0 +1,888 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.functionaltests.extension.tags.Tag.TOPOLOGY_DEPENDENT\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.SwitchHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+class QinQFlowSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Unroll\n+    def \"System allows to manipulate with QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"Two switches connected to traffgen and enabled multiTable mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            } && it.paths.size() > 2\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a protected QinQ flow\"\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        flow.allocateProtectedPath = true\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        /** System doesn't allow to create a flow with innerVlan and without vlan at the same time.\n+         * for e.g.: when you create a flow with the following params:\n+         * vlan == 0 and innerVlan != 0,\n+         * then flow will be created with vlan != 0 and innerVlan == 0\n+         */\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Shared rule of flow is installed\"\n+        def srcSwSharedRulesAmount = northbound.getSwitchRules(swP.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        def dstSwSharedRulesAmount = northbound.getSwitchRules(swP.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        if (srcInnerVlanId > 0 || srcVlanId > 0) {\n+            assert srcSwSharedRulesAmount == 1\n+        } else {\n+            assert srcSwSharedRulesAmount == 0\n+        }\n+        if (dstInnerVlanId > 0 || dstVlanId > 0) {\n+            assert dstSwSharedRulesAmount == 1\n+        } else {\n+            assert dstSwSharedRulesAmount == 0\n+        }\n+\n+        and: \"The flow allows traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def examQinQFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow1 = pathHelper.getInvolvedSwitches(\n+                pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        )\n+        involvedSwitchesFlow1.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        when: \"Create a flow without QinQ on the same port\"\n+        // it is not working with APIv1, flows are invalid; change to v2 when 3432 is merged\n+        def flow2 = flowHelperV2.randomFlow(swP).tap {\n+            it.source.portNumber = flow.source.portNumber\n+            it.source.vlanId = flow.source.vlanId + 1\n+            it.destination.portNumber = flow.destination.portNumber\n+            it.destination.vlanId = flow.destination.vlanId + 1\n+        }\n+        flowHelperV2.addFlow(flow2)\n+\n+        then: \"Both existing flows are valid\"\n+        [flow.flowId, flow2.flowId].each {\n+            northbound.validateFlow(it).each { assert it.asExpected }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow2 = pathHelper.getInvolvedSwitches(pathHelper.convert(northbound.getFlowPath(flow2.flowId)))\n+        def involvedSwitchesforBothFlows = (involvedSwitchesFlow1 + involvedSwitchesFlow2).unique { it.dpId }\n+        involvedSwitchesforBothFlows.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        and: \"Both flows are pingable\"\n+        [flow.flowId, flow2.flowId].each {\n+            verifyAll(northbound.pingFlow(it, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        then: \"Both flows allow traffic\"\n+        def examSimpleFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow2), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse, examSimpleFlow.forward, examSimpleFlow.reverse]\n+                    .eachParallel { direction ->\n+                        def resources = traffExam.startExam(direction)\n+                        direction.setResources(resources)\n+                        assert traffExam.waitExam(direction).hasTraffic()\n+                    }\n+        }\n+\n+        when: \"Update the QinQ flow\"\n+        def updateResponse = flowHelperV2.updateFlow(flow.flowId, flow.tap {\n+            flow.source.vlanId = flow2.source.vlanId\n+            flow.source.innerVlanId = flow2.destination.vlanId\n+            flow.destination.vlanId = flow2.destination.vlanId\n+            flow.destination.innerVlanId = flow2.source.vlanId\n+        })\n+\n+        then: \"Update response contains correct info about innerVlanIds\"\n+        with(updateResponse) {\n+            it.source.vlanId == flow2.source.vlanId\n+            it.source.innerVlanId == flow2.destination.vlanId\n+            it.destination.vlanId == flow2.destination.vlanId\n+            it.destination.innerVlanId == flow2.source.vlanId\n+        }\n+\n+        and: \"Flow is really updated\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == flow2.source.vlanId\n+            it.source.innerVlanId == flow2.destination.vlanId\n+            it.destination.vlanId == flow2.destination.vlanId\n+            it.destination.innerVlanId == flow2.source.vlanId\n+        }\n+\n+        then: \"Both existing flows are still valid and pingable\"\n+        [flow.flowId, flow2.flowId].each {\n+            northbound.validateFlow(it).each { assert it.asExpected }\n+        }\n+\n+        [flow.flowId, flow2.flowId].each {\n+            verifyAll(northbound.pingFlow(it, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        when: \"Delete the flows\"\n+        [flow.flowId, flow2.flowId].each { flowHelperV2.deleteFlow(it) }\n+\n+        then: \"Flows rules are deleted\"\n+        involvedSwitchesforBothFlows.each { sw ->\n+            Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+                assert northbound.getSwitchRules(sw.dpId).flowEntries*.cookie.sort() == sw.defaultCookies.sort()\n+            }\n+        }\n+\n+        and: \"Shared rule of flow is deleted\"\n+        [swP.src.dpId, swP.dst.dpId].each { swId ->\n+            assert northbound.getSwitchRules(swId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+            }.empty\n+        }\n+\n+        where:\n+        srcVlanId | srcInnerVlanId | dstVlanId | dstInnerVlanId\n+        0         | 0              | 0         | 0\n+        10        | 20             | 30        | 40\n+        10        | 10             | 10        | 10\n+        10        | 0              | 0         | 40\n+        0         | 20             | 30        | 0\n+        10        | 20             | 0         | 0\n+        0         | 0              | 30        | 40\n+        10        | 20             | 30        | 0\n+        0         | 20             | 30        | 40\n+    }\n+\n+    @Unroll\n+    def \"System allows to create a single switch QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"A switch with enabled multiTable mode\"\n+        def sw = topology.activeSwitches.find { northbound.getSwitchProperties(it.dpId).multiTable } ?:\n+                assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a single switch QinQ flow\"\n+        def flow = flowHelperV2.singleSwitchFlow(sw)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Shared rule of flow is installed\"\n+        def expectedAmoutOfSharedRule = 0\n+        if (srcInnerVlanId > 0 || srcVlanId > 0) {\n+            expectedAmoutOfSharedRule += 1\n+        }\n+        if (dstInnerVlanId > 0 || dstVlanId > 0) {\n+            expectedAmoutOfSharedRule += 1\n+        }\n+        northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size() == expectedAmoutOfSharedRule\n+\n+        and: \"Involved switches pass switch validation\"\n+        with(pathHelper.getInvolvedSwitches(pathHelper.convert(northbound.getFlowPath(flow.flowId)))) {\n+            def validationInfo = northbound.validateSwitch(it.dpId)\n+            validationInfo.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            validationInfo.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        }\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+\n+        then: \"Flow rules are deleted\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+            assert northbound.getSwitchRules(sw.dpId).flowEntries*.cookie.sort() == sw.defaultCookies.sort()\n+        }\n+        northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.empty\n+\n+        where:\n+        srcVlanId | srcInnerVlanId | dstVlanId | dstInnerVlanId\n+        0         | 0              | 0         | 0\n+        10        | 20             | 30        | 40\n+        10        | 10             | 10        | 10\n+        10        | 0              | 0         | 40\n+        0         | 20             | 30        | 0\n+        10        | 20             | 0         | 0\n+        0         | 0              | 30        | 40\n+        10        | 20             | 30        | 0\n+        0         | 20             | 30        | 40\n+    }\n+\n+    @Tags(TOPOLOGY_DEPENDENT)\n+    def \"System doesn't allow to create a QinQ flow when a switch supports multi table mode but it is disabled\"() {\n+        given: \"A switch pair with disabled multi table mode at least on the one switch\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].any { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+        def initSrcSwProps = northbound.getSwitchProperties(swP.src.dpId)\n+        SwitchHelper.updateSwitchProperties(swP.src, initSrcSwProps.jacksonCopy().tap {\n+            it.multiTable = false\n+        })\n+        when: \"Try to create a QinQ flow when at least on switch doesn't support multi table mode\"\n+\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.innerVlanId = 4093\n+        flow.destination.innerVlanId = 3904\n+        northboundV2.addFlow(flow)\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        exc.responseBodyAsString.to(MessageError).errorMessage == \"Could not create flow\"\n+\n+        cleanup: \"Revert system to original state\"\n+        northbound.updateSwitchProperties(swP.src.dpId, initSrcSwProps)\n+        Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+            assert northbound.getSwitchRules(swP.src.dpId).flowEntries*.cookie.sort() == swP.src.defaultCookies.sort()\n+        }\n+        SwitchHelper.updateSwitchProperties(swP.src, initSrcSwProps)\n+    }\n+\n+    @Unroll\n+    def \"System doesn't allow to create a QinQ flow with incorrect innerVlanIds\\\n+(src:#srcInnerVlanId, dst:#dstInnerVlanId)\"() {\n+        when: \"Try to create a QinQ flow with incorrect innerVlanId\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        northboundV2.addFlow(flow)\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        exc.responseBodyAsString.to(MessageError).errorMessage == \"Invalid request payload\"\n+\n+        where:\n+        srcInnerVlanId | dstInnerVlanId\n+        4096           | 10\n+        10             | -1\n+    }\n+\n+    @Ignore(\"wait 3432\")\n+    def \"System doesn't allow to create a QinQ flow via APIv1\"() {\n+        given: \"Two switches with enabled multi table mode\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a QinQ flow via APIv1\"\n+        def flowV1 = flowHelper.randomFlow(swP)\n+        flowV1.source.innerVlanId = 100\n+        flowV1.destination.innerVlanId = 200\n+        northbound.addFlow(flowV1)\n+\n+        then: \"Human readable error is returned\"\n+        def eCreate = thrown(HttpClientErrorException)\n+        eCreate.statusCode == HttpStatus.BAD_REQUEST\n+        eCreate.responseBodyAsString.to(MessageError).errorMessage.contains(\"Could not create flow\")\n+    }\n+\n+    @Ignore\n+    def \"System doesn't allow to update/delete a QinQ flow via APIv1\"() {\n+        given: \"Two switches with enabled multi table mode\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a QinQ flow via APIv2\"\n+        def flowV2 = flowHelperV2.randomFlow(swP)\n+        flowV2.source.innerVlanId = 234\n+        flowV2.destination.innerVlanId = 432\n+        northboundV2.addFlow(flowV2)\n+\n+        and: \"Try to update the flow via APIv1\"\n+        flowHelperV2.updateFlow(flowV2.flowId, flowV2.tap { flowV2.source.innerVlanId += 1 })\n+\n+        then: \"Human readable error is returned\"\n+        def eUpdate = thrown(HttpClientErrorException)\n+        eUpdate.statusCode == HttpStatus.BAD_REQUEST\n+        eUpdate.responseBodyAsString.to(MessageError).errorMessage.contains(\"Could not update flow\")\n+\n+        when: \"Try to delete the flow via APIv1\"\n+        northbound.deleteFlow(flowV2.flowId)\n+\n+        then: \"Human readable error is returned\"\n+        def eDelete = thrown(HttpClientErrorException)\n+        eDelete.statusCode == HttpStatus.BAD_REQUEST\n+        eDelete.responseBodyAsString.to(MessageError).errorMessage.contains(\"Could not delete flow\")\n+\n+        cleanup:\n+        flowV2 && flowHelperV2.deleteFlow(flowV2.flowId)\n+    }\n+\n+    def \"System allows to create QinQ flow and flow without QnQ with the same vlan on the same port\"() {\n+        given: \"Two switches with enabled multi table mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a QinQ flow\"\n+        def flowWithQinQ = flowHelperV2.randomFlow(swP)\n+        flowWithQinQ.source.innerVlanId = 234\n+        flowWithQinQ.destination.innerVlanId = 432\n+        flowHelperV2.addFlow(flowWithQinQ)\n+\n+        and: \"Create a flow without QinQ\"\n+        def flowWithoutQinQ = flowHelperV2.randomFlow(swP)\n+        flowWithoutQinQ.source.vlanId = 0\n+        flowWithoutQinQ.source.innerVlanId = flowWithQinQ.source.vlanId\n+        flowHelperV2.addFlow(flowWithoutQinQ)\n+\n+        then: \"Both flows allow traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def examFlowWithtQinQ = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flowWithQinQ), 1000, 5)\n+        def examFlowWithoutQinQ = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flowWithoutQinQ), 1000, 5)\n+        withPool {\n+            [examFlowWithtQinQ.forward, examFlowWithtQinQ.reverse,\n+             examFlowWithoutQinQ.forward, examFlowWithoutQinQ.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Revert system to original state\"\n+        [flowWithQinQ, flowWithoutQinQ].each { flowHelperV2.deleteFlow(it.flowId) }", "originalCommit": "053a2ad50ac0c14d702c1aef1df0cd232c98f23b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjYxOTQ3Nw==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r426619477", "bodyText": "done", "author": "andriidovhan", "createdAt": "2020-05-18T13:19:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkyMDYwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkyMTQyNQ==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r425921425", "bodyText": "please be more specific", "author": "rtretyak", "createdAt": "2020-05-15T16:40:38Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/QinQFlowSpec.groovy", "diffHunk": "@@ -0,0 +1,888 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.functionaltests.extension.tags.Tag.TOPOLOGY_DEPENDENT\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.SwitchHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+class QinQFlowSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Unroll\n+    def \"System allows to manipulate with QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"Two switches connected to traffgen and enabled multiTable mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            } && it.paths.size() > 2\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a protected QinQ flow\"\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        flow.allocateProtectedPath = true\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        /** System doesn't allow to create a flow with innerVlan and without vlan at the same time.\n+         * for e.g.: when you create a flow with the following params:\n+         * vlan == 0 and innerVlan != 0,\n+         * then flow will be created with vlan != 0 and innerVlan == 0\n+         */\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Shared rule of flow is installed\"\n+        def srcSwSharedRulesAmount = northbound.getSwitchRules(swP.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        def dstSwSharedRulesAmount = northbound.getSwitchRules(swP.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        if (srcInnerVlanId > 0 || srcVlanId > 0) {\n+            assert srcSwSharedRulesAmount == 1\n+        } else {\n+            assert srcSwSharedRulesAmount == 0\n+        }\n+        if (dstInnerVlanId > 0 || dstVlanId > 0) {\n+            assert dstSwSharedRulesAmount == 1\n+        } else {\n+            assert dstSwSharedRulesAmount == 0\n+        }\n+\n+        and: \"The flow allows traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def examQinQFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow1 = pathHelper.getInvolvedSwitches(\n+                pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        )\n+        involvedSwitchesFlow1.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        when: \"Create a flow without QinQ on the same port\"\n+        // it is not working with APIv1, flows are invalid; change to v2 when 3432 is merged\n+        def flow2 = flowHelperV2.randomFlow(swP).tap {\n+            it.source.portNumber = flow.source.portNumber\n+            it.source.vlanId = flow.source.vlanId + 1\n+            it.destination.portNumber = flow.destination.portNumber\n+            it.destination.vlanId = flow.destination.vlanId + 1\n+        }\n+        flowHelperV2.addFlow(flow2)\n+\n+        then: \"Both existing flows are valid\"\n+        [flow.flowId, flow2.flowId].each {\n+            northbound.validateFlow(it).each { assert it.asExpected }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow2 = pathHelper.getInvolvedSwitches(pathHelper.convert(northbound.getFlowPath(flow2.flowId)))\n+        def involvedSwitchesforBothFlows = (involvedSwitchesFlow1 + involvedSwitchesFlow2).unique { it.dpId }\n+        involvedSwitchesforBothFlows.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        and: \"Both flows are pingable\"\n+        [flow.flowId, flow2.flowId].each {\n+            verifyAll(northbound.pingFlow(it, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        then: \"Both flows allow traffic\"\n+        def examSimpleFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow2), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse, examSimpleFlow.forward, examSimpleFlow.reverse]\n+                    .eachParallel { direction ->\n+                        def resources = traffExam.startExam(direction)\n+                        direction.setResources(resources)\n+                        assert traffExam.waitExam(direction).hasTraffic()\n+                    }\n+        }\n+\n+        when: \"Update the QinQ flow\"\n+        def updateResponse = flowHelperV2.updateFlow(flow.flowId, flow.tap {\n+            flow.source.vlanId = flow2.source.vlanId\n+            flow.source.innerVlanId = flow2.destination.vlanId\n+            flow.destination.vlanId = flow2.destination.vlanId\n+            flow.destination.innerVlanId = flow2.source.vlanId\n+        })\n+\n+        then: \"Update response contains correct info about innerVlanIds\"\n+        with(updateResponse) {\n+            it.source.vlanId == flow2.source.vlanId\n+            it.source.innerVlanId == flow2.destination.vlanId\n+            it.destination.vlanId == flow2.destination.vlanId\n+            it.destination.innerVlanId == flow2.source.vlanId\n+        }\n+\n+        and: \"Flow is really updated\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == flow2.source.vlanId\n+            it.source.innerVlanId == flow2.destination.vlanId\n+            it.destination.vlanId == flow2.destination.vlanId\n+            it.destination.innerVlanId == flow2.source.vlanId\n+        }\n+\n+        then: \"Both existing flows are still valid and pingable\"\n+        [flow.flowId, flow2.flowId].each {\n+            northbound.validateFlow(it).each { assert it.asExpected }\n+        }\n+\n+        [flow.flowId, flow2.flowId].each {\n+            verifyAll(northbound.pingFlow(it, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        when: \"Delete the flows\"\n+        [flow.flowId, flow2.flowId].each { flowHelperV2.deleteFlow(it) }\n+\n+        then: \"Flows rules are deleted\"\n+        involvedSwitchesforBothFlows.each { sw ->\n+            Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+                assert northbound.getSwitchRules(sw.dpId).flowEntries*.cookie.sort() == sw.defaultCookies.sort()\n+            }\n+        }\n+\n+        and: \"Shared rule of flow is deleted\"\n+        [swP.src.dpId, swP.dst.dpId].each { swId ->\n+            assert northbound.getSwitchRules(swId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+            }.empty\n+        }\n+\n+        where:\n+        srcVlanId | srcInnerVlanId | dstVlanId | dstInnerVlanId\n+        0         | 0              | 0         | 0\n+        10        | 20             | 30        | 40\n+        10        | 10             | 10        | 10\n+        10        | 0              | 0         | 40\n+        0         | 20             | 30        | 0\n+        10        | 20             | 0         | 0\n+        0         | 0              | 30        | 40\n+        10        | 20             | 30        | 0\n+        0         | 20             | 30        | 40\n+    }\n+\n+    @Unroll\n+    def \"System allows to create a single switch QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"A switch with enabled multiTable mode\"\n+        def sw = topology.activeSwitches.find { northbound.getSwitchProperties(it.dpId).multiTable } ?:\n+                assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a single switch QinQ flow\"\n+        def flow = flowHelperV2.singleSwitchFlow(sw)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Shared rule of flow is installed\"\n+        def expectedAmoutOfSharedRule = 0\n+        if (srcInnerVlanId > 0 || srcVlanId > 0) {\n+            expectedAmoutOfSharedRule += 1\n+        }\n+        if (dstInnerVlanId > 0 || dstVlanId > 0) {\n+            expectedAmoutOfSharedRule += 1\n+        }\n+        northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size() == expectedAmoutOfSharedRule\n+\n+        and: \"Involved switches pass switch validation\"\n+        with(pathHelper.getInvolvedSwitches(pathHelper.convert(northbound.getFlowPath(flow.flowId)))) {\n+            def validationInfo = northbound.validateSwitch(it.dpId)\n+            validationInfo.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            validationInfo.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        }\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+\n+        then: \"Flow rules are deleted\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+            assert northbound.getSwitchRules(sw.dpId).flowEntries*.cookie.sort() == sw.defaultCookies.sort()\n+        }\n+        northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.empty\n+\n+        where:\n+        srcVlanId | srcInnerVlanId | dstVlanId | dstInnerVlanId\n+        0         | 0              | 0         | 0\n+        10        | 20             | 30        | 40\n+        10        | 10             | 10        | 10\n+        10        | 0              | 0         | 40\n+        0         | 20             | 30        | 0\n+        10        | 20             | 0         | 0\n+        0         | 0              | 30        | 40\n+        10        | 20             | 30        | 0\n+        0         | 20             | 30        | 40\n+    }\n+\n+    @Tags(TOPOLOGY_DEPENDENT)\n+    def \"System doesn't allow to create a QinQ flow when a switch supports multi table mode but it is disabled\"() {\n+        given: \"A switch pair with disabled multi table mode at least on the one switch\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].any { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+        def initSrcSwProps = northbound.getSwitchProperties(swP.src.dpId)\n+        SwitchHelper.updateSwitchProperties(swP.src, initSrcSwProps.jacksonCopy().tap {\n+            it.multiTable = false\n+        })\n+        when: \"Try to create a QinQ flow when at least on switch doesn't support multi table mode\"\n+\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.innerVlanId = 4093\n+        flow.destination.innerVlanId = 3904\n+        northboundV2.addFlow(flow)\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        exc.responseBodyAsString.to(MessageError).errorMessage == \"Could not create flow\"\n+\n+        cleanup: \"Revert system to original state\"\n+        northbound.updateSwitchProperties(swP.src.dpId, initSrcSwProps)\n+        Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+            assert northbound.getSwitchRules(swP.src.dpId).flowEntries*.cookie.sort() == swP.src.defaultCookies.sort()\n+        }\n+        SwitchHelper.updateSwitchProperties(swP.src, initSrcSwProps)\n+    }\n+\n+    @Unroll\n+    def \"System doesn't allow to create a QinQ flow with incorrect innerVlanIds\\\n+(src:#srcInnerVlanId, dst:#dstInnerVlanId)\"() {\n+        when: \"Try to create a QinQ flow with incorrect innerVlanId\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        northboundV2.addFlow(flow)\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        exc.responseBodyAsString.to(MessageError).errorMessage == \"Invalid request payload\"\n+\n+        where:\n+        srcInnerVlanId | dstInnerVlanId\n+        4096           | 10\n+        10             | -1\n+    }\n+\n+    @Ignore(\"wait 3432\")\n+    def \"System doesn't allow to create a QinQ flow via APIv1\"() {\n+        given: \"Two switches with enabled multi table mode\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a QinQ flow via APIv1\"\n+        def flowV1 = flowHelper.randomFlow(swP)\n+        flowV1.source.innerVlanId = 100\n+        flowV1.destination.innerVlanId = 200\n+        northbound.addFlow(flowV1)\n+\n+        then: \"Human readable error is returned\"\n+        def eCreate = thrown(HttpClientErrorException)\n+        eCreate.statusCode == HttpStatus.BAD_REQUEST\n+        eCreate.responseBodyAsString.to(MessageError).errorMessage.contains(\"Could not create flow\")\n+    }\n+\n+    @Ignore\n+    def \"System doesn't allow to update/delete a QinQ flow via APIv1\"() {\n+        given: \"Two switches with enabled multi table mode\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a QinQ flow via APIv2\"\n+        def flowV2 = flowHelperV2.randomFlow(swP)\n+        flowV2.source.innerVlanId = 234\n+        flowV2.destination.innerVlanId = 432\n+        northboundV2.addFlow(flowV2)\n+\n+        and: \"Try to update the flow via APIv1\"\n+        flowHelperV2.updateFlow(flowV2.flowId, flowV2.tap { flowV2.source.innerVlanId += 1 })\n+\n+        then: \"Human readable error is returned\"\n+        def eUpdate = thrown(HttpClientErrorException)\n+        eUpdate.statusCode == HttpStatus.BAD_REQUEST\n+        eUpdate.responseBodyAsString.to(MessageError).errorMessage.contains(\"Could not update flow\")\n+\n+        when: \"Try to delete the flow via APIv1\"\n+        northbound.deleteFlow(flowV2.flowId)\n+\n+        then: \"Human readable error is returned\"\n+        def eDelete = thrown(HttpClientErrorException)\n+        eDelete.statusCode == HttpStatus.BAD_REQUEST\n+        eDelete.responseBodyAsString.to(MessageError).errorMessage.contains(\"Could not delete flow\")\n+\n+        cleanup:\n+        flowV2 && flowHelperV2.deleteFlow(flowV2.flowId)\n+    }\n+\n+    def \"System allows to create QinQ flow and flow without QnQ with the same vlan on the same port\"() {\n+        given: \"Two switches with enabled multi table mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a QinQ flow\"\n+        def flowWithQinQ = flowHelperV2.randomFlow(swP)\n+        flowWithQinQ.source.innerVlanId = 234\n+        flowWithQinQ.destination.innerVlanId = 432\n+        flowHelperV2.addFlow(flowWithQinQ)\n+\n+        and: \"Create a flow without QinQ\"\n+        def flowWithoutQinQ = flowHelperV2.randomFlow(swP)\n+        flowWithoutQinQ.source.vlanId = 0\n+        flowWithoutQinQ.source.innerVlanId = flowWithQinQ.source.vlanId\n+        flowHelperV2.addFlow(flowWithoutQinQ)\n+\n+        then: \"Both flows allow traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def examFlowWithtQinQ = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flowWithQinQ), 1000, 5)\n+        def examFlowWithoutQinQ = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flowWithoutQinQ), 1000, 5)\n+        withPool {\n+            [examFlowWithtQinQ.forward, examFlowWithtQinQ.reverse,\n+             examFlowWithoutQinQ.forward, examFlowWithoutQinQ.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Revert system to original state\"\n+        [flowWithQinQ, flowWithoutQinQ].each { flowHelperV2.deleteFlow(it.flowId) }\n+    }\n+\n+    def \"System detects conflict QinQ flows\"() {\n+        given: \"Two switches with enabled multi table mode\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a first flow\"\n+        def flow1 = flowHelperV2.randomFlow(swP)\n+        flow1.source.vlanId = 10\n+        flow1.source.innerVlanId = 0\n+        flowHelperV2.addFlow(flow1)\n+\n+        and: \"Try to create a conflict flow\"", "originalCommit": "053a2ad50ac0c14d702c1aef1df0cd232c98f23b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjYzMjA1NQ==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r426632055", "bodyText": "done", "author": "andriidovhan", "createdAt": "2020-05-18T13:38:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkyMTQyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkyMzIyMQ==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r425923221", "bodyText": "Well both flows in this test are actually non-qinq..And laconic test/step descriptions make it even more difficult to understand", "author": "rtretyak", "createdAt": "2020-05-15T16:43:49Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/QinQFlowSpec.groovy", "diffHunk": "@@ -0,0 +1,888 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.functionaltests.extension.tags.Tag.TOPOLOGY_DEPENDENT\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.SwitchHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+class QinQFlowSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Unroll\n+    def \"System allows to manipulate with QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"Two switches connected to traffgen and enabled multiTable mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            } && it.paths.size() > 2\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a protected QinQ flow\"\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        flow.allocateProtectedPath = true\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        /** System doesn't allow to create a flow with innerVlan and without vlan at the same time.\n+         * for e.g.: when you create a flow with the following params:\n+         * vlan == 0 and innerVlan != 0,\n+         * then flow will be created with vlan != 0 and innerVlan == 0\n+         */\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Shared rule of flow is installed\"\n+        def srcSwSharedRulesAmount = northbound.getSwitchRules(swP.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        def dstSwSharedRulesAmount = northbound.getSwitchRules(swP.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        if (srcInnerVlanId > 0 || srcVlanId > 0) {\n+            assert srcSwSharedRulesAmount == 1\n+        } else {\n+            assert srcSwSharedRulesAmount == 0\n+        }\n+        if (dstInnerVlanId > 0 || dstVlanId > 0) {\n+            assert dstSwSharedRulesAmount == 1\n+        } else {\n+            assert dstSwSharedRulesAmount == 0\n+        }\n+\n+        and: \"The flow allows traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def examQinQFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow1 = pathHelper.getInvolvedSwitches(\n+                pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        )\n+        involvedSwitchesFlow1.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        when: \"Create a flow without QinQ on the same port\"\n+        // it is not working with APIv1, flows are invalid; change to v2 when 3432 is merged\n+        def flow2 = flowHelperV2.randomFlow(swP).tap {\n+            it.source.portNumber = flow.source.portNumber\n+            it.source.vlanId = flow.source.vlanId + 1\n+            it.destination.portNumber = flow.destination.portNumber\n+            it.destination.vlanId = flow.destination.vlanId + 1\n+        }\n+        flowHelperV2.addFlow(flow2)\n+\n+        then: \"Both existing flows are valid\"\n+        [flow.flowId, flow2.flowId].each {\n+            northbound.validateFlow(it).each { assert it.asExpected }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow2 = pathHelper.getInvolvedSwitches(pathHelper.convert(northbound.getFlowPath(flow2.flowId)))\n+        def involvedSwitchesforBothFlows = (involvedSwitchesFlow1 + involvedSwitchesFlow2).unique { it.dpId }\n+        involvedSwitchesforBothFlows.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        and: \"Both flows are pingable\"\n+        [flow.flowId, flow2.flowId].each {\n+            verifyAll(northbound.pingFlow(it, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        then: \"Both flows allow traffic\"\n+        def examSimpleFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow2), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse, examSimpleFlow.forward, examSimpleFlow.reverse]\n+                    .eachParallel { direction ->\n+                        def resources = traffExam.startExam(direction)\n+                        direction.setResources(resources)\n+                        assert traffExam.waitExam(direction).hasTraffic()\n+                    }\n+        }\n+\n+        when: \"Update the QinQ flow\"\n+        def updateResponse = flowHelperV2.updateFlow(flow.flowId, flow.tap {\n+            flow.source.vlanId = flow2.source.vlanId\n+            flow.source.innerVlanId = flow2.destination.vlanId\n+            flow.destination.vlanId = flow2.destination.vlanId\n+            flow.destination.innerVlanId = flow2.source.vlanId\n+        })\n+\n+        then: \"Update response contains correct info about innerVlanIds\"\n+        with(updateResponse) {\n+            it.source.vlanId == flow2.source.vlanId\n+            it.source.innerVlanId == flow2.destination.vlanId\n+            it.destination.vlanId == flow2.destination.vlanId\n+            it.destination.innerVlanId == flow2.source.vlanId\n+        }\n+\n+        and: \"Flow is really updated\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == flow2.source.vlanId\n+            it.source.innerVlanId == flow2.destination.vlanId\n+            it.destination.vlanId == flow2.destination.vlanId\n+            it.destination.innerVlanId == flow2.source.vlanId\n+        }\n+\n+        then: \"Both existing flows are still valid and pingable\"\n+        [flow.flowId, flow2.flowId].each {\n+            northbound.validateFlow(it).each { assert it.asExpected }\n+        }\n+\n+        [flow.flowId, flow2.flowId].each {\n+            verifyAll(northbound.pingFlow(it, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        when: \"Delete the flows\"\n+        [flow.flowId, flow2.flowId].each { flowHelperV2.deleteFlow(it) }\n+\n+        then: \"Flows rules are deleted\"\n+        involvedSwitchesforBothFlows.each { sw ->\n+            Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+                assert northbound.getSwitchRules(sw.dpId).flowEntries*.cookie.sort() == sw.defaultCookies.sort()\n+            }\n+        }\n+\n+        and: \"Shared rule of flow is deleted\"\n+        [swP.src.dpId, swP.dst.dpId].each { swId ->\n+            assert northbound.getSwitchRules(swId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+            }.empty\n+        }\n+\n+        where:\n+        srcVlanId | srcInnerVlanId | dstVlanId | dstInnerVlanId\n+        0         | 0              | 0         | 0\n+        10        | 20             | 30        | 40\n+        10        | 10             | 10        | 10\n+        10        | 0              | 0         | 40\n+        0         | 20             | 30        | 0\n+        10        | 20             | 0         | 0\n+        0         | 0              | 30        | 40\n+        10        | 20             | 30        | 0\n+        0         | 20             | 30        | 40\n+    }\n+\n+    @Unroll\n+    def \"System allows to create a single switch QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"A switch with enabled multiTable mode\"\n+        def sw = topology.activeSwitches.find { northbound.getSwitchProperties(it.dpId).multiTable } ?:\n+                assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a single switch QinQ flow\"\n+        def flow = flowHelperV2.singleSwitchFlow(sw)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Shared rule of flow is installed\"\n+        def expectedAmoutOfSharedRule = 0\n+        if (srcInnerVlanId > 0 || srcVlanId > 0) {\n+            expectedAmoutOfSharedRule += 1\n+        }\n+        if (dstInnerVlanId > 0 || dstVlanId > 0) {\n+            expectedAmoutOfSharedRule += 1\n+        }\n+        northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size() == expectedAmoutOfSharedRule\n+\n+        and: \"Involved switches pass switch validation\"\n+        with(pathHelper.getInvolvedSwitches(pathHelper.convert(northbound.getFlowPath(flow.flowId)))) {\n+            def validationInfo = northbound.validateSwitch(it.dpId)\n+            validationInfo.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            validationInfo.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        }\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+\n+        then: \"Flow rules are deleted\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+            assert northbound.getSwitchRules(sw.dpId).flowEntries*.cookie.sort() == sw.defaultCookies.sort()\n+        }\n+        northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.empty\n+\n+        where:\n+        srcVlanId | srcInnerVlanId | dstVlanId | dstInnerVlanId\n+        0         | 0              | 0         | 0\n+        10        | 20             | 30        | 40\n+        10        | 10             | 10        | 10\n+        10        | 0              | 0         | 40\n+        0         | 20             | 30        | 0\n+        10        | 20             | 0         | 0\n+        0         | 0              | 30        | 40\n+        10        | 20             | 30        | 0\n+        0         | 20             | 30        | 40\n+    }\n+\n+    @Tags(TOPOLOGY_DEPENDENT)\n+    def \"System doesn't allow to create a QinQ flow when a switch supports multi table mode but it is disabled\"() {\n+        given: \"A switch pair with disabled multi table mode at least on the one switch\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].any { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+        def initSrcSwProps = northbound.getSwitchProperties(swP.src.dpId)\n+        SwitchHelper.updateSwitchProperties(swP.src, initSrcSwProps.jacksonCopy().tap {\n+            it.multiTable = false\n+        })\n+        when: \"Try to create a QinQ flow when at least on switch doesn't support multi table mode\"\n+\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.innerVlanId = 4093\n+        flow.destination.innerVlanId = 3904\n+        northboundV2.addFlow(flow)\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        exc.responseBodyAsString.to(MessageError).errorMessage == \"Could not create flow\"\n+\n+        cleanup: \"Revert system to original state\"\n+        northbound.updateSwitchProperties(swP.src.dpId, initSrcSwProps)\n+        Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+            assert northbound.getSwitchRules(swP.src.dpId).flowEntries*.cookie.sort() == swP.src.defaultCookies.sort()\n+        }\n+        SwitchHelper.updateSwitchProperties(swP.src, initSrcSwProps)\n+    }\n+\n+    @Unroll\n+    def \"System doesn't allow to create a QinQ flow with incorrect innerVlanIds\\\n+(src:#srcInnerVlanId, dst:#dstInnerVlanId)\"() {\n+        when: \"Try to create a QinQ flow with incorrect innerVlanId\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        northboundV2.addFlow(flow)\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        exc.responseBodyAsString.to(MessageError).errorMessage == \"Invalid request payload\"\n+\n+        where:\n+        srcInnerVlanId | dstInnerVlanId\n+        4096           | 10\n+        10             | -1\n+    }\n+\n+    @Ignore(\"wait 3432\")\n+    def \"System doesn't allow to create a QinQ flow via APIv1\"() {\n+        given: \"Two switches with enabled multi table mode\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a QinQ flow via APIv1\"\n+        def flowV1 = flowHelper.randomFlow(swP)\n+        flowV1.source.innerVlanId = 100\n+        flowV1.destination.innerVlanId = 200\n+        northbound.addFlow(flowV1)\n+\n+        then: \"Human readable error is returned\"\n+        def eCreate = thrown(HttpClientErrorException)\n+        eCreate.statusCode == HttpStatus.BAD_REQUEST\n+        eCreate.responseBodyAsString.to(MessageError).errorMessage.contains(\"Could not create flow\")\n+    }\n+\n+    @Ignore\n+    def \"System doesn't allow to update/delete a QinQ flow via APIv1\"() {\n+        given: \"Two switches with enabled multi table mode\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a QinQ flow via APIv2\"\n+        def flowV2 = flowHelperV2.randomFlow(swP)\n+        flowV2.source.innerVlanId = 234\n+        flowV2.destination.innerVlanId = 432\n+        northboundV2.addFlow(flowV2)\n+\n+        and: \"Try to update the flow via APIv1\"\n+        flowHelperV2.updateFlow(flowV2.flowId, flowV2.tap { flowV2.source.innerVlanId += 1 })\n+\n+        then: \"Human readable error is returned\"\n+        def eUpdate = thrown(HttpClientErrorException)\n+        eUpdate.statusCode == HttpStatus.BAD_REQUEST\n+        eUpdate.responseBodyAsString.to(MessageError).errorMessage.contains(\"Could not update flow\")\n+\n+        when: \"Try to delete the flow via APIv1\"\n+        northbound.deleteFlow(flowV2.flowId)\n+\n+        then: \"Human readable error is returned\"\n+        def eDelete = thrown(HttpClientErrorException)\n+        eDelete.statusCode == HttpStatus.BAD_REQUEST\n+        eDelete.responseBodyAsString.to(MessageError).errorMessage.contains(\"Could not delete flow\")\n+\n+        cleanup:\n+        flowV2 && flowHelperV2.deleteFlow(flowV2.flowId)\n+    }\n+\n+    def \"System allows to create QinQ flow and flow without QnQ with the same vlan on the same port\"() {\n+        given: \"Two switches with enabled multi table mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a QinQ flow\"\n+        def flowWithQinQ = flowHelperV2.randomFlow(swP)\n+        flowWithQinQ.source.innerVlanId = 234\n+        flowWithQinQ.destination.innerVlanId = 432\n+        flowHelperV2.addFlow(flowWithQinQ)\n+\n+        and: \"Create a flow without QinQ\"\n+        def flowWithoutQinQ = flowHelperV2.randomFlow(swP)\n+        flowWithoutQinQ.source.vlanId = 0\n+        flowWithoutQinQ.source.innerVlanId = flowWithQinQ.source.vlanId\n+        flowHelperV2.addFlow(flowWithoutQinQ)\n+\n+        then: \"Both flows allow traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def examFlowWithtQinQ = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flowWithQinQ), 1000, 5)\n+        def examFlowWithoutQinQ = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flowWithoutQinQ), 1000, 5)\n+        withPool {\n+            [examFlowWithtQinQ.forward, examFlowWithtQinQ.reverse,\n+             examFlowWithoutQinQ.forward, examFlowWithoutQinQ.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Revert system to original state\"\n+        [flowWithQinQ, flowWithoutQinQ].each { flowHelperV2.deleteFlow(it.flowId) }\n+    }\n+\n+    def \"System detects conflict QinQ flows\"() {\n+        given: \"Two switches with enabled multi table mode\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a first flow\"\n+        def flow1 = flowHelperV2.randomFlow(swP)\n+        flow1.source.vlanId = 10\n+        flow1.source.innerVlanId = 0\n+        flowHelperV2.addFlow(flow1)\n+\n+        and: \"Try to create a conflict flow\"\n+        def flow2 = flowHelperV2.randomFlow(swP)\n+        flow2.source.vlanId = 0\n+        flow2.source.innerVlanId = flow1.source.vlanId\n+        flow2.source.portNumber = flow1.source.portNumber\n+        northboundV2.addFlow(flow2)\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.CONFLICT\n+        exc.responseBodyAsString.to(MessageError).errorMessage == \"Could not create flow\"\n+\n+        and: \"Revert system to original state\"\n+        flowHelperV2.deleteFlow(flow1.flowId)\n+    }", "originalCommit": "053a2ad50ac0c14d702c1aef1df0cd232c98f23b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY1ODU0OA==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r426658548", "bodyText": "added 'where' block\nwhere:\n        vlan | innerVlan | conflictVlan | conflictInnerVlanId\n        10   | 100       | 10           | 100\n        10   | 0         | 0            | 10", "author": "andriidovhan", "createdAt": "2020-05-18T14:15:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkyMzIyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkyNDEzNw==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r425924137", "bodyText": "flow1.destination.vlanId", "author": "rtretyak", "createdAt": "2020-05-15T16:45:25Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/QinQFlowSpec.groovy", "diffHunk": "@@ -0,0 +1,888 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.functionaltests.extension.tags.Tag.TOPOLOGY_DEPENDENT\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.SwitchHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+class QinQFlowSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Unroll\n+    def \"System allows to manipulate with QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"Two switches connected to traffgen and enabled multiTable mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            } && it.paths.size() > 2\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a protected QinQ flow\"\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        flow.allocateProtectedPath = true\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        /** System doesn't allow to create a flow with innerVlan and without vlan at the same time.\n+         * for e.g.: when you create a flow with the following params:\n+         * vlan == 0 and innerVlan != 0,\n+         * then flow will be created with vlan != 0 and innerVlan == 0\n+         */\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Shared rule of flow is installed\"\n+        def srcSwSharedRulesAmount = northbound.getSwitchRules(swP.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        def dstSwSharedRulesAmount = northbound.getSwitchRules(swP.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        if (srcInnerVlanId > 0 || srcVlanId > 0) {\n+            assert srcSwSharedRulesAmount == 1\n+        } else {\n+            assert srcSwSharedRulesAmount == 0\n+        }\n+        if (dstInnerVlanId > 0 || dstVlanId > 0) {\n+            assert dstSwSharedRulesAmount == 1\n+        } else {\n+            assert dstSwSharedRulesAmount == 0\n+        }\n+\n+        and: \"The flow allows traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def examQinQFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow1 = pathHelper.getInvolvedSwitches(\n+                pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        )\n+        involvedSwitchesFlow1.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        when: \"Create a flow without QinQ on the same port\"\n+        // it is not working with APIv1, flows are invalid; change to v2 when 3432 is merged\n+        def flow2 = flowHelperV2.randomFlow(swP).tap {\n+            it.source.portNumber = flow.source.portNumber\n+            it.source.vlanId = flow.source.vlanId + 1\n+            it.destination.portNumber = flow.destination.portNumber\n+            it.destination.vlanId = flow.destination.vlanId + 1\n+        }\n+        flowHelperV2.addFlow(flow2)\n+\n+        then: \"Both existing flows are valid\"\n+        [flow.flowId, flow2.flowId].each {\n+            northbound.validateFlow(it).each { assert it.asExpected }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow2 = pathHelper.getInvolvedSwitches(pathHelper.convert(northbound.getFlowPath(flow2.flowId)))\n+        def involvedSwitchesforBothFlows = (involvedSwitchesFlow1 + involvedSwitchesFlow2).unique { it.dpId }\n+        involvedSwitchesforBothFlows.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        and: \"Both flows are pingable\"\n+        [flow.flowId, flow2.flowId].each {\n+            verifyAll(northbound.pingFlow(it, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        then: \"Both flows allow traffic\"\n+        def examSimpleFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow2), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse, examSimpleFlow.forward, examSimpleFlow.reverse]\n+                    .eachParallel { direction ->\n+                        def resources = traffExam.startExam(direction)\n+                        direction.setResources(resources)\n+                        assert traffExam.waitExam(direction).hasTraffic()\n+                    }\n+        }\n+\n+        when: \"Update the QinQ flow\"\n+        def updateResponse = flowHelperV2.updateFlow(flow.flowId, flow.tap {\n+            flow.source.vlanId = flow2.source.vlanId\n+            flow.source.innerVlanId = flow2.destination.vlanId\n+            flow.destination.vlanId = flow2.destination.vlanId\n+            flow.destination.innerVlanId = flow2.source.vlanId\n+        })\n+\n+        then: \"Update response contains correct info about innerVlanIds\"\n+        with(updateResponse) {\n+            it.source.vlanId == flow2.source.vlanId\n+            it.source.innerVlanId == flow2.destination.vlanId\n+            it.destination.vlanId == flow2.destination.vlanId\n+            it.destination.innerVlanId == flow2.source.vlanId\n+        }\n+\n+        and: \"Flow is really updated\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == flow2.source.vlanId\n+            it.source.innerVlanId == flow2.destination.vlanId\n+            it.destination.vlanId == flow2.destination.vlanId\n+            it.destination.innerVlanId == flow2.source.vlanId\n+        }\n+\n+        then: \"Both existing flows are still valid and pingable\"\n+        [flow.flowId, flow2.flowId].each {\n+            northbound.validateFlow(it).each { assert it.asExpected }\n+        }\n+\n+        [flow.flowId, flow2.flowId].each {\n+            verifyAll(northbound.pingFlow(it, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        when: \"Delete the flows\"\n+        [flow.flowId, flow2.flowId].each { flowHelperV2.deleteFlow(it) }\n+\n+        then: \"Flows rules are deleted\"\n+        involvedSwitchesforBothFlows.each { sw ->\n+            Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+                assert northbound.getSwitchRules(sw.dpId).flowEntries*.cookie.sort() == sw.defaultCookies.sort()\n+            }\n+        }\n+\n+        and: \"Shared rule of flow is deleted\"\n+        [swP.src.dpId, swP.dst.dpId].each { swId ->\n+            assert northbound.getSwitchRules(swId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+            }.empty\n+        }\n+\n+        where:\n+        srcVlanId | srcInnerVlanId | dstVlanId | dstInnerVlanId\n+        0         | 0              | 0         | 0\n+        10        | 20             | 30        | 40\n+        10        | 10             | 10        | 10\n+        10        | 0              | 0         | 40\n+        0         | 20             | 30        | 0\n+        10        | 20             | 0         | 0\n+        0         | 0              | 30        | 40\n+        10        | 20             | 30        | 0\n+        0         | 20             | 30        | 40\n+    }\n+\n+    @Unroll\n+    def \"System allows to create a single switch QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"A switch with enabled multiTable mode\"\n+        def sw = topology.activeSwitches.find { northbound.getSwitchProperties(it.dpId).multiTable } ?:\n+                assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a single switch QinQ flow\"\n+        def flow = flowHelperV2.singleSwitchFlow(sw)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Shared rule of flow is installed\"\n+        def expectedAmoutOfSharedRule = 0\n+        if (srcInnerVlanId > 0 || srcVlanId > 0) {\n+            expectedAmoutOfSharedRule += 1\n+        }\n+        if (dstInnerVlanId > 0 || dstVlanId > 0) {\n+            expectedAmoutOfSharedRule += 1\n+        }\n+        northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size() == expectedAmoutOfSharedRule\n+\n+        and: \"Involved switches pass switch validation\"\n+        with(pathHelper.getInvolvedSwitches(pathHelper.convert(northbound.getFlowPath(flow.flowId)))) {\n+            def validationInfo = northbound.validateSwitch(it.dpId)\n+            validationInfo.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            validationInfo.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        }\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+\n+        then: \"Flow rules are deleted\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+            assert northbound.getSwitchRules(sw.dpId).flowEntries*.cookie.sort() == sw.defaultCookies.sort()\n+        }\n+        northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.empty\n+\n+        where:\n+        srcVlanId | srcInnerVlanId | dstVlanId | dstInnerVlanId\n+        0         | 0              | 0         | 0\n+        10        | 20             | 30        | 40\n+        10        | 10             | 10        | 10\n+        10        | 0              | 0         | 40\n+        0         | 20             | 30        | 0\n+        10        | 20             | 0         | 0\n+        0         | 0              | 30        | 40\n+        10        | 20             | 30        | 0\n+        0         | 20             | 30        | 40\n+    }\n+\n+    @Tags(TOPOLOGY_DEPENDENT)\n+    def \"System doesn't allow to create a QinQ flow when a switch supports multi table mode but it is disabled\"() {\n+        given: \"A switch pair with disabled multi table mode at least on the one switch\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].any { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+        def initSrcSwProps = northbound.getSwitchProperties(swP.src.dpId)\n+        SwitchHelper.updateSwitchProperties(swP.src, initSrcSwProps.jacksonCopy().tap {\n+            it.multiTable = false\n+        })\n+        when: \"Try to create a QinQ flow when at least on switch doesn't support multi table mode\"\n+\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.innerVlanId = 4093\n+        flow.destination.innerVlanId = 3904\n+        northboundV2.addFlow(flow)\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        exc.responseBodyAsString.to(MessageError).errorMessage == \"Could not create flow\"\n+\n+        cleanup: \"Revert system to original state\"\n+        northbound.updateSwitchProperties(swP.src.dpId, initSrcSwProps)\n+        Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+            assert northbound.getSwitchRules(swP.src.dpId).flowEntries*.cookie.sort() == swP.src.defaultCookies.sort()\n+        }\n+        SwitchHelper.updateSwitchProperties(swP.src, initSrcSwProps)\n+    }\n+\n+    @Unroll\n+    def \"System doesn't allow to create a QinQ flow with incorrect innerVlanIds\\\n+(src:#srcInnerVlanId, dst:#dstInnerVlanId)\"() {\n+        when: \"Try to create a QinQ flow with incorrect innerVlanId\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        northboundV2.addFlow(flow)\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        exc.responseBodyAsString.to(MessageError).errorMessage == \"Invalid request payload\"\n+\n+        where:\n+        srcInnerVlanId | dstInnerVlanId\n+        4096           | 10\n+        10             | -1\n+    }\n+\n+    @Ignore(\"wait 3432\")\n+    def \"System doesn't allow to create a QinQ flow via APIv1\"() {\n+        given: \"Two switches with enabled multi table mode\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a QinQ flow via APIv1\"\n+        def flowV1 = flowHelper.randomFlow(swP)\n+        flowV1.source.innerVlanId = 100\n+        flowV1.destination.innerVlanId = 200\n+        northbound.addFlow(flowV1)\n+\n+        then: \"Human readable error is returned\"\n+        def eCreate = thrown(HttpClientErrorException)\n+        eCreate.statusCode == HttpStatus.BAD_REQUEST\n+        eCreate.responseBodyAsString.to(MessageError).errorMessage.contains(\"Could not create flow\")\n+    }\n+\n+    @Ignore\n+    def \"System doesn't allow to update/delete a QinQ flow via APIv1\"() {\n+        given: \"Two switches with enabled multi table mode\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a QinQ flow via APIv2\"\n+        def flowV2 = flowHelperV2.randomFlow(swP)\n+        flowV2.source.innerVlanId = 234\n+        flowV2.destination.innerVlanId = 432\n+        northboundV2.addFlow(flowV2)\n+\n+        and: \"Try to update the flow via APIv1\"\n+        flowHelperV2.updateFlow(flowV2.flowId, flowV2.tap { flowV2.source.innerVlanId += 1 })\n+\n+        then: \"Human readable error is returned\"\n+        def eUpdate = thrown(HttpClientErrorException)\n+        eUpdate.statusCode == HttpStatus.BAD_REQUEST\n+        eUpdate.responseBodyAsString.to(MessageError).errorMessage.contains(\"Could not update flow\")\n+\n+        when: \"Try to delete the flow via APIv1\"\n+        northbound.deleteFlow(flowV2.flowId)\n+\n+        then: \"Human readable error is returned\"\n+        def eDelete = thrown(HttpClientErrorException)\n+        eDelete.statusCode == HttpStatus.BAD_REQUEST\n+        eDelete.responseBodyAsString.to(MessageError).errorMessage.contains(\"Could not delete flow\")\n+\n+        cleanup:\n+        flowV2 && flowHelperV2.deleteFlow(flowV2.flowId)\n+    }\n+\n+    def \"System allows to create QinQ flow and flow without QnQ with the same vlan on the same port\"() {\n+        given: \"Two switches with enabled multi table mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a QinQ flow\"\n+        def flowWithQinQ = flowHelperV2.randomFlow(swP)\n+        flowWithQinQ.source.innerVlanId = 234\n+        flowWithQinQ.destination.innerVlanId = 432\n+        flowHelperV2.addFlow(flowWithQinQ)\n+\n+        and: \"Create a flow without QinQ\"\n+        def flowWithoutQinQ = flowHelperV2.randomFlow(swP)\n+        flowWithoutQinQ.source.vlanId = 0\n+        flowWithoutQinQ.source.innerVlanId = flowWithQinQ.source.vlanId\n+        flowHelperV2.addFlow(flowWithoutQinQ)\n+\n+        then: \"Both flows allow traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def examFlowWithtQinQ = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flowWithQinQ), 1000, 5)\n+        def examFlowWithoutQinQ = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flowWithoutQinQ), 1000, 5)\n+        withPool {\n+            [examFlowWithtQinQ.forward, examFlowWithtQinQ.reverse,\n+             examFlowWithoutQinQ.forward, examFlowWithoutQinQ.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Revert system to original state\"\n+        [flowWithQinQ, flowWithoutQinQ].each { flowHelperV2.deleteFlow(it.flowId) }\n+    }\n+\n+    def \"System detects conflict QinQ flows\"() {\n+        given: \"Two switches with enabled multi table mode\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a first flow\"\n+        def flow1 = flowHelperV2.randomFlow(swP)\n+        flow1.source.vlanId = 10\n+        flow1.source.innerVlanId = 0\n+        flowHelperV2.addFlow(flow1)\n+\n+        and: \"Try to create a conflict flow\"\n+        def flow2 = flowHelperV2.randomFlow(swP)\n+        flow2.source.vlanId = 0\n+        flow2.source.innerVlanId = flow1.source.vlanId\n+        flow2.source.portNumber = flow1.source.portNumber\n+        northboundV2.addFlow(flow2)\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.CONFLICT\n+        exc.responseBodyAsString.to(MessageError).errorMessage == \"Could not create flow\"\n+\n+        and: \"Revert system to original state\"\n+        flowHelperV2.deleteFlow(flow1.flowId)\n+    }\n+\n+    def \"System allows to create more than one QinQ flow on the same port and with the same vlan\"() {\n+        given: \"Two switches connected to traffgen and enabled multiTable mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a first QinQ flow\"\n+        def flow1 = flowHelperV2.randomFlow(swP)\n+        flow1.source.innerVlanId = 300\n+        flow1.destination.innerVlanId = 400\n+        flowHelperV2.addFlow(flow1)\n+\n+        and: \"Create a second QinQ flow\"\n+        def flow2 = flowHelperV2.randomFlow(swP)\n+        flow2.source.vlanId = flow1.source.vlanId\n+        flow2.source.innerVlanId = flow1.destination.innerVlanId\n+        flow2.destination.vlanId = flow2.destination.vlanId", "originalCommit": "053a2ad50ac0c14d702c1aef1df0cd232c98f23b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjYzNzU4OA==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r426637588", "bodyText": "thx, fixed", "author": "andriidovhan", "createdAt": "2020-05-18T13:46:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkyNDEzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkyNjM5NA==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r425926394", "bodyText": "same", "author": "rtretyak", "createdAt": "2020-05-15T16:49:48Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/QinQFlowSpec.groovy", "diffHunk": "@@ -0,0 +1,888 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.functionaltests.extension.tags.Tag.TOPOLOGY_DEPENDENT\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.SwitchHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+class QinQFlowSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Unroll\n+    def \"System allows to manipulate with QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"Two switches connected to traffgen and enabled multiTable mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            } && it.paths.size() > 2\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a protected QinQ flow\"\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        flow.allocateProtectedPath = true\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        /** System doesn't allow to create a flow with innerVlan and without vlan at the same time.\n+         * for e.g.: when you create a flow with the following params:\n+         * vlan == 0 and innerVlan != 0,\n+         * then flow will be created with vlan != 0 and innerVlan == 0\n+         */\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Shared rule of flow is installed\"\n+        def srcSwSharedRulesAmount = northbound.getSwitchRules(swP.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        def dstSwSharedRulesAmount = northbound.getSwitchRules(swP.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        if (srcInnerVlanId > 0 || srcVlanId > 0) {\n+            assert srcSwSharedRulesAmount == 1\n+        } else {\n+            assert srcSwSharedRulesAmount == 0\n+        }\n+        if (dstInnerVlanId > 0 || dstVlanId > 0) {\n+            assert dstSwSharedRulesAmount == 1\n+        } else {\n+            assert dstSwSharedRulesAmount == 0\n+        }\n+\n+        and: \"The flow allows traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def examQinQFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow1 = pathHelper.getInvolvedSwitches(\n+                pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        )\n+        involvedSwitchesFlow1.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        when: \"Create a flow without QinQ on the same port\"\n+        // it is not working with APIv1, flows are invalid; change to v2 when 3432 is merged\n+        def flow2 = flowHelperV2.randomFlow(swP).tap {\n+            it.source.portNumber = flow.source.portNumber\n+            it.source.vlanId = flow.source.vlanId + 1\n+            it.destination.portNumber = flow.destination.portNumber\n+            it.destination.vlanId = flow.destination.vlanId + 1\n+        }\n+        flowHelperV2.addFlow(flow2)\n+\n+        then: \"Both existing flows are valid\"\n+        [flow.flowId, flow2.flowId].each {\n+            northbound.validateFlow(it).each { assert it.asExpected }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow2 = pathHelper.getInvolvedSwitches(pathHelper.convert(northbound.getFlowPath(flow2.flowId)))\n+        def involvedSwitchesforBothFlows = (involvedSwitchesFlow1 + involvedSwitchesFlow2).unique { it.dpId }\n+        involvedSwitchesforBothFlows.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        and: \"Both flows are pingable\"\n+        [flow.flowId, flow2.flowId].each {\n+            verifyAll(northbound.pingFlow(it, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        then: \"Both flows allow traffic\"\n+        def examSimpleFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow2), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse, examSimpleFlow.forward, examSimpleFlow.reverse]\n+                    .eachParallel { direction ->\n+                        def resources = traffExam.startExam(direction)\n+                        direction.setResources(resources)\n+                        assert traffExam.waitExam(direction).hasTraffic()\n+                    }\n+        }\n+\n+        when: \"Update the QinQ flow\"\n+        def updateResponse = flowHelperV2.updateFlow(flow.flowId, flow.tap {\n+            flow.source.vlanId = flow2.source.vlanId\n+            flow.source.innerVlanId = flow2.destination.vlanId\n+            flow.destination.vlanId = flow2.destination.vlanId\n+            flow.destination.innerVlanId = flow2.source.vlanId\n+        })\n+\n+        then: \"Update response contains correct info about innerVlanIds\"\n+        with(updateResponse) {\n+            it.source.vlanId == flow2.source.vlanId\n+            it.source.innerVlanId == flow2.destination.vlanId\n+            it.destination.vlanId == flow2.destination.vlanId\n+            it.destination.innerVlanId == flow2.source.vlanId\n+        }\n+\n+        and: \"Flow is really updated\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == flow2.source.vlanId\n+            it.source.innerVlanId == flow2.destination.vlanId\n+            it.destination.vlanId == flow2.destination.vlanId\n+            it.destination.innerVlanId == flow2.source.vlanId\n+        }\n+\n+        then: \"Both existing flows are still valid and pingable\"\n+        [flow.flowId, flow2.flowId].each {\n+            northbound.validateFlow(it).each { assert it.asExpected }\n+        }\n+\n+        [flow.flowId, flow2.flowId].each {\n+            verifyAll(northbound.pingFlow(it, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        when: \"Delete the flows\"\n+        [flow.flowId, flow2.flowId].each { flowHelperV2.deleteFlow(it) }\n+\n+        then: \"Flows rules are deleted\"\n+        involvedSwitchesforBothFlows.each { sw ->\n+            Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+                assert northbound.getSwitchRules(sw.dpId).flowEntries*.cookie.sort() == sw.defaultCookies.sort()\n+            }\n+        }\n+\n+        and: \"Shared rule of flow is deleted\"\n+        [swP.src.dpId, swP.dst.dpId].each { swId ->\n+            assert northbound.getSwitchRules(swId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+            }.empty\n+        }\n+\n+        where:\n+        srcVlanId | srcInnerVlanId | dstVlanId | dstInnerVlanId\n+        0         | 0              | 0         | 0\n+        10        | 20             | 30        | 40\n+        10        | 10             | 10        | 10\n+        10        | 0              | 0         | 40\n+        0         | 20             | 30        | 0\n+        10        | 20             | 0         | 0\n+        0         | 0              | 30        | 40\n+        10        | 20             | 30        | 0\n+        0         | 20             | 30        | 40\n+    }\n+\n+    @Unroll\n+    def \"System allows to create a single switch QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"A switch with enabled multiTable mode\"\n+        def sw = topology.activeSwitches.find { northbound.getSwitchProperties(it.dpId).multiTable } ?:\n+                assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a single switch QinQ flow\"\n+        def flow = flowHelperV2.singleSwitchFlow(sw)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Shared rule of flow is installed\"\n+        def expectedAmoutOfSharedRule = 0\n+        if (srcInnerVlanId > 0 || srcVlanId > 0) {\n+            expectedAmoutOfSharedRule += 1\n+        }\n+        if (dstInnerVlanId > 0 || dstVlanId > 0) {\n+            expectedAmoutOfSharedRule += 1\n+        }\n+        northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size() == expectedAmoutOfSharedRule\n+\n+        and: \"Involved switches pass switch validation\"\n+        with(pathHelper.getInvolvedSwitches(pathHelper.convert(northbound.getFlowPath(flow.flowId)))) {\n+            def validationInfo = northbound.validateSwitch(it.dpId)\n+            validationInfo.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            validationInfo.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        }\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+\n+        then: \"Flow rules are deleted\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+            assert northbound.getSwitchRules(sw.dpId).flowEntries*.cookie.sort() == sw.defaultCookies.sort()\n+        }\n+        northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.empty\n+\n+        where:\n+        srcVlanId | srcInnerVlanId | dstVlanId | dstInnerVlanId\n+        0         | 0              | 0         | 0\n+        10        | 20             | 30        | 40\n+        10        | 10             | 10        | 10\n+        10        | 0              | 0         | 40\n+        0         | 20             | 30        | 0\n+        10        | 20             | 0         | 0\n+        0         | 0              | 30        | 40\n+        10        | 20             | 30        | 0\n+        0         | 20             | 30        | 40\n+    }\n+\n+    @Tags(TOPOLOGY_DEPENDENT)\n+    def \"System doesn't allow to create a QinQ flow when a switch supports multi table mode but it is disabled\"() {\n+        given: \"A switch pair with disabled multi table mode at least on the one switch\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].any { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+        def initSrcSwProps = northbound.getSwitchProperties(swP.src.dpId)\n+        SwitchHelper.updateSwitchProperties(swP.src, initSrcSwProps.jacksonCopy().tap {\n+            it.multiTable = false\n+        })\n+        when: \"Try to create a QinQ flow when at least on switch doesn't support multi table mode\"\n+\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.innerVlanId = 4093\n+        flow.destination.innerVlanId = 3904\n+        northboundV2.addFlow(flow)\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        exc.responseBodyAsString.to(MessageError).errorMessage == \"Could not create flow\"\n+\n+        cleanup: \"Revert system to original state\"\n+        northbound.updateSwitchProperties(swP.src.dpId, initSrcSwProps)\n+        Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+            assert northbound.getSwitchRules(swP.src.dpId).flowEntries*.cookie.sort() == swP.src.defaultCookies.sort()\n+        }\n+        SwitchHelper.updateSwitchProperties(swP.src, initSrcSwProps)\n+    }\n+\n+    @Unroll\n+    def \"System doesn't allow to create a QinQ flow with incorrect innerVlanIds\\\n+(src:#srcInnerVlanId, dst:#dstInnerVlanId)\"() {\n+        when: \"Try to create a QinQ flow with incorrect innerVlanId\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        northboundV2.addFlow(flow)\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        exc.responseBodyAsString.to(MessageError).errorMessage == \"Invalid request payload\"\n+\n+        where:\n+        srcInnerVlanId | dstInnerVlanId\n+        4096           | 10\n+        10             | -1\n+    }\n+\n+    @Ignore(\"wait 3432\")\n+    def \"System doesn't allow to create a QinQ flow via APIv1\"() {\n+        given: \"Two switches with enabled multi table mode\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a QinQ flow via APIv1\"\n+        def flowV1 = flowHelper.randomFlow(swP)\n+        flowV1.source.innerVlanId = 100\n+        flowV1.destination.innerVlanId = 200\n+        northbound.addFlow(flowV1)\n+\n+        then: \"Human readable error is returned\"\n+        def eCreate = thrown(HttpClientErrorException)\n+        eCreate.statusCode == HttpStatus.BAD_REQUEST\n+        eCreate.responseBodyAsString.to(MessageError).errorMessage.contains(\"Could not create flow\")\n+    }\n+\n+    @Ignore\n+    def \"System doesn't allow to update/delete a QinQ flow via APIv1\"() {\n+        given: \"Two switches with enabled multi table mode\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a QinQ flow via APIv2\"\n+        def flowV2 = flowHelperV2.randomFlow(swP)\n+        flowV2.source.innerVlanId = 234\n+        flowV2.destination.innerVlanId = 432\n+        northboundV2.addFlow(flowV2)\n+\n+        and: \"Try to update the flow via APIv1\"\n+        flowHelperV2.updateFlow(flowV2.flowId, flowV2.tap { flowV2.source.innerVlanId += 1 })\n+\n+        then: \"Human readable error is returned\"\n+        def eUpdate = thrown(HttpClientErrorException)\n+        eUpdate.statusCode == HttpStatus.BAD_REQUEST\n+        eUpdate.responseBodyAsString.to(MessageError).errorMessage.contains(\"Could not update flow\")\n+\n+        when: \"Try to delete the flow via APIv1\"\n+        northbound.deleteFlow(flowV2.flowId)\n+\n+        then: \"Human readable error is returned\"\n+        def eDelete = thrown(HttpClientErrorException)\n+        eDelete.statusCode == HttpStatus.BAD_REQUEST\n+        eDelete.responseBodyAsString.to(MessageError).errorMessage.contains(\"Could not delete flow\")\n+\n+        cleanup:\n+        flowV2 && flowHelperV2.deleteFlow(flowV2.flowId)\n+    }\n+\n+    def \"System allows to create QinQ flow and flow without QnQ with the same vlan on the same port\"() {\n+        given: \"Two switches with enabled multi table mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a QinQ flow\"\n+        def flowWithQinQ = flowHelperV2.randomFlow(swP)\n+        flowWithQinQ.source.innerVlanId = 234\n+        flowWithQinQ.destination.innerVlanId = 432\n+        flowHelperV2.addFlow(flowWithQinQ)\n+\n+        and: \"Create a flow without QinQ\"\n+        def flowWithoutQinQ = flowHelperV2.randomFlow(swP)\n+        flowWithoutQinQ.source.vlanId = 0\n+        flowWithoutQinQ.source.innerVlanId = flowWithQinQ.source.vlanId\n+        flowHelperV2.addFlow(flowWithoutQinQ)\n+\n+        then: \"Both flows allow traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def examFlowWithtQinQ = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flowWithQinQ), 1000, 5)\n+        def examFlowWithoutQinQ = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flowWithoutQinQ), 1000, 5)\n+        withPool {\n+            [examFlowWithtQinQ.forward, examFlowWithtQinQ.reverse,\n+             examFlowWithoutQinQ.forward, examFlowWithoutQinQ.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Revert system to original state\"\n+        [flowWithQinQ, flowWithoutQinQ].each { flowHelperV2.deleteFlow(it.flowId) }\n+    }\n+\n+    def \"System detects conflict QinQ flows\"() {\n+        given: \"Two switches with enabled multi table mode\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a first flow\"\n+        def flow1 = flowHelperV2.randomFlow(swP)\n+        flow1.source.vlanId = 10\n+        flow1.source.innerVlanId = 0\n+        flowHelperV2.addFlow(flow1)\n+\n+        and: \"Try to create a conflict flow\"\n+        def flow2 = flowHelperV2.randomFlow(swP)\n+        flow2.source.vlanId = 0\n+        flow2.source.innerVlanId = flow1.source.vlanId\n+        flow2.source.portNumber = flow1.source.portNumber\n+        northboundV2.addFlow(flow2)\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.CONFLICT\n+        exc.responseBodyAsString.to(MessageError).errorMessage == \"Could not create flow\"\n+\n+        and: \"Revert system to original state\"\n+        flowHelperV2.deleteFlow(flow1.flowId)\n+    }\n+\n+    def \"System allows to create more than one QinQ flow on the same port and with the same vlan\"() {\n+        given: \"Two switches connected to traffgen and enabled multiTable mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a first QinQ flow\"\n+        def flow1 = flowHelperV2.randomFlow(swP)\n+        flow1.source.innerVlanId = 300\n+        flow1.destination.innerVlanId = 400\n+        flowHelperV2.addFlow(flow1)\n+\n+        and: \"Create a second QinQ flow\"\n+        def flow2 = flowHelperV2.randomFlow(swP)\n+        flow2.source.vlanId = flow1.source.vlanId\n+        flow2.source.innerVlanId = flow1.destination.innerVlanId\n+        flow2.destination.vlanId = flow2.destination.vlanId\n+        flow2.destination.innerVlanId = flow1.source.innerVlanId\n+        flowHelperV2.addFlow(flow2)\n+\n+\n+        then: \"Both flow are valid and pingable\"\n+        [flow1.flowId, flow2.flowId].each { flowId ->\n+            northbound.validateFlow(flowId).each { assert it.asExpected }\n+            verifyAll(northbound.pingFlow(flowId, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        and: \"Flows allow traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def exam1 = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow1), 1000, 5)\n+        def exam2 = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow2), 1000, 5)\n+        withPool {\n+            [exam1.forward, exam1.reverse, exam2.forward, exam2.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        when: \"Delete the second flow\"\n+        flowHelperV2.deleteFlow(flow2.flowId)\n+\n+        then: \"The first flow is still valid and pingable\"\n+        northbound.validateFlow(flow1.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow1.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"The first flow still allows traffic\"\n+        withPool {\n+            [exam1.forward, exam1.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Cleanup: Delete the first flow\"\n+        flowHelperV2.deleteFlow(flow1.flowId)\n+    }\n+\n+    @Unroll\n+    def \"System allows to create a single-switch-port QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"A switch with enabled multiTable mode\"\n+        def sw = topology.activeSwitches.find { northbound.getSwitchProperties(it.dpId).multiTable } ?:\n+                assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a single switch QinQ flow\"\n+        def flow = flowHelperV2.singleSwitchSinglePortFlow(sw)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        with(pathHelper.getInvolvedSwitches(pathHelper.convert(northbound.getFlowPath(flow.flowId)))) {\n+            def validationInfo = northbound.validateSwitch(it.dpId)\n+            validationInfo.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            validationInfo.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        }\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+\n+        then: \"Flow rules are deleted\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+            assert northbound.getSwitchRules(sw.dpId).flowEntries*.cookie.sort() == sw.defaultCookies.sort()\n+        }\n+\n+        where:\n+        srcVlanId | srcInnerVlanId | dstVlanId | dstInnerVlanId\n+        10        | 20             | 30        | 40\n+        10        | 20             | 30        | 0\n+        10        | 20             | 0         | 0\n+        10        | 0              | 0         | 40\n+        0         | 20             | 30        | 0\n+        0         | 20             | 30        | 40\n+        0         | 0              | 30        | 40", "originalCommit": "053a2ad50ac0c14d702c1aef1df0cd232c98f23b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkyNjU5Mw==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r425926593", "bodyText": "same", "author": "rtretyak", "createdAt": "2020-05-15T16:50:10Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/QinQFlowSpec.groovy", "diffHunk": "@@ -0,0 +1,888 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.functionaltests.extension.tags.Tag.TOPOLOGY_DEPENDENT\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.SwitchHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+class QinQFlowSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Unroll\n+    def \"System allows to manipulate with QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"Two switches connected to traffgen and enabled multiTable mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            } && it.paths.size() > 2\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a protected QinQ flow\"\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        flow.allocateProtectedPath = true\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        /** System doesn't allow to create a flow with innerVlan and without vlan at the same time.\n+         * for e.g.: when you create a flow with the following params:\n+         * vlan == 0 and innerVlan != 0,\n+         * then flow will be created with vlan != 0 and innerVlan == 0\n+         */\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Shared rule of flow is installed\"\n+        def srcSwSharedRulesAmount = northbound.getSwitchRules(swP.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        def dstSwSharedRulesAmount = northbound.getSwitchRules(swP.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        if (srcInnerVlanId > 0 || srcVlanId > 0) {\n+            assert srcSwSharedRulesAmount == 1\n+        } else {\n+            assert srcSwSharedRulesAmount == 0\n+        }\n+        if (dstInnerVlanId > 0 || dstVlanId > 0) {\n+            assert dstSwSharedRulesAmount == 1\n+        } else {\n+            assert dstSwSharedRulesAmount == 0\n+        }\n+\n+        and: \"The flow allows traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def examQinQFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow1 = pathHelper.getInvolvedSwitches(\n+                pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        )\n+        involvedSwitchesFlow1.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        when: \"Create a flow without QinQ on the same port\"\n+        // it is not working with APIv1, flows are invalid; change to v2 when 3432 is merged\n+        def flow2 = flowHelperV2.randomFlow(swP).tap {\n+            it.source.portNumber = flow.source.portNumber\n+            it.source.vlanId = flow.source.vlanId + 1\n+            it.destination.portNumber = flow.destination.portNumber\n+            it.destination.vlanId = flow.destination.vlanId + 1\n+        }\n+        flowHelperV2.addFlow(flow2)\n+\n+        then: \"Both existing flows are valid\"\n+        [flow.flowId, flow2.flowId].each {\n+            northbound.validateFlow(it).each { assert it.asExpected }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow2 = pathHelper.getInvolvedSwitches(pathHelper.convert(northbound.getFlowPath(flow2.flowId)))\n+        def involvedSwitchesforBothFlows = (involvedSwitchesFlow1 + involvedSwitchesFlow2).unique { it.dpId }\n+        involvedSwitchesforBothFlows.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        and: \"Both flows are pingable\"\n+        [flow.flowId, flow2.flowId].each {\n+            verifyAll(northbound.pingFlow(it, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        then: \"Both flows allow traffic\"\n+        def examSimpleFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow2), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse, examSimpleFlow.forward, examSimpleFlow.reverse]\n+                    .eachParallel { direction ->\n+                        def resources = traffExam.startExam(direction)\n+                        direction.setResources(resources)\n+                        assert traffExam.waitExam(direction).hasTraffic()\n+                    }\n+        }\n+\n+        when: \"Update the QinQ flow\"\n+        def updateResponse = flowHelperV2.updateFlow(flow.flowId, flow.tap {\n+            flow.source.vlanId = flow2.source.vlanId\n+            flow.source.innerVlanId = flow2.destination.vlanId\n+            flow.destination.vlanId = flow2.destination.vlanId\n+            flow.destination.innerVlanId = flow2.source.vlanId\n+        })\n+\n+        then: \"Update response contains correct info about innerVlanIds\"\n+        with(updateResponse) {\n+            it.source.vlanId == flow2.source.vlanId\n+            it.source.innerVlanId == flow2.destination.vlanId\n+            it.destination.vlanId == flow2.destination.vlanId\n+            it.destination.innerVlanId == flow2.source.vlanId\n+        }\n+\n+        and: \"Flow is really updated\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == flow2.source.vlanId\n+            it.source.innerVlanId == flow2.destination.vlanId\n+            it.destination.vlanId == flow2.destination.vlanId\n+            it.destination.innerVlanId == flow2.source.vlanId\n+        }\n+\n+        then: \"Both existing flows are still valid and pingable\"\n+        [flow.flowId, flow2.flowId].each {\n+            northbound.validateFlow(it).each { assert it.asExpected }\n+        }\n+\n+        [flow.flowId, flow2.flowId].each {\n+            verifyAll(northbound.pingFlow(it, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        when: \"Delete the flows\"\n+        [flow.flowId, flow2.flowId].each { flowHelperV2.deleteFlow(it) }\n+\n+        then: \"Flows rules are deleted\"\n+        involvedSwitchesforBothFlows.each { sw ->\n+            Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+                assert northbound.getSwitchRules(sw.dpId).flowEntries*.cookie.sort() == sw.defaultCookies.sort()\n+            }\n+        }\n+\n+        and: \"Shared rule of flow is deleted\"\n+        [swP.src.dpId, swP.dst.dpId].each { swId ->\n+            assert northbound.getSwitchRules(swId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+            }.empty\n+        }\n+\n+        where:\n+        srcVlanId | srcInnerVlanId | dstVlanId | dstInnerVlanId\n+        0         | 0              | 0         | 0\n+        10        | 20             | 30        | 40\n+        10        | 10             | 10        | 10\n+        10        | 0              | 0         | 40\n+        0         | 20             | 30        | 0\n+        10        | 20             | 0         | 0\n+        0         | 0              | 30        | 40\n+        10        | 20             | 30        | 0\n+        0         | 20             | 30        | 40\n+    }\n+\n+    @Unroll\n+    def \"System allows to create a single switch QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"A switch with enabled multiTable mode\"\n+        def sw = topology.activeSwitches.find { northbound.getSwitchProperties(it.dpId).multiTable } ?:\n+                assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a single switch QinQ flow\"\n+        def flow = flowHelperV2.singleSwitchFlow(sw)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Shared rule of flow is installed\"\n+        def expectedAmoutOfSharedRule = 0\n+        if (srcInnerVlanId > 0 || srcVlanId > 0) {\n+            expectedAmoutOfSharedRule += 1\n+        }\n+        if (dstInnerVlanId > 0 || dstVlanId > 0) {\n+            expectedAmoutOfSharedRule += 1\n+        }\n+        northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size() == expectedAmoutOfSharedRule\n+\n+        and: \"Involved switches pass switch validation\"\n+        with(pathHelper.getInvolvedSwitches(pathHelper.convert(northbound.getFlowPath(flow.flowId)))) {\n+            def validationInfo = northbound.validateSwitch(it.dpId)\n+            validationInfo.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            validationInfo.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        }\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+\n+        then: \"Flow rules are deleted\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+            assert northbound.getSwitchRules(sw.dpId).flowEntries*.cookie.sort() == sw.defaultCookies.sort()\n+        }\n+        northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.empty\n+\n+        where:\n+        srcVlanId | srcInnerVlanId | dstVlanId | dstInnerVlanId\n+        0         | 0              | 0         | 0\n+        10        | 20             | 30        | 40\n+        10        | 10             | 10        | 10\n+        10        | 0              | 0         | 40\n+        0         | 20             | 30        | 0\n+        10        | 20             | 0         | 0\n+        0         | 0              | 30        | 40\n+        10        | 20             | 30        | 0\n+        0         | 20             | 30        | 40\n+    }\n+\n+    @Tags(TOPOLOGY_DEPENDENT)\n+    def \"System doesn't allow to create a QinQ flow when a switch supports multi table mode but it is disabled\"() {\n+        given: \"A switch pair with disabled multi table mode at least on the one switch\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].any { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+        def initSrcSwProps = northbound.getSwitchProperties(swP.src.dpId)\n+        SwitchHelper.updateSwitchProperties(swP.src, initSrcSwProps.jacksonCopy().tap {\n+            it.multiTable = false\n+        })\n+        when: \"Try to create a QinQ flow when at least on switch doesn't support multi table mode\"\n+\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.innerVlanId = 4093\n+        flow.destination.innerVlanId = 3904\n+        northboundV2.addFlow(flow)\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        exc.responseBodyAsString.to(MessageError).errorMessage == \"Could not create flow\"\n+\n+        cleanup: \"Revert system to original state\"\n+        northbound.updateSwitchProperties(swP.src.dpId, initSrcSwProps)\n+        Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+            assert northbound.getSwitchRules(swP.src.dpId).flowEntries*.cookie.sort() == swP.src.defaultCookies.sort()\n+        }\n+        SwitchHelper.updateSwitchProperties(swP.src, initSrcSwProps)\n+    }\n+\n+    @Unroll\n+    def \"System doesn't allow to create a QinQ flow with incorrect innerVlanIds\\\n+(src:#srcInnerVlanId, dst:#dstInnerVlanId)\"() {\n+        when: \"Try to create a QinQ flow with incorrect innerVlanId\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        northboundV2.addFlow(flow)\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        exc.responseBodyAsString.to(MessageError).errorMessage == \"Invalid request payload\"\n+\n+        where:\n+        srcInnerVlanId | dstInnerVlanId\n+        4096           | 10\n+        10             | -1\n+    }\n+\n+    @Ignore(\"wait 3432\")\n+    def \"System doesn't allow to create a QinQ flow via APIv1\"() {\n+        given: \"Two switches with enabled multi table mode\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a QinQ flow via APIv1\"\n+        def flowV1 = flowHelper.randomFlow(swP)\n+        flowV1.source.innerVlanId = 100\n+        flowV1.destination.innerVlanId = 200\n+        northbound.addFlow(flowV1)\n+\n+        then: \"Human readable error is returned\"\n+        def eCreate = thrown(HttpClientErrorException)\n+        eCreate.statusCode == HttpStatus.BAD_REQUEST\n+        eCreate.responseBodyAsString.to(MessageError).errorMessage.contains(\"Could not create flow\")\n+    }\n+\n+    @Ignore\n+    def \"System doesn't allow to update/delete a QinQ flow via APIv1\"() {\n+        given: \"Two switches with enabled multi table mode\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a QinQ flow via APIv2\"\n+        def flowV2 = flowHelperV2.randomFlow(swP)\n+        flowV2.source.innerVlanId = 234\n+        flowV2.destination.innerVlanId = 432\n+        northboundV2.addFlow(flowV2)\n+\n+        and: \"Try to update the flow via APIv1\"\n+        flowHelperV2.updateFlow(flowV2.flowId, flowV2.tap { flowV2.source.innerVlanId += 1 })\n+\n+        then: \"Human readable error is returned\"\n+        def eUpdate = thrown(HttpClientErrorException)\n+        eUpdate.statusCode == HttpStatus.BAD_REQUEST\n+        eUpdate.responseBodyAsString.to(MessageError).errorMessage.contains(\"Could not update flow\")\n+\n+        when: \"Try to delete the flow via APIv1\"\n+        northbound.deleteFlow(flowV2.flowId)\n+\n+        then: \"Human readable error is returned\"\n+        def eDelete = thrown(HttpClientErrorException)\n+        eDelete.statusCode == HttpStatus.BAD_REQUEST\n+        eDelete.responseBodyAsString.to(MessageError).errorMessage.contains(\"Could not delete flow\")\n+\n+        cleanup:\n+        flowV2 && flowHelperV2.deleteFlow(flowV2.flowId)\n+    }\n+\n+    def \"System allows to create QinQ flow and flow without QnQ with the same vlan on the same port\"() {\n+        given: \"Two switches with enabled multi table mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a QinQ flow\"\n+        def flowWithQinQ = flowHelperV2.randomFlow(swP)\n+        flowWithQinQ.source.innerVlanId = 234\n+        flowWithQinQ.destination.innerVlanId = 432\n+        flowHelperV2.addFlow(flowWithQinQ)\n+\n+        and: \"Create a flow without QinQ\"\n+        def flowWithoutQinQ = flowHelperV2.randomFlow(swP)\n+        flowWithoutQinQ.source.vlanId = 0\n+        flowWithoutQinQ.source.innerVlanId = flowWithQinQ.source.vlanId\n+        flowHelperV2.addFlow(flowWithoutQinQ)\n+\n+        then: \"Both flows allow traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def examFlowWithtQinQ = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flowWithQinQ), 1000, 5)\n+        def examFlowWithoutQinQ = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flowWithoutQinQ), 1000, 5)\n+        withPool {\n+            [examFlowWithtQinQ.forward, examFlowWithtQinQ.reverse,\n+             examFlowWithoutQinQ.forward, examFlowWithoutQinQ.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Revert system to original state\"\n+        [flowWithQinQ, flowWithoutQinQ].each { flowHelperV2.deleteFlow(it.flowId) }\n+    }\n+\n+    def \"System detects conflict QinQ flows\"() {\n+        given: \"Two switches with enabled multi table mode\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a first flow\"\n+        def flow1 = flowHelperV2.randomFlow(swP)\n+        flow1.source.vlanId = 10\n+        flow1.source.innerVlanId = 0\n+        flowHelperV2.addFlow(flow1)\n+\n+        and: \"Try to create a conflict flow\"\n+        def flow2 = flowHelperV2.randomFlow(swP)\n+        flow2.source.vlanId = 0\n+        flow2.source.innerVlanId = flow1.source.vlanId\n+        flow2.source.portNumber = flow1.source.portNumber\n+        northboundV2.addFlow(flow2)\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.CONFLICT\n+        exc.responseBodyAsString.to(MessageError).errorMessage == \"Could not create flow\"\n+\n+        and: \"Revert system to original state\"\n+        flowHelperV2.deleteFlow(flow1.flowId)\n+    }\n+\n+    def \"System allows to create more than one QinQ flow on the same port and with the same vlan\"() {\n+        given: \"Two switches connected to traffgen and enabled multiTable mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a first QinQ flow\"\n+        def flow1 = flowHelperV2.randomFlow(swP)\n+        flow1.source.innerVlanId = 300\n+        flow1.destination.innerVlanId = 400\n+        flowHelperV2.addFlow(flow1)\n+\n+        and: \"Create a second QinQ flow\"\n+        def flow2 = flowHelperV2.randomFlow(swP)\n+        flow2.source.vlanId = flow1.source.vlanId\n+        flow2.source.innerVlanId = flow1.destination.innerVlanId\n+        flow2.destination.vlanId = flow2.destination.vlanId\n+        flow2.destination.innerVlanId = flow1.source.innerVlanId\n+        flowHelperV2.addFlow(flow2)\n+\n+\n+        then: \"Both flow are valid and pingable\"\n+        [flow1.flowId, flow2.flowId].each { flowId ->\n+            northbound.validateFlow(flowId).each { assert it.asExpected }\n+            verifyAll(northbound.pingFlow(flowId, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        and: \"Flows allow traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def exam1 = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow1), 1000, 5)\n+        def exam2 = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow2), 1000, 5)\n+        withPool {\n+            [exam1.forward, exam1.reverse, exam2.forward, exam2.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        when: \"Delete the second flow\"\n+        flowHelperV2.deleteFlow(flow2.flowId)\n+\n+        then: \"The first flow is still valid and pingable\"\n+        northbound.validateFlow(flow1.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow1.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"The first flow still allows traffic\"\n+        withPool {\n+            [exam1.forward, exam1.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Cleanup: Delete the first flow\"\n+        flowHelperV2.deleteFlow(flow1.flowId)\n+    }\n+\n+    @Unroll\n+    def \"System allows to create a single-switch-port QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"A switch with enabled multiTable mode\"\n+        def sw = topology.activeSwitches.find { northbound.getSwitchProperties(it.dpId).multiTable } ?:\n+                assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a single switch QinQ flow\"\n+        def flow = flowHelperV2.singleSwitchSinglePortFlow(sw)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        with(pathHelper.getInvolvedSwitches(pathHelper.convert(northbound.getFlowPath(flow.flowId)))) {\n+            def validationInfo = northbound.validateSwitch(it.dpId)\n+            validationInfo.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            validationInfo.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        }\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+\n+        then: \"Flow rules are deleted\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+            assert northbound.getSwitchRules(sw.dpId).flowEntries*.cookie.sort() == sw.defaultCookies.sort()\n+        }\n+\n+        where:\n+        srcVlanId | srcInnerVlanId | dstVlanId | dstInnerVlanId\n+        10        | 20             | 30        | 40\n+        10        | 20             | 30        | 0\n+        10        | 20             | 0         | 0\n+        10        | 0              | 0         | 40\n+        0         | 20             | 30        | 0\n+        0         | 20             | 30        | 40\n+        0         | 0              | 30        | 40\n+    }\n+\n+    @Unroll\n+    @Tags(HARDWARE) //not tested\n+    def \"System allows to manipulate with QinQ vxlan flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"Two switches connected to traffgen and enabled multiTable mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable &&\n+                        sw.noviflow && !sw.wb5164\n+            } && it.paths.size() > 2\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a protected QinQ vxlan flow\"\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.encapsulationType = FlowEncapsulationType.VXLAN\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        flow.allocateProtectedPath = true\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        /** System doesn't allow to create a flow with innerVlan and without vlan at the same time.\n+         * for e.g.: when you create a flow with the following params:\n+         * vlan == 0 and innerVlan != 0,\n+         * then flow will be created with vlan != 0 and innerVlan == 0\n+         */\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Shared rule of flow is installed\"\n+        def srcSwSharedRulesAmount = northbound.getSwitchRules(swP.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        def dstSwSharedRulesAmount = northbound.getSwitchRules(swP.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        if (srcInnerVlanId > 0 || srcVlanId > 0) {\n+            assert srcSwSharedRulesAmount == 1\n+        } else {\n+            assert srcSwSharedRulesAmount == 0\n+        }\n+        if (dstInnerVlanId > 0 || dstVlanId > 0) {\n+            assert dstSwSharedRulesAmount == 1\n+        } else {\n+            assert dstSwSharedRulesAmount == 0\n+        }", "originalCommit": "053a2ad50ac0c14d702c1aef1df0cd232c98f23b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkyNjY4NA==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r425926684", "bodyText": "same", "author": "rtretyak", "createdAt": "2020-05-15T16:50:20Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/QinQFlowSpec.groovy", "diffHunk": "@@ -0,0 +1,888 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.functionaltests.extension.tags.Tag.TOPOLOGY_DEPENDENT\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.SwitchHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+class QinQFlowSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Unroll\n+    def \"System allows to manipulate with QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"Two switches connected to traffgen and enabled multiTable mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            } && it.paths.size() > 2\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a protected QinQ flow\"\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        flow.allocateProtectedPath = true\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        /** System doesn't allow to create a flow with innerVlan and without vlan at the same time.\n+         * for e.g.: when you create a flow with the following params:\n+         * vlan == 0 and innerVlan != 0,\n+         * then flow will be created with vlan != 0 and innerVlan == 0\n+         */\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Shared rule of flow is installed\"\n+        def srcSwSharedRulesAmount = northbound.getSwitchRules(swP.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        def dstSwSharedRulesAmount = northbound.getSwitchRules(swP.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        if (srcInnerVlanId > 0 || srcVlanId > 0) {\n+            assert srcSwSharedRulesAmount == 1\n+        } else {\n+            assert srcSwSharedRulesAmount == 0\n+        }\n+        if (dstInnerVlanId > 0 || dstVlanId > 0) {\n+            assert dstSwSharedRulesAmount == 1\n+        } else {\n+            assert dstSwSharedRulesAmount == 0\n+        }\n+\n+        and: \"The flow allows traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def examQinQFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow1 = pathHelper.getInvolvedSwitches(\n+                pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        )\n+        involvedSwitchesFlow1.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        when: \"Create a flow without QinQ on the same port\"\n+        // it is not working with APIv1, flows are invalid; change to v2 when 3432 is merged\n+        def flow2 = flowHelperV2.randomFlow(swP).tap {\n+            it.source.portNumber = flow.source.portNumber\n+            it.source.vlanId = flow.source.vlanId + 1\n+            it.destination.portNumber = flow.destination.portNumber\n+            it.destination.vlanId = flow.destination.vlanId + 1\n+        }\n+        flowHelperV2.addFlow(flow2)\n+\n+        then: \"Both existing flows are valid\"\n+        [flow.flowId, flow2.flowId].each {\n+            northbound.validateFlow(it).each { assert it.asExpected }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow2 = pathHelper.getInvolvedSwitches(pathHelper.convert(northbound.getFlowPath(flow2.flowId)))\n+        def involvedSwitchesforBothFlows = (involvedSwitchesFlow1 + involvedSwitchesFlow2).unique { it.dpId }\n+        involvedSwitchesforBothFlows.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        and: \"Both flows are pingable\"\n+        [flow.flowId, flow2.flowId].each {\n+            verifyAll(northbound.pingFlow(it, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        then: \"Both flows allow traffic\"\n+        def examSimpleFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow2), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse, examSimpleFlow.forward, examSimpleFlow.reverse]\n+                    .eachParallel { direction ->\n+                        def resources = traffExam.startExam(direction)\n+                        direction.setResources(resources)\n+                        assert traffExam.waitExam(direction).hasTraffic()\n+                    }\n+        }\n+\n+        when: \"Update the QinQ flow\"\n+        def updateResponse = flowHelperV2.updateFlow(flow.flowId, flow.tap {\n+            flow.source.vlanId = flow2.source.vlanId\n+            flow.source.innerVlanId = flow2.destination.vlanId\n+            flow.destination.vlanId = flow2.destination.vlanId\n+            flow.destination.innerVlanId = flow2.source.vlanId\n+        })\n+\n+        then: \"Update response contains correct info about innerVlanIds\"\n+        with(updateResponse) {\n+            it.source.vlanId == flow2.source.vlanId\n+            it.source.innerVlanId == flow2.destination.vlanId\n+            it.destination.vlanId == flow2.destination.vlanId\n+            it.destination.innerVlanId == flow2.source.vlanId\n+        }\n+\n+        and: \"Flow is really updated\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == flow2.source.vlanId\n+            it.source.innerVlanId == flow2.destination.vlanId\n+            it.destination.vlanId == flow2.destination.vlanId\n+            it.destination.innerVlanId == flow2.source.vlanId\n+        }\n+\n+        then: \"Both existing flows are still valid and pingable\"\n+        [flow.flowId, flow2.flowId].each {\n+            northbound.validateFlow(it).each { assert it.asExpected }\n+        }\n+\n+        [flow.flowId, flow2.flowId].each {\n+            verifyAll(northbound.pingFlow(it, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        when: \"Delete the flows\"\n+        [flow.flowId, flow2.flowId].each { flowHelperV2.deleteFlow(it) }\n+\n+        then: \"Flows rules are deleted\"\n+        involvedSwitchesforBothFlows.each { sw ->\n+            Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+                assert northbound.getSwitchRules(sw.dpId).flowEntries*.cookie.sort() == sw.defaultCookies.sort()\n+            }\n+        }\n+\n+        and: \"Shared rule of flow is deleted\"\n+        [swP.src.dpId, swP.dst.dpId].each { swId ->\n+            assert northbound.getSwitchRules(swId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+            }.empty\n+        }\n+\n+        where:\n+        srcVlanId | srcInnerVlanId | dstVlanId | dstInnerVlanId\n+        0         | 0              | 0         | 0\n+        10        | 20             | 30        | 40\n+        10        | 10             | 10        | 10\n+        10        | 0              | 0         | 40\n+        0         | 20             | 30        | 0\n+        10        | 20             | 0         | 0\n+        0         | 0              | 30        | 40\n+        10        | 20             | 30        | 0\n+        0         | 20             | 30        | 40\n+    }\n+\n+    @Unroll\n+    def \"System allows to create a single switch QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"A switch with enabled multiTable mode\"\n+        def sw = topology.activeSwitches.find { northbound.getSwitchProperties(it.dpId).multiTable } ?:\n+                assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a single switch QinQ flow\"\n+        def flow = flowHelperV2.singleSwitchFlow(sw)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Shared rule of flow is installed\"\n+        def expectedAmoutOfSharedRule = 0\n+        if (srcInnerVlanId > 0 || srcVlanId > 0) {\n+            expectedAmoutOfSharedRule += 1\n+        }\n+        if (dstInnerVlanId > 0 || dstVlanId > 0) {\n+            expectedAmoutOfSharedRule += 1\n+        }\n+        northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size() == expectedAmoutOfSharedRule\n+\n+        and: \"Involved switches pass switch validation\"\n+        with(pathHelper.getInvolvedSwitches(pathHelper.convert(northbound.getFlowPath(flow.flowId)))) {\n+            def validationInfo = northbound.validateSwitch(it.dpId)\n+            validationInfo.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            validationInfo.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        }\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+\n+        then: \"Flow rules are deleted\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+            assert northbound.getSwitchRules(sw.dpId).flowEntries*.cookie.sort() == sw.defaultCookies.sort()\n+        }\n+        northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.empty\n+\n+        where:\n+        srcVlanId | srcInnerVlanId | dstVlanId | dstInnerVlanId\n+        0         | 0              | 0         | 0\n+        10        | 20             | 30        | 40\n+        10        | 10             | 10        | 10\n+        10        | 0              | 0         | 40\n+        0         | 20             | 30        | 0\n+        10        | 20             | 0         | 0\n+        0         | 0              | 30        | 40\n+        10        | 20             | 30        | 0\n+        0         | 20             | 30        | 40\n+    }\n+\n+    @Tags(TOPOLOGY_DEPENDENT)\n+    def \"System doesn't allow to create a QinQ flow when a switch supports multi table mode but it is disabled\"() {\n+        given: \"A switch pair with disabled multi table mode at least on the one switch\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].any { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+        def initSrcSwProps = northbound.getSwitchProperties(swP.src.dpId)\n+        SwitchHelper.updateSwitchProperties(swP.src, initSrcSwProps.jacksonCopy().tap {\n+            it.multiTable = false\n+        })\n+        when: \"Try to create a QinQ flow when at least on switch doesn't support multi table mode\"\n+\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.innerVlanId = 4093\n+        flow.destination.innerVlanId = 3904\n+        northboundV2.addFlow(flow)\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        exc.responseBodyAsString.to(MessageError).errorMessage == \"Could not create flow\"\n+\n+        cleanup: \"Revert system to original state\"\n+        northbound.updateSwitchProperties(swP.src.dpId, initSrcSwProps)\n+        Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+            assert northbound.getSwitchRules(swP.src.dpId).flowEntries*.cookie.sort() == swP.src.defaultCookies.sort()\n+        }\n+        SwitchHelper.updateSwitchProperties(swP.src, initSrcSwProps)\n+    }\n+\n+    @Unroll\n+    def \"System doesn't allow to create a QinQ flow with incorrect innerVlanIds\\\n+(src:#srcInnerVlanId, dst:#dstInnerVlanId)\"() {\n+        when: \"Try to create a QinQ flow with incorrect innerVlanId\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        northboundV2.addFlow(flow)\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        exc.responseBodyAsString.to(MessageError).errorMessage == \"Invalid request payload\"\n+\n+        where:\n+        srcInnerVlanId | dstInnerVlanId\n+        4096           | 10\n+        10             | -1\n+    }\n+\n+    @Ignore(\"wait 3432\")\n+    def \"System doesn't allow to create a QinQ flow via APIv1\"() {\n+        given: \"Two switches with enabled multi table mode\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a QinQ flow via APIv1\"\n+        def flowV1 = flowHelper.randomFlow(swP)\n+        flowV1.source.innerVlanId = 100\n+        flowV1.destination.innerVlanId = 200\n+        northbound.addFlow(flowV1)\n+\n+        then: \"Human readable error is returned\"\n+        def eCreate = thrown(HttpClientErrorException)\n+        eCreate.statusCode == HttpStatus.BAD_REQUEST\n+        eCreate.responseBodyAsString.to(MessageError).errorMessage.contains(\"Could not create flow\")\n+    }\n+\n+    @Ignore\n+    def \"System doesn't allow to update/delete a QinQ flow via APIv1\"() {\n+        given: \"Two switches with enabled multi table mode\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a QinQ flow via APIv2\"\n+        def flowV2 = flowHelperV2.randomFlow(swP)\n+        flowV2.source.innerVlanId = 234\n+        flowV2.destination.innerVlanId = 432\n+        northboundV2.addFlow(flowV2)\n+\n+        and: \"Try to update the flow via APIv1\"\n+        flowHelperV2.updateFlow(flowV2.flowId, flowV2.tap { flowV2.source.innerVlanId += 1 })\n+\n+        then: \"Human readable error is returned\"\n+        def eUpdate = thrown(HttpClientErrorException)\n+        eUpdate.statusCode == HttpStatus.BAD_REQUEST\n+        eUpdate.responseBodyAsString.to(MessageError).errorMessage.contains(\"Could not update flow\")\n+\n+        when: \"Try to delete the flow via APIv1\"\n+        northbound.deleteFlow(flowV2.flowId)\n+\n+        then: \"Human readable error is returned\"\n+        def eDelete = thrown(HttpClientErrorException)\n+        eDelete.statusCode == HttpStatus.BAD_REQUEST\n+        eDelete.responseBodyAsString.to(MessageError).errorMessage.contains(\"Could not delete flow\")\n+\n+        cleanup:\n+        flowV2 && flowHelperV2.deleteFlow(flowV2.flowId)\n+    }\n+\n+    def \"System allows to create QinQ flow and flow without QnQ with the same vlan on the same port\"() {\n+        given: \"Two switches with enabled multi table mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a QinQ flow\"\n+        def flowWithQinQ = flowHelperV2.randomFlow(swP)\n+        flowWithQinQ.source.innerVlanId = 234\n+        flowWithQinQ.destination.innerVlanId = 432\n+        flowHelperV2.addFlow(flowWithQinQ)\n+\n+        and: \"Create a flow without QinQ\"\n+        def flowWithoutQinQ = flowHelperV2.randomFlow(swP)\n+        flowWithoutQinQ.source.vlanId = 0\n+        flowWithoutQinQ.source.innerVlanId = flowWithQinQ.source.vlanId\n+        flowHelperV2.addFlow(flowWithoutQinQ)\n+\n+        then: \"Both flows allow traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def examFlowWithtQinQ = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flowWithQinQ), 1000, 5)\n+        def examFlowWithoutQinQ = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flowWithoutQinQ), 1000, 5)\n+        withPool {\n+            [examFlowWithtQinQ.forward, examFlowWithtQinQ.reverse,\n+             examFlowWithoutQinQ.forward, examFlowWithoutQinQ.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Revert system to original state\"\n+        [flowWithQinQ, flowWithoutQinQ].each { flowHelperV2.deleteFlow(it.flowId) }\n+    }\n+\n+    def \"System detects conflict QinQ flows\"() {\n+        given: \"Two switches with enabled multi table mode\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a first flow\"\n+        def flow1 = flowHelperV2.randomFlow(swP)\n+        flow1.source.vlanId = 10\n+        flow1.source.innerVlanId = 0\n+        flowHelperV2.addFlow(flow1)\n+\n+        and: \"Try to create a conflict flow\"\n+        def flow2 = flowHelperV2.randomFlow(swP)\n+        flow2.source.vlanId = 0\n+        flow2.source.innerVlanId = flow1.source.vlanId\n+        flow2.source.portNumber = flow1.source.portNumber\n+        northboundV2.addFlow(flow2)\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.CONFLICT\n+        exc.responseBodyAsString.to(MessageError).errorMessage == \"Could not create flow\"\n+\n+        and: \"Revert system to original state\"\n+        flowHelperV2.deleteFlow(flow1.flowId)\n+    }\n+\n+    def \"System allows to create more than one QinQ flow on the same port and with the same vlan\"() {\n+        given: \"Two switches connected to traffgen and enabled multiTable mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a first QinQ flow\"\n+        def flow1 = flowHelperV2.randomFlow(swP)\n+        flow1.source.innerVlanId = 300\n+        flow1.destination.innerVlanId = 400\n+        flowHelperV2.addFlow(flow1)\n+\n+        and: \"Create a second QinQ flow\"\n+        def flow2 = flowHelperV2.randomFlow(swP)\n+        flow2.source.vlanId = flow1.source.vlanId\n+        flow2.source.innerVlanId = flow1.destination.innerVlanId\n+        flow2.destination.vlanId = flow2.destination.vlanId\n+        flow2.destination.innerVlanId = flow1.source.innerVlanId\n+        flowHelperV2.addFlow(flow2)\n+\n+\n+        then: \"Both flow are valid and pingable\"\n+        [flow1.flowId, flow2.flowId].each { flowId ->\n+            northbound.validateFlow(flowId).each { assert it.asExpected }\n+            verifyAll(northbound.pingFlow(flowId, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        and: \"Flows allow traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def exam1 = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow1), 1000, 5)\n+        def exam2 = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow2), 1000, 5)\n+        withPool {\n+            [exam1.forward, exam1.reverse, exam2.forward, exam2.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        when: \"Delete the second flow\"\n+        flowHelperV2.deleteFlow(flow2.flowId)\n+\n+        then: \"The first flow is still valid and pingable\"\n+        northbound.validateFlow(flow1.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow1.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"The first flow still allows traffic\"\n+        withPool {\n+            [exam1.forward, exam1.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Cleanup: Delete the first flow\"\n+        flowHelperV2.deleteFlow(flow1.flowId)\n+    }\n+\n+    @Unroll\n+    def \"System allows to create a single-switch-port QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"A switch with enabled multiTable mode\"\n+        def sw = topology.activeSwitches.find { northbound.getSwitchProperties(it.dpId).multiTable } ?:\n+                assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a single switch QinQ flow\"\n+        def flow = flowHelperV2.singleSwitchSinglePortFlow(sw)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        with(pathHelper.getInvolvedSwitches(pathHelper.convert(northbound.getFlowPath(flow.flowId)))) {\n+            def validationInfo = northbound.validateSwitch(it.dpId)\n+            validationInfo.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            validationInfo.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        }\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+\n+        then: \"Flow rules are deleted\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+            assert northbound.getSwitchRules(sw.dpId).flowEntries*.cookie.sort() == sw.defaultCookies.sort()\n+        }\n+\n+        where:\n+        srcVlanId | srcInnerVlanId | dstVlanId | dstInnerVlanId\n+        10        | 20             | 30        | 40\n+        10        | 20             | 30        | 0\n+        10        | 20             | 0         | 0\n+        10        | 0              | 0         | 40\n+        0         | 20             | 30        | 0\n+        0         | 20             | 30        | 40\n+        0         | 0              | 30        | 40\n+    }\n+\n+    @Unroll\n+    @Tags(HARDWARE) //not tested\n+    def \"System allows to manipulate with QinQ vxlan flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"Two switches connected to traffgen and enabled multiTable mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable &&\n+                        sw.noviflow && !sw.wb5164\n+            } && it.paths.size() > 2\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a protected QinQ vxlan flow\"\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.encapsulationType = FlowEncapsulationType.VXLAN\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        flow.allocateProtectedPath = true\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        /** System doesn't allow to create a flow with innerVlan and without vlan at the same time.\n+         * for e.g.: when you create a flow with the following params:\n+         * vlan == 0 and innerVlan != 0,\n+         * then flow will be created with vlan != 0 and innerVlan == 0\n+         */\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Shared rule of flow is installed\"\n+        def srcSwSharedRulesAmount = northbound.getSwitchRules(swP.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        def dstSwSharedRulesAmount = northbound.getSwitchRules(swP.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        if (srcInnerVlanId > 0 || srcVlanId > 0) {\n+            assert srcSwSharedRulesAmount == 1\n+        } else {\n+            assert srcSwSharedRulesAmount == 0\n+        }\n+        if (dstInnerVlanId > 0 || dstVlanId > 0) {\n+            assert dstSwSharedRulesAmount == 1\n+        } else {\n+            assert dstSwSharedRulesAmount == 0\n+        }\n+\n+        and: \"The flow allows traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def examQinQFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow1 = pathHelper.getInvolvedSwitches(\n+                pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        )\n+        involvedSwitchesFlow1.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        when: \"Create a flow without QinQ on the same port\"\n+        // it is not working with APIv1, flows are invalid; change to v2 when 3432 is merged\n+        def flow2 = flowHelperV2.randomFlow(swP).tap {\n+            it.source.portNumber = flow.source.portNumber\n+            it.source.vlanId = flow.source.vlanId + 1\n+            it.destination.portNumber = flow.destination.portNumber\n+            it.destination.vlanId = flow.destination.vlanId + 1\n+        }\n+        flowHelperV2.addFlow(flow2)\n+\n+        then: \"Both existing flows are valid\"\n+        [flow.flowId, flow2.flowId].each {\n+            northbound.validateFlow(it).each { assert it.asExpected }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow2 = pathHelper.getInvolvedSwitches(pathHelper.convert(northbound.getFlowPath(flow2.flowId)))\n+        def involvedSwitchesforBothFlows = (involvedSwitchesFlow1 + involvedSwitchesFlow2).unique { it.dpId }\n+        involvedSwitchesforBothFlows.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        and: \"Both flows are pingable\"\n+        [flow.flowId, flow2.flowId].each {\n+            verifyAll(northbound.pingFlow(it, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        then: \"Both flows allow traffic\"\n+        def examSimpleFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow2), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse, examSimpleFlow.forward, examSimpleFlow.reverse]\n+                    .eachParallel { direction ->\n+                        def resources = traffExam.startExam(direction)\n+                        direction.setResources(resources)\n+                        assert traffExam.waitExam(direction).hasTraffic()\n+                    }\n+        }\n+\n+        when: \"Update the QinQ flow\"\n+        def updateResponse = flowHelperV2.updateFlow(flow.flowId, flow.tap {\n+            flow.source.vlanId = flow2.source.vlanId\n+            flow.source.innerVlanId = flow2.destination.vlanId\n+            flow.destination.vlanId = flow2.destination.vlanId\n+            flow.destination.innerVlanId = flow2.source.vlanId\n+        })\n+\n+        then: \"Update response contains correct info about innerVlanIds\"\n+        with(updateResponse) {\n+            it.source.vlanId == flow2.source.vlanId\n+            it.source.innerVlanId == flow2.destination.vlanId\n+            it.destination.vlanId == flow2.destination.vlanId\n+            it.destination.innerVlanId == flow2.source.vlanId\n+        }\n+\n+        and: \"Flow is really updated\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == flow2.source.vlanId\n+            it.source.innerVlanId == flow2.destination.vlanId\n+            it.destination.vlanId == flow2.destination.vlanId\n+            it.destination.innerVlanId == flow2.source.vlanId\n+        }\n+\n+        then: \"Both existing flows are still valid and pingable\"\n+        [flow.flowId, flow2.flowId].each {\n+            northbound.validateFlow(it).each { assert it.asExpected }\n+        }\n+\n+        [flow.flowId, flow2.flowId].each {\n+            verifyAll(northbound.pingFlow(it, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        when: \"Delete the flows\"\n+        [flow.flowId, flow2.flowId].each { flowHelperV2.deleteFlow(it) }\n+\n+        then: \"Flows rules are deleted\"\n+        involvedSwitchesforBothFlows.each { sw ->\n+            Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+                assert northbound.getSwitchRules(sw.dpId).flowEntries*.cookie.sort() == sw.defaultCookies.sort()\n+            }\n+        }\n+\n+        and: \"Shared rule of flow is deleted\"\n+        [swP.src.dpId, swP.dst.dpId].each { swId ->\n+            assert northbound.getSwitchRules(swId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+            }.empty\n+        }\n+\n+        where:\n+        srcVlanId | srcInnerVlanId | dstVlanId | dstInnerVlanId\n+        0         | 0              | 0         | 0\n+        10        | 20             | 30        | 40\n+        10        | 10             | 10        | 10\n+        10        | 0              | 0         | 40\n+        0         | 20             | 30        | 0\n+        10        | 20             | 0         | 0\n+        0         | 0              | 30        | 40\n+        10        | 20             | 30        | 0\n+        0         | 20             | 30        | 40", "originalCommit": "053a2ad50ac0c14d702c1aef1df0cd232c98f23b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkyNzA3Mw==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r425927073", "bodyText": "rules", "author": "rtretyak", "createdAt": "2020-05-15T16:51:04Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/QinQFlowSpec.groovy", "diffHunk": "@@ -0,0 +1,888 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static groovyx.gpars.GParsPool.withPool\n+import static org.junit.Assume.assumeTrue\n+import static org.openkilda.functionaltests.extension.tags.Tag.HARDWARE\n+import static org.openkilda.functionaltests.extension.tags.Tag.TOPOLOGY_DEPENDENT\n+import static org.openkilda.testing.Constants.RULES_INSTALLATION_TIME\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.extension.tags.Tags\n+import org.openkilda.functionaltests.helpers.SwitchHelper\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.command.switches.DeleteRulesAction\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.model.cookie.Cookie\n+import org.openkilda.model.cookie.CookieBase.CookieType\n+import org.openkilda.northbound.dto.v1.flows.PingInput\n+import org.openkilda.testing.service.traffexam.TraffExamService\n+import org.openkilda.testing.tools.FlowTrafficExamBuilder\n+\n+import org.springframework.beans.factory.annotation.Autowired\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Unroll\n+\n+import javax.inject.Provider\n+\n+class QinQFlowSpec extends HealthCheckSpecification {\n+\n+    @Autowired\n+    Provider<TraffExamService> traffExamProvider\n+\n+    @Unroll\n+    def \"System allows to manipulate with QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"Two switches connected to traffgen and enabled multiTable mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            } && it.paths.size() > 2\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a protected QinQ flow\"\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        flow.allocateProtectedPath = true\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        /** System doesn't allow to create a flow with innerVlan and without vlan at the same time.\n+         * for e.g.: when you create a flow with the following params:\n+         * vlan == 0 and innerVlan != 0,\n+         * then flow will be created with vlan != 0 and innerVlan == 0\n+         */\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Shared rule of flow is installed\"\n+        def srcSwSharedRulesAmount = northbound.getSwitchRules(swP.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        def dstSwSharedRulesAmount = northbound.getSwitchRules(swP.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        if (srcInnerVlanId > 0 || srcVlanId > 0) {\n+            assert srcSwSharedRulesAmount == 1\n+        } else {\n+            assert srcSwSharedRulesAmount == 0\n+        }\n+        if (dstInnerVlanId > 0 || dstVlanId > 0) {\n+            assert dstSwSharedRulesAmount == 1\n+        } else {\n+            assert dstSwSharedRulesAmount == 0\n+        }\n+\n+        and: \"The flow allows traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def examQinQFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow1 = pathHelper.getInvolvedSwitches(\n+                pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        )\n+        involvedSwitchesFlow1.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        when: \"Create a flow without QinQ on the same port\"\n+        // it is not working with APIv1, flows are invalid; change to v2 when 3432 is merged\n+        def flow2 = flowHelperV2.randomFlow(swP).tap {\n+            it.source.portNumber = flow.source.portNumber\n+            it.source.vlanId = flow.source.vlanId + 1\n+            it.destination.portNumber = flow.destination.portNumber\n+            it.destination.vlanId = flow.destination.vlanId + 1\n+        }\n+        flowHelperV2.addFlow(flow2)\n+\n+        then: \"Both existing flows are valid\"\n+        [flow.flowId, flow2.flowId].each {\n+            northbound.validateFlow(it).each { assert it.asExpected }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow2 = pathHelper.getInvolvedSwitches(pathHelper.convert(northbound.getFlowPath(flow2.flowId)))\n+        def involvedSwitchesforBothFlows = (involvedSwitchesFlow1 + involvedSwitchesFlow2).unique { it.dpId }\n+        involvedSwitchesforBothFlows.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        and: \"Both flows are pingable\"\n+        [flow.flowId, flow2.flowId].each {\n+            verifyAll(northbound.pingFlow(it, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        then: \"Both flows allow traffic\"\n+        def examSimpleFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow2), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse, examSimpleFlow.forward, examSimpleFlow.reverse]\n+                    .eachParallel { direction ->\n+                        def resources = traffExam.startExam(direction)\n+                        direction.setResources(resources)\n+                        assert traffExam.waitExam(direction).hasTraffic()\n+                    }\n+        }\n+\n+        when: \"Update the QinQ flow\"\n+        def updateResponse = flowHelperV2.updateFlow(flow.flowId, flow.tap {\n+            flow.source.vlanId = flow2.source.vlanId\n+            flow.source.innerVlanId = flow2.destination.vlanId\n+            flow.destination.vlanId = flow2.destination.vlanId\n+            flow.destination.innerVlanId = flow2.source.vlanId\n+        })\n+\n+        then: \"Update response contains correct info about innerVlanIds\"\n+        with(updateResponse) {\n+            it.source.vlanId == flow2.source.vlanId\n+            it.source.innerVlanId == flow2.destination.vlanId\n+            it.destination.vlanId == flow2.destination.vlanId\n+            it.destination.innerVlanId == flow2.source.vlanId\n+        }\n+\n+        and: \"Flow is really updated\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == flow2.source.vlanId\n+            it.source.innerVlanId == flow2.destination.vlanId\n+            it.destination.vlanId == flow2.destination.vlanId\n+            it.destination.innerVlanId == flow2.source.vlanId\n+        }\n+\n+        then: \"Both existing flows are still valid and pingable\"\n+        [flow.flowId, flow2.flowId].each {\n+            northbound.validateFlow(it).each { assert it.asExpected }\n+        }\n+\n+        [flow.flowId, flow2.flowId].each {\n+            verifyAll(northbound.pingFlow(it, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        when: \"Delete the flows\"\n+        [flow.flowId, flow2.flowId].each { flowHelperV2.deleteFlow(it) }\n+\n+        then: \"Flows rules are deleted\"\n+        involvedSwitchesforBothFlows.each { sw ->\n+            Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+                assert northbound.getSwitchRules(sw.dpId).flowEntries*.cookie.sort() == sw.defaultCookies.sort()\n+            }\n+        }\n+\n+        and: \"Shared rule of flow is deleted\"\n+        [swP.src.dpId, swP.dst.dpId].each { swId ->\n+            assert northbound.getSwitchRules(swId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+            }.empty\n+        }\n+\n+        where:\n+        srcVlanId | srcInnerVlanId | dstVlanId | dstInnerVlanId\n+        0         | 0              | 0         | 0\n+        10        | 20             | 30        | 40\n+        10        | 10             | 10        | 10\n+        10        | 0              | 0         | 40\n+        0         | 20             | 30        | 0\n+        10        | 20             | 0         | 0\n+        0         | 0              | 30        | 40\n+        10        | 20             | 30        | 0\n+        0         | 20             | 30        | 40\n+    }\n+\n+    @Unroll\n+    def \"System allows to create a single switch QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"A switch with enabled multiTable mode\"\n+        def sw = topology.activeSwitches.find { northbound.getSwitchProperties(it.dpId).multiTable } ?:\n+                assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a single switch QinQ flow\"\n+        def flow = flowHelperV2.singleSwitchFlow(sw)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Shared rule of flow is installed\"\n+        def expectedAmoutOfSharedRule = 0\n+        if (srcInnerVlanId > 0 || srcVlanId > 0) {\n+            expectedAmoutOfSharedRule += 1\n+        }\n+        if (dstInnerVlanId > 0 || dstVlanId > 0) {\n+            expectedAmoutOfSharedRule += 1\n+        }\n+        northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size() == expectedAmoutOfSharedRule\n+\n+        and: \"Involved switches pass switch validation\"\n+        with(pathHelper.getInvolvedSwitches(pathHelper.convert(northbound.getFlowPath(flow.flowId)))) {\n+            def validationInfo = northbound.validateSwitch(it.dpId)\n+            validationInfo.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            validationInfo.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        }\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+\n+        then: \"Flow rules are deleted\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+            assert northbound.getSwitchRules(sw.dpId).flowEntries*.cookie.sort() == sw.defaultCookies.sort()\n+        }\n+        northbound.getSwitchRules(sw.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.empty\n+\n+        where:\n+        srcVlanId | srcInnerVlanId | dstVlanId | dstInnerVlanId\n+        0         | 0              | 0         | 0\n+        10        | 20             | 30        | 40\n+        10        | 10             | 10        | 10\n+        10        | 0              | 0         | 40\n+        0         | 20             | 30        | 0\n+        10        | 20             | 0         | 0\n+        0         | 0              | 30        | 40\n+        10        | 20             | 30        | 0\n+        0         | 20             | 30        | 40\n+    }\n+\n+    @Tags(TOPOLOGY_DEPENDENT)\n+    def \"System doesn't allow to create a QinQ flow when a switch supports multi table mode but it is disabled\"() {\n+        given: \"A switch pair with disabled multi table mode at least on the one switch\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].any { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+        def initSrcSwProps = northbound.getSwitchProperties(swP.src.dpId)\n+        SwitchHelper.updateSwitchProperties(swP.src, initSrcSwProps.jacksonCopy().tap {\n+            it.multiTable = false\n+        })\n+        when: \"Try to create a QinQ flow when at least on switch doesn't support multi table mode\"\n+\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.innerVlanId = 4093\n+        flow.destination.innerVlanId = 3904\n+        northboundV2.addFlow(flow)\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        exc.responseBodyAsString.to(MessageError).errorMessage == \"Could not create flow\"\n+\n+        cleanup: \"Revert system to original state\"\n+        northbound.updateSwitchProperties(swP.src.dpId, initSrcSwProps)\n+        Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+            assert northbound.getSwitchRules(swP.src.dpId).flowEntries*.cookie.sort() == swP.src.defaultCookies.sort()\n+        }\n+        SwitchHelper.updateSwitchProperties(swP.src, initSrcSwProps)\n+    }\n+\n+    @Unroll\n+    def \"System doesn't allow to create a QinQ flow with incorrect innerVlanIds\\\n+(src:#srcInnerVlanId, dst:#dstInnerVlanId)\"() {\n+        when: \"Try to create a QinQ flow with incorrect innerVlanId\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        northboundV2.addFlow(flow)\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.BAD_REQUEST\n+        exc.responseBodyAsString.to(MessageError).errorMessage == \"Invalid request payload\"\n+\n+        where:\n+        srcInnerVlanId | dstInnerVlanId\n+        4096           | 10\n+        10             | -1\n+    }\n+\n+    @Ignore(\"wait 3432\")\n+    def \"System doesn't allow to create a QinQ flow via APIv1\"() {\n+        given: \"Two switches with enabled multi table mode\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a QinQ flow via APIv1\"\n+        def flowV1 = flowHelper.randomFlow(swP)\n+        flowV1.source.innerVlanId = 100\n+        flowV1.destination.innerVlanId = 200\n+        northbound.addFlow(flowV1)\n+\n+        then: \"Human readable error is returned\"\n+        def eCreate = thrown(HttpClientErrorException)\n+        eCreate.statusCode == HttpStatus.BAD_REQUEST\n+        eCreate.responseBodyAsString.to(MessageError).errorMessage.contains(\"Could not create flow\")\n+    }\n+\n+    @Ignore\n+    def \"System doesn't allow to update/delete a QinQ flow via APIv1\"() {\n+        given: \"Two switches with enabled multi table mode\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a QinQ flow via APIv2\"\n+        def flowV2 = flowHelperV2.randomFlow(swP)\n+        flowV2.source.innerVlanId = 234\n+        flowV2.destination.innerVlanId = 432\n+        northboundV2.addFlow(flowV2)\n+\n+        and: \"Try to update the flow via APIv1\"\n+        flowHelperV2.updateFlow(flowV2.flowId, flowV2.tap { flowV2.source.innerVlanId += 1 })\n+\n+        then: \"Human readable error is returned\"\n+        def eUpdate = thrown(HttpClientErrorException)\n+        eUpdate.statusCode == HttpStatus.BAD_REQUEST\n+        eUpdate.responseBodyAsString.to(MessageError).errorMessage.contains(\"Could not update flow\")\n+\n+        when: \"Try to delete the flow via APIv1\"\n+        northbound.deleteFlow(flowV2.flowId)\n+\n+        then: \"Human readable error is returned\"\n+        def eDelete = thrown(HttpClientErrorException)\n+        eDelete.statusCode == HttpStatus.BAD_REQUEST\n+        eDelete.responseBodyAsString.to(MessageError).errorMessage.contains(\"Could not delete flow\")\n+\n+        cleanup:\n+        flowV2 && flowHelperV2.deleteFlow(flowV2.flowId)\n+    }\n+\n+    def \"System allows to create QinQ flow and flow without QnQ with the same vlan on the same port\"() {\n+        given: \"Two switches with enabled multi table mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a QinQ flow\"\n+        def flowWithQinQ = flowHelperV2.randomFlow(swP)\n+        flowWithQinQ.source.innerVlanId = 234\n+        flowWithQinQ.destination.innerVlanId = 432\n+        flowHelperV2.addFlow(flowWithQinQ)\n+\n+        and: \"Create a flow without QinQ\"\n+        def flowWithoutQinQ = flowHelperV2.randomFlow(swP)\n+        flowWithoutQinQ.source.vlanId = 0\n+        flowWithoutQinQ.source.innerVlanId = flowWithQinQ.source.vlanId\n+        flowHelperV2.addFlow(flowWithoutQinQ)\n+\n+        then: \"Both flows allow traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def examFlowWithtQinQ = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flowWithQinQ), 1000, 5)\n+        def examFlowWithoutQinQ = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flowWithoutQinQ), 1000, 5)\n+        withPool {\n+            [examFlowWithtQinQ.forward, examFlowWithtQinQ.reverse,\n+             examFlowWithoutQinQ.forward, examFlowWithoutQinQ.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Revert system to original state\"\n+        [flowWithQinQ, flowWithoutQinQ].each { flowHelperV2.deleteFlow(it.flowId) }\n+    }\n+\n+    def \"System detects conflict QinQ flows\"() {\n+        given: \"Two switches with enabled multi table mode\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { northbound.getSwitchProperties(it.dpId).multiTable }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a first flow\"\n+        def flow1 = flowHelperV2.randomFlow(swP)\n+        flow1.source.vlanId = 10\n+        flow1.source.innerVlanId = 0\n+        flowHelperV2.addFlow(flow1)\n+\n+        and: \"Try to create a conflict flow\"\n+        def flow2 = flowHelperV2.randomFlow(swP)\n+        flow2.source.vlanId = 0\n+        flow2.source.innerVlanId = flow1.source.vlanId\n+        flow2.source.portNumber = flow1.source.portNumber\n+        northboundV2.addFlow(flow2)\n+\n+        then: \"Human readable error is returned\"\n+        def exc = thrown(HttpClientErrorException)\n+        exc.statusCode == HttpStatus.CONFLICT\n+        exc.responseBodyAsString.to(MessageError).errorMessage == \"Could not create flow\"\n+\n+        and: \"Revert system to original state\"\n+        flowHelperV2.deleteFlow(flow1.flowId)\n+    }\n+\n+    def \"System allows to create more than one QinQ flow on the same port and with the same vlan\"() {\n+        given: \"Two switches connected to traffgen and enabled multiTable mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a first QinQ flow\"\n+        def flow1 = flowHelperV2.randomFlow(swP)\n+        flow1.source.innerVlanId = 300\n+        flow1.destination.innerVlanId = 400\n+        flowHelperV2.addFlow(flow1)\n+\n+        and: \"Create a second QinQ flow\"\n+        def flow2 = flowHelperV2.randomFlow(swP)\n+        flow2.source.vlanId = flow1.source.vlanId\n+        flow2.source.innerVlanId = flow1.destination.innerVlanId\n+        flow2.destination.vlanId = flow2.destination.vlanId\n+        flow2.destination.innerVlanId = flow1.source.innerVlanId\n+        flowHelperV2.addFlow(flow2)\n+\n+\n+        then: \"Both flow are valid and pingable\"\n+        [flow1.flowId, flow2.flowId].each { flowId ->\n+            northbound.validateFlow(flowId).each { assert it.asExpected }\n+            verifyAll(northbound.pingFlow(flowId, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        and: \"Flows allow traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def exam1 = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow1), 1000, 5)\n+        def exam2 = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow2), 1000, 5)\n+        withPool {\n+            [exam1.forward, exam1.reverse, exam2.forward, exam2.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        when: \"Delete the second flow\"\n+        flowHelperV2.deleteFlow(flow2.flowId)\n+\n+        then: \"The first flow is still valid and pingable\"\n+        northbound.validateFlow(flow1.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow1.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"The first flow still allows traffic\"\n+        withPool {\n+            [exam1.forward, exam1.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Cleanup: Delete the first flow\"\n+        flowHelperV2.deleteFlow(flow1.flowId)\n+    }\n+\n+    @Unroll\n+    def \"System allows to create a single-switch-port QinQ flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"A switch with enabled multiTable mode\"\n+        def sw = topology.activeSwitches.find { northbound.getSwitchProperties(it.dpId).multiTable } ?:\n+                assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a single switch QinQ flow\"\n+        def flow = flowHelperV2.singleSwitchSinglePortFlow(sw)\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        with(pathHelper.getInvolvedSwitches(pathHelper.convert(northbound.getFlowPath(flow.flowId)))) {\n+            def validationInfo = northbound.validateSwitch(it.dpId)\n+            validationInfo.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            validationInfo.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        }\n+\n+        when: \"Delete the flow\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+\n+        then: \"Flow rules are deleted\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+            assert northbound.getSwitchRules(sw.dpId).flowEntries*.cookie.sort() == sw.defaultCookies.sort()\n+        }\n+\n+        where:\n+        srcVlanId | srcInnerVlanId | dstVlanId | dstInnerVlanId\n+        10        | 20             | 30        | 40\n+        10        | 20             | 30        | 0\n+        10        | 20             | 0         | 0\n+        10        | 0              | 0         | 40\n+        0         | 20             | 30        | 0\n+        0         | 20             | 30        | 40\n+        0         | 0              | 30        | 40\n+    }\n+\n+    @Unroll\n+    @Tags(HARDWARE) //not tested\n+    def \"System allows to manipulate with QinQ vxlan flow\\\n+(srcVlanId: #srcVlanId, srcInnerVlanId: #srcInnerVlanId, dstVlanId: #dstVlanId, dstInnerVlanId: #dstInnerVlanId)\"() {\n+        given: \"Two switches connected to traffgen and enabled multiTable mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable &&\n+                        sw.noviflow && !sw.wb5164\n+            } && it.paths.size() > 2\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        when: \"Create a protected QinQ vxlan flow\"\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.encapsulationType = FlowEncapsulationType.VXLAN\n+        flow.source.vlanId = srcVlanId\n+        flow.source.innerVlanId = srcInnerVlanId\n+        flow.destination.vlanId = dstVlanId\n+        flow.destination.innerVlanId = dstInnerVlanId\n+        flow.allocateProtectedPath = true\n+        def response = flowHelperV2.addFlow(flow)\n+\n+        then: \"Response contains correct info about innerVlanIds\"\n+        /** System doesn't allow to create a flow with innerVlan and without vlan at the same time.\n+         * for e.g.: when you create a flow with the following params:\n+         * vlan == 0 and innerVlan != 0,\n+         * then flow will be created with vlan != 0 and innerVlan == 0\n+         */\n+        with(response) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is really created with requested innerVlanIds\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == (srcVlanId ? srcVlanId : srcInnerVlanId)\n+            it.source.innerVlanId == (srcVlanId ? srcInnerVlanId : 0)\n+            it.destination.vlanId == (dstVlanId ? dstVlanId : dstInnerVlanId)\n+            it.destination.innerVlanId == (dstVlanId ? dstInnerVlanId : 0)\n+        }\n+\n+        and: \"Flow is valid and pingable\"\n+        northbound.validateFlow(flow.flowId).each { assert it.asExpected }\n+        verifyAll(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        and: \"Shared rule of flow is installed\"\n+        def srcSwSharedRulesAmount = northbound.getSwitchRules(swP.src.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        def dstSwSharedRulesAmount = northbound.getSwitchRules(swP.dst.dpId).flowEntries.findAll {\n+            new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+        }.size()\n+        if (srcInnerVlanId > 0 || srcVlanId > 0) {\n+            assert srcSwSharedRulesAmount == 1\n+        } else {\n+            assert srcSwSharedRulesAmount == 0\n+        }\n+        if (dstInnerVlanId > 0 || dstVlanId > 0) {\n+            assert dstSwSharedRulesAmount == 1\n+        } else {\n+            assert dstSwSharedRulesAmount == 0\n+        }\n+\n+        and: \"The flow allows traffic\"\n+        def traffExam = traffExamProvider.get()\n+        def examQinQFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow1 = pathHelper.getInvolvedSwitches(\n+                pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        )\n+        involvedSwitchesFlow1.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        when: \"Create a flow without QinQ on the same port\"\n+        // it is not working with APIv1, flows are invalid; change to v2 when 3432 is merged\n+        def flow2 = flowHelperV2.randomFlow(swP).tap {\n+            it.source.portNumber = flow.source.portNumber\n+            it.source.vlanId = flow.source.vlanId + 1\n+            it.destination.portNumber = flow.destination.portNumber\n+            it.destination.vlanId = flow.destination.vlanId + 1\n+        }\n+        flowHelperV2.addFlow(flow2)\n+\n+        then: \"Both existing flows are valid\"\n+        [flow.flowId, flow2.flowId].each {\n+            northbound.validateFlow(it).each { assert it.asExpected }\n+        }\n+\n+        and: \"Involved switches pass switch validation\"\n+        def involvedSwitchesFlow2 = pathHelper.getInvolvedSwitches(pathHelper.convert(northbound.getFlowPath(flow2.flowId)))\n+        def involvedSwitchesforBothFlows = (involvedSwitchesFlow1 + involvedSwitchesFlow2).unique { it.dpId }\n+        involvedSwitchesforBothFlows.each {\n+            with(northbound.validateSwitch(it.dpId)) { validation ->\n+                validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+            }\n+        }\n+\n+        and: \"Both flows are pingable\"\n+        [flow.flowId, flow2.flowId].each {\n+            verifyAll(northbound.pingFlow(it, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        then: \"Both flows allow traffic\"\n+        def examSimpleFlow = new FlowTrafficExamBuilder(topology, traffExam)\n+                .buildBidirectionalExam(flowHelperV2.toV1(flow2), 1000, 5)\n+        withPool {\n+            [examQinQFlow.forward, examQinQFlow.reverse, examSimpleFlow.forward, examSimpleFlow.reverse]\n+                    .eachParallel { direction ->\n+                        def resources = traffExam.startExam(direction)\n+                        direction.setResources(resources)\n+                        assert traffExam.waitExam(direction).hasTraffic()\n+                    }\n+        }\n+\n+        when: \"Update the QinQ flow\"\n+        def updateResponse = flowHelperV2.updateFlow(flow.flowId, flow.tap {\n+            flow.source.vlanId = flow2.source.vlanId\n+            flow.source.innerVlanId = flow2.destination.vlanId\n+            flow.destination.vlanId = flow2.destination.vlanId\n+            flow.destination.innerVlanId = flow2.source.vlanId\n+        })\n+\n+        then: \"Update response contains correct info about innerVlanIds\"\n+        with(updateResponse) {\n+            it.source.vlanId == flow2.source.vlanId\n+            it.source.innerVlanId == flow2.destination.vlanId\n+            it.destination.vlanId == flow2.destination.vlanId\n+            it.destination.innerVlanId == flow2.source.vlanId\n+        }\n+\n+        and: \"Flow is really updated\"\n+        with(northbound.getFlow(flow.flowId)) {\n+            it.source.vlanId == flow2.source.vlanId\n+            it.source.innerVlanId == flow2.destination.vlanId\n+            it.destination.vlanId == flow2.destination.vlanId\n+            it.destination.innerVlanId == flow2.source.vlanId\n+        }\n+\n+        then: \"Both existing flows are still valid and pingable\"\n+        [flow.flowId, flow2.flowId].each {\n+            northbound.validateFlow(it).each { assert it.asExpected }\n+        }\n+\n+        [flow.flowId, flow2.flowId].each {\n+            verifyAll(northbound.pingFlow(it, new PingInput())) {\n+                it.forward.pingSuccess\n+                it.reverse.pingSuccess\n+            }\n+        }\n+\n+        when: \"Delete the flows\"\n+        [flow.flowId, flow2.flowId].each { flowHelperV2.deleteFlow(it) }\n+\n+        then: \"Flows rules are deleted\"\n+        involvedSwitchesforBothFlows.each { sw ->\n+            Wrappers.wait(RULES_INSTALLATION_TIME, 1) {\n+                assert northbound.getSwitchRules(sw.dpId).flowEntries*.cookie.sort() == sw.defaultCookies.sort()\n+            }\n+        }\n+\n+        and: \"Shared rule of flow is deleted\"\n+        [swP.src.dpId, swP.dst.dpId].each { swId ->\n+            assert northbound.getSwitchRules(swId).flowEntries.findAll {\n+                new Cookie(it.cookie).getType() == CookieType.SHARED_OF_FLOW\n+            }.empty\n+        }\n+\n+        where:\n+        srcVlanId | srcInnerVlanId | dstVlanId | dstInnerVlanId\n+        0         | 0              | 0         | 0\n+        10        | 20             | 30        | 40\n+        10        | 10             | 10        | 10\n+        10        | 0              | 0         | 40\n+        0         | 20             | 30        | 0\n+        10        | 20             | 0         | 0\n+        0         | 0              | 30        | 40\n+        10        | 20             | 30        | 0\n+        0         | 20             | 30        | 40\n+    }\n+\n+    @Ignore(\"https://github.com/telstra/open-kilda/issues/3477\")\n+    @Tidy\n+    def \"System is able to synchronize switch(flow rules)\"() {\n+        given: \"Two switches connected to traffgen and enabled multiTable mode\"\n+        def allTraffGenSwitches = topology.activeTraffGens*.switchConnected\n+        assumeTrue(\"Unable to find required switches in topology\", (allTraffGenSwitches.size() > 1))\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffGenSwitches*.dpId && northbound.getSwitchProperties(sw.dpId).multiTable\n+            }\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        and: \"A QinQ flow on the given switches\"\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flow.maximumBandwidth = 100\n+        flow.source.innerVlanId = 600\n+        flow.destination.innerVlanId = 700\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Delete all flow rules(ingress/egress/shared) on the src switch\"\n+        northbound.deleteSwitchRules(swP.src.dpId, DeleteRulesAction.DROP_ALL_ADD_DEFAULTS)\n+\n+        then: \"System detects missing rule on the src switch\"", "originalCommit": "053a2ad50ac0c14d702c1aef1df0cd232c98f23b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjYzNzg4MA==", "url": "https://github.com/telstra/open-kilda/pull/3466#discussion_r426637880", "bodyText": "fixed", "author": "andriidovhan", "createdAt": "2020-05-18T13:46:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkyNzA3Mw=="}], "type": "inlineReview"}, {"oid": "eddf1bf28b451739303fcf57b3766e3dbed4681d", "url": "https://github.com/telstra/open-kilda/commit/eddf1bf28b451739303fcf57b3766e3dbed4681d", "message": "adjust connectedDevices work with qinq and add test", "committedDate": "2020-05-18T07:23:51Z", "type": "forcePushed"}, {"oid": "cac4e4738f580145621d48890f7cd38016f44483", "url": "https://github.com/telstra/open-kilda/commit/cac4e4738f580145621d48890f7cd38016f44483", "message": "adjust connectedDevices work with qinq and add test", "committedDate": "2020-05-18T07:59:40Z", "type": "forcePushed"}, {"oid": "2be00881e5fc38ba0d32ed4983132242295da1b3", "url": "https://github.com/telstra/open-kilda/commit/2be00881e5fc38ba0d32ed4983132242295da1b3", "message": "adjust connectedDevices work with qinq and add test", "committedDate": "2020-05-18T09:31:42Z", "type": "forcePushed"}, {"oid": "419fd2710c6fa6fd8e2334c780ecc917d490fb4f", "url": "https://github.com/telstra/open-kilda/commit/419fd2710c6fa6fd8e2334c780ecc917d490fb4f", "message": "fix", "committedDate": "2020-05-18T14:40:17Z", "type": "forcePushed"}, {"oid": "39859ce9fd26748c5352958868eaf337fe73efa2", "url": "https://github.com/telstra/open-kilda/commit/39859ce9fd26748c5352958868eaf337fe73efa2", "message": "adjust connectedDevices work with qinq and add test", "committedDate": "2020-05-18T14:44:58Z", "type": "forcePushed"}, {"oid": "428f0ad7fdd0768926d0ed48b985afa61b5a68a2", "url": "https://github.com/telstra/open-kilda/commit/428f0ad7fdd0768926d0ed48b985afa61b5a68a2", "message": "adjust connectedDevices work with qinq and add test", "committedDate": "2020-05-19T06:47:01Z", "type": "forcePushed"}, {"oid": "3b177268e526f3591b87d8121b33437c973bb3d3", "url": "https://github.com/telstra/open-kilda/commit/3b177268e526f3591b87d8121b33437c973bb3d3", "message": "adjust connectedDevices work with qinq and add test", "committedDate": "2020-05-19T07:50:08Z", "type": "forcePushed"}, {"oid": "c24461f66cc539b00d81a11a080bc63ce9aedf8e", "url": "https://github.com/telstra/open-kilda/commit/c24461f66cc539b00d81a11a080bc63ce9aedf8e", "message": "fix SwitchSyncSpec", "committedDate": "2020-05-20T06:18:33Z", "type": "forcePushed"}, {"oid": "f0dc9bd6980bc7a35590b9b70c24d1b9431a91c0", "url": "https://github.com/telstra/open-kilda/commit/f0dc9bd6980bc7a35590b9b70c24d1b9431a91c0", "message": "fix MetersSpec.groovy", "committedDate": "2020-05-21T14:55:43Z", "type": "forcePushed"}, {"oid": "6c9bcafa7cafabb73904c570e8ea912eb49b6028", "url": "https://github.com/telstra/open-kilda/commit/6c9bcafa7cafabb73904c570e8ea912eb49b6028", "message": "fix MetersSpec.groovy", "committedDate": "2020-05-22T07:28:05Z", "type": "forcePushed"}, {"oid": "4f0d7d440d5c863bed114857b6591394c3cfa641", "url": "https://github.com/telstra/open-kilda/commit/4f0d7d440d5c863bed114857b6591394c3cfa641", "message": "fix errorMessages in tests for APIv1", "committedDate": "2020-05-22T14:01:18Z", "type": "forcePushed"}, {"oid": "296daf728e7a0cf75683af841113acc5faebd654", "url": "https://github.com/telstra/open-kilda/commit/296daf728e7a0cf75683af841113acc5faebd654", "message": "fix errorMessages in tests for APIv1", "committedDate": "2020-05-22T14:19:24Z", "type": "forcePushed"}, {"oid": "a735210af1cd2a99f1a19452f75c19933048394c", "url": "https://github.com/telstra/open-kilda/commit/a735210af1cd2a99f1a19452f75c19933048394c", "message": "fix errorMessages in tests for APIv1", "committedDate": "2020-05-22T19:20:26Z", "type": "forcePushed"}, {"oid": "9bc3b4c94d82383e42cc92fc67e0895ddbba0fc5", "url": "https://github.com/telstra/open-kilda/commit/9bc3b4c94d82383e42cc92fc67e0895ddbba0fc5", "message": "fix errorMessages in tests for APIv1", "committedDate": "2020-05-26T14:57:23Z", "type": "forcePushed"}, {"oid": "fd130a5582bf2c8d3f47d11017770f539dd98b41", "url": "https://github.com/telstra/open-kilda/commit/fd130a5582bf2c8d3f47d11017770f539dd98b41", "message": "fix errorMessages in tests for APIv1", "committedDate": "2020-05-26T17:28:25Z", "type": "forcePushed"}, {"oid": "6c97d1f634bdd0ba8a8afd7d05404dd98bbfd169", "url": "https://github.com/telstra/open-kilda/commit/6c97d1f634bdd0ba8a8afd7d05404dd98bbfd169", "message": "fix errorMessages in tests for APIv1", "committedDate": "2020-05-27T03:52:02Z", "type": "forcePushed"}, {"oid": "a54667e1d31364dc15edf05f7f76e5812813d7b2", "url": "https://github.com/telstra/open-kilda/commit/a54667e1d31364dc15edf05f7f76e5812813d7b2", "message": "Dispatch v1 flow create to flow hs\n\n- changed worker for flow v1 create request\n- fixed compile time warnings", "committedDate": "2020-05-27T07:09:53Z", "type": "commit"}, {"oid": "e9e0e4fe07ca62d176c27759c1f7ca52718e448a", "url": "https://github.com/telstra/open-kilda/commit/e9e0e4fe07ca62d176c27759c1f7ca52718e448a", "message": "(func-test-incompatibility)", "committedDate": "2020-05-27T07:09:53Z", "type": "commit"}, {"oid": "587ded3aa33ca55dd8391aa931232c54a2f801a0", "url": "https://github.com/telstra/open-kilda/commit/587ded3aa33ca55dd8391aa931232c54a2f801a0", "message": "(func-tests-incompatibility)", "committedDate": "2020-05-27T07:09:53Z", "type": "commit"}, {"oid": "7bafe09b26010ed2e691ecb72cf10beac358c225", "url": "https://github.com/telstra/open-kilda/commit/7bafe09b26010ed2e691ecb72cf10beac358c225", "message": "(func-tests-incompatibility)", "committedDate": "2020-05-27T07:09:53Z", "type": "commit"}, {"oid": "8e9e4eff8509bd8610b00c2a982cbfd97f5c7535", "url": "https://github.com/telstra/open-kilda/commit/8e9e4eff8509bd8610b00c2a982cbfd97f5c7535", "message": "adjust test framework to work with list of vlans", "committedDate": "2020-05-27T07:09:53Z", "type": "commit"}, {"oid": "f5a84119f77ae2c22c0eecca572ab9277818c90e", "url": "https://github.com/telstra/open-kilda/commit/f5a84119f77ae2c22c0eecca572ab9277818c90e", "message": "add QinQFlow spec", "committedDate": "2020-05-27T07:09:53Z", "type": "commit"}, {"oid": "e759339c695e1fb5294e4d9118d289825a3609ce", "url": "https://github.com/telstra/open-kilda/commit/e759339c695e1fb5294e4d9118d289825a3609ce", "message": "delete duplicated test", "committedDate": "2020-05-27T07:09:53Z", "type": "commit"}, {"oid": "a307ae9bb3d3503e79b863eb9d4e6b6c982e94f2", "url": "https://github.com/telstra/open-kilda/commit/a307ae9bb3d3503e79b863eb9d4e6b6c982e94f2", "message": "test traffic for vlan/default/qinq flows at the same time", "committedDate": "2020-05-27T07:09:53Z", "type": "commit"}, {"oid": "b1078c76b2ea239469dd15219baf9a72938d7a63", "url": "https://github.com/telstra/open-kilda/commit/b1078c76b2ea239469dd15219baf9a72938d7a63", "message": "add test for issue 3472", "committedDate": "2020-05-27T07:09:53Z", "type": "commit"}, {"oid": "a8163f92872fc3a682b5a9d5d4485d308d884045", "url": "https://github.com/telstra/open-kilda/commit/a8163f92872fc3a682b5a9d5d4485d308d884045", "message": "add test swap endpoints qinq", "committedDate": "2020-05-27T07:12:52Z", "type": "commit"}, {"oid": "e13393d95b337c57885aeb9a0dc326995cf22323", "url": "https://github.com/telstra/open-kilda/commit/e13393d95b337c57885aeb9a0dc326995cf22323", "message": "adjust connectedDevices work with qinq and add test", "committedDate": "2020-05-27T07:12:52Z", "type": "commit"}, {"oid": "d119a04b81dfe61b77bf1a5f2d287335328fcb46", "url": "https://github.com/telstra/open-kilda/commit/d119a04b81dfe61b77bf1a5f2d287335328fcb46", "message": "update SwitchHelper(ignore shared rule)", "committedDate": "2020-05-27T07:12:52Z", "type": "commit"}, {"oid": "40f08cfe41c8ab6b396a930635a318314e2dab53", "url": "https://github.com/telstra/open-kilda/commit/40f08cfe41c8ab6b396a930635a318314e2dab53", "message": "fix MetersSpec", "committedDate": "2020-05-27T07:12:52Z", "type": "commit"}, {"oid": "ac87020d079c1b986d834abf0af9c6d1912dae8c", "url": "https://github.com/telstra/open-kilda/commit/ac87020d079c1b986d834abf0af9c6d1912dae8c", "message": "fix errorMessages in tests for APIv1", "committedDate": "2020-05-27T07:22:33Z", "type": "forcePushed"}, {"oid": "d45e50a429badf6daf6948dcadf6f03d43b0d8a5", "url": "https://github.com/telstra/open-kilda/commit/d45e50a429badf6daf6948dcadf6f03d43b0d8a5", "message": "fix errorMessages in tests for APIv1", "committedDate": "2020-05-27T10:47:26Z", "type": "forcePushed"}, {"oid": "fa2f189eac6cea8bf38ce17c7d3567e09973b671", "url": "https://github.com/telstra/open-kilda/commit/fa2f189eac6cea8bf38ce17c7d3567e09973b671", "message": "fix errorMessages in tests for APIv1", "committedDate": "2020-05-27T11:50:47Z", "type": "commit"}, {"oid": "fa2f189eac6cea8bf38ce17c7d3567e09973b671", "url": "https://github.com/telstra/open-kilda/commit/fa2f189eac6cea8bf38ce17c7d3567e09973b671", "message": "fix errorMessages in tests for APIv1", "committedDate": "2020-05-27T11:50:47Z", "type": "forcePushed"}]}