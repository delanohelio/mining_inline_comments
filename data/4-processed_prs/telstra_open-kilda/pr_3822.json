{"pr_number": 3822, "pr_title": "Add func tests for protected flow + max_latency", "pr_createdAt": "2020-11-03T11:02:31Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3822", "timeline": [{"oid": "e6d6bc75e0d03e0949512cacb6598c1459a78181", "url": "https://github.com/telstra/open-kilda/commit/e6d6bc75e0d03e0949512cacb6598c1459a78181", "message": "Add func tests for protected flow + max_latency\n\n- reveal #3821\n- change order of features in ProtectedPathV2Spec (no actual changes)\n- cleanup verifier now behaves differently if spec has 'cleanupSpec' fixture", "committedDate": "2020-11-03T11:14:37Z", "type": "forcePushed"}, {"oid": "4c74eab337197354a0f7030e9db6985ce4948457", "url": "https://github.com/telstra/open-kilda/commit/4c74eab337197354a0f7030e9db6985ce4948457", "message": "Add func tests for protected flow + max_latency\n\n- reveal #3821\n- change order of features in ProtectedPathV2Spec (no actual changes)\n- cleanup verifier now behaves differently if spec has 'cleanupSpec' fixture", "committedDate": "2020-11-03T11:18:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYxMTExMw==", "url": "https://github.com/telstra/open-kilda/pull/3822#discussion_r516611113", "bodyText": "I would check that all links are UP\nWrappers.wait(discoveryInterval + WAIT_OFFSET) {\n            assert northbound.getActiveLinks().size() == topology.islsForActiveSwitches.size() * 2\n        }", "author": "andriidovhan", "createdAt": "2020-11-03T11:52:54Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathMaxLatencySpec.groovy", "diffHunk": "@@ -0,0 +1,112 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static org.junit.Assume.assumeTrue\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.helpers.model.SwitchPair\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.messaging.info.event.PathNode\n+import org.openkilda.model.PathComputationStrategy\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Shared\n+import spock.lang.Unroll\n+\n+class ProtectedPathMaxLatencySpec extends HealthCheckSpecification {\n+    @Shared List<PathNode> mainPath, protectedPath\n+    @Shared List<Isl> mainIsls, protectedIsls, islsToBreak\n+    @Shared SwitchPair switchPair\n+\n+    def setupOnce() {\n+        //setup: Two active switches with two diverse paths\n+        List<List<PathNode>> paths\n+        switchPair = topologyHelper.switchPairs.find {\n+            paths = it.paths.unique(false) { a, b -> a.intersect(b) == [] ? 1 : 0 }\n+            paths.size() >= 2\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+        mainPath = paths[0]\n+        protectedPath = paths[1]\n+        mainIsls = pathHelper.getInvolvedIsls(mainPath)\n+        protectedIsls = pathHelper.getInvolvedIsls(protectedPath)\n+        //deactivate other paths for more clear experiment\n+        def isls = mainIsls + protectedIsls\n+        islsToBreak = switchPair.paths.findAll { !paths.contains(it) }\n+                                    .collect { pathHelper.getInvolvedIsls(it).find {!isls.contains(it) && !isls.contains(it.reversed) } }\n+                                    .unique { [it, it.reversed].sort() }\n+        islsToBreak.each { antiflap.portDown(it.srcSwitch.dpId, it.srcPort) }\n+    }\n+\n+    @Tidy\n+    @Ignore(\"https://github.com/telstra/open-kilda/issues/3821\")\n+    def \"Able to create protected flow with max_latency strategy if both paths satisfy SLA\"() {\n+        given: \"2 non-overlapping paths with 10 and 9 latency\"\n+        setLatencyForPaths(10, 9)\n+\n+        when: \"Create a flow with protected path and max_latency 11\"\n+        def flow = flowHelperV2.randomFlow(switchPair).tap {\n+            allocateProtectedPath = true\n+            maxLatency = 11\n+            pathComputationStrategy = PathComputationStrategy.MAX_LATENCY.toString()\n+        }\n+        flowHelperV2.addFlow(flow)\n+\n+        then: \"Flow is created, main path is the 10 latency path, protected is 9 latency\"\n+        def path = northbound.getFlowPath(flow.flowId)\n+        pathHelper.convert(path) == mainPath\n+        pathHelper.convert(path.protectedPath) == protectedPath\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+    }\n+\n+    @Tidy\n+    @Unroll\n+    def \"Unable to create protected flow with max_latency strategy if #condition\"() {\n+        given: \"2 non-overlapping paths with 10 and 9 latency\"\n+        setLatencyForPaths(10, 9)\n+\n+        when: \"Create a flow with protected path and max_latency #testMaxLatency\"\n+        def flow = flowHelperV2.randomFlow(switchPair).tap {\n+            allocateProtectedPath = true\n+            maxLatency = testMaxLatency\n+            pathComputationStrategy = PathComputationStrategy.MAX_LATENCY.toString()\n+        }\n+        flowHelperV2.addFlow(flow)\n+\n+        then: \"Flow is not created, error returned describing that no paths found\"\n+        def e = thrown(HttpClientErrorException)\n+        e.statusCode == HttpStatus.NOT_FOUND\n+        def errorDetails = e.responseBodyAsString.to(MessageError)\n+        errorDetails.errorMessage == \"Could not create flow\"\n+        errorDetails.errorDescription.startsWith(\"Not enough bandwidth or no path found. Failed to find path\")\n+\n+        cleanup:\n+        !e && flowHelperV2.deleteFlow(flow.flowId)\n+\n+        where:\n+        testMaxLatency  | condition\n+        10              | \"only 1 path satisfies SLA\"\n+        9               | \"both paths do not satisfy SLA\"\n+    }\n+\n+    def setLatencyForPaths(int mainPathLatency, int protectedPathLatency) {\n+        def nanoMultiplier = 1000000\n+        def mainIslCost = mainPathLatency.intdiv(mainIsls.size()) * nanoMultiplier\n+        def protectedIslCost = protectedPathLatency.intdiv(protectedIsls.size()) * nanoMultiplier\n+        [mainIsls[0], mainIsls[0].reversed].each {\n+            database.updateIslLatency(it, mainIslCost + (mainPathLatency % mainIsls.size()) * nanoMultiplier) }\n+        mainIsls.tail().each {[it, it.reversed].each { database.updateIslLatency(it, mainIslCost) } }\n+        [protectedIsls[0], protectedIsls[0].reversed].each {\n+            database.updateIslLatency(it, protectedIslCost + (protectedPathLatency % protectedIsls.size()) * nanoMultiplier) }\n+        protectedIsls.tail().each {[it, it.reversed].each { database.updateIslLatency(it, protectedIslCost) } }\n+    }\n+\n+    def cleanupSpec() {\n+        islsToBreak.each { getAntiflap().portUp(it.srcSwitch.dpId, it.srcPort) }", "originalCommit": "4c74eab337197354a0f7030e9db6985ce4948457", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYxNzYzOA==", "url": "https://github.com/telstra/open-kilda/pull/3822#discussion_r516617638", "bodyText": "how about setting the LOW_PRIORITY tag for negative tests?", "author": "andriidovhan", "createdAt": "2020-11-03T12:04:53Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/ProtectedPathMaxLatencySpec.groovy", "diffHunk": "@@ -0,0 +1,112 @@\n+package org.openkilda.functionaltests.spec.flows\n+\n+import static org.junit.Assume.assumeTrue\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.helpers.model.SwitchPair\n+import org.openkilda.messaging.error.MessageError\n+import org.openkilda.messaging.info.event.PathNode\n+import org.openkilda.model.PathComputationStrategy\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+\n+import org.springframework.http.HttpStatus\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Ignore\n+import spock.lang.Shared\n+import spock.lang.Unroll\n+\n+class ProtectedPathMaxLatencySpec extends HealthCheckSpecification {\n+    @Shared List<PathNode> mainPath, protectedPath\n+    @Shared List<Isl> mainIsls, protectedIsls, islsToBreak\n+    @Shared SwitchPair switchPair\n+\n+    def setupOnce() {\n+        //setup: Two active switches with two diverse paths\n+        List<List<PathNode>> paths\n+        switchPair = topologyHelper.switchPairs.find {\n+            paths = it.paths.unique(false) { a, b -> a.intersect(b) == [] ? 1 : 0 }\n+            paths.size() >= 2\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+        mainPath = paths[0]\n+        protectedPath = paths[1]\n+        mainIsls = pathHelper.getInvolvedIsls(mainPath)\n+        protectedIsls = pathHelper.getInvolvedIsls(protectedPath)\n+        //deactivate other paths for more clear experiment\n+        def isls = mainIsls + protectedIsls\n+        islsToBreak = switchPair.paths.findAll { !paths.contains(it) }\n+                                    .collect { pathHelper.getInvolvedIsls(it).find {!isls.contains(it) && !isls.contains(it.reversed) } }\n+                                    .unique { [it, it.reversed].sort() }\n+        islsToBreak.each { antiflap.portDown(it.srcSwitch.dpId, it.srcPort) }\n+    }\n+\n+    @Tidy\n+    @Ignore(\"https://github.com/telstra/open-kilda/issues/3821\")\n+    def \"Able to create protected flow with max_latency strategy if both paths satisfy SLA\"() {\n+        given: \"2 non-overlapping paths with 10 and 9 latency\"\n+        setLatencyForPaths(10, 9)\n+\n+        when: \"Create a flow with protected path and max_latency 11\"\n+        def flow = flowHelperV2.randomFlow(switchPair).tap {\n+            allocateProtectedPath = true\n+            maxLatency = 11\n+            pathComputationStrategy = PathComputationStrategy.MAX_LATENCY.toString()\n+        }\n+        flowHelperV2.addFlow(flow)\n+\n+        then: \"Flow is created, main path is the 10 latency path, protected is 9 latency\"\n+        def path = northbound.getFlowPath(flow.flowId)\n+        pathHelper.convert(path) == mainPath\n+        pathHelper.convert(path.protectedPath) == protectedPath\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+    }\n+\n+    @Tidy\n+    @Unroll\n+    def \"Unable to create protected flow with max_latency strategy if #condition\"() {", "originalCommit": "4c74eab337197354a0f7030e9db6985ce4948457", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a06e904b53ac68056a50622e13289477f988c779", "url": "https://github.com/telstra/open-kilda/commit/a06e904b53ac68056a50622e13289477f988c779", "message": "Add func tests for protected flow + max_latency\n\n- reveal #3821\n- change order of features in ProtectedPathV2Spec (no actual changes)\n- cleanup verifier now behaves differently if spec has 'cleanupSpec' fixture", "committedDate": "2020-11-03T12:50:19Z", "type": "forcePushed"}, {"oid": "363053517e9ea57bdc9f5a813059d4279a4a87f9", "url": "https://github.com/telstra/open-kilda/commit/363053517e9ea57bdc9f5a813059d4279a4a87f9", "message": "Add func tests for protected flow + max_latency\n\n- reveal #3821\n- change order of features in ProtectedPathV2Spec (no actual changes)\n- cleanup verifier now behaves differently if spec has 'cleanupSpec' fixture", "committedDate": "2020-11-10T09:02:56Z", "type": "forcePushed"}, {"oid": "18b7b39144b5e739b270be2632035b5cd6d6c7b2", "url": "https://github.com/telstra/open-kilda/commit/18b7b39144b5e739b270be2632035b5cd6d6c7b2", "message": "Add func tests for protected flow + max_latency\n\n- reveal #3821\n- change order of features in ProtectedPathV2Spec (no actual changes)\n- cleanup verifier now behaves differently if spec has 'cleanupSpec' fixture", "committedDate": "2020-11-10T09:28:36Z", "type": "forcePushed"}, {"oid": "ccd239b45c28282cccd38299351ff381178452a2", "url": "https://github.com/telstra/open-kilda/commit/ccd239b45c28282cccd38299351ff381178452a2", "message": "Add func tests for protected flow + max_latency\n\n- reveal #3821\n- change order of features in ProtectedPathV2Spec (no actual changes)\n- cleanup verifier now behaves differently if spec has 'cleanupSpec' fixture", "committedDate": "2020-11-11T17:54:32Z", "type": "commit"}, {"oid": "ccd239b45c28282cccd38299351ff381178452a2", "url": "https://github.com/telstra/open-kilda/commit/ccd239b45c28282cccd38299351ff381178452a2", "message": "Add func tests for protected flow + max_latency\n\n- reveal #3821\n- change order of features in ProtectedPathV2Spec (no actual changes)\n- cleanup verifier now behaves differently if spec has 'cleanupSpec' fixture", "committedDate": "2020-11-11T17:54:32Z", "type": "forcePushed"}]}