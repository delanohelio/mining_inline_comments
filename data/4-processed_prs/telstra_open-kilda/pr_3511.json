{"pr_number": 3511, "pr_title": "Delete Flow Topology", "pr_createdAt": "2020-05-28T08:10:24Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3511", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3OTIyNw==", "url": "https://github.com/telstra/open-kilda/pull/3511#discussion_r432279227", "bodyText": "nit: add @Deprecated annotation and @deprecated java doc", "author": "niksv", "createdAt": "2020-05-29T06:25:33Z", "path": "src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/controller/v1/FlowController.java", "diffHunk": "@@ -204,55 +203,27 @@\n         return flowService.pathFlow(flowId);\n     }\n \n-\n     /**\n      * Push flows to kilda ... this can be used to get flows into kilda without kilda creating them\n      * itself. Kilda won't expect to create them .. it may (and should) validate them at some stage.\n-     *\n-     * @param externalFlows a list of flows to push to kilda for it to absorb without expectation of creating the flow\n-     *        rules\n-     * @return list of flow\n      */\n     @ApiOperation(value = \"Push flows without expectation of modifying switches. It can push to switch and validate.\",\n             response = BatchResults.class)\n     @PutMapping(path = \"/push\")\n     @ResponseStatus(HttpStatus.OK)\n-    public CompletableFuture<BatchResults> pushFlows(\n-            @RequestBody List<FlowInfoData> externalFlows,\n-            @ApiParam(value = \"default: false. If true, this will propagate rules to the switches.\",\n-                    required = false)\n-            @RequestParam(value = \"propagate\", required = false) Optional<Boolean> propagate,\n-            @ApiParam(value = \"default: false. If true, will wait until poll timeout for validation.\",\n-                    required = false)\n-            @RequestParam(\"verify\") Optional<Boolean> verify) {\n-\n-        Boolean defaultPropagate = false;\n-        Boolean defaultVerify = false;\n-        return flowService.pushFlows(externalFlows, propagate.orElse(defaultPropagate), verify.orElse(defaultVerify));\n+    public CompletableFuture<BatchResults> pushFlows() {", "originalCommit": "79a69f764f3578f8c345a92f7685cf625f609b99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM0ODEyMw==", "url": "https://github.com/telstra/open-kilda/pull/3511#discussion_r432348123", "bodyText": "Added.", "author": "dpoltavets", "createdAt": "2020-05-29T08:54:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3OTIyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3OTI4NQ==", "url": "https://github.com/telstra/open-kilda/pull/3511#discussion_r432279285", "bodyText": "same", "author": "niksv", "createdAt": "2020-05-29T06:25:41Z", "path": "src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/controller/v1/FlowController.java", "diffHunk": "@@ -204,55 +203,27 @@\n         return flowService.pathFlow(flowId);\n     }\n \n-\n     /**\n      * Push flows to kilda ... this can be used to get flows into kilda without kilda creating them\n      * itself. Kilda won't expect to create them .. it may (and should) validate them at some stage.\n-     *\n-     * @param externalFlows a list of flows to push to kilda for it to absorb without expectation of creating the flow\n-     *        rules\n-     * @return list of flow\n      */\n     @ApiOperation(value = \"Push flows without expectation of modifying switches. It can push to switch and validate.\",\n             response = BatchResults.class)\n     @PutMapping(path = \"/push\")\n     @ResponseStatus(HttpStatus.OK)\n-    public CompletableFuture<BatchResults> pushFlows(\n-            @RequestBody List<FlowInfoData> externalFlows,\n-            @ApiParam(value = \"default: false. If true, this will propagate rules to the switches.\",\n-                    required = false)\n-            @RequestParam(value = \"propagate\", required = false) Optional<Boolean> propagate,\n-            @ApiParam(value = \"default: false. If true, will wait until poll timeout for validation.\",\n-                    required = false)\n-            @RequestParam(\"verify\") Optional<Boolean> verify) {\n-\n-        Boolean defaultPropagate = false;\n-        Boolean defaultVerify = false;\n-        return flowService.pushFlows(externalFlows, propagate.orElse(defaultPropagate), verify.orElse(defaultVerify));\n+    public CompletableFuture<BatchResults> pushFlows() {\n+        return flowService.pushFlows();\n     }\n \n-\n     /**\n      * Unpush flows to kilda ... essentially the opposite of push.\n-     *\n-     * @param externalFlows a list of flows to unpush without propagation to Floodlight\n-     * @return list of flow\n      */\n     @ApiOperation(value = \"Unpush flows without expectation of modifying switches. It can push to switch and validate.\",\n             response = BatchResults.class)\n     @PutMapping(path = \"/unpush\")\n     @ResponseStatus(HttpStatus.OK)\n-    public CompletableFuture<BatchResults> unpushFlows(\n-            @RequestBody List<FlowInfoData> externalFlows,\n-            @ApiParam(value = \"default: false. If true, this will propagate rules to the switches.\",\n-                    required = false)\n-            @RequestParam(value = \"propagate\", required = false) Optional<Boolean> propagate,\n-            @ApiParam(value = \"default: false. If true, will wait until poll timeout for validation.\",\n-                    required = false)\n-            @RequestParam(value = \"verify\", required = false) Optional<Boolean> verify) {\n-        Boolean defaultPropagate = false;\n-        Boolean defaultVerify = false;\n-        return flowService.unpushFlows(externalFlows, propagate.orElse(defaultPropagate), verify.orElse(defaultVerify));\n+    public CompletableFuture<BatchResults> unpushFlows() {", "originalCommit": "79a69f764f3578f8c345a92f7685cf625f609b99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM0ODE0OA==", "url": "https://github.com/telstra/open-kilda/pull/3511#discussion_r432348148", "bodyText": "Added.", "author": "dpoltavets", "createdAt": "2020-05-29T08:54:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3OTI4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3OTM0OA==", "url": "https://github.com/telstra/open-kilda/pull/3511#discussion_r432279348", "bodyText": "same", "author": "niksv", "createdAt": "2020-05-29T06:25:51Z", "path": "src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/service/FlowService.java", "diffHunk": "@@ -166,23 +165,13 @@\n \n     /**\n      * Use this to push flows that may not be in the database / caches but they should be.\n-     *\n-     * @param externalFlows the list of flows to push.\n-     * @param propagate     if true, the path/rules will be propagated to the switch\n-     * @param verify        if true, we'll wait up to poll seconds to confirm if rules have been applied\n      */\n-    CompletableFuture<BatchResults> pushFlows(final List<FlowInfoData> externalFlows, Boolean propagate,\n-                                              Boolean verify);\n+    CompletableFuture<BatchResults> pushFlows();", "originalCommit": "79a69f764f3578f8c345a92f7685cf625f609b99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM0ODE4Ng==", "url": "https://github.com/telstra/open-kilda/pull/3511#discussion_r432348186", "bodyText": "Added.", "author": "dpoltavets", "createdAt": "2020-05-29T08:54:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3OTM0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3OTM4OQ==", "url": "https://github.com/telstra/open-kilda/pull/3511#discussion_r432279389", "bodyText": "same", "author": "niksv", "createdAt": "2020-05-29T06:25:57Z", "path": "src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/service/FlowService.java", "diffHunk": "@@ -166,23 +165,13 @@\n \n     /**\n      * Use this to push flows that may not be in the database / caches but they should be.\n-     *\n-     * @param externalFlows the list of flows to push.\n-     * @param propagate     if true, the path/rules will be propagated to the switch\n-     * @param verify        if true, we'll wait up to poll seconds to confirm if rules have been applied\n      */\n-    CompletableFuture<BatchResults> pushFlows(final List<FlowInfoData> externalFlows, Boolean propagate,\n-                                              Boolean verify);\n+    CompletableFuture<BatchResults> pushFlows();\n \n     /**\n      * Use this to unpush flows .. ie undo a push\n-     *\n-     * @param externalFlows the list of flows to unpush.\n-     * @param propagate     if true, the path/rules will be propagated to the switch\n-     * @param verify        if true, we'll wait up to poll seconds to confirm if rules have been applied\n      */\n-    CompletableFuture<BatchResults> unpushFlows(final List<FlowInfoData> externalFlows, Boolean propagate,\n-                                                Boolean verify);\n+    CompletableFuture<BatchResults> unpushFlows();", "originalCommit": "79a69f764f3578f8c345a92f7685cf625f609b99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM0ODIzMA==", "url": "https://github.com/telstra/open-kilda/pull/3511#discussion_r432348230", "bodyText": "Added.", "author": "dpoltavets", "createdAt": "2020-05-29T08:55:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI3OTM4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI4OTkzNA==", "url": "https://github.com/telstra/open-kilda/pull/3511#discussion_r432289934", "bodyText": "any side effects of using sw-manager topic? at least spam logs?", "author": "timofei-durakov", "createdAt": "2020-05-29T06:55:48Z", "path": "src-java/network-topology/network-storm-topology/src/main/java/org/openkilda/wfm/topology/network/NetworkTopology.java", "diffHunk": "@@ -137,7 +137,7 @@ private void inputSwitchManager(TopologyBuilder topology, int scaleFactor) {\n \n     private void inputSpeakerRules(TopologyBuilder topology, int scaleFactor) {\n         KafkaSpout<String, Message> spout = buildKafkaSpout(\n-                topologyConfig.getFlowTopic(), ComponentId.INPUT_SPEAKER_RULES.toString());\n+                topologyConfig.getSwitchManagerTopic(), ComponentId.INPUT_SPEAKER_RULES.toString());", "originalCommit": "79a69f764f3578f8c345a92f7685cf625f609b99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM0ODM5OQ==", "url": "https://github.com/telstra/open-kilda/pull/3511#discussion_r432348399", "bodyText": "Fixed. To avoid spamming error messages, the logging level has been lowered in SpeakerRulesRouter.", "author": "dpoltavets", "createdAt": "2020-05-29T08:55:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI4OTkzNA=="}], "type": "inlineReview"}, {"oid": "413965aaa2041feaf283fedaf7deebde4b1a5f63", "url": "https://github.com/telstra/open-kilda/commit/413965aaa2041feaf283fedaf7deebde4b1a5f63", "message": "Flow topology has been removed", "committedDate": "2020-05-29T08:30:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM4NzQyNQ==", "url": "https://github.com/telstra/open-kilda/pull/3511#discussion_r432387425", "bodyText": "Why tests for object not related to flow topology are removed?", "author": "surabujin", "createdAt": "2020-05-29T10:09:28Z", "path": "src-java/flow-topology/flow-storm-topology/src/test/java/org/openkilda/messaging/command/flow/AbstractSerializerTest.java", "diffHunk": "@@ -1,640 +0,0 @@\n-/* Copyright 2019 Telstra Open Source\n- *\n- *   Licensed under the Apache License, Version 2.0 (the \"License\");\n- *   you may not use this file except in compliance with the License.\n- *   You may obtain a copy of the License at\n- *\n- *       http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *   Unless required by applicable law or agreed to in writing, software\n- *   distributed under the License is distributed on an \"AS IS\" BASIS,\n- *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- *   See the License for the specific language governing permissions and\n- *   limitations under the License.\n- */\n-\n-package org.openkilda.messaging.command.flow;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n-import static org.openkilda.messaging.command.Constants.flowName;\n-\n-import org.openkilda.messaging.AbstractSerializer;\n-import org.openkilda.messaging.Destination;\n-import org.openkilda.messaging.Message;\n-import org.openkilda.messaging.command.CommandMessage;\n-import org.openkilda.messaging.command.discovery.HealthCheckCommandData;\n-import org.openkilda.messaging.command.switches.DeleteRulesCriteria;\n-import org.openkilda.messaging.error.ErrorData;\n-import org.openkilda.messaging.error.ErrorMessage;\n-import org.openkilda.messaging.error.ErrorType;\n-import org.openkilda.messaging.info.InfoMessage;\n-import org.openkilda.messaging.info.discovery.NetworkInfoData;\n-import org.openkilda.messaging.info.event.IslChangeType;\n-import org.openkilda.messaging.info.event.IslInfoData;\n-import org.openkilda.messaging.info.event.PathInfoData;\n-import org.openkilda.messaging.info.event.PathNode;\n-import org.openkilda.messaging.info.event.PortChangeType;\n-import org.openkilda.messaging.info.event.PortInfoData;\n-import org.openkilda.messaging.info.event.SwitchChangeType;\n-import org.openkilda.messaging.info.event.SwitchInfoData;\n-import org.openkilda.messaging.info.flow.FlowReadResponse;\n-import org.openkilda.messaging.info.flow.FlowRerouteResponse;\n-import org.openkilda.messaging.info.flow.FlowResponse;\n-import org.openkilda.messaging.info.flow.FlowStatusResponse;\n-import org.openkilda.messaging.info.flow.FlowsResponse;\n-import org.openkilda.messaging.model.FlowDto;\n-import org.openkilda.messaging.model.FlowPairDto;\n-import org.openkilda.messaging.model.SpeakerSwitchDescription;\n-import org.openkilda.messaging.model.SpeakerSwitchView;\n-import org.openkilda.messaging.payload.flow.FlowIdStatusPayload;\n-import org.openkilda.messaging.payload.flow.FlowState;\n-import org.openkilda.model.FlowEncapsulationType;\n-import org.openkilda.model.FlowEndpoint;\n-import org.openkilda.model.IslEndpoint;\n-import org.openkilda.model.OutputVlanType;\n-import org.openkilda.model.SwitchId;\n-\n-import org.junit.Ignore;\n-import org.junit.Test;\n-\n-import java.io.IOException;\n-import java.net.Inet4Address;\n-import java.net.InetSocketAddress;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.UUID;\n-\n-@Ignore\n-public abstract class AbstractSerializerTest {\n-    private static final String FLOW_NAME = \"test_flow\";\n-    private static final SwitchId SWITCH_ID = new SwitchId(\"00:00:00:00:00:00:00:00\");\n-    private static final SwitchId EGRESS_SWITCH_ID = new SwitchId(\"00:00:00:00:00:00:00:00\");\n-    private static final String CORRELATION_ID = UUID.randomUUID().toString();\n-    private static final UUID TRANSACTION_ID = UUID.randomUUID();\n-    private static final long TIMESTAMP = System.currentTimeMillis();\n-    private static final int INPUT_PORT = 1;\n-    private static final int OUTPUT_PORT = 2;\n-    private static final int INPUT_VLAN_ID = 101;\n-    private static final int OUTPUT_VLAN_ID = 102;\n-    private static final int TRANSIT_ENCAPSULATION_ID = 103;\n-    private static final FlowEncapsulationType TRANSIT_ENCAPSULATION_TYPE = FlowEncapsulationType.TRANSIT_VLAN;\n-    private static final long BANDWIDTH = 10000L;\n-    private static final long COOKIE = 0x1L;\n-    private static final Long METER_ID = null;\n-    private static final OutputVlanType OUTPUT_VLAN_TYPE = OutputVlanType.REPLACE;\n-    private static final FlowState FLOW_STATUS = FlowState.UP;\n-    private static final PortChangeType PORT_CHANGE = PortChangeType.OTHER_UPDATE;\n-    private static final SwitchChangeType SWITCH_EVENT = SwitchChangeType.CHANGED;\n-    private static final Destination DESTINATION = null;\n-\n-    private static final FlowIdStatusPayload flowIdStatusResponse = new FlowIdStatusPayload(FLOW_NAME, FLOW_STATUS);\n-\n-    private static final String requester = \"requester-id\";\n-    private static final SwitchInfoData sw1 = new SwitchInfoData(new SwitchId(\"ff:01\"),\n-            SwitchChangeType.ACTIVATED, \"1.1.1.1\", \"ff:01\", \"switch-1\", \"kilda\", false);\n-    private static final SwitchInfoData sw2 = new SwitchInfoData(new SwitchId(\"ff:02\"),\n-            SwitchChangeType.ACTIVATED, \"2.2.2.2\", \"ff:02\", \"switch-2\", \"kilda\", false);\n-    private static final List<PathNode> nodes = Arrays.asList(\n-            new PathNode(new SwitchId(\"ff:01\"), 1, 0, 0L),\n-            new PathNode(new SwitchId(\"ff:02\"), 2, 1, 0L));\n-    private static final IslInfoData isl = IslInfoData.builder()\n-            .latency(0L)\n-            .source(nodes.get(0))\n-            .destination(nodes.get(1))\n-            .speed(1000L)\n-            .state(IslChangeType.DISCOVERED)\n-            .availableBandwidth(900L)\n-            .underMaintenance(false)\n-            .build();\n-\n-    private static final PathInfoData path = new PathInfoData(0L, nodes);\n-    private static final FlowDto flowModel = FlowDto.builder()\n-            .flowId(FLOW_NAME)\n-            .bandwidth(1000)\n-            .ignoreBandwidth(false)\n-            .periodicPings(false)\n-            .cookie(COOKIE)\n-            .lastUpdated(String.valueOf(TIMESTAMP))\n-            .sourceSwitch(new SwitchId(\"ff:01\")).sourcePort(10).sourcePort(100)\n-            .destinationSwitch(new SwitchId(\"ff:02\")).destinationPort(20).destinationVlan(200)\n-            .meterId(1)\n-            .transitEncapsulationId(1024)\n-            .state(FLOW_STATUS)\n-            .build();\n-\n-    protected final AbstractSerializer serializer;\n-\n-    public AbstractSerializerTest(AbstractSerializer serializer) {\n-        this.serializer = serializer;\n-    }\n-\n-    @Test\n-    public void serializeInstallEgressFlowMessageTest() throws IOException, ClassNotFoundException {\n-        InstallEgressFlow data = new InstallEgressFlow(TRANSACTION_ID, FLOW_NAME, COOKIE,\n-                EGRESS_SWITCH_ID, INPUT_PORT, OUTPUT_PORT, TRANSIT_ENCAPSULATION_ID, TRANSIT_ENCAPSULATION_TYPE,\n-                OUTPUT_VLAN_ID, 0, OUTPUT_VLAN_TYPE, false,\n-                new FlowEndpoint(SWITCH_ID, 1, 200));\n-        System.out.println(data);\n-\n-        CommandMessage command = new CommandMessage(data, System.currentTimeMillis(), CORRELATION_ID, DESTINATION);\n-        serializer.serialize(command);\n-\n-        Message message = (Message) serializer.deserialize();\n-        assertTrue(message instanceof CommandMessage);\n-\n-        CommandMessage resultCommand = (CommandMessage) message;\n-        assertTrue(resultCommand.getData() instanceof InstallEgressFlow);\n-\n-        InstallEgressFlow resultData = (InstallEgressFlow) resultCommand.getData();\n-        System.out.println(resultData);\n-        assertEquals(data, resultData);\n-        assertEquals(data.hashCode(), resultData.hashCode());\n-    }\n-\n-    @Test\n-    public void serializeInstallIngressFlowMessageTest() throws IOException, ClassNotFoundException {\n-        InstallIngressFlow data = new InstallIngressFlow(TRANSACTION_ID, FLOW_NAME, COOKIE, SWITCH_ID,\n-                INPUT_PORT, OUTPUT_PORT, INPUT_VLAN_ID, 0, TRANSIT_ENCAPSULATION_ID,\n-                TRANSIT_ENCAPSULATION_TYPE, OUTPUT_VLAN_TYPE, BANDWIDTH, METER_ID, EGRESS_SWITCH_ID,\n-                false, false, false);\n-        System.out.println(data);\n-\n-        CommandMessage command = new CommandMessage(data, System.currentTimeMillis(), CORRELATION_ID, DESTINATION);\n-        serializer.serialize(command);\n-\n-        Message message = (Message) serializer.deserialize();\n-        assertTrue(message instanceof CommandMessage);\n-\n-        CommandMessage resultCommand = (CommandMessage) message;\n-        assertTrue(resultCommand.getData() instanceof InstallIngressFlow);\n-\n-        InstallIngressFlow resultData = (InstallIngressFlow) resultCommand.getData();\n-        System.out.println(resultData);\n-        assertEquals(data, resultData);\n-        assertEquals(data.hashCode(), resultData.hashCode());\n-    }\n-\n-    @Test\n-    public void serializeInstallTransitFlowMessageTest() throws IOException, ClassNotFoundException {\n-        InstallTransitFlow data = new InstallTransitFlow(TRANSACTION_ID, FLOW_NAME, COOKIE,\n-                SWITCH_ID, INPUT_PORT, OUTPUT_PORT, TRANSIT_ENCAPSULATION_ID, TRANSIT_ENCAPSULATION_TYPE, false);\n-        System.out.println(data);\n-\n-        CommandMessage command = new CommandMessage(data, System.currentTimeMillis(), CORRELATION_ID, DESTINATION);\n-        serializer.serialize(command);\n-\n-        Message message = (Message) serializer.deserialize();\n-        assertTrue(message instanceof CommandMessage);\n-\n-        CommandMessage resultCommand = (CommandMessage) message;\n-        assertTrue(resultCommand.getData() instanceof InstallTransitFlow);\n-\n-        InstallTransitFlow resultData = (InstallTransitFlow) resultCommand.getData();\n-        System.out.println(resultData);\n-        assertEquals(data, resultData);\n-        assertEquals(data.hashCode(), resultData.hashCode());\n-    }\n-\n-    @Test\n-    public void serializeInstallOneSwitchFlowMessageTest() throws IOException, ClassNotFoundException {\n-        InstallOneSwitchFlow data = new InstallOneSwitchFlow(TRANSACTION_ID, FLOW_NAME, COOKIE, SWITCH_ID, INPUT_PORT,\n-                OUTPUT_PORT, INPUT_VLAN_ID, 0, OUTPUT_VLAN_ID, 0, OUTPUT_VLAN_TYPE, BANDWIDTH, METER_ID,\n-                false, false, false);\n-        System.out.println(data);\n-\n-        CommandMessage command = new CommandMessage(data, System.currentTimeMillis(), CORRELATION_ID, DESTINATION);\n-        serializer.serialize(command);\n-\n-        Message message = (Message) serializer.deserialize();\n-        assertTrue(message instanceof CommandMessage);\n-\n-        CommandMessage resultCommand = (CommandMessage) message;\n-        assertTrue(resultCommand.getData() instanceof InstallOneSwitchFlow);\n-\n-        InstallOneSwitchFlow resultData = (InstallOneSwitchFlow) resultCommand.getData();\n-        System.out.println(resultData);\n-        assertEquals(data, resultData);\n-        assertEquals(data.hashCode(), resultData.hashCode());\n-    }\n-\n-    @Test\n-    public void flowCreateRequestTest() throws IOException, ClassNotFoundException {\n-        FlowCreateRequest data = new FlowCreateRequest(flowModel);\n-        System.out.println(data);\n-\n-        CommandMessage command = new CommandMessage(data, System.currentTimeMillis(), CORRELATION_ID, DESTINATION);\n-        serializer.serialize(command);\n-\n-        Message message = (Message) serializer.deserialize();\n-        assertTrue(message instanceof CommandMessage);\n-\n-        CommandMessage resultCommand = (CommandMessage) message;\n-        assertTrue(resultCommand.getData() instanceof FlowCreateRequest);\n-\n-        FlowCreateRequest resultData = (FlowCreateRequest) resultCommand.getData();\n-        System.out.println(resultData);\n-        assertEquals(data, resultData);\n-        assertEquals(data.hashCode(), resultData.hashCode());\n-        assertEquals(flowModel.hashCode(), resultData.getPayload().hashCode());\n-    }\n-\n-    @Test\n-    public void flowUpdateRequestTest() throws IOException, ClassNotFoundException {\n-        FlowUpdateRequest data = new FlowUpdateRequest(flowModel);\n-        System.out.println(data);\n-\n-        CommandMessage command = new CommandMessage(data, System.currentTimeMillis(), CORRELATION_ID, DESTINATION);\n-        serializer.serialize(command);\n-\n-        Message message = (Message) serializer.deserialize();\n-        assertTrue(message instanceof CommandMessage);\n-\n-        CommandMessage resultCommand = (CommandMessage) message;\n-        assertTrue(resultCommand.getData() instanceof FlowUpdateRequest);\n-\n-        FlowUpdateRequest resultData = (FlowUpdateRequest) resultCommand.getData();\n-        System.out.println(resultData);\n-        assertEquals(data, resultData);\n-        assertEquals(data.hashCode(), resultData.hashCode());\n-        assertEquals(flowModel.hashCode(), resultData.getPayload().hashCode());\n-    }\n-\n-    @Test\n-    public void flowDeleteRequestTest() throws IOException, ClassNotFoundException {\n-        FlowDeleteRequest data = new FlowDeleteRequest(flowName);\n-        System.out.println(data);\n-\n-        CommandMessage command = new CommandMessage(data, System.currentTimeMillis(), CORRELATION_ID, DESTINATION);\n-        serializer.serialize(command);\n-\n-        Message message = (Message) serializer.deserialize();\n-        assertTrue(message instanceof CommandMessage);\n-\n-        CommandMessage resultCommand = (CommandMessage) message;\n-        assertTrue(resultCommand.getData() instanceof FlowDeleteRequest);\n-\n-        FlowDeleteRequest resultData = (FlowDeleteRequest) resultCommand.getData();\n-        System.out.println(resultData);\n-        assertEquals(data, resultData);\n-        assertEquals(data.hashCode(), resultData.hashCode());\n-        assertEquals(data.getFlowId(), resultData.getFlowId());\n-    }\n-\n-    @Test\n-    public void flowGetBidirectionalRequestTest() throws IOException, ClassNotFoundException {\n-        FlowReadRequest data = new FlowReadRequest(FLOW_NAME);\n-        System.out.println(data);\n-\n-        CommandMessage command = new CommandMessage(data, System.currentTimeMillis(), CORRELATION_ID, DESTINATION);\n-        serializer.serialize(command);\n-\n-        Message message = (Message) serializer.deserialize();\n-        assertTrue(message instanceof CommandMessage);\n-\n-        CommandMessage resultCommand = (CommandMessage) message;\n-        assertTrue(resultCommand.getData() instanceof FlowReadRequest);\n-\n-        FlowReadRequest resultData = (FlowReadRequest) resultCommand.getData();\n-        System.out.println(resultData);\n-        assertEquals(data, resultData);\n-        assertEquals(data.hashCode(), resultData.hashCode());\n-        assertEquals(FLOW_NAME, resultData.getFlowId());\n-    }\n-\n-    @Test\n-    public void flowGetFlowReadResponseTest() throws IOException, ClassNotFoundException {\n-        FlowReadResponse data = new FlowReadResponse(flowModel, Collections.singletonList(FLOW_NAME));\n-        System.out.println(data);\n-\n-        InfoMessage info = new InfoMessage(data, System.currentTimeMillis(), CORRELATION_ID, DESTINATION,\n-                null);\n-        serializer.serialize(info);\n-\n-        Message message = (Message) serializer.deserialize();\n-        assertTrue(message instanceof InfoMessage);\n-\n-        InfoMessage resultInfo = (InfoMessage) message;\n-        assertTrue(resultInfo.getData() instanceof FlowReadResponse);\n-\n-        FlowReadResponse resultData = (FlowReadResponse) resultInfo.getData();\n-        System.out.println(resultData);\n-        assertEquals(data, resultData);\n-        assertEquals(data.hashCode(), resultData.hashCode());\n-    }\n-\n-    @Test\n-    public void flowRerouteResponseTest() throws IOException, ClassNotFoundException {\n-        FlowRerouteResponse data = new FlowRerouteResponse(path, true);\n-        System.out.println(data);\n-\n-        InfoMessage info = new InfoMessage(data, System.currentTimeMillis(), CORRELATION_ID, DESTINATION,\n-                null);\n-        serializer.serialize(info);\n-\n-        Message message = (Message) serializer.deserialize();\n-        assertTrue(message instanceof InfoMessage);\n-\n-        InfoMessage resultInfo = (InfoMessage) message;\n-        assertTrue(resultInfo.getData() instanceof FlowRerouteResponse);\n-\n-        FlowRerouteResponse resultData = (FlowRerouteResponse) resultInfo.getData();\n-        System.out.println(resultData);\n-        assertEquals(data, resultData);\n-        assertEquals(data.hashCode(), resultData.hashCode());\n-        assertEquals(path.hashCode(), resultData.getPayload().hashCode());\n-    }\n-\n-    @Test\n-    public void flowStatusResponseTest() throws IOException, ClassNotFoundException {\n-        FlowStatusResponse data = new FlowStatusResponse(flowIdStatusResponse);\n-        System.out.println(data);\n-\n-        InfoMessage info = new InfoMessage(data, System.currentTimeMillis(), CORRELATION_ID, DESTINATION,\n-                null);\n-        serializer.serialize(info);\n-\n-        Message message = (Message) serializer.deserialize();\n-        assertTrue(message instanceof InfoMessage);\n-\n-        InfoMessage resultInfo = (InfoMessage) message;\n-        assertTrue(resultInfo.getData() instanceof FlowStatusResponse);\n-\n-        FlowStatusResponse resultData = (FlowStatusResponse) resultInfo.getData();\n-        System.out.println(resultData);\n-        assertEquals(data, resultData);\n-        assertEquals(data.hashCode(), resultData.hashCode());\n-        assertEquals(flowIdStatusResponse.hashCode(), resultData.getPayload().hashCode());\n-    }\n-\n-    @Test\n-    public void flowResponseTest() throws IOException, ClassNotFoundException {\n-        FlowResponse data = new FlowResponse(flowModel);\n-        System.out.println(data);\n-\n-        InfoMessage info = new InfoMessage(data, System.currentTimeMillis(), CORRELATION_ID, DESTINATION,\n-                null);\n-        serializer.serialize(info);\n-\n-        Message message = (Message) serializer.deserialize();\n-        assertTrue(message instanceof InfoMessage);\n-\n-        InfoMessage resultInfo = (InfoMessage) message;\n-        assertTrue(resultInfo.getData() instanceof FlowResponse);\n-\n-        FlowResponse resultData = (FlowResponse) resultInfo.getData();\n-        System.out.println(resultData);\n-        assertEquals(data, resultData);\n-        assertEquals(data.hashCode(), resultData.hashCode());\n-        assertEquals(flowModel.hashCode(), resultData.getPayload().hashCode());\n-    }\n-\n-    @Test\n-    public void flowsResponseTest() throws IOException, ClassNotFoundException {\n-        FlowsResponse data = new FlowsResponse(Collections.singletonList(flowModel.getFlowId()));\n-        System.out.println(data);\n-\n-        InfoMessage info = new InfoMessage(data, System.currentTimeMillis(), CORRELATION_ID, DESTINATION,\n-                null);\n-        serializer.serialize(info);\n-\n-        Message message = (Message) serializer.deserialize();\n-        assertTrue(message instanceof InfoMessage);\n-\n-        InfoMessage resultInfo = (InfoMessage) message;\n-        assertTrue(resultInfo.getData() instanceof FlowsResponse);\n-\n-        FlowsResponse resultData = (FlowsResponse) resultInfo.getData();\n-        System.out.println(resultData);\n-        assertEquals(data, resultData);\n-        assertEquals(data.hashCode(), resultData.hashCode());\n-        assertEquals(Collections.singletonList(flowModel.getFlowId()).hashCode(), resultData.getFlowIds().hashCode());\n-    }\n-\n-    @Test\n-    public void eventIslInfoTest() throws IOException, ClassNotFoundException {", "originalCommit": "413965aaa2041feaf283fedaf7deebde4b1a5f63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ2MzMwMQ==", "url": "https://github.com/telstra/open-kilda/pull/3511#discussion_r432463301", "bodyText": "These tests have long been ignored and do not test anything.", "author": "dpoltavets", "createdAt": "2020-05-29T12:55:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM4NzQyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM4ODQyNw==", "url": "https://github.com/telstra/open-kilda/pull/3511#discussion_r432388427", "bodyText": "Do not remove this test. Replace FlowIntoData() with some other payload.", "author": "surabujin", "createdAt": "2020-05-29T10:11:32Z", "path": "src-java/flow-topology/flow-storm-topology/src/test/java/org/openkilda/wfm/topology/utils/LoggerContextInitializerTest.java", "diffHunk": "@@ -1,91 +0,0 @@\n-/* Copyright 2018 Telstra Open Source\n- *\n- *   Licensed under the Apache License, Version 2.0 (the \"License\");\n- *   you may not use this file except in compliance with the License.\n- *   You may obtain a copy of the License at\n- *\n- *       http://www.apache.org/licenses/LICENSE-2.0\n- *\n- *   Unless required by applicable law or agreed to in writing, software\n- *   distributed under the License is distributed on an \"AS IS\" BASIS,\n- *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- *   See the License for the specific language governing permissions and\n- *   limitations under the License.\n- */\n-\n-package org.openkilda.wfm.topology.utils;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-import static org.mockito.ArgumentMatchers.eq;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.when;\n-\n-import org.openkilda.messaging.info.InfoMessage;\n-import org.openkilda.messaging.info.flow.FlowInfoData;\n-import org.openkilda.wfm.CommandContext;\n-\n-import com.fasterxml.jackson.core.JsonProcessingException;\n-import com.fasterxml.jackson.databind.ObjectMapper;\n-import org.apache.storm.tuple.Fields;\n-import org.apache.storm.tuple.Tuple;\n-import org.junit.Test;\n-\n-import java.util.Optional;\n-import java.util.UUID;\n-\n-public class LoggerContextInitializerTest {", "originalCommit": "413965aaa2041feaf283fedaf7deebde4b1a5f63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ2MzUwMA==", "url": "https://github.com/telstra/open-kilda/pull/3511#discussion_r432463500", "bodyText": "These tests have been restored.", "author": "dpoltavets", "createdAt": "2020-05-29T12:55:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM4ODQyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ0NzA5Mg==", "url": "https://github.com/telstra/open-kilda/pull/3511#discussion_r432447092", "bodyText": "What about installEgressFlow, installEgressFlow and installOneSwitchFlow methods? What about deeper handling triggered from these methods?", "author": "surabujin", "createdAt": "2020-05-29T12:23:29Z", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/kafka/RecordHandler.java", "diffHunk": "@@ -452,26 +396,6 @@ private void installServer42IngressFlow(final InstallServer42IngressFlow command\n                 command.isMultiTable());\n     }\n \n-    /**\n-     * Processes egress flow install message.\n-     *\n-     * @param message command message for flow installation\n-     */\n-    private void doProcessEgressFlow(final CommandMessage message, String replyToTopic, Destination replyDestination)\n-            throws FlowCommandException {\n-        InstallEgressFlow command = (InstallEgressFlow) message.getData();\n-        logger.info(\"Installing egress flow '{}' on switch '{}'\", command.getId(), command.getSwitchId());\n-\n-        try {\n-            installEgressFlow(command);", "originalCommit": "413965aaa2041feaf283fedaf7deebde4b1a5f63", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ2Mzg2MQ==", "url": "https://github.com/telstra/open-kilda/pull/3511#discussion_r432463861", "bodyText": "These methods have been removed.", "author": "dpoltavets", "createdAt": "2020-05-29T12:56:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ0NzA5Mg=="}], "type": "inlineReview"}, {"oid": "5988f40930fb112943e15f5408ddecf5a94ad640", "url": "https://github.com/telstra/open-kilda/commit/5988f40930fb112943e15f5408ddecf5a94ad640", "message": "Flow topology has been removed", "committedDate": "2020-05-29T12:41:49Z", "type": "forcePushed"}, {"oid": "89cc5dd2d07992300d573ec222026a56ceeedf80", "url": "https://github.com/telstra/open-kilda/commit/89cc5dd2d07992300d573ec222026a56ceeedf80", "message": "Flow topology has been removed", "committedDate": "2020-05-29T14:53:39Z", "type": "commit"}, {"oid": "89cc5dd2d07992300d573ec222026a56ceeedf80", "url": "https://github.com/telstra/open-kilda/commit/89cc5dd2d07992300d573ec222026a56ceeedf80", "message": "Flow topology has been removed", "committedDate": "2020-05-29T14:53:39Z", "type": "forcePushed"}]}