{"pr_number": 3840, "pr_title": "Add test for round-trip isl discovery in special cases", "pr_createdAt": "2020-11-10T08:08:41Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3840", "timeline": [{"oid": "f1a1f5512e8f6235e7fb12c5f9c86af17b3ce293", "url": "https://github.com/telstra/open-kilda/commit/f1a1f5512e8f6235e7fb12c5f9c86af17b3ce293", "message": "Add test for round-trip isl discovery in special cases", "committedDate": "2020-11-10T08:09:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYzMDM5Ng==", "url": "https://github.com/telstra/open-kilda/pull/3840#discussion_r520630396", "bodyText": "Do we really need to wait WAIT_OFFSET * 2?", "author": "andriidovhan", "createdAt": "2020-11-10T15:01:54Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/RoundTripIslSpec.groovy", "diffHunk": "@@ -33,6 +37,62 @@ class RoundTripIslSpec extends HealthCheckSpecification {\n     via the 'knockoutSwitch' method on the stage env*/\n     Integer customWaitOffset = WAIT_OFFSET * 4\n \n+    @Unroll\n+    @Tidy\n+    def \"Isl with round-trip properly changes status after port events(#descr)\"() {\n+        given: \"Round-trip ISL with a-switch\"\n+        def cleanupActions = []\n+        def isl = topology.islsForActiveSwitches.find { it.aswitch?.inPort && it.aswitch?.outPort &&\n+                [it.srcSwitch, it.dstSwitch].every { it.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD) }\n+        }\n+        assumeTrue(\"Wasn't able to find round-trip ISL with a-switch\", isl != null)\n+        bfd && northboundV2.setLinkBfd(isl)\n+\n+        when: \"Port down event happens\"\n+        antiflap.portDown(isl.srcSwitch.dpId, isl.srcPort)\n+        cleanupActions << { antiflap.portUp(isl.srcSwitch.dpId, isl.srcPort) }\n+\n+        then: \"ISL changed status to FAILED\"\n+        Wrappers.wait(WAIT_OFFSET * 2) {", "originalCommit": "f1a1f5512e8f6235e7fb12c5f9c86af17b3ce293", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk5OTEzMQ==", "url": "https://github.com/telstra/open-kilda/pull/3840#discussion_r521999131", "bodyText": "fixed", "author": "rtretyak", "createdAt": "2020-11-12T10:27:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYzMDM5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYzMTgyMQ==", "url": "https://github.com/telstra/open-kilda/pull/3840#discussion_r520631821", "bodyText": "wait is needless here, I guess\nThe isl is already failed (L57-58)", "author": "andriidovhan", "createdAt": "2020-11-10T15:03:50Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/RoundTripIslSpec.groovy", "diffHunk": "@@ -33,6 +37,62 @@ class RoundTripIslSpec extends HealthCheckSpecification {\n     via the 'knockoutSwitch' method on the stage env*/\n     Integer customWaitOffset = WAIT_OFFSET * 4\n \n+    @Unroll\n+    @Tidy\n+    def \"Isl with round-trip properly changes status after port events(#descr)\"() {\n+        given: \"Round-trip ISL with a-switch\"\n+        def cleanupActions = []\n+        def isl = topology.islsForActiveSwitches.find { it.aswitch?.inPort && it.aswitch?.outPort &&\n+                [it.srcSwitch, it.dstSwitch].every { it.features.contains(SwitchFeature.NOVIFLOW_COPY_FIELD) }\n+        }\n+        assumeTrue(\"Wasn't able to find round-trip ISL with a-switch\", isl != null)\n+        bfd && northboundV2.setLinkBfd(isl)\n+\n+        when: \"Port down event happens\"\n+        antiflap.portDown(isl.srcSwitch.dpId, isl.srcPort)\n+        cleanupActions << { antiflap.portUp(isl.srcSwitch.dpId, isl.srcPort) }\n+\n+        then: \"ISL changed status to FAILED\"\n+        Wrappers.wait(WAIT_OFFSET * 2) {\n+            assert northbound.getLink(isl).state == FAILED\n+            assert northbound.getLink(isl.reversed).state == FAILED\n+        }\n+\n+        when: \"Port up event happens, but traffic goes only in one direction\"\n+        lockKeeper.removeFlows([isl.aswitch])\n+        cleanupActions << { lockKeeper.addFlows([isl.aswitch]) }\n+        cleanupActions.pop().call() //antiflap.portUp(isl.srcSwitch.dpId, isl.srcPort)\n+\n+        then: \"ISL is not getting discovered\"\n+        TimeUnit.SECONDS.sleep(discoveryInterval + 2)\n+        Wrappers.wait(WAIT_OFFSET) {", "originalCommit": "f1a1f5512e8f6235e7fb12c5f9c86af17b3ce293", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTk5OTE4OQ==", "url": "https://github.com/telstra/open-kilda/pull/3840#discussion_r521999189", "bodyText": "fixed", "author": "rtretyak", "createdAt": "2020-11-12T10:27:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYzMTgyMQ=="}], "type": "inlineReview"}, {"oid": "3a8decc7ddeda06fdcc32318e37d67af22a3bed0", "url": "https://github.com/telstra/open-kilda/commit/3a8decc7ddeda06fdcc32318e37d67af22a3bed0", "message": "Add test for round-trip isl discovery in special cases", "committedDate": "2020-11-12T10:25:14Z", "type": "commit"}, {"oid": "3a8decc7ddeda06fdcc32318e37d67af22a3bed0", "url": "https://github.com/telstra/open-kilda/commit/3a8decc7ddeda06fdcc32318e37d67af22a3bed0", "message": "Add test for round-trip isl discovery in special cases", "committedDate": "2020-11-12T10:25:14Z", "type": "forcePushed"}]}