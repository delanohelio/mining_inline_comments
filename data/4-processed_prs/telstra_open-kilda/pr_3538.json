{"pr_number": 3538, "pr_title": "Server42 Part 3 Storm Control Topology", "pr_createdAt": "2020-06-11T17:17:23Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3538", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI2NTU5Mg==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r440265592", "bodyText": "Perhaps we can move this \"mapping\" inside mapping class/utility and produce it with mapstruct?", "author": "surabujin", "createdAt": "2020-06-15T15:36:26Z", "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/bolts/FlowUpdateHubBolt.java", "diffHunk": "@@ -112,6 +119,43 @@ public void sendPeriodicPingNotification(String flowId, boolean enabled) {\n         emitWithContext(Stream.HUB_TO_PING_SENDER.name(), getCurrentTuple(), new Values(currentKey, message));\n     }\n \n+    @Override\n+    public void sendActivateFlowMonitoring(RequestedFlow flow) {\n+        //TODO(nmarchenko) move that to some util method to avoid duplicate with create\n+        FlowEndpointPayload src = FlowEndpointPayload.builder()", "originalCommit": "c84a1998b39c03df3fc4bd3b09f848cae5b00c41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA1NTI4Nw==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r445055287", "bodyText": "done", "author": "nikitamarchenko", "createdAt": "2020-06-24T17:27:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI2NTU5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI2NjU4NA==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r440266584", "bodyText": "you don't trust to .equals(...) method?", "author": "surabujin", "createdAt": "2020-06-15T15:37:54Z", "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/create/action/OnFinishedAction.java", "diffHunk": "@@ -38,6 +38,9 @@ public void perform(State from, State to, Event event, FlowCreateContext context\n         RequestedFlow requestedFlow = stateMachine.getTargetFlow();\n         stateMachine.getCarrier().sendPeriodicPingNotification(requestedFlow.getFlowId(),\n                 requestedFlow.isPeriodicPings());\n+        if (requestedFlow.getSrcSwitch().toLong() != requestedFlow.getDestSwitch().toLong()) {", "originalCommit": "c84a1998b39c03df3fc4bd3b09f848cae5b00c41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA1ODgzNw==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r445058837", "bodyText": "done", "author": "nikitamarchenko", "createdAt": "2020-06-24T17:33:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI2NjU4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3NTU2Mg==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r440675562", "bodyText": "return featureTogglesRepository.find()\n                .map(FeatureToggles::getServer42FlowRtt)\n                .orElse(FeatureToggles.DEFAULTS.getServer42FlowRtt());\n\nWhy not?\nIt will allow us to keep all default values in a single place and change them at any time without worries that some places use hardcoded default values.", "author": "surabujin", "createdAt": "2020-06-16T08:26:40Z", "path": "src-java/server42/server42-control-storm-topology/src/main/java/org/openkilda/server42/control/topology/service/FlowRttService.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+\n+package org.openkilda.server42.control.topology.service;\n+\n+import org.openkilda.model.FeatureToggles;\n+import org.openkilda.model.Flow;\n+import org.openkilda.model.SwitchId;\n+import org.openkilda.model.SwitchProperties;\n+import org.openkilda.persistence.PersistenceManager;\n+import org.openkilda.persistence.repositories.FeatureTogglesRepository;\n+import org.openkilda.persistence.repositories.FlowRepository;\n+import org.openkilda.persistence.repositories.RepositoryFactory;\n+import org.openkilda.persistence.repositories.SwitchPropertiesRepository;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Slf4j\n+public class FlowRttService {\n+\n+    private final IFlowCarrier carrier;\n+    private final FeatureTogglesRepository featureTogglesRepository;\n+    private final SwitchPropertiesRepository switchPropertiesRepository;\n+    private final FlowRepository flowRepository;\n+\n+    public FlowRttService(IFlowCarrier carrier, PersistenceManager persistenceManager) {\n+        this.carrier = carrier;\n+        RepositoryFactory repositoryFactory = persistenceManager.getRepositoryFactory();\n+        switchPropertiesRepository = repositoryFactory.createSwitchPropertiesRepository();\n+        featureTogglesRepository = repositoryFactory.createFeatureTogglesRepository();\n+        flowRepository = repositoryFactory.createFlowRepository();\n+    }\n+\n+    /**\n+     * Check if rtt global feature enabled and rtt enabled for switch then ask carrier to activate flow.\n+     *\n+     * @param flowId flow id\n+     * @param port switch customer port\n+     * @param vlan switch customer vlan id\n+     * @param isForward is endpoint forward\n+     */\n+    public void activateFlowMonitoring(String flowId, SwitchId switchId, Integer port, Integer vlan,\n+                                       boolean isForward) {\n+        if (isFlowRttFeatureToggle() && isFlowRttFeatureEnabledFor(switchId)) {\n+            carrier.notifyActivateFlowMonitoring(flowId, switchId, port, vlan, isForward);\n+        } else {\n+            log.info(\"skip activation of flow RTT for flow: {} and switch:{}\", flowId, switchId);\n+        }\n+    }\n+\n+    /**\n+     * Activate monitoring for all existed flows on provided switch.\n+     * @param switchId switch id\n+     */\n+    public void activateFlowMonitoringForSwitch(SwitchId switchId) {\n+        Map<Boolean, List<Flow>> flowByDirection =\n+                flowRepository.findByEndpointSwitch(switchId).stream().collect(Collectors.partitioningBy(\n+                        f -> f.getSrcSwitch().getSwitchId().toLong() == switchId.toLong()));\n+\n+        flowByDirection.get(true).forEach(flow -> carrier.notifyActivateFlowMonitoring(flow.getFlowId(),\n+                switchId, flow.getSrcPort(), flow.getSrcVlan(), true\n+        ));\n+\n+        flowByDirection.get(false).forEach(flow -> carrier.notifyActivateFlowMonitoring(flow.getFlowId(),\n+                switchId, flow.getDestPort(), flow.getDestVlan(), false\n+        ));\n+    }\n+\n+    private boolean isFlowRttFeatureToggle() {\n+        return featureTogglesRepository.find().map(FeatureToggles::getServer42FlowRtt).orElse(false);", "originalCommit": "c84a1998b39c03df3fc4bd3b09f848cae5b00c41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA1OTMyMw==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r445059323", "bodyText": "done", "author": "nikitamarchenko", "createdAt": "2020-06-24T17:34:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3NTU2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3OTA0OQ==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r440679049", "bodyText": "Should we filter out one-switch flows here?", "author": "surabujin", "createdAt": "2020-06-16T08:32:10Z", "path": "src-java/server42/server42-control-storm-topology/src/main/java/org/openkilda/server42/control/topology/service/FlowRttService.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+\n+package org.openkilda.server42.control.topology.service;\n+\n+import org.openkilda.model.FeatureToggles;\n+import org.openkilda.model.Flow;\n+import org.openkilda.model.SwitchId;\n+import org.openkilda.model.SwitchProperties;\n+import org.openkilda.persistence.PersistenceManager;\n+import org.openkilda.persistence.repositories.FeatureTogglesRepository;\n+import org.openkilda.persistence.repositories.FlowRepository;\n+import org.openkilda.persistence.repositories.RepositoryFactory;\n+import org.openkilda.persistence.repositories.SwitchPropertiesRepository;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Slf4j\n+public class FlowRttService {\n+\n+    private final IFlowCarrier carrier;\n+    private final FeatureTogglesRepository featureTogglesRepository;\n+    private final SwitchPropertiesRepository switchPropertiesRepository;\n+    private final FlowRepository flowRepository;\n+\n+    public FlowRttService(IFlowCarrier carrier, PersistenceManager persistenceManager) {\n+        this.carrier = carrier;\n+        RepositoryFactory repositoryFactory = persistenceManager.getRepositoryFactory();\n+        switchPropertiesRepository = repositoryFactory.createSwitchPropertiesRepository();\n+        featureTogglesRepository = repositoryFactory.createFeatureTogglesRepository();\n+        flowRepository = repositoryFactory.createFlowRepository();\n+    }\n+\n+    /**\n+     * Check if rtt global feature enabled and rtt enabled for switch then ask carrier to activate flow.\n+     *\n+     * @param flowId flow id\n+     * @param port switch customer port\n+     * @param vlan switch customer vlan id\n+     * @param isForward is endpoint forward\n+     */\n+    public void activateFlowMonitoring(String flowId, SwitchId switchId, Integer port, Integer vlan,\n+                                       boolean isForward) {\n+        if (isFlowRttFeatureToggle() && isFlowRttFeatureEnabledFor(switchId)) {\n+            carrier.notifyActivateFlowMonitoring(flowId, switchId, port, vlan, isForward);\n+        } else {\n+            log.info(\"skip activation of flow RTT for flow: {} and switch:{}\", flowId, switchId);\n+        }\n+    }\n+\n+    /**\n+     * Activate monitoring for all existed flows on provided switch.\n+     * @param switchId switch id\n+     */\n+    public void activateFlowMonitoringForSwitch(SwitchId switchId) {\n+        Map<Boolean, List<Flow>> flowByDirection =\n+                flowRepository.findByEndpointSwitch(switchId).stream().collect(Collectors.partitioningBy(", "originalCommit": "c84a1998b39c03df3fc4bd3b09f848cae5b00c41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA2MTUyNQ==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r445061525", "bodyText": "done", "author": "nikitamarchenko", "createdAt": "2020-06-24T17:38:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3OTA0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY4Mjc3OQ==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r440682779", "bodyText": "Possible NPE here - chances are low but still exists. If there is a \"corrupter\" flow in DB with only 1 path in one direction - and there is only one such flow for this switch - NPE will arrive here (and for reverse/false side too).", "author": "surabujin", "createdAt": "2020-06-16T08:38:01Z", "path": "src-java/server42/server42-control-storm-topology/src/main/java/org/openkilda/server42/control/topology/service/FlowRttService.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+\n+package org.openkilda.server42.control.topology.service;\n+\n+import org.openkilda.model.FeatureToggles;\n+import org.openkilda.model.Flow;\n+import org.openkilda.model.SwitchId;\n+import org.openkilda.model.SwitchProperties;\n+import org.openkilda.persistence.PersistenceManager;\n+import org.openkilda.persistence.repositories.FeatureTogglesRepository;\n+import org.openkilda.persistence.repositories.FlowRepository;\n+import org.openkilda.persistence.repositories.RepositoryFactory;\n+import org.openkilda.persistence.repositories.SwitchPropertiesRepository;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Slf4j\n+public class FlowRttService {\n+\n+    private final IFlowCarrier carrier;\n+    private final FeatureTogglesRepository featureTogglesRepository;\n+    private final SwitchPropertiesRepository switchPropertiesRepository;\n+    private final FlowRepository flowRepository;\n+\n+    public FlowRttService(IFlowCarrier carrier, PersistenceManager persistenceManager) {\n+        this.carrier = carrier;\n+        RepositoryFactory repositoryFactory = persistenceManager.getRepositoryFactory();\n+        switchPropertiesRepository = repositoryFactory.createSwitchPropertiesRepository();\n+        featureTogglesRepository = repositoryFactory.createFeatureTogglesRepository();\n+        flowRepository = repositoryFactory.createFlowRepository();\n+    }\n+\n+    /**\n+     * Check if rtt global feature enabled and rtt enabled for switch then ask carrier to activate flow.\n+     *\n+     * @param flowId flow id\n+     * @param port switch customer port\n+     * @param vlan switch customer vlan id\n+     * @param isForward is endpoint forward\n+     */\n+    public void activateFlowMonitoring(String flowId, SwitchId switchId, Integer port, Integer vlan,\n+                                       boolean isForward) {\n+        if (isFlowRttFeatureToggle() && isFlowRttFeatureEnabledFor(switchId)) {\n+            carrier.notifyActivateFlowMonitoring(flowId, switchId, port, vlan, isForward);\n+        } else {\n+            log.info(\"skip activation of flow RTT for flow: {} and switch:{}\", flowId, switchId);\n+        }\n+    }\n+\n+    /**\n+     * Activate monitoring for all existed flows on provided switch.\n+     * @param switchId switch id\n+     */\n+    public void activateFlowMonitoringForSwitch(SwitchId switchId) {\n+        Map<Boolean, List<Flow>> flowByDirection =\n+                flowRepository.findByEndpointSwitch(switchId).stream().collect(Collectors.partitioningBy(\n+                        f -> f.getSrcSwitch().getSwitchId().toLong() == switchId.toLong()));\n+\n+        flowByDirection.get(true).forEach(flow -> carrier.notifyActivateFlowMonitoring(flow.getFlowId(),", "originalCommit": "c84a1998b39c03df3fc4bd3b09f848cae5b00c41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA2MjYwOA==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r445062608", "bodyText": "done", "author": "nikitamarchenko", "createdAt": "2020-06-24T17:40:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY4Mjc3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY5MjAxMA==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r440692010", "bodyText": "Abstract bolt already does this (with the only difference - it will add \"Unhandled exception prefix\" to the log message).", "author": "surabujin", "createdAt": "2020-06-16T08:52:16Z", "path": "src-java/server42/server42-control-storm-topology/src/main/java/org/openkilda/server42/control/topology/storm/bolt/flow/FlowHandler.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.server42.control.topology.storm.bolt.flow;\n+\n+import org.openkilda.messaging.payload.flow.FlowEndpointPayload;\n+import org.openkilda.model.SwitchId;\n+import org.openkilda.persistence.PersistenceManager;\n+import org.openkilda.server42.control.messaging.flowrtt.AddFlow;\n+import org.openkilda.server42.control.messaging.flowrtt.ClearFlows;\n+import org.openkilda.server42.control.messaging.flowrtt.Headers;\n+import org.openkilda.server42.control.messaging.flowrtt.RemoveFlow;\n+import org.openkilda.server42.control.topology.service.FlowRttService;\n+import org.openkilda.server42.control.topology.service.IFlowCarrier;\n+import org.openkilda.server42.control.topology.storm.ComponentId;\n+import org.openkilda.server42.control.topology.storm.bolt.flow.command.FlowCommand;\n+import org.openkilda.server42.control.topology.storm.bolt.router.Router;\n+import org.openkilda.server42.messaging.FlowDirection;\n+import org.openkilda.wfm.AbstractBolt;\n+import org.openkilda.wfm.error.PipelineException;\n+\n+import org.apache.storm.kafka.bolt.mapper.FieldNameBasedTupleToKafkaMapper;\n+import org.apache.storm.topology.OutputFieldsDeclarer;\n+import org.apache.storm.tuple.Fields;\n+import org.apache.storm.tuple.Tuple;\n+import org.apache.storm.tuple.Values;\n+\n+public class FlowHandler extends AbstractBolt\n+        implements IFlowCarrier {\n+\n+    public static final String BOLT_ID = ComponentId.FLOW_HANDLER.toString();\n+\n+    public static final String STREAM_CONTROL_COMMANDS_ID = \"control.commands\";\n+    public static final Fields STREAM_CONTROL_COMMANDS_FIELDS = new Fields(FieldNameBasedTupleToKafkaMapper.BOLT_KEY,\n+            FieldNameBasedTupleToKafkaMapper.BOLT_MESSAGE);\n+    private final PersistenceManager persistenceManager;\n+    private transient FlowRttService flowRttService;\n+\n+    public FlowHandler(PersistenceManager persistenceManager) {\n+        this.persistenceManager = persistenceManager;\n+    }\n+\n+    protected void init() {\n+        this.flowRttService = new FlowRttService(this, persistenceManager);\n+    }\n+\n+    @Override\n+    protected void handleInput(Tuple input) throws Exception {\n+        String source = input.getSourceComponent();\n+        if (Router.BOLT_ID.equals(source)) {\n+            handleRouterCommand(input);\n+        } else {\n+            unhandledInput(input);\n+        }\n+    }\n+\n+    @Override\n+    protected void handleException(Exception error) throws Exception {", "originalCommit": "c84a1998b39c03df3fc4bd3b09f848cae5b00c41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA0NDIyMw==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r445044223", "bodyText": "done", "author": "nikitamarchenko", "createdAt": "2020-06-24T17:07:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY5MjAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY5NDY1OQ==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r440694659", "bodyText": "Why there is no headers(correlation-id) here?", "author": "surabujin", "createdAt": "2020-06-16T08:56:22Z", "path": "src-java/server42/server42-control-storm-topology/src/main/java/org/openkilda/server42/control/topology/storm/bolt/flow/FlowHandler.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.server42.control.topology.storm.bolt.flow;\n+\n+import org.openkilda.messaging.payload.flow.FlowEndpointPayload;\n+import org.openkilda.model.SwitchId;\n+import org.openkilda.persistence.PersistenceManager;\n+import org.openkilda.server42.control.messaging.flowrtt.AddFlow;\n+import org.openkilda.server42.control.messaging.flowrtt.ClearFlows;\n+import org.openkilda.server42.control.messaging.flowrtt.Headers;\n+import org.openkilda.server42.control.messaging.flowrtt.RemoveFlow;\n+import org.openkilda.server42.control.topology.service.FlowRttService;\n+import org.openkilda.server42.control.topology.service.IFlowCarrier;\n+import org.openkilda.server42.control.topology.storm.ComponentId;\n+import org.openkilda.server42.control.topology.storm.bolt.flow.command.FlowCommand;\n+import org.openkilda.server42.control.topology.storm.bolt.router.Router;\n+import org.openkilda.server42.messaging.FlowDirection;\n+import org.openkilda.wfm.AbstractBolt;\n+import org.openkilda.wfm.error.PipelineException;\n+\n+import org.apache.storm.kafka.bolt.mapper.FieldNameBasedTupleToKafkaMapper;\n+import org.apache.storm.topology.OutputFieldsDeclarer;\n+import org.apache.storm.tuple.Fields;\n+import org.apache.storm.tuple.Tuple;\n+import org.apache.storm.tuple.Values;\n+\n+public class FlowHandler extends AbstractBolt\n+        implements IFlowCarrier {\n+\n+    public static final String BOLT_ID = ComponentId.FLOW_HANDLER.toString();\n+\n+    public static final String STREAM_CONTROL_COMMANDS_ID = \"control.commands\";\n+    public static final Fields STREAM_CONTROL_COMMANDS_FIELDS = new Fields(FieldNameBasedTupleToKafkaMapper.BOLT_KEY,\n+            FieldNameBasedTupleToKafkaMapper.BOLT_MESSAGE);\n+    private final PersistenceManager persistenceManager;\n+    private transient FlowRttService flowRttService;\n+\n+    public FlowHandler(PersistenceManager persistenceManager) {\n+        this.persistenceManager = persistenceManager;\n+    }\n+\n+    protected void init() {\n+        this.flowRttService = new FlowRttService(this, persistenceManager);\n+    }\n+\n+    @Override\n+    protected void handleInput(Tuple input) throws Exception {\n+        String source = input.getSourceComponent();\n+        if (Router.BOLT_ID.equals(source)) {\n+            handleRouterCommand(input);\n+        } else {\n+            unhandledInput(input);\n+        }\n+    }\n+\n+    @Override\n+    protected void handleException(Exception error) throws Exception {\n+        try {\n+            super.handleException(error);\n+        } catch (Exception e) {\n+            log.error(e.getMessage(), e);\n+        }\n+    }\n+\n+    @Override\n+    public void declareOutputFields(OutputFieldsDeclarer outputFieldsDeclarer) {\n+        outputFieldsDeclarer.declareStream(STREAM_CONTROL_COMMANDS_ID, STREAM_CONTROL_COMMANDS_FIELDS);\n+    }\n+\n+    private void handleRouterCommand(Tuple input) throws PipelineException {\n+        handleCommand(input, Router.FIELD_ID_COMMAND);\n+    }\n+\n+    private void handleCommand(Tuple input, String fieldName) throws PipelineException {\n+        FlowCommand command = pullValue(input, fieldName, FlowCommand.class);\n+        command.apply(this);\n+    }\n+\n+    public void processActivateFlowMonitoring(String flowId, FlowEndpointPayload flow, boolean isForward) {\n+        flowRttService.activateFlowMonitoring(flowId, flow.getDatapath(), flow.getPortNumber(),\n+                flow.getVlanId(), isForward);\n+    }\n+\n+    public void processDeactivateFlowMonitoring(SwitchId switchId, String flowId) {\n+        // no logic just repack\n+        notifyDeactivateFlowMonitoring(switchId, flowId);\n+    }\n+\n+    public void processActivateFlowMonitoringOnSwitch(SwitchId switchId) {\n+        flowRttService.activateFlowMonitoringForSwitch(switchId);\n+    }\n+\n+    public void processDeactivateFlowMonitoringOnSwitch(SwitchId switchId) {\n+        // no logic just repack\n+        notifyDeactivateFlowMonitoring(switchId);\n+    }\n+\n+    @Override\n+    public void notifyActivateFlowMonitoring(String flowId, SwitchId switchId, Integer port, Integer vlan,\n+                                             boolean isForward) {\n+        AddFlow addFlow = AddFlow.builder()\n+                .flowId(flowId)\n+                .port(port)\n+                .tunnelId(vlan.longValue())\n+                .direction(isForward ? FlowDirection.FORWARD : FlowDirection.REVERSE)\n+                .headers(buildHeader())\n+                .build();\n+\n+        emit(STREAM_CONTROL_COMMANDS_ID, getCurrentTuple(), new Values(switchId.toString(), addFlow));\n+    }\n+\n+    @Override\n+    public void notifyDeactivateFlowMonitoring(SwitchId switchId, String flowId) {\n+        RemoveFlow removeFlow = RemoveFlow.builder()\n+                .flowId(flowId)\n+                .headers(buildHeader())\n+                .build();\n+        emit(STREAM_CONTROL_COMMANDS_ID, getCurrentTuple(), new Values(switchId.toString(), removeFlow));\n+    }\n+\n+    private void notifyDeactivateFlowMonitoring(SwitchId switchId) {\n+        ClearFlows clearFlows = new ClearFlows();", "originalCommit": "c84a1998b39c03df3fc4bd3b09f848cae5b00c41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA2MDY3Nw==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r445060677", "bodyText": "done", "author": "nikitamarchenko", "createdAt": "2020-06-24T17:37:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY5NDY1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgxMzY4OQ==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r440813689", "bodyText": "in groovy can be just def server42switchesDpIds = server42switches*.dpId", "author": "rtretyak", "createdAt": "2020-06-16T12:34:02Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/server42/Server42RttSpec.groovy", "diffHunk": "@@ -0,0 +1,256 @@\n+package org.openkilda.functionaltests.spec.server42\n+\n+import static java.util.stream.Collectors.toSet\n+import static org.openkilda.testing.Constants.STATS_LOGGING_TIMEOUT\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.model.system.FeatureTogglesDto\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.northbound.dto.v1.switches.SwitchPropertiesDto\n+\n+import groovy.time.TimeCategory\n+import org.springframework.beans.factory.annotation.Value\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Narrative\n+import spock.lang.Shared\n+import spock.util.mop.Use\n+\n+\n+@Use(TimeCategory)\n+@Narrative(\"Verify that statistic is collected from server42 Rtt\")\n+class Server42RttSpec extends HealthCheckSpecification {\n+    @Shared\n+    @Value('${opentsdb.metric.prefix}')\n+    String metricPrefix\n+\n+    def \"Create two flow with server42 Rtt feature and check datapoints in opentsdb\"() {\n+        given: \"Two active neighboring switches one with server42 and one without\"\n+\n+        def server42switches = topology.getActiveServer42Switches();\n+\n+        def server42switchesDpIds = server42switches.stream().map(", "originalCommit": "c84a1998b39c03df3fc4bd3b09f848cae5b00c41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA3MDczMg==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r445070732", "bodyText": "done", "author": "nikitamarchenko", "createdAt": "2020-06-24T17:54:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgxMzY4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgxNTczNw==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r440815737", "bodyText": "search is not really required since you already did it on L35. can be just def server42Switch = switchPair.src.dpId", "author": "rtretyak", "createdAt": "2020-06-16T12:37:29Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/server42/Server42RttSpec.groovy", "diffHunk": "@@ -0,0 +1,256 @@\n+package org.openkilda.functionaltests.spec.server42\n+\n+import static java.util.stream.Collectors.toSet\n+import static org.openkilda.testing.Constants.STATS_LOGGING_TIMEOUT\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.model.system.FeatureTogglesDto\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.northbound.dto.v1.switches.SwitchPropertiesDto\n+\n+import groovy.time.TimeCategory\n+import org.springframework.beans.factory.annotation.Value\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Narrative\n+import spock.lang.Shared\n+import spock.util.mop.Use\n+\n+\n+@Use(TimeCategory)\n+@Narrative(\"Verify that statistic is collected from server42 Rtt\")\n+class Server42RttSpec extends HealthCheckSpecification {\n+    @Shared\n+    @Value('${opentsdb.metric.prefix}')\n+    String metricPrefix\n+\n+    def \"Create two flow with server42 Rtt feature and check datapoints in opentsdb\"() {\n+        given: \"Two active neighboring switches one with server42 and one without\"\n+\n+        def server42switches = topology.getActiveServer42Switches();\n+\n+        def server42switchesDpIds = server42switches.stream().map(\n+                { s -> s.getDpId() }).collect(toSet());\n+\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.src.dpId in server42switchesDpIds && !server42switchesDpIds.contains(it.dst.dpId)\n+        }\n+\n+        when: \"Set server42FlowRtt toggle to true\"\n+        enableFlowRtt()\n+\n+        and: \"Set server 42 src switch enabled\"\n+        def server42Switch = server42switches.stream().find { s -> s.getDpId() == switchPair.src.dpId }", "originalCommit": "c84a1998b39c03df3fc4bd3b09f848cae5b00c41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA3OTMzNA==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r445079334", "bodyText": "done", "author": "nikitamarchenko", "createdAt": "2020-06-24T18:10:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgxNTczNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgxOTY0NA==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r440819644", "bodyText": "since you forcibly changed feature toggle with enableFlowRtt() on L40 you need to revert this operation at the end of the test. same for enableFlowRttForSwitch. You may have to remember their original state before changing it in order to properly undo it", "author": "rtretyak", "createdAt": "2020-06-16T12:43:55Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/server42/Server42RttSpec.groovy", "diffHunk": "@@ -0,0 +1,256 @@\n+package org.openkilda.functionaltests.spec.server42\n+\n+import static java.util.stream.Collectors.toSet\n+import static org.openkilda.testing.Constants.STATS_LOGGING_TIMEOUT\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.model.system.FeatureTogglesDto\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.northbound.dto.v1.switches.SwitchPropertiesDto\n+\n+import groovy.time.TimeCategory\n+import org.springframework.beans.factory.annotation.Value\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Narrative\n+import spock.lang.Shared\n+import spock.util.mop.Use\n+\n+\n+@Use(TimeCategory)\n+@Narrative(\"Verify that statistic is collected from server42 Rtt\")\n+class Server42RttSpec extends HealthCheckSpecification {\n+    @Shared\n+    @Value('${opentsdb.metric.prefix}')\n+    String metricPrefix\n+\n+    def \"Create two flow with server42 Rtt feature and check datapoints in opentsdb\"() {\n+        given: \"Two active neighboring switches one with server42 and one without\"\n+\n+        def server42switches = topology.getActiveServer42Switches();\n+\n+        def server42switchesDpIds = server42switches.stream().map(\n+                { s -> s.getDpId() }).collect(toSet());\n+\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.src.dpId in server42switchesDpIds && !server42switchesDpIds.contains(it.dst.dpId)\n+        }\n+\n+        when: \"Set server42FlowRtt toggle to true\"\n+        enableFlowRtt()\n+\n+        and: \"Set server 42 src switch enabled\"\n+        def server42Switch = server42switches.stream().find { s -> s.getDpId() == switchPair.src.dpId }\n+        enableFlowRttForSwitch(server42Switch)\n+\n+        and: \"Flow for forward metric created\"\n+        def flowCreateTime = new Date()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        and: \"Reversed flow for backward metric created\"\n+        def reversedFlow = flowHelperV2.randomFlow(switchPair.reversed)\n+        flowHelperV2.addFlow(reversedFlow)\n+\n+        then: \"Check if stats for forward is available\"\n+        def statsData = null\n+        Wrappers.wait(STATS_LOGGING_TIMEOUT, 1) {\n+            statsData = otsdb.query(flowCreateTime, metricPrefix + \"flow.rtt\",\n+                    [flowid   : flow.flowId,\n+                     direction: \"forward\"]).dps\n+            assert statsData && !statsData.empty\n+        }\n+        and: \"Check if stats for reverse is available\"\n+        Wrappers.wait(STATS_LOGGING_TIMEOUT, 1) {\n+            statsData = otsdb.query(flowCreateTime, metricPrefix + \"flow.rtt\",\n+                    [flowid   : reversedFlow.flowId,\n+                     direction: \"reverse\"]).dps\n+            assert statsData && !statsData.empty\n+        }\n+        and: \"Cleanup: revert system to original state\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+        flowHelperV2.deleteFlow(reversedFlow.flowId)", "originalCommit": "c84a1998b39c03df3fc4bd3b09f848cae5b00c41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQ1MDUxOA==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r449450518", "bodyText": "done", "author": "nikitamarchenko", "createdAt": "2020-07-03T08:28:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgxOTY0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgyNDAzMA==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r440824030", "bodyText": "Since we can still run tests on topologies without server42 it is not guaranteed to find such switchPair. Then the result of 'find' method will be null. After such switch-searching operations we usually do an 'assumption'\nassumeTrue(\"Was not able to find a switch with a server42 connected\", switchPair != null)\n\nIf assumption is not satisfied the test will be marked as 'skipped'", "author": "rtretyak", "createdAt": "2020-06-16T12:50:56Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/server42/Server42RttSpec.groovy", "diffHunk": "@@ -0,0 +1,256 @@\n+package org.openkilda.functionaltests.spec.server42\n+\n+import static java.util.stream.Collectors.toSet\n+import static org.openkilda.testing.Constants.STATS_LOGGING_TIMEOUT\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.model.system.FeatureTogglesDto\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.northbound.dto.v1.switches.SwitchPropertiesDto\n+\n+import groovy.time.TimeCategory\n+import org.springframework.beans.factory.annotation.Value\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Narrative\n+import spock.lang.Shared\n+import spock.util.mop.Use\n+\n+\n+@Use(TimeCategory)\n+@Narrative(\"Verify that statistic is collected from server42 Rtt\")\n+class Server42RttSpec extends HealthCheckSpecification {\n+    @Shared\n+    @Value('${opentsdb.metric.prefix}')\n+    String metricPrefix\n+\n+    def \"Create two flow with server42 Rtt feature and check datapoints in opentsdb\"() {\n+        given: \"Two active neighboring switches one with server42 and one without\"\n+\n+        def server42switches = topology.getActiveServer42Switches();\n+\n+        def server42switchesDpIds = server42switches.stream().map(\n+                { s -> s.getDpId() }).collect(toSet());\n+\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.src.dpId in server42switchesDpIds && !server42switchesDpIds.contains(it.dst.dpId)\n+        }", "originalCommit": "c84a1998b39c03df3fc4bd3b09f848cae5b00c41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA3NzY1Nw==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r445077657", "bodyText": "done", "author": "nikitamarchenko", "createdAt": "2020-06-24T18:07:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgyNDAzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMzMjc3MQ==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r441332771", "bodyText": "this call is not too accurate, since checkpointTime was literally millisecond ago, so you are querying stats data from 'now' to 'now'", "author": "rtretyak", "createdAt": "2020-06-17T07:20:21Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/server42/Server42RttSpec.groovy", "diffHunk": "@@ -0,0 +1,256 @@\n+package org.openkilda.functionaltests.spec.server42\n+\n+import static java.util.stream.Collectors.toSet\n+import static org.openkilda.testing.Constants.STATS_LOGGING_TIMEOUT\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.model.system.FeatureTogglesDto\n+import org.openkilda.model.FlowEncapsulationType\n+import org.openkilda.northbound.dto.v1.switches.SwitchPropertiesDto\n+\n+import groovy.time.TimeCategory\n+import org.springframework.beans.factory.annotation.Value\n+import org.springframework.web.client.HttpClientErrorException\n+import spock.lang.Narrative\n+import spock.lang.Shared\n+import spock.util.mop.Use\n+\n+\n+@Use(TimeCategory)\n+@Narrative(\"Verify that statistic is collected from server42 Rtt\")\n+class Server42RttSpec extends HealthCheckSpecification {\n+    @Shared\n+    @Value('${opentsdb.metric.prefix}')\n+    String metricPrefix\n+\n+    def \"Create two flow with server42 Rtt feature and check datapoints in opentsdb\"() {\n+        given: \"Two active neighboring switches one with server42 and one without\"\n+\n+        def server42switches = topology.getActiveServer42Switches();\n+\n+        def server42switchesDpIds = server42switches.stream().map(\n+                { s -> s.getDpId() }).collect(toSet());\n+\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.src.dpId in server42switchesDpIds && !server42switchesDpIds.contains(it.dst.dpId)\n+        }\n+\n+        when: \"Set server42FlowRtt toggle to true\"\n+        enableFlowRtt()\n+\n+        and: \"Set server 42 src switch enabled\"\n+        def server42Switch = server42switches.stream().find { s -> s.getDpId() == switchPair.src.dpId }\n+        enableFlowRttForSwitch(server42Switch)\n+\n+        and: \"Flow for forward metric created\"\n+        def flowCreateTime = new Date()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        and: \"Reversed flow for backward metric created\"\n+        def reversedFlow = flowHelperV2.randomFlow(switchPair.reversed)\n+        flowHelperV2.addFlow(reversedFlow)\n+\n+        then: \"Check if stats for forward is available\"\n+        def statsData = null\n+        Wrappers.wait(STATS_LOGGING_TIMEOUT, 1) {\n+            statsData = otsdb.query(flowCreateTime, metricPrefix + \"flow.rtt\",\n+                    [flowid   : flow.flowId,\n+                     direction: \"forward\"]).dps\n+            assert statsData && !statsData.empty\n+        }\n+        and: \"Check if stats for reverse is available\"\n+        Wrappers.wait(STATS_LOGGING_TIMEOUT, 1) {\n+            statsData = otsdb.query(flowCreateTime, metricPrefix + \"flow.rtt\",\n+                    [flowid   : reversedFlow.flowId,\n+                     direction: \"reverse\"]).dps\n+            assert statsData && !statsData.empty\n+        }\n+        and: \"Cleanup: revert system to original state\"\n+        flowHelperV2.deleteFlow(flow.flowId)\n+        flowHelperV2.deleteFlow(reversedFlow.flowId)\n+    }\n+\n+    def \"Create two flow with server42 Rtt feature and check feature togglers\"() {\n+        given: \"Two active neighboring switches one with server42 and one without\"\n+\n+        def server42switches = topology.getActiveServer42Switches();\n+\n+        def server42switchesDpIds = server42switches.stream().map(\n+                { s -> s.getDpId() }).collect(toSet());\n+\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.src.dpId in server42switchesDpIds && !server42switchesDpIds.contains(it.dst.dpId)\n+        }\n+\n+        def server42Switch = server42switches.stream().find { s -> s.getDpId() == switchPair.src.dpId }\n+\n+        when: \"Set server42FlowRtt toggle to false\"\n+        disableFlowRtt()\n+\n+        and: \"Set server42Switch FlowRtt deactivated\"\n+        disableFlowRttForSwitch(server42Switch)\n+\n+        and: \"Flow for forward metric created\"\n+        def checkpointTime = new Date()\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        and: \"Reversed flow for backward metric created\"\n+        def reversedFlow = flowHelperV2.randomFlow(switchPair.reversed)\n+        flowHelperV2.addFlow(reversedFlow)\n+\n+        and: \"Check if stats for forward is not available\"\n+        otsdb.query(checkpointTime, metricPrefix + \"flow.rtt\",\n+                [flowid   : flow.flowId,\n+                 direction: \"forward\"]).dps\n+        then: \"No data points for forward flow found\"\n+        thrown(HttpClientErrorException)\n+\n+        when: \"Check if stats for reverse is not available\"\n+        otsdb.query(checkpointTime, metricPrefix + \"flow.rtt\",\n+                [flowid   : reversedFlow.flowId,\n+                 direction: \"reverse\"]).dps\n+        then: \"No data points for reverse flow found\"\n+        thrown(HttpClientErrorException)\n+\n+        when: \"We enable global toggler\"\n+        enableFlowRtt()\n+        checkpointTime = new Date()\n+        and: \"Check if stats for forward is not available\"\n+        otsdb.query(checkpointTime, metricPrefix + \"flow.rtt\",", "originalCommit": "c84a1998b39c03df3fc4bd3b09f848cae5b00c41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQ1MDYxNw==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r449450617", "bodyText": "done", "author": "nikitamarchenko", "createdAt": "2020-07-03T08:28:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMzMjc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYxMzIyMg==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r443613222", "bodyText": "2020", "author": "rozdy", "createdAt": "2020-06-22T14:45:47Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/kafka/ObjectSerializer.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/* Copyright 2019 Telstra Open Source", "originalCommit": "c84a1998b39c03df3fc4bd3b09f848cae5b00c41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA2MzAwNQ==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r445063005", "bodyText": "done", "author": "nikitamarchenko", "createdAt": "2020-06-24T17:40:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYxMzIyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE1NzYzNg==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r444157636", "bodyText": "Why can't we make KafkaEncoder not abstract? Can we get rid of this class?", "author": "rozdy", "createdAt": "2020-06-23T11:38:33Z", "path": "src-java/nbworker-topology/nbworker-storm-topology/src/main/java/org/openkilda/wfm/topology/nbworker/bolts/Server42EncoderBolt.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/* Copyright 2020 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.wfm.topology.nbworker.bolts;\n+\n+import org.openkilda.wfm.share.bolt.KafkaEncoder;\n+\n+public class Server42EncoderBolt extends KafkaEncoder {", "originalCommit": "c84a1998b39c03df3fc4bd3b09f848cae5b00c41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA2NDAwMQ==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r445064001", "bodyText": "we will reimplement the entire messaging system after we move to the next Kafka client.", "author": "nikitamarchenko", "createdAt": "2020-06-24T17:42:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE1NzYzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE2MTUwNw==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r444161507", "bodyText": "Can you add some comments to this readme?", "author": "rozdy", "createdAt": "2020-06-23T11:46:03Z", "path": "src-java/server42/server42-control-storm-topology/README.md", "diffHunk": "@@ -0,0 +1,11 @@\n+{\"clazz\":\"org.openkilda.messaging.info.InfoMessage\",\"payload\":{\"clazz\":\"org.openkilda.server42.control.messaging.flowrtt.ActivateFlowMonitoringInfoData\",\"flowid\":\"26May223903_714_bakingsoda8474\",\"source\":{\"switch-id\":\"00:00:00:00:00:00:00:03\",\"port-id\":10,\"vlan-id\":0,\"inner-vlan-id\":0,\"detect-connected-devices\":{\"lldp\":false,\"arp\":false}},\"destination\":{\"switch-id\":\"00:00:00:00:00:00:00:08\",\"port-id\":10,\"vlan-id\":0,\"inner-vlan-id\":0,\"detect-connected-devices\":{\"lldp\":false,\"arp\":false}},\"timestamp\":1590521951216},\"timestamp\":1590521951099,\"correlation_id\":\"9108c10c-9f88-11ea-87b9-01ca9e008117 : 3ad0a1f4-14e6-4e16-8e28-d82092a1edad : 1590521943945\",\"destination\":null,\"region\":null}\n+\n+{\"clazz\":\"org.openkilda.messaging.info.InfoMessage\",\"payload\":{\"clazz\":\"org.openkilda.server42.control.messaging.flowrtt.DeactivateFlowMonitoringInfoData\",\"flowid\":\"26May223903_714_bakingsoda8474\",\"switch-ids\":[\"00:00:00:00:00:00:00:08\",\"00:00:00:00:00:00:00:03\"],\"timestamp\":1590521957546},\"timestamp\":1590521956918,\"correlation_id\":\"95db30ba-9f88-11ea-87b9-5b861a82ebfb : 55f82eaf-82a1-4a93-b6f5-a883f8d63362 : 1590521956156\",\"destination\":null,\"region\":null}\n+\n+make func-tests PARAMS='--tests DefaultFlowV2Spec.\"System allows tagged traffic via default flow(0<->0)\"'\n+\n+docker exec -ti kafka /opt/kafka/bin/kafka-console-consumer.sh --bootstrap-server=kafka.kilda:9092 --topic=kilda.flowhs.server42-storm-notify.priv\n+\n+make compile\n+storm kill server42-control\n+docker-compose run wfm ./deploy_single_topology.sh server42-control topology.properties", "originalCommit": "c84a1998b39c03df3fc4bd3b09f848cae5b00c41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA2NzkxMg==", "url": "https://github.com/telstra/open-kilda/pull/3538#discussion_r445067912", "bodyText": "wow, that's my draft.", "author": "nikitamarchenko", "createdAt": "2020-06-24T17:49:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDE2MTUwNw=="}], "type": "inlineReview"}, {"oid": "c9534318ef7cd137e98ca5bfb387d9a407712ef5", "url": "https://github.com/telstra/open-kilda/commit/c9534318ef7cd137e98ca5bfb387d9a407712ef5", "message": "Server42 Part 3 Storm Control Topology", "committedDate": "2020-06-29T17:20:21Z", "type": "forcePushed"}, {"oid": "2ea326ca00cd4d5ebce06dc5303f22de2a192f20", "url": "https://github.com/telstra/open-kilda/commit/2ea326ca00cd4d5ebce06dc5303f22de2a192f20", "message": "Server42 Part 3 Storm Control Topology", "committedDate": "2020-07-03T06:43:50Z", "type": "forcePushed"}, {"oid": "aad37ce69ebc40d569c8f918c206e9dfae43ff00", "url": "https://github.com/telstra/open-kilda/commit/aad37ce69ebc40d569c8f918c206e9dfae43ff00", "message": "Server42 Part 3 Storm Control Topology", "committedDate": "2020-07-03T06:53:37Z", "type": "forcePushed"}, {"oid": "4c2ced8230250ad464b435fdaf3c59097b43db8b", "url": "https://github.com/telstra/open-kilda/commit/4c2ced8230250ad464b435fdaf3c59097b43db8b", "message": "Server42 Part 3 Storm Control Topology", "committedDate": "2020-07-03T09:02:13Z", "type": "commit"}, {"oid": "4c2ced8230250ad464b435fdaf3c59097b43db8b", "url": "https://github.com/telstra/open-kilda/commit/4c2ced8230250ad464b435fdaf3c59097b43db8b", "message": "Server42 Part 3 Storm Control Topology", "committedDate": "2020-07-03T09:02:13Z", "type": "forcePushed"}]}