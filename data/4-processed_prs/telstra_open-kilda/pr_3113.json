{"pr_number": 3113, "pr_title": "Add test for #3087", "pr_createdAt": "2020-01-14T14:51:58Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3113", "timeline": [{"oid": "835a9d512942ea75eff14ef1a2788924e2edd2f2", "url": "https://github.com/telstra/open-kilda/commit/835a9d512942ea75eff14ef1a2788924e2edd2f2", "message": "Add test for #3087", "committedDate": "2020-01-14T16:23:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc2MjMzMQ==", "url": "https://github.com/telstra/open-kilda/pull/3113#discussion_r366762331", "bodyText": "northbound.portUp(mainPathUniqueIsl.srcSwitch.dpId, mainPathUniqueIsl.srcPort)\nnorthbound.portUp(commonIsl.srcSwitch.dpId, commonIsl.srcPort)", "author": "andriidovhan", "createdAt": "2020-01-15T09:10:43Z", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -444,6 +448,83 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tidy\n+    def \"System properly handles multiple flow reroutes if ISL on new path breaks while first reroute is in progress\"() {\n+        given: \"Switch pair that have at least 3 paths and 2 paths that have at least 1 common isl\"\n+        List<PathNode> mainPath, backupPath, thirdPath\n+        List<Isl> mainIsls, backupIsls\n+        Isl mainPathUniqueIsl, commonIsl\n+        def swPair = topologyHelper.switchPairs.find { pair ->\n+            //we are looking for 2 paths that have a common isl. This ISL should not be used in third path\n+            mainPath = pair.paths.find { path ->\n+                mainIsls = pathHelper.getInvolvedIsls(path)\n+                backupPath = pair.paths.findAll { it != path }.find { currentBackupPath ->\n+                    backupIsls = pathHelper.getInvolvedIsls(currentBackupPath)\n+                    def mainPathUniqueIsls = mainIsls.findAll {\n+                        !backupIsls.contains(it)\n+                    }\n+                    def commonIsls = backupIsls.findAll {\n+                        it in mainIsls\n+                    }\n+                    //given possible mainPath isls to break and available common isls\n+                    def result = [mainPathUniqueIsls, commonIsls].combinations().find { unique, common ->\n+                        //there should be a safe third path that does not involve any of them\n+                        thirdPath = pair.paths.findAll { it != path && it != currentBackupPath }.find {\n+                            def isls = pathHelper.getInvolvedIsls(it)\n+                            !isls.contains(common) && !isls.contains(unique)\n+                        }\n+                    }\n+                    if(result) {\n+                        mainPathUniqueIsl = result[0]\n+                        commonIsl = result[1]\n+                    }\n+                    thirdPath\n+                }\n+            }\n+        }\n+        assert swPair, \"Not able to find a switch pair with suitable paths\"\n+        log.debug(\"main isls: $mainIsls\")\n+        log.debug(\"backup isls: $backupIsls\")\n+\n+        and: \"A flow over these switches that uses one of the desired paths that have common ISL\"\n+        swPair.paths.findAll { it != mainPath }.each { pathHelper.makePathMorePreferable(mainPath, it) }\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        and: \"A potential 'backup' path that shares common isl has the preferred cost (will be preferred during reroute)\"\n+        //now make backup path more preferable in order to have control over where the reroute will try to failover\n+        northbound.deleteLinkProps(northbound.getAllLinkProps())\n+        swPair.paths.findAll { it != backupPath }.each { pathHelper.makePathMorePreferable(backupPath, it) }\n+\n+        when: \"An ISL which is unique for current path breaks, leading to a flow reroute\"\n+        northbound.portDown(mainPathUniqueIsl.srcSwitch.dpId, mainPathUniqueIsl.srcPort)\n+        Wrappers.wait(3, 0) {\n+            assert northbound.getLink(mainPathUniqueIsl).state == IslChangeType.FAILED\n+        }\n+\n+        and: \"Right when reroute starts: an ISL which is common for current path and potential backup path breaks too, \\\n+triggering one more reroute of the current path\"\n+        sleep(rerouteDelay * 1000 + 50)\n+        northbound.portDown(commonIsl.srcSwitch.dpId, commonIsl.srcPort)\n+\n+        then: \"Flow is UP\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+\n+        and: \"New flow path avoids both main and backup paths as well as broken ISLs\"\n+        def actualIsls = pathHelper.getInvolvedIsls(northbound.getFlowPath(flow.flowId))\n+        !actualIsls.contains(commonIsl)\n+        !actualIsls.contains(mainPathUniqueIsl)\n+\n+        and: \"Flow is pingable\"\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        cleanup:\n+        flowHelperV2.deleteFlow(flow.flowId)", "originalCommit": "835a9d512942ea75eff14ef1a2788924e2edd2f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc2NjcyMw==", "url": "https://github.com/telstra/open-kilda/pull/3113#discussion_r366766723", "bodyText": "flow && flowHelperV2.deleteFlow(flow.flowId)", "author": "andriidovhan", "createdAt": "2020-01-15T09:20:09Z", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -444,6 +448,83 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tidy\n+    def \"System properly handles multiple flow reroutes if ISL on new path breaks while first reroute is in progress\"() {\n+        given: \"Switch pair that have at least 3 paths and 2 paths that have at least 1 common isl\"\n+        List<PathNode> mainPath, backupPath, thirdPath\n+        List<Isl> mainIsls, backupIsls\n+        Isl mainPathUniqueIsl, commonIsl\n+        def swPair = topologyHelper.switchPairs.find { pair ->\n+            //we are looking for 2 paths that have a common isl. This ISL should not be used in third path\n+            mainPath = pair.paths.find { path ->\n+                mainIsls = pathHelper.getInvolvedIsls(path)\n+                backupPath = pair.paths.findAll { it != path }.find { currentBackupPath ->\n+                    backupIsls = pathHelper.getInvolvedIsls(currentBackupPath)\n+                    def mainPathUniqueIsls = mainIsls.findAll {\n+                        !backupIsls.contains(it)\n+                    }\n+                    def commonIsls = backupIsls.findAll {\n+                        it in mainIsls\n+                    }\n+                    //given possible mainPath isls to break and available common isls\n+                    def result = [mainPathUniqueIsls, commonIsls].combinations().find { unique, common ->\n+                        //there should be a safe third path that does not involve any of them\n+                        thirdPath = pair.paths.findAll { it != path && it != currentBackupPath }.find {\n+                            def isls = pathHelper.getInvolvedIsls(it)\n+                            !isls.contains(common) && !isls.contains(unique)\n+                        }\n+                    }\n+                    if(result) {\n+                        mainPathUniqueIsl = result[0]\n+                        commonIsl = result[1]\n+                    }\n+                    thirdPath\n+                }\n+            }\n+        }\n+        assert swPair, \"Not able to find a switch pair with suitable paths\"\n+        log.debug(\"main isls: $mainIsls\")\n+        log.debug(\"backup isls: $backupIsls\")\n+\n+        and: \"A flow over these switches that uses one of the desired paths that have common ISL\"\n+        swPair.paths.findAll { it != mainPath }.each { pathHelper.makePathMorePreferable(mainPath, it) }\n+        def flow = flowHelperV2.randomFlow(swPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        and: \"A potential 'backup' path that shares common isl has the preferred cost (will be preferred during reroute)\"\n+        //now make backup path more preferable in order to have control over where the reroute will try to failover\n+        northbound.deleteLinkProps(northbound.getAllLinkProps())\n+        swPair.paths.findAll { it != backupPath }.each { pathHelper.makePathMorePreferable(backupPath, it) }\n+\n+        when: \"An ISL which is unique for current path breaks, leading to a flow reroute\"\n+        northbound.portDown(mainPathUniqueIsl.srcSwitch.dpId, mainPathUniqueIsl.srcPort)\n+        Wrappers.wait(3, 0) {\n+            assert northbound.getLink(mainPathUniqueIsl).state == IslChangeType.FAILED\n+        }\n+\n+        and: \"Right when reroute starts: an ISL which is common for current path and potential backup path breaks too, \\\n+triggering one more reroute of the current path\"\n+        sleep(rerouteDelay * 1000 + 50)\n+        northbound.portDown(commonIsl.srcSwitch.dpId, commonIsl.srcPort)\n+\n+        then: \"Flow is UP\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+\n+        and: \"New flow path avoids both main and backup paths as well as broken ISLs\"\n+        def actualIsls = pathHelper.getInvolvedIsls(northbound.getFlowPath(flow.flowId))\n+        !actualIsls.contains(commonIsl)\n+        !actualIsls.contains(mainPathUniqueIsl)\n+\n+        and: \"Flow is pingable\"\n+        with(northbound.pingFlow(flow.flowId, new PingInput())) {\n+            it.forward.pingSuccess\n+            it.reverse.pingSuccess\n+        }\n+\n+        cleanup:\n+        flowHelperV2.deleteFlow(flow.flowId)", "originalCommit": "835a9d512942ea75eff14ef1a2788924e2edd2f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "95753697ad5723676106e7d66a21af267e497c5e", "url": "https://github.com/telstra/open-kilda/commit/95753697ad5723676106e7d66a21af267e497c5e", "message": "Add test for #3087", "committedDate": "2020-01-15T13:33:03Z", "type": "forcePushed"}, {"oid": "9684193465abc8e39c152d5b3fa5008733c320cf", "url": "https://github.com/telstra/open-kilda/commit/9684193465abc8e39c152d5b3fa5008733c320cf", "message": "Add test for #3087", "committedDate": "2020-01-15T14:16:41Z", "type": "forcePushed"}, {"oid": "c57860d096ae09f259cda2b566a7bfd0e9e73c3b", "url": "https://github.com/telstra/open-kilda/commit/c57860d096ae09f259cda2b566a7bfd0e9e73c3b", "message": "Add test for #3087", "committedDate": "2020-01-27T15:13:48Z", "type": "forcePushed"}, {"oid": "d97f7ecc695c1ca1bb22708484ec481b39948435", "url": "https://github.com/telstra/open-kilda/commit/d97f7ecc695c1ca1bb22708484ec481b39948435", "message": "Add test for #3087", "committedDate": "2020-02-04T10:49:32Z", "type": "commit"}, {"oid": "d97f7ecc695c1ca1bb22708484ec481b39948435", "url": "https://github.com/telstra/open-kilda/commit/d97f7ecc695c1ca1bb22708484ec481b39948435", "message": "Add test for #3087", "committedDate": "2020-02-04T10:49:32Z", "type": "forcePushed"}]}