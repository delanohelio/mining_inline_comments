{"pr_number": 3787, "pr_title": "Flow loop feature implementation", "pr_createdAt": "2020-10-16T10:21:18Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3787", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ2OTY2MA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r506469660", "bodyText": "Why do you use the plural form (getFlowLoopS)? A flow can't have more than one loop\nProbably would be better to use the singular form (getFlowLoopS -> getFlowLoop)", "author": "andriidovhan", "createdAt": "2020-10-16T14:11:27Z", "path": "src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/controller/v2/FlowControllerV2.java", "diffHunk": "@@ -160,6 +162,50 @@\n         return flowService.patchFlow(flowId, flowPatchDto);\n     }\n \n+    /**\n+     * Get existing flow loops.\n+     *\n+     * @param flowId filter by flow id\n+     * @param switchId filter by switch id\n+     * @return list of flow loops\n+     */\n+    @ApiOperation(value = \"Get flow loops\", response = FlowLoopResponse.class, responseContainer = \"List\")\n+    @GetMapping(value = \"/loop\")\n+    @ResponseStatus(HttpStatus.OK)\n+    public CompletableFuture<List<FlowLoopResponse>> getFlowLoops(", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTI2NjIyNQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r509266225", "bodyText": "This method allows you to get all looped flows in the system by combining filters. You can skip optional flow_id param and get looped flows by switch_id or all of them.", "author": "rozdy", "createdAt": "2020-10-21T13:13:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ2OTY2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzNjc0Ng==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508436746", "bodyText": "Please log or throw an exception for an unhandled request.", "author": "dpoltavets", "createdAt": "2020-10-20T11:52:39Z", "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/bolts/FlowUpdateHubBolt.java", "diffHunk": "@@ -93,8 +95,17 @@ protected void init() {\n     @Override\n     protected void onRequest(Tuple input) throws PipelineException {\n         currentKey = input.getStringByField(MessageKafkaTranslator.FIELD_ID_KEY);\n-        FlowRequest payload = (FlowRequest) input.getValueByField(FIELD_ID_PAYLOAD);\n-        service.handleRequest(currentKey, pullContext(input), payload);\n+        Object payload = input.getValueByField(FIELD_ID_PAYLOAD);\n+        if (payload instanceof FlowRequest) {\n+            FlowRequest flowRequest = (FlowRequest) payload;\n+            service.handleUpdateRequest(currentKey, pullContext(input), flowRequest);\n+        } else if (payload instanceof CreateFlowLoopRequest) {\n+            CreateFlowLoopRequest flowLoopRequest = (CreateFlowLoopRequest) payload;\n+            service.handleCreateFlowLoopRequest(currentKey, pullContext(input), flowLoopRequest);\n+        } else if (payload instanceof DeleteFlowLoopRequest) {\n+            DeleteFlowLoopRequest flowLoopRequest = (DeleteFlowLoopRequest) payload;\n+            service.handleDeleteFlowLoopRequest(currentKey, pullContext(input), flowLoopRequest);\n+        }", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA1NDI5NQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r511054295", "bodyText": "+1", "author": "sergii-iakovenko", "createdAt": "2020-10-23T18:07:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzNjc0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYwOTMxMg==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513609312", "bodyText": "fixed", "author": "rozdy", "createdAt": "2020-10-28T16:57:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzNjc0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzODAzOQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508438039", "bodyText": "You can use the getFlow method defined in FlowProcessingAction.", "author": "dpoltavets", "createdAt": "2020-10-20T11:55:06Z", "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/update/actions/ValidateFlowAction.java", "diffHunk": "@@ -81,9 +84,11 @@ public ValidateFlowAction(PersistenceManager persistenceManager, FlowOperationsD\n         stateMachine.setTargetFlow(targetFlow);\n         stateMachine.setBulkUpdateFlowIds(context.getBulkUpdateFlowIds());\n         stateMachine.setDoNotRevert(context.isDoNotRevert());\n+        Flow flow = flowRepository.findById(flowId)", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYwOTQxNg==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513609416", "bodyText": "done", "author": "rozdy", "createdAt": "2020-10-28T16:57:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzODAzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0MTM4NQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508441385", "bodyText": "Please remove this merge artifact.", "author": "dpoltavets", "createdAt": "2020-10-20T12:00:54Z", "path": "src-java/kilda-persistence-neo4j/src/main/java/org/openkilda/persistence/repositories/impl/Neo4jFlowRepository.java", "diffHunk": "@@ -0,0 +1,673 @@\n+/* Copyright 2018 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.persistence.repositories.impl;\n+\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singleton;\n+\n+import org.openkilda.model.Flow;\n+import org.openkilda.model.FlowFilter;\n+import org.openkilda.model.FlowPath;\n+import org.openkilda.model.FlowStatus;\n+import org.openkilda.model.PathSegment;\n+import org.openkilda.model.Switch;\n+import org.openkilda.model.SwitchId;\n+import org.openkilda.persistence.FetchStrategy;\n+import org.openkilda.persistence.TransactionManager;\n+import org.openkilda.persistence.converters.FlowStatusConverter;\n+import org.openkilda.persistence.converters.SwitchIdConverter;\n+import org.openkilda.persistence.exceptions.PersistenceException;\n+import org.openkilda.persistence.repositories.FlowRepository;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import lombok.NonNull;\n+import lombok.extern.slf4j.Slf4j;\n+import org.neo4j.ogm.cypher.ComparisonOperator;\n+import org.neo4j.ogm.cypher.Filter;\n+import org.neo4j.ogm.cypher.Filters;\n+import org.neo4j.ogm.session.Neo4jSession;\n+import org.neo4j.ogm.session.Session;\n+import org.neo4j.ogm.typeconversion.InstantStringConverter;\n+\n+import java.time.Instant;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+/**\n+ * Neo4j OGM implementation of {@link FlowRepository}.\n+ */\n+@Slf4j\n+public class Neo4jFlowRepository extends Neo4jGenericRepository<Flow> implements FlowRepository {", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYwOTUxNA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513609514", "bodyText": "removed", "author": "rozdy", "createdAt": "2020-10-28T16:57:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0MTM4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0MzgxOQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508443819", "bodyText": "Why did you remove @NonNull?", "author": "dpoltavets", "createdAt": "2020-10-20T12:05:21Z", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/IngressFlowSegmentCommand.java", "diffHunk": "@@ -38,7 +37,7 @@\n     IngressFlowSegmentCommand(\n             MessageContext messageContext, UUID commandId, FlowSegmentMetadata metadata,\n             FlowEndpoint endpoint, MeterConfig meterConfig, SwitchId egressSwitchId, int islPort,\n-            @NonNull FlowTransitEncapsulation encapsulation, RulesContext rulesContext) {\n+            FlowTransitEncapsulation encapsulation, RulesContext rulesContext) {", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY0OTMyNQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508649325", "bodyText": "I know \"why?\" and I don't agree with this.", "author": "surabujin", "createdAt": "2020-10-20T16:02:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0MzgxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYwOTY2OQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513609669", "bodyText": "reworked", "author": "rozdy", "createdAt": "2020-10-28T16:58:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0MzgxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0NTU4OA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508445588", "bodyText": "Why do flow loop rules have this priority?", "author": "dpoltavets", "createdAt": "2020-10-20T12:08:25Z", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/switchmanager/SwitchManager.java", "diffHunk": "@@ -216,6 +216,7 @@\n     public static final int CATCH_BFD_RULE_PRIORITY = DROP_VERIFICATION_LOOP_RULE_PRIORITY + 1;\n     public static final int ROUND_TRIP_LATENCY_RULE_PRIORITY = DROP_VERIFICATION_LOOP_RULE_PRIORITY + 1;\n     public static final int FLOW_PRIORITY = FlowModUtils.PRIORITY_HIGH;\n+    public static final int FLOW_LOOP_PRIORITY = FLOW_PRIORITY + 10;", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY1OTAzMg==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508659032", "bodyText": "+10 is not enough, it will intersect with QinQ rules. Need at least 11, but better 50 or 100 (so you can use -10 as priority step for default-port rules).", "author": "surabujin", "createdAt": "2020-10-20T16:11:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0NTU4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxMDI2OQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513610269", "bodyText": "changed to +100", "author": "rozdy", "createdAt": "2020-10-28T16:58:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0NTU4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODUwMjIyOQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508502229", "bodyText": "Do we really need both looped and loopSwitchId fields? I propose to treat loopSwitchId != null as a looped marker.", "author": "surabujin", "createdAt": "2020-10-20T13:28:52Z", "path": "src-java/base-topology/base-messaging/src/main/java/org/openkilda/messaging/model/FlowDto.java", "diffHunk": "@@ -183,6 +183,12 @@\n     @JsonProperty(\"diverse_with\")\n     private Set<String> diverseWith;\n \n+    @JsonProperty(\"looped\")\n+    private boolean looped;", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxMDQ1Mg==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513610452", "bodyText": "removed looped field", "author": "rozdy", "createdAt": "2020-10-28T16:59:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODUwMjIyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU3NTE3Nw==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508575177", "bodyText": "Use FlowSideAdapter instead of PathSegment is it much more clear - at least you don't need to know is the ingress switch included in the first path segment or not.\nAnd avoid extraction of dependent objects segment.getPath() there was a huge amount of errors created by such coding approach.", "author": "surabujin", "createdAt": "2020-10-20T14:49:03Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java", "diffHunk": "@@ -277,6 +292,72 @@ private FlowSegmentRequestFactory makeIngressRequest(\n                 .build();\n     }\n \n+    private boolean ingressLoopRuleRequired(Flow flow, PathSegment segment) {", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxMDYxMQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513610611", "bodyText": "done", "author": "rozdy", "createdAt": "2020-10-28T16:59:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU3NTE3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU3NjU5Nw==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508576597", "bodyText": "Should it be egressLoopRuleRequired()?", "author": "surabujin", "createdAt": "2020-10-20T14:50:40Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java", "diffHunk": "@@ -243,10 +252,16 @@ private RulesContext createRulesContext(PathContext pathContext) {\n         if (lastSegment != null) {\n             if (doEgress) {\n                 requests.add(makeEgressRequest(context, path, encapsulation, lastSegment, egressSide, ingressSide));\n+                if (transitLoopRuleRequired(flow, lastSegment)) {", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxMTc2MA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513611760", "bodyText": "according to current naming loop rules are called ingress and transit.", "author": "rozdy", "createdAt": "2020-10-28T17:00:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU3NjU5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU5NjI0Nw==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508596247", "bodyText": "??? Why it is here? I mean why it is into metadata? Is the corresponding IngressFlowLoopSegmentRequestFactory not informative enough to define these requirements?\nPS Don't see the usage of these fields.", "author": "surabujin", "createdAt": "2020-10-20T15:14:44Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java", "diffHunk": "@@ -370,9 +451,15 @@ private PathSegmentSide makePathSegmentDestSide(PathSegment segment) {\n                 segment.isDestWithMultiTable());\n     }\n \n+    private FlowSegmentMetadata makeMetadata(String flowId, Cookie cookie, boolean isMultitable,\n+                                             boolean ingressLoopRuleRequired,\n+                                             boolean transitLoopRuleRequired) {\n+        return new FlowSegmentMetadata(flowId, cookie, isMultitable,\n+                ingressLoopRuleRequired, transitLoopRuleRequired);", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxMTg5MQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513611891", "bodyText": "Removed", "author": "rozdy", "createdAt": "2020-10-28T17:01:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU5NjI0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODYyMDA4OQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508620089", "bodyText": "I would like to use OfAdapter.INSTANCE.makeVlanReplaceActions() here as a reference approach to calculate vlan's stack update.", "author": "surabujin", "createdAt": "2020-10-20T15:36:44Z", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/of/IngressInstallFlowModFactory.java", "diffHunk": "@@ -61,6 +63,21 @@ public IngressInstallFlowModFactory(\n         return instructions;\n     }\n \n+    @Override\n+    protected List<OFInstruction> makeIngressFlowLoopInstructions(FlowEndpoint endpoint) {\n+        List<OFAction> actions = new ArrayList<>();\n+        if (endpoint.getInnerVlanId() != 0) {", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxMjAyMA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513612020", "bodyText": "done", "author": "rozdy", "createdAt": "2020-10-28T17:01:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODYyMDA4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODYzNjYyMA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508636620", "bodyText": "I would like to suggest other terminology... because we don't have the egress loop, I would not use the ingress term here. Let's name it endpoint loop i.e. in this case it will makeEndpointLoopRequest and EndpointLoopSegmentRequestFactory (can't say should we include flow anywhere in this name).\nPS I don't have a better name for transit loop segment.", "author": "surabujin", "createdAt": "2020-10-20T15:50:29Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java", "diffHunk": "@@ -277,6 +292,72 @@ private FlowSegmentRequestFactory makeIngressRequest(\n                 .build();\n     }\n \n+    private boolean ingressLoopRuleRequired(Flow flow, PathSegment segment) {\n+        return flow.isLooped() && segment.getSrcSwitch().getSwitchId().equals(flow.getLoopSwitchId())\n+                && !segment.getPath().isProtected();\n+    }\n+\n+    private FlowSegmentRequestFactory makeIngressLoopRequest(", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxNzU0Mg==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513617542", "bodyText": "I prefer naming ingress/transit loop. From flow perspective loop rules either forward traffic input to output (just like single switch ingress rule) or forward traffic to next switch in a looped path (just like transit rule).", "author": "rozdy", "createdAt": "2020-10-28T17:08:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODYzNjYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAwODcwNA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r516008704", "bodyText": "It looks weird when we make makeTransitLoopRequest call to create a rule for the egress switch. :(\nCan we make method makeEgressLoopRequest() and put makeTransitLookRequest call inside it? It will be less confusing, at least for me. And similar wrapper for transitLoopRuleRequired too.", "author": "surabujin", "createdAt": "2020-11-02T14:28:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODYzNjYyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY0MTE5OA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508641198", "bodyText": "Now when we have 2 kind' of requests, we should rename existing makeIngressRequest, makeTransitRequest and makeEgressRequest into makeIngressSegmentRequest, makeTransitSegmentRequest and makeEgressSegmentRequest.", "author": "surabujin", "createdAt": "2020-10-20T15:54:24Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java", "diffHunk": "@@ -277,6 +292,72 @@ private FlowSegmentRequestFactory makeIngressRequest(\n                 .build();\n     }\n \n+    private boolean ingressLoopRuleRequired(Flow flow, PathSegment segment) {\n+        return flow.isLooped() && segment.getSrcSwitch().getSwitchId().equals(flow.getLoopSwitchId())\n+                && !segment.getPath().isProtected();\n+    }\n+\n+    private FlowSegmentRequestFactory makeIngressLoopRequest(\n+            CommandContext context, FlowPath path, FlowTransitEncapsulation encapsulation,\n+            FlowSideAdapter flowSide, PathSegment segment) {\n+        PathSegmentSide segmentSide = makePathSegmentSourceSide(segment);\n+\n+        UUID commandId = commandIdGenerator.generate();\n+        MessageContext messageContext = new MessageContext(commandId.toString(), context.getCorrelationId());\n+        Cookie cookie = path.getCookie().toBuilder().type(CookieType.FLOW_LOOP).build();\n+        return IngressFlowLoopSegmentRequestFactory.builder()\n+                .messageContext(messageContext)\n+                .metadata(makeMetadata(path.getFlow().getFlowId(), cookie, ensureEqualMultiTableFlag(\n+                        flowSide.isMultiTableSegment(), segmentSide.isMultiTable(),\n+                        String.format(\"First flow(id:%s, path:%s) segment and flow level multi-table flag values are \"\n+                                              + \"incompatible to each other - flow(%s) != segment(%s)\",\n+                                      path.getFlow().getFlowId(), path.getPathId(),\n+                                      flowSide.isMultiTableSegment(), segmentSide.isMultiTable())),\n+                        true, false))\n+                .endpoint(flowSide.getEndpoint())\n+                .islPort(segmentSide.getEndpoint().getPortNumber())\n+                .encapsulation(encapsulation)\n+                .build();\n+    }\n+\n+    private boolean transitLoopRuleRequired(Flow flow, PathSegment segment) {\n+        return flow.isLooped() && segment.getDestSwitch().getSwitchId().equals(flow.getLoopSwitchId())\n+                && !segment.getPath().isProtected();\n+    }\n+\n+    private FlowSegmentRequestFactory makeTransitLoopRequest(", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxNzcwMA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513617700", "bodyText": "done", "author": "rozdy", "createdAt": "2020-10-28T17:09:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY0MTE5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY0NDc2Nw==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508644767", "bodyText": "No. You must not allow this. Search for other solution.", "author": "surabujin", "createdAt": "2020-10-20T15:57:25Z", "path": "src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/floodlight/api/request/IngressFlowSegmentBase.java", "diffHunk": "@@ -48,7 +48,7 @@\n \n     IngressFlowSegmentBase(\n             MessageContext context, UUID commandId, FlowSegmentMetadata metadata, @NonNull FlowEndpoint endpoint,\n-            MeterConfig meterConfig, @NonNull SwitchId egressSwitchId,", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxNzg4Mg==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513617882", "bodyText": "reworked", "author": "rozdy", "createdAt": "2020-10-28T17:09:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY0NDc2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY0NzAxNQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508647015", "bodyText": "One more time - why for you need it here?", "author": "surabujin", "createdAt": "2020-10-20T15:59:51Z", "path": "src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/floodlight/model/FlowSegmentMetadata.java", "diffHunk": "@@ -35,13 +35,31 @@\n     @JsonProperty(\"multi_table\")\n     private final boolean multiTable;\n \n+    @JsonProperty(\"ingress_loop_rule\")\n+    private final boolean ingressLoopRule;\n+\n+    @JsonProperty(\"transit_loop_rule\")\n+    private final boolean transitLoopRule;\n+\n     @JsonCreator\n     public FlowSegmentMetadata(\n             @JsonProperty(\"flowid\") @NonNull String flowId,\n             @JsonProperty(\"cookie\") @NonNull Cookie cookie,\n-            @JsonProperty(\"multi_table\") boolean multiTable) {\n+            @JsonProperty(\"multi_table\") boolean multiTable,\n+            @JsonProperty(\"ingress_loop_rule\") boolean ingressLoopRule,\n+            @JsonProperty(\"transit_loop_rule\") boolean transitLoopRule) {\n+        this.flowId = flowId;\n+        this.cookie = cookie;\n+        this.multiTable = multiTable;\n+        this.ingressLoopRule = ingressLoopRule;\n+        this.transitLoopRule = transitLoopRule;\n+    }\n+\n+    public FlowSegmentMetadata(String flowId, Cookie cookie, boolean multiTable) {\n         this.flowId = flowId;\n         this.cookie = cookie;\n         this.multiTable = multiTable;\n+        this.ingressLoopRule = false;", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxODAzOA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513618038", "bodyText": "removed", "author": "rozdy", "createdAt": "2020-10-28T17:09:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY0NzAxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY0Nzk5Nw==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508647997", "bodyText": "And here too - don't do it.", "author": "surabujin", "createdAt": "2020-10-20T16:00:53Z", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/IngressFlowSegmentBase.java", "diffHunk": "@@ -71,7 +71,7 @@\n \n     IngressFlowSegmentBase(\n             MessageContext messageContext, SwitchId switchId, UUID commandId, FlowSegmentMetadata metadata,\n-            @NonNull FlowEndpoint endpoint, MeterConfig meterConfig, @NonNull SwitchId egressSwitchId,", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxODI1NA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513618254", "bodyText": "reworked", "author": "rozdy", "createdAt": "2020-10-28T17:09:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY0Nzk5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY1MzYwOQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508653609", "bodyText": "-1 in flow segments was used to match already existing priorities. \"normal\" priorities step should be +-10.", "author": "surabujin", "createdAt": "2020-10-20T16:06:46Z", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/of/IngressFlowModFactory.java", "diffHunk": "@@ -297,6 +297,83 @@ public OFFlowMod makeArpInputCustomerFlowMessage() {\n                 .build());\n     }\n \n+    /**\n+     * Make ingress flow loop rule to match all port traffic and route it back to port from where it came.\n+     */\n+    public OFFlowMod makeDefaultPortIngressFlowLoopMessage() {\n+        FlowEndpoint endpoint = command.getEndpoint();\n+        return flowModBuilderFactory\n+                .makeBuilder(of, TableId.of(SwitchManager.INGRESS_TABLE_ID), -1)", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxODQ4Ng==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513618486", "bodyText": "changed", "author": "rozdy", "createdAt": "2020-10-28T17:10:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY1MzYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY2NTA2OQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508665069", "bodyText": "better one level of if {} else if {} else {} that this 2 level detection.", "author": "surabujin", "createdAt": "2020-10-20T16:18:24Z", "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/bolts/RouterBolt.java", "diffHunk": "@@ -98,6 +100,12 @@ protected void handleInput(Tuple input) {\n         } else if (data instanceof SwapFlowEndpointRequest) {\n             log.debug(\"Received a swap flow endpoints request with key {}. MessageId {}\", key, input.getMessageId());\n             emitWithContext(ROUTER_TO_FLOW_SWAP_ENDPOINTS_HUB.name(), input, new Values(key, data));\n+        } else if (data instanceof FlowLoopRequest) {\n+            String type = data instanceof CreateFlowLoopRequest ? \"create\" : \"delete\";", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxODY1OA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513618658", "bodyText": "done", "author": "rozdy", "createdAt": "2020-10-28T17:10:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY2NTA2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY2NjYyMA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508666620", "bodyText": "brrr... move it into some method.", "author": "surabujin", "createdAt": "2020-10-20T16:20:31Z", "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/update/actions/InstallIngressRulesAction.java", "diffHunk": "@@ -62,21 +65,57 @@ protected void perform(State from, State to, Event event, FlowUpdateContext cont\n         switch (stateMachine.getEndpointUpdate()) {\n             case SOURCE:\n                 speakerContext.getForward().setUpdateMeter(false);\n-                commands.addAll(commandBuilder.buildIngressOnlyOneDirection(\n-                        stateMachine.getCommandContext(), flow, newPrimaryForward, newPrimaryReverse,\n-                        speakerContext.getForward()));\n+                switch (stateMachine.getFlowLoopOperation()) {", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxODc1NA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513618754", "bodyText": "done", "author": "rozdy", "createdAt": "2020-10-28T17:10:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY2NjYyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY2ODA2MA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508668060", "bodyText": "... :(", "author": "surabujin", "createdAt": "2020-10-20T16:22:34Z", "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/update/actions/InstallIngressRulesAction.java", "diffHunk": "@@ -62,21 +65,57 @@ protected void perform(State from, State to, Event event, FlowUpdateContext cont\n         switch (stateMachine.getEndpointUpdate()) {\n             case SOURCE:\n                 speakerContext.getForward().setUpdateMeter(false);\n-                commands.addAll(commandBuilder.buildIngressOnlyOneDirection(\n-                        stateMachine.getCommandContext(), flow, newPrimaryForward, newPrimaryReverse,\n-                        speakerContext.getForward()));\n+                switch (stateMachine.getFlowLoopOperation()) {\n+                    case NONE:\n+                        commands.addAll(commandBuilder.buildIngressOnlyOneDirection(\n+                                stateMachine.getCommandContext(), flow, newPrimaryForward, newPrimaryReverse,\n+                                speakerContext.getForward()));\n+                        break;\n+                    case CREATE:\n+                        commands.addAll(commandBuilder.buildIngressOnlyOneDirection(\n+                                stateMachine.getCommandContext(), flow, newPrimaryForward, newPrimaryReverse,\n+                                speakerContext.getForward()).stream()\n+                                .filter(f -> f instanceof IngressFlowLoopSegmentRequestFactory)", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxOTIyNA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513619224", "bodyText": "Unfortunately I don't have better solution", "author": "rozdy", "createdAt": "2020-10-28T17:11:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY2ODA2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3MjgzMg==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508672832", "bodyText": "Do not introduce new cookie types, add a new flag into FlowSegmentCookie.", "author": "surabujin", "createdAt": "2020-10-20T16:29:44Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/cookie/CookieBase.java", "diffHunk": "@@ -155,6 +155,7 @@ protected static String formatIllegalTypeError(CookieType illegalType, Set<Cooki\n         APPLICATION_MIRROR_FLOW(0x00A),\n         EXCLUSION_FLOW(0x0B),\n         SERVER_42_INGRESS(0x00C),\n+        FLOW_LOOP(0x00D),", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxOTMzNA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513619334", "bodyText": "reworked", "author": "rozdy", "createdAt": "2020-10-28T17:11:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3MjgzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3Mzc3Mg==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508673772", "bodyText": "Do we still need it?", "author": "surabujin", "createdAt": "2020-10-20T16:31:01Z", "path": "src-java/kilda-persistence-neo4j/src/main/java/org/openkilda/persistence/repositories/impl/Neo4jFlowRepository.java", "diffHunk": "@@ -0,0 +1,673 @@\n+/* Copyright 2018 Telstra Open Source", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA1OTYyNA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r511059624", "bodyText": "Right, it must be removed.", "author": "sergii-iakovenko", "createdAt": "2020-10-23T18:18:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3Mzc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxOTQ2OQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513619469", "bodyText": "removed", "author": "rozdy", "createdAt": "2020-10-28T17:11:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3Mzc3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY4MDY5NQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508680695", "bodyText": "It definitely should be loops.", "author": "surabujin", "createdAt": "2020-10-20T16:41:55Z", "path": "src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/controller/v2/FlowControllerV2.java", "diffHunk": "@@ -160,6 +162,50 @@\n         return flowService.patchFlow(flowId, flowPatchDto);\n     }\n \n+    /**\n+     * Get existing flow loops.\n+     *\n+     * @param flowId filter by flow id\n+     * @param switchId filter by switch id\n+     * @return list of flow loops\n+     */\n+    @ApiOperation(value = \"Get flow loops\", response = FlowLoopResponse.class, responseContainer = \"List\")\n+    @GetMapping(value = \"/loop\")", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxOTYwNQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513619605", "bodyText": "done", "author": "rozdy", "createdAt": "2020-10-28T17:11:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY4MDY5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY4MjAzMg==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508682032", "bodyText": "Why we allow \"no response\"?", "author": "surabujin", "createdAt": "2020-10-20T16:44:03Z", "path": "src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/service/impl/FlowServiceImpl.java", "diffHunk": "@@ -699,4 +707,50 @@ private FlowPathPayload buildFlowPathPayload(List<FlowPathDto> paths, String flo\n                 .thenApply(org.openkilda.messaging.nbtopology.response.FlowConnectedDevicesResponse.class::cast)\n                 .thenApply(connectedDeviceMapper::toResponse);\n     }\n+\n+    @Override\n+    public CompletableFuture<List<FlowLoopResponse>> getFlowLoops(String flowId, String switchId) {\n+        logger.info(\"Get flow loops for flow {} and switch {}\", flowId, switchId);\n+\n+        GetFlowLoopsRequest request = new GetFlowLoopsRequest(flowId, switchId);\n+\n+        CommandMessage message = new CommandMessage(\n+                request, System.currentTimeMillis(), RequestCorrelationId.getId(), Destination.WFM);\n+\n+        return messagingChannel.sendAndGet(nbworkerTopic, message)\n+                .thenApply(result -> Optional.of(result).map(FlowLoopsResponse.class::cast)\n+                        .map(FlowLoopsResponse::getPayload)\n+                        .orElse(Collections.emptyList())", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyMDI2MQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513620261", "bodyText": "System may not have any looped flows", "author": "rozdy", "createdAt": "2020-10-28T17:12:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY4MjAzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY5NTI3NQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r508695275", "bodyText": "Can we move it to the DB level?", "author": "surabujin", "createdAt": "2020-10-20T17:04:27Z", "path": "src-java/kilda-persistence-tinkerpop/src/main/java/org/openkilda/persistence/ferma/repositories/FermaFlowRepository.java", "diffHunk": "@@ -500,6 +500,24 @@ public long computeFlowsBandwidthSum(Set<String> flowIds) {\n                         }));\n     }\n \n+    @Override\n+    public Collection<Flow> findLoopedByFlowIdAndLoopSwitchId(String flowId, SwitchId switchId) {\n+        return framedGraph().traverse(g -> {\n+            GraphTraversal<Vertex, Vertex> vertexVertexGraphTraversal = g.V()\n+                    .hasLabel(FlowFrame.FRAME_LABEL)\n+                    .has(FlowFrame.LOOPED_PROPERTY, true);\n+            if (flowId != null) {\n+                vertexVertexGraphTraversal.has(FlowFrame.FLOW_ID_PROPERTY, flowId);\n+            }\n+            return vertexVertexGraphTraversal;\n+        }).toListExplicit(FlowFrame.class).stream()\n+                .map(Flow::new)\n+                .filter(f -> switchId == null", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA2MjgxMw==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r511062813", "bodyText": "From performance standpoint, it's better to refactor this method into 2 traverses with subsequent concatenation:\nString switchIdAsStr = SwitchIdConverter.INSTANCE.toGraphProperty(switchId);\n\nList<Flow> result = new ArrayList<>();\n        \nframedGraph().traverse(g -> g.V()\n                .hasLabel(FlowFrame.FRAME_LABEL)\n                .has(FlowFrame.SRC_SWITCH_ID_PROPERTY, switchIdAsStr)\n                .has(FlowFrame.LOOPED_PROPERTY, true))\n                .frameExplicit(FlowFrame.class)\n                .forEachRemaining(frame -> result.add(new Flow(frame))));\n\nframedGraph().traverse(g -> g.V()\n                .hasLabel(FlowFrame.FRAME_LABEL)\n                .has(FlowFrame.DST_SWITCH_ID_PROPERTY, switchIdAsStr)\n               .has(FlowFrame.LOOPED_PROPERTY, true))\n                .frameExplicit(FlowFrame.class)\n                .forEachRemaining(frame -> result.add(new Flow(frame)));\n\nreturn result;\n\nIn this approach the indexes are used instead of full scan.", "author": "sergii-iakovenko", "createdAt": "2020-10-23T18:24:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY5NTI3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyMDM4OQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513620389", "bodyText": "done", "author": "rozdy", "createdAt": "2020-10-28T17:12:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY5NTI3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA1ODAwNg==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r511058006", "bodyText": "A switch statement inside another switch is very confusing. Pls, consider refactoring - e.g. move into a method.", "author": "sergii-iakovenko", "createdAt": "2020-10-23T18:15:10Z", "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/fsm/update/actions/InstallNonIngressRulesAction.java", "diffHunk": "@@ -84,16 +87,40 @@ protected void perform(State from, State to,\n     }\n \n     private Collection<FlowSegmentRequestFactory> buildCommands(FlowCommandBuilder commandBuilder,\n-                                                                CommandContext context, Flow flow,\n-                                                                FlowPath path, FlowPath oppositePath,\n-                                                                FlowUpdateFsm.EndpointUpdate endpointUpdate) {\n-        switch (endpointUpdate) {\n+                                                                FlowUpdateFsm stateMachine, Flow flow,\n+                                                                FlowPath path, FlowPath oppositePath) {\n+        CommandContext context = stateMachine.getCommandContext();\n+        switch (stateMachine.getEndpointUpdate()) {\n             case BOTH:\n                 return new ArrayList<>(commandBuilder.buildEgressOnly(context, flow, path, oppositePath));\n             case SOURCE:\n-                return new ArrayList<>(commandBuilder.buildEgressOnlyOneDirection(context, flow, oppositePath, path));\n+                switch (stateMachine.getFlowLoopOperation()) {", "originalCommit": "51ac61bcad0045d7ff94fa2843af85d7590d6b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyMDUyNw==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r513620527", "bodyText": "reworked", "author": "rozdy", "createdAt": "2020-10-28T17:13:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA1ODAwNg=="}], "type": "inlineReview"}, {"oid": "0d0446d560a6fd34ecb2d9ff66dc7b5118fcbdc5", "url": "https://github.com/telstra/open-kilda/commit/0d0446d560a6fd34ecb2d9ff66dc7b5118fcbdc5", "message": "Flow loop feature implementation", "committedDate": "2020-10-28T16:54:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDA1NjA4Nw==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r514056087", "bodyText": "The return value of OfAdapter.INSTANCE.makeVlanReplaceActions() is not used anywhere.", "author": "dpoltavets", "createdAt": "2020-10-29T07:38:43Z", "path": "src-java/floodlight-service/floodlight-modules/src/main/java/org/openkilda/floodlight/command/flow/ingress/of/IngressInstallFlowModFactory.java", "diffHunk": "@@ -61,6 +63,21 @@ public IngressInstallFlowModFactory(\n         return instructions;\n     }\n \n+    @Override\n+    protected List<OFInstruction> makeIngressFlowLoopInstructions(FlowEndpoint endpoint) {\n+        List<OFAction> actions = new ArrayList<>();\n+        if (endpoint.getInnerVlanId() != 0) {\n+            OfAdapter.INSTANCE.makeVlanReplaceActions(of, Collections.singletonList(endpoint.getOuterVlanId()),", "originalCommit": "0d0446d560a6fd34ecb2d9ff66dc7b5118fcbdc5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDI4NzU1NQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r514287555", "bodyText": "Fixed", "author": "rozdy", "createdAt": "2020-10-29T14:09:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDA1NjA4Nw=="}], "type": "inlineReview"}, {"oid": "c34918dd97ae0334c0d8aebac71022f3c248e970", "url": "https://github.com/telstra/open-kilda/commit/c34918dd97ae0334c0d8aebac71022f3c248e970", "message": "Flow loop feature implementation", "committedDate": "2020-10-29T14:05:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk3ODQ4NA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r515978484", "bodyText": "Perhaps we should/can use another coordinate system. For example side identifier (source/dest) and the number of switches from this side 0..N. Relative address is simpler from flow modification perspective, but harder if you need to hit into the specific switch.\nThis is just an idea to think about.", "author": "surabujin", "createdAt": "2020-11-02T13:42:17Z", "path": "src-java/base-topology/base-messaging/src/main/java/org/openkilda/messaging/model/FlowDto.java", "diffHunk": "@@ -183,6 +183,9 @@\n     @JsonProperty(\"diverse_with\")\n     private Set<String> diverseWith;\n \n+    @JsonProperty(\"loop_switch_id\")\n+    private SwitchId loopSwitchId;", "originalCommit": "c34918dd97ae0334c0d8aebac71022f3c248e970", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAxODc4NA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r516018784", "bodyText": "Add \"0x\" prefix to get rid of any ambiguity.", "author": "surabujin", "createdAt": "2020-11-02T14:43:35Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRule.java", "diffHunk": "@@ -59,7 +59,7 @@ public String toString() {\n             outVlanString = \"-\" + outVlanString;\n         }\n         return \"{sw:\" + switchId\n-                + \", ck:\" + cookie\n+                + \", ck:\" + Long.toHexString(cookie)", "originalCommit": "c34918dd97ae0334c0d8aebac71022f3c248e970", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5NTEwOA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r518295108", "bodyText": "Added.", "author": "rozdy", "createdAt": "2020-11-05T19:09:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAxODc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA2MjM4MA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r516062380", "bodyText": "will it work in q-in-q?", "author": "surabujin", "createdAt": "2020-11-02T15:43:56Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRuleConverter.java", "diffHunk": "@@ -114,9 +119,26 @@ private SimpleSwitchRule buildIngressSimpleSwitchRule(Flow flow, FlowPath flowPa\n             } else if (flow.getEncapsulationType().equals(FlowEncapsulationType.VXLAN)) {\n                 rule.setTunnelId(encapsulationId.getEncapsulationId());\n             }\n+\n+            if (flow.getLoopSwitchId() == flowPath.getSrcSwitch().getSwitchId()) {\n+                rules.add(buildIngressLoopSimpleSwitchRule(rule, flowPath, ingress));\n+            }\n         }\n+        rules.add(rule);\n \n-        return rule;\n+        return rules;\n+    }\n+\n+    private SimpleSwitchRule buildIngressLoopSimpleSwitchRule(SimpleSwitchRule rule, FlowPath flowPath,\n+                                                              FlowSideAdapter ingress) {\n+        return SimpleSwitchRule.builder()\n+                .switchId(rule.getSwitchId())\n+                .cookie(flowPath.getCookie().toBuilder().looped(true).build().getValue())\n+                .inPort(rule.getInPort())\n+                .inVlan(rule.getInVlan())", "originalCommit": "c34918dd97ae0334c0d8aebac71022f3c248e970", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5NTMxOQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r518295319", "bodyText": "q-in-q will be covered in next patch", "author": "rozdy", "createdAt": "2020-11-05T19:09:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA2MjM4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA2Mjg5OA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r516062898", "bodyText": "same issue with naming :(", "author": "surabujin", "createdAt": "2020-11-02T15:44:38Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRuleConverter.java", "diffHunk": "@@ -182,8 +206,23 @@ private SimpleSwitchRule buildEgressSimpleSwitchRule(Flow flow, FlowPath flowPat\n             rule.setTunnelId(encapsulationId.getEncapsulationId());\n             rule.setOutVlan(calcVlanSetSequence(Collections.emptyList(), endpoint.getVlanStack()));\n         }\n+        if (flow.getLoopSwitchId() == endpoint.getSwitchId()) {\n+            rules.add(buildTransitLoopSimpleSwitchRule(rule, flowPath));", "originalCommit": "c34918dd97ae0334c0d8aebac71022f3c248e970", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5NTYzOQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r518295639", "bodyText": "I have changed naming. Is it better from your perspective?", "author": "rozdy", "createdAt": "2020-11-05T19:10:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA2Mjg5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA4MzUyOQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r516083529", "bodyText": "... why?", "author": "surabujin", "createdAt": "2020-11-02T16:13:05Z", "path": "src-java/flowhs-topology/flowhs-messaging/src/main/java/org/openkilda/messaging/payload/flow/FlowResponsePayload.java", "diffHunk": "@@ -48,6 +49,10 @@\n     @JsonProperty(\"target-path-computation-strategy\")\n     private String targetPathComputationStrategy;\n \n+    @EqualsAndHashCode.Exclude", "originalCommit": "c34918dd97ae0334c0d8aebac71022f3c248e970", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5NTc0OA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r518295748", "bodyText": "removed", "author": "rozdy", "createdAt": "2020-11-05T19:10:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA4MzUyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA4OTMxNQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r516089315", "bodyText": "You loose looped flag in .toBuilder().build() cycle. Also you need getter for it.", "author": "surabujin", "createdAt": "2020-11-02T16:21:30Z", "path": "src-java/kilda-model/src/main/java/org/openkilda/model/cookie/FlowSegmentCookie.java", "diffHunk": "@@ -133,7 +136,11 @@ private static long makeValue(CookieType type, FlowPathDirection direction, long\n         if (direction != null) {\n             value = makeValueDirection(direction);\n         }\n-        return setField(value, FLOW_EFFECTIVE_ID_FIELD, flowEffectiveId);\n+        long result = setField(value, FLOW_EFFECTIVE_ID_FIELD, flowEffectiveId);\n+        if (looped) {", "originalCommit": "c34918dd97ae0334c0d8aebac71022f3c248e970", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5NTg2MA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r518295860", "bodyText": "added", "author": "rozdy", "createdAt": "2020-11-05T19:10:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA4OTMxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA5MTI2NA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r516091264", "bodyText": "other properties are named via underscores.", "author": "surabujin", "createdAt": "2020-11-02T16:24:16Z", "path": "src-java/kilda-persistence-tinkerpop/src/main/java/org/openkilda/persistence/ferma/frames/FlowFrame.java", "diffHunk": "@@ -73,6 +73,7 @@\n     public static final String DST_LLDP_PROPERTY = \"detect_dst_lldp_connected_devices\";\n     public static final String SRC_ARP_PROPERTY = \"detect_src_arp_connected_devices\";\n     public static final String DST_ARP_PROPERTY = \"detect_dst_arp_connected_devices\";\n+    public static final String LOOP_SWITCH_ID_PROPERTY = \"loopSwitchId\";", "originalCommit": "c34918dd97ae0334c0d8aebac71022f3c248e970", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5NTk0Ng==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r518295946", "bodyText": "changed", "author": "rozdy", "createdAt": "2020-11-05T19:10:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA5MTI2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA5Mjg0OA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r516092848", "bodyText": "Are we going to have more than 1 loop per flow?", "author": "surabujin", "createdAt": "2020-11-02T16:26:22Z", "path": "src-java/northbound-service/northbound/src/main/java/org/openkilda/northbound/controller/v2/FlowControllerV2.java", "diffHunk": "@@ -158,6 +160,50 @@\n         return flowService.patchFlow(flowId, flowPatchDto);\n     }\n \n+    /**\n+     * Get existing flow loops.\n+     *\n+     * @param flowId filter by flow id\n+     * @param switchId filter by switch id\n+     * @return list of flow loops\n+     */\n+    @ApiOperation(value = \"Get flow loops\", response = FlowLoopResponse.class, responseContainer = \"List\")\n+    @GetMapping(value = \"/loops\")\n+    @ResponseStatus(HttpStatus.OK)\n+    public CompletableFuture<List<FlowLoopResponse>> getFlowLoops(\n+            @RequestParam(value = \"flow_id\", required = false) String flowId,\n+            @RequestParam(value = \"switch_id\", required = false) String switchId) {\n+        return flowService.getFlowLoops(flowId, switchId);\n+    }\n+\n+    /**\n+     * Create flow loop.\n+     *\n+     * @param flowId flow id\n+     * @param flowLoopPayload parameters for flow loop\n+     * @return created flow loop\n+     */\n+    @ApiOperation(value = \"Create flow loop\", response = FlowLoopResponse.class)\n+    @PostMapping(value = \"/{flow_id}/loops\")", "originalCommit": "c34918dd97ae0334c0d8aebac71022f3c248e970", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5NjM3NQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r518296375", "bodyText": "No, just a naming convention. We have plural forms everywhere.", "author": "rozdy", "createdAt": "2020-11-05T19:11:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA5Mjg0OA=="}], "type": "inlineReview"}, {"oid": "927a0619b479d74187ae6bca84c9ad28604489ea", "url": "https://github.com/telstra/open-kilda/commit/927a0619b479d74187ae6bca84c9ad28604489ea", "message": "Flow loop feature implementation", "committedDate": "2020-11-05T18:58:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU5MTU5MA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r518591590", "bodyText": "Other loop requests do not verify multitable flag, why this one needs it?", "author": "surabujin", "createdAt": "2020-11-06T08:25:20Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/service/SpeakerFlowSegmentRequestBuilder.java", "diffHunk": "@@ -277,7 +293,76 @@ private FlowSegmentRequestFactory makeIngressRequest(\n                 .build();\n     }\n \n-    private FlowSegmentRequestFactory makeTransitRequest(\n+    private boolean ingressLoopRuleRequired(Flow flow, FlowSideAdapter flowSideAdapter, boolean isProtected) {\n+        return flow.isLooped() && flowSideAdapter.getEndpoint().getSwitchId().equals(flow.getLoopSwitchId())\n+                && !isProtected;\n+    }\n+\n+    private FlowSegmentRequestFactory makeIngressLoopRequest(\n+            CommandContext context, FlowPath path, FlowTransitEncapsulation encapsulation,\n+            FlowSideAdapter flowSide, PathSegment segment, FlowSideAdapter egress) {\n+        PathSegmentSide segmentSide = makePathSegmentSourceSide(segment);\n+\n+        UUID commandId = commandIdGenerator.generate();\n+        MessageContext messageContext = new MessageContext(commandId.toString(), context.getCorrelationId());\n+        Cookie cookie = path.getCookie().toBuilder().looped(true).build();\n+\n+        return IngressFlowLoopSegmentRequestFactory.builder()\n+                .messageContext(messageContext)\n+                .metadata(makeMetadata(path.getFlow().getFlowId(), cookie, ensureEqualMultiTableFlag(", "originalCommit": "927a0619b479d74187ae6bca84c9ad28604489ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkyOTgwNg==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r519929806", "bodyText": "Removed vefification", "author": "rozdy", "createdAt": "2020-11-09T16:08:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU5MTU5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU5NzA2NQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r518597065", "bodyText": "If I were you I will put such check/condition into FlowSideAdapter.", "author": "surabujin", "createdAt": "2020-11-06T08:36:13Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRuleConverter.java", "diffHunk": "@@ -98,6 +99,10 @@ private SimpleSwitchRule buildIngressSimpleSwitchRule(Flow flow, FlowPath flowPa\n             FlowEndpoint egressEndpoint = FlowSideAdapter.makeEgressAdapter(flow, flowPath).getEndpoint();\n             rule.setOutPort(outPort);\n             rule.setOutVlan(calcVlanSetSequence(ingress, egressEndpoint.getVlanStack()));\n+\n+            if (flow.getSrcSwitchId().equals(flow.getLoopSwitchId())) {", "originalCommit": "927a0619b479d74187ae6bca84c9ad28604489ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkyOTk3MQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r519929971", "bodyText": "done", "author": "rozdy", "createdAt": "2020-11-09T16:09:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU5NzA2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU5ODI5Mg==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r518598292", "bodyText": "em???", "author": "surabujin", "createdAt": "2020-11-06T08:38:48Z", "path": "src-java/flowhs-topology/flowhs-messaging/src/main/java/org/openkilda/messaging/payload/flow/FlowResponsePayload.java", "diffHunk": "@@ -48,6 +49,10 @@\n     @JsonProperty(\"target-path-computation-strategy\")\n     private String targetPathComputationStrategy;\n \n+    //@EqualsAndHashCode.Exclude", "originalCommit": "927a0619b479d74187ae6bca84c9ad28604489ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkzMDE4NQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r519930185", "bodyText": "fixed", "author": "rozdy", "createdAt": "2020-11-09T16:09:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU5ODI5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYwOTAwOQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r518609009", "bodyText": "Can/should we check that the loop switch is already null and do nothing in this case? (same for create request, but in case of an equality of the loop switches)", "author": "surabujin", "createdAt": "2020-11-06T08:58:50Z", "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/service/FlowUpdateService.java", "diffHunk": "@@ -147,6 +133,78 @@ public void handleTimeout(String key) {\n         removeIfFinished(fsm, key);\n     }\n \n+    /**\n+     * Handles create flow loop request.\n+     *\n+     * @param request request to handle.\n+     */\n+    public void handleCreateFlowLoopRequest(String key, CommandContext commandContext,\n+                                            CreateFlowLoopRequest request) {\n+        Optional<Flow> flow = flowRepository.findById(request.getFlowId());\n+        if (flow.isPresent()) {\n+            FlowRequest flowRequest = RequestedFlowMapper.INSTANCE.toFlowRequest(flow.get());\n+            flowRequest.setLoopSwitchId(request.getSwitchId());\n+            handleRequest(key, commandContext, flowRequest);\n+        } else {\n+            carrier.sendNorthboundResponse(buildFlowNotFoundErrorMessage(request.getFlowId(), commandContext));\n+        }\n+    }\n+\n+    /**\n+     * Handles delete flow loop request.\n+     *\n+     * @param request request to handle.\n+     */\n+    public void handleDeleteFlowLoopRequest(String key, CommandContext commandContext,\n+                                            DeleteFlowLoopRequest request) {\n+        Optional<Flow> flow = flowRepository.findById(request.getFlowId());\n+        if (flow.isPresent()) {\n+            FlowRequest flowRequest = RequestedFlowMapper.INSTANCE.toFlowRequest(flow.get());\n+            flowRequest.setLoopSwitchId(null);", "originalCommit": "927a0619b479d74187ae6bca84c9ad28604489ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkzMDUzNQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r519930535", "bodyText": "This checks already in FSM code", "author": "rozdy", "createdAt": "2020-11-09T16:09:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYwOTAwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYxMDI2NQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r518610265", "bodyText": "Move it into some method. And you can make this check flow side/endpoint, not for whole flow. Just extend EndpointDescriptor with the required data.", "author": "surabujin", "createdAt": "2020-11-06T09:01:02Z", "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/validation/FlowValidator.java", "diffHunk": "@@ -94,6 +94,41 @@ public void validate(RequestedFlow flow, Set<String> bulkUpdateFlowIds)\n         }\n     }\n \n+    /**\n+     * Validates the specified flow.\n+     *\n+     * @param flow current flow state.\n+     * @param requestedFlow a flow to be validated.\n+     * @param bulkUpdateFlowIds flows to be ignored when check endpoints.\n+     * @throws InvalidFlowException is thrown if a violation is found.\n+     */\n+    public void validate(Flow flow, RequestedFlow requestedFlow, Set<String> bulkUpdateFlowIds)\n+            throws InvalidFlowException, UnavailableFlowEndpointException {\n+        validate(requestedFlow, bulkUpdateFlowIds);\n+        if (requestedFlow.getLoopSwitchId() != null) {", "originalCommit": "927a0619b479d74187ae6bca84c9ad28604489ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkzMjAxMA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r519932010", "bodyText": "Moved to method. I don't think EndpointDescriptor is useful here.", "author": "rozdy", "createdAt": "2020-11-09T16:11:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYxMDI2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYxMDYwOA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r518610608", "bodyText": "em?..", "author": "surabujin", "createdAt": "2020-11-06T09:01:40Z", "path": "src-java/flowhs-topology/flowhs-storm-topology/src/main/java/org/openkilda/wfm/topology/flowhs/validation/FlowValidator.java", "diffHunk": "@@ -352,7 +392,7 @@ private void checkForMultiTableRequirement(EndpointDescriptor descriptor) throws\n         SwitchProperties switchProperties = switchPropertiesRepository.findBySwitchId(\n                 endpoint.getSwitchId())\n                 .orElseGet(() -> SwitchProperties.builder().build());\n-        if (! switchProperties.isMultiTable()) {", "originalCommit": "927a0619b479d74187ae6bca84c9ad28604489ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTkzMjIwMA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r519932200", "bodyText": "Autoformat. Fixed back.", "author": "rozdy", "createdAt": "2020-11-09T16:12:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYxMDYwOA=="}], "type": "inlineReview"}, {"oid": "93b7a3bf254bfa7b8aff442a6d2ad5de040da112", "url": "https://github.com/telstra/open-kilda/commit/93b7a3bf254bfa7b8aff442a6d2ad5de040da112", "message": "Flow loop feature implementation", "committedDate": "2020-11-09T16:05:58Z", "type": "forcePushed"}, {"oid": "b1c7a3c40fd889aee68ae336cf09b7d274e88914", "url": "https://github.com/telstra/open-kilda/commit/b1c7a3c40fd889aee68ae336cf09b7d274e88914", "message": "Flow loop feature implementation", "committedDate": "2020-11-09T18:19:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM3MjU0Ng==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r520372546", "bodyText": "We are making the same rule for single-switch and for multi-switch flows is it expected behavior?", "author": "surabujin", "createdAt": "2020-11-10T08:24:46Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRuleConverter.java", "diffHunk": "@@ -114,9 +119,26 @@ private SimpleSwitchRule buildIngressSimpleSwitchRule(Flow flow, FlowPath flowPa\n             } else if (flow.getEncapsulationType().equals(FlowEncapsulationType.VXLAN)) {\n                 rule.setTunnelId(encapsulationId.getEncapsulationId());\n             }\n+\n+            if (ingress.isLooped() && !flowPath.isProtected()) {\n+                rules.add(buildIngressLoopSimpleSwitchRule(rule, flowPath, ingress));", "originalCommit": "b1c7a3c40fd889aee68ae336cf09b7d274e88914", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc5Njc1Mg==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r520796752", "bodyText": "Ingress loop rule is dependent only on input port and vlan stack so it's the same for single-switch and multi-switch flows.", "author": "rozdy", "createdAt": "2020-11-10T18:53:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM3MjU0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM3NTQyMg==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r520375422", "bodyText": "Here you have a direct and indirect fill of rules. I would like to not mix these approaches, it makes it difficult to understand from reading in one glance.", "author": "surabujin", "createdAt": "2020-11-10T08:29:32Z", "path": "src-java/base-topology/base-storm-topology/src/main/java/org/openkilda/wfm/share/utils/rule/validation/SimpleSwitchRuleConverter.java", "diffHunk": "@@ -114,9 +119,26 @@ private SimpleSwitchRule buildIngressSimpleSwitchRule(Flow flow, FlowPath flowPa\n             } else if (flow.getEncapsulationType().equals(FlowEncapsulationType.VXLAN)) {\n                 rule.setTunnelId(encapsulationId.getEncapsulationId());\n             }\n+\n+            if (ingress.isLooped() && !flowPath.isProtected()) {\n+                rules.add(buildIngressLoopSimpleSwitchRule(rule, flowPath, ingress));\n+            }\n         }\n+        rules.add(rule);", "originalCommit": "b1c7a3c40fd889aee68ae336cf09b7d274e88914", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc5NjkyMw==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r520796923", "bodyText": "Fixed.", "author": "rozdy", "createdAt": "2020-11-10T18:53:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM3NTQyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM4NjA4OQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r520386089", "bodyText": "em... why for?", "author": "surabujin", "createdAt": "2020-11-10T08:46:51Z", "path": "src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/messaging/command/flow/InstallIngressLoopFlow.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/* Copyright 2019 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.messaging.command.flow;\n+\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static org.openkilda.messaging.Utils.FLOW_ID;\n+import static org.openkilda.messaging.Utils.TRANSACTION_ID;\n+\n+import org.openkilda.model.FlowEncapsulationType;\n+import org.openkilda.model.FlowEndpoint;\n+import org.openkilda.model.OutputVlanType;\n+import org.openkilda.model.SwitchId;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+\n+import java.util.Objects;\n+import java.util.UUID;\n+\n+/**\n+ * Class represents egress flow installation info.\n+ * Transit vlan id is used in matching.\n+ * Output action depends on flow input and output vlan presence, but should at least contain transit vlan stripping.\n+ * Output vlan id is optional, because flow could be untagged on outgoing side.\n+ */\n+@JsonSerialize\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder(value = {", "originalCommit": "b1c7a3c40fd889aee68ae336cf09b7d274e88914", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc5NzAzMA==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r520797030", "bodyText": "Removed.", "author": "rozdy", "createdAt": "2020-11-10T18:53:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM4NjA4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM4NjQyMg==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r520386422", "bodyText": "same here", "author": "surabujin", "createdAt": "2020-11-10T08:47:22Z", "path": "src-java/floodlight-service/floodlight-api/src/main/java/org/openkilda/messaging/command/flow/InstallTransitLoopFlow.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/* Copyright 2019 Telstra Open Source\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *   you may not use this file except in compliance with the License.\n+ *   You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   Unless required by applicable law or agreed to in writing, software\n+ *   distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *   See the License for the specific language governing permissions and\n+ *   limitations under the License.\n+ */\n+\n+package org.openkilda.messaging.command.flow;\n+\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static org.openkilda.messaging.Utils.FLOW_ID;\n+import static org.openkilda.messaging.Utils.TRANSACTION_ID;\n+\n+import org.openkilda.model.FlowEncapsulationType;\n+import org.openkilda.model.FlowEndpoint;\n+import org.openkilda.model.OutputVlanType;\n+import org.openkilda.model.SwitchId;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+\n+import java.util.Objects;\n+import java.util.UUID;\n+\n+/**\n+ * Class represents egress flow installation info.\n+ * Transit vlan id is used in matching.\n+ * Output action depends on flow input and output vlan presence, but should at least contain transit vlan stripping.\n+ * Output vlan id is optional, because flow could be untagged on outgoing side.\n+ */\n+@JsonSerialize\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+@JsonPropertyOrder(value = {", "originalCommit": "b1c7a3c40fd889aee68ae336cf09b7d274e88914", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc5NzE4OQ==", "url": "https://github.com/telstra/open-kilda/pull/3787#discussion_r520797189", "bodyText": "Removed.", "author": "rozdy", "createdAt": "2020-11-10T18:54:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM4NjQyMg=="}], "type": "inlineReview"}, {"oid": "24afd0d2cd12b9c20135f5a01becea4ffcedb7fc", "url": "https://github.com/telstra/open-kilda/commit/24afd0d2cd12b9c20135f5a01becea4ffcedb7fc", "message": "Flow loop feature implementation", "committedDate": "2020-11-10T18:50:23Z", "type": "forcePushed"}, {"oid": "4c1e12811fc2702d37ab12147d00be869883c3c3", "url": "https://github.com/telstra/open-kilda/commit/4c1e12811fc2702d37ab12147d00be869883c3c3", "message": "Flow loop feature implementation", "committedDate": "2020-11-11T20:27:54Z", "type": "forcePushed"}, {"oid": "c8749d82814eb9920cdc0caf7cba65595eebb324", "url": "https://github.com/telstra/open-kilda/commit/c8749d82814eb9920cdc0caf7cba65595eebb324", "message": "Flow loop feature implementation", "committedDate": "2020-11-12T09:14:07Z", "type": "forcePushed"}, {"oid": "a62ec8fc0532698c3afa7547f74963475562a2eb", "url": "https://github.com/telstra/open-kilda/commit/a62ec8fc0532698c3afa7547f74963475562a2eb", "message": "Flow loop feature implementation", "committedDate": "2020-11-12T17:18:39Z", "type": "forcePushed"}, {"oid": "5a5439563627f529fa034c5fb875ecac912c30e7", "url": "https://github.com/telstra/open-kilda/commit/5a5439563627f529fa034c5fb875ecac912c30e7", "message": "Flow loop feature implementation", "committedDate": "2020-11-13T09:23:56Z", "type": "forcePushed"}, {"oid": "8051d5cb778ef38261553c630aca8b74040473ef", "url": "https://github.com/telstra/open-kilda/commit/8051d5cb778ef38261553c630aca8b74040473ef", "message": "Flow loop feature implementation", "committedDate": "2020-11-13T10:18:10Z", "type": "commit"}, {"oid": "8051d5cb778ef38261553c630aca8b74040473ef", "url": "https://github.com/telstra/open-kilda/commit/8051d5cb778ef38261553c630aca8b74040473ef", "message": "Flow loop feature implementation", "committedDate": "2020-11-13T10:18:10Z", "type": "forcePushed"}]}