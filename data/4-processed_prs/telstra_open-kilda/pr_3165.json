{"pr_number": 3165, "pr_title": "Rework unit-tests for flow H&S services", "pr_createdAt": "2020-02-03T16:06:03Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3165", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYxNzU2OQ==", "url": "https://github.com/telstra/open-kilda/pull/3165#discussion_r374617569", "bodyText": "Maybe we should create issue for this case?", "author": "rozdy", "createdAt": "2020-02-04T11:30:19Z", "path": "src-java/flowhs-topology/flowhs-storm-topology/src/test/java/org/openkilda/wfm/topology/flowhs/service/FlowDeleteServiceTest.java", "diffHunk": "@@ -231,57 +149,48 @@ public void shouldCompleteDeleteOnTimeoutRuleRemoval() {\n \n         // 4 times sending 4 rules = 16 requests.\n         verify(carrier, times(16)).sendSpeakerRequest(any());\n-        verify(flowPathRepository, times(1)).delete(MockitoHamcrest.argThat(\n-                Matchers.hasProperty(\"pathId\", is(FORWARD_FLOW_PATH))));\n-        verify(flowPathRepository, times(1)).delete(MockitoHamcrest.argThat(\n-                Matchers.hasProperty(\"pathId\", is(REVERSE_FLOW_PATH))));\n-        verify(flowResourcesManager, times(1)).deallocatePathResources(MockitoHamcrest.argThat(\n-                Matchers.hasProperty(\"forward\",\n-                        Matchers.<PathResources>hasProperty(\"pathId\", is(FORWARD_FLOW_PATH)))));\n-        verify(flowRepository, times(1)).delete(eq(flow));\n+        verifyFlowIsMissing(flow);\n     }\n \n     @Test\n     public void shouldFailDeleteOnTimeoutDuringRuleRemoval() {\n-        Flow flow = build2SwitchFlow();\n-        buildFlowResources();\n-\n-        FlowDeleteService deleteService = new FlowDeleteService(carrier, persistenceManager,\n-                flowResourcesManager, TRANSACTION_RETRIES_LIMIT, SPEAKER_COMMAND_RETRIES_LIMIT);\n+        String flowId = makeFlow().getFlowId();\n \n-        deleteService.handleRequest(\"test_key\", commandContext, FLOW_ID);\n+        FlowDeleteService service = makeService();\n \n-        assertEquals(FlowStatus.IN_PROGRESS, flow.getStatus());\n-        verify(carrier, times(1)).sendNorthboundResponse(any());\n+        service.handleRequest(dummyRequestKey, commandContext, flowId);\n+        verifyFlowStatus(flowId, FlowStatus.IN_PROGRESS);\n+        verifyNorthboundSuccessResponse(carrier);\n \n-        deleteService.handleTimeout(\"test_key\");\n+        service.handleTimeout(dummyRequestKey);\n \n         verify(carrier, times(4)).sendSpeakerRequest(any());\n-        verify(flowResourcesManager, never()).deallocatePathResources(any());\n-        verify(flowPathRepository, never()).delete(any());\n-        verify(flowRepository, never()).delete(any());\n+        // FIXME(surabujin): flow stays in IN_PROGRESS status, any further request can't be handled.\n+        //  em... there is no actual handling for timeout event, so FSM will stack in memory forever", "originalCommit": "74eb78ed4f827ef17d85f809892253bb555b9a15", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI2OTE4NQ==", "url": "https://github.com/telstra/open-kilda/pull/3165#discussion_r383269185", "bodyText": "I have traced workflow one more time. The issue is not so serious as mentioned here - speaker worker bolt will produce timeout event's for all unanswered speaker request, and due to this timeout responses delete operation will be completed. So this particular test is excessive because there is no special handling of \"global\" timeout in delete operation.", "author": "surabujin", "createdAt": "2020-02-24T13:39:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDYxNzU2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY0MjY5Mw==", "url": "https://github.com/telstra/open-kilda/pull/3165#discussion_r374642693", "bodyText": "I think it's better to write correct test and ignore it with link to issue.", "author": "rozdy", "createdAt": "2020-02-04T12:31:12Z", "path": "src-java/flowhs-topology/flowhs-storm-topology/src/test/java/org/openkilda/wfm/topology/flowhs/service/FlowDeleteServiceTest.java", "diffHunk": "@@ -365,32 +264,23 @@ public void shouldCompleteDeleteOnErrorDuringRemovingFlow() {\n         }\n \n         verify(carrier, times(4)).sendSpeakerRequest(any());\n-        verify(flowPathRepository, times(1)).delete(MockitoHamcrest.argThat(\n-                Matchers.hasProperty(\"pathId\", is(FORWARD_FLOW_PATH))));\n-        verify(flowPathRepository, times(1)).delete(MockitoHamcrest.argThat(\n-                Matchers.hasProperty(\"pathId\", is(REVERSE_FLOW_PATH))));\n-        verify(flowResourcesManager, times(1)).deallocatePathResources(MockitoHamcrest.argThat(\n-                Matchers.hasProperty(\"forward\",\n-                        Matchers.<PathResources>hasProperty(\"pathId\", is(FORWARD_FLOW_PATH)))));\n-        verify(flowRepository, times(1)).delete(eq(flow));\n+        // FIXME(surabujin): one more way to make not removable via kilda-API flow", "originalCommit": "74eb78ed4f827ef17d85f809892253bb555b9a15", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMzOTEzMg==", "url": "https://github.com/telstra/open-kilda/pull/3165#discussion_r383339132", "bodyText": "This test emulates DB layer error, but we do not define any \"solution\" for such kind of errors i.e we do not define how we should handle them. Without understanding how we should handle this error, test can't be created.\n#3230", "author": "surabujin", "createdAt": "2020-02-24T15:38:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY0MjY5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY0OTUzMw==", "url": "https://github.com/telstra/open-kilda/pull/3165#discussion_r374649533", "bodyText": "Dont -> Down", "author": "rozdy", "createdAt": "2020-02-04T12:45:38Z", "path": "src-java/flowhs-topology/flowhs-storm-topology/src/test/java/org/openkilda/wfm/topology/flowhs/service/FlowRerouteServiceTest.java", "diffHunk": "@@ -26,954 +25,619 @@\n import static org.mockito.ArgumentMatchers.eq;\n import static org.mockito.Mockito.doAnswer;\n import static org.mockito.Mockito.doThrow;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.never;\n-import static org.mockito.Mockito.reset;\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n import static org.mockito.hamcrest.MockitoHamcrest.argThat;\n-import static org.openkilda.model.SwitchProperties.DEFAULT_FLOW_ENCAPSULATION_TYPES;\n \n import org.openkilda.floodlight.api.request.FlowSegmentRequest;\n-import org.openkilda.floodlight.api.response.SpeakerFlowSegmentResponse;\n import org.openkilda.floodlight.flow.response.FlowErrorResponse;\n import org.openkilda.floodlight.flow.response.FlowErrorResponse.ErrorCode;\n-import org.openkilda.model.Cookie;\n+import org.openkilda.messaging.error.ErrorType;\n+import org.openkilda.messaging.info.flow.FlowRerouteResponse;\n import org.openkilda.model.Flow;\n-import org.openkilda.model.FlowEncapsulationType;\n import org.openkilda.model.FlowPath;\n import org.openkilda.model.FlowPathStatus;\n import org.openkilda.model.FlowStatus;\n import org.openkilda.model.IslEndpoint;\n-import org.openkilda.model.MeterId;\n import org.openkilda.model.PathId;\n import org.openkilda.model.PathSegment;\n-import org.openkilda.model.Switch;\n-import org.openkilda.model.SwitchId;\n-import org.openkilda.model.SwitchProperties;\n-import org.openkilda.model.TransitVlan;\n-import org.openkilda.pce.Path;\n-import org.openkilda.pce.Path.Segment;\n+import org.openkilda.model.history.FlowEvent;\n import org.openkilda.pce.PathPair;\n import org.openkilda.pce.exception.RecoverableException;\n import org.openkilda.pce.exception.UnroutableFlowException;\n-import org.openkilda.persistence.repositories.RepositoryFactory;\n-import org.openkilda.persistence.repositories.SwitchPropertiesRepository;\n-import org.openkilda.persistence.repositories.SwitchRepository;\n-import org.openkilda.persistence.repositories.history.FlowEventRepository;\n-import org.openkilda.wfm.CommandContext;\n-import org.openkilda.wfm.share.flow.resources.EncapsulationResources;\n-import org.openkilda.wfm.share.flow.resources.FlowResources;\n-import org.openkilda.wfm.share.flow.resources.FlowResources.PathResources;\n+import org.openkilda.persistence.repositories.FlowPathRepository;\n+import org.openkilda.persistence.repositories.FlowRepository;\n+import org.openkilda.persistence.repositories.IslRepository;\n import org.openkilda.wfm.share.flow.resources.ResourceAllocationException;\n-import org.openkilda.wfm.share.flow.resources.transitvlan.TransitVlanEncapsulation;\n import org.openkilda.wfm.topology.flowhs.model.FlowRerouteFact;\n \n+import org.hamcrest.Matchers;\n+import org.junit.Assert;\n import org.junit.Before;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n+import org.mockito.ArgumentMatchers;\n import org.mockito.Mock;\n import org.mockito.junit.MockitoJUnitRunner;\n \n-import java.util.ArrayList;\n+import java.time.Instant;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n @RunWith(MockitoJUnitRunner.class)\n public class FlowRerouteServiceTest extends AbstractFlowTest {\n     private static final int TRANSACTION_RETRIES_LIMIT = 3;\n     private static final int PATH_ALLOCATION_RETRIES_LIMIT = 10;\n     private static final int PATH_ALLOCATION_RETRY_DELAY = 0;\n     private static final int SPEAKER_COMMAND_RETRIES_LIMIT = 0;\n-    private static final String FLOW_ID = \"TEST_FLOW\";\n-    private static final SwitchId SWITCH_1 = new SwitchId(1);\n-    private static final SwitchId SWITCH_2 = new SwitchId(2);\n-    private static final SwitchId SWITCH_3 = new SwitchId(3);\n-    private static final PathId OLD_FORWARD_FLOW_PATH = new PathId(FLOW_ID + \"_forward_old\");\n-    private static final PathId OLD_REVERSE_FLOW_PATH = new PathId(FLOW_ID + \"_reverse_old\");\n-    private static final PathId NEW_FORWARD_FLOW_PATH = new PathId(FLOW_ID + \"_forward_new\");\n-    private static final PathId NEW_REVERSE_FLOW_PATH = new PathId(FLOW_ID + \"_reverse_new\");\n \n     @Mock\n     private FlowRerouteHubCarrier carrier;\n-    @Mock\n-    private CommandContext commandContext;\n-    @Mock\n-    private FlowEventRepository flowEventRepository;\n-\n-    private FlowRerouteService rerouteService;\n \n-    private String currentRequestKey;\n-\n-    private Map<SwitchId, Switch> swMap = new HashMap<>();\n+    private String currentRequestKey = dummyRequestKey;\n \n     @Before\n     public void setUp() {\n-        RepositoryFactory repositoryFactory = mock(RepositoryFactory.class);\n-        when(repositoryFactory.createFlowRepository()).thenReturn(flowRepository);\n-        when(flowPathRepository.getUsedBandwidthBetweenEndpoints(any(), anyInt(), any(), anyInt())).thenReturn(0L);\n-        when(repositoryFactory.createFlowPathRepository()).thenReturn(flowPathRepository);\n-        when(repositoryFactory.createFeatureTogglesRepository()).thenReturn(featureTogglesRepository);\n-\n-        when(repositoryFactory.createIslRepository()).thenReturn(islRepository);\n-\n-        SwitchRepository switchRepository = mock(SwitchRepository.class);\n-        when(switchRepository.reload(any())).thenAnswer(invocation -> invocation.getArgument(0));\n-        when(repositoryFactory.createSwitchRepository()).thenReturn(switchRepository);\n-\n-        SwitchPropertiesRepository switchPropertiesRepository = mock(SwitchPropertiesRepository.class);\n-        when(switchPropertiesRepository.findBySwitchId(any(SwitchId.class))).thenAnswer((invocation) ->\n-                Optional.of(SwitchProperties.builder()\n-                        .multiTable(false)\n-                        .supportedTransitEncapsulation(DEFAULT_FLOW_ENCAPSULATION_TYPES)\n-                        .build()));\n-        when(repositoryFactory.createSwitchPropertiesRepository()).thenReturn(switchPropertiesRepository);\n-\n-        when(flowEventRepository.existsByTaskId(any())).thenReturn(false);\n-        when(repositoryFactory.createFlowEventRepository()).thenReturn(flowEventRepository);\n-\n-        when(persistenceManager.getRepositoryFactory()).thenReturn(repositoryFactory);\n-\n         doAnswer(getSpeakerCommandsAnswer()).when(carrier).sendSpeakerRequest(any());\n \n-        doAnswer(invocation -> {\n-            FlowRerouteFact retry = invocation.getArgument(0);\n-            currentRequestKey = retry.getKey();\n-            rerouteService.handlePostponedRequest(retry);\n-            return null;\n-        }).when(carrier).injectRetry(any());\n-\n-        rerouteService = new FlowRerouteService(carrier, persistenceManager,\n-                pathComputer, flowResourcesManager, TRANSACTION_RETRIES_LIMIT,\n-                PATH_ALLOCATION_RETRIES_LIMIT, PATH_ALLOCATION_RETRY_DELAY, SPEAKER_COMMAND_RETRIES_LIMIT);\n-\n-        currentRequestKey = \"test-key\";\n-\n-        for (SwitchId id : new SwitchId[] {SWITCH_1, SWITCH_2, SWITCH_3}) {\n-            Switch entry = makeSwitch(id);\n-            swMap.put(id, entry);\n-            when(switchRepository.findById(eq(id))).thenReturn(Optional.of(entry));\n-        }\n+        // must be done before first service create attempt, because repository objects are cached inside FSM actions\n+        setupFlowRepositorySpy();\n+        setupFlowPathRepositorySpy();\n+        setupIslRepositorySpy();\n     }\n \n     @Test\n-    public void shouldFailRerouteFlowIfNoPathAvailable()\n-            throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        when(pathComputer.getPath(any(), any())).thenThrow(new UnroutableFlowException(\"No path found\"));\n-        buildFlowResources();\n-\n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                \"test_key\", commandContext, FLOW_ID, null, false, false, null));\n-\n-        assertEquals(FlowStatus.DOWN, flow.getStatus());\n-        assertEquals(OLD_FORWARD_FLOW_PATH, flow.getForwardPathId());\n-        assertEquals(OLD_REVERSE_FLOW_PATH, flow.getReversePathId());\n-        verify(pathComputer, times(1)).getPath(any(), any());\n-        verify(flowResourcesManager, never()).allocateFlowResources(any());\n-        verify(carrier, never()).sendSpeakerRequest(any());\n-        verify(carrier, times(1)).sendNorthboundResponse(any());\n+    public void shouldFailRerouteFlowIfNoPathAvailable() throws RecoverableException, UnroutableFlowException {\n+        Flow origin = makeFlow();\n+        preparePathComputation(origin.getFlowId(), new UnroutableFlowException(injectedErrorMessage));\n+\n+        FlowRerouteFact request = new FlowRerouteFact(\n+                dummyRequestKey, commandContext, origin.getFlowId(), null, false, false, null);\n+        testExpectedFailure(request, origin, FlowStatus.DOWN, ErrorType.NOT_FOUND);\n+        verify(pathComputer, times(1))\n+                .getPath(makeFlowArgumentMatch(origin.getFlowId()), any());\n     }\n \n     @Test\n-    public void shouldFailRerouteFlowIfRecoverableException()\n-            throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        when(pathComputer.getPath(any(), any())).thenThrow(new RecoverableException(\"PCE error\"));\n-        buildFlowResources();\n-\n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                \"test_key\", commandContext, FLOW_ID, null, false, false, null));\n-\n-        assertEquals(FlowStatus.UP, flow.getStatus());\n-        assertEquals(OLD_FORWARD_FLOW_PATH, flow.getForwardPathId());\n-        assertEquals(OLD_REVERSE_FLOW_PATH, flow.getReversePathId());\n-        verify(pathComputer, times(PATH_ALLOCATION_RETRIES_LIMIT + 1)).getPath(any(), any());\n-        verify(flowResourcesManager, never()).allocateFlowResources(any());\n-        verify(carrier, never()).sendSpeakerRequest(any());\n-        verify(carrier, times(1)).sendNorthboundResponse(any());\n+    public void shouldFailRerouteFlowIfRecoverableException() throws RecoverableException, UnroutableFlowException {\n+        Flow origin = makeFlow();\n+        preparePathComputation(origin.getFlowId(), new RecoverableException(injectedErrorMessage));\n+\n+        FlowRerouteFact request = new FlowRerouteFact(\n+                dummyRequestKey, commandContext, origin.getFlowId(), null, false, false, null);\n+        testExpectedFailure(request, origin, FlowStatus.UP, ErrorType.INTERNAL_ERROR);\n+        verify(pathComputer, times(PATH_ALLOCATION_RETRIES_LIMIT + 1))\n+                .getPath(makeFlowArgumentMatch(origin.getFlowId()), any());\n     }\n \n     @Test\n     public void shouldFailRerouteFlowIfMultipleOverprovisionBandwidth()\n-            throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        when(pathComputer.getPath(any(), any())).thenReturn(build2SwitchPathPair(2, 3));\n-        buildFlowResources();\n+            throws RecoverableException, UnroutableFlowException {\n+        Flow origin = makeFlow();\n+        preparePathComputation(origin.getFlowId(), make3SwitchesPathPair());\n \n-        when(islRepository.updateAvailableBandwidth(any(), anyInt(), any(), anyInt(), anyLong()))\n-                .thenThrow(ResourceAllocationException.class);\n+        IslRepository repository = setupIslRepositorySpy();\n+        doThrow(ResourceAllocationException.class)\n+                .when(repository).updateAvailableBandwidth(any(), anyInt(), any(), anyInt(), anyLong());\n \n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                \"test_key\", commandContext, FLOW_ID, null, false, false, null));\n+        FlowRerouteFact request = new FlowRerouteFact(\n+                dummyRequestKey, commandContext, origin.getFlowId(), null, false, false, null);\n+        testExpectedFailure(request, origin, FlowStatus.UP, ErrorType.INTERNAL_ERROR);\n \n-        assertEquals(FlowStatus.UP, flow.getStatus());\n-        assertEquals(OLD_FORWARD_FLOW_PATH, flow.getForwardPathId());\n-        assertEquals(OLD_REVERSE_FLOW_PATH, flow.getReversePathId());\n-        verify(pathComputer, times(PATH_ALLOCATION_RETRIES_LIMIT + 1)).getPath(any(), any());\n-        verify(islRepository, times(PATH_ALLOCATION_RETRIES_LIMIT + 1))\n+        verify(repository, times(PATH_ALLOCATION_RETRIES_LIMIT + 1))\n                 .updateAvailableBandwidth(any(), anyInt(), any(), anyInt(), anyLong());\n-        verify(flowResourcesManager, times(PATH_ALLOCATION_RETRIES_LIMIT + 1)).allocateFlowResources(any());\n-        verify(carrier, never()).sendSpeakerRequest(any());\n-        verify(carrier, times(1)).sendNorthboundResponse(any());\n     }\n \n     @Test\n     public void shouldFailRerouteFlowIfNoResourcesAvailable()\n             throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        when(pathComputer.getPath(any(), any())).thenReturn(build2SwitchPathPair(2, 3));\n-        when(flowResourcesManager.allocateFlowResources(any()))\n-                .thenThrow(new ResourceAllocationException(\"No resources\"));\n-\n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                \"test_key\", commandContext, FLOW_ID, null, false, false, null));\n-\n-        assertEquals(FlowStatus.UP, flow.getStatus());\n-        assertEquals(OLD_FORWARD_FLOW_PATH, flow.getForwardPathId());\n-        assertEquals(OLD_REVERSE_FLOW_PATH, flow.getReversePathId());\n-        verify(pathComputer, times(PATH_ALLOCATION_RETRIES_LIMIT + 1)).getPath(any(), any());\n-        verify(flowResourcesManager, times(PATH_ALLOCATION_RETRIES_LIMIT + 1)).allocateFlowResources(any());\n-        verify(carrier, never()).sendSpeakerRequest(any());\n-        verify(carrier, times(1)).sendNorthboundResponse(any());\n+        Flow origin = makeFlow();\n+        preparePathComputation(origin.getFlowId(), make3SwitchesPathPair());\n+\n+        doThrow(new ResourceAllocationException(injectedErrorMessage))\n+                .when(flowResourcesManager).allocateFlowResources(makeFlowArgumentMatch(origin.getFlowId()));\n+\n+        FlowRerouteFact request = new FlowRerouteFact(\n+                dummyRequestKey, commandContext, origin.getFlowId(), null, false, false, null);\n+        testExpectedFailure(request, origin, FlowStatus.UP, ErrorType.INTERNAL_ERROR);\n+\n+        verify(flowResourcesManager, times(PATH_ALLOCATION_RETRIES_LIMIT + 1))\n+                .allocateFlowResources(makeFlowArgumentMatch(origin.getFlowId()));\n     }\n \n     @Test\n     public void shouldFailRerouteFlowOnResourcesAllocationConstraint()\n-            throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        when(pathComputer.getPath(any(), any())).thenReturn(build2SwitchPathPair(2, 3));\n-        buildFlowResources();\n-        doThrow(new RuntimeException(\"Must fail\")).when(flowPathRepository).lockInvolvedSwitches(any(), any());\n+            throws RecoverableException, UnroutableFlowException {\n+        Flow origin = makeFlow();\n+        preparePathComputation(origin.getFlowId(), make3SwitchesPathPair());\n \n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                \"test_key\", commandContext, FLOW_ID, null, false, false, null));\n+        FlowPathRepository repository = setupFlowPathRepositorySpy();\n+        doThrow(new RuntimeException(injectedErrorMessage))\n+                .when(repository)\n+                .createOrUpdate(any(FlowPath.class));\n \n-        verify(flowResourcesManager, times(0)).deallocatePathResources(any());\n-        verify(flowResourcesManager, times(0)).deallocatePathResources(any(), anyLong(), any());\n+        FlowRerouteFact request = new FlowRerouteFact(\n+                dummyRequestKey, commandContext, origin.getFlowId(), null, false, false, null);\n+        testExpectedFailure(request, origin, FlowStatus.UP, ErrorType.INTERNAL_ERROR);\n     }\n \n-    @Test\n-    public void shouldSkipRerouteIfNoNewPathFound()\n-            throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        when(pathComputer.getPath(any(), any())).thenReturn(build2SwitchPathPair());\n-        buildFlowResources();\n-\n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                \"test_key\", commandContext, FLOW_ID, null, false, false, null));\n-\n-        assertEquals(FlowStatus.UP, flow.getStatus());\n-        assertEquals(OLD_FORWARD_FLOW_PATH, flow.getForwardPathId());\n-        assertEquals(OLD_REVERSE_FLOW_PATH, flow.getReversePathId());\n-        verify(carrier, never()).sendSpeakerRequest(any());\n-        verify(carrier, times(1)).sendNorthboundResponse(any());\n+    private void testExpectedFailure(\n+            FlowRerouteFact request, Flow origin, FlowStatus expectedFlowStatus, ErrorType expectedError) {\n+        makeService().handleRequest(request);\n+\n+        verifyNoSpeakerInteraction(carrier);\n+        verifyNorthboundErrorResponse(carrier, expectedError);\n+\n+        Flow result = verifyFlowStatus(origin.getFlowId(), expectedFlowStatus);\n+        verifyNoPathReplace(origin, result);\n     }\n \n     @Test\n-    public void shouldFailRerouteOnUnsuccessfulInstallation()\n-            throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        when(pathComputer.getPath(any(), any())).thenReturn(build2SwitchPathPair(2, 3));\n-        buildFlowResources();\n+    public void shouldSkipRerouteIfNoNewPathFound() throws RecoverableException, UnroutableFlowException {\n+        Flow origin = makeFlow();\n+        preparePathComputation(origin.getFlowId(), make2SwitchesPathPair());\n \n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                \"test_key\", commandContext, FLOW_ID, null, false, false, null));\n+        makeService().handleRequest(new FlowRerouteFact(\n+                dummyRequestKey, commandContext, origin.getFlowId(), null, false, false, null));\n \n-        assertEquals(FlowStatus.IN_PROGRESS, flow.getStatus());\n-        verify(carrier, times(1)).sendNorthboundResponse(any());\n+        verifyNoSpeakerInteraction(carrier);\n+        verifyNorthboundSuccessResponse(carrier);\n \n-        FlowSegmentRequest request;\n-        while ((request = requests.poll()) != null) {\n-            if (request.isInstallRequest()) {\n-                rerouteService.handleAsyncResponse(\"test_key\", FlowErrorResponse.errorBuilder()\n-                        .messageContext(request.getMessageContext())\n+        Flow result = verifyFlowStatus(origin.getFlowId(), FlowStatus.UP);\n+        verifyNoPathReplace(origin, result);\n+    }\n+\n+    @Test\n+    public void shouldFailRerouteOnUnsuccessfulInstallation() throws RecoverableException, UnroutableFlowException {\n+        Flow origin = makeFlow();\n+        preparePathComputation(origin.getFlowId(), make3SwitchesPathPair());\n+\n+        FlowRerouteService service = makeService();\n+        service.handleRequest(new FlowRerouteFact(\n+                currentRequestKey, commandContext, origin.getFlowId(), null, false, false, null));\n+\n+        verifyFlowStatus(origin.getFlowId(), FlowStatus.IN_PROGRESS);\n+        verifyNorthboundSuccessResponse(carrier);\n+\n+        FlowSegmentRequest speakerRequest;\n+        while ((speakerRequest = requests.poll()) != null) {\n+            if (speakerRequest.isInstallRequest()) {\n+                service.handleAsyncResponse(currentRequestKey, FlowErrorResponse.errorBuilder()\n+                        .messageContext(speakerRequest.getMessageContext())\n                         .errorCode(ErrorCode.UNKNOWN)\n-                        .description(\"Switch is unavailable\")\n-                        .commandId(request.getCommandId())\n-                        .metadata(request.getMetadata())\n-                        .switchId(request.getSwitchId())\n+                        .description(injectedErrorMessage)\n+                        .commandId(speakerRequest.getCommandId())\n+                        .metadata(speakerRequest.getMetadata())\n+                        .switchId(speakerRequest.getSwitchId())\n                         .build());\n             } else {\n-                rerouteService.handleAsyncResponse(\"test_key\", SpeakerFlowSegmentResponse.builder()\n-                        .messageContext(request.getMessageContext())\n-                        .commandId(request.getCommandId())\n-                        .metadata(request.getMetadata())\n-                        .switchId(request.getSwitchId())\n-                        .success(true)\n-                        .build());\n+                produceAsyncResponse(service, speakerRequest);\n             }\n         }\n \n-        assertEquals(FlowStatus.UP, flow.getStatus());\n-        assertEquals(OLD_FORWARD_FLOW_PATH, flow.getForwardPathId());\n-        assertEquals(OLD_REVERSE_FLOW_PATH, flow.getReversePathId());\n+        Flow result = verifyFlowStatus(origin.getFlowId(), FlowStatus.UP);\n+        verifyNoPathReplace(origin, result);\n     }\n \n     @Test\n-    public void shouldFailRerouteOnTimeoutDuringInstallation()\n-            throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        when(pathComputer.getPath(any(), any())).thenReturn(build2SwitchPathPair(2, 3));\n-        buildFlowResources();\n+    public void shouldFailRerouteOnTimeoutDuringInstallation() throws RecoverableException, UnroutableFlowException {\n+        Flow origin = makeFlow();\n+        preparePathComputation(origin.getFlowId(), make3SwitchesPathPair());\n \n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                \"test_key\", commandContext, FLOW_ID, null, false, false, null));\n+        FlowRerouteService service = makeService();\n+        service.handleRequest(new FlowRerouteFact(\n+                currentRequestKey, commandContext, origin.getFlowId(), null, false, false, null));\n \n-        assertEquals(FlowStatus.IN_PROGRESS, flow.getStatus());\n-        verify(carrier, times(1)).sendNorthboundResponse(any());\n+        verifyFlowStatus(origin.getFlowId(), FlowStatus.IN_PROGRESS);\n+        verifyNorthboundSuccessResponse(carrier);\n \n-        rerouteService.handleTimeout(\"test_key\");\n+        service.handleTimeout(currentRequestKey);\n \n-        FlowSegmentRequest request;\n-        while ((request = requests.poll()) != null) {\n-            produceAsyncResponse(\"test_key\", request);\n+        FlowSegmentRequest speakerRequest;\n+        while ((speakerRequest = requests.poll()) != null) {\n+            produceAsyncResponse(service, speakerRequest);\n         }\n \n-        assertEquals(FlowStatus.UP, flow.getStatus());\n-        assertEquals(OLD_FORWARD_FLOW_PATH, flow.getForwardPathId());\n-        assertEquals(OLD_REVERSE_FLOW_PATH, flow.getReversePathId());\n+        Flow result = verifyFlowStatus(origin.getFlowId(), FlowStatus.UP);\n+        verifyNoPathReplace(origin, result);\n     }\n \n     @Test\n-    public void shouldFailRerouteOnUnsuccessfulValidation()\n-            throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        when(pathComputer.getPath(any(), any())).thenReturn(build2SwitchPathPair(2, 3));\n-        buildFlowResources();\n+    public void shouldFailRerouteOnUnsuccessfulValidation() throws RecoverableException, UnroutableFlowException {\n+        Flow origin = makeFlow();\n+        preparePathComputation(origin.getFlowId(), make3SwitchesPathPair());\n \n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                \"test_key\", commandContext, FLOW_ID, null, false, false, null));\n+        FlowRerouteService service = makeService();\n+        service.handleRequest(new FlowRerouteFact(\n+                currentRequestKey, commandContext, origin.getFlowId(), null, false, false, null));\n \n-        assertEquals(FlowStatus.IN_PROGRESS, flow.getStatus());\n-        verify(carrier, times(1)).sendNorthboundResponse(any());\n+        verifyFlowStatus(origin.getFlowId(), FlowStatus.IN_PROGRESS);\n+        verifyNorthboundSuccessResponse(carrier);\n \n-        FlowSegmentRequest request;\n-        while ((request = requests.poll()) != null) {\n-            if (request.isVerifyRequest()) {\n-                rerouteService.handleAsyncResponse(\"test_key\", FlowErrorResponse.errorBuilder()\n+        FlowSegmentRequest speakerRequest;\n+        while ((speakerRequest = requests.poll()) != null) {\n+            if (speakerRequest.isVerifyRequest()) {\n+                service.handleAsyncResponse(currentRequestKey, FlowErrorResponse.errorBuilder()\n                         .errorCode(ErrorCode.UNKNOWN)\n-                        .description(\"Unknown rule\")\n-                        .messageContext(request.getMessageContext())\n-                        .commandId(request.getCommandId())\n-                        .metadata(request.getMetadata())\n-                        .switchId(request.getSwitchId())\n+                        .description(injectedErrorMessage)\n+                        .messageContext(speakerRequest.getMessageContext())\n+                        .commandId(speakerRequest.getCommandId())\n+                        .metadata(speakerRequest.getMetadata())\n+                        .switchId(speakerRequest.getSwitchId())\n                         .build());\n             } else {\n-                rerouteService.handleAsyncResponse(\"test_key\", SpeakerFlowSegmentResponse.builder()\n-                        .messageContext(request.getMessageContext())\n-                        .commandId(request.getCommandId())\n-                        .metadata(request.getMetadata())\n-                        .switchId(request.getSwitchId())\n-                        .success(true)\n-                        .build());\n+                produceAsyncResponse(service, speakerRequest);\n             }\n         }\n \n-        assertEquals(FlowStatus.UP, flow.getStatus());\n-        assertEquals(OLD_FORWARD_FLOW_PATH, flow.getForwardPathId());\n-        assertEquals(OLD_REVERSE_FLOW_PATH, flow.getReversePathId());\n+        Flow result = verifyFlowStatus(origin.getFlowId(), FlowStatus.UP);\n+        verifyNoPathReplace(origin, result);\n     }\n \n     @Test\n-    public void shouldFailRerouteOnTimeoutDuringValidation()\n-            throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        when(pathComputer.getPath(any(), any())).thenReturn(build2SwitchPathPair(2, 3));\n-        buildFlowResources();\n+    public void shouldFailRerouteOnTimeoutDuringValidation() throws RecoverableException, UnroutableFlowException {\n+        Flow origin = makeFlow();\n+        preparePathComputation(origin.getFlowId(), make3SwitchesPathPair());\n \n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                \"test_key\", commandContext, FLOW_ID, null, false, false, null));\n+        FlowRerouteService service = makeService();\n+        service.handleRequest(new FlowRerouteFact(\n+                currentRequestKey, commandContext, origin.getFlowId(), null, false, false, null));\n \n-        assertEquals(FlowStatus.IN_PROGRESS, flow.getStatus());\n-        verify(carrier, times(1)).sendNorthboundResponse(any());\n+        verifyFlowStatus(origin.getFlowId(), FlowStatus.IN_PROGRESS);\n+        verifyNorthboundSuccessResponse(carrier);\n \n-        FlowSegmentRequest request;\n-        while ((request = requests.poll()) != null) {\n-            if (request.isVerifyRequest()) {\n-                rerouteService.handleTimeout(\"test_key\");\n+        FlowSegmentRequest speakerRequest;\n+        while ((speakerRequest = requests.poll()) != null) {\n+            if (speakerRequest.isVerifyRequest()) {\n+                service.handleTimeout(currentRequestKey);\n             } else {\n-                rerouteService.handleAsyncResponse(\"test_key\", SpeakerFlowSegmentResponse.builder()\n-                        .messageContext(request.getMessageContext())\n-                        .commandId(request.getCommandId())\n-                        .metadata(request.getMetadata())\n-                        .switchId(request.getSwitchId())\n-                        .success(true)\n-                        .build());\n+                produceAsyncResponse(service, speakerRequest);\n             }\n         }\n \n-        assertEquals(FlowStatus.UP, flow.getStatus());\n-        assertEquals(OLD_FORWARD_FLOW_PATH, flow.getForwardPathId());\n-        assertEquals(OLD_REVERSE_FLOW_PATH, flow.getReversePathId());\n+        Flow result = verifyFlowStatus(origin.getFlowId(), FlowStatus.UP);\n+        verifyNoPathReplace(origin, result);\n     }\n \n     @Test\n-    public void shouldFailRerouteOnSwapPathsError()\n-            throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        when(pathComputer.getPath(any(), any())).thenReturn(build2SwitchPathPair(2, 3));\n-        buildFlowResources();\n-\n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                \"test_key\", commandContext, FLOW_ID, null, false, false, null));\n-\n-        assertEquals(FlowStatus.IN_PROGRESS, flow.getStatus());\n-        verify(carrier, times(1)).sendNorthboundResponse(any());\n-\n-        doAnswer(invocation -> {\n-            // imitate transaction rollback\n-            Flow persistedFlow = invocation.getArgument(0);\n-            FlowPath oldForward = persistedFlow.getPaths().stream()\n-                    .filter(path -> path.getPathId().equals(OLD_FORWARD_FLOW_PATH))\n-                    .findAny().get();\n-            persistedFlow.setForwardPath(oldForward);\n-            FlowPath oldReverse = persistedFlow.getPaths().stream()\n-                    .filter(path -> path.getPathId().equals(OLD_REVERSE_FLOW_PATH))\n-                    .findAny().get();\n-            persistedFlow.setReversePath(oldReverse);\n-\n-            throw new RuntimeException(\"A persistence error\");\n-        }).when(flowRepository).createOrUpdate(argThat(\n-                hasProperty(\"forwardPathId\", equalTo(NEW_FORWARD_FLOW_PATH))));\n-\n-        FlowSegmentRequest request;\n-        while ((request = requests.poll()) != null) {\n-            if (request.isVerifyRequest()) {\n-                rerouteService.handleAsyncResponse(\"test_key\", buildResponseOnVerifyRequest(request));\n+    public void shouldFailRerouteOnSwapPathsError() throws RecoverableException, UnroutableFlowException {\n+        Flow origin = makeFlow();\n+        preparePathComputation(origin.getFlowId(), make3SwitchesPathPair());\n+\n+        FlowRepository repository = setupFlowRepositorySpy();\n+        doThrow(new RuntimeException(injectedErrorMessage))\n+                .when(repository).createOrUpdate(\n+                argThat(hasProperty(\"forwardPathId\", Matchers.not(equalTo(origin.getForwardPathId())))));\n+\n+        FlowRerouteService service = makeService();\n+        service.handleRequest(new FlowRerouteFact(\n+                currentRequestKey, commandContext, origin.getFlowId(), null, false, false, null));\n+\n+        verifyFlowStatus(origin.getFlowId(), FlowStatus.IN_PROGRESS);\n+        verifyNorthboundSuccessResponse(carrier);\n+\n+        FlowSegmentRequest speakerRequest;\n+        while ((speakerRequest = requests.poll()) != null) {\n+            if (speakerRequest.isVerifyRequest()) {\n+                service.handleAsyncResponse(currentRequestKey, buildResponseOnVerifyRequest(speakerRequest));\n             } else {\n-                rerouteService.handleAsyncResponse(\"test_key\", SpeakerFlowSegmentResponse.builder()\n-                        .messageContext(request.getMessageContext())\n-                        .commandId(request.getCommandId())\n-                        .metadata(request.getMetadata())\n-                        .switchId(request.getSwitchId())\n-                        .success(true)\n-                        .build());\n+                produceAsyncResponse(service, speakerRequest);\n             }\n         }\n \n-        assertEquals(FlowStatus.UP, flow.getStatus());\n-        assertEquals(OLD_FORWARD_FLOW_PATH, flow.getForwardPathId());\n-        assertEquals(OLD_REVERSE_FLOW_PATH, flow.getReversePathId());\n+        Flow result = verifyFlowStatus(origin.getFlowId(), FlowStatus.UP);\n+        verifyNoPathReplace(origin, result);\n     }\n \n     @Test\n     public void shouldFailRerouteOnErrorDuringCompletingFlowPathInstallation()\n-            throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        when(pathComputer.getPath(any(), any())).thenReturn(build2SwitchPathPair(2, 3));\n-        buildFlowResources();\n-\n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                \"test_key\", commandContext, FLOW_ID, null, false, false, null));\n-\n-        assertEquals(FlowStatus.IN_PROGRESS, flow.getStatus());\n-        verify(carrier, times(1)).sendNorthboundResponse(any());\n-\n-        doAnswer(invocation -> {\n-            // imitate transaction rollback\n-            flow.getPath(invocation.getArgument(0)).ifPresent(\n-                    persistedFlowPath -> persistedFlowPath.setStatus(FlowPathStatus.IN_PROGRESS));\n-\n-            throw new RuntimeException(\"A persistence error\");\n-        }).when(flowPathRepository).updateStatus(eq(NEW_FORWARD_FLOW_PATH), eq(FlowPathStatus.ACTIVE));\n-\n-        FlowSegmentRequest request;\n-        while ((request = requests.poll()) != null) {\n-            if (request.isVerifyRequest()) {\n-                rerouteService.handleAsyncResponse(\"test_key\", buildResponseOnVerifyRequest(request));\n+            throws RecoverableException, UnroutableFlowException {\n+        Flow origin = makeFlow();\n+        preparePathComputation(origin.getFlowId(), make3SwitchesPathPair());\n+\n+        FlowPathRepository repository = setupFlowPathRepositorySpy();\n+        Set<PathId> originalPaths = origin.getPaths().stream()\n+                .map(FlowPath::getPathId)\n+                .collect(Collectors.toSet());\n+        doThrow(new RuntimeException(injectedErrorMessage))\n+                .when(repository)\n+                .updateStatus(\n+                        ArgumentMatchers.argThat(argument -> !originalPaths.contains(argument)),\n+                        eq(FlowPathStatus.ACTIVE));\n+\n+        FlowRerouteService service = makeService();\n+        service.handleRequest(new FlowRerouteFact(\n+                currentRequestKey, commandContext, origin.getFlowId(), null, false, false, null));\n+\n+        verifyFlowStatus(origin.getFlowId(), FlowStatus.IN_PROGRESS);\n+        verifyNorthboundSuccessResponse(carrier);\n+\n+        FlowSegmentRequest speakerRequest;\n+        while ((speakerRequest = requests.poll()) != null) {\n+            if (speakerRequest.isVerifyRequest()) {\n+                service.handleAsyncResponse(currentRequestKey, buildResponseOnVerifyRequest(speakerRequest));\n             } else {\n-                rerouteService.handleAsyncResponse(\"test_key\", SpeakerFlowSegmentResponse.builder()\n-                        .messageContext(request.getMessageContext())\n-                        .commandId(request.getCommandId())\n-                        .metadata(request.getMetadata())\n-                        .switchId(request.getSwitchId())\n-                        .success(true)\n-                        .build());\n+                produceAsyncResponse(service, speakerRequest);\n             }\n         }\n \n-        assertEquals(FlowStatus.UP, flow.getStatus());\n-        assertEquals(OLD_FORWARD_FLOW_PATH, flow.getForwardPathId());\n-        assertEquals(OLD_REVERSE_FLOW_PATH, flow.getReversePathId());\n+        Flow result = verifyFlowStatus(origin.getFlowId(), FlowStatus.UP);\n+        verifyNoPathReplace(origin, result);\n     }\n \n     @Test\n     public void shouldCompleteRerouteOnErrorDuringCompletingFlowPathRemoval()\n-            throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        when(pathComputer.getPath(any(), any())).thenReturn(build2SwitchPathPair(2, 3));\n-        buildFlowResources();\n+            throws RecoverableException, UnroutableFlowException {\n+        Flow origin = makeFlow();\n+        preparePathComputation(origin.getFlowId(), make3SwitchesPathPair());\n \n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                \"test_key\", commandContext, FLOW_ID, null, false, false, null));\n+        FlowPathRepository repository = setupFlowPathRepositorySpy();\n+        doThrow(new RuntimeException(injectedErrorMessage))\n+                .when(repository)\n+                .delete(argThat(hasProperty(\"pathId\", equalTo(origin.getForwardPathId()))));\n \n-        assertEquals(FlowStatus.IN_PROGRESS, flow.getStatus());\n-        verify(carrier, times(1)).sendNorthboundResponse(any());\n+        FlowRerouteService service = makeService();\n+        service.handleRequest(new FlowRerouteFact(\n+                currentRequestKey, commandContext, origin.getFlowId(), null, false, false, null));\n \n-        doThrow(new RuntimeException(\"A persistence error\"))\n-                .when(flowPathRepository).delete(argThat(\n-                hasProperty(\"pathId\", equalTo(OLD_FORWARD_FLOW_PATH))));\n+        verifyFlowStatus(origin.getFlowId(), FlowStatus.IN_PROGRESS);\n+        verifyNorthboundSuccessResponse(carrier);\n \n-        FlowSegmentRequest request;\n-        while ((request = requests.poll()) != null) {\n-            produceAsyncResponse(\"test_key\", request);\n+        FlowSegmentRequest speakerRequest;\n+        while ((speakerRequest = requests.poll()) != null) {\n+            produceAsyncResponse(service, speakerRequest);\n         }\n \n-        assertEquals(FlowStatus.UP, flow.getStatus());\n-        assertEquals(NEW_FORWARD_FLOW_PATH, flow.getForwardPathId());\n-        assertEquals(NEW_REVERSE_FLOW_PATH, flow.getReversePathId());\n+        Flow result = verifyFlowStatus(origin.getFlowId(), FlowStatus.UP);\n+        verifyPathReplace(origin, result);\n     }\n \n     @Test\n     public void shouldCompleteRerouteOnErrorDuringResourceDeallocation()\n-            throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        when(pathComputer.getPath(any(), any())).thenReturn(build2SwitchPathPair(2, 3));\n-        buildFlowResources();\n+            throws RecoverableException, UnroutableFlowException {\n+        Flow origin = makeFlow();\n+        preparePathComputation(origin.getFlowId(), make3SwitchesPathPair());\n \n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                \"test_key\", commandContext, FLOW_ID, null, false, false, null));\n+        FlowRerouteService service = makeService();\n+        service.handleRequest(new FlowRerouteFact(\n+                currentRequestKey, commandContext, origin.getFlowId(), null, false, false, null));\n \n-        assertEquals(FlowStatus.IN_PROGRESS, flow.getStatus());\n-        verify(carrier, times(1)).sendNorthboundResponse(any());\n+        verifyFlowStatus(origin.getFlowId(), FlowStatus.IN_PROGRESS);\n+        verifyNorthboundSuccessResponse(carrier);\n \n-        doThrow(new RuntimeException(\"A persistence error\"))\n+        doThrow(new RuntimeException(injectedErrorMessage))\n                 .when(flowResourcesManager).deallocatePathResources(argThat(\n                 hasProperty(\"forward\",\n-                        hasProperty(\"pathId\", equalTo(OLD_FORWARD_FLOW_PATH)))));\n+                        hasProperty(\"pathId\", equalTo(origin.getForwardPathId())))));\n \n-        FlowSegmentRequest request;\n-        while ((request = requests.poll()) != null) {\n-            if (request.isVerifyRequest()) {\n-                rerouteService.handleAsyncResponse(\"test_key\", buildResponseOnVerifyRequest(request));\n+        FlowSegmentRequest speakerRequest;\n+        while ((speakerRequest = requests.poll()) != null) {\n+            if (speakerRequest.isVerifyRequest()) {\n+                service.handleAsyncResponse(currentRequestKey, buildResponseOnVerifyRequest(speakerRequest));\n             } else {\n-                rerouteService.handleAsyncResponse(\"test_key\", SpeakerFlowSegmentResponse.builder()\n-                        .messageContext(request.getMessageContext())\n-                        .commandId(request.getCommandId())\n-                        .metadata(request.getMetadata())\n-                        .switchId(request.getSwitchId())\n-                        .success(true)\n-                        .build());\n+                produceAsyncResponse(service, speakerRequest);\n             }\n         }\n \n-        assertEquals(FlowStatus.UP, flow.getStatus());\n-        assertEquals(NEW_FORWARD_FLOW_PATH, flow.getForwardPathId());\n-        assertEquals(NEW_REVERSE_FLOW_PATH, flow.getReversePathId());\n+        Flow result = verifyFlowStatus(origin.getFlowId(), FlowStatus.UP);\n+        verifyPathReplace(origin, result);\n     }\n \n     @Test\n-    public void shouldSuccessfullyRerouteFlow()\n-            throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        flow.setStatus(FlowStatus.DOWN);\n+    public void shouldSuccessfullyRerouteFlow() throws RecoverableException, UnroutableFlowException {\n+        Flow origin = makeFlow();\n+        origin.setStatus(FlowStatus.DOWN);\n+        flushFlowChanges(origin);\n \n-        when(pathComputer.getPath(any(), any()))\n-                .thenReturn(build2SwitchPathPair(2, 3))\n-                .thenReturn(build3SwitchPathPair());\n-        buildFlowResources();\n+        preparePathComputation(origin.getFlowId(), make3SwitchesPathPair());\n \n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                \"test_key\", commandContext, FLOW_ID, null, false, false, null));\n+        FlowRerouteService service = makeService();\n+        service.handleRequest(new FlowRerouteFact(\n+                currentRequestKey, commandContext, origin.getFlowId(), null, false, false, null));\n \n-        assertEquals(FlowStatus.IN_PROGRESS, flow.getStatus());\n-        verify(carrier, times(1)).sendNorthboundResponse(any());\n+        verifyFlowStatus(origin.getFlowId(), FlowStatus.IN_PROGRESS);\n+        verifyNorthboundSuccessResponse(carrier);\n \n-        FlowSegmentRequest request;\n-        while ((request = requests.poll()) != null) {\n-            produceAsyncResponse(\"test_key\", request);\n+        FlowSegmentRequest speakerRequest;\n+        while ((speakerRequest = requests.poll()) != null) {\n+            produceAsyncResponse(service, speakerRequest);\n         }\n \n-        assertEquals(FlowStatus.UP, flow.getStatus());\n-        assertEquals(NEW_FORWARD_FLOW_PATH, flow.getForwardPathId());\n-        assertEquals(NEW_REVERSE_FLOW_PATH, flow.getReversePathId());\n+        Flow result = verifyFlowStatus(origin.getFlowId(), FlowStatus.UP);\n+        verifyPathReplace(origin, result);\n     }\n \n     @Test\n-    public void shouldSuccessfullyHandleOverlappingRequests()\n-            throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        flow.setStatus(FlowStatus.DOWN);\n-\n-        when(pathComputer.getPath(any(), any()))\n-                .thenReturn(build2SwitchPathPair(2, 3))\n-                .thenReturn(build3SwitchPathPair());\n+    public void shouldSuccessfullyHandleOverlappingRequests() throws RecoverableException, UnroutableFlowException {\n+        Flow origin = makeFlow();\n+        origin.setStatus(FlowStatus.DOWN);\n+        flushFlowChanges(origin);\n \n-        FlowResources resourcesOrigin = makeFlowResources(\n-                flow.getFlowId(), flow.getForwardPathId(), flow.getReversePathId());\n+        when(pathComputer.getPath(makeFlowArgumentMatch(origin.getFlowId()), any()))\n+                .thenReturn(make2SwitchAltPathPair())\n+                .thenReturn(make3SwitchesPathPair());\n \n-        PathId pathForwardFirst = new PathId(flow.getFlowId() + \"_forward_first\");\n-        PathId pathReverseFirst = new PathId(flow.getFlowId() + \"_reverse_first\");\n-        FlowResources resourcesFirst = makeFlowResources(\n-                flow.getFlowId(), pathForwardFirst, pathReverseFirst, resourcesOrigin);\n+        FlowRerouteService service = makeService();\n+        setupPostponedRequestInjector(service);\n \n-        PathId pathForwardSecond = new PathId(flow.getFlowId() + \"_forward_second\");\n-        PathId pathReverseSecond = new PathId(flow.getFlowId() + \"_reverse_second\");\n-        FlowResources resourcesSecond = makeFlowResources(\n-                flow.getFlowId(), pathForwardSecond, pathReverseSecond, resourcesFirst);\n+        service.handleRequest(new FlowRerouteFact(\n+                currentRequestKey, commandContext, origin.getFlowId(), null, false, false, null));\n \n-        when(flowResourcesManager.allocateFlowResources(any()))\n-                .thenReturn(resourcesFirst)\n-                .thenReturn(resourcesSecond);\n+        verifyFlowStatus(origin.getFlowId(), FlowStatus.IN_PROGRESS);\n \n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                currentRequestKey, commandContext, flow.getFlowId(), null, false, false, null));\n-        assertEquals(FlowStatus.IN_PROGRESS, flow.getStatus());\n-\n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                \"test_key2\", commandContext, flow.getFlowId(), null, false, false, null));\n-        assertEquals(FlowStatus.IN_PROGRESS, flow.getStatus());\n+        String overlappingKey = dummyRequestKey + \"2\";\n+        service.handleRequest(new FlowRerouteFact(\n+                overlappingKey, commandContext, origin.getFlowId(), null, false, false, null));\n+        verifyFlowStatus(origin.getFlowId(), FlowStatus.IN_PROGRESS);\n \n         FlowSegmentRequest request;\n         while ((request = requests.poll()) != null) {\n-            produceAsyncResponse(currentRequestKey, request);\n+            produceAsyncResponse(service, request);\n         }\n \n-        assertEquals(FlowStatus.UP, flow.getStatus());\n-        assertEquals(pathForwardSecond, flow.getForwardPathId());\n-        assertEquals(pathReverseSecond, flow.getReversePathId());\n+        Flow result = verifyFlowStatus(origin.getFlowId(), FlowStatus.UP);\n+        verifyPathReplace(origin, result);\n+\n+        FlowPath forwardPath = result.getForwardPath();\n+        Assert.assertNotNull(forwardPath);\n+        Assert.assertTrue(1 < forwardPath.getSegments().size());  // second path have 2 segments\n     }\n \n     @Test\n     public void shouldFixFlowStatusOnRequestConflict() {\n-        Flow flow = build2SwitchFlow();\n-        flow.setStatus(FlowStatus.UP);\n-\n-        reset(flowEventRepository);\n-        when(flowEventRepository.existsByTaskId(any()))\n-                .thenReturn(true)\n-                .thenReturn(true);\n-\n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                currentRequestKey, commandContext, flow.getFlowId(), null, false, false, null));\n-        FlowSegmentRequest request;\n-        while ((request = requests.poll()) != null) {\n-            produceAsyncResponse(currentRequestKey, request);\n+        Flow origin = makeFlow();\n+\n+        FlowEvent dummyHistoryEntry = FlowEvent.builder()\n+                .flowId(origin.getFlowId())\n+                .timestamp(Instant.now())\n+                .action(\"injected-collision\")\n+                .actor(getClass().getSimpleName())\n+                .taskId(commandContext.getCorrelationId())\n+                .details(\"dummy\")\n+                .build();\n+        persistenceManager.getRepositoryFactory().createFlowEventRepository()\n+                .createOrUpdate(dummyHistoryEntry);\n+\n+        FlowRerouteService service = makeService();\n+        service.handleRequest(new FlowRerouteFact(\n+                currentRequestKey, commandContext, origin.getFlowId(), null, false, false, null));\n+        FlowSegmentRequest speakerRequest;\n+        while ((speakerRequest = requests.poll()) != null) {\n+            produceAsyncResponse(service, speakerRequest);\n         }\n-        assertEquals(FlowStatus.UP, flow.getStatus());\n+        verifyFlowStatus(origin.getFlowId(), FlowStatus.UP); // because effectivelyDown == false\n \n-        rerouteService.handleRequest(new FlowRerouteFact(\n-                currentRequestKey, commandContext, flow.getFlowId(), null, false, true, null));\n-        while ((request = requests.poll()) != null) {\n-            produceAsyncResponse(currentRequestKey, request);\n+        service.handleRequest(new FlowRerouteFact(\n+                currentRequestKey, commandContext, origin.getFlowId(), null, false, true, null));\n+        while ((speakerRequest = requests.poll()) != null) {\n+            produceAsyncResponse(service, speakerRequest);\n         }\n-        assertEquals(FlowStatus.DOWN, flow.getStatus());\n+        verifyFlowStatus(origin.getFlowId(), FlowStatus.DOWN); // because effectivelyDown == true\n     }\n \n     @Test\n-    public void shouldMakeFlowDontOnTimeoutIfEffectivelyDown()\n-            throws RecoverableException, UnroutableFlowException, ResourceAllocationException {\n-        Flow flow = build2SwitchFlow();\n-        when(pathComputer.getPath(any(), any())).thenReturn(build2SwitchPathPair(2, 3));\n-        buildFlowResources();\n+    public void shouldMakeFlowDontOnTimeoutIfEffectivelyDown() throws RecoverableException, UnroutableFlowException {", "originalCommit": "74eb78ed4f827ef17d85f809892253bb555b9a15", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e6332958525317ceef5f663ae92ea4f40d468d3a", "url": "https://github.com/telstra/open-kilda/commit/e6332958525317ceef5f663ae92ea4f40d468d3a", "message": "Rework unit-tests for flow H&S services\n\nUse correct implementation of persistence layer to make test's results\nrepresentative.", "committedDate": "2020-02-06T09:58:06Z", "type": "forcePushed"}, {"oid": "4fe2f7de70df06e53a5da1e72ca98636ed24c8e8", "url": "https://github.com/telstra/open-kilda/commit/4fe2f7de70df06e53a5da1e72ca98636ed24c8e8", "message": "Rework unit-tests for flow H&S services\n\nUse correct implementation of persistence layer to make test's results\nrepresentative.", "committedDate": "2020-02-24T15:39:27Z", "type": "forcePushed"}, {"oid": "2cbc9ddfb0b1b6fb5f49df319d99ab771feed8f6", "url": "https://github.com/telstra/open-kilda/commit/2cbc9ddfb0b1b6fb5f49df319d99ab771feed8f6", "message": "Rework unit-tests for flow H&S services\n\nUse correct implementation of persistence layer to make test's results\nrepresentative.", "committedDate": "2020-03-10T09:25:03Z", "type": "commit"}, {"oid": "2cbc9ddfb0b1b6fb5f49df319d99ab771feed8f6", "url": "https://github.com/telstra/open-kilda/commit/2cbc9ddfb0b1b6fb5f49df319d99ab771feed8f6", "message": "Rework unit-tests for flow H&S services\n\nUse correct implementation of persistence layer to make test's results\nrepresentative.", "committedDate": "2020-03-10T09:25:03Z", "type": "forcePushed"}]}