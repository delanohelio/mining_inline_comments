{"pr_number": 3602, "pr_title": "add test for partialSwitchUpdate", "pr_createdAt": "2020-07-06T17:29:20Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3602", "timeline": [{"oid": "36a74544eb6ce350a50ab83f4cdab2f1ac12e16e", "url": "https://github.com/telstra/open-kilda/commit/36a74544eb6ce350a50ab83f4cdab2f1ac12e16e", "message": "add test for partialSwitchUpdate", "committedDate": "2020-07-07T05:25:19Z", "type": "forcePushed"}, {"oid": "f666db63e62306249a0b8e797b1476a0de7e4de4", "url": "https://github.com/telstra/open-kilda/commit/f666db63e62306249a0b8e797b1476a0de7e4de4", "message": "remove setSwitchPop method", "committedDate": "2020-07-09T05:58:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg4OTcyOA==", "url": "https://github.com/telstra/open-kilda/pull/3602#discussion_r454889728", "bodyText": "A more compact groovy way would be\ndef updateRequest =[location: [(data.field): data.newValue] as SwitchPatchDto", "author": "rtretyak", "createdAt": "2020-07-15T08:42:10Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/switches/SwitchesSpec.groovy", "diffHunk": "@@ -333,4 +335,90 @@ class SwitchesSpec extends HealthCheckSpecification {\n                  operation: { getNorthbound().validateSwitch(NON_EXISTENT_SWITCH_ID) }]\n         ]\n     }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    @Unroll\n+    def \"Able to partially update switch a 'location.#data.field' field\"() {\n+        given: \"A switch\"\n+        def sw = topology.activeSwitches.first()\n+        def initConf = northbound.getSwitch(sw.dpId)\n+\n+        when: \"Request a switch partial update for a #data.field field\"\n+        def updateRequest = new SwitchPatchDto().tap {", "originalCommit": "f666db63e62306249a0b8e797b1476a0de7e4de4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk5Mjk2MA==", "url": "https://github.com/telstra/open-kilda/pull/3602#discussion_r454992960", "bodyText": "thx, done", "author": "andriidovhan", "createdAt": "2020-07-15T11:50:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg4OTcyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg5NjM4Nw==", "url": "https://github.com/telstra/open-kilda/pull/3602#discussion_r454896387", "bodyText": "Just create a method that maps SwitchDto (initConf) to SwitchPatchDto and get rid of all these if-else branches", "author": "rtretyak", "createdAt": "2020-07-15T08:52:52Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/switches/SwitchesSpec.groovy", "diffHunk": "@@ -333,4 +335,90 @@ class SwitchesSpec extends HealthCheckSpecification {\n                  operation: { getNorthbound().validateSwitch(NON_EXISTENT_SWITCH_ID) }]\n         ]\n     }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    @Unroll\n+    def \"Able to partially update switch a 'location.#data.field' field\"() {\n+        given: \"A switch\"\n+        def sw = topology.activeSwitches.first()\n+        def initConf = northbound.getSwitch(sw.dpId)\n+\n+        when: \"Request a switch partial update for a #data.field field\"\n+        def updateRequest = new SwitchPatchDto().tap {\n+            it.location = new SwitchLocationDtoV2().tap { it.\"$data.field\" = data.newValue }\n+        }\n+        def response = northboundV2.partialSwitchUpdate(sw.dpId, updateRequest)\n+\n+        then: \"Update response reflects the changes\"\n+        response.location.\"$data.field\" == data.newValue\n+\n+        and: \"Changes actually took place\"\n+        northbound.getSwitch(sw.dpId).location.\"$data.field\" == data.newValue\n+\n+        cleanup:", "originalCommit": "f666db63e62306249a0b8e797b1476a0de7e4de4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAyMTYzNQ==", "url": "https://github.com/telstra/open-kilda/pull/3602#discussion_r455021635", "bodyText": "I didn't extract it into separate method(I will do it when we start to use this kind of operation more often).\nFor now I just refactored this block of code", "author": "andriidovhan", "createdAt": "2020-07-15T12:43:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg5NjM4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg5NzU0NQ==", "url": "https://github.com/telstra/open-kilda/pull/3602#discussion_r454897545", "bodyText": "northboundV2.partialSwitchUpdate(sw.dpId, new SwitchPatchDto().tap { it.pop = initConf.pop ?: \"\" }", "author": "rtretyak", "createdAt": "2020-07-15T08:54:41Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/switches/SwitchesSpec.groovy", "diffHunk": "@@ -333,4 +335,90 @@ class SwitchesSpec extends HealthCheckSpecification {\n                  operation: { getNorthbound().validateSwitch(NON_EXISTENT_SWITCH_ID) }]\n         ]\n     }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    @Unroll\n+    def \"Able to partially update switch a 'location.#data.field' field\"() {\n+        given: \"A switch\"\n+        def sw = topology.activeSwitches.first()\n+        def initConf = northbound.getSwitch(sw.dpId)\n+\n+        when: \"Request a switch partial update for a #data.field field\"\n+        def updateRequest = new SwitchPatchDto().tap {\n+            it.location = new SwitchLocationDtoV2().tap { it.\"$data.field\" = data.newValue }\n+        }\n+        def response = northboundV2.partialSwitchUpdate(sw.dpId, updateRequest)\n+\n+        then: \"Update response reflects the changes\"\n+        response.location.\"$data.field\" == data.newValue\n+\n+        and: \"Changes actually took place\"\n+        northbound.getSwitch(sw.dpId).location.\"$data.field\" == data.newValue\n+\n+        cleanup:\n+        if (initConf.location.\"$data.field\") {\n+            northboundV2.partialSwitchUpdate(sw.dpId, new SwitchPatchDto().tap {\n+                it.location = new SwitchLocationDtoV2().tap { it.\"$data.field\" = initConf.location.\"$data.field\" }\n+            })\n+        } else {\n+            if (data.field in [\"latitude\", \"longitude\"]) {\n+                northboundV2.partialSwitchUpdate(sw.dpId, new SwitchPatchDto().tap {\n+                    it.location = new SwitchLocationDtoV2().tap { it.\"$data.field\" = 0 }\n+                })\n+            } else {\n+                northboundV2.partialSwitchUpdate(sw.dpId, new SwitchPatchDto().tap {\n+                    it.location = new SwitchLocationDtoV2().tap { it.\"$data.field\" = \"\" }\n+                })\n+            }\n+        }\n+\n+        where:\n+        data << [\n+                [\n+                        field   : \"latitude\",\n+                        newValue: 654\n+                ],\n+                [\n+                        field   : \"longitude\",\n+                        newValue: 456\n+                ],\n+                [\n+                        field   : \"street\",\n+                        newValue: \"testStreet\"\n+                ],\n+                [\n+                        field   : \"city\",\n+                        newValue: \"testCity\"\n+                ],\n+                [\n+                        field   : \"country\",\n+                        newValue: \"testCountry\"\n+                ]\n+        ]\n+    }\n+\n+    @Tidy\n+    def \"Able to partially update switch a 'pop' field\"() {\n+        given: \"A switch\"\n+        def sw = topology.activeSwitches.first()\n+        def initConf = northbound.getSwitch(sw.dpId)\n+\n+        when: \"Request a switch partial update for a 'pop' field\"\n+        def newPopValue = \"test_POP\"\n+        def response = northboundV2.partialSwitchUpdate(sw.dpId, new SwitchPatchDto().tap { it.pop = newPopValue })\n+\n+        then: \"Update response reflects the changes\"\n+        response.pop == newPopValue\n+\n+        and: \"Changes actually took place\"\n+        northbound.getSwitch(sw.dpId).pop == newPopValue\n+\n+        cleanup:\n+        if (initConf.pop) {", "originalCommit": "f666db63e62306249a0b8e797b1476a0de7e4de4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk5NTA1Nw==", "url": "https://github.com/telstra/open-kilda/pull/3602#discussion_r454995057", "bodyText": "thx, done", "author": "andriidovhan", "createdAt": "2020-07-15T11:55:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg5NzU0NQ=="}], "type": "inlineReview"}, {"oid": "b9a85537a6648c9107f5b7c9efb4189d2ebb6d9f", "url": "https://github.com/telstra/open-kilda/commit/b9a85537a6648c9107f5b7c9efb4189d2ebb6d9f", "message": "add test for partialSwitchUpdate", "committedDate": "2020-07-15T12:47:12Z", "type": "commit"}, {"oid": "53f36f6b54791ca5dbd6f5cb47a973b8151bf0ba", "url": "https://github.com/telstra/open-kilda/commit/53f36f6b54791ca5dbd6f5cb47a973b8151bf0ba", "message": "remove setSwitchPop method", "committedDate": "2020-07-15T12:47:12Z", "type": "commit"}, {"oid": "53f36f6b54791ca5dbd6f5cb47a973b8151bf0ba", "url": "https://github.com/telstra/open-kilda/commit/53f36f6b54791ca5dbd6f5cb47a973b8151bf0ba", "message": "remove setSwitchPop method", "committedDate": "2020-07-15T12:47:12Z", "type": "forcePushed"}]}