{"pr_number": 3132, "pr_title": "Add test for #3128", "pr_createdAt": "2020-01-21T15:28:32Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3132", "timeline": [{"oid": "e5f13bf5cac05835346cfb60df8b8f4d8f0cf447", "url": "https://github.com/telstra/open-kilda/commit/e5f13bf5cac05835346cfb60df8b8f4d8f0cf447", "message": "Add test for #3128", "committedDate": "2020-01-22T09:48:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA0NTQ3Mg==", "url": "https://github.com/telstra/open-kilda/pull/3132#discussion_r370045472", "bodyText": "I guess we can omit it.reversed", "author": "andriidovhan", "createdAt": "2020-01-23T10:42:06Z", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.openkilda.functionaltests.spec.resilience\n+\n+import static org.openkilda.testing.Constants.PATH_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.info.event.PathNode\n+import org.openkilda.messaging.info.event.SwitchChangeType\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.SwitchStatus\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.model.topology.TopologyDefinition.Switch\n+\n+import groovy.util.logging.Slf4j\n+\n+@Slf4j\n+class RollbacksSpec extends HealthCheckSpecification {\n+\n+    @Tidy\n+    def \"System retries the reroute if it fails to install rules on one the current target path's switches\"() {\n+        given: \"Switch pair with at least 3 available paths, one path should have a transit switch that we will break \\\n+and at least 1 path must remain safe\"\n+        List<PathNode> mainPath, failoverPath, safePath\n+        Switch switchToBreak //will belong to failoverPath and be absent in safePath\n+        Isl islToBreak //will be used to break the mainPath. This ISL is not used in safePath or failoverPath\n+        def switchPair = topologyHelper.switchPairs.find { swPair ->\n+            if(swPair.paths.size() >= 3) {\n+                failoverPath = swPair.paths.find { failoverPathCandidate ->\n+                    def failoverSwitches = pathHelper.getInvolvedSwitches(failoverPathCandidate)\n+                    safePath = swPair.paths.find { safePathCandidate ->\n+                        def safeSwitches = pathHelper.getInvolvedSwitches(safePathCandidate)\n+                        switchToBreak = failoverSwitches.find { !(it in safeSwitches) }\n+                        def safeIsls = pathHelper.getInvolvedIsls(safePathCandidate).collectMany { [it, it.reversed] }\n+                        def failoverIsls = pathHelper.getInvolvedIsls(failoverPathCandidate).collectMany { [it, it.reversed] }", "originalCommit": "e5f13bf5cac05835346cfb60df8b8f4d8f0cf447", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA2NzA1OA==", "url": "https://github.com/telstra/open-kilda/pull/3132#discussion_r370067058", "bodyText": "When looking for islToBreak i want to consider isls in both directions, since I don't want its 'srcSwitch' part to be equal to switchToBreak. For example, if it happens that there is only 1 islToBreak that works for me and its srcSwitch equals to switchToBreak, then I will pick reversed version of this isl", "author": "rtretyak", "createdAt": "2020-01-23T11:33:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA0NTQ3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA0ODA3NA==", "url": "https://github.com/telstra/open-kilda/pull/3132#discussion_r370048074", "bodyText": "how about checking that flowPath is the same as mainPath?", "author": "andriidovhan", "createdAt": "2020-01-23T10:47:29Z", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.openkilda.functionaltests.spec.resilience\n+\n+import static org.openkilda.testing.Constants.PATH_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.info.event.PathNode\n+import org.openkilda.messaging.info.event.SwitchChangeType\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.SwitchStatus\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.model.topology.TopologyDefinition.Switch\n+\n+import groovy.util.logging.Slf4j\n+\n+@Slf4j\n+class RollbacksSpec extends HealthCheckSpecification {\n+\n+    @Tidy\n+    def \"System retries the reroute if it fails to install rules on one the current target path's switches\"() {\n+        given: \"Switch pair with at least 3 available paths, one path should have a transit switch that we will break \\\n+and at least 1 path must remain safe\"\n+        List<PathNode> mainPath, failoverPath, safePath\n+        Switch switchToBreak //will belong to failoverPath and be absent in safePath\n+        Isl islToBreak //will be used to break the mainPath. This ISL is not used in safePath or failoverPath\n+        def switchPair = topologyHelper.switchPairs.find { swPair ->\n+            if(swPair.paths.size() >= 3) {\n+                failoverPath = swPair.paths.find { failoverPathCandidate ->\n+                    def failoverSwitches = pathHelper.getInvolvedSwitches(failoverPathCandidate)\n+                    safePath = swPair.paths.find { safePathCandidate ->\n+                        def safeSwitches = pathHelper.getInvolvedSwitches(safePathCandidate)\n+                        switchToBreak = failoverSwitches.find { !(it in safeSwitches) }\n+                        def safeIsls = pathHelper.getInvolvedIsls(safePathCandidate).collectMany { [it, it.reversed] }\n+                        def failoverIsls = pathHelper.getInvolvedIsls(failoverPathCandidate).collectMany { [it, it.reversed] }\n+                        mainPath = swPair.paths.find { it != failoverPathCandidate && it != safePathCandidate }\n+                        islToBreak = pathHelper.getInvolvedIsls(mainPath).collectMany { [it, it.reversed] }.find {\n+                            !(it in safeIsls) && !(it in failoverIsls) && it.srcSwitch != switchToBreak\n+                        }\n+                        switchToBreak && islToBreak\n+                    }\n+                }\n+            }\n+            failoverPath\n+        }\n+        assert switchPair, \"Not able to find a switch pair with suitable paths\"\n+        log.debug(\"main path: $mainPath\\nfailover path: $failoverPath\\nsafe path: $safePath\\nisl to break: \" +\n+                \"$islToBreak\\nswitch to break: $switchToBreak\")\n+\n+        and: \"A flow using given switch pair\"\n+        switchPair.paths.findAll { it != mainPath }.each { pathHelper.makePathMorePreferable(mainPath, it) }\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)", "originalCommit": "e5f13bf5cac05835346cfb60df8b8f4d8f0cf447", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDE1NjU3OA==", "url": "https://github.com/telstra/open-kilda/pull/3132#discussion_r370156578", "bodyText": "added, but I don't really see how it can be different from mainPath. we are not testing our 'makePathMorePreferable' here", "author": "rtretyak", "createdAt": "2020-01-23T14:41:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA0ODA3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1ODg0Mw==", "url": "https://github.com/telstra/open-kilda/pull/3132#discussion_r370058843", "bodyText": "misconfigured ?", "author": "andriidovhan", "createdAt": "2020-01-23T11:12:38Z", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.openkilda.functionaltests.spec.resilience\n+\n+import static org.openkilda.testing.Constants.PATH_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.info.event.PathNode\n+import org.openkilda.messaging.info.event.SwitchChangeType\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.SwitchStatus\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.model.topology.TopologyDefinition.Switch\n+\n+import groovy.util.logging.Slf4j\n+\n+@Slf4j\n+class RollbacksSpec extends HealthCheckSpecification {\n+\n+    @Tidy\n+    def \"System retries the reroute if it fails to install rules on one the current target path's switches\"() {\n+        given: \"Switch pair with at least 3 available paths, one path should have a transit switch that we will break \\\n+and at least 1 path must remain safe\"\n+        List<PathNode> mainPath, failoverPath, safePath\n+        Switch switchToBreak //will belong to failoverPath and be absent in safePath\n+        Isl islToBreak //will be used to break the mainPath. This ISL is not used in safePath or failoverPath\n+        def switchPair = topologyHelper.switchPairs.find { swPair ->\n+            if(swPair.paths.size() >= 3) {\n+                failoverPath = swPair.paths.find { failoverPathCandidate ->\n+                    def failoverSwitches = pathHelper.getInvolvedSwitches(failoverPathCandidate)\n+                    safePath = swPair.paths.find { safePathCandidate ->\n+                        def safeSwitches = pathHelper.getInvolvedSwitches(safePathCandidate)\n+                        switchToBreak = failoverSwitches.find { !(it in safeSwitches) }\n+                        def safeIsls = pathHelper.getInvolvedIsls(safePathCandidate).collectMany { [it, it.reversed] }\n+                        def failoverIsls = pathHelper.getInvolvedIsls(failoverPathCandidate).collectMany { [it, it.reversed] }\n+                        mainPath = swPair.paths.find { it != failoverPathCandidate && it != safePathCandidate }\n+                        islToBreak = pathHelper.getInvolvedIsls(mainPath).collectMany { [it, it.reversed] }.find {\n+                            !(it in safeIsls) && !(it in failoverIsls) && it.srcSwitch != switchToBreak\n+                        }\n+                        switchToBreak && islToBreak\n+                    }\n+                }\n+            }\n+            failoverPath\n+        }\n+        assert switchPair, \"Not able to find a switch pair with suitable paths\"\n+        log.debug(\"main path: $mainPath\\nfailover path: $failoverPath\\nsafe path: $safePath\\nisl to break: \" +\n+                \"$islToBreak\\nswitch to break: $switchToBreak\")\n+\n+        and: \"A flow using given switch pair\"\n+        switchPair.paths.findAll { it != mainPath }.each { pathHelper.makePathMorePreferable(mainPath, it) }\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        and: \"Switch on the preferred failover path will suddenly be unavailable for rules installation when the reroute starts\"\n+        //select a required failover path beforehand\n+        northbound.deleteLinkProps(northbound.getAllLinkProps())\n+        switchPair.paths.findAll { it != failoverPath }.each { pathHelper.makePathMorePreferable(failoverPath, it) }\n+        //disconnect the switch, but make it look like 'active'\n+        lockKeeper.knockoutSwitch(switchToBreak)\n+        def switchIsOut = true\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchToBreak.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+        database.setSwitchStatus(switchToBreak.dpId, SwitchStatus.ACTIVE)\n+\n+        when: \"Main path of the flow breaks\"\n+        def portDown = antiflap.portDown(islToBreak.srcSwitch.dpId, islToBreak.srcPort)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getLink(islToBreak).state == IslChangeType.FAILED\n+        }\n+\n+        then: \"System rollbacks from failover path, finds another working path and successfully reroutes the flow\"\n+        Wrappers.wait(PATH_INSTALLATION_TIME) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        def currentPath = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        currentPath != mainPath\n+        currentPath != failoverPath\n+        !pathHelper.getInvolvedSwitches(currentPath).contains(switchToBreak)\n+        !pathHelper.getInvolvedIsls(currentPath).contains(islToBreak)\n+        !pathHelper.getInvolvedIsls(currentPath).contains(islToBreak.reversed)\n+\n+        and: \"All related switches have no rule anomalies\"\n+        [mainPath, failoverPath, currentPath].collectMany { pathHelper.getInvolvedSwitches(it) }.unique().each {\n+            northbound.validateSwitch(it.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\"])", "originalCommit": "e5f13bf5cac05835346cfb60df8b8f4d8f0cf447", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDE1NzEzNQ==", "url": "https://github.com/telstra/open-kilda/pull/3132#discussion_r370157135", "bodyText": "added", "author": "rtretyak", "createdAt": "2020-01-23T14:42:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1ODg0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1OTQ5Nw==", "url": "https://github.com/telstra/open-kilda/pull/3132#discussion_r370059497", "bodyText": "northbound.deleteLinkProps(northbound.getAllLinkProps())", "author": "andriidovhan", "createdAt": "2020-01-23T11:13:59Z", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/resilience/RollbacksSpec.groovy", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.openkilda.functionaltests.spec.resilience\n+\n+import static org.openkilda.testing.Constants.PATH_INSTALLATION_TIME\n+import static org.openkilda.testing.Constants.WAIT_OFFSET\n+\n+import org.openkilda.functionaltests.HealthCheckSpecification\n+import org.openkilda.functionaltests.extension.failfast.Tidy\n+import org.openkilda.functionaltests.helpers.Wrappers\n+import org.openkilda.messaging.info.event.IslChangeType\n+import org.openkilda.messaging.info.event.PathNode\n+import org.openkilda.messaging.info.event.SwitchChangeType\n+import org.openkilda.messaging.payload.flow.FlowState\n+import org.openkilda.model.SwitchStatus\n+import org.openkilda.testing.model.topology.TopologyDefinition.Isl\n+import org.openkilda.testing.model.topology.TopologyDefinition.Switch\n+\n+import groovy.util.logging.Slf4j\n+\n+@Slf4j\n+class RollbacksSpec extends HealthCheckSpecification {\n+\n+    @Tidy\n+    def \"System retries the reroute if it fails to install rules on one the current target path's switches\"() {\n+        given: \"Switch pair with at least 3 available paths, one path should have a transit switch that we will break \\\n+and at least 1 path must remain safe\"\n+        List<PathNode> mainPath, failoverPath, safePath\n+        Switch switchToBreak //will belong to failoverPath and be absent in safePath\n+        Isl islToBreak //will be used to break the mainPath. This ISL is not used in safePath or failoverPath\n+        def switchPair = topologyHelper.switchPairs.find { swPair ->\n+            if(swPair.paths.size() >= 3) {\n+                failoverPath = swPair.paths.find { failoverPathCandidate ->\n+                    def failoverSwitches = pathHelper.getInvolvedSwitches(failoverPathCandidate)\n+                    safePath = swPair.paths.find { safePathCandidate ->\n+                        def safeSwitches = pathHelper.getInvolvedSwitches(safePathCandidate)\n+                        switchToBreak = failoverSwitches.find { !(it in safeSwitches) }\n+                        def safeIsls = pathHelper.getInvolvedIsls(safePathCandidate).collectMany { [it, it.reversed] }\n+                        def failoverIsls = pathHelper.getInvolvedIsls(failoverPathCandidate).collectMany { [it, it.reversed] }\n+                        mainPath = swPair.paths.find { it != failoverPathCandidate && it != safePathCandidate }\n+                        islToBreak = pathHelper.getInvolvedIsls(mainPath).collectMany { [it, it.reversed] }.find {\n+                            !(it in safeIsls) && !(it in failoverIsls) && it.srcSwitch != switchToBreak\n+                        }\n+                        switchToBreak && islToBreak\n+                    }\n+                }\n+            }\n+            failoverPath\n+        }\n+        assert switchPair, \"Not able to find a switch pair with suitable paths\"\n+        log.debug(\"main path: $mainPath\\nfailover path: $failoverPath\\nsafe path: $safePath\\nisl to break: \" +\n+                \"$islToBreak\\nswitch to break: $switchToBreak\")\n+\n+        and: \"A flow using given switch pair\"\n+        switchPair.paths.findAll { it != mainPath }.each { pathHelper.makePathMorePreferable(mainPath, it) }\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flowHelperV2.addFlow(flow)\n+\n+        and: \"Switch on the preferred failover path will suddenly be unavailable for rules installation when the reroute starts\"\n+        //select a required failover path beforehand\n+        northbound.deleteLinkProps(northbound.getAllLinkProps())\n+        switchPair.paths.findAll { it != failoverPath }.each { pathHelper.makePathMorePreferable(failoverPath, it) }\n+        //disconnect the switch, but make it look like 'active'\n+        lockKeeper.knockoutSwitch(switchToBreak)\n+        def switchIsOut = true\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchToBreak.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+        database.setSwitchStatus(switchToBreak.dpId, SwitchStatus.ACTIVE)\n+\n+        when: \"Main path of the flow breaks\"\n+        def portDown = antiflap.portDown(islToBreak.srcSwitch.dpId, islToBreak.srcPort)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getLink(islToBreak).state == IslChangeType.FAILED\n+        }\n+\n+        then: \"System rollbacks from failover path, finds another working path and successfully reroutes the flow\"\n+        Wrappers.wait(PATH_INSTALLATION_TIME) {\n+            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+        }\n+        def currentPath = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        currentPath != mainPath\n+        currentPath != failoverPath\n+        !pathHelper.getInvolvedSwitches(currentPath).contains(switchToBreak)\n+        !pathHelper.getInvolvedIsls(currentPath).contains(islToBreak)\n+        !pathHelper.getInvolvedIsls(currentPath).contains(islToBreak.reversed)\n+\n+        and: \"All related switches have no rule anomalies\"\n+        [mainPath, failoverPath, currentPath].collectMany { pathHelper.getInvolvedSwitches(it) }.unique().each {\n+            northbound.validateSwitch(it.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\"])\n+        }\n+\n+        cleanup:\n+        if(switchIsOut) {\n+            database.setSwitchStatus(switchToBreak.dpId, SwitchStatus.INACTIVE)\n+            lockKeeper.reviveSwitch(switchToBreak)\n+            Wrappers.wait(WAIT_OFFSET) {\n+                assert northbound.getSwitch(switchToBreak.dpId).state == SwitchChangeType.ACTIVATED\n+            }\n+        }\n+        if(portDown) {\n+            antiflap.portUp(islToBreak.srcSwitch.dpId, islToBreak.srcPort)\n+            Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n+                assert northbound.getLink(islToBreak).state == IslChangeType.DISCOVERED\n+            }\n+        }\n+        flow && flowHelperV2.deleteFlow(flow.flowId)", "originalCommit": "e5f13bf5cac05835346cfb60df8b8f4d8f0cf447", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDE1ODI4Mw==", "url": "https://github.com/telstra/open-kilda/pull/3132#discussion_r370158283", "bodyText": "added", "author": "rtretyak", "createdAt": "2020-01-23T14:44:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1OTQ5Nw=="}], "type": "inlineReview"}, {"oid": "afb043507b6d349a48c4463457451c313c47b89a", "url": "https://github.com/telstra/open-kilda/commit/afb043507b6d349a48c4463457451c313c47b89a", "message": "Add test for #3128", "committedDate": "2020-01-23T14:43:46Z", "type": "forcePushed"}, {"oid": "b0db126c18b96958b1982b4e4a70cd0d26ff9bf4", "url": "https://github.com/telstra/open-kilda/commit/b0db126c18b96958b1982b4e4a70cd0d26ff9bf4", "message": "Add test for #3128", "committedDate": "2020-01-27T14:46:59Z", "type": "forcePushed"}, {"oid": "8f274e6d2ef0402db4f0ab79fdd25f407bf35fc3", "url": "https://github.com/telstra/open-kilda/commit/8f274e6d2ef0402db4f0ab79fdd25f407bf35fc3", "message": "Add test for #3128", "committedDate": "2020-02-03T17:31:30Z", "type": "forcePushed"}, {"oid": "f939d5da66c2f300a3268409f183de217c9b2386", "url": "https://github.com/telstra/open-kilda/commit/f939d5da66c2f300a3268409f183de217c9b2386", "message": "Add test for #3128", "committedDate": "2020-02-04T08:16:41Z", "type": "commit"}, {"oid": "650ee92de63ef888e407b94fe8dcdca15a3c4b34", "url": "https://github.com/telstra/open-kilda/commit/650ee92de63ef888e407b94fe8dcdca15a3c4b34", "message": "fix \"Flow in Down status is rerouted after switchUp event\" according to #3162", "committedDate": "2020-02-04T08:18:05Z", "type": "commit"}, {"oid": "650ee92de63ef888e407b94fe8dcdca15a3c4b34", "url": "https://github.com/telstra/open-kilda/commit/650ee92de63ef888e407b94fe8dcdca15a3c4b34", "message": "fix \"Flow in Down status is rerouted after switchUp event\" according to #3162", "committedDate": "2020-02-04T08:18:05Z", "type": "forcePushed"}, {"oid": "cde84a3321438171eebf06d8e3fb18e4861cb3be", "url": "https://github.com/telstra/open-kilda/commit/cde84a3321438171eebf06d8e3fb18e4861cb3be", "message": "improve tests according to reroute on switchUp event", "committedDate": "2020-02-04T09:39:43Z", "type": "commit"}]}