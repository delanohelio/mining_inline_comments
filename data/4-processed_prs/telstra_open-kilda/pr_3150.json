{"pr_number": 3150, "pr_title": "improve tests for flow rerouting after switchUp event", "pr_createdAt": "2020-01-28T14:19:15Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3150", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgzMDI5OA==", "url": "https://github.com/telstra/open-kilda/pull/3150#discussion_r371830298", "bodyText": "scr -> src", "author": "rtretyak", "createdAt": "2020-01-28T14:22:04Z", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -410,77 +412,162 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n     @Tidy\n     @Tags(VIRTUAL)\n     def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n-        given: \"Two active neighboring switches with two parallel links and two available paths\"\n+        given: \"First switch pair with two parallel links and two available paths\"\n         assumeTrue(\"Reroute should be completed before link is FAILED\", rerouteDelay * 2 < discoveryTimeout)\n-        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+        def switchPair1 = topologyHelper.getAllNeighboringSwitchPairs().find {\n             it.paths.findAll { it.size() == 2 }.size() > 1\n-        } ?: assumeTrue(\"No suiting switches found\", false)\n+        } ?: assumeTrue(\"No suiting switches found for the first flow\", false)\n+\n+        and: \"Second switch pair where the scr switch from the first switch pair is a transit switch\"", "originalCommit": "387a50073c16cda3da10645fdc630f6702697172", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg2MjU5NA==", "url": "https://github.com/telstra/open-kilda/pull/3150#discussion_r371862594", "bodyText": "thx, fixed", "author": "andriidovhan", "createdAt": "2020-01-28T15:12:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgzMDI5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgzNDAzMg==", "url": "https://github.com/telstra/open-kilda/pull/3150#discussion_r371834032", "bodyText": "Because of this condition I'm afraid you'll have to include all reversed(mirrored) switch pairs during search. Because all remaining switch pairs may use switchPair1.dst.dpId as their src", "author": "rtretyak", "createdAt": "2020-01-28T14:28:11Z", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -410,77 +412,162 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n     @Tidy\n     @Tags(VIRTUAL)\n     def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n-        given: \"Two active neighboring switches with two parallel links and two available paths\"\n+        given: \"First switch pair with two parallel links and two available paths\"\n         assumeTrue(\"Reroute should be completed before link is FAILED\", rerouteDelay * 2 < discoveryTimeout)\n-        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+        def switchPair1 = topologyHelper.getAllNeighboringSwitchPairs().find {\n             it.paths.findAll { it.size() == 2 }.size() > 1\n-        } ?: assumeTrue(\"No suiting switches found\", false)\n+        } ?: assumeTrue(\"No suiting switches found for the first flow\", false)\n+\n+        and: \"Second switch pair where the scr switch from the first switch pair is a transit switch\"\n+        List<PathNode> secondFlowPath\n+        def switchPair2 = topologyHelper.getAllNotNeighboringSwitchPairs().find { swP ->\n+            swP.paths.find { pathCandidate ->\n+                secondFlowPath = pathCandidate\n+                def involvedSwitches = pathHelper.getInvolvedSwitches(pathCandidate)\n+                involvedSwitches.size() == 3 && involvedSwitches[1].dpId == switchPair1.src.dpId &&\n+                        involvedSwitches[-1].dpId == switchPair1.dst.dpId", "originalCommit": "387a50073c16cda3da10645fdc630f6702697172", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTg3NDAxOA==", "url": "https://github.com/telstra/open-kilda/pull/3150#discussion_r371874018", "bodyText": "thx, fixed", "author": "andriidovhan", "createdAt": "2020-01-28T15:30:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgzNDAzMg=="}], "type": "inlineReview"}, {"oid": "a7689b77ea49965f40f752b6862224d5163f4c8b", "url": "https://github.com/telstra/open-kilda/commit/a7689b77ea49965f40f752b6862224d5163f4c8b", "message": "improve tests for flow rerouting after switchUp event", "committedDate": "2020-01-28T15:29:24Z", "type": "forcePushed"}, {"oid": "817b8c2c82883ff7855486aa7992da372b94eeb0", "url": "https://github.com/telstra/open-kilda/commit/817b8c2c82883ff7855486aa7992da372b94eeb0", "message": "improve tests for flow rerouting after switchUp event", "committedDate": "2020-01-28T15:32:18Z", "type": "forcePushed"}, {"oid": "4c182f19a62a5090efda10235b5b9459e5868f7d", "url": "https://github.com/telstra/open-kilda/commit/4c182f19a62a5090efda10235b5b9459e5868f7d", "message": "improve tests for flow rerouting after switchUp event", "committedDate": "2020-01-28T15:45:20Z", "type": "forcePushed"}, {"oid": "312d084f57bff86dfc3724313e789638e382d91e", "url": "https://github.com/telstra/open-kilda/commit/312d084f57bff86dfc3724313e789638e382d91e", "message": "improve tests for flow rerouting after switchUp event", "committedDate": "2020-01-28T15:49:58Z", "type": "forcePushed"}, {"oid": "20a73221e301d98b0038c88fe66f9daedfd7b4a2", "url": "https://github.com/telstra/open-kilda/commit/20a73221e301d98b0038c88fe66f9daedfd7b4a2", "message": "improve tests for flow rerouting after switchUp event", "committedDate": "2020-01-29T10:55:20Z", "type": "commit"}, {"oid": "20a73221e301d98b0038c88fe66f9daedfd7b4a2", "url": "https://github.com/telstra/open-kilda/commit/20a73221e301d98b0038c88fe66f9daedfd7b4a2", "message": "improve tests for flow rerouting after switchUp event", "committedDate": "2020-01-29T10:55:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjMxNjMzNQ==", "url": "https://github.com/telstra/open-kilda/pull/3150#discussion_r372316335", "bodyText": "I don't see any reason for this. prolonging test execution for another 2s", "author": "rtretyak", "createdAt": "2020-01-29T10:58:40Z", "path": "services/src/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/AutoRerouteV2Spec.groovy", "diffHunk": "@@ -410,87 +411,194 @@ class AutoRerouteV2Spec extends HealthCheckSpecification {\n     @Tidy\n     @Tags(VIRTUAL)\n     def \"Flow in 'Down' status is rerouted after switchUp event\"() {\n-        given: \"Two active neighboring switches with two parallel links and two available paths\"\n+        given: \"First switch pair with two parallel links and two available paths\"\n         assumeTrue(\"Reroute should be completed before link is FAILED\", rerouteDelay * 2 < discoveryTimeout)\n-        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+        def switchPair1 = topologyHelper.getAllNeighboringSwitchPairs().find {\n             it.paths.findAll { it.size() == 2 }.size() > 1\n-        } ?: assumeTrue(\"No suiting switches found\", false)\n+        } ?: assumeTrue(\"No suiting switches found for the first flow\", false)\n+\n+        and: \"Second switch pair where the sr\u0441 switch from the first switch pair is a transit switch\"\n+        List<PathNode> secondFlowPath\n+        def switchPair2 = topologyHelper.getAllNotNeighboringSwitchPairs().find { swP ->\n+            (swP.paths + swP.getReversed().paths).find { pathCandidate ->\n+                secondFlowPath = pathCandidate\n+                def involvedSwitches = pathHelper.getInvolvedSwitches(pathCandidate)\n+                involvedSwitches.size() == 3 && involvedSwitches[1].dpId == switchPair1.src.dpId &&\n+                        involvedSwitches[-1].dpId == switchPair1.dst.dpId\n+                /**\n+                 * Because of this condition we have to include all reversed(mirrored) switch pairs during search.\n+                 * Because all remaining switch pairs may use switchPair1.dst.dpId as their src\n+                 */\n+            }\n+        } ?: assumeTrue(\"No suiting switches found for the second flow\", false)\n \n-        //Main and backup paths for further manipulation with them\n-        def mainPath = switchPair.paths.min { it.size() }\n-        def backupPath = switchPair.paths.findAll { it != mainPath }.min { it.size() }\n-        def altPaths = switchPair.paths.findAll { it != mainPath && it != backupPath }\n+        //Main and backup paths of firstFlow for further manipulation with them\n+        def firstFlowMainPath = switchPair1.paths.min { it.size() }\n+        def firstFlowBackupPath = switchPair1.paths.findAll { it != firstFlowMainPath }.min { it.size() }\n+        def firstFlowAltPaths = switchPair1.paths.findAll {\n+            it != firstFlowMainPath && it != firstFlowBackupPath && it[0] != secondFlowPath[1]\n+        } // exclude firstFlowMainPath, firstFlowBackupPath and link which is used by second flow\n+        def secondFlowAltPaths = switchPair2.paths.findAll { it[1] != secondFlowPath[1] }\n \n-        //All alternative paths are unavailable (bring ports down on the srcSwitch)\n+        //All alternative paths for both flows are unavailable (bring ports down on the srcSwitch)\n         List<PathNode> broughtDownPorts = []\n-        altPaths.unique { it.first() }.each { path ->\n+        (firstFlowAltPaths + secondFlowAltPaths).unique { it.first() }.each { path ->\n             def src = path.first()\n             broughtDownPorts.add(src)\n             antiflap.portDown(src.switchId, src.portNo)\n         }\n         Wrappers.wait(antiflapMin + WAIT_OFFSET) {\n             assert northbound.getAllLinks().findAll {\n-                it.state == IslChangeType.FAILED\n+                it.state == FAILED\n             }.size() == broughtDownPorts.size() * 2\n         }\n \n-        //Main path more preferable than the backup\n-        pathHelper.makePathMorePreferable(mainPath, backupPath)\n+        //firstFlowMainPath path more preferable than the firstFlowBackupPath\n+        pathHelper.makePathMorePreferable(firstFlowMainPath, firstFlowBackupPath)\n \n-        and: \"A flow\"\n-        def flow = flowHelperV2.randomFlow(switchPair)\n-        flowHelperV2.addFlow(flow)\n-        assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+        and: \"First flow without transit switches\"\n+        def firstFlow = flowHelperV2.randomFlow(switchPair1)\n+        flowHelperV2.addFlow(firstFlow)\n+        assert PathHelper.convert(northbound.getFlowPath(firstFlow.flowId)) == firstFlowMainPath\n+\n+        and: \"Second flow with transit switch\"\n+        def secondFlow = flowHelperV2.randomFlow(switchPair2)\n+        flowHelperV2.addFlow(secondFlow)\n+        assert PathHelper.convert(northbound.getFlowPath(secondFlow.flowId)) == secondFlowPath\n \n-        when: \"Disconnect the src switch from the controller\"\n-        def islToBreak = pathHelper.getInvolvedIsls(mainPath).first()\n-        def islToReroute = pathHelper.getInvolvedIsls(backupPath).first()\n-        lockKeeper.knockoutSwitch(switchPair.src)\n+        when: \"Disconnect the src switch of the first flow from the controller\"\n+        def islToBreak = pathHelper.getInvolvedIsls(firstFlowMainPath).first()\n+        def islToReroute = pathHelper.getInvolvedIsls(firstFlowBackupPath).first()\n+        lockKeeper.knockoutSwitch(switchPair1.src)\n         Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n-            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.DEACTIVATED\n+            assert northbound.getSwitch(switchPair1.src.dpId).state == SwitchChangeType.DEACTIVATED\n         }\n+        def isSwitchActivated = false\n \n         and: \"Mark the switch as ACTIVE in db\" // just to reproduce #3131\n-        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.ACTIVE)\n+        database.setSwitchStatus(switchPair1.src.dpId, SwitchStatus.ACTIVE)\n \n         and: \"Init auto reroute (bring ports down on the dstSwitch)\"\n         antiflap.portDown(islToBreak.dstSwitch.dpId, islToBreak.dstPort)\n \n-        then: \"Flow is not rerouted and flow status is 'Down'\"\n+        then: \"Flows are not rerouted and flows status are 'Down'\"\n+        def flowPathMap = [(firstFlow.flowId): firstFlowMainPath, (secondFlow.flowId): secondFlowPath]\n         TimeUnit.SECONDS.sleep(rerouteDelay * 2) // it helps to be sure that the auto-reroute operation is completed\n         Wrappers.wait(WAIT_OFFSET / 2) {\n             assert northbound.getLink(islToBreak).state == FAILED\n             // just to be sure that backup ISL is not failed\n             assert northbound.getLink(islToReroute).state == DISCOVERED\n-            assert northbound.getFlowStatus(flow.flowId).status == FlowState.DOWN\n-            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == mainPath\n+            withPool {\n+                [firstFlow.flowId, secondFlow.flowId].eachParallel { String flowId ->\n+                    assert northbound.getFlowStatus(flowId).status == FlowState.DOWN\n+                    assert PathHelper.convert(northbound.getFlowPath(flowId)) == flowPathMap[flowId]\n+                }\n+            }\n         }\n \n         when: \"Connect the switch back to the controller\"\n-        database.setSwitchStatus(switchPair.src.dpId, SwitchStatus.INACTIVE) // set real status\n-        lockKeeper.reviveSwitch(switchPair.src)\n+        database.setSwitchStatus(switchPair1.src.dpId, SwitchStatus.INACTIVE) // set real status\n+        lockKeeper.reviveSwitch(switchPair1.src)\n         Wrappers.wait(WAIT_OFFSET) {\n-            assert northbound.getSwitch(switchPair.src.dpId).state == SwitchChangeType.ACTIVATED\n+            assert northbound.getSwitch(switchPair1.src.dpId).state == SwitchChangeType.ACTIVATED\n         }\n+        isSwitchActivated = true\n \n-        then: \"Flow is rerouted\"\n+        then: \"Both flows are rerouted\"\n         Wrappers.wait(rerouteDelay + WAIT_OFFSET) {\n-            assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n-            assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == backupPath\n+            withPool {\n+                [firstFlow.flowId, secondFlow.flowId].eachParallel { String flowId ->\n+                    assert northbound.getFlowStatus(flowId).status == FlowState.UP\n+                    assert PathHelper.convert(northbound.getFlowPath(flowId)) != flowPathMap[flowId]\n+                }\n+            }\n         }\n \n-        //and: \"Flow is rerouted due to switchUp event\"\n-        //TODO(andriidovhan) check flow history (it is not implemented yet)\n+        and: \"Flow is rerouted due to switchUp event\"\n+        //TODO(andriidovhan) specify flow history verification(it is not implemented yet) Reroute reason: switchUp event\n+        Wrappers.wait(WAIT_OFFSET / 2) {\n+            assert northbound.getFlowHistory(firstFlow.flowId).findAll { it.action == \"Flow rerouting\" }.size() == 2\n+            assert northbound.getFlowHistory(secondFlow.flowId).findAll { it.action == \"Flow rerouting\" }.size() == 2\n+        }\n \n         cleanup: \"Restore topology, delete the flow and reset costs\"\n-        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        firstFlow && flowHelperV2.deleteFlow(firstFlow.flowId)\n+        secondFlow && flowHelperV2.deleteFlow(secondFlow.flowId)\n+        !isSwitchActivated && lockKeeper.reviveSwitch(switchPair1.src)\n+        Wrappers.wait(WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchPair1.src.dpId).state == SwitchChangeType.ACTIVATED\n+        }\n         islToBreak && antiflap.portUp(islToBreak.dstSwitch.dpId, islToBreak.dstPort)\n         broughtDownPorts && broughtDownPorts.each { antiflap.portUp(it.switchId, it.portNo) }\n         Wrappers.wait(discoveryInterval + WAIT_OFFSET) {\n             northbound.getAllLinks().each { assert it.state != FAILED }\n         }\n     }\n \n+    @Tidy\n+    def \"Flow is not rerouted when switchUp event appear for a switch which is not related to the flow\"() {\n+        given: \"Given a flow in DOWN status on neighboring switches\"\n+        def swP = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            it.paths.findAll { it.size() == 2 }.size() == 1\n+        } ?: assumeTrue(\"No suiting switches found\", false)\n+\n+        def flowPath = swP.paths.min { it.size() }\n+        def altPath = swP.paths.findAll { it != flowPath }\n+        def flow = flowHelperV2.randomFlow(swP)\n+        flowHelperV2.addFlow(flow)\n+        assert PathHelper.convert(northbound.getFlowPath(flow.flowId)) == flowPath\n+\n+        //All alternative paths for both flows are unavailable (bring ports down on the srcSwitch)\n+        List<PathNode> broughtDownPorts = []\n+        altPath.unique { it.first() }.each { path ->\n+            def src = path.first()\n+            broughtDownPorts.add(src)\n+            antiflap.portDown(src.switchId, src.portNo)\n+        }\n+        Wrappers.wait(antiflapMin + WAIT_OFFSET) {\n+            assert northbound.getAllLinks().findAll {\n+                it.state == FAILED\n+            }.size() == broughtDownPorts.size() * 2\n+        }\n+\n+        //move the flow to DOWN status\n+        def islToBreak = pathHelper.getInvolvedIsls(flowPath).first()\n+        antiflap.portDown(islToBreak.srcSwitch.dpId, islToBreak.srcPort)\n+        assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP\n+\n+        when: \"Generate switchUp event on switch which is not related to the flow\"\n+        def involvedSwitches = pathHelper.getInvolvedSwitches(flowPath)*.dpId\n+        def switchToManipulate = topology.activeSwitches.find { !(it.dpId in involvedSwitches) }\n+        lockKeeper.knockoutSwitch(switchToManipulate)\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchToManipulate.dpId).state == SwitchChangeType.DEACTIVATED\n+        }\n+        def isSwitchActivated = false\n+        lockKeeper.reviveSwitch(switchToManipulate)\n+        Wrappers.wait(discoveryTimeout + WAIT_OFFSET) {\n+            assert northbound.getSwitch(switchToManipulate.dpId).state == SwitchChangeType.ACTIVATED\n+        }\n+        isSwitchActivated = true\n+\n+        then: \"Flow is not triggered for reroute due to switchUp event because switch is not related to the flow\"\n+        TimeUnit.SECONDS.sleep(rerouteDelay * 2) // it helps to be sure that the auto-reroute operation is completed\n+        Wrappers.timedLoop(rerouteDelay) { // just in case", "originalCommit": "20a73221e301d98b0038c88fe66f9daedfd7b4a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1NjMyMA==", "url": "https://github.com/telstra/open-kilda/pull/3150#discussion_r372356320", "bodyText": "I will remove it in further pr", "author": "andriidovhan", "createdAt": "2020-01-29T12:34:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjMxNjMzNQ=="}], "type": "inlineReview"}]}