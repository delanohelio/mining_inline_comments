{"pr_number": 3739, "pr_title": "add tests for #3728", "pr_createdAt": "2020-09-24T14:15:36Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3739", "timeline": [{"oid": "241bc3ceb5878e89563ce9da9c0d8ce97f1805d2", "url": "https://github.com/telstra/open-kilda/commit/241bc3ceb5878e89563ce9da9c0d8ce97f1805d2", "message": "add tests for #3728", "committedDate": "2020-09-25T06:16:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc3MDYyNA==", "url": "https://github.com/telstra/open-kilda/pull/3739#discussion_r494770624", "bodyText": "I'd rename it System doesn't rebuild path for the flow... since reroute could be miss-leading here", "author": "timofei-durakov", "createdAt": "2020-09-25T06:19:44Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowCrudV2Spec.groovy", "diffHunk": "@@ -1104,6 +1103,155 @@ class FlowCrudV2Spec extends HealthCheckSpecification {\n         }\n     }\n \n+    @Tidy\n+    def \"System doesn't reroute flow to more preferable path while updating portNumber/vlanId\"() {", "originalCommit": "241bc3ceb5878e89563ce9da9c0d8ce97f1805d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc5MjU3MA==", "url": "https://github.com/telstra/open-kilda/pull/3739#discussion_r494792570", "bodyText": "renamed", "author": "andriidovhan", "createdAt": "2020-09-25T07:13:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc3MDYyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc3MTEwNA==", "url": "https://github.com/telstra/open-kilda/pull/3739#discussion_r494771104", "bodyText": "it will be better if you verify separately all three scenarios:\n\nsrc endpoint changed\ndst endpoint changed\nboth endpoints changed", "author": "timofei-durakov", "createdAt": "2020-09-25T06:21:05Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowCrudV2Spec.groovy", "diffHunk": "@@ -1104,6 +1103,155 @@ class FlowCrudV2Spec extends HealthCheckSpecification {\n         }\n     }\n \n+    @Tidy\n+    def \"System doesn't reroute flow to more preferable path while updating portNumber/vlanId\"() {\n+        given: \"Two active switches connected to traffgens with two possible paths at least\"\n+        def allTraffgenSwitchIds = topology.activeTraffGens*.switchConnected*.dpId ?:\n+                assumeTrue(\"Should be at least two active traffgens connected to switches\", false)\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find { swP ->\n+            allTraffgenSwitchIds.contains(swP.src.dpId) && allTraffgenSwitchIds.contains(swP.dst.dpId) &&\n+                    swP.paths.size() >= 2\n+        } ?: assumeTrue(\"Unable to find required switches/paths in topology\",false)\n+\n+        and: \"A flow\"\n+        def flow = flowHelperV2.randomFlow(switchPair, false)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Make the current path less preferable than alternatives\"\n+        def currentPath = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        def alternativePaths = switchPair.paths.findAll { it != currentPath }\n+        alternativePaths.each { pathHelper.makePathMorePreferable(it, currentPath) }\n+\n+        and: \"Update the flow: port number and vlanId on the src/dst endpoints\"\n+        def updatedFlow = flow.jacksonCopy().tap {", "originalCommit": "241bc3ceb5878e89563ce9da9c0d8ce97f1805d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDgwMjQ1Nw==", "url": "https://github.com/telstra/open-kilda/pull/3739#discussion_r494802457", "bodyText": "added", "author": "andriidovhan", "createdAt": "2020-09-25T07:34:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc3MTEwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc3MTY1OA==", "url": "https://github.com/telstra/open-kilda/pull/3739#discussion_r494771658", "bodyText": "destination is updated on line 1129, no checks for it is made here", "author": "timofei-durakov", "createdAt": "2020-09-25T06:22:41Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowCrudV2Spec.groovy", "diffHunk": "@@ -1104,6 +1103,155 @@ class FlowCrudV2Spec extends HealthCheckSpecification {\n         }\n     }\n \n+    @Tidy\n+    def \"System doesn't reroute flow to more preferable path while updating portNumber/vlanId\"() {\n+        given: \"Two active switches connected to traffgens with two possible paths at least\"\n+        def allTraffgenSwitchIds = topology.activeTraffGens*.switchConnected*.dpId ?:\n+                assumeTrue(\"Should be at least two active traffgens connected to switches\", false)\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find { swP ->\n+            allTraffgenSwitchIds.contains(swP.src.dpId) && allTraffgenSwitchIds.contains(swP.dst.dpId) &&\n+                    swP.paths.size() >= 2\n+        } ?: assumeTrue(\"Unable to find required switches/paths in topology\",false)\n+\n+        and: \"A flow\"\n+        def flow = flowHelperV2.randomFlow(switchPair, false)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Make the current path less preferable than alternatives\"\n+        def currentPath = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        def alternativePaths = switchPair.paths.findAll { it != currentPath }\n+        alternativePaths.each { pathHelper.makePathMorePreferable(it, currentPath) }\n+\n+        and: \"Update the flow: port number and vlanId on the src/dst endpoints\"\n+        def updatedFlow = flow.jacksonCopy().tap {\n+            it.source.portNumber = 10 // traffgen port\n+            it.source.vlanId = flow.destination.vlanId + 1\n+            it.destination.portNumber = 10 // traffgen port\n+            it.destination.vlanId = flow.source.vlanId + 1\n+        }\n+        flowHelperV2.updateFlow(flow.flowId, updatedFlow)\n+\n+        then: \"Flow is really updated\"\n+        with(northboundV2.getFlow(flow.flowId)) {\n+            it.source.portNumber == updatedFlow.source.portNumber\n+            it.source.vlanId == updatedFlow.source.vlanId", "originalCommit": "241bc3ceb5878e89563ce9da9c0d8ce97f1805d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDgwMjM5MA==", "url": "https://github.com/telstra/open-kilda/pull/3739#discussion_r494802390", "bodyText": "oops, my bad.\nfixed", "author": "andriidovhan", "createdAt": "2020-09-25T07:34:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc3MTY1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc3MjY4OQ==", "url": "https://github.com/telstra/open-kilda/pull/3739#discussion_r494772689", "bodyText": "this scenario as-is seems to be useless, isl conflict validation is made prior the update happen, If you want to verify rollback you need to knock out src switch during the update for example, or make fl not receiving install commands", "author": "timofei-durakov", "createdAt": "2020-09-25T06:25:30Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowCrudV2Spec.groovy", "diffHunk": "@@ -1104,6 +1103,155 @@ class FlowCrudV2Spec extends HealthCheckSpecification {\n         }\n     }\n \n+    @Tidy\n+    def \"System doesn't reroute flow to more preferable path while updating portNumber/vlanId\"() {\n+        given: \"Two active switches connected to traffgens with two possible paths at least\"\n+        def allTraffgenSwitchIds = topology.activeTraffGens*.switchConnected*.dpId ?:\n+                assumeTrue(\"Should be at least two active traffgens connected to switches\", false)\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find { swP ->\n+            allTraffgenSwitchIds.contains(swP.src.dpId) && allTraffgenSwitchIds.contains(swP.dst.dpId) &&\n+                    swP.paths.size() >= 2\n+        } ?: assumeTrue(\"Unable to find required switches/paths in topology\",false)\n+\n+        and: \"A flow\"\n+        def flow = flowHelperV2.randomFlow(switchPair, false)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Make the current path less preferable than alternatives\"\n+        def currentPath = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        def alternativePaths = switchPair.paths.findAll { it != currentPath }\n+        alternativePaths.each { pathHelper.makePathMorePreferable(it, currentPath) }\n+\n+        and: \"Update the flow: port number and vlanId on the src/dst endpoints\"\n+        def updatedFlow = flow.jacksonCopy().tap {\n+            it.source.portNumber = 10 // traffgen port\n+            it.source.vlanId = flow.destination.vlanId + 1\n+            it.destination.portNumber = 10 // traffgen port\n+            it.destination.vlanId = flow.source.vlanId + 1\n+        }\n+        flowHelperV2.updateFlow(flow.flowId, updatedFlow)\n+\n+        then: \"Flow is really updated\"\n+        with(northboundV2.getFlow(flow.flowId)) {\n+            it.source.portNumber == updatedFlow.source.portNumber\n+            it.source.vlanId == updatedFlow.source.vlanId\n+        }\n+\n+        and: \"Flow is not rerouted\"\n+        Wrappers.timedLoop(rerouteDelay + WAIT_OFFSET / 2) {\n+            pathHelper.convert(northbound.getFlowPath(flow.flowId)) == currentPath\n+        }\n+\n+        and: \"System allows traffic on the flow\"\n+        def traffExam = traffExamProvider.get()\n+        def examFlow = new FlowTrafficExamBuilder(topology, traffExam).buildBidirectionalExam(\n+                flowHelperV2.toV1(updatedFlow), 100, 5\n+        )\n+        withPool {\n+            [examFlow.forward, examFlow.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"Flow is valid\"\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"All involved switches pass switch validation\"\n+        withPool {\n+            currentPath*.switchId.eachParallel { SwitchId swId ->\n+                with(northbound.validateSwitch(swId)) { validation ->\n+                    validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                    validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                }\n+            }\n+        }\n+        def involvedSwitchesPassSwValidation = true\n+\n+        cleanup: \"Revert system to original state\"\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        northbound.deleteLinkProps(northbound.getAllLinkProps())\n+        !involvedSwitchesPassSwValidation && currentPath*.switchId.each { SwitchId swId ->\n+            northbound.synchronizeSwitch(swId, true)\n+        }\n+        database.resetCosts()\n+    }\n+\n+    @Tidy\n+    def \"System doesn't reroute flow to more preferable path during rollback after unsuccessfull update portNumber action\"() {", "originalCommit": "241bc3ceb5878e89563ce9da9c0d8ce97f1805d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDgwMjUzNQ==", "url": "https://github.com/telstra/open-kilda/pull/3739#discussion_r494802535", "bodyText": "deleted", "author": "andriidovhan", "createdAt": "2020-09-25T07:34:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc3MjY4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc3NDM5Nw==", "url": "https://github.com/telstra/open-kilda/pull/3739#discussion_r494774397", "bodyText": "the same issue, btw, no inner vlan validation here", "author": "timofei-durakov", "createdAt": "2020-09-25T06:29:56Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/QinQFlowSpec.groovy", "diffHunk": "@@ -885,4 +887,80 @@ class QinQFlowSpec extends HealthCheckSpecification {\n         cleanup:\n         flow && flowHelperV2.deleteFlow(flow.flowId)\n     }\n+\n+    @Tidy\n+    def \"System doesn't reroute flow to more preferable path while updating innerVlanId\"() {\n+        given: \"Two active switches connected to traffgens with two possible paths at least\"\n+        def allTraffgenSwitchIds = topology.activeTraffGens*.switchConnected*.dpId ?:\n+                assumeTrue(\"Should be at least two active traffgens connected to switches\", false)\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffgenSwitchIds && northbound.getSwitchProperties(sw.dpId).multiTable\n+            } && it.paths.size() > 2\n+        } ?: assumeTrue(\"Not able to find enough switches with traffgens and in multi-table mode\", false)\n+\n+        and: \"A flow\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flow.source.innerVlanId = flow.source.vlanId\n+        flow.destination.innerVlanId = flow.destination.vlanId\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Make the current path less preferable than alternatives\"\n+        def currentPath = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        def alternativePaths = switchPair.paths.findAll { it != currentPath }\n+        alternativePaths.each { pathHelper.makePathMorePreferable(it, currentPath) }\n+\n+        and: \"Update the flow: port number and vlanId on the src/dst endpoints\"\n+        def updatedFlow = flow.jacksonCopy().tap {\n+            it.source.innerVlanId = flow.destination.vlanId\n+            it.destination.innerVlanId = flow.source.vlanId\n+        }\n+        flowHelperV2.updateFlow(flow.flowId, updatedFlow)\n+\n+        then: \"Flow is really updated\"\n+        with(northboundV2.getFlow(flow.flowId)) {\n+            it.source.portNumber == updatedFlow.source.portNumber", "originalCommit": "241bc3ceb5878e89563ce9da9c0d8ce97f1805d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDgwOTQxOA==", "url": "https://github.com/telstra/open-kilda/pull/3739#discussion_r494809418", "bodyText": "thx, fixed", "author": "andriidovhan", "createdAt": "2020-09-25T07:48:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc3NDM5Nw=="}], "type": "inlineReview"}, {"oid": "c4c247278144168492da83683db979e946bf3538", "url": "https://github.com/telstra/open-kilda/commit/c4c247278144168492da83683db979e946bf3538", "message": "add tests for #3728", "committedDate": "2020-09-25T07:54:26Z", "type": "forcePushed"}, {"oid": "b47ea2f257e0cfb2ef9371ab4557319acfad2dc3", "url": "https://github.com/telstra/open-kilda/commit/b47ea2f257e0cfb2ef9371ab4557319acfad2dc3", "message": "add tests for #3728", "committedDate": "2020-09-29T06:52:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI4NDA4Mg==", "url": "https://github.com/telstra/open-kilda/pull/3739#discussion_r497284082", "bodyText": "should be taken from topology.yaml", "author": "rtretyak", "createdAt": "2020-09-30T07:01:57Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowCrudV2Spec.groovy", "diffHunk": "@@ -1104,6 +1103,117 @@ class FlowCrudV2Spec extends HealthCheckSpecification {\n         }\n     }\n \n+    @Tidy\n+    def \"System doesn't rebuild path for a flow to more preferable path while updating portNumber/vlanId\"() {\n+        given: \"Two active switches connected to traffgens with two possible paths at least\"\n+        def allTraffgenSwitchIds = topology.activeTraffGens*.switchConnected*.dpId ?:\n+                assumeTrue(\"Should be at least two active traffgens connected to switches\", false)\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find { swP ->\n+            allTraffgenSwitchIds.contains(swP.src.dpId) && allTraffgenSwitchIds.contains(swP.dst.dpId) &&\n+                    swP.paths.size() >= 2\n+        } ?: assumeTrue(\"Unable to find required switches/paths in topology\",false)\n+\n+        and: \"A flow\"\n+        def flow = flowHelperV2.randomFlow(switchPair, false)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Make the current path less preferable than alternatives\"\n+        def currentPath = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        def alternativePaths = switchPair.paths.findAll { it != currentPath }\n+        alternativePaths.each { pathHelper.makePathMorePreferable(it, currentPath) }\n+\n+        and: \"Update the flow: vlanId on the src endpoint\"\n+        def updatedFlowSrcEndpoint = flow.jacksonCopy().tap {\n+            it.source.vlanId = flow.destination.vlanId + 1\n+        }\n+        flowHelperV2.updateFlow(flow.flowId, updatedFlowSrcEndpoint)\n+\n+        then: \"Flow is really updated\"\n+        with(northboundV2.getFlow(flow.flowId)) {\n+            it.source.portNumber == updatedFlowSrcEndpoint.source.portNumber\n+            it.source.vlanId == updatedFlowSrcEndpoint.source.vlanId\n+        }\n+\n+        and: \"Flow path is not rebuild\"\n+        Wrappers.timedLoop(rerouteDelay) {\n+            pathHelper.convert(northbound.getFlowPath(flow.flowId)) == currentPath\n+        }\n+\n+        when: \"Update the flow: vlanId on the dst endpoint\"\n+        def updatedFlowDstEndpoint = flow.jacksonCopy().tap {\n+            it.destination.vlanId = flow.source.vlanId + 1\n+        }\n+        flowHelperV2.updateFlow(flow.flowId, updatedFlowDstEndpoint)\n+\n+        then: \"Flow is really updated\"\n+        with(northboundV2.getFlow(flow.flowId)) {\n+            it.destination.portNumber == updatedFlowDstEndpoint.destination.portNumber\n+            it.destination.vlanId == updatedFlowDstEndpoint.destination.vlanId\n+        }\n+\n+        and: \"Flow path is not rebuild\"\n+        Wrappers.timedLoop(rerouteDelay) {\n+            pathHelper.convert(northbound.getFlowPath(flow.flowId)) == currentPath\n+        }\n+\n+        then: \"Update the flow: port number and vlanId on the src/dst endpoints\"\n+        def updatedFlow = flow.jacksonCopy().tap {\n+            it.source.portNumber = 10 // traffgen port", "originalCommit": "b47ea2f257e0cfb2ef9371ab4557319acfad2dc3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMwNjQ3MA==", "url": "https://github.com/telstra/open-kilda/pull/3739#discussion_r497306470", "bodyText": "fixed", "author": "andriidovhan", "createdAt": "2020-09-30T07:44:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI4NDA4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI4NDg3MA==", "url": "https://github.com/telstra/open-kilda/pull/3739#discussion_r497284870", "bodyText": "assert", "author": "rtretyak", "createdAt": "2020-09-30T07:03:45Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowCrudV2Spec.groovy", "diffHunk": "@@ -1104,6 +1103,117 @@ class FlowCrudV2Spec extends HealthCheckSpecification {\n         }\n     }\n \n+    @Tidy\n+    def \"System doesn't rebuild path for a flow to more preferable path while updating portNumber/vlanId\"() {\n+        given: \"Two active switches connected to traffgens with two possible paths at least\"\n+        def allTraffgenSwitchIds = topology.activeTraffGens*.switchConnected*.dpId ?:\n+                assumeTrue(\"Should be at least two active traffgens connected to switches\", false)\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find { swP ->\n+            allTraffgenSwitchIds.contains(swP.src.dpId) && allTraffgenSwitchIds.contains(swP.dst.dpId) &&\n+                    swP.paths.size() >= 2\n+        } ?: assumeTrue(\"Unable to find required switches/paths in topology\",false)\n+\n+        and: \"A flow\"\n+        def flow = flowHelperV2.randomFlow(switchPair, false)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Make the current path less preferable than alternatives\"\n+        def currentPath = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        def alternativePaths = switchPair.paths.findAll { it != currentPath }\n+        alternativePaths.each { pathHelper.makePathMorePreferable(it, currentPath) }\n+\n+        and: \"Update the flow: vlanId on the src endpoint\"\n+        def updatedFlowSrcEndpoint = flow.jacksonCopy().tap {\n+            it.source.vlanId = flow.destination.vlanId + 1\n+        }\n+        flowHelperV2.updateFlow(flow.flowId, updatedFlowSrcEndpoint)\n+\n+        then: \"Flow is really updated\"\n+        with(northboundV2.getFlow(flow.flowId)) {\n+            it.source.portNumber == updatedFlowSrcEndpoint.source.portNumber\n+            it.source.vlanId == updatedFlowSrcEndpoint.source.vlanId\n+        }\n+\n+        and: \"Flow path is not rebuild\"\n+        Wrappers.timedLoop(rerouteDelay) {\n+            pathHelper.convert(northbound.getFlowPath(flow.flowId)) == currentPath\n+        }\n+\n+        when: \"Update the flow: vlanId on the dst endpoint\"\n+        def updatedFlowDstEndpoint = flow.jacksonCopy().tap {\n+            it.destination.vlanId = flow.source.vlanId + 1\n+        }\n+        flowHelperV2.updateFlow(flow.flowId, updatedFlowDstEndpoint)\n+\n+        then: \"Flow is really updated\"\n+        with(northboundV2.getFlow(flow.flowId)) {\n+            it.destination.portNumber == updatedFlowDstEndpoint.destination.portNumber\n+            it.destination.vlanId == updatedFlowDstEndpoint.destination.vlanId\n+        }\n+\n+        and: \"Flow path is not rebuild\"\n+        Wrappers.timedLoop(rerouteDelay) {\n+            pathHelper.convert(northbound.getFlowPath(flow.flowId)) == currentPath", "originalCommit": "b47ea2f257e0cfb2ef9371ab4557319acfad2dc3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI4OTYxMg==", "url": "https://github.com/telstra/open-kilda/pull/3739#discussion_r497289612", "bodyText": "agree, fixed", "author": "andriidovhan", "createdAt": "2020-09-30T07:13:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI4NDg3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI4NDkzNQ==", "url": "https://github.com/telstra/open-kilda/pull/3739#discussion_r497284935", "bodyText": "assert", "author": "rtretyak", "createdAt": "2020-09-30T07:03:53Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowCrudV2Spec.groovy", "diffHunk": "@@ -1104,6 +1103,117 @@ class FlowCrudV2Spec extends HealthCheckSpecification {\n         }\n     }\n \n+    @Tidy\n+    def \"System doesn't rebuild path for a flow to more preferable path while updating portNumber/vlanId\"() {\n+        given: \"Two active switches connected to traffgens with two possible paths at least\"\n+        def allTraffgenSwitchIds = topology.activeTraffGens*.switchConnected*.dpId ?:\n+                assumeTrue(\"Should be at least two active traffgens connected to switches\", false)\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find { swP ->\n+            allTraffgenSwitchIds.contains(swP.src.dpId) && allTraffgenSwitchIds.contains(swP.dst.dpId) &&\n+                    swP.paths.size() >= 2\n+        } ?: assumeTrue(\"Unable to find required switches/paths in topology\",false)\n+\n+        and: \"A flow\"\n+        def flow = flowHelperV2.randomFlow(switchPair, false)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Make the current path less preferable than alternatives\"\n+        def currentPath = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        def alternativePaths = switchPair.paths.findAll { it != currentPath }\n+        alternativePaths.each { pathHelper.makePathMorePreferable(it, currentPath) }\n+\n+        and: \"Update the flow: vlanId on the src endpoint\"\n+        def updatedFlowSrcEndpoint = flow.jacksonCopy().tap {\n+            it.source.vlanId = flow.destination.vlanId + 1\n+        }\n+        flowHelperV2.updateFlow(flow.flowId, updatedFlowSrcEndpoint)\n+\n+        then: \"Flow is really updated\"\n+        with(northboundV2.getFlow(flow.flowId)) {\n+            it.source.portNumber == updatedFlowSrcEndpoint.source.portNumber\n+            it.source.vlanId == updatedFlowSrcEndpoint.source.vlanId\n+        }\n+\n+        and: \"Flow path is not rebuild\"\n+        Wrappers.timedLoop(rerouteDelay) {\n+            pathHelper.convert(northbound.getFlowPath(flow.flowId)) == currentPath\n+        }\n+\n+        when: \"Update the flow: vlanId on the dst endpoint\"\n+        def updatedFlowDstEndpoint = flow.jacksonCopy().tap {\n+            it.destination.vlanId = flow.source.vlanId + 1\n+        }\n+        flowHelperV2.updateFlow(flow.flowId, updatedFlowDstEndpoint)\n+\n+        then: \"Flow is really updated\"\n+        with(northboundV2.getFlow(flow.flowId)) {\n+            it.destination.portNumber == updatedFlowDstEndpoint.destination.portNumber\n+            it.destination.vlanId == updatedFlowDstEndpoint.destination.vlanId\n+        }\n+\n+        and: \"Flow path is not rebuild\"\n+        Wrappers.timedLoop(rerouteDelay) {\n+            pathHelper.convert(northbound.getFlowPath(flow.flowId)) == currentPath\n+        }\n+\n+        then: \"Update the flow: port number and vlanId on the src/dst endpoints\"\n+        def updatedFlow = flow.jacksonCopy().tap {\n+            it.source.portNumber = 10 // traffgen port\n+            it.source.vlanId = updatedFlowDstEndpoint.source.vlanId + 1\n+            it.destination.portNumber = 10 // traffgen port\n+            it.destination.vlanId = updatedFlowDstEndpoint.destination.vlanId + 1\n+        }\n+        flowHelperV2.updateFlow(flow.flowId, updatedFlow)\n+\n+        then: \"Flow is really updated\"\n+        with(northboundV2.getFlow(flow.flowId)) {\n+            it.source.portNumber == updatedFlow.source.portNumber\n+            it.source.vlanId == updatedFlow.source.vlanId\n+            it.destination.portNumber == updatedFlow.destination.portNumber\n+            it.destination.vlanId == updatedFlow.destination.vlanId\n+        }\n+\n+        and: \"Flow path is not rebuild\"\n+        Wrappers.timedLoop(rerouteDelay + WAIT_OFFSET / 2) {\n+            pathHelper.convert(northbound.getFlowPath(flow.flowId)) == currentPath", "originalCommit": "b47ea2f257e0cfb2ef9371ab4557319acfad2dc3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI5MTIwMQ==", "url": "https://github.com/telstra/open-kilda/pull/3739#discussion_r497291201", "bodyText": "fixed", "author": "andriidovhan", "createdAt": "2020-09-30T07:16:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI4NDkzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI4NTUyOQ==", "url": "https://github.com/telstra/open-kilda/pull/3739#discussion_r497285529", "bodyText": "not required", "author": "rtretyak", "createdAt": "2020-09-30T07:05:11Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowCrudV2Spec.groovy", "diffHunk": "@@ -1104,6 +1103,117 @@ class FlowCrudV2Spec extends HealthCheckSpecification {\n         }\n     }\n \n+    @Tidy\n+    def \"System doesn't rebuild path for a flow to more preferable path while updating portNumber/vlanId\"() {\n+        given: \"Two active switches connected to traffgens with two possible paths at least\"\n+        def allTraffgenSwitchIds = topology.activeTraffGens*.switchConnected*.dpId ?:\n+                assumeTrue(\"Should be at least two active traffgens connected to switches\", false)\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find { swP ->\n+            allTraffgenSwitchIds.contains(swP.src.dpId) && allTraffgenSwitchIds.contains(swP.dst.dpId) &&\n+                    swP.paths.size() >= 2\n+        } ?: assumeTrue(\"Unable to find required switches/paths in topology\",false)\n+\n+        and: \"A flow\"\n+        def flow = flowHelperV2.randomFlow(switchPair, false)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Make the current path less preferable than alternatives\"\n+        def currentPath = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        def alternativePaths = switchPair.paths.findAll { it != currentPath }\n+        alternativePaths.each { pathHelper.makePathMorePreferable(it, currentPath) }\n+\n+        and: \"Update the flow: vlanId on the src endpoint\"\n+        def updatedFlowSrcEndpoint = flow.jacksonCopy().tap {\n+            it.source.vlanId = flow.destination.vlanId + 1\n+        }\n+        flowHelperV2.updateFlow(flow.flowId, updatedFlowSrcEndpoint)\n+\n+        then: \"Flow is really updated\"\n+        with(northboundV2.getFlow(flow.flowId)) {\n+            it.source.portNumber == updatedFlowSrcEndpoint.source.portNumber\n+            it.source.vlanId == updatedFlowSrcEndpoint.source.vlanId\n+        }\n+\n+        and: \"Flow path is not rebuild\"\n+        Wrappers.timedLoop(rerouteDelay) {\n+            pathHelper.convert(northbound.getFlowPath(flow.flowId)) == currentPath\n+        }\n+\n+        when: \"Update the flow: vlanId on the dst endpoint\"\n+        def updatedFlowDstEndpoint = flow.jacksonCopy().tap {\n+            it.destination.vlanId = flow.source.vlanId + 1\n+        }\n+        flowHelperV2.updateFlow(flow.flowId, updatedFlowDstEndpoint)\n+\n+        then: \"Flow is really updated\"\n+        with(northboundV2.getFlow(flow.flowId)) {\n+            it.destination.portNumber == updatedFlowDstEndpoint.destination.portNumber\n+            it.destination.vlanId == updatedFlowDstEndpoint.destination.vlanId\n+        }\n+\n+        and: \"Flow path is not rebuild\"\n+        Wrappers.timedLoop(rerouteDelay) {\n+            pathHelper.convert(northbound.getFlowPath(flow.flowId)) == currentPath\n+        }\n+\n+        then: \"Update the flow: port number and vlanId on the src/dst endpoints\"\n+        def updatedFlow = flow.jacksonCopy().tap {\n+            it.source.portNumber = 10 // traffgen port\n+            it.source.vlanId = updatedFlowDstEndpoint.source.vlanId + 1\n+            it.destination.portNumber = 10 // traffgen port\n+            it.destination.vlanId = updatedFlowDstEndpoint.destination.vlanId + 1\n+        }\n+        flowHelperV2.updateFlow(flow.flowId, updatedFlow)\n+\n+        then: \"Flow is really updated\"\n+        with(northboundV2.getFlow(flow.flowId)) {\n+            it.source.portNumber == updatedFlow.source.portNumber\n+            it.source.vlanId == updatedFlow.source.vlanId\n+            it.destination.portNumber == updatedFlow.destination.portNumber\n+            it.destination.vlanId == updatedFlow.destination.vlanId\n+        }\n+\n+        and: \"Flow path is not rebuild\"\n+        Wrappers.timedLoop(rerouteDelay + WAIT_OFFSET / 2) {\n+            pathHelper.convert(northbound.getFlowPath(flow.flowId)) == currentPath\n+        }\n+\n+        and: \"Flow is valid\"\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"System allows traffic on the flow\"\n+        def traffExam = traffExamProvider.get()\n+        def examFlow = new FlowTrafficExamBuilder(topology, traffExam).buildBidirectionalExam(\n+                flowHelperV2.toV1(updatedFlow), 100, 5\n+        )\n+        withPool {\n+            [examFlow.forward, examFlow.reverse].eachParallel { direction ->\n+                def resources = traffExam.startExam(direction)\n+                direction.setResources(resources)\n+                assert traffExam.waitExam(direction).hasTraffic()\n+            }\n+        }\n+\n+        and: \"All involved switches pass switch validation\"\n+        withPool {\n+            currentPath*.switchId.eachParallel { SwitchId swId ->\n+                with(northbound.validateSwitch(swId)) { validation ->\n+                    validation.verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                    validation.verifyMeterSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+                }\n+            }\n+        }\n+        def involvedSwitchesPassSwValidation = true\n+\n+        cleanup: \"Revert system to original state\"\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        northbound.deleteLinkProps(northbound.getAllLinkProps())\n+        !involvedSwitchesPassSwValidation && currentPath*.switchId.each { SwitchId swId ->\n+            northbound.synchronizeSwitch(swId, true)\n+        }\n+        database.resetCosts()", "originalCommit": "b47ea2f257e0cfb2ef9371ab4557319acfad2dc3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMwNjg3NA==", "url": "https://github.com/telstra/open-kilda/pull/3739#discussion_r497306874", "bodyText": "you are right, it is needless\nallLinkProps are already deleted\nfixed", "author": "andriidovhan", "createdAt": "2020-09-30T07:45:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI4NTUyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI4NjAyNQ==", "url": "https://github.com/telstra/open-kilda/pull/3739#discussion_r497286025", "bodyText": "assert", "author": "rtretyak", "createdAt": "2020-09-30T07:06:10Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/QinQFlowSpec.groovy", "diffHunk": "@@ -885,4 +887,80 @@ class QinQFlowSpec extends HealthCheckSpecification {\n         cleanup:\n         flow && flowHelperV2.deleteFlow(flow.flowId)\n     }\n+\n+    @Tidy\n+    def \"System doesn't rebuild flow path to more preferable path while updating innerVlanId\"() {\n+        given: \"Two active switches connected to traffgens with two possible paths at least\"\n+        def allTraffgenSwitchIds = topology.activeTraffGens*.switchConnected*.dpId ?:\n+                assumeTrue(\"Should be at least two active traffgens connected to switches\", false)\n+        def switchPair = topologyHelper.getAllNeighboringSwitchPairs().find {\n+            [it.src, it.dst].every { sw ->\n+                sw.dpId in allTraffgenSwitchIds && northbound.getSwitchProperties(sw.dpId).multiTable\n+            } && it.paths.size() > 2\n+        } ?: assumeTrue(\"Not able to find enough switches with traffgens and in multi-table mode\", false)\n+\n+        and: \"A flow\"\n+        def flow = flowHelperV2.randomFlow(switchPair)\n+        flow.source.innerVlanId = flow.source.vlanId\n+        flow.destination.innerVlanId = flow.destination.vlanId\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Make the current path less preferable than alternatives\"\n+        def currentPath = pathHelper.convert(northbound.getFlowPath(flow.flowId))\n+        def alternativePaths = switchPair.paths.findAll { it != currentPath }\n+        alternativePaths.each { pathHelper.makePathMorePreferable(it, currentPath) }\n+\n+        and: \"Update the flow: port number and vlanId on the src/dst endpoints\"\n+        def updatedFlow = flow.jacksonCopy().tap {\n+            it.source.innerVlanId = flow.destination.vlanId\n+            it.destination.innerVlanId = flow.source.vlanId\n+        }\n+        flowHelperV2.updateFlow(flow.flowId, updatedFlow)\n+\n+        then: \"Flow is really updated\"\n+        with(northboundV2.getFlow(flow.flowId)) {\n+            it.source.innerVlanId == updatedFlow.source.innerVlanId\n+            it.destination.innerVlanId == updatedFlow.destination.innerVlanId\n+        }\n+\n+        and: \"Flow is not rerouted\"\n+        Wrappers.timedLoop(rerouteDelay + WAIT_OFFSET / 2) {\n+            pathHelper.convert(northbound.getFlowPath(flow.flowId)) == currentPath", "originalCommit": "b47ea2f257e0cfb2ef9371ab4557319acfad2dc3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMwNzYyMw==", "url": "https://github.com/telstra/open-kilda/pull/3739#discussion_r497307623", "bodyText": "fixed", "author": "andriidovhan", "createdAt": "2020-09-30T07:46:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI4NjAyNQ=="}], "type": "inlineReview"}, {"oid": "42619458dede441d7982a0601c90bdee83dc439d", "url": "https://github.com/telstra/open-kilda/commit/42619458dede441d7982a0601c90bdee83dc439d", "message": "add tests for #3728", "committedDate": "2020-09-30T07:48:10Z", "type": "forcePushed"}, {"oid": "13bd3526b2f013111f83862bd6a6c84f28197109", "url": "https://github.com/telstra/open-kilda/commit/13bd3526b2f013111f83862bd6a6c84f28197109", "message": "add tests for #3728", "committedDate": "2020-09-30T07:49:32Z", "type": "commit"}, {"oid": "13bd3526b2f013111f83862bd6a6c84f28197109", "url": "https://github.com/telstra/open-kilda/commit/13bd3526b2f013111f83862bd6a6c84f28197109", "message": "add tests for #3728", "committedDate": "2020-09-30T07:49:32Z", "type": "forcePushed"}]}