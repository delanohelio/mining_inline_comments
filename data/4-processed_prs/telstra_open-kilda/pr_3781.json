{"pr_number": 3781, "pr_title": "Add test that reveals #3780", "pr_createdAt": "2020-10-13T11:13:43Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3781", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQyOTM0Ng==", "url": "https://github.com/telstra/open-kilda/pull/3781#discussion_r505429346", "bodyText": "this test is ignored, do we really need to keep these lines as commented out?", "author": "andriidovhan", "createdAt": "2020-10-15T10:19:48Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/IslReplugSpec.groovy", "diffHunk": "@@ -220,4 +220,89 @@ class IslReplugSpec extends HealthCheckSpecification {\n         cleanup:\n         database.resetCosts()\n     }\n+\n+    @Ignore(\"https://github.com/telstra/open-kilda/issues/3780\")\n+    def \"User is able to replug ISL with enabled BFD, receive new ISL, enable bfd on it and replug back\"() {\n+        given: \"An ISL with BFD and ability to replug\"\n+        def isl = topology.islsForActiveSwitches.find { it.aswitch?.inPort && it.aswitch?.outPort &&\n+            [it.srcSwitch, it.dstSwitch].every { it.features.contains(SwitchFeature.BFD) } }\n+        assumeTrue(\"Require at least one BFD ISL\", isl as boolean)\n+        def notConnectedIsl = topology.notConnectedIsls.find { it.srcSwitch.features.contains(SwitchFeature.BFD) &&\n+                it.srcSwitch != isl.dstSwitch }\n+        assumeTrue(\"Require at least one 'not connected' ISL\", notConnectedIsl as boolean)\n+        northbound.setLinkBfd(islUtils.toLinkEnableBfd(isl, true))\n+        Wrappers.wait(WAIT_OFFSET) {\n+            [isl, isl.reversed].each {\n+                verifyAll(northbound.getLink(it)) {\n+                    it.enableBfd\n+                    it.bfdSessionStatus == \"up\"\n+                }\n+            }\n+        }\n+\n+        when: \"Replug a bfd-enabled link to some other free port\"\n+        def newIsl = islUtils.replug(isl, true, notConnectedIsl, true, true)\n+\n+        then: \"Old ISL becomes Moved, new ISL is discovered\"\n+        Wrappers.wait(discoveryExhaustedInterval + WAIT_OFFSET) {\n+            [isl, isl.reversed].each { assert northbound.getLink(it).state == MOVED }\n+            [newIsl, newIsl.reversed].each { assert northbound.getLink(it).state == DISCOVERED }\n+        }\n+\n+//        and: \"Bfd on Moved ISL reports 'down' status\"", "originalCommit": "672ca6386ff211e66397ff68a2b2db0f889100c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQzMTc4Nw==", "url": "https://github.com/telstra/open-kilda/pull/3781#discussion_r505431787", "bodyText": "how about combining these two wait into single?", "author": "andriidovhan", "createdAt": "2020-10-15T10:24:05Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/IslReplugSpec.groovy", "diffHunk": "@@ -220,4 +220,89 @@ class IslReplugSpec extends HealthCheckSpecification {\n         cleanup:\n         database.resetCosts()\n     }\n+\n+    @Ignore(\"https://github.com/telstra/open-kilda/issues/3780\")\n+    def \"User is able to replug ISL with enabled BFD, receive new ISL, enable bfd on it and replug back\"() {\n+        given: \"An ISL with BFD and ability to replug\"\n+        def isl = topology.islsForActiveSwitches.find { it.aswitch?.inPort && it.aswitch?.outPort &&\n+            [it.srcSwitch, it.dstSwitch].every { it.features.contains(SwitchFeature.BFD) } }\n+        assumeTrue(\"Require at least one BFD ISL\", isl as boolean)\n+        def notConnectedIsl = topology.notConnectedIsls.find { it.srcSwitch.features.contains(SwitchFeature.BFD) &&\n+                it.srcSwitch != isl.dstSwitch }\n+        assumeTrue(\"Require at least one 'not connected' ISL\", notConnectedIsl as boolean)\n+        northbound.setLinkBfd(islUtils.toLinkEnableBfd(isl, true))\n+        Wrappers.wait(WAIT_OFFSET) {\n+            [isl, isl.reversed].each {\n+                verifyAll(northbound.getLink(it)) {\n+                    it.enableBfd\n+                    it.bfdSessionStatus == \"up\"\n+                }\n+            }\n+        }\n+\n+        when: \"Replug a bfd-enabled link to some other free port\"\n+        def newIsl = islUtils.replug(isl, true, notConnectedIsl, true, true)\n+\n+        then: \"Old ISL becomes Moved, new ISL is discovered\"\n+        Wrappers.wait(discoveryExhaustedInterval + WAIT_OFFSET) {\n+            [isl, isl.reversed].each { assert northbound.getLink(it).state == MOVED }\n+            [newIsl, newIsl.reversed].each { assert northbound.getLink(it).state == DISCOVERED }\n+        }\n+\n+//        and: \"Bfd on Moved ISL reports 'down' status\"\n+//        [isl, isl.reversed].each {\n+//            verifyAll(northbound.getLink(it)) {\n+//                enableBfd\n+//                bfdSessionStatus == \"down\"\n+//            }\n+//        }\n+\n+        when: \"Turn on BFD for new ISL\"\n+        northbound.setLinkBfd(islUtils.toLinkEnableBfd(newIsl, true))\n+\n+        then: \"BFD is turned on according to getLink API\"\n+        Wrappers.wait(WAIT_OFFSET / 2) {\n+            [newIsl, newIsl.reversed].each {\n+                verifyAll(northbound.getLink(it)) {\n+                    it.enableBfd\n+                    it.bfdSessionStatus == \"up\"\n+                }\n+            }\n+        }\n+\n+        when: \"Replug a new link back where it was before\"\n+        def newOldIsl = islUtils.replug(newIsl, true, isl, true, true)\n+        verifyAll(newOldIsl) {\n+            it.srcSwitch == isl.srcSwitch\n+            it.dstSwitch == isl.dstSwitch\n+            it.srcPort == isl.srcPort\n+            it.dstPort == isl.dstPort\n+        }\n+\n+        then: \"Initial ISL becomes Discovered again, replugged ISL becomes Moved\"\n+        Wrappers.wait(discoveryExhaustedInterval + WAIT_OFFSET) {\n+            [newIsl, newIsl.reversed].each { assert northbound.getLink(it).state == MOVED } }\n+        Wrappers.wait(discoveryExhaustedInterval + WAIT_OFFSET) {", "originalCommit": "672ca6386ff211e66397ff68a2b2db0f889100c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQzMjA1MQ==", "url": "https://github.com/telstra/open-kilda/pull/3781#discussion_r505432051", "bodyText": "the same comment as in L252", "author": "andriidovhan", "createdAt": "2020-10-15T10:24:32Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/IslReplugSpec.groovy", "diffHunk": "@@ -220,4 +220,89 @@ class IslReplugSpec extends HealthCheckSpecification {\n         cleanup:\n         database.resetCosts()\n     }\n+\n+    @Ignore(\"https://github.com/telstra/open-kilda/issues/3780\")\n+    def \"User is able to replug ISL with enabled BFD, receive new ISL, enable bfd on it and replug back\"() {\n+        given: \"An ISL with BFD and ability to replug\"\n+        def isl = topology.islsForActiveSwitches.find { it.aswitch?.inPort && it.aswitch?.outPort &&\n+            [it.srcSwitch, it.dstSwitch].every { it.features.contains(SwitchFeature.BFD) } }\n+        assumeTrue(\"Require at least one BFD ISL\", isl as boolean)\n+        def notConnectedIsl = topology.notConnectedIsls.find { it.srcSwitch.features.contains(SwitchFeature.BFD) &&\n+                it.srcSwitch != isl.dstSwitch }\n+        assumeTrue(\"Require at least one 'not connected' ISL\", notConnectedIsl as boolean)\n+        northbound.setLinkBfd(islUtils.toLinkEnableBfd(isl, true))\n+        Wrappers.wait(WAIT_OFFSET) {\n+            [isl, isl.reversed].each {\n+                verifyAll(northbound.getLink(it)) {\n+                    it.enableBfd\n+                    it.bfdSessionStatus == \"up\"\n+                }\n+            }\n+        }\n+\n+        when: \"Replug a bfd-enabled link to some other free port\"\n+        def newIsl = islUtils.replug(isl, true, notConnectedIsl, true, true)\n+\n+        then: \"Old ISL becomes Moved, new ISL is discovered\"\n+        Wrappers.wait(discoveryExhaustedInterval + WAIT_OFFSET) {\n+            [isl, isl.reversed].each { assert northbound.getLink(it).state == MOVED }\n+            [newIsl, newIsl.reversed].each { assert northbound.getLink(it).state == DISCOVERED }\n+        }\n+\n+//        and: \"Bfd on Moved ISL reports 'down' status\"\n+//        [isl, isl.reversed].each {\n+//            verifyAll(northbound.getLink(it)) {\n+//                enableBfd\n+//                bfdSessionStatus == \"down\"\n+//            }\n+//        }\n+\n+        when: \"Turn on BFD for new ISL\"\n+        northbound.setLinkBfd(islUtils.toLinkEnableBfd(newIsl, true))\n+\n+        then: \"BFD is turned on according to getLink API\"\n+        Wrappers.wait(WAIT_OFFSET / 2) {\n+            [newIsl, newIsl.reversed].each {\n+                verifyAll(northbound.getLink(it)) {\n+                    it.enableBfd\n+                    it.bfdSessionStatus == \"up\"\n+                }\n+            }\n+        }\n+\n+        when: \"Replug a new link back where it was before\"\n+        def newOldIsl = islUtils.replug(newIsl, true, isl, true, true)\n+        verifyAll(newOldIsl) {\n+            it.srcSwitch == isl.srcSwitch\n+            it.dstSwitch == isl.dstSwitch\n+            it.srcPort == isl.srcPort\n+            it.dstPort == isl.dstPort\n+        }\n+\n+        then: \"Initial ISL becomes Discovered again, replugged ISL becomes Moved\"\n+        Wrappers.wait(discoveryExhaustedInterval + WAIT_OFFSET) {\n+            [newIsl, newIsl.reversed].each { assert northbound.getLink(it).state == MOVED } }\n+        Wrappers.wait(discoveryExhaustedInterval + WAIT_OFFSET) {\n+            [newOldIsl, newOldIsl.reversed].each { assert northbound.getLink(it).state == DISCOVERED }\n+        }\n+\n+//        and: \"Bfd on Moved ISL reports 'down' status\"", "originalCommit": "672ca6386ff211e66397ff68a2b2db0f889100c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTQzNDc4Mg==", "url": "https://github.com/telstra/open-kilda/pull/3781#discussion_r505434782", "bodyText": "please, disable bfd session", "author": "andriidovhan", "createdAt": "2020-10-15T10:29:04Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/links/IslReplugSpec.groovy", "diffHunk": "@@ -220,4 +220,89 @@ class IslReplugSpec extends HealthCheckSpecification {\n         cleanup:\n         database.resetCosts()\n     }\n+\n+    @Ignore(\"https://github.com/telstra/open-kilda/issues/3780\")\n+    def \"User is able to replug ISL with enabled BFD, receive new ISL, enable bfd on it and replug back\"() {\n+        given: \"An ISL with BFD and ability to replug\"\n+        def isl = topology.islsForActiveSwitches.find { it.aswitch?.inPort && it.aswitch?.outPort &&\n+            [it.srcSwitch, it.dstSwitch].every { it.features.contains(SwitchFeature.BFD) } }\n+        assumeTrue(\"Require at least one BFD ISL\", isl as boolean)\n+        def notConnectedIsl = topology.notConnectedIsls.find { it.srcSwitch.features.contains(SwitchFeature.BFD) &&\n+                it.srcSwitch != isl.dstSwitch }\n+        assumeTrue(\"Require at least one 'not connected' ISL\", notConnectedIsl as boolean)\n+        northbound.setLinkBfd(islUtils.toLinkEnableBfd(isl, true))\n+        Wrappers.wait(WAIT_OFFSET) {\n+            [isl, isl.reversed].each {\n+                verifyAll(northbound.getLink(it)) {\n+                    it.enableBfd\n+                    it.bfdSessionStatus == \"up\"\n+                }\n+            }\n+        }\n+\n+        when: \"Replug a bfd-enabled link to some other free port\"\n+        def newIsl = islUtils.replug(isl, true, notConnectedIsl, true, true)\n+\n+        then: \"Old ISL becomes Moved, new ISL is discovered\"\n+        Wrappers.wait(discoveryExhaustedInterval + WAIT_OFFSET) {\n+            [isl, isl.reversed].each { assert northbound.getLink(it).state == MOVED }\n+            [newIsl, newIsl.reversed].each { assert northbound.getLink(it).state == DISCOVERED }\n+        }\n+\n+//        and: \"Bfd on Moved ISL reports 'down' status\"\n+//        [isl, isl.reversed].each {\n+//            verifyAll(northbound.getLink(it)) {\n+//                enableBfd\n+//                bfdSessionStatus == \"down\"\n+//            }\n+//        }\n+\n+        when: \"Turn on BFD for new ISL\"\n+        northbound.setLinkBfd(islUtils.toLinkEnableBfd(newIsl, true))\n+\n+        then: \"BFD is turned on according to getLink API\"\n+        Wrappers.wait(WAIT_OFFSET / 2) {\n+            [newIsl, newIsl.reversed].each {\n+                verifyAll(northbound.getLink(it)) {\n+                    it.enableBfd\n+                    it.bfdSessionStatus == \"up\"\n+                }\n+            }\n+        }\n+\n+        when: \"Replug a new link back where it was before\"\n+        def newOldIsl = islUtils.replug(newIsl, true, isl, true, true)\n+        verifyAll(newOldIsl) {\n+            it.srcSwitch == isl.srcSwitch\n+            it.dstSwitch == isl.dstSwitch\n+            it.srcPort == isl.srcPort\n+            it.dstPort == isl.dstPort\n+        }\n+\n+        then: \"Initial ISL becomes Discovered again, replugged ISL becomes Moved\"\n+        Wrappers.wait(discoveryExhaustedInterval + WAIT_OFFSET) {\n+            [newIsl, newIsl.reversed].each { assert northbound.getLink(it).state == MOVED } }\n+        Wrappers.wait(discoveryExhaustedInterval + WAIT_OFFSET) {\n+            [newOldIsl, newOldIsl.reversed].each { assert northbound.getLink(it).state == DISCOVERED }\n+        }\n+\n+//        and: \"Bfd on Moved ISL reports 'down' status\"\n+//        [newIsl, newIsl.reversed].each {\n+//            verifyAll(northbound.getLink(it)) {\n+//                enableBfd\n+//                bfdSessionStatus == \"down\"\n+//            }\n+//        }\n+\n+        and: \"Bfd on Discovered ISL reports 'up' status\"\n+        [newOldIsl, newOldIsl.reversed].each {\n+            verifyAll(northbound.getLink(it)) {\n+                enableBfd\n+                bfdSessionStatus == \"up\"\n+            }\n+        }\n+\n+        cleanup: \"Removed Moved ISL\" //this cleanup is not comprehensive\n+        newIsl && northbound.deleteLink(islUtils.toLinkParameters(newIsl))", "originalCommit": "672ca6386ff211e66397ff68a2b2db0f889100c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8eb34a6781d0ac0facf7eab3e22b9873e9b1f222", "url": "https://github.com/telstra/open-kilda/commit/8eb34a6781d0ac0facf7eab3e22b9873e9b1f222", "message": "Add test that reveals #3780", "committedDate": "2020-10-30T11:55:33Z", "type": "commit"}, {"oid": "8eb34a6781d0ac0facf7eab3e22b9873e9b1f222", "url": "https://github.com/telstra/open-kilda/commit/8eb34a6781d0ac0facf7eab3e22b9873e9b1f222", "message": "Add test that reveals #3780", "committedDate": "2020-10-30T11:55:33Z", "type": "forcePushed"}]}