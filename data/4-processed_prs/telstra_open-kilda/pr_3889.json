{"pr_number": 3889, "pr_title": "add flowLoop tests for singleSwFlow", "pr_createdAt": "2020-11-30T14:08:42Z", "pr_url": "https://github.com/telstra/open-kilda/pull/3889", "timeline": [{"oid": "bad437a6096905b4c0c82a3d8ac7904615aa6e18", "url": "https://github.com/telstra/open-kilda/commit/bad437a6096905b4c0c82a3d8ac7904615aa6e18", "message": "add flowLoop tests for singleSwFlow", "committedDate": "2020-12-01T09:13:48Z", "type": "forcePushed"}, {"oid": "3b7474a1556620c99462c9ff63125ad12c2b9464", "url": "https://github.com/telstra/open-kilda/commit/3b7474a1556620c99462c9ff63125ad12c2b9464", "message": "add flowLoop tests for singleSwFlow", "committedDate": "2020-12-03T11:15:45Z", "type": "forcePushed"}, {"oid": "41a94a2639b845111bc03630a860b820d6bbbcf6", "url": "https://github.com/telstra/open-kilda/commit/41a94a2639b845111bc03630a860b820d6bbbcf6", "message": "add tests for flowLoop", "committedDate": "2020-12-07T18:10:49Z", "type": "commit"}, {"oid": "62aeb784e6bef351aba0235f267352b81de0676b", "url": "https://github.com/telstra/open-kilda/commit/62aeb784e6bef351aba0235f267352b81de0676b", "message": "unignore qinq and multiTable in flowLoopSpec", "committedDate": "2020-12-07T18:10:49Z", "type": "commit"}, {"oid": "4f4094319bcea79440b1a9de4f7df77d4f76312d", "url": "https://github.com/telstra/open-kilda/commit/4f4094319bcea79440b1a9de4f7df77d4f76312d", "message": "add flowLoop tests for singleSwFlow", "committedDate": "2020-12-07T18:10:49Z", "type": "commit"}, {"oid": "4f4094319bcea79440b1a9de4f7df77d4f76312d", "url": "https://github.com/telstra/open-kilda/commit/4f4094319bcea79440b1a9de4f7df77d4f76312d", "message": "add flowLoop tests for singleSwFlow", "committedDate": "2020-12-07T18:10:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTExMzczNw==", "url": "https://github.com/telstra/open-kilda/pull/3889#discussion_r539113737", "bodyText": "Tbh I still don't understand the point of this feature. Flow loop rule will be exactly the same as the actual flow rule", "author": "rtretyak", "createdAt": "2020-12-09T08:44:22Z", "path": "src-java/testing/functional-tests/src/test/groovy/org/openkilda/functionaltests/spec/flows/FlowLoopSpec.groovy", "diffHunk": "@@ -523,6 +523,108 @@ class FlowLoopSpec extends HealthCheckSpecification {\n         database.resetCosts()\n     }\n \n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Able to create flowLoop for a singleSwitch flow\"() {\n+        given: \"An active singleSwitch flow\"\n+        def sw = topology.activeSwitches.first()\n+        def flow = flowHelperV2.singleSwitchFlow(sw)\n+        flowHelperV2.addFlow(flow)\n+\n+        when: \"Create flowLoop on the sw switch\"\n+        def createResponse = northboundV2.createFlowLoop(flow.flowId, new FlowLoopPayload(sw.dpId))\n+\n+        then: \"Create flowLoop response contains flowId and src switchId\"\n+        assert createResponse.flowId == flow.flowId\n+        assert createResponse.switchId == sw.dpId\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"FlowLoop is really created on the switch\"\n+        def flowLoopOnSwitch = northboundV2.getFlowLoop(flow.flowId)\n+        flowLoopOnSwitch.size() == 1\n+        with(flowLoopOnSwitch[0]) {\n+            it.flowId == flow.flowId\n+            it.switchId == sw.dpId\n+        }\n+\n+        and: \"FlowLoop rules are created\"\n+        and: \"The switch is valid\"\n+        Wrappers.wait(RULES_INSTALLATION_TIME) {\n+            assert getFlowLoopRules(sw.dpId).size() == 2\n+            northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        }\n+\n+\n+        when: \"Delete flowLoop\"\n+        northboundV2.deleteFlowLoop(flow.flowId)\n+\n+        then: \"FlowLoop is deleted\"\n+        !northboundV2.getFlow(flow.flowId).loopSwitchId\n+\n+        and: \"FlowLoop rules are deleted from the switch\"\n+        assert getFlowLoopRules(sw.dpId).empty\n+\n+        and: \"Flow is UP and valid\"\n+        Wrappers.wait(WAIT_OFFSET) { assert northbound.getFlowStatus(flow.flowId).status == FlowState.UP }\n+        northbound.validateFlow(flow.flowId).each { direction -> assert direction.asExpected }\n+\n+        and: \"The switch is valid\"\n+        northbound.validateSwitch(sw.dpId).verifyRuleSectionsAreEmpty([\"missing\", \"excess\", \"misconfigured\"])\n+        def testIsCompleted = true\n+\n+        cleanup:\n+        flow && flowHelperV2.deleteFlow(flow.flowId)\n+        !testIsCompleted && northbound.synchronizeSwitch(sw.dpId, true)\n+    }\n+\n+    @Tidy\n+    @Tags(LOW_PRIORITY)\n+    def \"Able to create flowLoop for a singleSwitchSinglePort flow\"() {", "originalCommit": "4f4094319bcea79440b1a9de4f7df77d4f76312d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}