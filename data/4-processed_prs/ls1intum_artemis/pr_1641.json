{"pr_number": 1641, "pr_title": "[Exam] Exam management: Server routes with unified access check", "pr_createdAt": "2020-06-12T15:00:23Z", "pr_url": "https://github.com/ls1intum/Artemis/pull/1641", "timeline": [{"oid": "223505eac2c56392dd825390a638c662aeda88fd", "url": "https://github.com/ls1intum/Artemis/commit/223505eac2c56392dd825390a638c662aeda88fd", "message": "Add additional routes to ExamResource", "committedDate": "2020-06-11T00:09:12Z", "type": "commit"}, {"oid": "f16dcad73cfcf3ae40f13016e0387eb3edff0cd2", "url": "https://github.com/ls1intum/Artemis/commit/f16dcad73cfcf3ae40f13016e0387eb3edff0cd2", "message": "Add access check prototype methods", "committedDate": "2020-06-11T09:10:10Z", "type": "commit"}, {"oid": "691ac04cbfb3cf25b1985ba00b9b5984679d0fde", "url": "https://github.com/ls1intum/Artemis/commit/691ac04cbfb3cf25b1985ba00b9b5984679d0fde", "message": "Merge branch 'develop' into exam/management/server-routes", "committedDate": "2020-06-12T10:32:20Z", "type": "commit"}, {"oid": "e37bf44b36a1a32415c53a5b3698fe5280da8413", "url": "https://github.com/ls1intum/Artemis/commit/e37bf44b36a1a32415c53a5b3698fe5280da8413", "message": "Let isAtLeastInstructorInCourse() method retrieve the user", "committedDate": "2020-06-12T10:34:23Z", "type": "commit"}, {"oid": "05fcb54f56b3f734f49fb465b6fd31395ec5d2d2", "url": "https://github.com/ls1intum/Artemis/commit/05fcb54f56b3f734f49fb465b6fd31395ec5d2d2", "message": "Write to AuditLog on delete", "committedDate": "2020-06-12T10:39:10Z", "type": "commit"}, {"oid": "cfe349a2d7b16c0090ddf31c384852148e824e1a", "url": "https://github.com/ls1intum/Artemis/commit/cfe349a2d7b16c0090ddf31c384852148e824e1a", "message": "Retrieve exam from database after security checks are finished", "committedDate": "2020-06-12T10:54:36Z", "type": "commit"}, {"oid": "b0c6362bbc93a750230208a50707f6be5f131105", "url": "https://github.com/ls1intum/Artemis/commit/b0c6362bbc93a750230208a50707f6be5f131105", "message": "Move check methods to ExamService", "committedDate": "2020-06-12T11:14:45Z", "type": "commit"}, {"oid": "5550487f94495a140d447ee1463550947a4e7d3e", "url": "https://github.com/ls1intum/Artemis/commit/5550487f94495a140d447ee1463550947a4e7d3e", "message": "Improve ExamResource", "committedDate": "2020-06-12T13:01:54Z", "type": "commit"}, {"oid": "053a9a37f12eb0ac8fcd16186b20f268fd9fc797", "url": "https://github.com/ls1intum/Artemis/commit/053a9a37f12eb0ac8fcd16186b20f268fd9fc797", "message": "Create ExerciseGroupResource", "committedDate": "2020-06-12T14:09:02Z", "type": "commit"}, {"oid": "dbaa68c1e60556961bc79c1b1d508cb7b326175d", "url": "https://github.com/ls1intum/Artemis/commit/dbaa68c1e60556961bc79c1b1d508cb7b326175d", "message": "Create StudentExamResource", "committedDate": "2020-06-12T14:46:11Z", "type": "commit"}, {"oid": "a4b6445a6094a252abf73d3788dbb8e95a9cb50f", "url": "https://github.com/ls1intum/Artemis/commit/a4b6445a6094a252abf73d3788dbb8e95a9cb50f", "message": "Fix cyclic dependency", "committedDate": "2020-06-12T15:35:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc0NzE4NA==", "url": "https://github.com/ls1intum/Artemis/pull/1641#discussion_r439747184", "bodyText": "I don't think forbidden() is a good choice here. The user is allowed however the exam doesn't belong to the course.\nYou could either agrue with a \"notFound()\" here since you can't finde an exercise belonging to the course, maybe a HTTP 409 would be a good choice here?", "author": "julian-christl", "createdAt": "2020-06-13T15:28:50Z", "path": "src/main/java/de/tum/in/www1/artemis/service/ExamAccessService.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package de.tum.in.www1.artemis.service;\n+\n+import static de.tum.in.www1.artemis.web.rest.util.ResponseUtil.forbidden;\n+import static de.tum.in.www1.artemis.web.rest.util.ResponseUtil.notFound;\n+\n+import java.util.Optional;\n+\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.stereotype.Service;\n+\n+import de.tum.in.www1.artemis.domain.Course;\n+import de.tum.in.www1.artemis.domain.exam.Exam;\n+import de.tum.in.www1.artemis.repository.ExamRepository;\n+\n+/**\n+ * Service Implementation to check Exam access.\n+ */\n+@Service\n+public class ExamAccessService {\n+\n+    private final ExamRepository examRepository;\n+\n+    private final CourseService courseService;\n+\n+    private final AuthorizationCheckService authorizationCheckService;\n+\n+    public ExamAccessService(ExamRepository examRepository, CourseService courseService, AuthorizationCheckService authorizationCheckService) {\n+        this.examRepository = examRepository;\n+        this.courseService = courseService;\n+        this.authorizationCheckService = authorizationCheckService;\n+    }\n+\n+    /**\n+     * Checks if the current user is allowed to manage exams of the given course\n+     *\n+     * @param courseId  The id of the course\n+     * @param <T>       The type of the return type of the requesting route so that the response can be returned there\n+     * @return an optional with a typed ResponseEntity. If it is empty all checks passed\n+     */\n+    public <T> Optional<ResponseEntity<T>> checkCourseAccess(Long courseId) {\n+        Course course = courseService.findOne(courseId);\n+        if (!authorizationCheckService.isAtLeastInstructorInCourse(course, null)) {\n+            return Optional.of(forbidden());\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Checks if the current user is allowed to manage exams of the given course, that the exam exists and that the exam\n+     * belongs to the given course.\n+     *\n+     * @param courseId  The id of the course\n+     * @param examId    The id of the exam\n+     * @param <X>       The type of the return type of the requesting route so that the response can be returned there\n+     * @return an optional with a typed ResponseEntity. If it is empty all checks passed\n+     */\n+    public <X> Optional<ResponseEntity<X>> checkCourseAndExamAccess(Long courseId, Long examId) {\n+        Optional<ResponseEntity<X>> courseAccessFailure = checkCourseAccess(courseId);\n+        if (courseAccessFailure.isPresent()) {\n+            return courseAccessFailure;\n+        }\n+        Optional<Exam> exam = examRepository.findById(examId);\n+        if (exam.isEmpty()) {\n+            return Optional.of(notFound());\n+        }\n+        if (!exam.get().getCourse().getId().equals(courseId)) {\n+            return Optional.of(forbidden());", "originalCommit": "a4b6445a6094a252abf73d3788dbb8e95a9cb50f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3NTgwMg==", "url": "https://github.com/ls1intum/Artemis/pull/1641#discussion_r439775802", "bodyText": "I've added conflict() to ResponseUtil and applied it here.", "author": "sascha11110", "createdAt": "2020-06-13T22:53:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc0NzE4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc0NzI4OA==", "url": "https://github.com/ls1intum/Artemis/pull/1641#discussion_r439747288", "bodyText": "I don't think forbidden() is a good choice here. The user is allowed however the exam doesn't belong to the exercise group.\nYou could either agrue with a \"notFound()\" here since you can't finde an exercise belonging to the course, maybe a HTTP 409 would be a good choice here?", "author": "julian-christl", "createdAt": "2020-06-13T15:30:47Z", "path": "src/main/java/de/tum/in/www1/artemis/service/ExerciseGroupService.java", "diffHunk": "@@ -0,0 +1,107 @@\n+package de.tum.in.www1.artemis.service;\n+\n+import static de.tum.in.www1.artemis.web.rest.util.ResponseUtil.forbidden;\n+import static de.tum.in.www1.artemis.web.rest.util.ResponseUtil.notFound;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.validation.constraints.NotNull;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.stereotype.Service;\n+\n+import de.tum.in.www1.artemis.domain.exam.ExerciseGroup;\n+import de.tum.in.www1.artemis.repository.ExerciseGroupRepository;\n+import de.tum.in.www1.artemis.web.rest.errors.EntityNotFoundException;\n+\n+/**\n+ * Service Implementation for managing ExerciseGroup.\n+ */\n+@Service\n+public class ExerciseGroupService {\n+\n+    private final Logger log = LoggerFactory.getLogger(ExerciseGroupService.class);\n+\n+    private final ExerciseGroupRepository exerciseGroupRepository;\n+\n+    private final ExamAccessService examAccessService;\n+\n+    public ExerciseGroupService(ExerciseGroupRepository exerciseGroupRepository, ExamAccessService examAccessService) {\n+        this.exerciseGroupRepository = exerciseGroupRepository;\n+        this.examAccessService = examAccessService;\n+    }\n+\n+    /**\n+     * Save an exerciseGroup\n+     *\n+     * @param exerciseGroup the entity to save\n+     * @return the persisted entity\n+     */\n+    public ExerciseGroup save(ExerciseGroup exerciseGroup) {\n+        log.debug(\"Request to save exerciseGroup : {}\", exerciseGroup);\n+        return exerciseGroupRepository.save(exerciseGroup);\n+    }\n+\n+    /**\n+     * Get one exercise group by id.\n+     *\n+     * @param exerciseGroupId the id of the exercise group\n+     * @return the entity\n+     */\n+    @NotNull\n+    public ExerciseGroup findOne(Long exerciseGroupId) {\n+        log.debug(\"Request to get exercise group : {}\", exerciseGroupId);\n+        return exerciseGroupRepository.findById(exerciseGroupId)\n+                .orElseThrow(() -> new EntityNotFoundException(\"Exercise group with id \\\"\" + exerciseGroupId + \"\\\" does not exist\"));\n+    }\n+\n+    /**\n+     * Get all exercise groups for the given exam.\n+     *\n+     * @param examId the id of the exam\n+     * @return the list of all exercise groups\n+     */\n+    public List<ExerciseGroup> findAllByExamId(Long examId) {\n+        log.debug(\"REST request to get all exercise groups for Exam : {}\", examId);\n+        return exerciseGroupRepository.findByExamId(examId);\n+    }\n+\n+    /**\n+     * Delete the exercise group by id.\n+     *\n+     * @param exerciseGroupId the id of the entity\n+     */\n+    public void delete(Long exerciseGroupId) {\n+        log.debug(\"Request to delete exercise group : {}\", exerciseGroupId);\n+        exerciseGroupRepository.deleteById(exerciseGroupId);\n+    }\n+\n+    /**\n+     * Checks if the current user is allowed to manage exams of the given course, that the exam exists,\n+     * that the exam belongs to the given course and the exercise group belongs to the given exam.\n+     *\n+     * @param courseId          The id of the course\n+     * @param examId            The id of the exam\n+     * @param exerciseGroupId   The id of the exercise group\n+     * @param <X>               The type of the return type of the requesting route so that the\n+     *                          response can be returned there\n+     * @return an Optional with a typed ResponseEntity. If it is empty all checks passed\n+     */\n+    public <X> Optional<ResponseEntity<X>> checkCourseAndExamAndExerciseGroupAccess(Long courseId, Long examId, Long exerciseGroupId) {\n+        Optional<ResponseEntity<X>> courseAndExamAccessFailure = examAccessService.checkCourseAndExamAccess(courseId, examId);\n+        if (courseAndExamAccessFailure.isPresent()) {\n+            return courseAndExamAccessFailure;\n+        }\n+        Optional<ExerciseGroup> exerciseGroup = exerciseGroupRepository.findById(exerciseGroupId);\n+        if (exerciseGroup.isEmpty()) {\n+            return Optional.of(notFound());\n+        }\n+        if (!exerciseGroup.get().getExam().getId().equals(examId)) {\n+            return Optional.of(forbidden());", "originalCommit": "a4b6445a6094a252abf73d3788dbb8e95a9cb50f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3NTc1Mg==", "url": "https://github.com/ls1intum/Artemis/pull/1641#discussion_r439775752", "bodyText": "I've added conflict() to ResponseUtil and applied it here.", "author": "sascha11110", "createdAt": "2020-06-13T22:52:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc0NzI4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc0NzM2MA==", "url": "https://github.com/ls1intum/Artemis/pull/1641#discussion_r439747360", "bodyText": "I don't think forbidden() is a good choice here. The user is allowed however the student exam doesn't belong to the exam.\nYou could either agrue with a \"notFound()\" here since you can't finde an exercise belonging to the course, maybe a HTTP 409 would be a good choice here?", "author": "julian-christl", "createdAt": "2020-06-13T15:31:52Z", "path": "src/main/java/de/tum/in/www1/artemis/service/StudentExamService.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package de.tum.in.www1.artemis.service;\n+\n+import static de.tum.in.www1.artemis.web.rest.util.ResponseUtil.forbidden;\n+import static de.tum.in.www1.artemis.web.rest.util.ResponseUtil.notFound;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.validation.constraints.NotNull;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.stereotype.Service;\n+\n+import de.tum.in.www1.artemis.domain.exam.StudentExam;\n+import de.tum.in.www1.artemis.repository.StudentExamRepository;\n+import de.tum.in.www1.artemis.web.rest.errors.EntityNotFoundException;\n+\n+/**\n+ * Service Implementation for managing StudentExam.\n+ */\n+@Service\n+public class StudentExamService {\n+\n+    private final Logger log = LoggerFactory.getLogger(StudentExamService.class);\n+\n+    private final StudentExamRepository studentExamRepository;\n+\n+    private final ExamAccessService examAccessService;\n+\n+    public StudentExamService(StudentExamRepository studentExamRepository, ExamAccessService examAccessService) {\n+        this.studentExamRepository = studentExamRepository;\n+        this.examAccessService = examAccessService;\n+    }\n+\n+    /**\n+     * Get one student exam by id.\n+     *\n+     * @param studentExamId the id of the student exam\n+     * @return the entity\n+     */\n+    @NotNull\n+    public StudentExam findOne(Long studentExamId) {\n+        log.debug(\"Request to get student exam : {}\", studentExamId);\n+        return studentExamRepository.findById(studentExamId).orElseThrow(() -> new EntityNotFoundException(\"Student exam with id \\\"\" + studentExamId + \"\\\" does not exist\"));\n+    }\n+\n+    /**\n+     * Get all student exams for the given exam.\n+     *\n+     * @param examId the id of the exam\n+     * @return the list of all student exams\n+     */\n+    public List<StudentExam> findAllByExamId(Long examId) {\n+        log.debug(\"REST request to get all student exams for Exam : {}\", examId);\n+        return studentExamRepository.findByExamId(examId);\n+    }\n+\n+    /**\n+     * Checks if the current user is allowed to manage exams of the given course, that the exam exists,\n+     * that the exam belongs to the given course and the student exam belongs to the given exam.\n+     *\n+     * @param courseId      The id of the course\n+     * @param examId        The id of the exam\n+     * @param studentExamId The if of the student exam\n+     * @param <X>           The type of the return type of the requesting route so that the\n+     *      *               response can be returned there\n+     * @return an Optional with a typed ResponseEntity. If it is empty all checks passed\n+     */\n+    public <X> Optional<ResponseEntity<X>> checkCourseAndExamAndStudentExamAccess(Long courseId, Long examId, Long studentExamId) {\n+        Optional<ResponseEntity<X>> courseAndExamAccessFailure = examAccessService.checkCourseAndExamAccess(courseId, examId);\n+        if (courseAndExamAccessFailure.isPresent()) {\n+            return courseAndExamAccessFailure;\n+        }\n+        Optional<StudentExam> studentExam = studentExamRepository.findById(studentExamId);\n+        if (studentExam.isEmpty()) {\n+            return Optional.of(notFound());\n+        }\n+        if (!studentExam.get().getExam().getId().equals(examId)) {\n+            return Optional.of(forbidden());", "originalCommit": "a4b6445a6094a252abf73d3788dbb8e95a9cb50f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3NTc0Nw==", "url": "https://github.com/ls1intum/Artemis/pull/1641#discussion_r439775747", "bodyText": "I've added conflict() to ResponseUtil and applied it here.", "author": "sascha11110", "createdAt": "2020-06-13T22:52:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc0NzM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc0NzYyNg==", "url": "https://github.com/ls1intum/Artemis/pull/1641#discussion_r439747626", "bodyText": "Can't this be simplified?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Exam exam = examService.findOne(examId);\n          \n          \n            \n                    return courseAndExamAccessFailure.orElseGet(() -> ResponseEntity.ok(exam));\n          \n          \n            \n                    return courseAndExamAccessFailure.orElseGet(() -> ResponseEntity.ok(examService.findOne(examId)));", "author": "julian-christl", "createdAt": "2020-06-13T15:35:32Z", "path": "src/main/java/de/tum/in/www1/artemis/web/rest/ExamResource.java", "diffHunk": "@@ -104,18 +94,71 @@ public ExamResource(UserService userService, CourseService courseService, ExamSe\n             return createExam(courseId, updatedExam);\n         }\n \n-        User user = userService.getUserWithGroupsAndAuthorities();\n-        Course course = courseService.findOne(courseId);\n-        if (!authCheckService.isAtLeastInstructorInCourse(course, user)) {\n-            return forbidden();\n-        }\n-\n-        Optional<Exam> existingExam = examRepository.findById(updatedExam.getId());\n-        if (existingExam.isEmpty()) {\n-            return ResponseEntity.notFound().build();\n+        Optional<ResponseEntity<Exam>> courseAndExamAccessFailure = examAccessService.checkCourseAndExamAccess(courseId, updatedExam.getId());\n+        if (courseAndExamAccessFailure.isPresent()) {\n+            return courseAndExamAccessFailure.get();\n         }\n \n         Exam result = examService.save(updatedExam);\n         return ResponseEntity.ok().headers(HeaderUtil.createEntityUpdateAlert(applicationName, true, ENTITY_NAME, result.getTitle())).body(result);\n     }\n+\n+    /**\n+     * GET /courses/{courseId}/exams/{examId} : Find an exam by id.\n+     *\n+     * @param courseId  the course to which the exam belongs\n+     * @param examId    the exam to find\n+     * @return the ResponseEntity with status 200 (OK) and with the found exam as body\n+     */\n+    @GetMapping(\"/courses/{courseId}/exams/{examId}\")\n+    @PreAuthorize(\"hasAnyRole('ADMIN', 'INSTRUCTOR')\")\n+    public ResponseEntity<Exam> getExam(@PathVariable Long courseId, @PathVariable Long examId) {\n+        log.debug(\"REST request to get exam : {}\", examId);\n+        Optional<ResponseEntity<Exam>> courseAndExamAccessFailure = examAccessService.checkCourseAndExamAccess(courseId, examId);\n+        Exam exam = examService.findOne(examId);\n+        return courseAndExamAccessFailure.orElseGet(() -> ResponseEntity.ok(exam));", "originalCommit": "a4b6445a6094a252abf73d3788dbb8e95a9cb50f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc0Nzg1Mg==", "url": "https://github.com/ls1intum/Artemis/pull/1641#discussion_r439747852", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ExerciseGroup exerciseGroup = exerciseGroupService.findOne(exerciseGroupId);\n          \n          \n            \n                    return accessFailure.orElseGet(() -> ResponseEntity.ok(exerciseGroup));\n          \n          \n            \n                    return accessFailure.orElseGet(() -> ResponseEntity.ok(exerciseGroupService.findOne(exerciseGroupId)));", "author": "julian-christl", "createdAt": "2020-06-13T15:39:20Z", "path": "src/main/java/de/tum/in/www1/artemis/web/rest/ExerciseGroupResource.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package de.tum.in.www1.artemis.web.rest;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.boot.actuate.audit.AuditEvent;\n+import org.springframework.boot.actuate.audit.AuditEventRepository;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.web.bind.annotation.*;\n+\n+import de.tum.in.www1.artemis.config.Constants;\n+import de.tum.in.www1.artemis.domain.User;\n+import de.tum.in.www1.artemis.domain.exam.ExerciseGroup;\n+import de.tum.in.www1.artemis.service.ExamAccessService;\n+import de.tum.in.www1.artemis.service.ExerciseGroupService;\n+import de.tum.in.www1.artemis.service.UserService;\n+import de.tum.in.www1.artemis.web.rest.errors.BadRequestAlertException;\n+import de.tum.in.www1.artemis.web.rest.util.HeaderUtil;\n+\n+/**\n+ * REST controller for managing ExerciseGroup.\n+ */\n+@RestController\n+@RequestMapping(\"/api\")\n+public class ExerciseGroupResource {\n+\n+    private final Logger log = LoggerFactory.getLogger(ExerciseGroupResource.class);\n+\n+    private static final String ENTITY_NAME = \"exerciseGroup\";\n+\n+    @Value(\"${jhipster.clientApp.name}\")\n+    private String applicationName;\n+\n+    private final ExerciseGroupService exerciseGroupService;\n+\n+    private final ExamAccessService examAccessService;\n+\n+    private final UserService userService;\n+\n+    private final AuditEventRepository auditEventRepository;\n+\n+    public ExerciseGroupResource(ExerciseGroupService exerciseGroupService, ExamAccessService examAccessService, UserService userService,\n+            AuditEventRepository auditEventRepository) {\n+        this.exerciseGroupService = exerciseGroupService;\n+        this.examAccessService = examAccessService;\n+        this.userService = userService;\n+        this.auditEventRepository = auditEventRepository;\n+    }\n+\n+    /**\n+     * POST /courses/{courseId}/exams/{examId}/exerciseGroups : Create a new exercise group.\n+     *\n+     * @param courseId      the course to which the exercise group belongs to\n+     * @param examId        the exam to which the exercise group belongs to\n+     * @param exerciseGroup the exercise group to create\n+     * @return the ResponseEntity with status 201 (Created) and with the new exerciseGroup as body,\n+     *         or with status 400 (Bad Request) if the exerciseGroup has already an ID\n+     * @throws URISyntaxException if the Location URI syntax is incorrect\n+     */\n+    @PostMapping(\"/courses/{courseId}/exams/{examId}/exerciseGroups\")\n+    @PreAuthorize(\"hasAnyRole('ADMIN', 'INSTRUCTOR')\")\n+    public ResponseEntity<ExerciseGroup> createExerciseGroup(@PathVariable Long courseId, @PathVariable Long examId, @RequestBody ExerciseGroup exerciseGroup)\n+            throws URISyntaxException {\n+        log.debug(\"REST request to create an exercise group : {}\", exerciseGroup);\n+        if (exerciseGroup.getId() != null) {\n+            throw new BadRequestAlertException(\"A new exerciseGroup cannot already have an ID\", ENTITY_NAME, \"idexists\");\n+        }\n+\n+        Optional<ResponseEntity<ExerciseGroup>> courseAndExamAccessFailure = examAccessService.checkCourseAndExamAccess(courseId, examId);\n+        if (courseAndExamAccessFailure.isPresent()) {\n+            return courseAndExamAccessFailure.get();\n+        }\n+\n+        ExerciseGroup savedExerciseGroup = exerciseGroupService.save(exerciseGroup);\n+        return ResponseEntity.created(new URI(\"/api/courses/\" + courseId + \"/exams/\" + examId + \"/exerciseGroups/\" + savedExerciseGroup.getId()))\n+                .headers(HeaderUtil.createEntityCreationAlert(applicationName, true, ENTITY_NAME, savedExerciseGroup.getTitle())).body(savedExerciseGroup);\n+    }\n+\n+    /**\n+     * PUT /courses/{courseId}/exams/{examId}/exerciseGroups : Update an existing exercise group.\n+     *\n+     * @param courseId              the course to which the exercise group belongs to\n+     * @param examId                the exam to which the exercise group belongs to\n+     * @param updatedExerciseGroup  the exercise group to update\n+     * @return the ResponseEntity with status 200 (OK) and with the body of the updated exercise group\n+     * @throws URISyntaxException if the Location URI syntax is incorrect\n+     */\n+    @PutMapping(\"/courses/{courseId}/exams/{examId}/exerciseGroups\")\n+    @PreAuthorize(\"hasAnyRole('ADMIN', 'INSTRUCTOR')\")\n+    public ResponseEntity<ExerciseGroup> updateExerciseGroup(@PathVariable Long courseId, @PathVariable Long examId, @RequestBody ExerciseGroup updatedExerciseGroup)\n+            throws URISyntaxException {\n+        log.debug(\"REST request to update an exercise group : {}\", updatedExerciseGroup);\n+        if (updatedExerciseGroup.getId() == null) {\n+            return createExerciseGroup(courseId, examId, updatedExerciseGroup);\n+        }\n+\n+        Optional<ResponseEntity<ExerciseGroup>> accessFailure = exerciseGroupService.checkCourseAndExamAndExerciseGroupAccess(courseId, examId, updatedExerciseGroup.getId());\n+        if (accessFailure.isPresent()) {\n+            return accessFailure.get();\n+        }\n+\n+        ExerciseGroup result = exerciseGroupService.save(updatedExerciseGroup);\n+        return ResponseEntity.ok().headers(HeaderUtil.createEntityUpdateAlert(applicationName, true, ENTITY_NAME, result.getTitle())).body(result);\n+    }\n+\n+    /**\n+     * GET /courses/{courseId}/exams/{examId}/exerciseGroups/{exerciseGroupId} : Find an exercise group by id.\n+     *\n+     * @param courseId          the course to which the exercise group belongs to\n+     * @param examId            the exam to which the exercise group belongs to\n+     * @param exerciseGroupId   the id of the exercise group to find\n+     * @return the ResponseEntity with status 200 (OK) and with the found exercise group as body\n+     */\n+    @GetMapping(\"/courses/{courseId}/exams/{examId}/exerciseGroups/{exerciseGroupId}\")\n+    @PreAuthorize(\"hasAnyRole('ADMIN', 'INSTRUCTOR')\")\n+    public ResponseEntity<ExerciseGroup> getExerciseGroup(@PathVariable Long courseId, @PathVariable Long examId, @PathVariable Long exerciseGroupId) {\n+        log.debug(\"REST request to get exercise group : {}\", exerciseGroupId);\n+        Optional<ResponseEntity<ExerciseGroup>> accessFailure = exerciseGroupService.checkCourseAndExamAndExerciseGroupAccess(courseId, examId, exerciseGroupId);\n+        ExerciseGroup exerciseGroup = exerciseGroupService.findOne(exerciseGroupId);\n+        return accessFailure.orElseGet(() -> ResponseEntity.ok(exerciseGroup));", "originalCommit": "a4b6445a6094a252abf73d3788dbb8e95a9cb50f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc0Nzk1MA==", "url": "https://github.com/ls1intum/Artemis/pull/1641#discussion_r439747950", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    StudentExam studentExam = studentExamService.findOne(studentExamId);\n          \n          \n            \n                    return accessFailure.orElseGet(() -> ResponseEntity.ok(studentExam));\n          \n          \n            \n                    return accessFailure.orElseGet(() -> ResponseEntity.ok(studentExamService.findOne(studentExamId)));", "author": "julian-christl", "createdAt": "2020-06-13T15:40:44Z", "path": "src/main/java/de/tum/in/www1/artemis/web/rest/StudentExamResource.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package de.tum.in.www1.artemis.web.rest;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.PathVariable;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import de.tum.in.www1.artemis.domain.exam.StudentExam;\n+import de.tum.in.www1.artemis.service.ExamAccessService;\n+import de.tum.in.www1.artemis.service.StudentExamService;\n+\n+/**\n+ * REST controller for managing ExerciseGroup.\n+ */\n+@RestController\n+@RequestMapping(\"/api\")\n+public class StudentExamResource {\n+\n+    private final Logger log = LoggerFactory.getLogger(StudentExamResource.class);\n+\n+    private final ExamAccessService examAccessService;\n+\n+    private final StudentExamService studentExamService;\n+\n+    public StudentExamResource(ExamAccessService examAccessService, StudentExamService studentExamService) {\n+        this.examAccessService = examAccessService;\n+        this.studentExamService = studentExamService;\n+    }\n+\n+    /**\n+     * GET /courses/{courseId}/exams/{examId}/studentExams/{studentExamId} : Find a student exam by id.\n+     *\n+     * @param courseId      the course to which the student exam belongs to\n+     * @param examId        the exam to which the student exam belongs to\n+     * @param studentExamId the id of the student exam to find\n+     * @return the ResponseEntity with status 200 (OK) and with the found student exam as body\n+     */\n+    @GetMapping(\"/courses/{courseId}/exams/{examId}/studentExams/{studentExamId}\")\n+    @PreAuthorize(\"hasAnyRole('ADMIN', 'INSTRUCTOR')\")\n+    public ResponseEntity<StudentExam> getStudentExam(@PathVariable Long courseId, @PathVariable Long examId, @PathVariable Long studentExamId) {\n+        log.debug(\"REST request to get student exam : {}\", studentExamId);\n+        Optional<ResponseEntity<StudentExam>> accessFailure = studentExamService.checkCourseAndExamAndStudentExamAccess(courseId, examId, studentExamId);\n+        StudentExam studentExam = studentExamService.findOne(studentExamId);\n+        return accessFailure.orElseGet(() -> ResponseEntity.ok(studentExam));", "originalCommit": "a4b6445a6094a252abf73d3788dbb8e95a9cb50f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bbf5879122b00a59e073d621f8cb33d7ef99c8cf", "url": "https://github.com/ls1intum/Artemis/commit/bbf5879122b00a59e073d621f8cb33d7ef99c8cf", "message": "Make sure that exam is not null", "committedDate": "2020-06-13T22:43:06Z", "type": "commit"}, {"oid": "76c588e74b3b56369c0b06da116c2e96332f5b69", "url": "https://github.com/ls1intum/Artemis/commit/76c588e74b3b56369c0b06da116c2e96332f5b69", "message": "Address change requests", "committedDate": "2020-06-13T22:53:15Z", "type": "commit"}, {"oid": "8a36eb86117da147752a63ea9df9b48a509966ea", "url": "https://github.com/ls1intum/Artemis/commit/8a36eb86117da147752a63ea9df9b48a509966ea", "message": "Test ExamAccessService", "committedDate": "2020-06-13T23:55:06Z", "type": "commit"}, {"oid": "1a406dc3b367fb7a1737b9e86c458559e9091866", "url": "https://github.com/ls1intum/Artemis/commit/1a406dc3b367fb7a1737b9e86c458559e9091866", "message": "Move all access check methods to ExamAccessService", "committedDate": "2020-06-14T00:02:39Z", "type": "commit"}, {"oid": "60b9917975f39742c2cea5e75b690f86468c39e9", "url": "https://github.com/ls1intum/Artemis/commit/60b9917975f39742c2cea5e75b690f86468c39e9", "message": "Test checkCourseAndExamAndExerciseGroupAccess and checkCourseAndExamAndStudentExamAccess", "committedDate": "2020-06-14T00:33:08Z", "type": "commit"}, {"oid": "1956209e0e025ae2c1374d0375f98bfd54ca1de1", "url": "https://github.com/ls1intum/Artemis/commit/1956209e0e025ae2c1374d0375f98bfd54ca1de1", "message": "Add StudentExamIntegrationTest", "committedDate": "2020-06-14T11:08:33Z", "type": "commit"}, {"oid": "9abff16d1c5318ed95cd189858cfc1e5e5fa8d74", "url": "https://github.com/ls1intum/Artemis/commit/9abff16d1c5318ed95cd189858cfc1e5e5fa8d74", "message": "Refactor StudentExamIntegrationTest", "committedDate": "2020-06-14T11:54:46Z", "type": "commit"}, {"oid": "e87579f9bc90d4395510249ac907f199641fc89c", "url": "https://github.com/ls1intum/Artemis/commit/e87579f9bc90d4395510249ac907f199641fc89c", "message": "Add ExerciseGroupIntegrationTest", "committedDate": "2020-06-14T12:50:46Z", "type": "commit"}, {"oid": "ea47de25fdcf1c9c5650013a22a1ab620099f094", "url": "https://github.com/ls1intum/Artemis/commit/ea47de25fdcf1c9c5650013a22a1ab620099f094", "message": "Add tests to ExamIntegrationTest", "committedDate": "2020-06-14T13:25:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgzMzk0Nw==", "url": "https://github.com/ls1intum/Artemis/pull/1641#discussion_r439833947", "bodyText": "Should exam here actually have a course? I mean the courseid is already defined through the path variable, isn't it?\nIf the issue would be that the provided entity is wrong you should consider HTTP 422 Unprocessable Entity\nIf considering, adapt tests as well.", "author": "julian-christl", "createdAt": "2020-06-14T14:11:22Z", "path": "src/main/java/de/tum/in/www1/artemis/web/rest/ExamResource.java", "diffHunk": "@@ -68,6 +70,10 @@ public ExamResource(UserService userService, ExamService examService, ExamAccess\n             throw new BadRequestAlertException(\"A new exam cannot already have an ID\", ENTITY_NAME, \"idexists\");\n         }\n \n+        if (exam.getCourse() == null) {", "originalCommit": "ea47de25fdcf1c9c5650013a22a1ab620099f094", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0MDgzMQ==", "url": "https://github.com/ls1intum/Artemis/pull/1641#discussion_r439840831", "bodyText": "Yeah it should have a course, otherwise we have to set the course manually before we do examService.save(exam). Still, it's good that you commented here. We should check if the course of the delivered exam matches the courseId in the route as we check if the user is at least instructor in the course with courseId. I will adapt that.", "author": "sascha11110", "createdAt": "2020-06-14T15:27:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgzMzk0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0MTE5Ng==", "url": "https://github.com/ls1intum/Artemis/pull/1641#discussion_r439841196", "bodyText": "Addition: I think I will stick with conflict as HTTP status here as we do not interpret the status in the client and I don't want to introduce too many new status to the project.", "author": "sascha11110", "createdAt": "2020-06-14T15:31:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgzMzk0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0ODQxOA==", "url": "https://github.com/ls1intum/Artemis/pull/1641#discussion_r439848418", "bodyText": "To be honest I think that's bad design. There are standards for a reason and using non fitting statuses can make it hard for e.g. new developers as well.\nHowever I don't what to fixiate on this, if it's not handled clientside it's not a breaking issue and you can resolve these comments if you like.", "author": "julian-christl", "createdAt": "2020-06-14T16:54:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgzMzk0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgzNDEwMw==", "url": "https://github.com/ls1intum/Artemis/pull/1641#discussion_r439834103", "bodyText": "Should exam here actually have a course? I mean the courseid is already defined through the path variable, isn't it?\nIf the issue would be that the provided entity is wrong you should consider HTTP 422 Unprocessable Entity\nIf considering, adapt tests as well.", "author": "julian-christl", "createdAt": "2020-06-14T14:13:15Z", "path": "src/main/java/de/tum/in/www1/artemis/web/rest/ExamResource.java", "diffHunk": "@@ -94,6 +100,10 @@ public ExamResource(UserService userService, ExamService examService, ExamAccess\n             return createExam(courseId, updatedExam);\n         }\n \n+        if (updatedExam.getCourse() == null) {", "originalCommit": "ea47de25fdcf1c9c5650013a22a1ab620099f094", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0MDk1Ng==", "url": "https://github.com/ls1intum/Artemis/pull/1641#discussion_r439840956", "bodyText": "From comment above:\n\nYeah it should have a course, otherwise we have to set the course manually before we do examService.save(exam). Still, it's good that you commented here. We should check if the course of the delivered exam matches the courseId in the route as we check if the user is at least instructor in the course with courseId. I will adapt that.\n\nHere it makes even more sense to check for the course as the client receives the exam object with the course and the client will send the updated exam back.", "author": "sascha11110", "createdAt": "2020-06-14T15:28:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgzNDEwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgzNDI1Nw==", "url": "https://github.com/ls1intum/Artemis/pull/1641#discussion_r439834257", "bodyText": "Shouldn't a tutor be able to view a exam to a course in order to reach the Assessment Dashboard?", "author": "julian-christl", "createdAt": "2020-06-14T14:15:02Z", "path": "src/test/java/de/tum/in/www1/artemis/ExamIntegrationTest.java", "diffHunk": "@@ -160,4 +176,67 @@ public void testSaveExamToDatabase() throws Exception {\n         assertThat(savedStudentExam.getExercises().get(1)).isEqualTo(studentExam.getExercises().get(1));\n         assertThat(savedStudentExam.getExercises().get(2)).isEqualTo(studentExam.getExercises().get(2));\n     }\n+\n+    @Test\n+    @WithMockUser(username = \"student1\", roles = \"USER\")\n+    public void testAll_asStudent() throws Exception {\n+        this.testAllPreAuthorize();\n+    }\n+\n+    @Test\n+    @WithMockUser(username = \"tutor1\", roles = \"TA\")\n+    public void testAll_asTutor() throws Exception {\n+        this.testAllPreAuthorize();\n+    }\n+\n+    private void testAllPreAuthorize() throws Exception {\n+        Exam exam = ModelFactory.generateExam(course);\n+        request.post(\"/api/courses/\" + course.getId() + \"/exams\", exam, HttpStatus.FORBIDDEN);\n+        request.put(\"/api/courses/\" + course.getId() + \"/exams\", exam, HttpStatus.FORBIDDEN);\n+        request.get(\"/api/courses/\" + course.getId() + \"/exams/\" + exam1.getId(), HttpStatus.FORBIDDEN, Exam.class);", "originalCommit": "ea47de25fdcf1c9c5650013a22a1ab620099f094", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0MTYxNQ==", "url": "https://github.com/ls1intum/Artemis/pull/1641#discussion_r439841615", "bodyText": "At the moment I would limit the access as much as possible and open the routes only for users / roles that really need access. As more features are developed, the developer can decide which routes to open for his purposes. It is also possible that we will separate the calls to the student exams for the management and for the students.", "author": "sascha11110", "createdAt": "2020-06-14T15:35:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgzNDI1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgzNDQzNw==", "url": "https://github.com/ls1intum/Artemis/pull/1641#discussion_r439834437", "bodyText": "Do we have a better naming for this to show what the purpose of this attribute is?", "author": "julian-christl", "createdAt": "2020-06-14T14:16:53Z", "path": "src/test/java/de/tum/in/www1/artemis/ExamIntegrationTest.java", "diffHunk": "@@ -54,14 +64,20 @@\n     @Autowired\n     TextExerciseRepository textExerciseRepository;\n \n+    @SpyBean\n+    ExamAccessService examAccessService;\n+\n     private List<User> users;\n \n     private Course course;\n \n+    private Exam exam1;", "originalCommit": "ea47de25fdcf1c9c5650013a22a1ab620099f094", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0MTg0NQ==", "url": "https://github.com/ls1intum/Artemis/pull/1641#discussion_r439841845", "bodyText": "I will rename course to course1. I think it is a good practice to number related objects equally (the idea is that the course of exam1 is course1...).", "author": "sascha11110", "createdAt": "2020-06-14T15:37:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgzNDQzNw=="}], "type": "inlineReview"}, {"oid": "2b2b58ddb45cdd5e51647072ff7445eef21bfff9", "url": "https://github.com/ls1intum/Artemis/commit/2b2b58ddb45cdd5e51647072ff7445eef21bfff9", "message": "Rename course", "committedDate": "2020-06-14T15:43:19Z", "type": "commit"}, {"oid": "db18778556f08e4e7f867e877700ce6d02f2c553", "url": "https://github.com/ls1intum/Artemis/commit/db18778556f08e4e7f867e877700ce6d02f2c553", "message": "Check if the delivered course matches the courseId in the route", "committedDate": "2020-06-14T16:01:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0OTQzMg==", "url": "https://github.com/ls1intum/Artemis/pull/1641#discussion_r439849432", "bodyText": "We don't need the @query here, as the method name should suffice.\nSee https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods", "author": "kloessst", "createdAt": "2020-06-14T17:07:41Z", "path": "src/main/java/de/tum/in/www1/artemis/repository/ExamRepository.java", "diffHunk": "@@ -16,5 +16,5 @@\n public interface ExamRepository extends JpaRepository<Exam, Long> {\n \n     @Query(\"SELECT e FROM Exam e WHERE e.course.id = :#{#courseId}\")", "originalCommit": "db18778556f08e4e7f867e877700ce6d02f2c553", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0OTQ5Nw==", "url": "https://github.com/ls1intum/Artemis/pull/1641#discussion_r439849497", "bodyText": "We don't need the @query here, as the method name should suffice.\nSee https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods", "author": "kloessst", "createdAt": "2020-06-14T17:08:54Z", "path": "src/main/java/de/tum/in/www1/artemis/repository/ExerciseGroupRepository.java", "diffHunk": "@@ -15,6 +16,9 @@\n @Repository\n public interface ExerciseGroupRepository extends JpaRepository<ExerciseGroup, Long> {\n \n+    @Query(\"SELECT e FROM ExerciseGroup e WHERE e.exam.id = :#{#examId}\")", "originalCommit": "db18778556f08e4e7f867e877700ce6d02f2c553", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0OTUzMQ==", "url": "https://github.com/ls1intum/Artemis/pull/1641#discussion_r439849531", "bodyText": "We don't need the @query here, as the method name should suffice.\nSee https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods", "author": "kloessst", "createdAt": "2020-06-14T17:09:31Z", "path": "src/main/java/de/tum/in/www1/artemis/repository/StudentExamRepository.java", "diffHunk": "@@ -10,4 +14,7 @@\n  */\n @Repository\n public interface StudentExamRepository extends JpaRepository<StudentExam, Long> {\n+\n+    @Query(\"SELECT s FROM StudentExam s WHERE s.exam.id = :#{#examId}\")", "originalCommit": "db18778556f08e4e7f867e877700ce6d02f2c553", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "532b8a7706e71938a93416b99ab6b392d6abb78b", "url": "https://github.com/ls1intum/Artemis/commit/532b8a7706e71938a93416b99ab6b392d6abb78b", "message": "Remove unnecessary query annotations", "committedDate": "2020-06-14T17:58:31Z", "type": "commit"}, {"oid": "fb7ac56da90d047e3a140dc45f20e0059012cf51", "url": "https://github.com/ls1intum/Artemis/commit/fb7ac56da90d047e3a140dc45f20e0059012cf51", "message": "Remove unnecessary param annotation", "committedDate": "2020-06-14T18:07:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg2MzI4Nw==", "url": "https://github.com/ls1intum/Artemis/pull/1641#discussion_r439863287", "bodyText": "I don't think this will work, if there already are exercises connected with the exercise group.\nYou would first need to delete the exercises properly. Looking into deleteCourse, the following code should work.\n        for (Exercise exercise : exerciseGroup.getExercises()) {\n            exerciseService.delete(exercise.getId(), false, false);\n        }\n\nThis would mean that you need to load the exerciseGroup above \"withExercises()\"\nI suggest we change this in a follow-up PR and add a server integration test case to cover this case!", "author": "krusche", "createdAt": "2020-06-14T20:08:12Z", "path": "src/main/java/de/tum/in/www1/artemis/web/rest/ExerciseGroupResource.java", "diffHunk": "@@ -0,0 +1,182 @@\n+package de.tum.in.www1.artemis.web.rest;\n+\n+import static de.tum.in.www1.artemis.web.rest.util.ResponseUtil.conflict;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.boot.actuate.audit.AuditEvent;\n+import org.springframework.boot.actuate.audit.AuditEventRepository;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.security.access.prepost.PreAuthorize;\n+import org.springframework.web.bind.annotation.*;\n+\n+import de.tum.in.www1.artemis.config.Constants;\n+import de.tum.in.www1.artemis.domain.User;\n+import de.tum.in.www1.artemis.domain.exam.ExerciseGroup;\n+import de.tum.in.www1.artemis.service.ExamAccessService;\n+import de.tum.in.www1.artemis.service.ExerciseGroupService;\n+import de.tum.in.www1.artemis.service.UserService;\n+import de.tum.in.www1.artemis.web.rest.errors.BadRequestAlertException;\n+import de.tum.in.www1.artemis.web.rest.util.HeaderUtil;\n+\n+/**\n+ * REST controller for managing ExerciseGroup.\n+ */\n+@RestController\n+@RequestMapping(\"/api\")\n+public class ExerciseGroupResource {\n+\n+    private final Logger log = LoggerFactory.getLogger(ExerciseGroupResource.class);\n+\n+    private static final String ENTITY_NAME = \"exerciseGroup\";\n+\n+    @Value(\"${jhipster.clientApp.name}\")\n+    private String applicationName;\n+\n+    private final ExerciseGroupService exerciseGroupService;\n+\n+    private final ExamAccessService examAccessService;\n+\n+    private final UserService userService;\n+\n+    private final AuditEventRepository auditEventRepository;\n+\n+    public ExerciseGroupResource(ExerciseGroupService exerciseGroupService, ExamAccessService examAccessService, UserService userService,\n+            AuditEventRepository auditEventRepository) {\n+        this.exerciseGroupService = exerciseGroupService;\n+        this.examAccessService = examAccessService;\n+        this.userService = userService;\n+        this.auditEventRepository = auditEventRepository;\n+    }\n+\n+    /**\n+     * POST /courses/{courseId}/exams/{examId}/exerciseGroups : Create a new exercise group.\n+     *\n+     * @param courseId      the course to which the exercise group belongs to\n+     * @param examId        the exam to which the exercise group belongs to\n+     * @param exerciseGroup the exercise group to create\n+     * @return the ResponseEntity with status 201 (Created) and with the new exerciseGroup as body,\n+     *         or with status 400 (Bad Request) if the exerciseGroup has already an ID\n+     * @throws URISyntaxException if the Location URI syntax is incorrect\n+     */\n+    @PostMapping(\"/courses/{courseId}/exams/{examId}/exerciseGroups\")\n+    @PreAuthorize(\"hasAnyRole('ADMIN', 'INSTRUCTOR')\")\n+    public ResponseEntity<ExerciseGroup> createExerciseGroup(@PathVariable Long courseId, @PathVariable Long examId, @RequestBody ExerciseGroup exerciseGroup)\n+            throws URISyntaxException {\n+        log.debug(\"REST request to create an exercise group : {}\", exerciseGroup);\n+        if (exerciseGroup.getId() != null) {\n+            throw new BadRequestAlertException(\"A new exerciseGroup cannot already have an ID\", ENTITY_NAME, \"idexists\");\n+        }\n+\n+        if (exerciseGroup.getExam() == null) {\n+            return conflict();\n+        }\n+\n+        Optional<ResponseEntity<ExerciseGroup>> courseAndExamAccessFailure = examAccessService.checkCourseAndExamAccess(courseId, examId);\n+        if (courseAndExamAccessFailure.isPresent()) {\n+            return courseAndExamAccessFailure.get();\n+        }\n+\n+        ExerciseGroup savedExerciseGroup = exerciseGroupService.save(exerciseGroup);\n+        return ResponseEntity.created(new URI(\"/api/courses/\" + courseId + \"/exams/\" + examId + \"/exerciseGroups/\" + savedExerciseGroup.getId()))\n+                .headers(HeaderUtil.createEntityCreationAlert(applicationName, true, ENTITY_NAME, savedExerciseGroup.getTitle())).body(savedExerciseGroup);\n+    }\n+\n+    /**\n+     * PUT /courses/{courseId}/exams/{examId}/exerciseGroups : Update an existing exercise group.\n+     *\n+     * @param courseId              the course to which the exercise group belongs to\n+     * @param examId                the exam to which the exercise group belongs to\n+     * @param updatedExerciseGroup  the exercise group to update\n+     * @return the ResponseEntity with status 200 (OK) and with the body of the updated exercise group\n+     * @throws URISyntaxException if the Location URI syntax is incorrect\n+     */\n+    @PutMapping(\"/courses/{courseId}/exams/{examId}/exerciseGroups\")\n+    @PreAuthorize(\"hasAnyRole('ADMIN', 'INSTRUCTOR')\")\n+    public ResponseEntity<ExerciseGroup> updateExerciseGroup(@PathVariable Long courseId, @PathVariable Long examId, @RequestBody ExerciseGroup updatedExerciseGroup)\n+            throws URISyntaxException {\n+        log.debug(\"REST request to update an exercise group : {}\", updatedExerciseGroup);\n+        if (updatedExerciseGroup.getId() == null) {\n+            return createExerciseGroup(courseId, examId, updatedExerciseGroup);\n+        }\n+\n+        if (updatedExerciseGroup.getExam() == null) {\n+            return conflict();\n+        }\n+\n+        Optional<ResponseEntity<ExerciseGroup>> accessFailure = examAccessService.checkCourseAndExamAndExerciseGroupAccess(courseId, examId, updatedExerciseGroup.getId());\n+        if (accessFailure.isPresent()) {\n+            return accessFailure.get();\n+        }\n+\n+        ExerciseGroup result = exerciseGroupService.save(updatedExerciseGroup);\n+        return ResponseEntity.ok().headers(HeaderUtil.createEntityUpdateAlert(applicationName, true, ENTITY_NAME, result.getTitle())).body(result);\n+    }\n+\n+    /**\n+     * GET /courses/{courseId}/exams/{examId}/exerciseGroups/{exerciseGroupId} : Find an exercise group by id.\n+     *\n+     * @param courseId          the course to which the exercise group belongs to\n+     * @param examId            the exam to which the exercise group belongs to\n+     * @param exerciseGroupId   the id of the exercise group to find\n+     * @return the ResponseEntity with status 200 (OK) and with the found exercise group as body\n+     */\n+    @GetMapping(\"/courses/{courseId}/exams/{examId}/exerciseGroups/{exerciseGroupId}\")\n+    @PreAuthorize(\"hasAnyRole('ADMIN', 'INSTRUCTOR')\")\n+    public ResponseEntity<ExerciseGroup> getExerciseGroup(@PathVariable Long courseId, @PathVariable Long examId, @PathVariable Long exerciseGroupId) {\n+        log.debug(\"REST request to get exercise group : {}\", exerciseGroupId);\n+        Optional<ResponseEntity<ExerciseGroup>> accessFailure = examAccessService.checkCourseAndExamAndExerciseGroupAccess(courseId, examId, exerciseGroupId);\n+        return accessFailure.orElseGet(() -> ResponseEntity.ok(exerciseGroupService.findOne(exerciseGroupId)));\n+    }\n+\n+    /**\n+     * GET courses/{courseId}/exams/{examId}/exerciseGroups : Get all exercise groups of the given exam\n+     *\n+     * @param courseId  the course to which the exercise groups belong to\n+     * @param examId    the exam to which the exercise groups belong to\n+     * @return the ResponseEntity with status 200 (OK) and a list of exercise groups. The list can be empty\n+     */\n+    @GetMapping(\"courses/{courseId}/exams/{examId}/exerciseGroups\")\n+    @PreAuthorize(\"hasAnyRole('ADMIN', 'INSTRUCTOR')\")\n+    public ResponseEntity<List<ExerciseGroup>> getExerciseGroupsForExam(@PathVariable Long courseId, @PathVariable Long examId) {\n+        log.debug(\"REST request to get all exercise groups for exam : {}\", examId);\n+        Optional<ResponseEntity<List<ExerciseGroup>>> courseAndExamAccessFailure = examAccessService.checkCourseAndExamAccess(courseId, examId);\n+        return courseAndExamAccessFailure.orElseGet(() -> ResponseEntity.ok(exerciseGroupService.findAllByExamId(examId)));\n+    }\n+\n+    /**\n+     * DELETE /courses/{courseId}/exams/{examId}/exerciseGroups/{exerciseGroupId} : Delete the exercise group with the given id.\n+     *\n+     * @param courseId          the course to which the exercise group belongs to\n+     * @param examId            the exam to which the exercise group belongs to\n+     * @param exerciseGroupId   the id of the exercise group to delete\n+     * @return the ResponseEntity with status 200 (OK)\n+     */\n+    @DeleteMapping(\"/courses/{courseId}/exams/{examId}/exerciseGroups/{exerciseGroupId}\")\n+    @PreAuthorize(\"hasAnyRole('ADMIN', 'INSTRUCTOR')\")\n+    public ResponseEntity<Void> deleteExerciseGroup(@PathVariable Long courseId, @PathVariable Long examId, @PathVariable Long exerciseGroupId) {\n+        log.info(\"REST request to delete exercise group : {}\", exerciseGroupId);\n+\n+        Optional<ResponseEntity<Void>> accessFailure = examAccessService.checkCourseAndExamAndExerciseGroupAccess(courseId, examId, exerciseGroupId);\n+        if (accessFailure.isPresent()) {\n+            return accessFailure.get();\n+        }\n+\n+        ExerciseGroup exerciseGroup = exerciseGroupService.findOne(exerciseGroupId);\n+\n+        User user = userService.getUser();\n+        AuditEvent auditEvent = new AuditEvent(user.getLogin(), Constants.DELETE_EXERCISE_GROUP, \"exerciseGroup=\" + exerciseGroup.getTitle());\n+        auditEventRepository.add(auditEvent);\n+        log.info(\"User \" + user.getLogin() + \" has requested to delete the exercise group {}\", exerciseGroup.getTitle());\n+\n+        exerciseGroupService.delete(exerciseGroupId);", "originalCommit": "fb7ac56da90d047e3a140dc45f20e0059012cf51", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}