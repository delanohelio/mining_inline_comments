{"pr_number": 2715, "pr_title": "[DROOLS-4922] LinkageError: attempted duplicate class definition for \u2026", "pr_createdAt": "2020-01-10T08:35:10Z", "pr_url": "https://github.com/kiegroup/drools/pull/2715", "timeline": [{"oid": "91c47382fae7bf5097a38a86e674b93168e13b0d", "url": "https://github.com/kiegroup/drools/commit/91c47382fae7bf5097a38a86e674b93168e13b0d", "message": "[DROOLS-4922] LinkageError: attempted duplicate class definition for materialized Lambda during incremental compilation", "committedDate": "2020-01-15T07:06:08Z", "type": "forcePushed"}, {"oid": "bf39f645c3610190045d43c08a5dcc8e481c5a83", "url": "https://github.com/kiegroup/drools/commit/bf39f645c3610190045d43c08a5dcc8e481c5a83", "message": "[DROOLS-4922] LinkageError: attempted duplicate class definition for materialized Lambda during incremental compilation", "committedDate": "2020-01-17T03:39:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc2Mjg3NQ==", "url": "https://github.com/kiegroup/drools/pull/2715#discussion_r367762875", "bodyText": "Detect the case where rules are the same (= lambda expressions are the same) but lambda class class names are different (= whole lambda class source codes are different). In this case, I set ChangeType.MERGE. To compile, you need to apply this change to droolsjbpm-knowledge repo.\nhttps://gist.github.com/tkobayas/9dadafbdc2f87beb9127c079bd8f8c57", "author": "tkobayas", "createdAt": "2020-01-17T04:18:46Z", "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/CanonicalKieModule.java", "diffHunk": "@@ -543,6 +544,11 @@ private void addModifiedItemsToChangeSet( ResourceChangeSet mainChangeSet, Map<S\n             if ( compare == 0 ) {\n                 if ( !areEqualInModel( currentOld, currentNew ) ) {\n                     registerChange( mainChangeSet, changes, type, ChangeType.UPDATED, currentOld );\n+                } else {\n+                    // Considered as equal in model. It means LambdaHash are equal. So now check class name hash\n+                    if (currentOld instanceof RuleImpl && RuleImpl.areDifferentInLambdaClassNameHash( (RuleImpl)currentOld, (RuleImpl)currentNew )) {\n+                        registerChange( mainChangeSet, changes, type, ChangeType.MERGE, currentOld );", "originalCommit": "bf39f645c3610190045d43c08a5dcc8e481c5a83", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc2MzI5OA==", "url": "https://github.com/kiegroup/drools/pull/2715#discussion_r367763298", "bodyText": "This method only checks LambdaConsequnece for now. If this is the right approach, I would need to check LambdaPredicate and LambdaExtractor as well.", "author": "tkobayas", "createdAt": "2020-01-17T04:20:35Z", "path": "drools-model/drools-canonical-model/src/main/java/org/drools/model/impl/RuleImpl.java", "diffHunk": "@@ -125,4 +126,17 @@ public boolean isEqualTo( ModelComponent o ) {\n     public String toString() {\n         return \"Rule: \" +  pkg + \".\" + name + \" (view: \" + view + \", consequences: \" + consequences + \")\";\n     }\n+\n+    public static boolean areDifferentInLambdaClassNameHash(RuleImpl o1, RuleImpl o2) {\n+        System.out.println(\"areDifferentInLambdaClassNameHash : \" + o1.getName());\n+        String consequenceName1 = ((IntrospectableLambda) o1.getDefaultConsequence().getBlock()).getLambda().getClass().getName();\n+        String consequenceName2 = ((IntrospectableLambda) o2.getDefaultConsequence().getBlock()).getLambda().getClass().getName();\n+        System.out.println(\"  consequenceName1 = \" + consequenceName1);\n+        System.out.println(\"  consequenceName2 = \" + consequenceName2);\n+        if (!consequenceName1.equals(consequenceName2)) {\n+            System.out.println(\"  Different!!!\");\n+            return true;", "originalCommit": "bf39f645c3610190045d43c08a5dcc8e481c5a83", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc2MzY1MA==", "url": "https://github.com/kiegroup/drools/pull/2715#discussion_r367763650", "bodyText": "This method only replaces LambdaConsequnece for now. If this is the right approach, I would need to replace LambdaPredicate and LambdaExtractor as well. I'm not sure how much work will be required though (and there are any side effects).", "author": "tkobayas", "createdAt": "2020-01-17T04:22:47Z", "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/CanonicalKieBaseUpdater.java", "diffHunk": "@@ -188,6 +199,12 @@ public void run() {\n         }\n     }\n \n+    private void mergeRuleWithLambda(RuleImpl oldRule, RuleImpl newRule) {\n+        Consequence newConsequence = newRule.getConsequence();\n+        oldRule.setConsequence(newConsequence);\n+        System.out.println(\"mergeRuleWithLambda!!\");", "originalCommit": "bf39f645c3610190045d43c08a5dcc8e481c5a83", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc2NDA3MA==", "url": "https://github.com/kiegroup/drools/pull/2715#discussion_r367764070", "bodyText": "I added a public static final field \"EXPRESSION_HASH\" to validate the equality of materialized Lambda. This field is used in LambdaIntrospector.", "author": "tkobayas", "createdAt": "2020-01-17T04:25:27Z", "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/MaterializedLambda.java", "diffHunk": "@@ -107,10 +114,13 @@ void setMethodParameter(MethodDeclaration methodDeclaration) {\n     }\n \n     private EnumDeclaration create(CompilationUnit compilationUnit) {\n-        EnumDeclaration lambdaClass = compilationUnit.addEnum(className);\n+        EnumDeclaration lambdaClass = compilationUnit.addEnum(temporaryClassName);\n         lambdaClass.addAnnotation(org.drools.compiler.kie.builder.MaterializedLambda.class.getCanonicalName());\n         lambdaClass.setImplementedTypes(createImplementedType());\n         lambdaClass.addEntry(new EnumConstantDeclaration(\"INSTANCE\"));\n+\n+        lambdaClass.addFieldWithInitializer(String.class, \"EXPRESSION_HASH\", StaticJavaParser.parseExpression(\"\\\"\" + (md5Hash(lambdaExpr.toString())) + \"\\\"\"),\n+                                            Modifier.Keyword.PUBLIC, Modifier.Keyword.STATIC, Modifier.Keyword.FINAL);", "originalCommit": "bf39f645c3610190045d43c08a5dcc8e481c5a83", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "078bc1168bebbf35bada21f031463983b211065e", "url": "https://github.com/kiegroup/drools/commit/078bc1168bebbf35bada21f031463983b211065e", "message": "[DROOLS-4922] LinkageError: attempted duplicate class definition for materialized Lambda during incremental compilation", "committedDate": "2020-01-30T04:43:23Z", "type": "forcePushed"}, {"oid": "1c6d0f20ec0a4cc3f482cddd19021ca42043088c", "url": "https://github.com/kiegroup/drools/commit/1c6d0f20ec0a4cc3f482cddd19021ca42043088c", "message": "[DROOLS-4922] LinkageError: attempted duplicate class definition for materialized Lambda during incremental compilation", "committedDate": "2020-01-30T14:19:18Z", "type": "commit"}, {"oid": "1c6d0f20ec0a4cc3f482cddd19021ca42043088c", "url": "https://github.com/kiegroup/drools/commit/1c6d0f20ec0a4cc3f482cddd19021ca42043088c", "message": "[DROOLS-4922] LinkageError: attempted duplicate class definition for materialized Lambda during incremental compilation", "committedDate": "2020-01-30T14:19:18Z", "type": "forcePushed"}]}