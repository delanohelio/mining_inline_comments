{"pr_number": 3173, "pr_title": "DROOLS-5741 DMN internal refactors utilities for DROOLS-5670", "pr_createdAt": "2020-10-19T15:48:27Z", "pr_url": "https://github.com/kiegroup/drools/pull/3173", "timeline": [{"oid": "4f1da319c29e80f2888e088e9ccccbac8eea39ab", "url": "https://github.com/kiegroup/drools/commit/4f1da319c29e80f2888e088e9ccccbac8eea39ab", "message": "DROOLS-5741 DMN internal refactors utilities for DROOLS-5670", "committedDate": "2020-10-19T15:47:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODMwOTE1Nw==", "url": "https://github.com/kiegroup/drools/pull/3173#discussion_r508309157", "bodyText": "Very minor: is there any reason why you're explicitly creating the iterator instead of using a plain for-loop? I find this a bit harder to read.", "author": "mariofusco", "createdAt": "2020-10-20T08:29:47Z", "path": "kie-dmn/kie-dmn-core/src/main/java/org/kie/dmn/core/internal/utils/DynamicDMNContextBuilder.java", "diffHunk": "@@ -106,71 +92,88 @@ public DMNContext populateContextForDecisionServiceWith(String decisionServiceNa\n         return context;\n     }\n \n-    private Object recurseAsType(Object value, DMNType resultType) {\n+    private void processInputDataNode(Entry<String, Object> kv, InputDataNode idn) {\n+        nameStack.push(new NameAndDMNType(kv.getKey(), idn.getType()));\n+        Object recursed = recurseType(kv.getValue(), idn.getType());\n+        context.set(kv.getKey(), recursed);\n+        nameStack.pop();\n+    }\n+\n+    private void processDecisionNode(Entry<String, Object> kv, DecisionNode dn) {\n+        nameStack.push(new NameAndDMNType(kv.getKey(), dn.getResultType()));\n+        Object recursed = recurseType(kv.getValue(), dn.getResultType());\n+        context.set(kv.getKey(), recursed);\n+        nameStack.pop();\n+    }\n+\n+    private Object recurseType(Object value, DMNType resultType) {\n         if (resultType == null) {\n             debugStack();\n             LOG.debug(\"unknown type, and passing as-is\");\n             return value;\n         } else if (DMNTypeUtils.isFEELBuiltInType(resultType)) {\n             return getAsFEELBuiltinType(value, resultType);\n-        } else {\n-            if (resultType.isCollection()) {\n-                if (value instanceof Iterable<?>) {\n-                    List<Object> results = new ArrayList<>();\n-                    Iterable<?> iterable = (Iterable<?>) value;\n-                    Iterator<?> it = iterable.iterator();\n-                    while (it.hasNext()) {\n-                        Object next = it.next();\n-                        Object recursed = recurseAsType(next, resultType.getBaseType());\n-                        results.add(recursed);\n-                    }\n-                    return results;\n+        } else if (resultType.isCollection()) {\n+            return recurseCollection(value, resultType);\n+        } else if (resultType instanceof CompositeTypeImpl) {\n+            return recurseComposite(value, (CompositeTypeImpl) resultType);\n+        } else if (resultType instanceof SimpleTypeImpl) {\n+            return recurseType(value, resultType.getBaseType());\n+        }\n+        debugStack();\n+        LOG.debug(\"unknown case for type {} and passing as-is\", resultType);\n+        return value;\n+    }\n+\n+    private Object recurseComposite(Object value, CompositeTypeImpl compositeType) {\n+        if (value instanceof Map) {\n+            Map<String, Object> results = new HashMap<>();\n+            @SuppressWarnings(\"unchecked\")\n+            Map<String, Object> valueMap = (Map<String, Object>) value;\n+            for (Entry<String, Object> kv : valueMap.entrySet()) {\n+                if (compositeType.getFields().containsKey(kv.getKey())) {\n+                    DMNType keyType = compositeType.getFields().get(kv.getKey());\n+                    nameStack.push(new NameAndDMNType(kv.getKey(), keyType));\n+                    Object recursed = recurseType(kv.getValue(), keyType);\n+                    results.put(kv.getKey(), recursed);\n+                    nameStack.pop();\n                 } else {\n+                    nameStack.push(new NameAndDMNType(kv.getKey(), null));\n                     debugStack();\n-                    LOG.debug(\"The type {} has DMN-isCollection set, but the current value is not Iterable, passing as-is\", resultType);\n-                    return value;\n+                    LOG.debug(\"undefined type for key {} in {}, passing as-is\", kv.getKey(), compositeType);\n+                    results.put(kv.getKey(), kv.getValue());\n+                    nameStack.pop();\n                 }\n-            } else {\n-                if (resultType instanceof CompositeTypeImpl) {\n-                    CompositeTypeImpl compositeType = (CompositeTypeImpl) resultType;\n-                    if (value instanceof Map) {\n-                        Map<String, Object> results = new HashMap<>();\n-                        @SuppressWarnings(\"unchecked\")\n-                        Map<String, Object> valueMap = (Map<String, Object>) value;\n-                        for (Entry<String, Object> kv : valueMap.entrySet()) {\n-                            if (compositeType.getFields().containsKey(kv.getKey())) {\n-                                DMNType keyType = compositeType.getFields().get(kv.getKey());\n-                                nameStack.push(new NameAndDMNType(kv.getKey(), keyType));\n-                                Object recursed = recurseAsType(kv.getValue(), keyType);\n-                                results.put(kv.getKey(), recursed);\n-                                nameStack.pop();\n-                            } else {\n-                                nameStack.push(new NameAndDMNType(kv.getKey(), null));\n-                                debugStack();\n-                                LOG.debug(\"undefined type for key {} in {}, passing as-is\", kv.getKey(), compositeType);\n-                                results.put(kv.getKey(), kv.getValue());\n-                                nameStack.pop();\n-                            }\n-                        }\n-                        for (String k : compositeType.getFields().keySet()) {\n-                            if (!results.containsKey(k)) {\n-                                results.put(k, null);\n-                            }\n-                        }\n-                        return results;\n-                    } else {\n-                        debugStack();\n-                        LOG.debug(\"The type {} is a composite type, but the current value is not a Map, passing as-is\", resultType);\n-                        return value;\n-                    }\n-                } else if (resultType instanceof SimpleTypeImpl) {\n-                    return recurseAsType(value, resultType.getBaseType());\n+            }\n+            for (String k : compositeType.getFields().keySet()) {\n+                if (!results.containsKey(k)) {\n+                    results.put(k, null);\n                 }\n             }\n+            return results;\n+        } else {\n+            debugStack();\n+            LOG.debug(\"The type {} is a composite type, but the current value is not a Map, passing as-is\", compositeType);\n+            return value;\n+        }\n+    }\n+\n+    private Object recurseCollection(Object value, DMNType resultType) {\n+        if (value instanceof Iterable<?>) {\n+            List<Object> results = new ArrayList<>();\n+            Iterable<?> iterable = (Iterable<?>) value;\n+            Iterator<?> it = iterable.iterator();\n+            while (it.hasNext()) {", "originalCommit": "4f1da319c29e80f2888e088e9ccccbac8eea39ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dd1e61549512d719a0a0d0990bea66147ce7cd6d", "url": "https://github.com/kiegroup/drools/commit/dd1e61549512d719a0a0d0990bea66147ce7cd6d", "message": "implement code review feedback", "committedDate": "2020-10-20T10:28:28Z", "type": "commit"}]}