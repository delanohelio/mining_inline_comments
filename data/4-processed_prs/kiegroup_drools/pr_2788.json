{"pr_number": 2788, "pr_title": "[DROOLS-4956] Normarize rule constraints for property reactivity and \u2026", "pr_createdAt": "2020-02-26T08:18:30Z", "pr_url": "https://github.com/kiegroup/drools/pull/2788", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM1NjM4Ng==", "url": "https://github.com/kiegroup/drools/pull/2788#discussion_r384356386", "bodyText": "I like how everything related to this logic is in just one class", "author": "lucamolteni", "createdAt": "2020-02-26T09:05:42Z", "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/ConstraintUtil.java", "diffHunk": "@@ -0,0 +1,149 @@\n+package org.drools.modelcompiler.builder.generator;\n+\n+import java.util.Optional;\n+\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import org.drools.model.Index.ConstraintType;\n+import org.drools.modelcompiler.builder.generator.drlxparse.DrlxParseResult;\n+import org.drools.modelcompiler.builder.generator.drlxparse.SingleDrlxParseSuccess;\n+import org.drools.modelcompiler.builder.generator.visitor.pattern.PatternConstraintParseResult;\n+import org.drools.modelcompiler.util.EvaluationUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.drools.modelcompiler.builder.generator.DrlxParseUtil.THIS_PLACEHOLDER;\n+\n+public class ConstraintUtil {", "originalCommit": "ac9da977df36f5d3f3f646b6173b0cef1670e5d0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM1NzM4Mg==", "url": "https://github.com/kiegroup/drools/pull/2788#discussion_r384357382", "bodyText": "Please double check the inversion because I'm not sure but maybe > gets inverted to \u2264 and < to \u2265 (greater than => less than equal) (less than => greater than equal)", "author": "lucamolteni", "createdAt": "2020-02-26T09:07:39Z", "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/ConstraintUtil.java", "diffHunk": "@@ -0,0 +1,149 @@\n+package org.drools.modelcompiler.builder.generator;\n+\n+import java.util.Optional;\n+\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import org.drools.model.Index.ConstraintType;\n+import org.drools.modelcompiler.builder.generator.drlxparse.DrlxParseResult;\n+import org.drools.modelcompiler.builder.generator.drlxparse.SingleDrlxParseSuccess;\n+import org.drools.modelcompiler.builder.generator.visitor.pattern.PatternConstraintParseResult;\n+import org.drools.modelcompiler.util.EvaluationUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.drools.modelcompiler.builder.generator.DrlxParseUtil.THIS_PLACEHOLDER;\n+\n+public class ConstraintUtil {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(ConstraintUtil.class);\n+\n+    private static final String METHOD_PREFIX = EvaluationUtil.class.getCanonicalName() + \".\";\n+\n+    public static final String DROOLS_NORMALIZE_CONSTRAINT = \"drools.normalize.constraint\";\n+\n+    private static boolean ENABLE_NORMALIZE = Boolean.valueOf(System.getProperty(DROOLS_NORMALIZE_CONSTRAINT, \"true\"));\n+\n+    public static PatternConstraintParseResult normalizeConstraint(PatternConstraintParseResult pConstraint) {\n+        if (!ENABLE_NORMALIZE) {\n+            return pConstraint;\n+        }\n+\n+        DrlxParseResult drlxParseResult = pConstraint.getDrlxParseResult();\n+\n+        if (drlxParseResult instanceof SingleDrlxParseSuccess) {\n+            SingleDrlxParseSuccess s = (SingleDrlxParseSuccess) drlxParseResult;\n+\n+            // TODO: Add logic based on s.getExpr() class\n+\n+            ConstraintType type = s.getDecodeConstraintType();\n+            TypedExpression left = s.getLeft();\n+            TypedExpression right = s.getRight();\n+            if (type != null && (type == ConstraintType.EQUAL || type == ConstraintType.NOT_EQUAL || type == ConstraintType.GREATER_THAN || type == ConstraintType.GREATER_OR_EQUAL || type == ConstraintType.LESS_THAN ||\n+                                 type == ConstraintType.LESS_OR_EQUAL) && (isPropertyOnRight(left, right))) {\n+                inverseExpression(s);\n+            }\n+        }\n+\n+        return pConstraint;\n+    }\n+\n+    private static boolean isPropertyOnRight(TypedExpression left, TypedExpression right) {\n+        if (!isProperty(left) && isProperty(right)) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private static boolean isProperty(TypedExpression tExpr) {\n+        if (tExpr == null) {\n+            return false;\n+        }\n+        Expression expr = tExpr.getExpression();\n+        if (expr instanceof MethodCallExpr) {\n+            Optional<Expression> thisScope = getRootScope((MethodCallExpr) expr).filter(scope -> scope.equals(new NameExpr(THIS_PLACEHOLDER)));\n+            if (thisScope.isPresent()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static Optional<Expression> getRootScope(MethodCallExpr mcExpr) {\n+        // to get \"_this\" from nested property like \"_this.getAdress().getCity()\"\n+        return mcExpr.getScope().flatMap(s -> {\n+            if (s instanceof NameExpr) {\n+                return Optional.of(s);\n+            } else if (s instanceof MethodCallExpr) {\n+                return getRootScope((MethodCallExpr) s);\n+            } else {\n+                return Optional.empty();\n+            }\n+        });\n+    }\n+\n+    private static void inverseExpression(SingleDrlxParseSuccess s) {\n+        Expression expr = s.getExpr();\n+        if (!(expr instanceof MethodCallExpr)) {\n+            return;\n+        }\n+        MethodCallExpr mExpr = (MethodCallExpr) expr;\n+        String mExprName = mExpr.getName().asString();\n+        String methodName = mExprName.substring(METHOD_PREFIX.length(), mExprName.length());\n+        NodeList<Expression> arguments = mExpr.getArguments();\n+        if (arguments.size() != 2) {\n+            return;\n+        }\n+        ConstraintType inversedOperator = null;\n+        try {\n+            switch (s.getDecodeConstraintType()) {\n+                case EQUAL:\n+                    inversedOperator = ConstraintType.EQUAL;\n+                    break;\n+                case NOT_EQUAL:\n+                    inversedOperator = ConstraintType.NOT_EQUAL;\n+                    break;\n+                case GREATER_THAN:\n+                    inversedOperator = ConstraintType.LESS_THAN;\n+                    methodName = replaceMethodName(methodName, \"greaterThan\", \"lessThan\");\n+                    break;\n+                case GREATER_OR_EQUAL:", "originalCommit": "ac9da977df36f5d3f3f646b6173b0cef1670e5d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg4MzYyOQ==", "url": "https://github.com/kiegroup/drools/pull/2788#discussion_r384883629", "bodyText": "This normalization positionally reverses a constraint while keeping the same logical meaning. e.g. from \"20 > age\" to \"age < 20\". So a simple inversion ('>' to '<', '>=' to '<=') is correct :)", "author": "tkobayas", "createdAt": "2020-02-27T02:37:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM1NzM4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM1ODQxNg==", "url": "https://github.com/kiegroup/drools/pull/2788#discussion_r384358416", "bodyText": "Here maybe instead of the definition of the rule we should test the behaviour. So we insert all kind of people and only the one that matches are in the result. What do you think?", "author": "lucamolteni", "createdAt": "2020-02-26T09:09:41Z", "path": "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/ConstraintNormalizationTest.java", "diffHunk": "@@ -0,0 +1,420 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.drools.modelcompiler;\n+\n+import java.math.BigDecimal;\n+\n+import org.drools.core.common.NamedEntryPoint;\n+import org.drools.core.definitions.rule.impl.RuleImpl;\n+import org.drools.core.reteoo.AlphaNode;\n+import org.drools.core.reteoo.CompositeObjectSinkAdapter;\n+import org.drools.core.reteoo.ObjectTypeNode;\n+import org.drools.core.rule.GroupElement;\n+import org.drools.core.rule.Pattern;\n+import org.drools.modelcompiler.builder.generator.DRLIdGenerator;\n+import org.drools.modelcompiler.constraints.LambdaConstraint;\n+import org.drools.modelcompiler.domain.Address;\n+import org.drools.modelcompiler.domain.Child;\n+import org.drools.modelcompiler.domain.Man;\n+import org.drools.modelcompiler.domain.Person;\n+import org.drools.modelcompiler.domain.Toy;\n+import org.drools.modelcompiler.domain.Woman;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runners.Parameterized.Parameters;\n+import org.kie.api.runtime.KieSession;\n+\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertThat;\n+\n+public class ConstraintNormalizationTest extends BaseModelTest {\n+\n+    // Only supports executable-model at the moment\n+    @Parameters(name = \"{0}\")\n+    public static Object[] params() {\n+        if (Boolean.valueOf(System.getProperty(\"alphanetworkCompilerEnabled\"))) {\n+            return new Object[]{RUN_TYPE.FLOW_DSL, RUN_TYPE.PATTERN_DSL, RUN_TYPE.FLOW_WITH_ALPHA_NETWORK, RUN_TYPE.PATTERN_WITH_ALPHA_NETWORK};\n+        } else {\n+            return new Object[]{RUN_TYPE.FLOW_DSL, RUN_TYPE.PATTERN_DSL};\n+        }\n+    }\n+\n+    public ConstraintNormalizationTest(RUN_TYPE testRunType) {\n+        super(testRunType);\n+    }\n+\n+    @Test\n+    public void testNormalizationForPropertyReactivity() {\n+        final String str =\n+                \"package org.drools.test;\\n\" +\n+                           \"import \" + Person.class.getCanonicalName() + \";\\n\" +\n+                           \"import \" + Toy.class.getCanonicalName() + \";\\n\" +\n+                           \"rule R1 when \\n\" +\n+                           \" $t : Toy($owner : owner)\\n\" +\n+                           \" $p : Person($owner == name)\\n\" +\n+                           \"then\\n\" +\n+                           \"  $p.setAge(20);\" +\n+                           \"  update($p);\" +\n+                           \"end\\n\" +\n+                           \"rule R2 when \\n\" +\n+                           \"  $p : Person(age == 20)\\n\" +\n+                           \"then\\n\" +\n+                           \"end\\n\";\n+\n+        final KieSession ksession = getKieSession(str);\n+\n+        final Toy t = new Toy(\"Ball\");\n+        t.setOwner(\"Toshiya\");\n+        final Person p = new Person(\"Toshiya\", 45);\n+        ksession.insert(t);\n+        ksession.insert(p);\n+        assertEquals(2, ksession.fireAllRules(10)); // no infinite loop\n+    }\n+\n+    @Test\n+    public void testNormalizationForPropertyReactivity2() {\n+        final String str =\n+                \"package org.drools.test;\\n\" +\n+                           \"import \" + Person.class.getCanonicalName() + \";\\n\" +\n+                           \"rule R1 when \\n\" +\n+                           \" $i : Integer()\\n\" +\n+                           \" $p : Person($i < age)\\n\" +\n+                           \"then\\n\" +\n+                           \"  $p.setName(\\\"Blaa\\\");\" +\n+                           \"  update($p);\" +\n+                           \"end\\n\" +\n+                           \"rule R2 when \\n\" +\n+                           \" $p : Person(name == \\\"Blaa\\\")\\n\" +\n+                           \"then\\n\" +\n+                           \"end\\n\";\n+\n+        final KieSession ksession = getKieSession(str);\n+\n+        final Person p = new Person(\"Toshiya\", 45);\n+        ksession.insert(new Integer(30));\n+        ksession.insert(p);\n+        assertEquals(2, ksession.fireAllRules(10)); // no infinite loop\n+    }\n+\n+    @Test\n+    public void testNormalizationForAlphaIndexing() {\n+        final String str =\n+                \"package org.drools.test;\\n\" +\n+                           \"import \" + Person.class.getCanonicalName() + \";\\n\" +\n+                           \"rule R1 when \\n\" +\n+                           \" $p : Person(\\\"Toshiya\\\" == name)\\n\" +\n+                           \"then\\n\" +\n+                           \"end\\n\" +\n+                           \"rule R2 when \\n\" +\n+                           \" $p : Person(\\\"Mario\\\" == name)\\n\" +\n+                           \"then\\n\" +\n+                           \"end\\n\" +\n+                           \"rule R3 when \\n\" +\n+                           \" $p : Person(\\\"Luca\\\" == name)\\n\" +\n+                           \"then\\n\" +\n+                           \"end\\n\";\n+\n+        final KieSession ksession = getKieSession(str);\n+\n+        ObjectTypeNode otn = ((NamedEntryPoint) ksession.getEntryPoint(\"DEFAULT\")).getEntryPointNode().getObjectTypeNodes().entrySet()\n+                                                                                  .stream()\n+                                                                                  .filter(e -> e.getKey().getClassName().equals(Person.class.getCanonicalName()))\n+                                                                                  .map(e -> e.getValue())\n+                                                                                  .findFirst()\n+                                                                                  .get();\n+        CompositeObjectSinkAdapter sinkAdaptor = (CompositeObjectSinkAdapter) otn.getObjectSinkPropagator();\n+\n+        assertNotNull(sinkAdaptor.getHashedSinkMap());\n+        assertEquals(3, sinkAdaptor.getHashedSinkMap().size());\n+\n+        final Person p = new Person(\"Toshiya\", 45);\n+        ksession.insert(p);\n+        assertEquals(1, ksession.fireAllRules());\n+    }\n+\n+    @Test\n+    public void testNormalizationForNodeSharing() {\n+\n+        final String str =\n+                \"package org.drools.test;\\n\" +\n+                           \"import \" + Person.class.getCanonicalName() + \";\\n\" +\n+                           \"rule R1 when \\n\" +\n+                           \" $p : Person(\\\"Toshiya\\\" == name)\\n\" +\n+                           \"then\\n\" +\n+                           \"end\\n\" +\n+                           \"rule R2 when \\n\" +\n+                           \" $p : Person(name == \\\"Toshiya\\\")\\n\" +\n+                           \"then\\n\" +\n+                           \"end\\n\";\n+\n+        final KieSession ksession = getKieSession(str);\n+\n+        assertEquals(1, ReteDumper.collectNodes(ksession).stream().filter(AlphaNode.class::isInstance).count());\n+\n+        final Person p = new Person(\"Toshiya\", 45);\n+        ksession.insert(p);\n+        assertEquals(2, ksession.fireAllRules());\n+    }\n+\n+    @Test\n+    public void testOperators() throws Exception {\n+        final String str =\n+                \"package org.drools.test;\\n\" +\n+                           \"import \" + Person.class.getCanonicalName() + \";\\n\" +\n+                           \"rule R1 when \\n\" +\n+                           \" Person(20 < age, 30 > age)\\n\" +\n+                           \" Person(30 <= age, 40 >= age)\\n\" +\n+                           \"then\\n\" +\n+                           \"end\";\n+\n+        final KieSession ksession = getKieSession(str);\n+\n+        if (testRunType == RUN_TYPE.FLOW_DSL || testRunType == RUN_TYPE.PATTERN_DSL) {\n+            String exprId1 = new DRLIdGenerator().getExprId(Person.class, \"org.drools.modelcompiler.util.EvaluationUtil.\" +\n+                                                                          \"greaterThanNumbers(_this.getAge(), 20)\");", "originalCommit": "ac9da977df36f5d3f3f646b6173b0cef1670e5d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg4NDY2Mg==", "url": "https://github.com/kiegroup/drools/pull/2788#discussion_r384884662", "bodyText": "This normalization changes the constraint expression but keeps the same rule behaviour. So verifying rule outcome doesn't prove that the normalization works expectedly (\"insert all kind of people and only the one matches\" should happen with and without normalization). But I assert the rule outcome to confirm that it doesn't break the rule anyway.\nDifferences can be observed by:\n\nPropertyReactivity (in reality, executable-model works correctly even without normalization, though.)\nAlphaIndexing\nNodeSharing\n\nSo I added those tests first (testNormalizationForPropertyReactivity, testNormalizationForAlphaIndexing, testNormalizationForNodeSharing).\nThen, I added other tests (testOperators, testNestedProperty ...) for coverage of various expressions by comparing its exprId.\nBut, yeah, I may use NodeSharing check instead of exprId check. It would make sense better and be easier to read/write. I'll try and update. Thanks!", "author": "tkobayas", "createdAt": "2020-02-27T02:41:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM1ODQxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAzMDM5MQ==", "url": "https://github.com/kiegroup/drools/pull/2788#discussion_r385030391", "bodyText": "Understood, thank you for the explanation", "author": "lucamolteni", "createdAt": "2020-02-27T10:13:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDM1ODQxNg=="}], "type": "inlineReview"}, {"oid": "9e0a3cc35903d740fc1133691da1a821530828bd", "url": "https://github.com/kiegroup/drools/commit/9e0a3cc35903d740fc1133691da1a821530828bd", "message": "- implement BigDecimal", "committedDate": "2020-03-04T05:46:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzUzMTE0OA==", "url": "https://github.com/kiegroup/drools/pull/2788#discussion_r387531148", "bodyText": "I understand why you're doing this, but having a so special case only for BigDecimal is not ideal. I think this is still manageable but we need to avoid having tons of special cases like this. Regarding this specific fix, I'm afraid this is not avoidable, or anyway I also don't see a better way to cover this case. For now please just add a comment to explain why you need to do this otherwise we will have to \"rediscover\" it again when somebody else will bump into this in 6 months.", "author": "mariofusco", "createdAt": "2020-03-04T09:07:58Z", "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/ConstraintUtil.java", "diffHunk": "@@ -0,0 +1,219 @@\n+package org.drools.modelcompiler.builder.generator;\n+\n+import java.util.Optional;\n+\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.expr.BinaryExpr;\n+import com.github.javaparser.ast.expr.EnclosedExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import com.github.javaparser.ast.expr.UnaryExpr;\n+import org.drools.model.Index.ConstraintType;\n+import org.drools.modelcompiler.builder.generator.drlxparse.DrlxParseResult;\n+import org.drools.modelcompiler.builder.generator.drlxparse.SingleDrlxParseSuccess;\n+import org.drools.modelcompiler.util.EvaluationUtil;\n+\n+import static org.drools.modelcompiler.builder.generator.DrlxParseUtil.THIS_PLACEHOLDER;\n+\n+public class ConstraintUtil {\n+\n+    private static final String CLASS_NAME = EvaluationUtil.class.getCanonicalName() + \".\";\n+    private static final String TO_BIG_DECIMAL = EvaluationUtil.class.getCanonicalName() + \".toBigDecimal\";", "originalCommit": "9e0a3cc35903d740fc1133691da1a821530828bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU2NzgwNg==", "url": "https://github.com/kiegroup/drools/pull/2788#discussion_r387567806", "bodyText": "Thanks. Added a comment.", "author": "tkobayas", "createdAt": "2020-03-04T10:13:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzUzMTE0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTcwNTQyOA==", "url": "https://github.com/kiegroup/drools/pull/2788#discussion_r389705428", "bodyText": "I think that avoiding naming variables with a single character makes the code more readable. There are more places like this in the PR.", "author": "hellowdan", "createdAt": "2020-03-09T14:05:15Z", "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/builder/generator/ConstraintUtil.java", "diffHunk": "@@ -0,0 +1,229 @@\n+package org.drools.modelcompiler.builder.generator;\n+\n+import java.util.Optional;\n+\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.expr.BinaryExpr;\n+import com.github.javaparser.ast.expr.EnclosedExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import com.github.javaparser.ast.expr.UnaryExpr;\n+import org.drools.model.Index.ConstraintType;\n+import org.drools.modelcompiler.builder.generator.drlxparse.DrlxParseResult;\n+import org.drools.modelcompiler.builder.generator.drlxparse.SingleDrlxParseSuccess;\n+import org.drools.modelcompiler.util.EvaluationUtil;\n+\n+import static org.drools.modelcompiler.builder.generator.DrlxParseUtil.THIS_PLACEHOLDER;\n+\n+public class ConstraintUtil {\n+\n+    private static final String CLASS_NAME = EvaluationUtil.class.getCanonicalName() + \".\";\n+\n+    // This is required to detect BigDecimal property from generated MethodCallExpr\n+    private static final String TO_BIG_DECIMAL = EvaluationUtil.class.getCanonicalName() + \".toBigDecimal\";\n+\n+    private static final String GREATER_THAN_PREFIX = \"greaterThan\";\n+    private static final String GREATER_OR_EQUAL_PREFIX = \"greaterOrEqual\";\n+    private static final String LESS_THAN_PREFIX = \"lessThan\";\n+    private static final String LESS_OR_EQUAL_PREFIX = \"lessOrEqual\";\n+\n+    public static final String DROOLS_NORMALIZE_CONSTRAINT = \"drools.normalize.constraint\";\n+\n+    private static final boolean ENABLE_NORMALIZE = Boolean.parseBoolean(System.getProperty(DROOLS_NORMALIZE_CONSTRAINT, \"true\"));\n+\n+    private ConstraintUtil() {}\n+\n+    /**\n+     * Swap left and right operands in a constraint when a fact property is located on the right side.\n+     * \n+     * e.g. Person(20 < age) should be normalized to Person(age > 20)\n+     * \n+     * @param drlxParseResult\n+     * @return Normalized <code>DrlxParseResult</code>\n+     */\n+    public static DrlxParseResult normalizeConstraint(DrlxParseResult drlxParseResult) {\n+        if (!ENABLE_NORMALIZE) {\n+            return drlxParseResult;\n+        }\n+\n+        if (drlxParseResult instanceof SingleDrlxParseSuccess) {\n+            // Create a copy\n+            SingleDrlxParseSuccess s = new SingleDrlxParseSuccess((SingleDrlxParseSuccess) drlxParseResult);", "originalCommit": "6453527ede0287142cf296f2eb6c90655f4ebba8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgzMDE0Nw==", "url": "https://github.com/kiegroup/drools/pull/2788#discussion_r390830147", "bodyText": "Thank you for pointing this out! I have fixed it.", "author": "tkobayas", "createdAt": "2020-03-11T09:10:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTcwNTQyOA=="}], "type": "inlineReview"}, {"oid": "186b7699bb6ebc9180187d64970fcfd0adcb02ba", "url": "https://github.com/kiegroup/drools/commit/186b7699bb6ebc9180187d64970fcfd0adcb02ba", "message": "[DROOLS-4956] Normarize rule constraints for property reactivity and indexing", "committedDate": "2020-03-11T08:41:53Z", "type": "commit"}, {"oid": "41018f17b5b893fbef6dcb2b6978bcf61c61f140", "url": "https://github.com/kiegroup/drools/commit/41018f17b5b893fbef6dcb2b6978bcf61c61f140", "message": "- Check NodeSharing instead of exprId\n- Removed OOPath test", "committedDate": "2020-03-11T08:41:53Z", "type": "commit"}, {"oid": "9dadfdd57d68c937923f07bde62c783a39ab4ff3", "url": "https://github.com/kiegroup/drools/commit/9dadfdd57d68c937923f07bde62c783a39ab4ff3", "message": "- Fix code smells", "committedDate": "2020-03-11T08:41:53Z", "type": "commit"}, {"oid": "372655544d2e5cfec0546e43031288053939c5f5", "url": "https://github.com/kiegroup/drools/commit/372655544d2e5cfec0546e43031288053939c5f5", "message": "- wip", "committedDate": "2020-03-11T08:41:53Z", "type": "commit"}, {"oid": "a0e877d97816a0c375bf706e209e63f6902466fb", "url": "https://github.com/kiegroup/drools/commit/a0e877d97816a0c375bf706e209e63f6902466fb", "message": "- implement And, Or, Nagate", "committedDate": "2020-03-11T08:41:53Z", "type": "commit"}, {"oid": "2ba77b5c566c97b843913f7a739575689881b395", "url": "https://github.com/kiegroup/drools/commit/2ba77b5c566c97b843913f7a739575689881b395", "message": "- implement BigDecimal", "committedDate": "2020-03-11T08:41:53Z", "type": "commit"}, {"oid": "6b43786b75ec05771c15dd47965bd5f5b983ca54", "url": "https://github.com/kiegroup/drools/commit/6b43786b75ec05771c15dd47965bd5f5b983ca54", "message": "- add comment", "committedDate": "2020-03-11T08:41:53Z", "type": "commit"}, {"oid": "9773ab6994e7c9dbdf82c3792642654ecd4f21c4", "url": "https://github.com/kiegroup/drools/commit/9773ab6994e7c9dbdf82c3792642654ecd4f21c4", "message": "- implement STANDARD_FROM_DRL normalization", "committedDate": "2020-03-11T08:41:53Z", "type": "commit"}, {"oid": "c81d9e1b1d8a2253401f0e8a8763b1194c3a6d12", "url": "https://github.com/kiegroup/drools/commit/c81d9e1b1d8a2253401f0e8a8763b1194c3a6d12", "message": "- implement Map access", "committedDate": "2020-03-11T09:02:43Z", "type": "commit"}, {"oid": "c81d9e1b1d8a2253401f0e8a8763b1194c3a6d12", "url": "https://github.com/kiegroup/drools/commit/c81d9e1b1d8a2253401f0e8a8763b1194c3a6d12", "message": "- implement Map access", "committedDate": "2020-03-11T09:02:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMjYwMw==", "url": "https://github.com/kiegroup/drools/pull/2788#discussion_r388812603", "bodyText": "I wonder if I should implement the normalization for FactTemplateObjectType (If yes, need to detect its properties). Is it still used (I only hit this in Misc2Test#testFactTemplates)? According to https://issues.redhat.com/browse/DROOLS-600 , it will likely be removed...", "author": "tkobayas", "createdAt": "2020-03-06T10:00:58Z", "path": "drools-compiler/src/main/java/org/drools/compiler/rule/builder/util/ConstraintUtil.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package org.drools.compiler.rule.builder.util;\n+\n+import org.drools.compiler.lang.descr.BaseDescr;\n+import org.drools.compiler.lang.descr.OperatorDescr;\n+import org.drools.compiler.lang.descr.RelationalExprDescr;\n+import org.drools.core.base.ClassObjectType;\n+import org.drools.core.rule.Pattern;\n+import org.mvel2.util.PropertyTools;\n+\n+public class ConstraintUtil {\n+\n+    /**\n+     * Swap left and right operands in a constraint when a fact property is located on the right side.\n+     * \n+     * e.g. Person(20 < age) should be normalized to Person(age > 20)\n+     * \n+     * @param expression\n+     * @param operator \n+     * @param rightValue \n+     * @param leftValue \n+     * @return Normalized <code>expression</code>\n+     */\n+    public static String inverseExpression(RelationalExprDescr relDescr, String expression, String leftValue, String rightValue, String operator, Pattern pattern) {\n+\n+        Class<?> clazz = pattern.getObjectType().getClassType();\n+\n+        String leftProp = getFirstProp(leftValue);\n+        String rightProp = getFirstProp(rightValue);\n+\n+        OperatorDescr operatorDescr = relDescr.getOperatorDescr();\n+\n+        if (!(pattern.getObjectType() instanceof ClassObjectType)) {\n+            // do not inverse\n+            return expression;\n+        }", "originalCommit": "6453527ede0287142cf296f2eb6c90655f4ebba8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEwMDEzOA==", "url": "https://github.com/kiegroup/drools/pull/2788#discussion_r390100138", "bodyText": "Confirmed with @mariofusco , we don't support FactTemplates so it's okay to \"do not inverse\" here.", "author": "tkobayas", "createdAt": "2020-03-10T05:20:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMjYwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMzIxNA==", "url": "https://github.com/kiegroup/drools/pull/2788#discussion_r388813214", "bodyText": "There seems to be an issue with Map access and executable-model. I'll check next week.", "author": "tkobayas", "createdAt": "2020-03-06T10:02:15Z", "path": "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/ConstraintNormalizationTest.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.drools.modelcompiler;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.assertj.core.api.Assertions;\n+import org.drools.core.common.NamedEntryPoint;\n+import org.drools.core.reteoo.AlphaNode;\n+import org.drools.core.reteoo.CompositeObjectSinkAdapter;\n+import org.drools.core.reteoo.ObjectTypeNode;\n+import org.drools.modelcompiler.domain.Address;\n+import org.drools.modelcompiler.domain.Person;\n+import org.drools.modelcompiler.domain.Toy;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.kie.api.definition.type.FactType;\n+import org.kie.api.runtime.KieSession;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class ConstraintNormalizationTest extends BaseModelTest {\n+\n+    public ConstraintNormalizationTest(RUN_TYPE testRunType) {\n+        super(testRunType);\n+    }\n+\n+    @Test\n+    public void testNormalizationForPropertyReactivity() {\n+        final String str =\n+                \"package org.drools.test;\\n\" +\n+                           \"import \" + Person.class.getCanonicalName() + \";\\n\" +\n+                           \"import \" + Toy.class.getCanonicalName() + \";\\n\" +\n+                           \"rule R1 when \\n\" +\n+                           \" $t : Toy($owner : owner)\\n\" +\n+                           \" $p : Person($owner == name)\\n\" +\n+                           \"then\\n\" +\n+                           \"  $p.setAge(20);\" +\n+                           \"  update($p);\" +\n+                           \"end\\n\" +\n+                           \"rule R2 when \\n\" +\n+                           \"  $p : Person(age == 20)\\n\" +\n+                           \"then\\n\" +\n+                           \"end\\n\";\n+\n+        final KieSession ksession = getKieSession(str);\n+\n+        final Toy t = new Toy(\"Ball\");\n+        t.setOwner(\"Toshiya\");\n+        final Person p = new Person(\"Toshiya\", 45);\n+        ksession.insert(t);\n+        ksession.insert(p);\n+        assertEquals(2, ksession.fireAllRules(10)); // no infinite loop\n+    }\n+\n+    @Test\n+    public void testNormalizationForPropertyReactivity2() {\n+        final String str =\n+                \"package org.drools.test;\\n\" +\n+                           \"import \" + Person.class.getCanonicalName() + \";\\n\" +\n+                           \"rule R1 when \\n\" +\n+                           \" $i : Integer()\\n\" +\n+                           \" $p : Person($i < age)\\n\" +\n+                           \"then\\n\" +\n+                           \"  $p.setName(\\\"Blaa\\\");\" +\n+                           \"  update($p);\" +\n+                           \"end\\n\" +\n+                           \"rule R2 when \\n\" +\n+                           \" $p : Person(name == \\\"Blaa\\\")\\n\" +\n+                           \"then\\n\" +\n+                           \"end\\n\";\n+\n+        final KieSession ksession = getKieSession(str);\n+\n+        final Person p = new Person(\"Toshiya\", 45);\n+        ksession.insert(new Integer(30));\n+        ksession.insert(p);\n+        assertEquals(2, ksession.fireAllRules(10)); // no infinite loop\n+    }\n+\n+    @Test\n+    public void testNormalizationForAlphaIndexing() {\n+        final String str =\n+                \"package org.drools.test;\\n\" +\n+                           \"import \" + Person.class.getCanonicalName() + \";\\n\" +\n+                           \"rule R1 when \\n\" +\n+                           \" $p : Person(\\\"Toshiya\\\" == name)\\n\" +\n+                           \"then\\n\" +\n+                           \"end\\n\" +\n+                           \"rule R2 when \\n\" +\n+                           \" $p : Person(\\\"Mario\\\" == name)\\n\" +\n+                           \"then\\n\" +\n+                           \"end\\n\" +\n+                           \"rule R3 when \\n\" +\n+                           \" $p : Person(\\\"Luca\\\" == name)\\n\" +\n+                           \"then\\n\" +\n+                           \"end\\n\";\n+\n+        final KieSession ksession = getKieSession(str);\n+\n+        ObjectTypeNode otn = ((NamedEntryPoint) ksession.getEntryPoint(\"DEFAULT\")).getEntryPointNode().getObjectTypeNodes().entrySet()\n+                                                                                  .stream()\n+                                                                                  .filter(e -> e.getKey().getClassName().equals(Person.class.getCanonicalName()))\n+                                                                                  .map(e -> e.getValue())\n+                                                                                  .findFirst()\n+                                                                                  .get();\n+        CompositeObjectSinkAdapter sinkAdaptor = (CompositeObjectSinkAdapter) otn.getObjectSinkPropagator();\n+\n+        assertNotNull(sinkAdaptor.getHashedSinkMap());\n+        assertEquals(3, sinkAdaptor.getHashedSinkMap().size());\n+\n+        final Person p = new Person(\"Toshiya\", 45);\n+        ksession.insert(p);\n+        assertEquals(1, ksession.fireAllRules());\n+    }\n+\n+    @Test\n+    public void testNormalizationForNodeSharing() {\n+\n+        final String str =\n+                \"package org.drools.test;\\n\" +\n+                           \"import \" + Person.class.getCanonicalName() + \";\\n\" +\n+                           \"rule R1 when \\n\" +\n+                           \" $p : Person(\\\"Toshiya\\\" == name)\\n\" +\n+                           \"then\\n\" +\n+                           \"end\\n\" +\n+                           \"rule R2 when \\n\" +\n+                           \" $p : Person(name == \\\"Toshiya\\\")\\n\" +\n+                           \"then\\n\" +\n+                           \"end\\n\";\n+\n+        final KieSession ksession = getKieSession(str);\n+\n+        assertEquals(1, ReteDumper.collectNodes(ksession).stream().filter(AlphaNode.class::isInstance).count());\n+\n+        final Person p = new Person(\"Toshiya\", 45);\n+        ksession.insert(p);\n+        assertEquals(2, ksession.fireAllRules());\n+    }\n+\n+    @Test\n+    public void testOperators() throws Exception {\n+\n+        final String str =\n+                \"package org.drools.test;\\n\" +\n+                           \"import \" + Person.class.getCanonicalName() + \";\\n\" +\n+                           \"rule R1 when \\n\" +\n+                           \" Person(20 < age, 30 > age)\\n\" +\n+                           \" Person(30 <= age, 40 >= age)\\n\" +\n+                           \"then\\n\" +\n+                           \"end\\n\" +\n+\n+                           \"rule R2 when \\n\" +\n+                           \" Person(age > 20, age < 30)\\n\" +\n+                           \" Person(age >= 30, age <= 40)\\n\" +\n+                           \"then\\n\" +\n+                           \"end\";\n+\n+        final KieSession ksession = getKieSession(str);\n+\n+        // Check NodeSharing to verify if normalization works expectedly\n+        assertEquals(4, ReteDumper.collectNodes(ksession).stream().filter(AlphaNode.class::isInstance).count());\n+\n+        final Person p1 = new Person(\"John\", 21);\n+        final Person p2 = new Person(\"Paul\", 40);\n+\n+        ksession.insert(p1);\n+        ksession.insert(p2);\n+        assertEquals(2, ksession.fireAllRules());\n+    }\n+\n+    @Test\n+    public void testNestedProperty() throws Exception {\n+        final String str =\n+                \"package org.drools.test;\\n\" +\n+                           \"import \" + Person.class.getCanonicalName() + \";\\n\" +\n+                           \"rule R1 when \\n\" +\n+                           \" Person(\\\"ABC\\\" == address.city)\\n\" +\n+                           \"then\\n\" +\n+                           \"end\\n\" +\n+\n+                           \"rule R2 when \\n\" +\n+                           \" Person(address.city == \\\"ABC\\\")\\n\" +\n+                           \"then\\n\" +\n+                           \"end\";\n+\n+        final KieSession ksession = getKieSession(str);\n+\n+        // Check NodeSharing to verify if normalization works expectedly\n+        assertEquals(1, ReteDumper.collectNodes(ksession).stream().filter(AlphaNode.class::isInstance).count());\n+\n+        final Person p = new Person(\"Toshiya\", 45);\n+        p.setAddress(new Address(\"ABC\"));\n+\n+        ksession.insert(p);\n+        assertEquals(2, ksession.fireAllRules());\n+    }\n+\n+    @Test\n+    public void testComplexMethod() throws Exception {\n+        final String str =\n+                \"package org.drools.test;\\n\" +\n+                           \"import \" + Person.class.getCanonicalName() + \";\\n\" +\n+                           \"import \" + BigDecimal.class.getCanonicalName() + \";\\n\" +\n+                           \"rule R1 when \\n\" +\n+                           \" Person(0 == this.money.compareTo(new BigDecimal(\\\"0.0\\\")))\\n\" +\n+                           \"then\\n\" +\n+                           \"end\\n\" +\n+\n+                           \"rule R2 when \\n\" +\n+                           \" Person(this.money.compareTo(new BigDecimal(\\\"0.0\\\")) == 0)\\n\" +\n+                           \"then\\n\" +\n+                           \"end\";\n+\n+        final KieSession ksession = getKieSession(str);\n+\n+        // Check NodeSharing to verify if normalization works expectedly\n+        assertEquals(1, ReteDumper.collectNodes(ksession).stream().filter(AlphaNode.class::isInstance).count());\n+\n+        final Person p = new Person(\"Toshiya\", 45);\n+        p.setMoney(new BigDecimal(\"0.0\"));\n+\n+        ksession.insert(p);\n+        assertEquals(2, ksession.fireAllRules());\n+    }\n+\n+    @Test\n+    public void testPropsOnBothSide() throws Exception {\n+        final String str =\n+                \"package org.drools.test;\\n\" +\n+                           \"import \" + Person.class.getCanonicalName() + \";\\n\" +\n+                           \"rule R1 when \\n\" +\n+                           \" Person($id: id == age)\\n\" +\n+                           \"then\\n\" +\n+                           \"end\\n\" +\n+\n+                           \"rule R2 when \\n\" +\n+                           \" Person($id: id == age)\\n\" + // No normalization\n+                           \"then\\n\" +\n+                           \"end\";\n+\n+        final KieSession ksession = getKieSession(str);\n+\n+        // Check NodeSharing to verify if normalization works expectedly\n+        assertEquals(1, ReteDumper.collectNodes(ksession).stream().filter(AlphaNode.class::isInstance).count());\n+\n+        final Person p = new Person(\"Toshiya\", 45);\n+        p.setId(45);\n+\n+        ksession.insert(p);\n+        assertEquals(2, ksession.fireAllRules());\n+    }\n+\n+    @Test\n+    public void testExtraParentheses() throws Exception {\n+        final String str =\n+                \"package org.drools.test;\\n\" +\n+                           \"import \" + Person.class.getCanonicalName() + \";\\n\" +\n+                           \"rule R1 when \\n\" +\n+                           \" Person((30 < age))\\n\" +\n+                           \"then\\n\" +\n+                           \"end\\n\" +\n+\n+                           \"rule R2 when \\n\" +\n+                           \" Person((age > 30))\\n\" +\n+                           \"then\\n\" +\n+                           \"end\";\n+\n+        final KieSession ksession = getKieSession(str);\n+\n+        // Check NodeSharing to verify if normalization works expectedly\n+        assertEquals(1, ReteDumper.collectNodes(ksession).stream().filter(AlphaNode.class::isInstance).count());\n+\n+        final Person p = new Person(\"Toshiya\", 45);\n+\n+        ksession.insert(p);\n+        assertEquals(2, ksession.fireAllRules());\n+    }\n+\n+    @Test\n+    public void testAnd() throws Exception {\n+        final String str =\n+                \"package org.drools.test;\\n\" +\n+                           \"import \" + Person.class.getCanonicalName() + \";\\n\" +\n+                           \"rule R1 when \\n\" +\n+                           \" Person(\\\"Toshiya\\\" == name && \\\"Bird\\\" == likes)\\n\" +\n+                           \"then\\n\" +\n+                           \"end\\n\" +\n+\n+                           \"rule R2 when \\n\" +\n+                           \" Person(name == \\\"Toshiya\\\" && likes == \\\"Bird\\\")\\n\" +\n+                           \"then\\n\" +\n+                           \"end\\n\";\n+\n+        final KieSession ksession = getKieSession(str);\n+\n+        // Check NodeSharing to verify if normalization works expectedly\n+        if (testRunType == RUN_TYPE.STANDARD_FROM_DRL) {\n+            assertEquals(2, ReteDumper.collectNodes(ksession).stream().filter(AlphaNode.class::isInstance).count());\n+        } else {\n+            // && is not split in case of executable-model\n+            assertEquals(1, ReteDumper.collectNodes(ksession).stream().filter(AlphaNode.class::isInstance).count());\n+        }\n+\n+        final Person p = new Person(\"Toshiya\", 45);\n+        p.setLikes(\"Bird\");\n+\n+        ksession.insert(p);\n+        assertEquals(2, ksession.fireAllRules());\n+    }\n+\n+    @Test\n+    public void testOr() throws Exception {\n+        final String str =\n+                \"package org.drools.test;\\n\" +\n+                           \"import \" + Person.class.getCanonicalName() + \";\\n\" +\n+                           \"rule R1 when \\n\" +\n+                           \" Person(\\\"XXX\\\" == name || \\\"Bird\\\" == likes)\\n\" +\n+                           \"then\\n\" +\n+                           \"end\\n\" +\n+\n+                           \"rule R2 when \\n\" +\n+                           \" Person(name == \\\"XXX\\\" || likes == \\\"Bird\\\")\\n\" +\n+                           \"then\\n\" +\n+                           \"end\";\n+\n+        final KieSession ksession = getKieSession(str);\n+\n+        // Check NodeSharing to verify if normalization works expectedly\n+        assertEquals(1, ReteDumper.collectNodes(ksession).stream().filter(AlphaNode.class::isInstance).count());\n+\n+        final Person p = new Person(\"Toshiya\", 45);\n+        p.setLikes(\"Bird\");\n+\n+        ksession.insert(p);\n+        assertEquals(2, ksession.fireAllRules());\n+    }\n+\n+    @Test\n+    public void testNegate() throws Exception {\n+        final String str =\n+                \"package org.drools.test;\\n\" +\n+                           \"import \" + Person.class.getCanonicalName() + \";\\n\" +\n+                           \"rule R1 when \\n\" +\n+                           \" Person(!(30 > age))\\n\" +\n+                           \"then\\n\" +\n+                           \"end\\n\" +\n+\n+                           \"rule R2 when \\n\" +\n+                           \" Person(!(age < 30))\\n\" +\n+                           \"then\\n\" +\n+                           \"end\";\n+\n+        final KieSession ksession = getKieSession(str);\n+\n+        // Check NodeSharing to verify if normalization works expectedly\n+        assertEquals(1, ReteDumper.collectNodes(ksession).stream().filter(AlphaNode.class::isInstance).count());\n+\n+        final Person p = new Person(\"Toshiya\", 45);\n+\n+        ksession.insert(p);\n+        assertEquals(2, ksession.fireAllRules());\n+    }\n+\n+    @Test\n+    public void testBigDecimal() throws Exception {\n+        String str =\n+                \"import \" + Person.class.getCanonicalName() + \";\" +\n+                     \"rule R1 when\\n\" +\n+                     \"  $p : Person(20 < money)\\n\" +\n+                     \"then\\n\" +\n+                     \"end\\n\" +\n+\n+                     \"rule R2 when\\n\" +\n+                     \"  $p : Person(money > 20)\\n\" +\n+                     \"then\\n\" +\n+                     \"end\";\n+\n+        KieSession ksession = getKieSession(str);\n+\n+        // Check NodeSharing to verify if normalization works expectedly\n+        assertEquals(1, ReteDumper.collectNodes(ksession).stream().filter(AlphaNode.class::isInstance).count());\n+\n+        Person p = new Person(\"John\");\n+        p.setMoney(new BigDecimal(\"30.0\"));\n+\n+        ksession.insert(p);\n+\n+        assertEquals(2, ksession.fireAllRules());\n+    }\n+\n+    @Test\n+    public void testNegateComplex() throws Exception {\n+        String str =\n+                \"import \" + Person.class.getCanonicalName() + \";\" +\n+                     \"global java.util.List list;\\n\" +\n+                     \"rule R1 when\\n\" +\n+                     \"  $p : Person(!(20 < money && 40 > money))\\n\" +\n+                     \"then\\n\" +\n+                     \"  list.add($p.getName());\" +\n+                     \"end\\n\" +\n+\n+                     \"rule R2 when\\n\" +\n+                     \"  $p : Person(!(money > 20 && money < 40))\\n\" +\n+                     \"then\\n\" +\n+                     \"  list.add($p.getName());\" +\n+                     \"end\";\n+\n+        KieSession ksession = getKieSession(str);\n+\n+        // Check NodeSharing to verify if normalization works expectedly\n+        assertEquals(1, ReteDumper.collectNodes(ksession).stream().filter(AlphaNode.class::isInstance).count());\n+\n+        final List<String> list = new ArrayList<>();\n+        ksession.setGlobal(\"list\", list);\n+\n+        Person p1 = new Person(\"John\");\n+        p1.setMoney(new BigDecimal(\"10.0\"));\n+        Person p2 = new Person(\"Paul\");\n+        p2.setMoney(new BigDecimal(\"30.0\"));\n+        Person p3 = new Person(\"George\");\n+        p3.setMoney(new BigDecimal(\"50.0\"));\n+\n+        ksession.insert(p1);\n+        ksession.insert(p2);\n+        ksession.insert(p3);\n+\n+        assertEquals(4, ksession.fireAllRules());\n+        Assertions.assertThat(list).containsExactlyInAnyOrder(\"John\", \"George\", \"John\", \"George\");\n+    }\n+\n+    @Test\n+    public void testNegateComplex2() throws Exception {\n+        String str =\n+                \"import \" + Person.class.getCanonicalName() + \";\" +\n+                     \"global java.util.List list;\\n\" +\n+                     \"rule R1 when\\n\" +\n+                     \"  $p : Person(!(!(20 >= money) && 40 > money))\\n\" +\n+                     \"then\\n\" +\n+                     \"  list.add($p.getName());\" +\n+                     \"end\\n\" +\n+\n+                     \"rule R2 when\\n\" +\n+                     \"  $p : Person(!(!(money <= 20) && money < 40))\\n\" +\n+                     \"then\\n\" +\n+                     \"  list.add($p.getName());\" +\n+                     \"end\";\n+\n+        KieSession ksession = getKieSession(str);\n+\n+        // Check NodeSharing to verify if normalization works expectedly\n+        assertEquals(1, ReteDumper.collectNodes(ksession).stream().filter(AlphaNode.class::isInstance).count());\n+\n+        final List<String> list = new ArrayList<>();\n+        ksession.setGlobal(\"list\", list);\n+\n+        Person p1 = new Person(\"John\");\n+        p1.setMoney(new BigDecimal(\"10.0\"));\n+        Person p2 = new Person(\"Paul\");\n+        p2.setMoney(new BigDecimal(\"30.0\"));\n+        Person p3 = new Person(\"George\");\n+        p3.setMoney(new BigDecimal(\"50.0\"));\n+\n+        ksession.insert(p1);\n+        ksession.insert(p2);\n+        ksession.insert(p3);\n+\n+        assertEquals(4, ksession.fireAllRules());\n+        Assertions.assertThat(list).containsExactlyInAnyOrder(\"John\", \"George\", \"John\", \"George\");\n+    }\n+\n+    @Test\n+    public void testDeclaredType() throws Exception {\n+        final String str =\n+                \"package org.drools.test;\\n\" +\n+                           \"declare Person\\n\" +\n+                           \"    name : String\\n\" +\n+                           \"    age : int\\n\" +\n+                           \"end\\n\" +\n+                           \"rule R1 when \\n\" +\n+                           \" Person(\\\"Toshiya\\\" == name, 20 < age)\\n\" +\n+                           \"then\\n\" +\n+                           \"end\\n\" +\n+\n+                           \"rule R2 when \\n\" +\n+                           \" Person(name == \\\"Toshiya\\\", age > 20)\\n\" +\n+                           \"then\\n\" +\n+                           \"end\";\n+\n+        final KieSession ksession = getKieSession(str);\n+\n+        // Check NodeSharing to verify if normalization works expectedly\n+        assertEquals(2, ReteDumper.collectNodes(ksession).stream().filter(AlphaNode.class::isInstance).count());\n+\n+        FactType factType = ksession.getKieBase().getFactType(\"org.drools.test\", \"Person\");\n+        Object p = factType.newInstance();\n+        factType.set(p, \"name\", \"Toshiya\");\n+        factType.set(p, \"age\", 45);\n+        ksession.insert(p);\n+        assertEquals(2, ksession.fireAllRules());\n+    }\n+\n+    @Ignore\n+    @Test\n+    public void testMap() throws Exception {\n+        final String str =\n+                \"package org.drools.test;\\n\" +\n+                           \"import \" + Person.class.getCanonicalName() + \";\\n\" +\n+                           \"rule R1 when \\n\" +\n+                           \" Person(\\\"Value\\\" == itemsString[\\\"Key\\\"])\\n\" +\n+                           \"then\\n\" +\n+                           \"end\\n\" +\n+\n+                           \"rule R2 when \\n\" +\n+                           \" Person(itemsString[\\\"Key\\\"] == \\\"Value\\\")\\n\" +\n+                           \"then\\n\" +\n+                           \"end\";\n+\n+        final KieSession ksession = getKieSession(str);\n+\n+        // Check NodeSharing to verify if normalization works expectedly\n+        assertEquals(1, ReteDumper.collectNodes(ksession).stream().filter(AlphaNode.class::isInstance).count());\n+\n+        final Person p = new Person(\"Toshiya\");\n+        p.getItemsString().put(\"Key\", \"Value\");\n+\n+        ksession.insert(p);\n+        assertEquals(2, ksession.fireAllRules());\n+    }", "originalCommit": "6453527ede0287142cf296f2eb6c90655f4ebba8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDEwMDUwNg==", "url": "https://github.com/kiegroup/drools/pull/2788#discussion_r390100506", "bodyText": "Filed https://issues.redhat.com/browse/DROOLS-5136 . This issue needs to be fixed/merged first.", "author": "tkobayas", "createdAt": "2020-03-10T05:21:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMzIxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgzMTY5Mw==", "url": "https://github.com/kiegroup/drools/pull/2788#discussion_r390831693", "bodyText": "DROOLS-5136 has been fixed and merged. Now this PR is rebased to consume the fix so Map access normalization is implemented.", "author": "tkobayas", "createdAt": "2020-03-11T09:12:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMzIxNA=="}], "type": "inlineReview"}, {"oid": "491c035c297a3e9b86496336bfae9000507e09f5", "url": "https://github.com/kiegroup/drools/commit/491c035c297a3e9b86496336bfae9000507e09f5", "message": "- fix code smells", "committedDate": "2020-03-12T01:30:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1OTM5Mw==", "url": "https://github.com/kiegroup/drools/pull/2788#discussion_r392859393", "bodyText": "Minor thing: we already have part of this analysis for operator inside the enum IndexUtil.ConstraintType. If possible I'd keep all the similar code there. For instance you can add this canInverse method in that enum and then testing it with IndexUtil.ConstraintType.decode(operator).canInverse()", "author": "mariofusco", "createdAt": "2020-03-16T08:44:39Z", "path": "drools-compiler/src/main/java/org/drools/compiler/rule/builder/util/ConstraintUtil.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package org.drools.compiler.rule.builder.util;\n+\n+import org.drools.compiler.lang.descr.BaseDescr;\n+import org.drools.compiler.lang.descr.OperatorDescr;\n+import org.drools.compiler.lang.descr.RelationalExprDescr;\n+import org.drools.core.base.ClassObjectType;\n+import org.drools.core.rule.Pattern;\n+import org.mvel2.util.PropertyTools;\n+\n+public class ConstraintUtil {\n+\n+    public static final String DROOLS_NORMALIZE_CONSTRAINT = \"drools.normalize.constraint\";\n+\n+    private static final boolean ENABLE_NORMALIZE = Boolean.parseBoolean(System.getProperty(DROOLS_NORMALIZE_CONSTRAINT, \"true\"));\n+\n+    private ConstraintUtil() {}\n+\n+    /**\n+     * Swap left and right operands in a constraint when a fact property is located on the right side.\n+     * \n+     * e.g. Person(20 < age) should be normalized to Person(age > 20)\n+     * \n+     * @param expression\n+     * @param operator \n+     * @param rightValue \n+     * @param leftValue \n+     * @return Normalized <code>expression</code>\n+     */\n+    public static String inverseExpression(RelationalExprDescr relDescr, String expression, String leftValue, String rightValue, String operator, Pattern pattern) {\n+        if (!ENABLE_NORMALIZE) {\n+            return expression;\n+        }\n+        Class<?> clazz = pattern.getObjectType().getClassType();\n+\n+        String leftProp = getFirstProp(leftValue);\n+        String rightProp = getFirstProp(rightValue);\n+\n+        OperatorDescr operatorDescr = relDescr.getOperatorDescr();\n+\n+        if (canInverse(pattern, operator, operatorDescr, leftProp, rightProp) && isPropertyOnRight(clazz, leftProp, rightProp)) {\n+            boolean negate = false;\n+            if (isNagatedExpression(expression, leftValue, rightValue, operator)) {\n+                if (relDescr.getOperatorDescr().isNegated()) {\n+                    negate = true;\n+                } else {\n+                    // do not inverse\n+                    return expression;\n+                }\n+            }\n+\n+            BaseDescr left = relDescr.getLeft();\n+            relDescr.setLeft(relDescr.getRight());\n+            relDescr.setRight(left);\n+\n+            String inversedOperator = inverseOperator(operator);\n+\n+            operatorDescr.setOperator(inversedOperator);\n+\n+            StringBuilder sb = new StringBuilder();\n+            String inversedExpression = sb.append(rightValue).append(\" \").append(inversedOperator).append(\" \").append(leftValue).toString();\n+            if (negate) {\n+                inversedExpression = \"!( \" + inversedExpression + \" )\";\n+            }\n+\n+            return inversedExpression;\n+        }\n+\n+        // do not inverse\n+        return expression;\n+    }\n+\n+    private static boolean isPropertyOnRight(Class<?> clazz, String leftProp, String rightProp) {\n+        return (PropertyTools.getFieldOrAccessor(clazz, leftProp) == null) && ((PropertyTools.getFieldOrAccessor(clazz, rightProp) != null) || (rightProp.equals(\"this\")));\n+    }\n+\n+    private static boolean canInverse(Pattern pattern, String operator, OperatorDescr operatorDescr, String leftProp, String rightProp) {\n+        if (!(pattern.getObjectType() instanceof ClassObjectType)) {\n+            return false;\n+        }\n+        if (!operator.equals(operatorDescr.getOperator())) {\n+            return false;\n+        }\n+        if (leftProp.isEmpty() || rightProp.isEmpty()) {\n+            return false;\n+        }\n+        return canInverse(operator);\n+    }\n+\n+    private static boolean canInverse(String operator) {\n+        return (operator.equals(\"==\") || operator.equals(\"!=\") || operator.equals(\">\") || operator.equals(\"<\") || operator.equals(\">=\") || operator.equals(\"<=\"));", "originalCommit": "491c035c297a3e9b86496336bfae9000507e09f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg5NDM4NQ==", "url": "https://github.com/kiegroup/drools/pull/2788#discussion_r392894385", "bodyText": "Thank you for the suggestion. I did the refactoring for org.drools.core.util.index.IndexUtil.ConstraintType in standard-drl and did similar for org.drools.model.Index.ConstraintType in executable-model. Finally, IndexUtil.ConstraintType and Index.ConstraintType have duplicate logic but maybe it's okay? (If Index.ConstraintType wants to use IndexUtil.ConstraintType method, it will require a conversion from Index.ConstraintType to IndexUtil.ConstraintType so it would be a bit redundant)", "author": "tkobayas", "createdAt": "2020-03-16T09:49:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1OTM5Mw=="}], "type": "inlineReview"}, {"oid": "bdd2487091fd9fae9f440f19a2e0d39eb0651a07", "url": "https://github.com/kiegroup/drools/commit/bdd2487091fd9fae9f440f19a2e0d39eb0651a07", "message": "- Refactor to use IndexUtil", "committedDate": "2020-03-16T09:38:39Z", "type": "commit"}]}