{"pr_number": 2930, "pr_title": "[DROOLS-5381] Implemented code-generation for TreeModel", "pr_createdAt": "2020-06-03T16:42:34Z", "pr_url": "https://github.com/kiegroup/drools/pull/2930", "timeline": [{"oid": "e6700161dc7d042bcbd9fb14b0f4e30209f510b1", "url": "https://github.com/kiegroup/drools/commit/e6700161dc7d042bcbd9fb14b0f4e30209f510b1", "message": "[DROOLS-5381] Implemented code-generation for TreeModel. Put common code in KiePMMLDroolsModelFactoryUtils. Implemented tests", "committedDate": "2020-06-03T16:34:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwNzMxOA==", "url": "https://github.com/kiegroup/drools/pull/2930#discussion_r435107318", "bodyText": "Can you please add modelClassName to error message?", "author": "danielezonca", "createdAt": "2020-06-04T09:11:13Z", "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-drools/kie-pmml-models-drools-common/src/main/java/org/kie/pmml/models/drools/utils/KiePMMLDroolsModelFactoryUtils.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.drools.utils;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.IntegerLiteralExpr;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.ExplicitConstructorInvocationStmt;\n+import org.dmg.pmml.DataDictionary;\n+import org.dmg.pmml.Model;\n+import org.kie.pmml.commons.exceptions.KiePMMLException;\n+import org.kie.pmml.commons.exceptions.KiePMMLInternalException;\n+import org.kie.pmml.commons.model.KiePMMLOutputField;\n+import org.kie.pmml.commons.model.enums.MINING_FUNCTION;\n+import org.kie.pmml.commons.model.enums.PMML_MODEL;\n+import org.kie.pmml.commons.model.enums.RESULT_FEATURE;\n+import org.kie.pmml.models.drools.tuples.KiePMMLOriginalTypeGeneratedType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedClassName;\n+import static org.kie.pmml.compiler.commons.factories.KiePMMLOutputFieldFactory.getOutputFields;\n+import static org.kie.pmml.compiler.commons.utils.JavaParserUtils.MAIN_CLASS_NOT_FOUND;\n+import static org.kie.pmml.compiler.commons.utils.JavaParserUtils.getFromFileName;\n+import static org.kie.pmml.compiler.commons.utils.ModelUtils.getTargetFieldName;\n+\n+/**\n+ * Utility class to provide common methods for KiePMMLDroolsModel-specific <b>factories</b>\n+ */\n+public class KiePMMLDroolsModelFactoryUtils {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLDroolsModelFactoryUtils.class.getName());\n+\n+    public KiePMMLDroolsModelFactoryUtils() {\n+        // Avoid instantiation\n+    }\n+\n+    /**\n+     *\n+     * @param dataDictionary\n+     * @param model\n+     * @param fieldTypeMap\n+     * @param packageName\n+     * @param javaTemplate the name of the <b>file</b> to be used as template source\n+     * @param modelClassName the name of the class used in the provided template\n+     * @return\n+     */\n+    public static CompilationUnit getKiePMMLModelCompilationUnit(final DataDictionary dataDictionary,\n+                                                                 final Model model,\n+                                                                 final Map<String, KiePMMLOriginalTypeGeneratedType> fieldTypeMap,\n+                                                                 final String packageName,\n+                                                                 final String javaTemplate,\n+                                                                 final String modelClassName) {\n+        logger.trace(\"getKiePMMLModelCompilationUnit {} {} {}\", dataDictionary, model, packageName);\n+        String className = getSanitizedClassName(model.getModelName());\n+        String targetField = getTargetFieldName(dataDictionary, model).orElse(null);\n+        List<KiePMMLOutputField> outputFields = getOutputFields(model);\n+        CompilationUnit templateCU = getFromFileName(javaTemplate);\n+        CompilationUnit cloneCU = templateCU.clone();\n+        cloneCU.setPackageDeclaration(packageName);\n+        ClassOrInterfaceDeclaration modelTemplate = cloneCU.getClassByName(modelClassName)\n+                .orElseThrow(() -> new KiePMMLException(MAIN_CLASS_NOT_FOUND));", "originalCommit": "e6700161dc7d042bcbd9fb14b0f4e30209f510b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEyNDY3OA==", "url": "https://github.com/kiegroup/drools/pull/2930#discussion_r435124678", "bodyText": "@danielezonca\ndone", "author": "gitgabrio", "createdAt": "2020-06-04T09:40:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwNzMxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwODU2OA==", "url": "https://github.com/kiegroup/drools/pull/2930#discussion_r435108568", "bodyText": "Can you please move this logic to a method to improve code readability?", "author": "danielezonca", "createdAt": "2020-06-04T09:13:21Z", "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-drools/kie-pmml-models-drools-common/src/test/java/org/kie/pmml/models/drools/utils/KiePMMLDroolsModelFactoryUtilsTest.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.pmml.models.drools.utils;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Random;\n+import java.util.Spliterator;\n+import java.util.Spliterators;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.IntegerLiteralExpr;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.ExpressionStmt;\n+import com.github.javaparser.ast.stmt.Statement;\n+import org.dmg.pmml.DataDictionary;\n+import org.dmg.pmml.DataField;\n+import org.dmg.pmml.DataType;\n+import org.dmg.pmml.FieldName;\n+import org.dmg.pmml.MiningField;\n+import org.dmg.pmml.MiningFunction;\n+import org.dmg.pmml.MiningSchema;\n+import org.dmg.pmml.Model;\n+import org.dmg.pmml.OpType;\n+import org.dmg.pmml.tree.TreeModel;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.kie.pmml.commons.model.KiePMMLOutputField;\n+import org.kie.pmml.commons.model.enums.MINING_FUNCTION;\n+import org.kie.pmml.commons.model.enums.PMML_MODEL;\n+import org.kie.pmml.commons.model.enums.RESULT_FEATURE;\n+import org.kie.pmml.models.drools.tuples.KiePMMLOriginalTypeGeneratedType;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedClassName;\n+import static org.kie.pmml.compiler.commons.utils.JavaParserUtils.getFromFileName;\n+\n+public class KiePMMLDroolsModelFactoryUtilsTest {\n+\n+    private static final String TEMPLATE_SOURCE = \"Template.tmpl\";\n+    private static final String TEMPLATE_CLASS_NAME = \"Template\";\n+\n+    private static CompilationUnit COMPILATION_UNIT;\n+    private static ClassOrInterfaceDeclaration MODEL_TEMPLATE;\n+\n+    @BeforeClass\n+    public static void setup() {\n+        COMPILATION_UNIT = getFromFileName(TEMPLATE_SOURCE);\n+        MODEL_TEMPLATE = COMPILATION_UNIT.getClassByName(TEMPLATE_CLASS_NAME).get();\n+    }\n+\n+    @Test\n+    public void getKiePMMLModelCompilationUnit() {\n+        DataDictionary dataDictionary = new DataDictionary();\n+        String targetFieldString = \"target.field\";\n+        FieldName targetFieldName = FieldName.create(targetFieldString);\n+        dataDictionary.addDataFields(new DataField(targetFieldName, OpType.CONTINUOUS, DataType.DOUBLE));\n+        String modelName = \"ModelName\";\n+        Model model = new TreeModel();\n+        model.setModelName(modelName);\n+        model.setMiningFunction(MiningFunction.CLASSIFICATION);\n+        MiningField targetMiningField = new MiningField(targetFieldName);\n+        targetMiningField.setUsageType(MiningField.UsageType.TARGET);\n+        MiningSchema miningSchema = new MiningSchema();\n+        miningSchema.addMiningFields(targetMiningField);\n+        model.setMiningSchema(miningSchema);\n+        Map<String, KiePMMLOriginalTypeGeneratedType> fieldTypeMap = new HashMap<>();\n+        fieldTypeMap.put(targetFieldString, new KiePMMLOriginalTypeGeneratedType(targetFieldString, getSanitizedClassName(targetFieldString)));\n+        String packageName = \"net.test\";\n+        CompilationUnit retrieved = KiePMMLDroolsModelFactoryUtils.getKiePMMLModelCompilationUnit(dataDictionary, model, fieldTypeMap, packageName, TEMPLATE_SOURCE, TEMPLATE_CLASS_NAME);\n+        assertEquals(packageName, retrieved.getPackageDeclaration().get().getNameAsString());\n+        ConstructorDeclaration constructorDeclaration = retrieved.getClassByName(modelName).get().getDefaultConstructor().get();\n+        MINING_FUNCTION miningFunction = MINING_FUNCTION.CLASSIFICATION;\n+        PMML_MODEL pmmlModel = PMML_MODEL.byName(model.getClass().getSimpleName());\n+        Map<String, Expression> assignExpressionMap = new HashMap<>();\n+        assignExpressionMap.put(\"targetField\", new StringLiteralExpr(targetFieldString));\n+        assignExpressionMap.put(\"miningFunction\", new NameExpr(miningFunction.getClass().getName() + \".\" + miningFunction.name()));\n+        assignExpressionMap.put(\"pmmlMODEL\", new NameExpr(pmmlModel.getClass().getName() + \".\" + pmmlModel.name()));\n+        commonEvaluateAssignExpr(constructorDeclaration.getBody(), assignExpressionMap);\n+        int expectedMethodCallExprs = assignExpressionMap.size() + fieldTypeMap.size() + 1; // The last \"1\" is for the super invocation\n+        commonEvaluateFieldTypeMap(constructorDeclaration.getBody(), fieldTypeMap, expectedMethodCallExprs);\n+    }\n+\n+    @Test\n+    public void setConstructor() {\n+        Model model = new TreeModel();\n+        PMML_MODEL pmmlModel = PMML_MODEL.byName(model.getClass().getSimpleName());\n+        ConstructorDeclaration constructorDeclaration = MODEL_TEMPLATE.getDefaultConstructor().get();\n+        SimpleName tableName = new SimpleName(\"TABLE_NAME\");\n+        String targetField = \"TARGET_FIELD\";\n+        MINING_FUNCTION miningFunction = MINING_FUNCTION.CLASSIFICATION;\n+        KiePMMLDroolsModelFactoryUtils.setConstructor(model, constructorDeclaration, tableName, targetField, miningFunction);\n+        assertEquals(tableName, constructorDeclaration.getName());\n+        Map<String, Expression> assignExpressionMap = new HashMap<>();\n+        assignExpressionMap.put(\"targetField\", new StringLiteralExpr(targetField));\n+        assignExpressionMap.put(\"miningFunction\", new NameExpr(miningFunction.getClass().getName() + \".\" + miningFunction.name()));\n+        assignExpressionMap.put(\"pmmlMODEL\", new NameExpr(pmmlModel.getClass().getName() + \".\" + pmmlModel.name()));\n+        commonEvaluateAssignExpr(constructorDeclaration.getBody(), assignExpressionMap);\n+    }\n+\n+    @Test\n+    public void addOutputFieldsPopulation() {\n+        BlockStmt blockStmt = new BlockStmt();\n+        List<KiePMMLOutputField> outputFields = IntStream.range(0, 3)\n+                .mapToObj(index -> KiePMMLOutputField.builder(\"OUTPUTFIELD-\" + index, Collections.emptyList())\n+                        .withRank(new Random().nextInt(3))\n+                        .withValue(\"VALUE-\" + index)\n+                        .withTargetField(\"TARGETFIELD-\" + index)\n+                        .build())\n+                .collect(Collectors.toList());\n+        KiePMMLDroolsModelFactoryUtils.addOutputFieldsPopulation(blockStmt, outputFields);\n+        List<MethodCallExpr> retrieved = getMethodCallExprList(blockStmt, outputFields.size(), \"outputFields\", \"add\");\n+        for (KiePMMLOutputField outputField : outputFields) {\n+            assertTrue(retrieved.stream()\n+                               .filter(methodCallExpr -> methodCallExpr.getArguments().size() == 1)\n+                               .map(methodCallExpr -> methodCallExpr.getArgument(0))\n+                               .filter(Expression::isMethodCallExpr)\n+                               .map(expressionArgument -> (MethodCallExpr) expressionArgument)\n+                               .anyMatch(methodCallExpr -> {\n+                                   boolean toReturn = commonEvaluateMethodCallExpr(methodCallExpr, \"build\", new NodeList<>(), MethodCallExpr.class);\n+                                   MethodCallExpr resultFeatureScopeExpr = (MethodCallExpr) methodCallExpr.getScope().get();\n+                                   NodeList<Expression> expectedArguments = NodeList.nodeList(new NameExpr(RESULT_FEATURE.class.getName() + \".\" + outputField.getResultFeature().toString()));\n+                                   toReturn &= commonEvaluateMethodCallExpr(resultFeatureScopeExpr, \"withResultFeature\", expectedArguments, MethodCallExpr.class);\n+                                   MethodCallExpr targetFieldScopeExpr = (MethodCallExpr) resultFeatureScopeExpr.getScope().get();\n+                                   expectedArguments = NodeList.nodeList(new StringLiteralExpr(outputField.getTargetField().get()));\n+                                   toReturn &= commonEvaluateMethodCallExpr(targetFieldScopeExpr, \"withTargetField\", expectedArguments, MethodCallExpr.class);\n+                                   MethodCallExpr valueScopeExpr = (MethodCallExpr) targetFieldScopeExpr.getScope().get();\n+                                   expectedArguments = NodeList.nodeList(new StringLiteralExpr(outputField.getValue().toString()));\n+                                   toReturn &= commonEvaluateMethodCallExpr(valueScopeExpr, \"withValue\", expectedArguments, MethodCallExpr.class);\n+                                   MethodCallExpr rankScopeExpr = (MethodCallExpr) valueScopeExpr.getScope().get();\n+                                   expectedArguments = NodeList.nodeList(new IntegerLiteralExpr(outputField.getRank()));\n+                                   toReturn &= commonEvaluateMethodCallExpr(rankScopeExpr, \"withRank\", expectedArguments, MethodCallExpr.class);\n+                                   MethodCallExpr builderScopeExpr = (MethodCallExpr) rankScopeExpr.getScope().get();\n+                                   expectedArguments = NodeList.nodeList(new StringLiteralExpr(outputField.getName()), new NameExpr(\"Collections.emptyList()\"));\n+                                   toReturn &= commonEvaluateMethodCallExpr(builderScopeExpr, \"builder\", expectedArguments, NameExpr.class);\n+                                   toReturn &= builderScopeExpr.getName().equals(new SimpleName(\"builder\"));\n+                                   toReturn &= builderScopeExpr.getScope().get().equals(new NameExpr(\"KiePMMLOutputField\"));\n+                                   return toReturn;", "originalCommit": "e6700161dc7d042bcbd9fb14b0f4e30209f510b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEyNDY0Mg==", "url": "https://github.com/kiegroup/drools/pull/2930#discussion_r435124642", "bodyText": "@danielezonca\ndone", "author": "gitgabrio", "createdAt": "2020-06-04T09:40:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwODU2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwODc3NA==", "url": "https://github.com/kiegroup/drools/pull/2930#discussion_r435108774", "bodyText": "Can you please move this logic to a method to improve code readability?", "author": "danielezonca", "createdAt": "2020-06-04T09:13:44Z", "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-drools/kie-pmml-models-drools-common/src/test/java/org/kie/pmml/models/drools/utils/KiePMMLDroolsModelFactoryUtilsTest.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.pmml.models.drools.utils;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Random;\n+import java.util.Spliterator;\n+import java.util.Spliterators;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.IntegerLiteralExpr;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.ExpressionStmt;\n+import com.github.javaparser.ast.stmt.Statement;\n+import org.dmg.pmml.DataDictionary;\n+import org.dmg.pmml.DataField;\n+import org.dmg.pmml.DataType;\n+import org.dmg.pmml.FieldName;\n+import org.dmg.pmml.MiningField;\n+import org.dmg.pmml.MiningFunction;\n+import org.dmg.pmml.MiningSchema;\n+import org.dmg.pmml.Model;\n+import org.dmg.pmml.OpType;\n+import org.dmg.pmml.tree.TreeModel;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.kie.pmml.commons.model.KiePMMLOutputField;\n+import org.kie.pmml.commons.model.enums.MINING_FUNCTION;\n+import org.kie.pmml.commons.model.enums.PMML_MODEL;\n+import org.kie.pmml.commons.model.enums.RESULT_FEATURE;\n+import org.kie.pmml.models.drools.tuples.KiePMMLOriginalTypeGeneratedType;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedClassName;\n+import static org.kie.pmml.compiler.commons.utils.JavaParserUtils.getFromFileName;\n+\n+public class KiePMMLDroolsModelFactoryUtilsTest {\n+\n+    private static final String TEMPLATE_SOURCE = \"Template.tmpl\";\n+    private static final String TEMPLATE_CLASS_NAME = \"Template\";\n+\n+    private static CompilationUnit COMPILATION_UNIT;\n+    private static ClassOrInterfaceDeclaration MODEL_TEMPLATE;\n+\n+    @BeforeClass\n+    public static void setup() {\n+        COMPILATION_UNIT = getFromFileName(TEMPLATE_SOURCE);\n+        MODEL_TEMPLATE = COMPILATION_UNIT.getClassByName(TEMPLATE_CLASS_NAME).get();\n+    }\n+\n+    @Test\n+    public void getKiePMMLModelCompilationUnit() {\n+        DataDictionary dataDictionary = new DataDictionary();\n+        String targetFieldString = \"target.field\";\n+        FieldName targetFieldName = FieldName.create(targetFieldString);\n+        dataDictionary.addDataFields(new DataField(targetFieldName, OpType.CONTINUOUS, DataType.DOUBLE));\n+        String modelName = \"ModelName\";\n+        Model model = new TreeModel();\n+        model.setModelName(modelName);\n+        model.setMiningFunction(MiningFunction.CLASSIFICATION);\n+        MiningField targetMiningField = new MiningField(targetFieldName);\n+        targetMiningField.setUsageType(MiningField.UsageType.TARGET);\n+        MiningSchema miningSchema = new MiningSchema();\n+        miningSchema.addMiningFields(targetMiningField);\n+        model.setMiningSchema(miningSchema);\n+        Map<String, KiePMMLOriginalTypeGeneratedType> fieldTypeMap = new HashMap<>();\n+        fieldTypeMap.put(targetFieldString, new KiePMMLOriginalTypeGeneratedType(targetFieldString, getSanitizedClassName(targetFieldString)));\n+        String packageName = \"net.test\";\n+        CompilationUnit retrieved = KiePMMLDroolsModelFactoryUtils.getKiePMMLModelCompilationUnit(dataDictionary, model, fieldTypeMap, packageName, TEMPLATE_SOURCE, TEMPLATE_CLASS_NAME);\n+        assertEquals(packageName, retrieved.getPackageDeclaration().get().getNameAsString());\n+        ConstructorDeclaration constructorDeclaration = retrieved.getClassByName(modelName).get().getDefaultConstructor().get();\n+        MINING_FUNCTION miningFunction = MINING_FUNCTION.CLASSIFICATION;\n+        PMML_MODEL pmmlModel = PMML_MODEL.byName(model.getClass().getSimpleName());\n+        Map<String, Expression> assignExpressionMap = new HashMap<>();\n+        assignExpressionMap.put(\"targetField\", new StringLiteralExpr(targetFieldString));\n+        assignExpressionMap.put(\"miningFunction\", new NameExpr(miningFunction.getClass().getName() + \".\" + miningFunction.name()));\n+        assignExpressionMap.put(\"pmmlMODEL\", new NameExpr(pmmlModel.getClass().getName() + \".\" + pmmlModel.name()));\n+        commonEvaluateAssignExpr(constructorDeclaration.getBody(), assignExpressionMap);\n+        int expectedMethodCallExprs = assignExpressionMap.size() + fieldTypeMap.size() + 1; // The last \"1\" is for the super invocation\n+        commonEvaluateFieldTypeMap(constructorDeclaration.getBody(), fieldTypeMap, expectedMethodCallExprs);\n+    }\n+\n+    @Test\n+    public void setConstructor() {\n+        Model model = new TreeModel();\n+        PMML_MODEL pmmlModel = PMML_MODEL.byName(model.getClass().getSimpleName());\n+        ConstructorDeclaration constructorDeclaration = MODEL_TEMPLATE.getDefaultConstructor().get();\n+        SimpleName tableName = new SimpleName(\"TABLE_NAME\");\n+        String targetField = \"TARGET_FIELD\";\n+        MINING_FUNCTION miningFunction = MINING_FUNCTION.CLASSIFICATION;\n+        KiePMMLDroolsModelFactoryUtils.setConstructor(model, constructorDeclaration, tableName, targetField, miningFunction);\n+        assertEquals(tableName, constructorDeclaration.getName());\n+        Map<String, Expression> assignExpressionMap = new HashMap<>();\n+        assignExpressionMap.put(\"targetField\", new StringLiteralExpr(targetField));\n+        assignExpressionMap.put(\"miningFunction\", new NameExpr(miningFunction.getClass().getName() + \".\" + miningFunction.name()));\n+        assignExpressionMap.put(\"pmmlMODEL\", new NameExpr(pmmlModel.getClass().getName() + \".\" + pmmlModel.name()));\n+        commonEvaluateAssignExpr(constructorDeclaration.getBody(), assignExpressionMap);\n+    }\n+\n+    @Test\n+    public void addOutputFieldsPopulation() {\n+        BlockStmt blockStmt = new BlockStmt();\n+        List<KiePMMLOutputField> outputFields = IntStream.range(0, 3)\n+                .mapToObj(index -> KiePMMLOutputField.builder(\"OUTPUTFIELD-\" + index, Collections.emptyList())\n+                        .withRank(new Random().nextInt(3))\n+                        .withValue(\"VALUE-\" + index)\n+                        .withTargetField(\"TARGETFIELD-\" + index)\n+                        .build())\n+                .collect(Collectors.toList());\n+        KiePMMLDroolsModelFactoryUtils.addOutputFieldsPopulation(blockStmt, outputFields);\n+        List<MethodCallExpr> retrieved = getMethodCallExprList(blockStmt, outputFields.size(), \"outputFields\", \"add\");\n+        for (KiePMMLOutputField outputField : outputFields) {\n+            assertTrue(retrieved.stream()\n+                               .filter(methodCallExpr -> methodCallExpr.getArguments().size() == 1)\n+                               .map(methodCallExpr -> methodCallExpr.getArgument(0))\n+                               .filter(Expression::isMethodCallExpr)\n+                               .map(expressionArgument -> (MethodCallExpr) expressionArgument)\n+                               .anyMatch(methodCallExpr -> {\n+                                   boolean toReturn = commonEvaluateMethodCallExpr(methodCallExpr, \"build\", new NodeList<>(), MethodCallExpr.class);\n+                                   MethodCallExpr resultFeatureScopeExpr = (MethodCallExpr) methodCallExpr.getScope().get();\n+                                   NodeList<Expression> expectedArguments = NodeList.nodeList(new NameExpr(RESULT_FEATURE.class.getName() + \".\" + outputField.getResultFeature().toString()));\n+                                   toReturn &= commonEvaluateMethodCallExpr(resultFeatureScopeExpr, \"withResultFeature\", expectedArguments, MethodCallExpr.class);\n+                                   MethodCallExpr targetFieldScopeExpr = (MethodCallExpr) resultFeatureScopeExpr.getScope().get();\n+                                   expectedArguments = NodeList.nodeList(new StringLiteralExpr(outputField.getTargetField().get()));\n+                                   toReturn &= commonEvaluateMethodCallExpr(targetFieldScopeExpr, \"withTargetField\", expectedArguments, MethodCallExpr.class);\n+                                   MethodCallExpr valueScopeExpr = (MethodCallExpr) targetFieldScopeExpr.getScope().get();\n+                                   expectedArguments = NodeList.nodeList(new StringLiteralExpr(outputField.getValue().toString()));\n+                                   toReturn &= commonEvaluateMethodCallExpr(valueScopeExpr, \"withValue\", expectedArguments, MethodCallExpr.class);\n+                                   MethodCallExpr rankScopeExpr = (MethodCallExpr) valueScopeExpr.getScope().get();\n+                                   expectedArguments = NodeList.nodeList(new IntegerLiteralExpr(outputField.getRank()));\n+                                   toReturn &= commonEvaluateMethodCallExpr(rankScopeExpr, \"withRank\", expectedArguments, MethodCallExpr.class);\n+                                   MethodCallExpr builderScopeExpr = (MethodCallExpr) rankScopeExpr.getScope().get();\n+                                   expectedArguments = NodeList.nodeList(new StringLiteralExpr(outputField.getName()), new NameExpr(\"Collections.emptyList()\"));\n+                                   toReturn &= commonEvaluateMethodCallExpr(builderScopeExpr, \"builder\", expectedArguments, NameExpr.class);\n+                                   toReturn &= builderScopeExpr.getName().equals(new SimpleName(\"builder\"));\n+                                   toReturn &= builderScopeExpr.getScope().get().equals(new NameExpr(\"KiePMMLOutputField\"));\n+                                   return toReturn;\n+                               }));\n+        }\n+    }\n+\n+    @Test\n+    public void addFieldTypeMapPopulation() {\n+        BlockStmt blockStmt = new BlockStmt();\n+        Map<String, KiePMMLOriginalTypeGeneratedType> fieldTypeMap = new HashMap<>();\n+        IntStream.range(0, 3).forEach(index -> {\n+            String key = \"KEY-\" + index;\n+            KiePMMLOriginalTypeGeneratedType value = new KiePMMLOriginalTypeGeneratedType(\"ORIGINALTYPE-\" + index, \"GENERATEDTYPE-\" + index);\n+            fieldTypeMap.put(key, value);\n+        });\n+        KiePMMLDroolsModelFactoryUtils.addFieldTypeMapPopulation(blockStmt, fieldTypeMap);\n+        commonEvaluateFieldTypeMap(blockStmt, fieldTypeMap, fieldTypeMap.size());\n+    }\n+\n+    private void commonEvaluateAssignExpr(BlockStmt blockStmt, Map<String, Expression> assignExpressionMap) {\n+        List<AssignExpr> retrieved = blockStmt.findAll(AssignExpr.class);\n+        for (Map.Entry<String, Expression> entry : assignExpressionMap.entrySet()) {\n+            assertTrue(retrieved.stream()\n+                               .filter(assignExpr -> assignExpr.getTarget().asNameExpr().equals(new NameExpr(entry.getKey())))\n+                               .anyMatch(assignExpr -> assignExpr.getValue().equals(entry.getValue())));\n+        }\n+    }\n+\n+    private void commonEvaluateFieldTypeMap(BlockStmt blockStmt, Map<String, KiePMMLOriginalTypeGeneratedType> fieldTypeMap, int expectedMethodCallSize) {\n+        List<MethodCallExpr> retrieved = getMethodCallExprList(blockStmt, expectedMethodCallSize, \"fieldTypeMap\", \"put\");\n+        for (Map.Entry<String, KiePMMLOriginalTypeGeneratedType> entry : fieldTypeMap.entrySet()) {\n+            assertTrue(retrieved.stream()\n+                               .map(MethodCallExpr::getArguments)\n+                               .anyMatch(arguments -> {\n+                                   boolean toReturn = arguments.size() == 2;\n+                                   Expression firstArgument = arguments.get(0);\n+                                   Expression secondArgument = arguments.get(1);\n+                                   toReturn &= firstArgument.isStringLiteralExpr() && ((StringLiteralExpr) firstArgument).getValue().equals(entry.getKey());\n+                                   toReturn &= secondArgument.isObjectCreationExpr() &&\n+                                           ((ObjectCreationExpr) secondArgument).getArgument(0).isStringLiteralExpr() &&\n+                                           ((StringLiteralExpr) ((ObjectCreationExpr) secondArgument).getArgument(0)).getValue().equals(entry.getValue().getOriginalType()) &&\n+                                           ((ObjectCreationExpr) secondArgument).getArgument(1).isStringLiteralExpr() &&\n+                                           ((StringLiteralExpr) ((ObjectCreationExpr) secondArgument).getArgument(1)).getValue().equals(entry.getValue().getGeneratedType());\n+                                   return toReturn;", "originalCommit": "e6700161dc7d042bcbd9fb14b0f4e30209f510b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEyNDYxMA==", "url": "https://github.com/kiegroup/drools/pull/2930#discussion_r435124610", "bodyText": "@danielezonca\ndone", "author": "gitgabrio", "createdAt": "2020-06-04T09:39:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwODc3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwOTAzMQ==", "url": "https://github.com/kiegroup/drools/pull/2930#discussion_r435109031", "bodyText": "Can you please move this logic to a method to improve code readability?\n(minor note, fix indent)", "author": "danielezonca", "createdAt": "2020-06-04T09:14:09Z", "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-drools/kie-pmml-models-drools-common/src/test/java/org/kie/pmml/models/drools/utils/KiePMMLDroolsModelFactoryUtilsTest.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.pmml.models.drools.utils;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Random;\n+import java.util.Spliterator;\n+import java.util.Spliterators;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.IntegerLiteralExpr;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import com.github.javaparser.ast.stmt.ExpressionStmt;\n+import com.github.javaparser.ast.stmt.Statement;\n+import org.dmg.pmml.DataDictionary;\n+import org.dmg.pmml.DataField;\n+import org.dmg.pmml.DataType;\n+import org.dmg.pmml.FieldName;\n+import org.dmg.pmml.MiningField;\n+import org.dmg.pmml.MiningFunction;\n+import org.dmg.pmml.MiningSchema;\n+import org.dmg.pmml.Model;\n+import org.dmg.pmml.OpType;\n+import org.dmg.pmml.tree.TreeModel;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.kie.pmml.commons.model.KiePMMLOutputField;\n+import org.kie.pmml.commons.model.enums.MINING_FUNCTION;\n+import org.kie.pmml.commons.model.enums.PMML_MODEL;\n+import org.kie.pmml.commons.model.enums.RESULT_FEATURE;\n+import org.kie.pmml.models.drools.tuples.KiePMMLOriginalTypeGeneratedType;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedClassName;\n+import static org.kie.pmml.compiler.commons.utils.JavaParserUtils.getFromFileName;\n+\n+public class KiePMMLDroolsModelFactoryUtilsTest {\n+\n+    private static final String TEMPLATE_SOURCE = \"Template.tmpl\";\n+    private static final String TEMPLATE_CLASS_NAME = \"Template\";\n+\n+    private static CompilationUnit COMPILATION_UNIT;\n+    private static ClassOrInterfaceDeclaration MODEL_TEMPLATE;\n+\n+    @BeforeClass\n+    public static void setup() {\n+        COMPILATION_UNIT = getFromFileName(TEMPLATE_SOURCE);\n+        MODEL_TEMPLATE = COMPILATION_UNIT.getClassByName(TEMPLATE_CLASS_NAME).get();\n+    }\n+\n+    @Test\n+    public void getKiePMMLModelCompilationUnit() {\n+        DataDictionary dataDictionary = new DataDictionary();\n+        String targetFieldString = \"target.field\";\n+        FieldName targetFieldName = FieldName.create(targetFieldString);\n+        dataDictionary.addDataFields(new DataField(targetFieldName, OpType.CONTINUOUS, DataType.DOUBLE));\n+        String modelName = \"ModelName\";\n+        Model model = new TreeModel();\n+        model.setModelName(modelName);\n+        model.setMiningFunction(MiningFunction.CLASSIFICATION);\n+        MiningField targetMiningField = new MiningField(targetFieldName);\n+        targetMiningField.setUsageType(MiningField.UsageType.TARGET);\n+        MiningSchema miningSchema = new MiningSchema();\n+        miningSchema.addMiningFields(targetMiningField);\n+        model.setMiningSchema(miningSchema);\n+        Map<String, KiePMMLOriginalTypeGeneratedType> fieldTypeMap = new HashMap<>();\n+        fieldTypeMap.put(targetFieldString, new KiePMMLOriginalTypeGeneratedType(targetFieldString, getSanitizedClassName(targetFieldString)));\n+        String packageName = \"net.test\";\n+        CompilationUnit retrieved = KiePMMLDroolsModelFactoryUtils.getKiePMMLModelCompilationUnit(dataDictionary, model, fieldTypeMap, packageName, TEMPLATE_SOURCE, TEMPLATE_CLASS_NAME);\n+        assertEquals(packageName, retrieved.getPackageDeclaration().get().getNameAsString());\n+        ConstructorDeclaration constructorDeclaration = retrieved.getClassByName(modelName).get().getDefaultConstructor().get();\n+        MINING_FUNCTION miningFunction = MINING_FUNCTION.CLASSIFICATION;\n+        PMML_MODEL pmmlModel = PMML_MODEL.byName(model.getClass().getSimpleName());\n+        Map<String, Expression> assignExpressionMap = new HashMap<>();\n+        assignExpressionMap.put(\"targetField\", new StringLiteralExpr(targetFieldString));\n+        assignExpressionMap.put(\"miningFunction\", new NameExpr(miningFunction.getClass().getName() + \".\" + miningFunction.name()));\n+        assignExpressionMap.put(\"pmmlMODEL\", new NameExpr(pmmlModel.getClass().getName() + \".\" + pmmlModel.name()));\n+        commonEvaluateAssignExpr(constructorDeclaration.getBody(), assignExpressionMap);\n+        int expectedMethodCallExprs = assignExpressionMap.size() + fieldTypeMap.size() + 1; // The last \"1\" is for the super invocation\n+        commonEvaluateFieldTypeMap(constructorDeclaration.getBody(), fieldTypeMap, expectedMethodCallExprs);\n+    }\n+\n+    @Test\n+    public void setConstructor() {\n+        Model model = new TreeModel();\n+        PMML_MODEL pmmlModel = PMML_MODEL.byName(model.getClass().getSimpleName());\n+        ConstructorDeclaration constructorDeclaration = MODEL_TEMPLATE.getDefaultConstructor().get();\n+        SimpleName tableName = new SimpleName(\"TABLE_NAME\");\n+        String targetField = \"TARGET_FIELD\";\n+        MINING_FUNCTION miningFunction = MINING_FUNCTION.CLASSIFICATION;\n+        KiePMMLDroolsModelFactoryUtils.setConstructor(model, constructorDeclaration, tableName, targetField, miningFunction);\n+        assertEquals(tableName, constructorDeclaration.getName());\n+        Map<String, Expression> assignExpressionMap = new HashMap<>();\n+        assignExpressionMap.put(\"targetField\", new StringLiteralExpr(targetField));\n+        assignExpressionMap.put(\"miningFunction\", new NameExpr(miningFunction.getClass().getName() + \".\" + miningFunction.name()));\n+        assignExpressionMap.put(\"pmmlMODEL\", new NameExpr(pmmlModel.getClass().getName() + \".\" + pmmlModel.name()));\n+        commonEvaluateAssignExpr(constructorDeclaration.getBody(), assignExpressionMap);\n+    }\n+\n+    @Test\n+    public void addOutputFieldsPopulation() {\n+        BlockStmt blockStmt = new BlockStmt();\n+        List<KiePMMLOutputField> outputFields = IntStream.range(0, 3)\n+                .mapToObj(index -> KiePMMLOutputField.builder(\"OUTPUTFIELD-\" + index, Collections.emptyList())\n+                        .withRank(new Random().nextInt(3))\n+                        .withValue(\"VALUE-\" + index)\n+                        .withTargetField(\"TARGETFIELD-\" + index)\n+                        .build())\n+                .collect(Collectors.toList());\n+        KiePMMLDroolsModelFactoryUtils.addOutputFieldsPopulation(blockStmt, outputFields);\n+        List<MethodCallExpr> retrieved = getMethodCallExprList(blockStmt, outputFields.size(), \"outputFields\", \"add\");\n+        for (KiePMMLOutputField outputField : outputFields) {\n+            assertTrue(retrieved.stream()\n+                               .filter(methodCallExpr -> methodCallExpr.getArguments().size() == 1)\n+                               .map(methodCallExpr -> methodCallExpr.getArgument(0))\n+                               .filter(Expression::isMethodCallExpr)\n+                               .map(expressionArgument -> (MethodCallExpr) expressionArgument)\n+                               .anyMatch(methodCallExpr -> {\n+                                   boolean toReturn = commonEvaluateMethodCallExpr(methodCallExpr, \"build\", new NodeList<>(), MethodCallExpr.class);\n+                                   MethodCallExpr resultFeatureScopeExpr = (MethodCallExpr) methodCallExpr.getScope().get();\n+                                   NodeList<Expression> expectedArguments = NodeList.nodeList(new NameExpr(RESULT_FEATURE.class.getName() + \".\" + outputField.getResultFeature().toString()));\n+                                   toReturn &= commonEvaluateMethodCallExpr(resultFeatureScopeExpr, \"withResultFeature\", expectedArguments, MethodCallExpr.class);\n+                                   MethodCallExpr targetFieldScopeExpr = (MethodCallExpr) resultFeatureScopeExpr.getScope().get();\n+                                   expectedArguments = NodeList.nodeList(new StringLiteralExpr(outputField.getTargetField().get()));\n+                                   toReturn &= commonEvaluateMethodCallExpr(targetFieldScopeExpr, \"withTargetField\", expectedArguments, MethodCallExpr.class);\n+                                   MethodCallExpr valueScopeExpr = (MethodCallExpr) targetFieldScopeExpr.getScope().get();\n+                                   expectedArguments = NodeList.nodeList(new StringLiteralExpr(outputField.getValue().toString()));\n+                                   toReturn &= commonEvaluateMethodCallExpr(valueScopeExpr, \"withValue\", expectedArguments, MethodCallExpr.class);\n+                                   MethodCallExpr rankScopeExpr = (MethodCallExpr) valueScopeExpr.getScope().get();\n+                                   expectedArguments = NodeList.nodeList(new IntegerLiteralExpr(outputField.getRank()));\n+                                   toReturn &= commonEvaluateMethodCallExpr(rankScopeExpr, \"withRank\", expectedArguments, MethodCallExpr.class);\n+                                   MethodCallExpr builderScopeExpr = (MethodCallExpr) rankScopeExpr.getScope().get();\n+                                   expectedArguments = NodeList.nodeList(new StringLiteralExpr(outputField.getName()), new NameExpr(\"Collections.emptyList()\"));\n+                                   toReturn &= commonEvaluateMethodCallExpr(builderScopeExpr, \"builder\", expectedArguments, NameExpr.class);\n+                                   toReturn &= builderScopeExpr.getName().equals(new SimpleName(\"builder\"));\n+                                   toReturn &= builderScopeExpr.getScope().get().equals(new NameExpr(\"KiePMMLOutputField\"));\n+                                   return toReturn;\n+                               }));\n+        }\n+    }\n+\n+    @Test\n+    public void addFieldTypeMapPopulation() {\n+        BlockStmt blockStmt = new BlockStmt();\n+        Map<String, KiePMMLOriginalTypeGeneratedType> fieldTypeMap = new HashMap<>();\n+        IntStream.range(0, 3).forEach(index -> {\n+            String key = \"KEY-\" + index;\n+            KiePMMLOriginalTypeGeneratedType value = new KiePMMLOriginalTypeGeneratedType(\"ORIGINALTYPE-\" + index, \"GENERATEDTYPE-\" + index);\n+            fieldTypeMap.put(key, value);\n+        });\n+        KiePMMLDroolsModelFactoryUtils.addFieldTypeMapPopulation(blockStmt, fieldTypeMap);\n+        commonEvaluateFieldTypeMap(blockStmt, fieldTypeMap, fieldTypeMap.size());\n+    }\n+\n+    private void commonEvaluateAssignExpr(BlockStmt blockStmt, Map<String, Expression> assignExpressionMap) {\n+        List<AssignExpr> retrieved = blockStmt.findAll(AssignExpr.class);\n+        for (Map.Entry<String, Expression> entry : assignExpressionMap.entrySet()) {\n+            assertTrue(retrieved.stream()\n+                               .filter(assignExpr -> assignExpr.getTarget().asNameExpr().equals(new NameExpr(entry.getKey())))\n+                               .anyMatch(assignExpr -> assignExpr.getValue().equals(entry.getValue())));\n+        }\n+    }\n+\n+    private void commonEvaluateFieldTypeMap(BlockStmt blockStmt, Map<String, KiePMMLOriginalTypeGeneratedType> fieldTypeMap, int expectedMethodCallSize) {\n+        List<MethodCallExpr> retrieved = getMethodCallExprList(blockStmt, expectedMethodCallSize, \"fieldTypeMap\", \"put\");\n+        for (Map.Entry<String, KiePMMLOriginalTypeGeneratedType> entry : fieldTypeMap.entrySet()) {\n+            assertTrue(retrieved.stream()\n+                               .map(MethodCallExpr::getArguments)\n+                               .anyMatch(arguments -> {\n+                                   boolean toReturn = arguments.size() == 2;\n+                                   Expression firstArgument = arguments.get(0);\n+                                   Expression secondArgument = arguments.get(1);\n+                                   toReturn &= firstArgument.isStringLiteralExpr() && ((StringLiteralExpr) firstArgument).getValue().equals(entry.getKey());\n+                                   toReturn &= secondArgument.isObjectCreationExpr() &&\n+                                           ((ObjectCreationExpr) secondArgument).getArgument(0).isStringLiteralExpr() &&\n+                                           ((StringLiteralExpr) ((ObjectCreationExpr) secondArgument).getArgument(0)).getValue().equals(entry.getValue().getOriginalType()) &&\n+                                           ((ObjectCreationExpr) secondArgument).getArgument(1).isStringLiteralExpr() &&\n+                                           ((StringLiteralExpr) ((ObjectCreationExpr) secondArgument).getArgument(1)).getValue().equals(entry.getValue().getGeneratedType());\n+                                   return toReturn;\n+                               }));\n+        }\n+    }\n+\n+    private boolean commonEvaluateMethodCallExpr(MethodCallExpr toEvaluate, String name, NodeList<Expression> expectedArguments, Class<? extends Expression> expectedScopeType) {\n+        boolean toReturn = Objects.equals(new SimpleName(name), toEvaluate.getName());\n+        toReturn &= expectedArguments.size() == toEvaluate.getArguments().size();\n+        for (int i = 0; i < expectedArguments.size(); i++) {\n+            toReturn &= expectedArguments.get(i).equals(toEvaluate.getArgument(i));\n+        }\n+        if (expectedScopeType != null) {\n+            toReturn &= toEvaluate.getScope().isPresent() && toEvaluate.getScope().get().getClass().equals(expectedScopeType);\n+        }\n+        return toReturn;\n+    }\n+\n+    private List<MethodCallExpr> getMethodCallExprList(BlockStmt blockStmt, int expectedSize, String scope, String method) {\n+        Stream<Statement> statementStream = getStatementStream(blockStmt, expectedSize);\n+        return statementStream\n+                .filter(Statement::isExpressionStmt)\n+                .map(expressionStmt -> ((ExpressionStmt) expressionStmt).getExpression())\n+                .filter(expression -> expression instanceof MethodCallExpr)\n+                .map(expression -> (MethodCallExpr) expression)\n+                .filter(methodCallExpr ->\n+                                methodCallExpr.getScope().isPresent() &&\n+                                        methodCallExpr.getScope().get().isNameExpr() &&\n+                                        ((NameExpr) methodCallExpr.getScope().get()).getName().asString().equals(scope) &&\n+                                        methodCallExpr.getName().asString().equals(method))", "originalCommit": "e6700161dc7d042bcbd9fb14b0f4e30209f510b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEyNDU2NA==", "url": "https://github.com/kiegroup/drools/pull/2930#discussion_r435124564", "bodyText": "@danielezonca\ndone", "author": "gitgabrio", "createdAt": "2020-06-04T09:39:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwOTAzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwOTkzNw==", "url": "https://github.com/kiegroup/drools/pull/2930#discussion_r435109937", "bodyText": "Can you please add className to error message?", "author": "danielezonca", "createdAt": "2020-06-04T09:15:34Z", "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-drools/kie-pmml-models-drools-scorecard/kie-pmml-models-drools-scorecard-compiler/src/main/java/org/kie/pmml/models/drools/scorecard/compiler/factories/KiePMMLScorecardModelFactory.java", "diffHunk": "@@ -79,22 +65,14 @@ public static KiePMMLScorecardModel getKiePMMLScorecardModel(DataDictionary data\n         return (KiePMMLScorecardModel) compiledClasses.get(fullClassName).newInstance();\n     }\n \n-    public static Map<String, String> getKiePMMLScorecardModelSourcesMap(final DataDictionary dataDictionary, final Scorecard model, final Map<String, KiePMMLOriginalTypeGeneratedType> fieldTypeMap, final String packageName) throws IOException {\n+    public static Map<String, String> getKiePMMLScorecardModelSourcesMap(final DataDictionary dataDictionary, final Scorecard model, final Map<String, KiePMMLOriginalTypeGeneratedType> fieldTypeMap, final String packageName) {\n         logger.trace(\"getKiePMMLScorecardModelSourcesMap {} {} {}\", dataDictionary, model, packageName);\n+        CompilationUnit cloneCU = getKiePMMLModelCompilationUnit(dataDictionary, model, fieldTypeMap, packageName, KIE_PMML_SCORECARD_MODEL_TEMPLATE_JAVA, KIE_PMML_SCORECARD_MODEL_TEMPLATE);\n         String className = getSanitizedClassName(model.getModelName());\n-        String targetField = getTargetFieldName(dataDictionary, model).orElse(null);\n-        List<KiePMMLOutputField> outputFields = getOutputFields(model);\n-        CompilationUnit templateCU = getFromFileName(KIE_PMML_SCORECARD_MODEL_TEMPLATE_JAVA);\n-        CompilationUnit cloneCU = templateCU.clone();\n-        cloneCU.setPackageDeclaration(packageName);\n-        ClassOrInterfaceDeclaration modelTemplate = cloneCU.getClassByName(KIE_PMML_SCORECARD_MODEL_TEMPLATE)\n-                .orElseThrow(() -> new RuntimeException(MAIN_CLASS_NOT_FOUND));\n-        modelTemplate.setName(className);\n-        MINING_FUNCTION miningFunction = MINING_FUNCTION.byName(model.getMiningFunction().value());\n+        ClassOrInterfaceDeclaration modelTemplate = cloneCU.getClassByName(className)\n+                .orElseThrow(() -> new KiePMMLException(MAIN_CLASS_NOT_FOUND));", "originalCommit": "e6700161dc7d042bcbd9fb14b0f4e30209f510b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEyNDUzOA==", "url": "https://github.com/kiegroup/drools/pull/2930#discussion_r435124538", "bodyText": "@danielezonca\ndone", "author": "gitgabrio", "createdAt": "2020-06-04T09:39:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwOTkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTExMDQ3OA==", "url": "https://github.com/kiegroup/drools/pull/2930#discussion_r435110478", "bodyText": "Can you please add className to error message?", "author": "danielezonca", "createdAt": "2020-06-04T09:16:29Z", "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-drools/kie-pmml-models-drools-tree/kie-pmml-models-drools-tree-compiler/src/main/java/org/kie/pmml/models/drools/tree/compiler/factories/KiePMMLTreeModelFactory.java", "diffHunk": "@@ -40,19 +48,38 @@\n \n     private static final Logger logger = LoggerFactory.getLogger(KiePMMLTreeModelFactory.class.getName());\n \n+    private static final String KIE_PMML_TREE_MODEL_TEMPLATE_JAVA = \"KiePMMLTreeModelTemplate.tmpl\";\n+    private static final String KIE_PMML_TREE_MODEL_TEMPLATE = \"KiePMMLTreeModelTemplate\";\n+\n     private KiePMMLTreeModelFactory() {\n+        // Avoid instantiation\n     }\n \n-    public static KiePMMLTreeModel getKiePMMLTreeModel(DataDictionary dataDictionary, TreeModel model, final Map<String, KiePMMLOriginalTypeGeneratedType> fieldTypeMap) {\n+    public static KiePMMLTreeModel getKiePMMLTreeModel(DataDictionary dataDictionary, TreeModel model, final Map<String, KiePMMLOriginalTypeGeneratedType> fieldTypeMap) throws IllegalAccessException, InstantiationException {\n         logger.trace(\"getKiePMMLTreeModel {}\", model);\n-        String name = model.getModelName();\n-        Optional<String> targetFieldName = getTargetFieldName(dataDictionary, model);\n-        final List<KiePMMLOutputField> outputFields = getOutputFields(model);\n-        return KiePMMLTreeModel.builder(name, Collections.emptyList(), MINING_FUNCTION.byName(model.getMiningFunction().value()), model.getAlgorithmName())\n-                .withOutputFields(outputFields)\n-                .withFieldTypeMap(fieldTypeMap)\n-                .withTargetField(targetFieldName.orElse(null))\n-                .build();\n+        String className = getSanitizedClassName(model.getModelName());\n+        String packageName = getSanitizedPackageName(className);\n+        Map<String, String> sourcesMap = getKiePMMLTreeModelSourcesMap(dataDictionary, model, fieldTypeMap, packageName);\n+        String fullClassName = packageName + \".\" + className;\n+        final Map<String, Class<?>> compiledClasses = KieMemoryCompiler.compile(sourcesMap, Thread.currentThread().getContextClassLoader());\n+        return (KiePMMLTreeModel) compiledClasses.get(fullClassName).newInstance();\n+    }\n+\n+    public static Map<String, String> getKiePMMLTreeModelSourcesMap(final DataDictionary dataDictionary,\n+                                                                    final TreeModel model,\n+                                                                    final Map<String, KiePMMLOriginalTypeGeneratedType> fieldTypeMap,\n+                                                                    final String packageName) {\n+        logger.trace(\"getKiePMMLTreeModelSourcesMap {} {} {}\", dataDictionary, model, packageName);\n+        CompilationUnit cloneCU = getKiePMMLModelCompilationUnit(dataDictionary, model, fieldTypeMap, packageName, KIE_PMML_TREE_MODEL_TEMPLATE_JAVA, KIE_PMML_TREE_MODEL_TEMPLATE);\n+        String className = getSanitizedClassName(model.getModelName());\n+        ClassOrInterfaceDeclaration modelTemplate = cloneCU.getClassByName(className)\n+                .orElseThrow(() -> new KiePMMLException(MAIN_CLASS_NOT_FOUND));", "originalCommit": "e6700161dc7d042bcbd9fb14b0f4e30209f510b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEyNDUwNw==", "url": "https://github.com/kiegroup/drools/pull/2930#discussion_r435124507", "bodyText": "@danielezonca\ndone", "author": "gitgabrio", "createdAt": "2020-06-04T09:39:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTExMDQ3OA=="}], "type": "inlineReview"}, {"oid": "db281405f309dc11db08582921a5ac455ba86679", "url": "https://github.com/kiegroup/drools/commit/db281405f309dc11db08582921a5ac455ba86679", "message": "[DROOLS-5381] Fixed as per PR request", "committedDate": "2020-06-04T09:39:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4OTM1Ng==", "url": "https://github.com/kiegroup/drools/pull/2930#discussion_r435289356", "bodyText": "Does this really avoid to create instances? It seems like public constructor.", "author": "jiripetrlik", "createdAt": "2020-06-04T14:11:44Z", "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-drools/kie-pmml-models-drools-common/src/main/java/org/kie/pmml/models/drools/utils/KiePMMLDroolsModelFactoryUtils.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.pmml.models.drools.utils;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.NodeList;\n+import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;\n+import com.github.javaparser.ast.body.ConstructorDeclaration;\n+import com.github.javaparser.ast.expr.AssignExpr;\n+import com.github.javaparser.ast.expr.Expression;\n+import com.github.javaparser.ast.expr.IntegerLiteralExpr;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.expr.ObjectCreationExpr;\n+import com.github.javaparser.ast.expr.SimpleName;\n+import com.github.javaparser.ast.expr.StringLiteralExpr;\n+import com.github.javaparser.ast.stmt.BlockStmt;\n+import org.dmg.pmml.DataDictionary;\n+import org.dmg.pmml.Model;\n+import org.kie.pmml.commons.exceptions.KiePMMLException;\n+import org.kie.pmml.commons.exceptions.KiePMMLInternalException;\n+import org.kie.pmml.commons.model.KiePMMLOutputField;\n+import org.kie.pmml.commons.model.enums.MINING_FUNCTION;\n+import org.kie.pmml.commons.model.enums.PMML_MODEL;\n+import org.kie.pmml.commons.model.enums.RESULT_FEATURE;\n+import org.kie.pmml.models.drools.tuples.KiePMMLOriginalTypeGeneratedType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.pmml.commons.utils.KiePMMLModelUtils.getSanitizedClassName;\n+import static org.kie.pmml.compiler.commons.factories.KiePMMLOutputFieldFactory.getOutputFields;\n+import static org.kie.pmml.compiler.commons.utils.JavaParserUtils.MAIN_CLASS_NOT_FOUND;\n+import static org.kie.pmml.compiler.commons.utils.JavaParserUtils.getFromFileName;\n+import static org.kie.pmml.compiler.commons.utils.ModelUtils.getTargetFieldName;\n+\n+/**\n+ * Utility class to provide common methods for KiePMMLDroolsModel-specific <b>factories</b>\n+ */\n+public class KiePMMLDroolsModelFactoryUtils {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(KiePMMLDroolsModelFactoryUtils.class.getName());\n+\n+    public KiePMMLDroolsModelFactoryUtils() {", "originalCommit": "db281405f309dc11db08582921a5ac455ba86679", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc5OTM3NQ==", "url": "https://github.com/kiegroup/drools/pull/2930#discussion_r435799375", "bodyText": "@jiripetrlik\nMy bad! Thanks for spotting that", "author": "gitgabrio", "createdAt": "2020-06-05T09:23:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4OTM1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI5MjM3OQ==", "url": "https://github.com/kiegroup/drools/pull/2930#discussion_r435292379", "bodyText": "What is the reason for removing logging from this class? I thing logging on trace level is fine.", "author": "jiripetrlik", "createdAt": "2020-06-04T14:15:49Z", "path": "kie-pmml-new/kie-pmml-models/kie-pmml-models-drools/kie-pmml-models-drools-tree/kie-pmml-models-drools-tree-compiler/src/main/java/org/kie/pmml/models/drools/tree/compiler/executor/TreeModelImplementationProvider.java", "diffHunk": "@@ -35,29 +34,27 @@\n  */\n public class TreeModelImplementationProvider extends DroolsModelProvider<TreeModel, KiePMMLTreeModel> {\n \n-    private static final Logger logger = LoggerFactory.getLogger(TreeModelImplementationProvider.class.getName());", "originalCommit": "db281405f309dc11db08582921a5ac455ba86679", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwMDYyOA==", "url": "https://github.com/kiegroup/drools/pull/2930#discussion_r435800628", "bodyText": "@jiripetrlik\nI'm trying to clean up things a little bit - all those \"trace\" were actually for \"development\" purpose, but I can not see a reason to have them when the code is merged.\nI would prefer to eventually add them if needed, but then at \"debug\" level", "author": "gitgabrio", "createdAt": "2020-06-05T09:25:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI5MjM3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgzNzc1MQ==", "url": "https://github.com/kiegroup/drools/pull/2930#discussion_r435837751", "bodyText": "@gitgabrio\nI think in general it is better to have as many logs as possible if these logs are in the proper level. User can specify which level he needs and avoid of unnecessary logs in production. But I think it does not block this PR and we can merge.", "author": "jiripetrlik", "createdAt": "2020-06-05T10:37:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI5MjM3OQ=="}], "type": "inlineReview"}, {"oid": "ff8914864af0d1a24906d67d4a553270b0920ae8", "url": "https://github.com/kiegroup/drools/commit/ff8914864af0d1a24906d67d4a553270b0920ae8", "message": "[DROOLS-5381] Fixed as per PR suggestion", "committedDate": "2020-06-05T09:26:32Z", "type": "commit"}]}