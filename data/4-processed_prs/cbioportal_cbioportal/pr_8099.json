{"pr_number": 8099, "pr_title": "Compress problematically large request bodies", "pr_createdAt": "2020-12-04T21:43:17Z", "pr_url": "https://github.com/cBioPortal/cbioportal/pull/8099", "timeline": [{"oid": "5e7e1237bd818f9c7af1c43ca921e785e6d6f0cb", "url": "https://github.com/cBioPortal/cbioportal/commit/5e7e1237bd818f9c7af1c43ca921e785e6d6f0cb", "message": "Compress problematically large request bodies\n\nProblem:\n- Some request bodies were so large (20+ Mb) that they resulted in\nsignificantly degraded performance for people with poor upload speeds\n\nSolution:\n- Create RequestBodyGZipFilter. It:\n  - Catches requests with a `Content-Encoding: gzip` header\n  - Reads and inflates the input stream\n  - Prevents excessively large requests from consuming too much memory\n- Add filter to web.xml\n- Add configurations for filter in portal.properties\n  - Feature toggle\n  - Inflated request body size limit\n- Add Content-Encoding header to list of accepted headers for\nCors filter.", "committedDate": "2020-12-07T19:06:47Z", "type": "forcePushed"}, {"oid": "e9aa85888fa2b4b4b1ed0cb0e49ea1a051921122", "url": "https://github.com/cBioPortal/cbioportal/commit/e9aa85888fa2b4b4b1ed0cb0e49ea1a051921122", "message": "Compress problematically large request bodies\n\nProblem:\n- Some request bodies were so large (20+ Mb) that they resulted in\nsignificantly degraded performance for people with poor upload speeds\n\nSolution:\n- Create RequestBodyGZipFilter. It:\n  - Catches requests with a `Content-Encoding: gzip` header\n  - Reads and inflates the input stream\n  - Prevents excessively large requests from consuming too much memory\n- Add filter to web.xml\n- Add configurations for filter in portal.properties\n  - Feature toggle\n  - Inflated request body size limit\n- Add Content-Encoding header to list of accepted headers for\nCors filter.", "committedDate": "2020-12-08T01:32:19Z", "type": "forcePushed"}, {"oid": "6234e71fa2f32b4f259091225403145f65cfe5f5", "url": "https://github.com/cBioPortal/cbioportal/commit/6234e71fa2f32b4f259091225403145f65cfe5f5", "message": "Compress problematically large request bodies\n\nProblem:\n- Some request bodies were so large (20+ Mb) that they resulted in\nsignificantly degraded performance for people with poor upload speeds\n\nSolution:\n- Create RequestBodyGZipFilter. It:\n  - Catches requests with a `Content-Encoding: gzip` header\n  - Reads and inflates the input stream\n  - Prevents excessively large requests from consuming too much memory\n- Add filter to web.xml\n- Add configurations for filter in portal.properties\n  - Feature toggle\n  - Inflated request body size limit\n- Add Content-Encoding header to list of accepted headers for\nCors filter.", "committedDate": "2020-12-08T01:44:59Z", "type": "forcePushed"}, {"oid": "9336b4cd7903af2e634b638f152f78f277cee580", "url": "https://github.com/cBioPortal/cbioportal/commit/9336b4cd7903af2e634b638f152f78f277cee580", "message": "Compress problematically large request bodies\n\nProblem:\n- Some request bodies were so large (20+ Mb) that they resulted in\nsignificantly degraded performance for people with poor upload speeds\n\nSolution:\n- Create RequestBodyGZipFilter. It:\n  - Catches requests with a `Content-Encoding: gzip` header\n  - Reads and inflates the input stream\n  - Prevents excessively large requests from consuming too much memory\n- Add filter to web.xml\n- Add configurations for filter in portal.properties\n  - Feature toggle\n  - Inflated request body size limit\n- Add Content-Encoding header to list of accepted headers for\nCors filter.", "committedDate": "2020-12-08T14:54:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU3NjQ2NA==", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r538576464", "bodyText": "CountingInputStream is marked as beta, but it works well, and I haven't found a more mature solution. Open to suggestions here.", "author": "Luke-Sikina", "createdAt": "2020-12-08T16:36:31Z", "path": "core/src/main/java/org/mskcc/cbio/portal/util/RequestBodyGZipFilter.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package org.mskcc.cbio.portal.util;\n+\n+import com.google.common.io.CountingInputStream;\n+import com.google.common.net.HttpHeaders;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.servlet.*;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletRequestWrapper;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.util.zip.GZIPInputStream;\n+\n+@Component(\"requestBodyGZipFilter\")\n+public class RequestBodyGZipFilter implements Filter {\n+    /**\n+     * We need to limit the size of the gzipped request bodies to avoid denial of memory attacks.\n+     * Because gzip can achieve text compression rates of around 1000x, without a common sense limit for\n+     * request body size, it would be very easy to send a request body that, when inflated, consumes the\n+     * entirety of a server's memory.\n+     */\n+    @Value(\"${request_gzip_body_size_bytes:50000000}\")\n+    private int maxInflatedRequestBodySize;\n+    \n+    @Value(\"${enable_request_body_compression:false}\")\n+    private boolean enabled;\n+\n+    @Override\n+    public void init(FilterConfig filterConfig) throws ServletException {\n+        // Nothing to init (Sonar asks you to comment if you leave a method empty)\n+    }\n+\n+    /**\n+     * Analyzes servlet request for possible gzipped body.\n+     * When Content-Encoding header has \"gzip\" value and request method is POST we read all the\n+     * gzipped stream and is it haz any data unzip it. In case when gzip Content-Encoding header\n+     * specified but body is not actually in gzip format we will throw ZipException.\n+     *\n+     * @param servletRequest  servlet request\n+     * @param servletResponse servlet response\n+     * @param chain           filter chain\n+     * @throws IOException      throws when fails\n+     * @throws ServletException thrown when fails\n+     */\n+    @Override\n+    public final void doFilter(\n+        final ServletRequest servletRequest,\n+        final ServletResponse servletResponse,\n+        final FilterChain chain\n+    ) throws IOException, ServletException {\n+        HttpServletRequest request = (HttpServletRequest) servletRequest;\n+        HttpServletResponse response = (HttpServletResponse) servletResponse;\n+        boolean isGzipped = request.getHeader(HttpHeaders.CONTENT_ENCODING) != null\n+            && request.getHeader(HttpHeaders.CONTENT_ENCODING).contains(\"gzip\");\n+        boolean requestTypeSupported = \"POST\".equals(request.getMethod());\n+\n+        if (isGzipped) {\n+            if (!enabled) {\n+                throw new IllegalStateException(\n+                    \"Received gzipped request body, but enable_request_body_compression is not set or is false\"\n+                );\n+            }\n+            if (!requestTypeSupported) {\n+                throw new IllegalStateException(\n+                    \"Received request with a Content-Encoding: gzip header and a request method of: \" +\n+                    request.getMethod()\n+                    + \" Only POST requests are supported.\"\n+                );\n+            }\n+\n+            request = new GzippedInputStreamWrapper((HttpServletRequest) servletRequest, maxInflatedRequestBodySize);\n+        }\n+\n+        chain.doFilter(request, response);\n+    }\n+    \n+    @Override\n+    public final void destroy() {\n+        // Nothing to destroy (Sonar asks you to comment if you leave a method empty)\n+    }\n+\n+    static class GzippedInputStreamWrapper extends HttpServletRequestWrapper {\n+        private final int maxInflatedRequestBodySize;\n+        private final CountingInputStream inputStream;", "originalCommit": "9336b4cd7903af2e634b638f152f78f277cee580", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU3ODM5OA==", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r538578398", "bodyText": "Interested if anyone has an idea on how to do this better.", "author": "Luke-Sikina", "createdAt": "2020-12-08T16:38:16Z", "path": "core/src/test/java/org/mskcc/cbio/portal/util/TestRequestBodyGZipFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.mskcc.cbio.portal.util;\n+\n+import com.google.common.net.HttpHeaders;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mockito;\n+import org.springframework.test.util.ReflectionTestUtils;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.stream.Collectors;\n+\n+public class TestRequestBodyGZipFilter {\n+\n+    /**\n+     * When I filter a request that doesn't have the gzip header,\n+     * the request should not be wrapped, and chain.doFilter should\n+     * be called on the same request object passed to the method.\n+     */\n+    @Test\n+    public void testDoFilterEnabledNotGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(null, \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+        \n+        // request should not be wrapped\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(request, response);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header, but the gzip\n+     * feature is disabled, the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterDisabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(false, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled, but the method is something other than POST,\n+     * the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterEnabledGZippedBadMethod() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"GET\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled and the method is POST, the doFilter method\n+     * should wrap the request with a GzippedInputStreamWrapper.\n+     * The BufferedReader for this GzippedInputStreamWrapper should return\n+     * the contents of the gzipped file used to create the original input stream.\n+     */\n+    @Test\n+    public void testDoFilterEnabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        // Not thrilled to be using the file system, but this was the most readable way to do this\n+        // that I could think of.\n+        // gzip_filter.json.gz is a gzip of a json file that contains the following: {\"field\":\"value\"}", "originalCommit": "9336b4cd7903af2e634b638f152f78f277cee580", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA5ODI4NA==", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541098284", "bodyText": "The total file size is 55 bytes .. perhaps it is reasonable to encode it directly as a byte array in code using escaped byte literals? The file is not human readable in any case (although I guess as a file it can be unzipped at the command line to \"look inside\" .. but the comment above handles that in the code.", "author": "sheridancbio", "createdAt": "2020-12-11T17:11:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU3ODM5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE0OTgzNA==", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541149834", "bodyText": "I like it. Thanks for the suggestion.", "author": "Luke-Sikina", "createdAt": "2020-12-11T18:38:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU3ODM5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA2NTE2NA==", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541065164", "bodyText": "\"and is it haz\" ... typos maybe?", "author": "sheridancbio", "createdAt": "2020-12-11T16:21:50Z", "path": "core/src/main/java/org/mskcc/cbio/portal/util/RequestBodyGZipFilter.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package org.mskcc.cbio.portal.util;\n+\n+import com.google.common.io.CountingInputStream;\n+import com.google.common.net.HttpHeaders;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.servlet.*;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletRequestWrapper;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.util.zip.GZIPInputStream;\n+\n+@Component(\"requestBodyGZipFilter\")\n+public class RequestBodyGZipFilter implements Filter {\n+    /**\n+     * We need to limit the size of the gzipped request bodies to avoid denial of memory attacks.\n+     * Because gzip can achieve text compression rates of around 1000x, without a common sense limit for\n+     * request body size, it would be very easy to send a request body that, when inflated, consumes the\n+     * entirety of a server's memory.\n+     */\n+    @Value(\"${request_gzip_body_size_bytes:50000000}\")\n+    private int maxInflatedRequestBodySize;\n+    \n+    @Value(\"${enable_request_body_compression:false}\")\n+    private boolean enabled;\n+\n+    @Override\n+    public void init(FilterConfig filterConfig) throws ServletException {\n+        // Nothing to init (Sonar asks you to comment if you leave a method empty)\n+    }\n+\n+    /**\n+     * Analyzes servlet request for possible gzipped body.\n+     * When Content-Encoding header has \"gzip\" value and request method is POST we read all the\n+     * gzipped stream and is it haz any data unzip it. In case when gzip Content-Encoding header", "originalCommit": "9336b4cd7903af2e634b638f152f78f277cee580", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA3MjY4MQ==", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541072681", "bodyText": "what do you think about moving this class outside to a new standalone class (same package)? At least the declarations in the testing class could be simplified? (no important really)", "author": "sheridancbio", "createdAt": "2020-12-11T16:32:43Z", "path": "core/src/main/java/org/mskcc/cbio/portal/util/RequestBodyGZipFilter.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package org.mskcc.cbio.portal.util;\n+\n+import com.google.common.io.CountingInputStream;\n+import com.google.common.net.HttpHeaders;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.servlet.*;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletRequestWrapper;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.util.zip.GZIPInputStream;\n+\n+@Component(\"requestBodyGZipFilter\")\n+public class RequestBodyGZipFilter implements Filter {\n+    /**\n+     * We need to limit the size of the gzipped request bodies to avoid denial of memory attacks.\n+     * Because gzip can achieve text compression rates of around 1000x, without a common sense limit for\n+     * request body size, it would be very easy to send a request body that, when inflated, consumes the\n+     * entirety of a server's memory.\n+     */\n+    @Value(\"${request_gzip_body_size_bytes:50000000}\")\n+    private int maxInflatedRequestBodySize;\n+    \n+    @Value(\"${enable_request_body_compression:false}\")\n+    private boolean enabled;\n+\n+    @Override\n+    public void init(FilterConfig filterConfig) throws ServletException {\n+        // Nothing to init (Sonar asks you to comment if you leave a method empty)\n+    }\n+\n+    /**\n+     * Analyzes servlet request for possible gzipped body.\n+     * When Content-Encoding header has \"gzip\" value and request method is POST we read all the\n+     * gzipped stream and is it haz any data unzip it. In case when gzip Content-Encoding header\n+     * specified but body is not actually in gzip format we will throw ZipException.\n+     *\n+     * @param servletRequest  servlet request\n+     * @param servletResponse servlet response\n+     * @param chain           filter chain\n+     * @throws IOException      throws when fails\n+     * @throws ServletException thrown when fails\n+     */\n+    @Override\n+    public final void doFilter(\n+        final ServletRequest servletRequest,\n+        final ServletResponse servletResponse,\n+        final FilterChain chain\n+    ) throws IOException, ServletException {\n+        HttpServletRequest request = (HttpServletRequest) servletRequest;\n+        HttpServletResponse response = (HttpServletResponse) servletResponse;\n+        boolean isGzipped = request.getHeader(HttpHeaders.CONTENT_ENCODING) != null\n+            && request.getHeader(HttpHeaders.CONTENT_ENCODING).contains(\"gzip\");\n+        boolean requestTypeSupported = \"POST\".equals(request.getMethod());\n+\n+        if (isGzipped) {\n+            if (!enabled) {\n+                throw new IllegalStateException(\n+                    \"Received gzipped request body, but enable_request_body_compression is not set or is false\"\n+                );\n+            }\n+            if (!requestTypeSupported) {\n+                throw new IllegalStateException(\n+                    \"Received request with a Content-Encoding: gzip header and a request method of: \" +\n+                    request.getMethod()\n+                    + \" Only POST requests are supported.\"\n+                );\n+            }\n+\n+            request = new GzippedInputStreamWrapper((HttpServletRequest) servletRequest, maxInflatedRequestBodySize);\n+        }\n+\n+        chain.doFilter(request, response);\n+    }\n+    \n+    @Override\n+    public final void destroy() {\n+        // Nothing to destroy (Sonar asks you to comment if you leave a method empty)\n+    }\n+\n+    static class GzippedInputStreamWrapper extends HttpServletRequestWrapper {", "originalCommit": "9336b4cd7903af2e634b638f152f78f277cee580", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA3NjE2MQ==", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541076161", "bodyText": "just wondering why the close() method below is @OverRide annotated, but not this read() method", "author": "sheridancbio", "createdAt": "2020-12-11T16:37:46Z", "path": "core/src/main/java/org/mskcc/cbio/portal/util/RequestBodyGZipFilter.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package org.mskcc.cbio.portal.util;\n+\n+import com.google.common.io.CountingInputStream;\n+import com.google.common.net.HttpHeaders;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.servlet.*;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletRequestWrapper;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.util.zip.GZIPInputStream;\n+\n+@Component(\"requestBodyGZipFilter\")\n+public class RequestBodyGZipFilter implements Filter {\n+    /**\n+     * We need to limit the size of the gzipped request bodies to avoid denial of memory attacks.\n+     * Because gzip can achieve text compression rates of around 1000x, without a common sense limit for\n+     * request body size, it would be very easy to send a request body that, when inflated, consumes the\n+     * entirety of a server's memory.\n+     */\n+    @Value(\"${request_gzip_body_size_bytes:50000000}\")\n+    private int maxInflatedRequestBodySize;\n+    \n+    @Value(\"${enable_request_body_compression:false}\")\n+    private boolean enabled;\n+\n+    @Override\n+    public void init(FilterConfig filterConfig) throws ServletException {\n+        // Nothing to init (Sonar asks you to comment if you leave a method empty)\n+    }\n+\n+    /**\n+     * Analyzes servlet request for possible gzipped body.\n+     * When Content-Encoding header has \"gzip\" value and request method is POST we read all the\n+     * gzipped stream and is it haz any data unzip it. In case when gzip Content-Encoding header\n+     * specified but body is not actually in gzip format we will throw ZipException.\n+     *\n+     * @param servletRequest  servlet request\n+     * @param servletResponse servlet response\n+     * @param chain           filter chain\n+     * @throws IOException      throws when fails\n+     * @throws ServletException thrown when fails\n+     */\n+    @Override\n+    public final void doFilter(\n+        final ServletRequest servletRequest,\n+        final ServletResponse servletResponse,\n+        final FilterChain chain\n+    ) throws IOException, ServletException {\n+        HttpServletRequest request = (HttpServletRequest) servletRequest;\n+        HttpServletResponse response = (HttpServletResponse) servletResponse;\n+        boolean isGzipped = request.getHeader(HttpHeaders.CONTENT_ENCODING) != null\n+            && request.getHeader(HttpHeaders.CONTENT_ENCODING).contains(\"gzip\");\n+        boolean requestTypeSupported = \"POST\".equals(request.getMethod());\n+\n+        if (isGzipped) {\n+            if (!enabled) {\n+                throw new IllegalStateException(\n+                    \"Received gzipped request body, but enable_request_body_compression is not set or is false\"\n+                );\n+            }\n+            if (!requestTypeSupported) {\n+                throw new IllegalStateException(\n+                    \"Received request with a Content-Encoding: gzip header and a request method of: \" +\n+                    request.getMethod()\n+                    + \" Only POST requests are supported.\"\n+                );\n+            }\n+\n+            request = new GzippedInputStreamWrapper((HttpServletRequest) servletRequest, maxInflatedRequestBodySize);\n+        }\n+\n+        chain.doFilter(request, response);\n+    }\n+    \n+    @Override\n+    public final void destroy() {\n+        // Nothing to destroy (Sonar asks you to comment if you leave a method empty)\n+    }\n+\n+    static class GzippedInputStreamWrapper extends HttpServletRequestWrapper {\n+        private final int maxInflatedRequestBodySize;\n+        private final CountingInputStream inputStream;\n+\n+        GzippedInputStreamWrapper(final HttpServletRequest request, int maxInflatedRequestBodySize) throws IOException {\n+            super(request);\n+            this.maxInflatedRequestBodySize = maxInflatedRequestBodySize;\n+            inputStream = new CountingInputStream(new GZIPInputStream(request.getInputStream()));\n+        }\n+\n+        @Override\n+        public ServletInputStream getInputStream() throws IOException {\n+            return new ServletInputStream() {\n+                public int read() throws IOException {", "originalCommit": "9336b4cd7903af2e634b638f152f78f277cee580", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA3ODIxMQ==", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541078211", "bodyText": "I guess the handler is only using the single byte at a time read() method?  Or should we also check the expanded size when using the other inputstream read() methods {  read(byte[]) and read(byte[], int, int) } ? The getReader() method below would also give access to the \"block at a time\" read methods (which are not checked for size yet)", "author": "sheridancbio", "createdAt": "2020-12-11T16:40:55Z", "path": "core/src/main/java/org/mskcc/cbio/portal/util/RequestBodyGZipFilter.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package org.mskcc.cbio.portal.util;\n+\n+import com.google.common.io.CountingInputStream;\n+import com.google.common.net.HttpHeaders;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import javax.servlet.*;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletRequestWrapper;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.util.zip.GZIPInputStream;\n+\n+@Component(\"requestBodyGZipFilter\")\n+public class RequestBodyGZipFilter implements Filter {\n+    /**\n+     * We need to limit the size of the gzipped request bodies to avoid denial of memory attacks.\n+     * Because gzip can achieve text compression rates of around 1000x, without a common sense limit for\n+     * request body size, it would be very easy to send a request body that, when inflated, consumes the\n+     * entirety of a server's memory.\n+     */\n+    @Value(\"${request_gzip_body_size_bytes:50000000}\")\n+    private int maxInflatedRequestBodySize;\n+    \n+    @Value(\"${enable_request_body_compression:false}\")\n+    private boolean enabled;\n+\n+    @Override\n+    public void init(FilterConfig filterConfig) throws ServletException {\n+        // Nothing to init (Sonar asks you to comment if you leave a method empty)\n+    }\n+\n+    /**\n+     * Analyzes servlet request for possible gzipped body.\n+     * When Content-Encoding header has \"gzip\" value and request method is POST we read all the\n+     * gzipped stream and is it haz any data unzip it. In case when gzip Content-Encoding header\n+     * specified but body is not actually in gzip format we will throw ZipException.\n+     *\n+     * @param servletRequest  servlet request\n+     * @param servletResponse servlet response\n+     * @param chain           filter chain\n+     * @throws IOException      throws when fails\n+     * @throws ServletException thrown when fails\n+     */\n+    @Override\n+    public final void doFilter(\n+        final ServletRequest servletRequest,\n+        final ServletResponse servletResponse,\n+        final FilterChain chain\n+    ) throws IOException, ServletException {\n+        HttpServletRequest request = (HttpServletRequest) servletRequest;\n+        HttpServletResponse response = (HttpServletResponse) servletResponse;\n+        boolean isGzipped = request.getHeader(HttpHeaders.CONTENT_ENCODING) != null\n+            && request.getHeader(HttpHeaders.CONTENT_ENCODING).contains(\"gzip\");\n+        boolean requestTypeSupported = \"POST\".equals(request.getMethod());\n+\n+        if (isGzipped) {\n+            if (!enabled) {\n+                throw new IllegalStateException(\n+                    \"Received gzipped request body, but enable_request_body_compression is not set or is false\"\n+                );\n+            }\n+            if (!requestTypeSupported) {\n+                throw new IllegalStateException(\n+                    \"Received request with a Content-Encoding: gzip header and a request method of: \" +\n+                    request.getMethod()\n+                    + \" Only POST requests are supported.\"\n+                );\n+            }\n+\n+            request = new GzippedInputStreamWrapper((HttpServletRequest) servletRequest, maxInflatedRequestBodySize);\n+        }\n+\n+        chain.doFilter(request, response);\n+    }\n+    \n+    @Override\n+    public final void destroy() {\n+        // Nothing to destroy (Sonar asks you to comment if you leave a method empty)\n+    }\n+\n+    static class GzippedInputStreamWrapper extends HttpServletRequestWrapper {\n+        private final int maxInflatedRequestBodySize;\n+        private final CountingInputStream inputStream;\n+\n+        GzippedInputStreamWrapper(final HttpServletRequest request, int maxInflatedRequestBodySize) throws IOException {\n+            super(request);\n+            this.maxInflatedRequestBodySize = maxInflatedRequestBodySize;\n+            inputStream = new CountingInputStream(new GZIPInputStream(request.getInputStream()));\n+        }\n+\n+        @Override\n+        public ServletInputStream getInputStream() throws IOException {\n+            return new ServletInputStream() {\n+                public int read() throws IOException {\n+                    if (inputStream.getCount() > maxInflatedRequestBodySize) {", "originalCommit": "9336b4cd7903af2e634b638f152f78f277cee580", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA4NzUwNg==", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541087506", "bodyText": "this is a new technique to me. Curious : did you try breaking the code so that the wrapping occurs even when the content_encoding header is not present? This test should fail under that condition right?", "author": "sheridancbio", "createdAt": "2020-12-11T16:54:35Z", "path": "core/src/test/java/org/mskcc/cbio/portal/util/TestRequestBodyGZipFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.mskcc.cbio.portal.util;\n+\n+import com.google.common.net.HttpHeaders;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mockito;\n+import org.springframework.test.util.ReflectionTestUtils;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.stream.Collectors;\n+\n+public class TestRequestBodyGZipFilter {\n+\n+    /**\n+     * When I filter a request that doesn't have the gzip header,\n+     * the request should not be wrapped, and chain.doFilter should\n+     * be called on the same request object passed to the method.\n+     */\n+    @Test\n+    public void testDoFilterEnabledNotGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(null, \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+        \n+        // request should not be wrapped\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(request, response);", "originalCommit": "9336b4cd7903af2e634b638f152f78f277cee580", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE0OTU0MA==", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541149540", "bodyText": "Prior to you asking, I didn't, because I was pretty confident that this worked. Now that you asked though, I have verified that this test fails under that condition. If doFilter is not called with those exact request and response objects, the test fails.", "author": "Luke-Sikina", "createdAt": "2020-12-11T18:38:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA4NzUwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA5MTU5NA==", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541091594", "bodyText": "the \"post\" argument name is improper ... sometimes the string coming in is \"GET\", so rename to \"command\" or \"httpCommand\"", "author": "sheridancbio", "createdAt": "2020-12-11T17:00:40Z", "path": "core/src/test/java/org/mskcc/cbio/portal/util/TestRequestBodyGZipFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.mskcc.cbio.portal.util;\n+\n+import com.google.common.net.HttpHeaders;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mockito;\n+import org.springframework.test.util.ReflectionTestUtils;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.stream.Collectors;\n+\n+public class TestRequestBodyGZipFilter {\n+\n+    /**\n+     * When I filter a request that doesn't have the gzip header,\n+     * the request should not be wrapped, and chain.doFilter should\n+     * be called on the same request object passed to the method.\n+     */\n+    @Test\n+    public void testDoFilterEnabledNotGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(null, \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+        \n+        // request should not be wrapped\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(request, response);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header, but the gzip\n+     * feature is disabled, the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterDisabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(false, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled, but the method is something other than POST,\n+     * the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterEnabledGZippedBadMethod() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"GET\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled and the method is POST, the doFilter method\n+     * should wrap the request with a GzippedInputStreamWrapper.\n+     * The BufferedReader for this GzippedInputStreamWrapper should return\n+     * the contents of the gzipped file used to create the original input stream.\n+     */\n+    @Test\n+    public void testDoFilterEnabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        // Not thrilled to be using the file system, but this was the most readable way to do this\n+        // that I could think of.\n+        // gzip_filter.json.gz is a gzip of a json file that contains the following: {\"field\":\"value\"}\n+        FileInputStream inputStream = new FileInputStream(\"src/test/resources/gzip_filter.json.gz\");\n+        TestInputStream stream = new TestInputStream(inputStream);\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        Mockito.when(request.getInputStream()).thenReturn(stream);\n+        \n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        \n+        subject.doFilter(request, response, chain);\n+\n+        // Request should be wrapped, so the request should now be a GzippedInputStreamWrapper\n+        ArgumentCaptor<RequestBodyGZipFilter.GzippedInputStreamWrapper> requestArg =\n+            ArgumentCaptor.forClass(RequestBodyGZipFilter.GzippedInputStreamWrapper.class);\n+        ArgumentCaptor<HttpServletResponse> responseArg = ArgumentCaptor.forClass(HttpServletResponse.class);\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(requestArg.capture(), responseArg.capture());\n+        RequestBodyGZipFilter.GzippedInputStreamWrapper wrappedStream = requestArg.getValue();\n+        \n+        String actualRequestBody = wrappedStream.getReader().lines().collect(Collectors.joining());\n+        String expectedRequestBody = \"{\\\"field\\\":\\\"value\\\"}\";\n+        Assert.assertEquals(expectedRequestBody, actualRequestBody);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled and the method is POST, but the unzipped message\n+     * body is larger than maxInflatedRequestBodySize, the doFilter method\n+     * should wrap the request with a GzippedInputStreamWrapper.\n+     * The BufferedReader for this GzippedInputStreamWrapper should throw an\n+     * IOException as it is read. This exception gets turned into\n+     * an UncheckedIOException by something, so we'll check for that instead.\n+     */\n+    @Test(expected = UncheckedIOException.class)\n+    public void testDoFilterEnabledGZippedButTooLong() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 1);\n+\n+        FileInputStream inputStream = new FileInputStream(\"src/test/resources/gzip_filter.json.gz\");\n+        TestInputStream stream = new TestInputStream(inputStream);\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        Mockito.when(request.getInputStream()).thenReturn(stream);\n+\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+\n+        subject.doFilter(request, response, chain);\n+\n+        // Request should be wrapped, so the request should now be a GzippedInputStreamWrapper\n+        ArgumentCaptor<RequestBodyGZipFilter.GzippedInputStreamWrapper> requestArg =\n+            ArgumentCaptor.forClass(RequestBodyGZipFilter.GzippedInputStreamWrapper.class);\n+        ArgumentCaptor<HttpServletResponse> responseArg = ArgumentCaptor.forClass(HttpServletResponse.class);\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(requestArg.capture(), responseArg.capture());\n+        RequestBodyGZipFilter.GzippedInputStreamWrapper wrappedStream = requestArg.getValue();\n+\n+        //this should cause an IOException\n+        wrappedStream.getReader().lines().collect(Collectors.joining());\n+    }\n+\n+\n+    private RequestBodyGZipFilter createRequestBodyGZipFilter(boolean enabled, int requestBodySize) {\n+        RequestBodyGZipFilter subject = new RequestBodyGZipFilter();\n+        ReflectionTestUtils.setField(subject, \"maxInflatedRequestBodySize\", requestBodySize);\n+        ReflectionTestUtils.setField(subject, \"enabled\", enabled);\n+        return subject;\n+    }\n+    \n+    private HttpServletRequest createHttpServletRequest(String gzip, String post) {", "originalCommit": "9336b4cd7903af2e634b638f152f78f277cee580", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE1MDU5OQ==", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541150599", "bodyText": "This is what happens when you click through Intellij's method refactoring too quickly. I've changed it to httpMethod", "author": "Luke-Sikina", "createdAt": "2020-12-11T18:40:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA5MTU5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA5NDgxNA==", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541094814", "bodyText": "The accepted strings for httpMethod can be referenced symbolically here perhaps? (from quick web search):\nhttps://javaee.github.io/javaee-spec/javadocs/javax/ws/rs/HttpMethod.html", "author": "sheridancbio", "createdAt": "2020-12-11T17:05:59Z", "path": "core/src/test/java/org/mskcc/cbio/portal/util/TestRequestBodyGZipFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.mskcc.cbio.portal.util;\n+\n+import com.google.common.net.HttpHeaders;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mockito;\n+import org.springframework.test.util.ReflectionTestUtils;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.stream.Collectors;\n+\n+public class TestRequestBodyGZipFilter {\n+\n+    /**\n+     * When I filter a request that doesn't have the gzip header,\n+     * the request should not be wrapped, and chain.doFilter should\n+     * be called on the same request object passed to the method.\n+     */\n+    @Test\n+    public void testDoFilterEnabledNotGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(null, \"POST\");", "originalCommit": "9336b4cd7903af2e634b638f152f78f277cee580", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA5NjM0Ng==", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541096346", "bodyText": "If we have not come up with a better way by the time we are ready to merge, we should drop this comment maybe", "author": "sheridancbio", "createdAt": "2020-12-11T17:08:28Z", "path": "core/src/test/java/org/mskcc/cbio/portal/util/TestRequestBodyGZipFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.mskcc.cbio.portal.util;\n+\n+import com.google.common.net.HttpHeaders;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mockito;\n+import org.springframework.test.util.ReflectionTestUtils;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.stream.Collectors;\n+\n+public class TestRequestBodyGZipFilter {\n+\n+    /**\n+     * When I filter a request that doesn't have the gzip header,\n+     * the request should not be wrapped, and chain.doFilter should\n+     * be called on the same request object passed to the method.\n+     */\n+    @Test\n+    public void testDoFilterEnabledNotGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(null, \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+        \n+        // request should not be wrapped\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(request, response);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header, but the gzip\n+     * feature is disabled, the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterDisabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(false, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled, but the method is something other than POST,\n+     * the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterEnabledGZippedBadMethod() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"GET\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled and the method is POST, the doFilter method\n+     * should wrap the request with a GzippedInputStreamWrapper.\n+     * The BufferedReader for this GzippedInputStreamWrapper should return\n+     * the contents of the gzipped file used to create the original input stream.\n+     */\n+    @Test\n+    public void testDoFilterEnabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        // Not thrilled to be using the file system, but this was the most readable way to do this", "originalCommit": "9336b4cd7903af2e634b638f152f78f277cee580", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA5OTg4NA==", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541099884", "bodyText": "don't need 2 blank lines here", "author": "sheridancbio", "createdAt": "2020-12-11T17:14:10Z", "path": "core/src/test/java/org/mskcc/cbio/portal/util/TestRequestBodyGZipFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.mskcc.cbio.portal.util;\n+\n+import com.google.common.net.HttpHeaders;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mockito;\n+import org.springframework.test.util.ReflectionTestUtils;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.stream.Collectors;\n+\n+public class TestRequestBodyGZipFilter {\n+\n+    /**\n+     * When I filter a request that doesn't have the gzip header,\n+     * the request should not be wrapped, and chain.doFilter should\n+     * be called on the same request object passed to the method.\n+     */\n+    @Test\n+    public void testDoFilterEnabledNotGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(null, \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+        \n+        // request should not be wrapped\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(request, response);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header, but the gzip\n+     * feature is disabled, the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterDisabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(false, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled, but the method is something other than POST,\n+     * the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterEnabledGZippedBadMethod() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"GET\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled and the method is POST, the doFilter method\n+     * should wrap the request with a GzippedInputStreamWrapper.\n+     * The BufferedReader for this GzippedInputStreamWrapper should return\n+     * the contents of the gzipped file used to create the original input stream.\n+     */\n+    @Test\n+    public void testDoFilterEnabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        // Not thrilled to be using the file system, but this was the most readable way to do this\n+        // that I could think of.\n+        // gzip_filter.json.gz is a gzip of a json file that contains the following: {\"field\":\"value\"}\n+        FileInputStream inputStream = new FileInputStream(\"src/test/resources/gzip_filter.json.gz\");\n+        TestInputStream stream = new TestInputStream(inputStream);\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        Mockito.when(request.getInputStream()).thenReturn(stream);\n+        \n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+", "originalCommit": "9336b4cd7903af2e634b638f152f78f277cee580", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEwMDU3OA==", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541100578", "bodyText": "mysterious", "author": "sheridancbio", "createdAt": "2020-12-11T17:15:16Z", "path": "core/src/test/java/org/mskcc/cbio/portal/util/TestRequestBodyGZipFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.mskcc.cbio.portal.util;\n+\n+import com.google.common.net.HttpHeaders;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mockito;\n+import org.springframework.test.util.ReflectionTestUtils;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.stream.Collectors;\n+\n+public class TestRequestBodyGZipFilter {\n+\n+    /**\n+     * When I filter a request that doesn't have the gzip header,\n+     * the request should not be wrapped, and chain.doFilter should\n+     * be called on the same request object passed to the method.\n+     */\n+    @Test\n+    public void testDoFilterEnabledNotGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(null, \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+        \n+        // request should not be wrapped\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(request, response);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header, but the gzip\n+     * feature is disabled, the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterDisabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(false, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled, but the method is something other than POST,\n+     * the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterEnabledGZippedBadMethod() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"GET\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled and the method is POST, the doFilter method\n+     * should wrap the request with a GzippedInputStreamWrapper.\n+     * The BufferedReader for this GzippedInputStreamWrapper should return\n+     * the contents of the gzipped file used to create the original input stream.\n+     */\n+    @Test\n+    public void testDoFilterEnabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        // Not thrilled to be using the file system, but this was the most readable way to do this\n+        // that I could think of.\n+        // gzip_filter.json.gz is a gzip of a json file that contains the following: {\"field\":\"value\"}\n+        FileInputStream inputStream = new FileInputStream(\"src/test/resources/gzip_filter.json.gz\");\n+        TestInputStream stream = new TestInputStream(inputStream);\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        Mockito.when(request.getInputStream()).thenReturn(stream);\n+        \n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        \n+        subject.doFilter(request, response, chain);\n+\n+        // Request should be wrapped, so the request should now be a GzippedInputStreamWrapper\n+        ArgumentCaptor<RequestBodyGZipFilter.GzippedInputStreamWrapper> requestArg =\n+            ArgumentCaptor.forClass(RequestBodyGZipFilter.GzippedInputStreamWrapper.class);\n+        ArgumentCaptor<HttpServletResponse> responseArg = ArgumentCaptor.forClass(HttpServletResponse.class);\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(requestArg.capture(), responseArg.capture());\n+        RequestBodyGZipFilter.GzippedInputStreamWrapper wrappedStream = requestArg.getValue();\n+        \n+        String actualRequestBody = wrappedStream.getReader().lines().collect(Collectors.joining());\n+        String expectedRequestBody = \"{\\\"field\\\":\\\"value\\\"}\";\n+        Assert.assertEquals(expectedRequestBody, actualRequestBody);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled and the method is POST, but the unzipped message\n+     * body is larger than maxInflatedRequestBodySize, the doFilter method\n+     * should wrap the request with a GzippedInputStreamWrapper.\n+     * The BufferedReader for this GzippedInputStreamWrapper should throw an\n+     * IOException as it is read. This exception gets turned into\n+     * an UncheckedIOException by something, so we'll check for that instead.", "originalCommit": "9336b4cd7903af2e634b638f152f78f277cee580", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEwMTgzMQ==", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541101831", "bodyText": "since the test is working we can conclude that the Reader returned gets used with only the read() method by .lines()\nthis construction at least is not using read(byte[])", "author": "sheridancbio", "createdAt": "2020-12-11T17:17:21Z", "path": "core/src/test/java/org/mskcc/cbio/portal/util/TestRequestBodyGZipFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.mskcc.cbio.portal.util;\n+\n+import com.google.common.net.HttpHeaders;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mockito;\n+import org.springframework.test.util.ReflectionTestUtils;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.stream.Collectors;\n+\n+public class TestRequestBodyGZipFilter {\n+\n+    /**\n+     * When I filter a request that doesn't have the gzip header,\n+     * the request should not be wrapped, and chain.doFilter should\n+     * be called on the same request object passed to the method.\n+     */\n+    @Test\n+    public void testDoFilterEnabledNotGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(null, \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+        \n+        // request should not be wrapped\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(request, response);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header, but the gzip\n+     * feature is disabled, the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterDisabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(false, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled, but the method is something other than POST,\n+     * the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterEnabledGZippedBadMethod() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"GET\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled and the method is POST, the doFilter method\n+     * should wrap the request with a GzippedInputStreamWrapper.\n+     * The BufferedReader for this GzippedInputStreamWrapper should return\n+     * the contents of the gzipped file used to create the original input stream.\n+     */\n+    @Test\n+    public void testDoFilterEnabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        // Not thrilled to be using the file system, but this was the most readable way to do this\n+        // that I could think of.\n+        // gzip_filter.json.gz is a gzip of a json file that contains the following: {\"field\":\"value\"}\n+        FileInputStream inputStream = new FileInputStream(\"src/test/resources/gzip_filter.json.gz\");\n+        TestInputStream stream = new TestInputStream(inputStream);\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        Mockito.when(request.getInputStream()).thenReturn(stream);\n+        \n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        \n+        subject.doFilter(request, response, chain);\n+\n+        // Request should be wrapped, so the request should now be a GzippedInputStreamWrapper\n+        ArgumentCaptor<RequestBodyGZipFilter.GzippedInputStreamWrapper> requestArg =\n+            ArgumentCaptor.forClass(RequestBodyGZipFilter.GzippedInputStreamWrapper.class);\n+        ArgumentCaptor<HttpServletResponse> responseArg = ArgumentCaptor.forClass(HttpServletResponse.class);\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(requestArg.capture(), responseArg.capture());\n+        RequestBodyGZipFilter.GzippedInputStreamWrapper wrappedStream = requestArg.getValue();\n+        \n+        String actualRequestBody = wrappedStream.getReader().lines().collect(Collectors.joining());\n+        String expectedRequestBody = \"{\\\"field\\\":\\\"value\\\"}\";\n+        Assert.assertEquals(expectedRequestBody, actualRequestBody);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled and the method is POST, but the unzipped message\n+     * body is larger than maxInflatedRequestBodySize, the doFilter method\n+     * should wrap the request with a GzippedInputStreamWrapper.\n+     * The BufferedReader for this GzippedInputStreamWrapper should throw an\n+     * IOException as it is read. This exception gets turned into\n+     * an UncheckedIOException by something, so we'll check for that instead.\n+     */\n+    @Test(expected = UncheckedIOException.class)\n+    public void testDoFilterEnabledGZippedButTooLong() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 1);\n+\n+        FileInputStream inputStream = new FileInputStream(\"src/test/resources/gzip_filter.json.gz\");\n+        TestInputStream stream = new TestInputStream(inputStream);\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        Mockito.when(request.getInputStream()).thenReturn(stream);\n+\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+\n+        subject.doFilter(request, response, chain);\n+\n+        // Request should be wrapped, so the request should now be a GzippedInputStreamWrapper\n+        ArgumentCaptor<RequestBodyGZipFilter.GzippedInputStreamWrapper> requestArg =\n+            ArgumentCaptor.forClass(RequestBodyGZipFilter.GzippedInputStreamWrapper.class);\n+        ArgumentCaptor<HttpServletResponse> responseArg = ArgumentCaptor.forClass(HttpServletResponse.class);\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(requestArg.capture(), responseArg.capture());\n+        RequestBodyGZipFilter.GzippedInputStreamWrapper wrappedStream = requestArg.getValue();\n+\n+        //this should cause an IOException\n+        wrappedStream.getReader().lines().collect(Collectors.joining());", "originalCommit": "9336b4cd7903af2e634b638f152f78f277cee580", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEwMjA3OA==", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541102078", "bodyText": "double blank line", "author": "sheridancbio", "createdAt": "2020-12-11T17:17:47Z", "path": "core/src/test/java/org/mskcc/cbio/portal/util/TestRequestBodyGZipFilter.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.mskcc.cbio.portal.util;\n+\n+import com.google.common.net.HttpHeaders;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mockito;\n+import org.springframework.test.util.ReflectionTestUtils;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletInputStream;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.stream.Collectors;\n+\n+public class TestRequestBodyGZipFilter {\n+\n+    /**\n+     * When I filter a request that doesn't have the gzip header,\n+     * the request should not be wrapped, and chain.doFilter should\n+     * be called on the same request object passed to the method.\n+     */\n+    @Test\n+    public void testDoFilterEnabledNotGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(null, \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+        \n+        // request should not be wrapped\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(request, response);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header, but the gzip\n+     * feature is disabled, the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterDisabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(false, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled, but the method is something other than POST,\n+     * the doFilter method should throw an exception.\n+     */\n+    @Test(expected = IllegalStateException.class)\n+    public void testDoFilterEnabledGZippedBadMethod() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"GET\");\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        subject.doFilter(request, response, chain);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled and the method is POST, the doFilter method\n+     * should wrap the request with a GzippedInputStreamWrapper.\n+     * The BufferedReader for this GzippedInputStreamWrapper should return\n+     * the contents of the gzipped file used to create the original input stream.\n+     */\n+    @Test\n+    public void testDoFilterEnabledGZipped() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 50000000);\n+\n+        // Not thrilled to be using the file system, but this was the most readable way to do this\n+        // that I could think of.\n+        // gzip_filter.json.gz is a gzip of a json file that contains the following: {\"field\":\"value\"}\n+        FileInputStream inputStream = new FileInputStream(\"src/test/resources/gzip_filter.json.gz\");\n+        TestInputStream stream = new TestInputStream(inputStream);\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        Mockito.when(request.getInputStream()).thenReturn(stream);\n+        \n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+\n+        \n+        subject.doFilter(request, response, chain);\n+\n+        // Request should be wrapped, so the request should now be a GzippedInputStreamWrapper\n+        ArgumentCaptor<RequestBodyGZipFilter.GzippedInputStreamWrapper> requestArg =\n+            ArgumentCaptor.forClass(RequestBodyGZipFilter.GzippedInputStreamWrapper.class);\n+        ArgumentCaptor<HttpServletResponse> responseArg = ArgumentCaptor.forClass(HttpServletResponse.class);\n+        Mockito.verify(chain, Mockito.times(1)).doFilter(requestArg.capture(), responseArg.capture());\n+        RequestBodyGZipFilter.GzippedInputStreamWrapper wrappedStream = requestArg.getValue();\n+        \n+        String actualRequestBody = wrappedStream.getReader().lines().collect(Collectors.joining());\n+        String expectedRequestBody = \"{\\\"field\\\":\\\"value\\\"}\";\n+        Assert.assertEquals(expectedRequestBody, actualRequestBody);\n+    }\n+\n+    /**\n+     * When I filter a request that has the gzip header and the gzip\n+     * feature is enabled and the method is POST, but the unzipped message\n+     * body is larger than maxInflatedRequestBodySize, the doFilter method\n+     * should wrap the request with a GzippedInputStreamWrapper.\n+     * The BufferedReader for this GzippedInputStreamWrapper should throw an\n+     * IOException as it is read. This exception gets turned into\n+     * an UncheckedIOException by something, so we'll check for that instead.\n+     */\n+    @Test(expected = UncheckedIOException.class)\n+    public void testDoFilterEnabledGZippedButTooLong() throws Exception {\n+        RequestBodyGZipFilter subject = createRequestBodyGZipFilter(true, 1);\n+\n+        FileInputStream inputStream = new FileInputStream(\"src/test/resources/gzip_filter.json.gz\");\n+        TestInputStream stream = new TestInputStream(inputStream);\n+        HttpServletRequest request = createHttpServletRequest(\"gzip\", \"POST\");\n+        Mockito.when(request.getInputStream()).thenReturn(stream);\n+\n+        HttpServletResponse response = Mockito.mock(HttpServletResponse.class);\n+        FilterChain chain = Mockito.mock(FilterChain.class);\n+", "originalCommit": "9336b4cd7903af2e634b638f152f78f277cee580", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEwNTM3Ng==", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541105376", "bodyText": "maybe \"short-term solution\" (because when sample lists are 300000 samples we will again see this problem even with compression)", "author": "sheridancbio", "createdAt": "2020-12-11T17:23:15Z", "path": "docs/portal.properties-Reference.md", "diffHunk": "@@ -416,3 +417,44 @@ For more information on how Ehcache is implemented in cBioPortal refer to the [C\n ```\n skin.show_gsva=true\n ```\n+\n+# Request Body Compression\n+\n+## Background\n+Some REST endpoints that the cBioPortal frontend uses have request bodies that scale as your dataset increases. In\n+portals where users commonly query more than 100,000 samples, we found that some of these request bodies could\n+get as large as 20 Mb. These large request bodies pose a significant problem for users with poor upload speeds - some\n+users experienced upload times of more than five minutes for these requests. Request body compression is our solution to", "originalCommit": "9336b4cd7903af2e634b638f152f78f277cee580", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEwNjcwNA==", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541106704", "bodyText": "good catch / comment", "author": "sheridancbio", "createdAt": "2020-12-11T17:25:23Z", "path": "docs/portal.properties-Reference.md", "diffHunk": "@@ -416,3 +417,44 @@ For more information on how Ehcache is implemented in cBioPortal refer to the [C\n ```\n skin.show_gsva=true\n ```\n+\n+# Request Body Compression\n+\n+## Background\n+Some REST endpoints that the cBioPortal frontend uses have request bodies that scale as your dataset increases. In\n+portals where users commonly query more than 100,000 samples, we found that some of these request bodies could\n+get as large as 20 Mb. These large request bodies pose a significant problem for users with poor upload speeds - some\n+users experienced upload times of more than five minutes for these requests. Request body compression is our solution to\n+this problem. When this feature is toggled on, we compress the request bodies of a few problematic endpoints.\n+\n+## Properties\n+There are two `portal.property` values related to this feature:\n+- `enable_request_body_compression`: when `true`, the feature will be enabled.\n+- `request_gzip_body_size_bytes`: the maximum allowable unzipped request body in bytes. Defaults to 50000000 (50 Mb).\n+\n+## Behavior\n+- This is a nonbreaking change. Any consumers of the cBioPortal API you have that send requests with uncompressed request\n+bodies will continue to work, regardless of whether you turn this feature on or off.\n+- If you turn this feature on, the cBioPortal API will now be able to handle any request with a gzipped request body,\n+provided:\n+  - It is a POST request.\n+  - It has a `Content-Encoding: gzip` header.\n+\n+## Reasons to Enable This Feature\n+- You have studies with tens of thousands of samples.\n+- You have users with poor upload speeds (< 1mb up).\n+\n+## Reasons to Disable This Feature\n+- It is harder to debug gzipped requests", "originalCommit": "9336b4cd7903af2e634b638f152f78f277cee580", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEwODQzOQ==", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541108439", "bodyText": "right .. we need to find a way to stop sending very long identifier lists if we really want to improve performance for everybody", "author": "sheridancbio", "createdAt": "2020-12-11T17:28:05Z", "path": "docs/portal.properties-Reference.md", "diffHunk": "@@ -416,3 +417,44 @@ For more information on how Ehcache is implemented in cBioPortal refer to the [C\n ```\n skin.show_gsva=true\n ```\n+\n+# Request Body Compression\n+\n+## Background\n+Some REST endpoints that the cBioPortal frontend uses have request bodies that scale as your dataset increases. In\n+portals where users commonly query more than 100,000 samples, we found that some of these request bodies could\n+get as large as 20 Mb. These large request bodies pose a significant problem for users with poor upload speeds - some\n+users experienced upload times of more than five minutes for these requests. Request body compression is our solution to\n+this problem. When this feature is toggled on, we compress the request bodies of a few problematic endpoints.\n+\n+## Properties\n+There are two `portal.property` values related to this feature:\n+- `enable_request_body_compression`: when `true`, the feature will be enabled.\n+- `request_gzip_body_size_bytes`: the maximum allowable unzipped request body in bytes. Defaults to 50000000 (50 Mb).\n+\n+## Behavior\n+- This is a nonbreaking change. Any consumers of the cBioPortal API you have that send requests with uncompressed request\n+bodies will continue to work, regardless of whether you turn this feature on or off.\n+- If you turn this feature on, the cBioPortal API will now be able to handle any request with a gzipped request body,\n+provided:\n+  - It is a POST request.\n+  - It has a `Content-Encoding: gzip` header.\n+\n+## Reasons to Enable This Feature\n+- You have studies with tens of thousands of samples.\n+- You have users with poor upload speeds (< 1mb up).\n+\n+## Reasons to Disable This Feature\n+- It is harder to debug gzipped requests\n+  - Chrome's `copy request as CURL` will not work.\n+  - The compressed request body is not human-readable.\n+- It is a potential vector for denial of memory attacks.\n+  - Any request that has a body that takes significantly more space in memory than it does in the request body is\n+    potentially dangerous. We try to mitigate this by limiting the size of the unzipped request body via the\n+    `request_gzip_body_size_bytes` property, but at a fundamental level, this is still a concern.\n+  - Along these lines, if you do enable this feature, setting `request_gzip_body_size_bytes` to an arbitrarily large\n+    number would be unwise.\n+- This is not a cure-all for performance issues\n+  - Most requests the cBioPortal makes do not have large request bodies, so most requests will not be compressed, and\n+    will see no performance improvement.\n+  - Users with good upload speeds will see minimal performance improvements, as their upload speed is not a bottleneck.", "originalCommit": "9336b4cd7903af2e634b638f152f78f277cee580", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEwOTY5Nw==", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541109697", "bodyText": "I guess this reports the setting of the property to the frontend perhaps?  That way the front end will know whether it can use compression or not. Ok", "author": "sheridancbio", "createdAt": "2020-12-11T17:30:08Z", "path": "portal/src/main/webapp/config_service.jsp", "diffHunk": "@@ -114,6 +114,7 @@\n             \"oncoprint.custom_driver_annotation.tiers.default\",\n             \"ensembl.transcript_url\",\n             \"enable_persistent_cache\",\n+            \"enable_request_body_compression\",", "originalCommit": "9336b4cd7903af2e634b638f152f78f277cee580", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE1MTY4NQ==", "url": "https://github.com/cBioPortal/cbioportal/pull/8099#discussion_r541151685", "bodyText": "Exactly.", "author": "Luke-Sikina", "createdAt": "2020-12-11T18:42:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTEwOTY5Nw=="}], "type": "inlineReview"}, {"oid": "d63fed70dcf94d64d7b05888ae39bbbb9c4b6938", "url": "https://github.com/cBioPortal/cbioportal/commit/d63fed70dcf94d64d7b05888ae39bbbb9c4b6938", "message": "Compress problematically large request bodies\n\nProblem:\n- Some request bodies were so large (20+ Mb) that they resulted in\nsignificantly degraded performance for people with poor upload speeds\n\nSolution:\n- Create RequestBodyGZipFilter. It:\n  - Catches requests with a `Content-Encoding: gzip` header\n  - Reads and inflates the input stream\n  - Prevents excessively large requests from consuming too much memory\n- Add filter to web.xml\n- Add configurations for filter in portal.properties\n  - Feature toggle\n  - Inflated request body size limit\n- Add Content-Encoding header to list of accepted headers for\nCors filter.", "committedDate": "2020-12-11T18:43:13Z", "type": "forcePushed"}, {"oid": "09f23de8cdafaaf99823a280d109797f249ec628", "url": "https://github.com/cBioPortal/cbioportal/commit/09f23de8cdafaaf99823a280d109797f249ec628", "message": "Compress problematically large request bodies\n\nProblem:\n- Some request bodies were so large (20+ Mb) that they resulted in\nsignificantly degraded performance for people with poor upload speeds\n\nSolution:\n- Create RequestBodyGZipFilter. It:\n  - Catches requests with a `Content-Encoding: gzip` header\n  - Reads and inflates the input stream\n  - Prevents excessively large requests from consuming too much memory\n- Add filter to web.xml\n- Add configurations for filter in portal.properties\n  - Feature toggle\n  - Inflated request body size limit\n- Add Content-Encoding header to list of accepted headers for\nCors filter.", "committedDate": "2020-12-11T18:43:34Z", "type": "forcePushed"}, {"oid": "312511490b851f51605bfcece6f3017a006de8a5", "url": "https://github.com/cBioPortal/cbioportal/commit/312511490b851f51605bfcece6f3017a006de8a5", "message": "Compress problematically large request bodies\n\nProblem:\n- Some request bodies were so large (20+ Mb) that they resulted in\nsignificantly degraded performance for people with poor upload speeds\n\nSolution:\n- Create RequestBodyGZipFilter. It:\n  - Catches requests with a `Content-Encoding: gzip` header\n  - Reads and inflates the input stream\n  - Prevents excessively large requests from consuming too much memory\n- Add filter to web.xml\n- Add configurations for filter in portal.properties\n  - Feature toggle\n  - Inflated request body size limit\n- Add Content-Encoding header to list of accepted headers for\nCors filter.", "committedDate": "2020-12-11T20:37:59Z", "type": "forcePushed"}, {"oid": "503f577174d1111afbfa1066b230c9eeecb13672", "url": "https://github.com/cBioPortal/cbioportal/commit/503f577174d1111afbfa1066b230c9eeecb13672", "message": "Compress problematically large request bodies\n\nProblem:\n- Some request bodies were so large (20+ Mb) that they resulted in\nsignificantly degraded performance for people with poor upload speeds\n\nSolution:\n- Create RequestBodyGZipFilter. It:\n  - Catches requests with a `Content-Encoding: gzip` header\n  - Reads and inflates the input stream\n  - Prevents excessively large requests from consuming too much memory\n- Add filter to web.xml\n- Add configurations for filter in portal.properties\n  - Feature toggle\n  - Inflated request body size limit\n- Add Content-Encoding header to list of accepted headers for\nCors filter.", "committedDate": "2020-12-11T20:45:11Z", "type": "forcePushed"}, {"oid": "c75a635c9ffa96ab7707c569021a006fb1b4751e", "url": "https://github.com/cBioPortal/cbioportal/commit/c75a635c9ffa96ab7707c569021a006fb1b4751e", "message": "Compress problematically large request bodies\n\nProblem:\n- Some request bodies were so large (20+ Mb) that they resulted in\nsignificantly degraded performance for people with poor upload speeds\n\nSolution:\n- Create RequestBodyGZipFilter. It:\n  - Catches requests with a `Content-Encoding: gzip` header\n  - Reads and inflates the input stream\n  - Prevents excessively large requests from consuming too much memory\n- Add filter to web.xml\n- Add configurations for filter in portal.properties\n  - Feature toggle\n  - Inflated request body size limit\n- Add Content-Encoding header to list of accepted headers for\nCors filter.", "committedDate": "2020-12-11T20:48:51Z", "type": "forcePushed"}, {"oid": "117d3c2bfbf1f1bd8685fb54161ffe4142e6005d", "url": "https://github.com/cBioPortal/cbioportal/commit/117d3c2bfbf1f1bd8685fb54161ffe4142e6005d", "message": "Compress problematically large request bodies\n\nProblem:\n- Some request bodies were so large (20+ Mb) that they resulted in\nsignificantly degraded performance for people with poor upload speeds\n\nSolution:\n- Create RequestBodyGZipFilter. It:\n  - Catches requests with a `Content-Encoding: gzip` header\n  - Reads and inflates the input stream\n  - Prevents excessively large requests from consuming too much memory\n- Add filter to web.xml\n- Add configurations for filter in portal.properties\n  - Feature toggle\n  - Inflated request body size limit\n- Add Content-Encoding header to list of accepted headers for\nCors filter.", "committedDate": "2020-12-11T21:02:21Z", "type": "commit"}, {"oid": "117d3c2bfbf1f1bd8685fb54161ffe4142e6005d", "url": "https://github.com/cBioPortal/cbioportal/commit/117d3c2bfbf1f1bd8685fb54161ffe4142e6005d", "message": "Compress problematically large request bodies\n\nProblem:\n- Some request bodies were so large (20+ Mb) that they resulted in\nsignificantly degraded performance for people with poor upload speeds\n\nSolution:\n- Create RequestBodyGZipFilter. It:\n  - Catches requests with a `Content-Encoding: gzip` header\n  - Reads and inflates the input stream\n  - Prevents excessively large requests from consuming too much memory\n- Add filter to web.xml\n- Add configurations for filter in portal.properties\n  - Feature toggle\n  - Inflated request body size limit\n- Add Content-Encoding header to list of accepted headers for\nCors filter.", "committedDate": "2020-12-11T21:02:21Z", "type": "forcePushed"}]}