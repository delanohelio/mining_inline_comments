{"pr_number": 1060, "pr_title": "Update Authorization Flows in Documentation", "pr_createdAt": "2020-07-27T15:20:03Z", "pr_url": "https://github.com/AthenZ/athenz/pull/1060", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk3NTcyMA==", "url": "https://github.com/AthenZ/athenz/pull/1060#discussion_r460975720", "bodyText": "Let's replace ZToken with Access token", "author": "abvaidya", "createdAt": "2020-07-27T15:28:25Z", "path": "docs/decent_authz_flow.md", "diffHunk": "@@ -0,0 +1,85 @@\n+In this section, we're going to examine the decentralized authorization flow.\n+\n+## Subsystems\n+\n+Before we go into the details of the authorization flow, it's important\n+to understand the subsystems.\n+\n+### ZMS (AuthZ Management System)\n+\n+ZMS is where domains, roles, and policies are defined. This is Athenz's\n+centralized authorization system and is likely part of a larger\n+management system. In addition to allowing CRUD operations on the\n+basic entities, ZMS provides an API to replicate the entities,\n+per domain, to ZTS. It also can directly support the access\n+check, both for internal management system checks, as well as a simple\n+centralized deployment.\n+\n+ZMS is the source of truth for domains, roles, and policies for\n+centralized authorization. ZMS supports a centralized call to check if a\n+principal has access to a resource. Because ZMS supports service\n+identities, ZMS can authenticate services.\n+\n+### SIA (Service Identity Agent)\n+\n+SIA is required for authenticating existing services. Any service should integrate \n+SIA (or an equivalent system). \n+To confirm a service's identity, SIA communicates with ZTS.\n+\n+### ZTS (AuthZ Token System)\n+\n+ZTS, the authentication token service, is only needed to support\n+decentralized or data plane functionality. In many ways, ZTS is like a\n+local replica of ZMS's data to check a principal's authentication and\n+confirm membership in roles within a domain. The authentication is in\n+the form of a signed ZToken that can be presented to any decentralized", "originalCommit": "8a8bad9b91265b84968b67ff5827420dc948c785", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk3NjM2Mw==", "url": "https://github.com/AthenZ/athenz/pull/1060#discussion_r460976363", "bodyText": "Let's replace colos with more generic term like data centers", "author": "abvaidya", "createdAt": "2020-07-27T15:29:19Z", "path": "docs/decent_authz_flow.md", "diffHunk": "@@ -0,0 +1,85 @@\n+In this section, we're going to examine the decentralized authorization flow.\n+\n+## Subsystems\n+\n+Before we go into the details of the authorization flow, it's important\n+to understand the subsystems.\n+\n+### ZMS (AuthZ Management System)\n+\n+ZMS is where domains, roles, and policies are defined. This is Athenz's\n+centralized authorization system and is likely part of a larger\n+management system. In addition to allowing CRUD operations on the\n+basic entities, ZMS provides an API to replicate the entities,\n+per domain, to ZTS. It also can directly support the access\n+check, both for internal management system checks, as well as a simple\n+centralized deployment.\n+\n+ZMS is the source of truth for domains, roles, and policies for\n+centralized authorization. ZMS supports a centralized call to check if a\n+principal has access to a resource. Because ZMS supports service\n+identities, ZMS can authenticate services.\n+\n+### SIA (Service Identity Agent)\n+\n+SIA is required for authenticating existing services. Any service should integrate \n+SIA (or an equivalent system). \n+To confirm a service's identity, SIA communicates with ZTS.\n+\n+### ZTS (AuthZ Token System)\n+\n+ZTS, the authentication token service, is only needed to support\n+decentralized or data plane functionality. In many ways, ZTS is like a\n+local replica of ZMS's data to check a principal's authentication and\n+confirm membership in roles within a domain. The authentication is in\n+the form of a signed ZToken that can be presented to any decentralized\n+service that wants to authorize access efficiently. If needed, multiple\n+ZTS instances will be distributed to different colos as needed to scale", "originalCommit": "8a8bad9b91265b84968b67ff5827420dc948c785", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk3Njg1NQ==", "url": "https://github.com/AthenZ/athenz/pull/1060#discussion_r460976855", "bodyText": "ZToken => Access token", "author": "abvaidya", "createdAt": "2020-07-27T15:29:57Z", "path": "docs/decent_authz_flow.md", "diffHunk": "@@ -0,0 +1,85 @@\n+In this section, we're going to examine the decentralized authorization flow.\n+\n+## Subsystems\n+\n+Before we go into the details of the authorization flow, it's important\n+to understand the subsystems.\n+\n+### ZMS (AuthZ Management System)\n+\n+ZMS is where domains, roles, and policies are defined. This is Athenz's\n+centralized authorization system and is likely part of a larger\n+management system. In addition to allowing CRUD operations on the\n+basic entities, ZMS provides an API to replicate the entities,\n+per domain, to ZTS. It also can directly support the access\n+check, both for internal management system checks, as well as a simple\n+centralized deployment.\n+\n+ZMS is the source of truth for domains, roles, and policies for\n+centralized authorization. ZMS supports a centralized call to check if a\n+principal has access to a resource. Because ZMS supports service\n+identities, ZMS can authenticate services.\n+\n+### SIA (Service Identity Agent)\n+\n+SIA is required for authenticating existing services. Any service should integrate \n+SIA (or an equivalent system). \n+To confirm a service's identity, SIA communicates with ZTS.\n+\n+### ZTS (AuthZ Token System)\n+\n+ZTS, the authentication token service, is only needed to support\n+decentralized or data plane functionality. In many ways, ZTS is like a\n+local replica of ZMS's data to check a principal's authentication and\n+confirm membership in roles within a domain. The authentication is in\n+the form of a signed ZToken that can be presented to any decentralized\n+service that wants to authorize access efficiently. If needed, multiple\n+ZTS instances will be distributed to different colos as needed to scale\n+for issuing tokens.\n+\n+### ZPE (AuthZ Policy Engine)\n+\n+Like ZTS, ZPE, the authorization policy engine is only needed to support\n+the decentralized authorization. ZPE is the subsystem of Athenz that\n+evaluates policies for a set of roles to yield an allowed or a denied\n+response.\n+\n+ZPE is a library that your service calls and only refers to a local\n+policy cache for your services domain (a small amount of data).\n+\n+### ZPU (AuthZ PolicyEngine Updater)\n+\n+Like ZTS and ZPE, ZPU is only needed to support the decentralized\n+authorization. The policy updater is the utility that retrieves from ZTS\n+the policy files for provisioned domains on a host, which ZPE uses to\n+evaluate access requests.\n+\n+## Decentralized Access Control\n+\n+A more interesting scenario introduces the local policy engine (ZPE),\n+and a few supporting changes. Rather than directly asking for an access\n+check with a principal identity, the identity is instead used to get a\n+ZToken, and that is presented to the target service until it expires.", "originalCommit": "8a8bad9b91265b84968b67ff5827420dc948c785", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk3NzEwNA==", "url": "https://github.com/AthenZ/athenz/pull/1060#discussion_r460977104", "bodyText": "ZToken => Access token", "author": "abvaidya", "createdAt": "2020-07-27T15:30:18Z", "path": "docs/decent_authz_flow.md", "diffHunk": "@@ -0,0 +1,85 @@\n+In this section, we're going to examine the decentralized authorization flow.\n+\n+## Subsystems\n+\n+Before we go into the details of the authorization flow, it's important\n+to understand the subsystems.\n+\n+### ZMS (AuthZ Management System)\n+\n+ZMS is where domains, roles, and policies are defined. This is Athenz's\n+centralized authorization system and is likely part of a larger\n+management system. In addition to allowing CRUD operations on the\n+basic entities, ZMS provides an API to replicate the entities,\n+per domain, to ZTS. It also can directly support the access\n+check, both for internal management system checks, as well as a simple\n+centralized deployment.\n+\n+ZMS is the source of truth for domains, roles, and policies for\n+centralized authorization. ZMS supports a centralized call to check if a\n+principal has access to a resource. Because ZMS supports service\n+identities, ZMS can authenticate services.\n+\n+### SIA (Service Identity Agent)\n+\n+SIA is required for authenticating existing services. Any service should integrate \n+SIA (or an equivalent system). \n+To confirm a service's identity, SIA communicates with ZTS.\n+\n+### ZTS (AuthZ Token System)\n+\n+ZTS, the authentication token service, is only needed to support\n+decentralized or data plane functionality. In many ways, ZTS is like a\n+local replica of ZMS's data to check a principal's authentication and\n+confirm membership in roles within a domain. The authentication is in\n+the form of a signed ZToken that can be presented to any decentralized\n+service that wants to authorize access efficiently. If needed, multiple\n+ZTS instances will be distributed to different colos as needed to scale\n+for issuing tokens.\n+\n+### ZPE (AuthZ Policy Engine)\n+\n+Like ZTS, ZPE, the authorization policy engine is only needed to support\n+the decentralized authorization. ZPE is the subsystem of Athenz that\n+evaluates policies for a set of roles to yield an allowed or a denied\n+response.\n+\n+ZPE is a library that your service calls and only refers to a local\n+policy cache for your services domain (a small amount of data).\n+\n+### ZPU (AuthZ PolicyEngine Updater)\n+\n+Like ZTS and ZPE, ZPU is only needed to support the decentralized\n+authorization. The policy updater is the utility that retrieves from ZTS\n+the policy files for provisioned domains on a host, which ZPE uses to\n+evaluate access requests.\n+\n+## Decentralized Access Control\n+\n+A more interesting scenario introduces the local policy engine (ZPE),\n+and a few supporting changes. Rather than directly asking for an access\n+check with a principal identity, the identity is instead used to get a\n+ZToken, and that is presented to the target service until it expires.\n+This mechanism allows a service to make a completely local access check\n+against ZPE, given a ZToken and locally cached policies.", "originalCommit": "8a8bad9b91265b84968b67ff5827420dc948c785", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9d38b6693129cf41ce106ccb9630dcf3aca676a8", "url": "https://github.com/AthenZ/athenz/commit/9d38b6693129cf41ce106ccb9630dcf3aca676a8", "message": "Update Authorization Flows in Documentation", "committedDate": "2020-07-27T15:47:54Z", "type": "commit"}, {"oid": "9d38b6693129cf41ce106ccb9630dcf3aca676a8", "url": "https://github.com/AthenZ/athenz/commit/9d38b6693129cf41ce106ccb9630dcf3aca676a8", "message": "Update Authorization Flows in Documentation", "committedDate": "2020-07-27T15:47:54Z", "type": "forcePushed"}]}