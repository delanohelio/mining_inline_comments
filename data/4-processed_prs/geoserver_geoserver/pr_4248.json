{"pr_number": 4248, "pr_title": "[GEOS-9625] Add filtering support in json-ld module", "pr_createdAt": "2020-05-18T13:30:11Z", "pr_url": "https://github.com/geoserver/geoserver/pull/4248", "timeline": [{"oid": "7af4b6e48110831b82d9c5e3674bc9a3f04280a4", "url": "https://github.com/geoserver/geoserver/commit/7af4b6e48110831b82d9c5e3674bc9a3f04280a4", "message": "[GEOS-9625] Add filtering support in json-ld module", "committedDate": "2020-05-18T16:01:33Z", "type": "commit"}, {"oid": "e5ba2d0bcf8e2ce3436b26c2076d082042fbad68", "url": "https://github.com/geoserver/geoserver/commit/e5ba2d0bcf8e2ce3436b26c2076d082042fbad68", "message": "add validation for filter and changes for better class readability", "committedDate": "2020-05-18T16:01:33Z", "type": "commit"}, {"oid": "fa265e67c1d6f2e2fb1201370f613df483cafcfa", "url": "https://github.com/geoserver/geoserver/commit/fa265e67c1d6f2e2fb1201370f613df483cafcfa", "message": "tests and documentation updates", "committedDate": "2020-05-18T16:01:33Z", "type": "commit"}, {"oid": "fa265e67c1d6f2e2fb1201370f613df483cafcfa", "url": "https://github.com/geoserver/geoserver/commit/fa265e67c1d6f2e2fb1201370f613df483cafcfa", "message": "tests and documentation updates", "committedDate": "2020-05-18T16:01:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5NTQ0NA==", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435095444", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            As it is possible to see, in the array and object case the filter sintax expected an :code:`\"$filter\"` key followed by an attribute with the filter to evaluate. In the attribute case, instead, the filter is being specified inside the value as :code:`\"$filter{...}\"` separeted by the cql expression of by the static content from a :code:`,`.\n          \n          \n            \n            In the array and object case the filter sintax expected an :code:`\"$filter\"` key followed by an attribute with the filter to evaluate. In the attribute case, instead, the filter is being specified inside the value as :code:`\"$filter{...}\"`, followed by  the cql expression, or by the static content, with a comma separating the two.", "author": "aaime", "createdAt": "2020-06-04T08:51:58Z", "path": "doc/en/user/source/community/json-ld/configuration.rst", "diffHunk": "@@ -116,3 +116,104 @@ The content of the json-ld output depends on specified properties in json-ld tem\n * a :code:`\"$source\":\"xpath\"` attribute can be added as the first element of an array or of an object;\n * if a :code:`\"$source\": \"xpath\"` attribute is present, it will act as a context against which all xpath expression will be evaluated. In the case of an array it will be use to iterate over a collection of element; if source evaluates to null the entire object/array will be skipped;\n * a :code:`../` syntax in an xpath means that xpath evaluation will be relative to the previous :code:`$source`. Give the above template file, the xpath :code:`\"../gsml:shape\"` will be evaluate not against the corresponding :code:`\"$source\": \"gsml:specification/gsml:GeologicUnit\"`, but against the parent one :code:`\"$source\": \"gsml:MappedFeature\"`.\n+\n+\n+Filtering Support\n+------------------\n+\n+In order to have a more fined grained control over the output it is possible to specify a filter at the array, object and attribute level.\n+Assuming to have a template file like the above, valid filters could be the followings:\n+\n+array \n+\n+.. code-block:: json\n+\n+ {\n+   \"lithology\":[\n+      {\n+         \"$source\":\"gsml:lithology\",\n+         \"$filter\":\"xpath('gsml:ControlledConcept/gsml:name') = 'name_2'\"\n+      },\n+      {\n+         \"@id\":\"${gsml:ControlledConcept/@id}\",\n+         \"name\":{\n+            \"value\":\"${gsml:ControlledConcept/gsml:name}\",\n+            \"@lang\":\"en\"\n+         },\n+         \"vocabulary\":{\n+            \"@href\":\"urn:ogc:def:nil:OGC::missing\"\n+         }\n+      }\n+   ]\n+ }\n+\n+\n+object \n+\n+.. code-block:: json\n+\n+ {\n+   \"gsml:GeologicUnit\":{\n+      \"$source\":\"gsml:specification/gsml:GeologicUnit\",\n+      \"$filter\":\"xpath('gml:description') = 'Olivine basalt'\",\n+      \"@id\":\"${@id}\",\n+      \"description\":\"${gml:description}\",\n+      \"gsml:geologicUnitType\":\"urn:ogc:def:nil:OGC::unknown\",\n+      \"gsml:composition\":\"...\"\n+   }\n+ }\n+\n+\n+\n+attribute (dynamic) \n+\n+.. code-block:: json\n+\n+  {\n+  \"gsml:GeologicUnit\": {\n+        \"$source\": \"gsml:specification/gsml:GeologicUnit\",\n+        \"@id\": \"${@id}\",\n+        \"description\": \"$filter{xpath('gml:description')='Olivine basalt'},${gml:description}\",\n+        \"gsml:geologicUnitType\": \"urn:ogc:def:nil:OGC::unknown\",\n+        \"gsml:composition\": \"...\"\n+    }\n+  }\n+\n+\n+attribute (static) \n+\n+.. code-block:: json\n+\n+   {\n+   \"gsml:composition\":[\n+      {\n+         \"$source\":\"gsml:composition\"\n+      },\n+      {\n+         \"gsml:compositionPart\":[\n+            {\n+               \"$source\":\"gsml:CompositionPart\"\n+            },\n+            {\n+               \"gsml:role\":{\n+                  \"value\":\"${gsml:role}\",\n+                  \"@codeSpace\":\"$filter{xpath('../../gml:description')='Olivine basalt'},urn:cgi:classifierScheme:Example:CompositionPartRole\"\n+               }\n+            }\n+         ]\n+      }\n+   ]\n+ }\n+\n+\n+\n+As it is possible to see, in the array and object case the filter sintax expected an :code:`\"$filter\"` key followed by an attribute with the filter to evaluate. In the attribute case, instead, the filter is being specified inside the value as :code:`\"$filter{...}\"` separeted by the cql expression of by the static content from a :code:`,`.", "originalCommit": "fa265e67c1d6f2e2fb1201370f613df483cafcfa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEzMzA0Nw==", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435133047", "bodyText": "fixed", "author": "taba90", "createdAt": "2020-06-04T09:54:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5NTQ0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5NTg3OQ==", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435095879", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              * in the array case, each of its element will be included in the output if the condition in the filter condition is true;\n          \n          \n            \n              * in the array case, elements will be included in the output only if the condition in the filter is matched;", "author": "aaime", "createdAt": "2020-06-04T08:52:43Z", "path": "doc/en/user/source/community/json-ld/configuration.rst", "diffHunk": "@@ -116,3 +116,104 @@ The content of the json-ld output depends on specified properties in json-ld tem\n * a :code:`\"$source\":\"xpath\"` attribute can be added as the first element of an array or of an object;\n * if a :code:`\"$source\": \"xpath\"` attribute is present, it will act as a context against which all xpath expression will be evaluated. In the case of an array it will be use to iterate over a collection of element; if source evaluates to null the entire object/array will be skipped;\n * a :code:`../` syntax in an xpath means that xpath evaluation will be relative to the previous :code:`$source`. Give the above template file, the xpath :code:`\"../gsml:shape\"` will be evaluate not against the corresponding :code:`\"$source\": \"gsml:specification/gsml:GeologicUnit\"`, but against the parent one :code:`\"$source\": \"gsml:MappedFeature\"`.\n+\n+\n+Filtering Support\n+------------------\n+\n+In order to have a more fined grained control over the output it is possible to specify a filter at the array, object and attribute level.\n+Assuming to have a template file like the above, valid filters could be the followings:\n+\n+array \n+\n+.. code-block:: json\n+\n+ {\n+   \"lithology\":[\n+      {\n+         \"$source\":\"gsml:lithology\",\n+         \"$filter\":\"xpath('gsml:ControlledConcept/gsml:name') = 'name_2'\"\n+      },\n+      {\n+         \"@id\":\"${gsml:ControlledConcept/@id}\",\n+         \"name\":{\n+            \"value\":\"${gsml:ControlledConcept/gsml:name}\",\n+            \"@lang\":\"en\"\n+         },\n+         \"vocabulary\":{\n+            \"@href\":\"urn:ogc:def:nil:OGC::missing\"\n+         }\n+      }\n+   ]\n+ }\n+\n+\n+object \n+\n+.. code-block:: json\n+\n+ {\n+   \"gsml:GeologicUnit\":{\n+      \"$source\":\"gsml:specification/gsml:GeologicUnit\",\n+      \"$filter\":\"xpath('gml:description') = 'Olivine basalt'\",\n+      \"@id\":\"${@id}\",\n+      \"description\":\"${gml:description}\",\n+      \"gsml:geologicUnitType\":\"urn:ogc:def:nil:OGC::unknown\",\n+      \"gsml:composition\":\"...\"\n+   }\n+ }\n+\n+\n+\n+attribute (dynamic) \n+\n+.. code-block:: json\n+\n+  {\n+  \"gsml:GeologicUnit\": {\n+        \"$source\": \"gsml:specification/gsml:GeologicUnit\",\n+        \"@id\": \"${@id}\",\n+        \"description\": \"$filter{xpath('gml:description')='Olivine basalt'},${gml:description}\",\n+        \"gsml:geologicUnitType\": \"urn:ogc:def:nil:OGC::unknown\",\n+        \"gsml:composition\": \"...\"\n+    }\n+  }\n+\n+\n+attribute (static) \n+\n+.. code-block:: json\n+\n+   {\n+   \"gsml:composition\":[\n+      {\n+         \"$source\":\"gsml:composition\"\n+      },\n+      {\n+         \"gsml:compositionPart\":[\n+            {\n+               \"$source\":\"gsml:CompositionPart\"\n+            },\n+            {\n+               \"gsml:role\":{\n+                  \"value\":\"${gsml:role}\",\n+                  \"@codeSpace\":\"$filter{xpath('../../gml:description')='Olivine basalt'},urn:cgi:classifierScheme:Example:CompositionPartRole\"\n+               }\n+            }\n+         ]\n+      }\n+   ]\n+ }\n+\n+\n+\n+As it is possible to see, in the array and object case the filter sintax expected an :code:`\"$filter\"` key followed by an attribute with the filter to evaluate. In the attribute case, instead, the filter is being specified inside the value as :code:`\"$filter{...}\"` separeted by the cql expression of by the static content from a :code:`,`.\n+The evaluation of a filter is handled by the module in the following way:\n+\n+* if a :code:`\"$filter\": \"cql\"` attribute is present after the :code:`\"$source\"` attribute in an array or an object:\n+  * in the array case, each of its element will be included in the output if the condition in the filter condition is true;", "originalCommit": "fa265e67c1d6f2e2fb1201370f613df483cafcfa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEzMzEzNQ==", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435133135", "bodyText": "fixed", "author": "taba90", "createdAt": "2020-06-04T09:54:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5NTg3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5NjEzMQ==", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435096131", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              * in the object case, the entire object will be included in the output if the condition in the filter condition is true;\n          \n          \n            \n              * in the object case, the object will be included in the output if the condition in the filter condition is matched, otherwise the object will be skipped;", "author": "aaime", "createdAt": "2020-06-04T08:53:09Z", "path": "doc/en/user/source/community/json-ld/configuration.rst", "diffHunk": "@@ -116,3 +116,104 @@ The content of the json-ld output depends on specified properties in json-ld tem\n * a :code:`\"$source\":\"xpath\"` attribute can be added as the first element of an array or of an object;\n * if a :code:`\"$source\": \"xpath\"` attribute is present, it will act as a context against which all xpath expression will be evaluated. In the case of an array it will be use to iterate over a collection of element; if source evaluates to null the entire object/array will be skipped;\n * a :code:`../` syntax in an xpath means that xpath evaluation will be relative to the previous :code:`$source`. Give the above template file, the xpath :code:`\"../gsml:shape\"` will be evaluate not against the corresponding :code:`\"$source\": \"gsml:specification/gsml:GeologicUnit\"`, but against the parent one :code:`\"$source\": \"gsml:MappedFeature\"`.\n+\n+\n+Filtering Support\n+------------------\n+\n+In order to have a more fined grained control over the output it is possible to specify a filter at the array, object and attribute level.\n+Assuming to have a template file like the above, valid filters could be the followings:\n+\n+array \n+\n+.. code-block:: json\n+\n+ {\n+   \"lithology\":[\n+      {\n+         \"$source\":\"gsml:lithology\",\n+         \"$filter\":\"xpath('gsml:ControlledConcept/gsml:name') = 'name_2'\"\n+      },\n+      {\n+         \"@id\":\"${gsml:ControlledConcept/@id}\",\n+         \"name\":{\n+            \"value\":\"${gsml:ControlledConcept/gsml:name}\",\n+            \"@lang\":\"en\"\n+         },\n+         \"vocabulary\":{\n+            \"@href\":\"urn:ogc:def:nil:OGC::missing\"\n+         }\n+      }\n+   ]\n+ }\n+\n+\n+object \n+\n+.. code-block:: json\n+\n+ {\n+   \"gsml:GeologicUnit\":{\n+      \"$source\":\"gsml:specification/gsml:GeologicUnit\",\n+      \"$filter\":\"xpath('gml:description') = 'Olivine basalt'\",\n+      \"@id\":\"${@id}\",\n+      \"description\":\"${gml:description}\",\n+      \"gsml:geologicUnitType\":\"urn:ogc:def:nil:OGC::unknown\",\n+      \"gsml:composition\":\"...\"\n+   }\n+ }\n+\n+\n+\n+attribute (dynamic) \n+\n+.. code-block:: json\n+\n+  {\n+  \"gsml:GeologicUnit\": {\n+        \"$source\": \"gsml:specification/gsml:GeologicUnit\",\n+        \"@id\": \"${@id}\",\n+        \"description\": \"$filter{xpath('gml:description')='Olivine basalt'},${gml:description}\",\n+        \"gsml:geologicUnitType\": \"urn:ogc:def:nil:OGC::unknown\",\n+        \"gsml:composition\": \"...\"\n+    }\n+  }\n+\n+\n+attribute (static) \n+\n+.. code-block:: json\n+\n+   {\n+   \"gsml:composition\":[\n+      {\n+         \"$source\":\"gsml:composition\"\n+      },\n+      {\n+         \"gsml:compositionPart\":[\n+            {\n+               \"$source\":\"gsml:CompositionPart\"\n+            },\n+            {\n+               \"gsml:role\":{\n+                  \"value\":\"${gsml:role}\",\n+                  \"@codeSpace\":\"$filter{xpath('../../gml:description')='Olivine basalt'},urn:cgi:classifierScheme:Example:CompositionPartRole\"\n+               }\n+            }\n+         ]\n+      }\n+   ]\n+ }\n+\n+\n+\n+As it is possible to see, in the array and object case the filter sintax expected an :code:`\"$filter\"` key followed by an attribute with the filter to evaluate. In the attribute case, instead, the filter is being specified inside the value as :code:`\"$filter{...}\"` separeted by the cql expression of by the static content from a :code:`,`.\n+The evaluation of a filter is handled by the module in the following way:\n+\n+* if a :code:`\"$filter\": \"cql\"` attribute is present after the :code:`\"$source\"` attribute in an array or an object:\n+  * in the array case, each of its element will be included in the output if the condition in the filter condition is true;\n+  * in the object case, the entire object will be included in the output if the condition in the filter condition is true;", "originalCommit": "fa265e67c1d6f2e2fb1201370f613df483cafcfa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEzMzIxMA==", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435133210", "bodyText": "fixed", "author": "taba90", "createdAt": "2020-06-04T09:54:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5NjEzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5NjQ3OA==", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435096478", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * if a :code:`$filter{cql}` is present inside an attribute value before the expression or the static content, separated by it from a :code:`,`:\n          \n          \n            \n            * if a :code:`$filter{cql}` is present inside an attribute value before the expression or static content:", "author": "aaime", "createdAt": "2020-06-04T08:53:40Z", "path": "doc/en/user/source/community/json-ld/configuration.rst", "diffHunk": "@@ -116,3 +116,104 @@ The content of the json-ld output depends on specified properties in json-ld tem\n * a :code:`\"$source\":\"xpath\"` attribute can be added as the first element of an array or of an object;\n * if a :code:`\"$source\": \"xpath\"` attribute is present, it will act as a context against which all xpath expression will be evaluated. In the case of an array it will be use to iterate over a collection of element; if source evaluates to null the entire object/array will be skipped;\n * a :code:`../` syntax in an xpath means that xpath evaluation will be relative to the previous :code:`$source`. Give the above template file, the xpath :code:`\"../gsml:shape\"` will be evaluate not against the corresponding :code:`\"$source\": \"gsml:specification/gsml:GeologicUnit\"`, but against the parent one :code:`\"$source\": \"gsml:MappedFeature\"`.\n+\n+\n+Filtering Support\n+------------------\n+\n+In order to have a more fined grained control over the output it is possible to specify a filter at the array, object and attribute level.\n+Assuming to have a template file like the above, valid filters could be the followings:\n+\n+array \n+\n+.. code-block:: json\n+\n+ {\n+   \"lithology\":[\n+      {\n+         \"$source\":\"gsml:lithology\",\n+         \"$filter\":\"xpath('gsml:ControlledConcept/gsml:name') = 'name_2'\"\n+      },\n+      {\n+         \"@id\":\"${gsml:ControlledConcept/@id}\",\n+         \"name\":{\n+            \"value\":\"${gsml:ControlledConcept/gsml:name}\",\n+            \"@lang\":\"en\"\n+         },\n+         \"vocabulary\":{\n+            \"@href\":\"urn:ogc:def:nil:OGC::missing\"\n+         }\n+      }\n+   ]\n+ }\n+\n+\n+object \n+\n+.. code-block:: json\n+\n+ {\n+   \"gsml:GeologicUnit\":{\n+      \"$source\":\"gsml:specification/gsml:GeologicUnit\",\n+      \"$filter\":\"xpath('gml:description') = 'Olivine basalt'\",\n+      \"@id\":\"${@id}\",\n+      \"description\":\"${gml:description}\",\n+      \"gsml:geologicUnitType\":\"urn:ogc:def:nil:OGC::unknown\",\n+      \"gsml:composition\":\"...\"\n+   }\n+ }\n+\n+\n+\n+attribute (dynamic) \n+\n+.. code-block:: json\n+\n+  {\n+  \"gsml:GeologicUnit\": {\n+        \"$source\": \"gsml:specification/gsml:GeologicUnit\",\n+        \"@id\": \"${@id}\",\n+        \"description\": \"$filter{xpath('gml:description')='Olivine basalt'},${gml:description}\",\n+        \"gsml:geologicUnitType\": \"urn:ogc:def:nil:OGC::unknown\",\n+        \"gsml:composition\": \"...\"\n+    }\n+  }\n+\n+\n+attribute (static) \n+\n+.. code-block:: json\n+\n+   {\n+   \"gsml:composition\":[\n+      {\n+         \"$source\":\"gsml:composition\"\n+      },\n+      {\n+         \"gsml:compositionPart\":[\n+            {\n+               \"$source\":\"gsml:CompositionPart\"\n+            },\n+            {\n+               \"gsml:role\":{\n+                  \"value\":\"${gsml:role}\",\n+                  \"@codeSpace\":\"$filter{xpath('../../gml:description')='Olivine basalt'},urn:cgi:classifierScheme:Example:CompositionPartRole\"\n+               }\n+            }\n+         ]\n+      }\n+   ]\n+ }\n+\n+\n+\n+As it is possible to see, in the array and object case the filter sintax expected an :code:`\"$filter\"` key followed by an attribute with the filter to evaluate. In the attribute case, instead, the filter is being specified inside the value as :code:`\"$filter{...}\"` separeted by the cql expression of by the static content from a :code:`,`.\n+The evaluation of a filter is handled by the module in the following way:\n+\n+* if a :code:`\"$filter\": \"cql\"` attribute is present after the :code:`\"$source\"` attribute in an array or an object:\n+  * in the array case, each of its element will be included in the output if the condition in the filter condition is true;\n+  * in the object case, the entire object will be included in the output if the condition in the filter condition is true;\n+\n+* if a :code:`$filter{cql}` is present inside an attribute value before the expression or the static content, separated by it from a :code:`,`:", "originalCommit": "fa265e67c1d6f2e2fb1201370f613df483cafcfa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEzMzI4MQ==", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435133281", "bodyText": "fixed", "author": "taba90", "createdAt": "2020-06-04T09:54:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5NjQ3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5NzU1OQ==", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435097559", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              * in case of a static content attribute, the static content will be included in the output if the filter condition is true.\n          \n          \n            \n              * in case of a static content attribute, the static content will be included in the output if the filter condition is true.\n          \n          \n            \n              * in case the expression is not matched, the content, static or dynamic, will not be set, resulting in the attribute being skipped.\n          \n      \n    \n    \n  \n\nIs the attribute going to be skipped, like I wrote, or encoded with a null value?", "author": "aaime", "createdAt": "2020-06-04T08:55:24Z", "path": "doc/en/user/source/community/json-ld/configuration.rst", "diffHunk": "@@ -116,3 +116,104 @@ The content of the json-ld output depends on specified properties in json-ld tem\n * a :code:`\"$source\":\"xpath\"` attribute can be added as the first element of an array or of an object;\n * if a :code:`\"$source\": \"xpath\"` attribute is present, it will act as a context against which all xpath expression will be evaluated. In the case of an array it will be use to iterate over a collection of element; if source evaluates to null the entire object/array will be skipped;\n * a :code:`../` syntax in an xpath means that xpath evaluation will be relative to the previous :code:`$source`. Give the above template file, the xpath :code:`\"../gsml:shape\"` will be evaluate not against the corresponding :code:`\"$source\": \"gsml:specification/gsml:GeologicUnit\"`, but against the parent one :code:`\"$source\": \"gsml:MappedFeature\"`.\n+\n+\n+Filtering Support\n+------------------\n+\n+In order to have a more fined grained control over the output it is possible to specify a filter at the array, object and attribute level.\n+Assuming to have a template file like the above, valid filters could be the followings:\n+\n+array \n+\n+.. code-block:: json\n+\n+ {\n+   \"lithology\":[\n+      {\n+         \"$source\":\"gsml:lithology\",\n+         \"$filter\":\"xpath('gsml:ControlledConcept/gsml:name') = 'name_2'\"\n+      },\n+      {\n+         \"@id\":\"${gsml:ControlledConcept/@id}\",\n+         \"name\":{\n+            \"value\":\"${gsml:ControlledConcept/gsml:name}\",\n+            \"@lang\":\"en\"\n+         },\n+         \"vocabulary\":{\n+            \"@href\":\"urn:ogc:def:nil:OGC::missing\"\n+         }\n+      }\n+   ]\n+ }\n+\n+\n+object \n+\n+.. code-block:: json\n+\n+ {\n+   \"gsml:GeologicUnit\":{\n+      \"$source\":\"gsml:specification/gsml:GeologicUnit\",\n+      \"$filter\":\"xpath('gml:description') = 'Olivine basalt'\",\n+      \"@id\":\"${@id}\",\n+      \"description\":\"${gml:description}\",\n+      \"gsml:geologicUnitType\":\"urn:ogc:def:nil:OGC::unknown\",\n+      \"gsml:composition\":\"...\"\n+   }\n+ }\n+\n+\n+\n+attribute (dynamic) \n+\n+.. code-block:: json\n+\n+  {\n+  \"gsml:GeologicUnit\": {\n+        \"$source\": \"gsml:specification/gsml:GeologicUnit\",\n+        \"@id\": \"${@id}\",\n+        \"description\": \"$filter{xpath('gml:description')='Olivine basalt'},${gml:description}\",\n+        \"gsml:geologicUnitType\": \"urn:ogc:def:nil:OGC::unknown\",\n+        \"gsml:composition\": \"...\"\n+    }\n+  }\n+\n+\n+attribute (static) \n+\n+.. code-block:: json\n+\n+   {\n+   \"gsml:composition\":[\n+      {\n+         \"$source\":\"gsml:composition\"\n+      },\n+      {\n+         \"gsml:compositionPart\":[\n+            {\n+               \"$source\":\"gsml:CompositionPart\"\n+            },\n+            {\n+               \"gsml:role\":{\n+                  \"value\":\"${gsml:role}\",\n+                  \"@codeSpace\":\"$filter{xpath('../../gml:description')='Olivine basalt'},urn:cgi:classifierScheme:Example:CompositionPartRole\"\n+               }\n+            }\n+         ]\n+      }\n+   ]\n+ }\n+\n+\n+\n+As it is possible to see, in the array and object case the filter sintax expected an :code:`\"$filter\"` key followed by an attribute with the filter to evaluate. In the attribute case, instead, the filter is being specified inside the value as :code:`\"$filter{...}\"` separeted by the cql expression of by the static content from a :code:`,`.\n+The evaluation of a filter is handled by the module in the following way:\n+\n+* if a :code:`\"$filter\": \"cql\"` attribute is present after the :code:`\"$source\"` attribute in an array or an object:\n+  * in the array case, each of its element will be included in the output if the condition in the filter condition is true;\n+  * in the object case, the entire object will be included in the output if the condition in the filter condition is true;\n+\n+* if a :code:`$filter{cql}` is present inside an attribute value before the expression or the static content, separated by it from a :code:`,`:\n+  * in case of an expression attribute, the result of the expression will be included in the output if the filter condition is true;\n+  * in case of a static content attribute, the static content will be included in the output if the filter condition is true.", "originalCommit": "fa265e67c1d6f2e2fb1201370f613df483cafcfa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEzMzQ2Ng==", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435133466", "bodyText": "fixed (yes it will be skipped)", "author": "taba90", "createdAt": "2020-06-04T09:54:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5NzU1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5ODYxOQ==", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435098619", "bodyText": "Ouch this makes for very heavy tests. Does not matter now that the tests are not run, but won't be good if/when the module upgrades to extension. It can be kept here and addressed at graduation time, just noting it will be trouble.", "author": "aaime", "createdAt": "2020-06-04T08:57:10Z", "path": "src/community/json-ld/pom.xml", "diffHunk": "@@ -155,6 +155,26 @@\n         </dependency>\n     </dependencies>\n \n+    <build>\n+    <plugins>\n+    <plugin>\n+        <groupId>org.apache.maven.plugins</groupId>\n+        <artifactId>maven-surefire-plugin</artifactId>\n+        <version>2.15</version>\n+        <configuration>\n+            <runOrder>alphabetical</runOrder>\n+            <includes>\n+                <include>**/*Test.java</include>\n+            </includes>\n+            <reuseForks>false</reuseForks>", "originalCommit": "fa265e67c1d6f2e2fb1201370f613df483cafcfa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEzNTA0Nw==", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435135047", "bodyText": "Yes I can imagine but it's the only way I found right now, to avoid that test method that should use a json-ld template end up using the one from another test.", "author": "taba90", "createdAt": "2020-06-04T09:57:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5ODYxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA5OTEzNw==", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435099137", "bodyText": "Public method without javadoc... but it seems it's in good company, and the module is unsupported, so eventually javadocs can be improved at the eventual graduation time, no need to do it now.", "author": "aaime", "createdAt": "2020-06-04T08:58:00Z", "path": "src/community/json-ld/src/main/java/org/geoserver/jsonld/JsonLdGenerator.java", "diffHunk": "@@ -133,6 +133,11 @@ public void writeResult(Object result) throws IOException {\n         }\n     }\n \n+    public void writeString(String entryName, String value) throws IOException {", "originalCommit": "fa265e67c1d6f2e2fb1201370f613df483cafcfa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwMDE4Ng==", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435100186", "bodyText": "Why couldn't this be written using a simple for loop? I don't see odd exit conditions.", "author": "aaime", "createdAt": "2020-06-04T08:59:40Z", "path": "src/community/json-ld/src/main/java/org/geoserver/jsonld/builders/AbstractJsonBuilder.java", "diffHunk": "@@ -6,26 +6,60 @@\n \n import java.io.IOException;\n import org.geoserver.jsonld.JsonLdGenerator;\n+import org.geoserver.jsonld.builders.impl.JsonBuilderContext;\n+import org.geoserver.jsonld.expressions.JsonLdCqlManager;\n+import org.geotools.filter.text.cql2.CQLException;\n+import org.opengis.filter.Filter;\n+import org.opengis.filter.expression.*;\n+import org.xml.sax.helpers.NamespaceSupport;\n \n /** Abstract implementation of {@link JsonBuilder} who groups some common attributes and methods. */\n public abstract class AbstractJsonBuilder implements JsonBuilder {\n \n     protected String key;\n \n-    public AbstractJsonBuilder(String key) {\n+    protected Filter filter;\n+\n+    protected int filterContextPos = 0;\n+\n+    protected NamespaceSupport namespaces;\n+\n+    public AbstractJsonBuilder(String key, NamespaceSupport namespaces) {\n         this.key = key;\n+        this.namespaces = namespaces;\n     }\n \n     protected void writeKey(JsonLdGenerator writer) throws IOException {\n         if (key != null && !key.equals(\"\")) writer.writeFieldName(key);\n         else throw new RuntimeException(\"Cannot write null key value\");\n     }\n \n+    protected boolean evaluateFilter(JsonBuilderContext context) {\n+        if (filter == null) return true;\n+        int i = 0;", "originalCommit": "fa265e67c1d6f2e2fb1201370f613df483cafcfa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEzNTYzMQ==", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435135631", "bodyText": "Indeed no need for the while here, fixed", "author": "taba90", "createdAt": "2020-06-04T09:58:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwMDE4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwMDU3Mw==", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435100573", "bodyText": "Commented out code, please remove.", "author": "aaime", "createdAt": "2020-06-04T09:00:16Z", "path": "src/community/json-ld/src/main/java/org/geoserver/jsonld/builders/impl/DynamicValueBuilder.java", "diffHunk": "@@ -38,65 +33,42 @@\n     private static final Logger LOGGER = Logging.getLogger(DynamicValueBuilder.class);\n \n     public DynamicValueBuilder(String key, String expression, NamespaceSupport namespaces) {\n-        super(key);\n+        super(key, namespaces);\n         this.namespaces = namespaces;\n+        JsonLdCqlManager cqlManager = new JsonLdCqlManager(expression, namespaces);\n         if (expression.startsWith(\"$${\")) {\n-            strCqlToExpression(expression);\n+            this.cql = cqlManager.getExpressionFromString();\n+            // strCqlToExpression(expression);", "originalCommit": "fa265e67c1d6f2e2fb1201370f613df483cafcfa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEzNTgwOQ==", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435135809", "bodyText": "removed", "author": "taba90", "createdAt": "2020-06-04T09:58:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwMDU3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwMDYyNQ==", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435100625", "bodyText": "Commented out code, please remove.", "author": "aaime", "createdAt": "2020-06-04T09:00:22Z", "path": "src/community/json-ld/src/main/java/org/geoserver/jsonld/builders/impl/DynamicValueBuilder.java", "diffHunk": "@@ -38,65 +33,42 @@\n     private static final Logger LOGGER = Logging.getLogger(DynamicValueBuilder.class);\n \n     public DynamicValueBuilder(String key, String expression, NamespaceSupport namespaces) {\n-        super(key);\n+        super(key, namespaces);\n         this.namespaces = namespaces;\n+        JsonLdCqlManager cqlManager = new JsonLdCqlManager(expression, namespaces);\n         if (expression.startsWith(\"$${\")) {\n-            strCqlToExpression(expression);\n+            this.cql = cqlManager.getExpressionFromString();\n+            // strCqlToExpression(expression);\n         } else if (expression.startsWith(\"${\")) {\n-            strXpathToPropertyName(expression);\n+            this.xpath = cqlManager.getAttributeExpressionFromString();\n+            // strXpathToPropertyName(expression);", "originalCommit": "fa265e67c1d6f2e2fb1201370f613df483cafcfa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEzNTg5MQ==", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435135891", "bodyText": "removed", "author": "taba90", "createdAt": "2020-06-04T09:58:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwMDYyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwMjI2Mw==", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435102263", "bodyText": "What if the filter itself contains a comma? (a CQL filter can contain a \"in\" operator that uses it, or might have a string literal containing it).", "author": "aaime", "createdAt": "2020-06-04T09:03:04Z", "path": "src/community/json-ld/src/main/java/org/geoserver/jsonld/configuration/JsonLdTemplateReader.java", "diffHunk": "@@ -121,13 +136,47 @@ private void getBuilderFromJsonArray(\n \n     private void getBuilderFromJsonAttribute(\n             String nodeName, JsonNode node, JsonBuilder currentBuilder) {\n+        String strNode = node.asText();\n+        String filter = null;\n+        if (strNode.contains(FILTERKEY)) {\n+            String[] arrNode = strNode.split(\",\");", "originalCommit": "fa265e67c1d6f2e2fb1201370f613df483cafcfa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEzNTk5MQ==", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435135991", "bodyText": "fixed", "author": "taba90", "createdAt": "2020-06-04T09:59:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwMjI2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwMjkwNQ==", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435102905", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class JsonLdCqlManager {\n          \n          \n            \n            public class JsonLdCQLManager {\n          \n      \n    \n    \n  \n\nDoes the class need to be public?", "author": "aaime", "createdAt": "2020-06-04T09:04:09Z", "path": "src/community/json-ld/src/main/java/org/geoserver/jsonld/expressions/JsonLdCqlManager.java", "diffHunk": "@@ -1,38 +1,125 @@\n-/* (c) 2019 Open Source Geospatial Foundation - all rights reserved\n+/* (c) 2020 Open Source Geospatial Foundation - all rights reserved\n  * This code is licensed under the GPL 2.0 license, available at the root\n  * application directory.\n  */\n package org.geoserver.jsonld.expressions;\n \n import java.util.ArrayList;\n-import java.util.Iterator;\n import java.util.List;\n-import java.util.Map;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n import org.geoserver.jsonld.builders.impl.JsonBuilderContext;\n-import org.geotools.data.complex.feature.type.ComplexFeatureTypeImpl;\n import org.geotools.factory.CommonFactoryFinder;\n-import org.geotools.feature.type.Types;\n+import org.geotools.filter.AttributeExpressionImpl;\n import org.geotools.filter.text.cql2.CQLException;\n import org.geotools.filter.text.ecql.ECQL;\n-import org.opengis.feature.type.FeatureType;\n+import org.geotools.filter.visitor.DuplicatingFilterVisitor;\n+import org.opengis.filter.Filter;\n import org.opengis.filter.FilterFactory;\n import org.opengis.filter.expression.Expression;\n+import org.opengis.filter.expression.Literal;\n import org.xml.sax.helpers.NamespaceSupport;\n \n /**\n  * Helper class that mainly allows the extraction of CQL and Xpath expressions out of a plain text\n- * string using special separators. It also provides some Utility methods to handle namespaces and\n- * xpath syntax\n+ * string using special separators. Moreover, since JsonLd templates can declare an xpath('some\n+ * xpath') function that has no real FunctionExpression implementation, this class provides methods\n+ * to extracts the xpath from the function as a literal, to substitute it after cql encoding\n+ * happened with an AttributeExpression.\n  */\n-public class ExpressionsUtils {\n+public class JsonLdCqlManager {", "originalCommit": "fa265e67c1d6f2e2fb1201370f613df483cafcfa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEzNzI0OQ==", "url": "https://github.com/geoserver/geoserver/pull/4248#discussion_r435137249", "bodyText": "at the moment it is used outside its package by the builders", "author": "taba90", "createdAt": "2020-06-04T10:01:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwMjkwNQ=="}], "type": "inlineReview"}, {"oid": "ca1763b490e951afd15222c8a382180af65eb3c0", "url": "https://github.com/geoserver/geoserver/commit/ca1763b490e951afd15222c8a382180af65eb3c0", "message": "reviewer's suggestion applied", "committedDate": "2020-06-04T09:52:55Z", "type": "commit"}]}