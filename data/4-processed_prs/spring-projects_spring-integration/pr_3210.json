{"pr_number": 3210, "pr_title": "Document Kotlin DSL", "pr_createdAt": "2020-03-05T21:41:03Z", "pr_url": "https://github.com/spring-projects/spring-integration/pull/3210", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU3MzIwMA==", "url": "https://github.com/spring-projects/spring-integration/pull/3210#discussion_r390573200", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            All you need to get started is just an import for `org.springframework.integration.dsl.integrationFlow` - an overloaded global function for Kotlin DSL.\n          \n          \n            \n            All you need to get started is just an import for `org.springframework.integration.dsl.kotlin.integrationFlow` - an overloaded global function for Kotlin DSL.", "author": "garyrussell", "createdAt": "2020-03-10T19:55:12Z", "path": "src/reference/asciidoc/kotlin-dsl.adoc", "diffHunk": "@@ -0,0 +1,96 @@\n+[[kotlin-dsl]]\n+== Kotlin DSL\n+\n+The Kotlin DSL is a wrapper and extension to <<./dsl.adoc#java-dsl,Java DSL>> and aimed to make Spring Integration development on Kotlin as smooth and straightforward as is it possible with interoperability with existing Java API and Kotlin language-specific structures.\n+\n+All you need to get started is just an import for `org.springframework.integration.dsl.integrationFlow` - an overloaded global function for Kotlin DSL.", "originalCommit": "f0759efd29638adfefefc296b3c929e98fb03fa0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU3NDExOA==", "url": "https://github.com/spring-projects/spring-integration/pull/3210#discussion_r390574118", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The Kotlin DSL is a wrapper and extension to <<./dsl.adoc#java-dsl,Java DSL>> and aimed to make Spring Integration development on Kotlin as smooth and straightforward as is it possible with interoperability with existing Java API and Kotlin language-specific structures.\n          \n          \n            \n            The Kotlin DSL is a wrapper and extension to <<./dsl.adoc#java-dsl,Java DSL>> and aimed to make Spring Integration development on Kotlin as smooth and straightforward as possible with interoperability with the existing Java API and Kotlin language-specific structures.\n          \n          \n            \n            ``` @", "author": "garyrussell", "createdAt": "2020-03-10T19:56:51Z", "path": "src/reference/asciidoc/kotlin-dsl.adoc", "diffHunk": "@@ -0,0 +1,96 @@\n+[[kotlin-dsl]]\n+== Kotlin DSL\n+\n+The Kotlin DSL is a wrapper and extension to <<./dsl.adoc#java-dsl,Java DSL>> and aimed to make Spring Integration development on Kotlin as smooth and straightforward as is it possible with interoperability with existing Java API and Kotlin language-specific structures.", "originalCommit": "f0759efd29638adfefefc296b3c929e98fb03fa0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU3NTYzNw==", "url": "https://github.com/spring-projects/spring-integration/pull/3210#discussion_r390575637", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For this purpose Spring Integration Java DSL provides an `IntegrationFlows` factory with its bunch of overloaded `from()` methods.\n          \n          \n            \n            For this purpose, the Spring Integration Java DSL provides an `IntegrationFlows` factory with its large number of overloaded `from()` methods.", "author": "garyrussell", "createdAt": "2020-03-10T19:59:35Z", "path": "src/reference/asciidoc/kotlin-dsl.adoc", "diffHunk": "@@ -0,0 +1,96 @@\n+[[kotlin-dsl]]\n+== Kotlin DSL\n+\n+The Kotlin DSL is a wrapper and extension to <<./dsl.adoc#java-dsl,Java DSL>> and aimed to make Spring Integration development on Kotlin as smooth and straightforward as is it possible with interoperability with existing Java API and Kotlin language-specific structures.\n+\n+All you need to get started is just an import for `org.springframework.integration.dsl.integrationFlow` - an overloaded global function for Kotlin DSL.\n+\n+For `IntegrationFlow` definitions as lambdas we typically don't need anything else from Kotlin and just declare a bean like this:\n+\n+====\n+[source, kotlin]\n+----\n+@Bean\n+fun oddFlow() =\n+IntegrationFlow { flow ->\n+    flow.handle<Any> { _, _ -> \"odd\" }\n+}\n+----\n+====\n+\n+In this case Kotlin understands that the lambda should be translated into `IntegrationFlow` anonymous instance and target Java DSL processor parses this construction properly into Java objects.\n+\n+As an alternative to the construction above and for consistency with use-cases explained below, a Kotlin-specif DSL should be used for declaring integration flows in the *builder* pattern style:\n+\n+====\n+[source, kotlin]\n+----\n+@Bean\n+fun flowLambda() =\n+    integrationFlow {\n+        filter<String> { it === \"test\" }\n+        wireTap {\n+                    handle { println(it.payload) }\n+                }\n+        transform<String, String> { it.toUpperCase() }\n+    }\n+----\n+====\n+\n+Such a global `integrationFlow()` function expects a lambda in builder style for a `KotlinIntegrationFlowDefinition` (a Kotlin wrapper for the `IntegrationFlowDefinition`) and produces a regular `IntegrationFlow` lambda implementation.\n+See more overloaded `integrationFlow()` variants below.\n+\n+Many other scenarios require an `IntegrationFlow` to be started from source of data (e.g. `JdbcPollingChannelAdapter`, `JmsInboundGateway` or just an existing `MessageChannel`).\n+For this purpose Spring Integration Java DSL provides an `IntegrationFlows` factory with its bunch of overloaded `from()` methods.", "originalCommit": "f0759efd29638adfefefc296b3c929e98fb03fa0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU3NjA2MA==", "url": "https://github.com/spring-projects/spring-integration/pull/3210#discussion_r390576060", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            To fix a gap, this project provides a Kotlin DSL around an `IntegrationFlows` factory.\n          \n          \n            \n            To fix the gap, this project provides a Kotlin DSL around an `IntegrationFlows` factory.", "author": "garyrussell", "createdAt": "2020-03-10T20:00:20Z", "path": "src/reference/asciidoc/kotlin-dsl.adoc", "diffHunk": "@@ -0,0 +1,96 @@\n+[[kotlin-dsl]]\n+== Kotlin DSL\n+\n+The Kotlin DSL is a wrapper and extension to <<./dsl.adoc#java-dsl,Java DSL>> and aimed to make Spring Integration development on Kotlin as smooth and straightforward as is it possible with interoperability with existing Java API and Kotlin language-specific structures.\n+\n+All you need to get started is just an import for `org.springframework.integration.dsl.integrationFlow` - an overloaded global function for Kotlin DSL.\n+\n+For `IntegrationFlow` definitions as lambdas we typically don't need anything else from Kotlin and just declare a bean like this:\n+\n+====\n+[source, kotlin]\n+----\n+@Bean\n+fun oddFlow() =\n+IntegrationFlow { flow ->\n+    flow.handle<Any> { _, _ -> \"odd\" }\n+}\n+----\n+====\n+\n+In this case Kotlin understands that the lambda should be translated into `IntegrationFlow` anonymous instance and target Java DSL processor parses this construction properly into Java objects.\n+\n+As an alternative to the construction above and for consistency with use-cases explained below, a Kotlin-specif DSL should be used for declaring integration flows in the *builder* pattern style:\n+\n+====\n+[source, kotlin]\n+----\n+@Bean\n+fun flowLambda() =\n+    integrationFlow {\n+        filter<String> { it === \"test\" }\n+        wireTap {\n+                    handle { println(it.payload) }\n+                }\n+        transform<String, String> { it.toUpperCase() }\n+    }\n+----\n+====\n+\n+Such a global `integrationFlow()` function expects a lambda in builder style for a `KotlinIntegrationFlowDefinition` (a Kotlin wrapper for the `IntegrationFlowDefinition`) and produces a regular `IntegrationFlow` lambda implementation.\n+See more overloaded `integrationFlow()` variants below.\n+\n+Many other scenarios require an `IntegrationFlow` to be started from source of data (e.g. `JdbcPollingChannelAdapter`, `JmsInboundGateway` or just an existing `MessageChannel`).\n+For this purpose Spring Integration Java DSL provides an `IntegrationFlows` factory with its bunch of overloaded `from()` methods.\n+This factory can be used in Kotlin as well:\n+\n+====\n+[source, kotlin]\n+----\n+@Bean\n+fun flowFromSupplier() =\n+         IntegrationFlows.from<String>({ \"bar\" }) { e -> e.poller { p -> p.fixedDelay(10).maxMessagesPerPoll(1) } }\n+                 .channel { c -> c.queue(\"fromSupplierQueue\") }\n+                 .get()\n+----\n+====\n+\n+But unfortunately not all `from()` methods are compatible with Kotlin structures.\n+To fix a gap, this project provides a Kotlin DSL around an `IntegrationFlows` factory.", "originalCommit": "f0759efd29638adfefefc296b3c929e98fb03fa0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU3Njg3NQ==", "url": "https://github.com/spring-projects/spring-integration/pull/3210#discussion_r390576875", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            It is done as a set of overloaded `integrationFlow()` functions.\n          \n          \n            \n            It is implemented as a set of overloaded `integrationFlow()` functions.", "author": "garyrussell", "createdAt": "2020-03-10T20:01:41Z", "path": "src/reference/asciidoc/kotlin-dsl.adoc", "diffHunk": "@@ -0,0 +1,96 @@\n+[[kotlin-dsl]]\n+== Kotlin DSL\n+\n+The Kotlin DSL is a wrapper and extension to <<./dsl.adoc#java-dsl,Java DSL>> and aimed to make Spring Integration development on Kotlin as smooth and straightforward as is it possible with interoperability with existing Java API and Kotlin language-specific structures.\n+\n+All you need to get started is just an import for `org.springframework.integration.dsl.integrationFlow` - an overloaded global function for Kotlin DSL.\n+\n+For `IntegrationFlow` definitions as lambdas we typically don't need anything else from Kotlin and just declare a bean like this:\n+\n+====\n+[source, kotlin]\n+----\n+@Bean\n+fun oddFlow() =\n+IntegrationFlow { flow ->\n+    flow.handle<Any> { _, _ -> \"odd\" }\n+}\n+----\n+====\n+\n+In this case Kotlin understands that the lambda should be translated into `IntegrationFlow` anonymous instance and target Java DSL processor parses this construction properly into Java objects.\n+\n+As an alternative to the construction above and for consistency with use-cases explained below, a Kotlin-specif DSL should be used for declaring integration flows in the *builder* pattern style:\n+\n+====\n+[source, kotlin]\n+----\n+@Bean\n+fun flowLambda() =\n+    integrationFlow {\n+        filter<String> { it === \"test\" }\n+        wireTap {\n+                    handle { println(it.payload) }\n+                }\n+        transform<String, String> { it.toUpperCase() }\n+    }\n+----\n+====\n+\n+Such a global `integrationFlow()` function expects a lambda in builder style for a `KotlinIntegrationFlowDefinition` (a Kotlin wrapper for the `IntegrationFlowDefinition`) and produces a regular `IntegrationFlow` lambda implementation.\n+See more overloaded `integrationFlow()` variants below.\n+\n+Many other scenarios require an `IntegrationFlow` to be started from source of data (e.g. `JdbcPollingChannelAdapter`, `JmsInboundGateway` or just an existing `MessageChannel`).\n+For this purpose Spring Integration Java DSL provides an `IntegrationFlows` factory with its bunch of overloaded `from()` methods.\n+This factory can be used in Kotlin as well:\n+\n+====\n+[source, kotlin]\n+----\n+@Bean\n+fun flowFromSupplier() =\n+         IntegrationFlows.from<String>({ \"bar\" }) { e -> e.poller { p -> p.fixedDelay(10).maxMessagesPerPoll(1) } }\n+                 .channel { c -> c.queue(\"fromSupplierQueue\") }\n+                 .get()\n+----\n+====\n+\n+But unfortunately not all `from()` methods are compatible with Kotlin structures.\n+To fix a gap, this project provides a Kotlin DSL around an `IntegrationFlows` factory.\n+It is done as a set of overloaded `integrationFlow()` functions.", "originalCommit": "f0759efd29638adfefefc296b3c929e98fb03fa0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU3NzcxMg==", "url": "https://github.com/spring-projects/spring-integration/pull/3210#discussion_r390577712", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            With a consumer for a `KotlinIntegrationFlowDefinition` to declare the rest of the flow as an `IntegrationFlow` lambda to reuse the mentioned above experience and also avoid `get()` call in the end.\n          \n          \n            \n            With a consumer for a `KotlinIntegrationFlowDefinition`, to declare the rest of the flow as an `IntegrationFlow` lambda to reuse the mentioned above experience; unlike the Java DSL, it also avoids the need for a `get()` call at the end of the flow.", "author": "garyrussell", "createdAt": "2020-03-10T20:03:24Z", "path": "src/reference/asciidoc/kotlin-dsl.adoc", "diffHunk": "@@ -0,0 +1,96 @@\n+[[kotlin-dsl]]\n+== Kotlin DSL\n+\n+The Kotlin DSL is a wrapper and extension to <<./dsl.adoc#java-dsl,Java DSL>> and aimed to make Spring Integration development on Kotlin as smooth and straightforward as is it possible with interoperability with existing Java API and Kotlin language-specific structures.\n+\n+All you need to get started is just an import for `org.springframework.integration.dsl.integrationFlow` - an overloaded global function for Kotlin DSL.\n+\n+For `IntegrationFlow` definitions as lambdas we typically don't need anything else from Kotlin and just declare a bean like this:\n+\n+====\n+[source, kotlin]\n+----\n+@Bean\n+fun oddFlow() =\n+IntegrationFlow { flow ->\n+    flow.handle<Any> { _, _ -> \"odd\" }\n+}\n+----\n+====\n+\n+In this case Kotlin understands that the lambda should be translated into `IntegrationFlow` anonymous instance and target Java DSL processor parses this construction properly into Java objects.\n+\n+As an alternative to the construction above and for consistency with use-cases explained below, a Kotlin-specif DSL should be used for declaring integration flows in the *builder* pattern style:\n+\n+====\n+[source, kotlin]\n+----\n+@Bean\n+fun flowLambda() =\n+    integrationFlow {\n+        filter<String> { it === \"test\" }\n+        wireTap {\n+                    handle { println(it.payload) }\n+                }\n+        transform<String, String> { it.toUpperCase() }\n+    }\n+----\n+====\n+\n+Such a global `integrationFlow()` function expects a lambda in builder style for a `KotlinIntegrationFlowDefinition` (a Kotlin wrapper for the `IntegrationFlowDefinition`) and produces a regular `IntegrationFlow` lambda implementation.\n+See more overloaded `integrationFlow()` variants below.\n+\n+Many other scenarios require an `IntegrationFlow` to be started from source of data (e.g. `JdbcPollingChannelAdapter`, `JmsInboundGateway` or just an existing `MessageChannel`).\n+For this purpose Spring Integration Java DSL provides an `IntegrationFlows` factory with its bunch of overloaded `from()` methods.\n+This factory can be used in Kotlin as well:\n+\n+====\n+[source, kotlin]\n+----\n+@Bean\n+fun flowFromSupplier() =\n+         IntegrationFlows.from<String>({ \"bar\" }) { e -> e.poller { p -> p.fixedDelay(10).maxMessagesPerPoll(1) } }\n+                 .channel { c -> c.queue(\"fromSupplierQueue\") }\n+                 .get()\n+----\n+====\n+\n+But unfortunately not all `from()` methods are compatible with Kotlin structures.\n+To fix a gap, this project provides a Kotlin DSL around an `IntegrationFlows` factory.\n+It is done as a set of overloaded `integrationFlow()` functions.\n+With a consumer for a `KotlinIntegrationFlowDefinition` to declare the rest of the flow as an `IntegrationFlow` lambda to reuse the mentioned above experience and also avoid `get()` call in the end.", "originalCommit": "f0759efd29638adfefefc296b3c929e98fb03fa0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU3ODIzMQ==", "url": "https://github.com/spring-projects/spring-integration/pull/3210#discussion_r390578231", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In addition Kotlin extensions are provided for Java DSL API which needs some refinement for Kotlin structures.\n          \n          \n            \n            In addition, Kotlin extensions are provided for the Java DSL API which needs some refinement for Kotlin structures.", "author": "garyrussell", "createdAt": "2020-03-10T20:04:19Z", "path": "src/reference/asciidoc/kotlin-dsl.adoc", "diffHunk": "@@ -0,0 +1,96 @@\n+[[kotlin-dsl]]\n+== Kotlin DSL\n+\n+The Kotlin DSL is a wrapper and extension to <<./dsl.adoc#java-dsl,Java DSL>> and aimed to make Spring Integration development on Kotlin as smooth and straightforward as is it possible with interoperability with existing Java API and Kotlin language-specific structures.\n+\n+All you need to get started is just an import for `org.springframework.integration.dsl.integrationFlow` - an overloaded global function for Kotlin DSL.\n+\n+For `IntegrationFlow` definitions as lambdas we typically don't need anything else from Kotlin and just declare a bean like this:\n+\n+====\n+[source, kotlin]\n+----\n+@Bean\n+fun oddFlow() =\n+IntegrationFlow { flow ->\n+    flow.handle<Any> { _, _ -> \"odd\" }\n+}\n+----\n+====\n+\n+In this case Kotlin understands that the lambda should be translated into `IntegrationFlow` anonymous instance and target Java DSL processor parses this construction properly into Java objects.\n+\n+As an alternative to the construction above and for consistency with use-cases explained below, a Kotlin-specif DSL should be used for declaring integration flows in the *builder* pattern style:\n+\n+====\n+[source, kotlin]\n+----\n+@Bean\n+fun flowLambda() =\n+    integrationFlow {\n+        filter<String> { it === \"test\" }\n+        wireTap {\n+                    handle { println(it.payload) }\n+                }\n+        transform<String, String> { it.toUpperCase() }\n+    }\n+----\n+====\n+\n+Such a global `integrationFlow()` function expects a lambda in builder style for a `KotlinIntegrationFlowDefinition` (a Kotlin wrapper for the `IntegrationFlowDefinition`) and produces a regular `IntegrationFlow` lambda implementation.\n+See more overloaded `integrationFlow()` variants below.\n+\n+Many other scenarios require an `IntegrationFlow` to be started from source of data (e.g. `JdbcPollingChannelAdapter`, `JmsInboundGateway` or just an existing `MessageChannel`).\n+For this purpose Spring Integration Java DSL provides an `IntegrationFlows` factory with its bunch of overloaded `from()` methods.\n+This factory can be used in Kotlin as well:\n+\n+====\n+[source, kotlin]\n+----\n+@Bean\n+fun flowFromSupplier() =\n+         IntegrationFlows.from<String>({ \"bar\" }) { e -> e.poller { p -> p.fixedDelay(10).maxMessagesPerPoll(1) } }\n+                 .channel { c -> c.queue(\"fromSupplierQueue\") }\n+                 .get()\n+----\n+====\n+\n+But unfortunately not all `from()` methods are compatible with Kotlin structures.\n+To fix a gap, this project provides a Kotlin DSL around an `IntegrationFlows` factory.\n+It is done as a set of overloaded `integrationFlow()` functions.\n+With a consumer for a `KotlinIntegrationFlowDefinition` to declare the rest of the flow as an `IntegrationFlow` lambda to reuse the mentioned above experience and also avoid `get()` call in the end.\n+For example:\n+\n+====\n+[source, kotlin]\n+----\n+@Bean\n+fun functionFlow() =\n+        integrationFlow<Function<String, String>>({ beanName(\"functionGateway\") }) {\n+            transform<String, String> { it.toUpperCase() }\n+        }\n+\n+@Bean\n+fun messageSourceFlow() =\n+        integrationFlow(MessageProcessorMessageSource { \"testSource\" },\n+                { poller { it.fixedDelay(10).maxMessagesPerPoll(1) } }) {\n+            channel { queue(\"fromSupplierQueue\") }\n+        }\n+----\n+====\n+\n+In addition Kotlin extensions are provided for Java DSL API which needs some refinement for Kotlin structures.", "originalCommit": "f0759efd29638adfefefc296b3c929e98fb03fa0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e7786f6bfff1e9372a5c6466f28600708bd0aed2", "url": "https://github.com/spring-projects/spring-integration/commit/e7786f6bfff1e9372a5c6466f28600708bd0aed2", "message": "Document Kotlin DSL\n\n* Remove unused imports in `FunctionsTests.kt`", "committedDate": "2020-03-10T20:39:20Z", "type": "commit"}, {"oid": "a4d070ec654f2c6fdcfae2b14b2a0adb4f46b323", "url": "https://github.com/spring-projects/spring-integration/commit/a4d070ec654f2c6fdcfae2b14b2a0adb4f46b323", "message": "* Fix typos in Docs", "committedDate": "2020-03-10T20:43:04Z", "type": "commit"}, {"oid": "a4d070ec654f2c6fdcfae2b14b2a0adb4f46b323", "url": "https://github.com/spring-projects/spring-integration/commit/a4d070ec654f2c6fdcfae2b14b2a0adb4f46b323", "message": "* Fix typos in Docs", "committedDate": "2020-03-10T20:43:04Z", "type": "forcePushed"}]}