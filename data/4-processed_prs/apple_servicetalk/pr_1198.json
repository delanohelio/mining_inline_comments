{"pr_number": 1198, "pr_title": "Consolidation of HTTP codecs with gRPC", "pr_createdAt": "2020-11-05T22:25:24Z", "pr_url": "https://github.com/apple/servicetalk/pull/1198", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQwNzk4OA==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r518407988", "bodyText": "I am on the fence about removing this. I guess we could keep this around and use this interface for gRPC (delegating to the HTTP codec), allowing for logic separation if we need it in the future. @idelpivnitskiy thoughts?", "author": "tkountis", "createdAt": "2020-11-05T22:27:21Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcMessageEncoding.java", "diffHunk": "@@ -1,37 +0,0 @@\n-/*\n- * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.grpc.api;\n-\n-/**\n- * API for <a href=\"https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md#message-encoding\"> message\n- * coding schemes</a>.\n- */\n-public interface GrpcMessageEncoding {", "originalCommit": "a16637fb4f2d6244d8152b15842eb6070a74e4b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxNTI0Mw==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r518515243", "bodyText": "Can you please clarify why you expect the need for gRPC-specific type?", "author": "idelpivnitskiy", "createdAt": "2020-11-06T04:21:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQwNzk4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODc2MzE5NQ==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r518763195", "bodyText": "I can't think of something, that's why I removed it.\nI am just considering whether keeping it allows for some flexibility on doing changes to one without affecting both.", "author": "tkountis", "createdAt": "2020-11-06T13:50:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQwNzk4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk3NDQ2NQ==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r518974465", "bodyText": "After thinking about it more, I'm agreed, it may be safer to have protocol-specific types that delegate the actual compression/decompression work to protocol-agnostic types.\nWe may have servicetalk-content-encoding-api module that will have ContentCodec class and identity, gzip, deflate implementations. Later we can create servicetalk-content-encoding-netty for netty-based implementations.\nThen we may have HttpContentEncoding for http-api and GrpcMessageEncoding for grpc modules. Each will delegate to the necessary API of ContentCodec + have an additional method to set up required header value:\nFor HttpContentEncoding:\ndefault HttpContentEncoding populateHeaders(final HttpHeader headers) {\n    headers.add(CONTENT_ENCODING, name());\n    headers.add(VARY, CONTENT_ENCODING);\n    return this;\n}\nFor GrpcMessageEncoding (should it extend HttpContentEncoding?):\n@Override\ndefault GrpcMessageEncoding populateHeaders(final HttpHeader headers) {\n    headers.set(GRPC_MESSAGE_ENCODING_KEY, name());\n    return this;\n}\nWDYT?", "author": "idelpivnitskiy", "createdAt": "2020-11-06T20:01:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQwNzk4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQzNTQwMQ==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r518435401", "bodyText": "This method is used only in tests and internal utility, can we make it pkg-private for now?", "author": "idelpivnitskiy", "createdAt": "2020-11-05T23:36:36Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcMessageEncodings.java", "diffHunk": "@@ -91,21 +100,21 @@ public static GrpcMessageEncoding deflate() {\n      *          otherwise {@code null} if {@code name} is {@code null} or empty\n      */\n     @Nullable\n-    public static GrpcMessageEncoding encodingFor(final Collection<GrpcMessageEncoding> allowedList,\n-                                                  @Nullable final String name) {\n+    public static ContentCodec encodingFor(final Collection<ContentCodec> allowedList,", "originalCommit": "a16637fb4f2d6244d8152b15842eb6070a74e4b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1NTU4Mw==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r518455583", "bodyText": "Do we need to always add it here? IIRC we always fallback to identity if nothing else was negotiated. With List API there is a risk of adding identity() twice.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T00:39:23Z", "path": "servicetalk-grpc-protobuf/src/main/java/io/servicetalk/grpc/protobuf/ProtoBufSerializationProviderBuilder.java", "diffHunk": "@@ -72,7 +72,7 @@\n      * @return {@code this}\n      */\n     public <T extends MessageLite> ProtoBufSerializationProviderBuilder\n-    supportedMessageEncodings(final Set<GrpcMessageEncoding> supportedEncodings) {\n+    supportedMessageEncodings(final List<ContentCodec> supportedEncodings) {\n         this.supportedEncodings.clear();\n         this.supportedEncodings.addAll(supportedEncodings);\n         this.supportedEncodings.add(identity()); // Always supported", "originalCommit": "a16637fb4f2d6244d8152b15842eb6070a74e4b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODc2NDI1MQ==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r518764251", "bodyText": "This is just to populate the mappings for the serializers. Duplication is not harmful there, I was guarding it, but it offers noise when you read it with no real benefit.", "author": "tkountis", "createdAt": "2020-11-06T13:52:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1NTU4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY4OTk0NQ==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r528689945", "bodyText": "Guarded", "author": "tkountis", "createdAt": "2020-11-23T13:07:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1NTU4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxNDM1MQ==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r518514351", "bodyText": "Can users use a factory from http-api?", "author": "idelpivnitskiy", "createdAt": "2020-11-06T04:17:33Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcMessageEncodings.java", "diffHunk": "@@ -15,72 +15,81 @@\n  */\n package io.servicetalk.grpc.api;\n \n+import io.servicetalk.http.api.ContentCodec;\n+import io.servicetalk.http.api.ContentCodecBuilder;\n+import io.servicetalk.http.api.DefaultStreamingContentCodecBuilder.DeflateStreamingContentCodecBuilder;\n+import io.servicetalk.http.api.DefaultStreamingContentCodecBuilder.GzipStreamingContentCodecBuilder;\n+import io.servicetalk.http.api.IdentityContentCodec;\n+\n import java.util.Collection;\n-import java.util.HashSet;\n-import java.util.Set;\n import javax.annotation.Nullable;\n \n-import static java.util.Arrays.asList;\n-import static java.util.Collections.unmodifiableSet;\n+import static io.servicetalk.http.api.CharSequences.contentEqualsIgnoreCase;\n+import static io.servicetalk.http.api.CharSequences.isEmpty;\n+import static io.servicetalk.http.api.CharSequences.startsWith;\n import static java.util.Objects.requireNonNull;\n \n /**\n  * Default available encoding implementations.\n  * Encoding {@link #identity()} is always supported regardless of the client or server settings.\n- *\n- * {@link #all()} is a set that includes all default encodings {@link #deflate()} and {@link #gzip()}.\n  */\n public final class GrpcMessageEncodings {\n \n-    private static final GrpcMessageEncoding IDENTITY =\n-            new DefaultGrpcMessageEncoding(\"identity\", new IdentityMessageCodec());\n-\n-    private static final GrpcMessageEncoding GZIP =\n-            new DefaultGrpcMessageEncoding(\"gzip\", new GzipMessageCodec());\n+    private static final ContentCodec IDENTITY = new IdentityContentCodec();\n \n-    private static final GrpcMessageEncoding DEFLATE =\n-            new DefaultGrpcMessageEncoding(\"deflate\", new DeflateMessageCodec());\n+    private static final ContentCodec GZIP = new GzipStreamingContentCodecBuilder().build();\n \n-    private static final Set<GrpcMessageEncoding> ALL =\n-            unmodifiableSet(new HashSet<>(asList(IDENTITY, GZIP, DEFLATE)));\n+    private static final ContentCodec DEFLATE = new DeflateStreamingContentCodecBuilder().build();\n \n     private GrpcMessageEncodings() {\n     }\n \n     /**\n-     * Returns the default, always supported 'identity' {@link GrpcMessageEncoding}.\n-     * @return the default, always supported 'identity' {@link GrpcMessageEncoding}\n+     * Returns the default, always supported 'identity' {@link ContentCodec}.\n+     * @return the default, always supported 'identity' {@link ContentCodec}\n      */\n-    public static GrpcMessageEncoding identity() {\n+    public static ContentCodec identity() {\n         return IDENTITY;\n     }\n \n     /**\n-     * Returns a GZIP based {@link GrpcMessageEncoding} backed by {@link java.util.zip.Inflater}.\n-     * @return a GZIP based {@link GrpcMessageEncoding} backed by {@link java.util.zip.Inflater}\n+     * Returns a GZIP based {@link ContentCodec} backed by {@link java.util.zip.Inflater}.\n+     * The max allowed payload size for this codec is 2Mib.\n+     *\n+     * @return a GZIP based {@link ContentCodec} backed by {@link java.util.zip.Inflater}\n      */\n-    public static GrpcMessageEncoding gzip() {\n+    public static ContentCodec gzipDefault() {", "originalCommit": "a16637fb4f2d6244d8152b15842eb6070a74e4b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODc2NDY3Mg==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r518764672", "bodyText": "Yes we can, especially if we merged the codec APIs then its even better.", "author": "tkountis", "createdAt": "2020-11-06T13:53:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxNDM1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxNTYwOQ==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r518515609", "bodyText": "Sad that we need to duplicate these logic in HTTP and gRPC :(\nHope we can have a better way to share it in the future.", "author": "idelpivnitskiy", "createdAt": "2020-11-06T04:23:12Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcUtils.java", "diffHunk": "@@ -241,14 +239,14 @@ private static void ensureGrpcStatusReceived(final HttpHeaders headers) {\n         }\n     }\n \n-    static GrpcMessageEncoding readGrpcMessageEncoding(final HttpMetaData httpMetaData,\n-                                                       final Set<GrpcMessageEncoding> allowedEncodings) {\n+    static ContentCodec readGrpcMessageEncoding(final HttpMetaData httpMetaData,", "originalCommit": "a16637fb4f2d6244d8152b15842eb6070a74e4b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY5MDIwNg==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r528690206", "bodyText": "Agreed offline to move these in a separate module in a separate PR", "author": "tkountis", "createdAt": "2020-11-23T13:08:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxNTYwOQ=="}], "type": "inlineReview"}, {"oid": "fe79c1f71f8d710eff342f269a40cc7d0b1ba8ed", "url": "https://github.com/apple/servicetalk/commit/fe79c1f71f8d710eff342f269a40cc7d0b1ba8ed", "message": "Consolidate Http codecs with gRPC", "committedDate": "2020-11-23T10:40:52Z", "type": "forcePushed"}, {"oid": "6701c4ab0efbcbe9fa506dec5314931ce1176329", "url": "https://github.com/apple/servicetalk/commit/6701c4ab0efbcbe9fa506dec5314931ce1176329", "message": "Consolidate Http codecs with gRPC", "committedDate": "2020-11-23T12:47:45Z", "type": "forcePushed"}, {"oid": "28b12ddabbe2beb3dd8e36711061aaf93112a509", "url": "https://github.com/apple/servicetalk/commit/28b12ddabbe2beb3dd8e36711061aaf93112a509", "message": "Consolidate Http codecs with gRPC", "committedDate": "2020-11-23T13:04:05Z", "type": "forcePushed"}, {"oid": "c50b348928dbb6bd4ee0eff1e0a53939a7ddbe4a", "url": "https://github.com/apple/servicetalk/commit/c50b348928dbb6bd4ee0eff1e0a53939a7ddbe4a", "message": "Consolidate Http codecs with gRPC", "committedDate": "2020-11-23T15:40:52Z", "type": "commit"}, {"oid": "c50b348928dbb6bd4ee0eff1e0a53939a7ddbe4a", "url": "https://github.com/apple/servicetalk/commit/c50b348928dbb6bd4ee0eff1e0a53939a7ddbe4a", "message": "Consolidate Http codecs with gRPC", "committedDate": "2020-11-23T15:40:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI3NDA5Ng==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r529274096", "bodyText": "buffer.readableBytes() is int. Can we simplify this to (int) min(buffer.readableBytes(), n)?\nWe should also account for negative n. The original skip method from the superclass does:\nif (n <= 0) {\n    return 0;\n}", "author": "idelpivnitskiy", "createdAt": "2020-11-24T08:06:21Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/AbstractZipContentCodec.java", "diffHunk": "@@ -579,4 +580,55 @@ public void write(byte[] b, int off, int len) {\n             buffer.writeBytes(b, off, len);\n         }\n     }\n+\n+    static final class BufferBoundedInputStream extends InputStream {\n+        private final Buffer buffer;\n+        private final int limit;\n+        private int count;\n+\n+        BufferBoundedInputStream(Buffer buffer, int limit) {\n+            this.buffer = requireNonNull(buffer);\n+            this.limit = limit;\n+        }\n+\n+        @Override\n+        public int read() {\n+            if (buffer.readableBytes() == 0) {\n+                return -1;\n+            }\n+            if (++count > limit) {\n+                throw new IndexOutOfBoundsException(\"Buffer limit has been reached: \" +\n+                        count + \" (expected <= \" + limit + \") bytes\");\n+            }\n+            return buffer.readByte() & 0xff;\n+        }\n+\n+        @Override\n+        public int read(byte[] b, int off, int len) {\n+            int readableBytes = buffer.readableBytes();\n+            if (readableBytes == 0) {\n+                return -1;\n+            }\n+            int bytes = min(readableBytes, len);\n+            if (count + bytes > limit) {\n+                throw new IndexOutOfBoundsException(\"Buffer limit has been reached: \" +\n+                        count + \" (expected <= \" + limit + \") bytes\");\n+            }\n+            count += bytes;\n+            buffer.readBytes(b, off, bytes);\n+            return bytes;\n+        }\n+\n+        @Override\n+        public long skip(long n) {\n+            int skipped = min(buffer.readableBytes(), (int) min(Integer.MAX_VALUE, n));", "originalCommit": "c50b348928dbb6bd4ee0eff1e0a53939a7ddbe4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxNTk4Mw==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r530015983", "bodyText": "I added the negative guard, but the cast to integer might not be the right way.\nCurrently the max allowed input is INT_MAX, if I relax that and cast the input, that could mean that an arbitrary input of (long 4294967297 -> int 1) can be used to skip 1 bytes rather than all available bytes.\nUnexpected behavior.", "author": "tkountis", "createdAt": "2020-11-24T23:44:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI3NDA5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAxOTM2Mg==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r533019362", "bodyText": "You don't need to cast the input, min(buffer.readableBytes(), n) will cast readableBytes to long. Because readableBytes is int, it can not be more than Integer.MAX_VALUE. Then the long result of the min function can safely be cast back to int: (int) min(buffer.readableBytes(), n).", "author": "idelpivnitskiy", "createdAt": "2020-12-01T01:48:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI3NDA5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI2Njc1MQ==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r533266751", "bodyText": "ofc \ud83e\udd26", "author": "tkountis", "createdAt": "2020-12-01T10:07:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI3NDA5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI3NDczMg==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r529274732", "bodyText": "We should count skipped bytes. Otherwise, we can go over the limit.", "author": "idelpivnitskiy", "createdAt": "2020-11-24T08:07:32Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/AbstractZipContentCodec.java", "diffHunk": "@@ -579,4 +580,55 @@ public void write(byte[] b, int off, int len) {\n             buffer.writeBytes(b, off, len);\n         }\n     }\n+\n+    static final class BufferBoundedInputStream extends InputStream {\n+        private final Buffer buffer;\n+        private final int limit;\n+        private int count;\n+\n+        BufferBoundedInputStream(Buffer buffer, int limit) {\n+            this.buffer = requireNonNull(buffer);\n+            this.limit = limit;\n+        }\n+\n+        @Override\n+        public int read() {\n+            if (buffer.readableBytes() == 0) {\n+                return -1;\n+            }\n+            if (++count > limit) {\n+                throw new IndexOutOfBoundsException(\"Buffer limit has been reached: \" +\n+                        count + \" (expected <= \" + limit + \") bytes\");\n+            }\n+            return buffer.readByte() & 0xff;\n+        }\n+\n+        @Override\n+        public int read(byte[] b, int off, int len) {\n+            int readableBytes = buffer.readableBytes();\n+            if (readableBytes == 0) {\n+                return -1;\n+            }\n+            int bytes = min(readableBytes, len);\n+            if (count + bytes > limit) {\n+                throw new IndexOutOfBoundsException(\"Buffer limit has been reached: \" +\n+                        count + \" (expected <= \" + limit + \") bytes\");\n+            }\n+            count += bytes;\n+            buffer.readBytes(b, off, bytes);\n+            return bytes;\n+        }\n+\n+        @Override\n+        public long skip(long n) {\n+            int skipped = min(buffer.readableBytes(), (int) min(Integer.MAX_VALUE, n));\n+            buffer.skipBytes(skipped);\n+            return skipped;", "originalCommit": "c50b348928dbb6bd4ee0eff1e0a53939a7ddbe4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI3NzQ0MA==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r529277440", "bodyText": "We should verify that len is not negative. buffer.readBytes will do the check but it will be too late, because you do count += bytes before that and bytes can be negative.", "author": "idelpivnitskiy", "createdAt": "2020-11-24T08:12:11Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/AbstractZipContentCodec.java", "diffHunk": "@@ -579,4 +580,55 @@ public void write(byte[] b, int off, int len) {\n             buffer.writeBytes(b, off, len);\n         }\n     }\n+\n+    static final class BufferBoundedInputStream extends InputStream {\n+        private final Buffer buffer;\n+        private final int limit;\n+        private int count;\n+\n+        BufferBoundedInputStream(Buffer buffer, int limit) {\n+            this.buffer = requireNonNull(buffer);\n+            this.limit = limit;\n+        }\n+\n+        @Override\n+        public int read() {\n+            if (buffer.readableBytes() == 0) {\n+                return -1;\n+            }\n+            if (++count > limit) {\n+                throw new IndexOutOfBoundsException(\"Buffer limit has been reached: \" +\n+                        count + \" (expected <= \" + limit + \") bytes\");\n+            }\n+            return buffer.readByte() & 0xff;\n+        }\n+\n+        @Override\n+        public int read(byte[] b, int off, int len) {\n+            int readableBytes = buffer.readableBytes();\n+            if (readableBytes == 0) {\n+                return -1;\n+            }\n+            int bytes = min(readableBytes, len);", "originalCommit": "c50b348928dbb6bd4ee0eff1e0a53939a7ddbe4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI3OTcyNQ==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r529279725", "bodyText": "Discussed offline and confirmed that we actually need the variant with length for gRPC because the received Buffer may contain more data that we want to encode/decode. In this case, the offset, limit is more standard API approach. Can you please reverth the offset? Sorry for back and forth.", "author": "idelpivnitskiy", "createdAt": "2020-11-24T08:16:22Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/ContentCodec.java", "diffHunk": "@@ -41,19 +41,18 @@\n      * @return {@link Buffer} the result buffer with the content encoded\n      */\n     default Buffer encode(Buffer src, BufferAllocator allocator) {\n-        return encode(src, src.readerIndex(), src.readableBytes(), allocator);\n+        return encode(src, src.readableBytes(), allocator);\n     }\n \n     /**\n      * Take a {@link Buffer} and encode its contents resulting in a {@link Buffer} with the encoded contents.\n      *\n      * @param src the {@link Buffer} to encode\n-     * @param offset the offset of the source to start reading from\n      * @param length the total length available for reading\n      * @param allocator the {@link BufferAllocator} to use for allocating auxiliary buffers or the returned buffer\n      * @return {@link Buffer} the result buffer with the content encoded\n      */\n-    Buffer encode(Buffer src, int offset, int length, BufferAllocator allocator);\n+    Buffer encode(Buffer src, int length, BufferAllocator allocator);", "originalCommit": "c50b348928dbb6bd4ee0eff1e0a53939a7ddbe4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTk3NjI5Mw==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r529976293", "bodyText": "It is more standard API, but in our case it seems (to me) more confusing.\nBuffer has the reader/writer indexes, which these methods mutate. So we typically mutate the readerIndex after consuming the buffer, to current_readerIndex + limit. If we support offset, that can be different than the readerIndex, (before or after), what happens to the readerIndex if the offset + limit < current_readerIndex? Do we move it back to adhere to the contract or keep it unchanged?\nI think since the Buffer API allows easy positioning of the readerIndex, we should allow the caller to rely on that for offsetting.\nWDYT?", "author": "tkountis", "createdAt": "2020-11-24T23:01:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI3OTcyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAyNDIyNQ==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r533024225", "bodyText": "Good point. Let's discuss offline what should be the default behavior of all codecs and deserializers. We are currently inconsistent. If we will decide to move indexes everywhere, then having only length here is reasonable. If we decide not to move indexes, then offset may be important.", "author": "idelpivnitskiy", "createdAt": "2020-12-01T02:03:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI3OTcyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI4Mjg3NQ==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r529282875", "bodyText": "It can be private", "author": "idelpivnitskiy", "createdAt": "2020-11-24T08:21:39Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/DefaultGrpcServiceContext.java", "diffHunk": "@@ -16,33 +16,36 @@\n package io.servicetalk.grpc.api;\n \n import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.encoding.api.ContentCodec;\n import io.servicetalk.http.api.HttpConnectionContext.HttpProtocol;\n import io.servicetalk.http.api.HttpServiceContext;\n import io.servicetalk.transport.api.ConnectionContext;\n \n import java.net.SocketAddress;\n import java.net.SocketOption;\n-import java.util.Set;\n+import java.util.ArrayList;\n+import java.util.List;\n import javax.annotation.Nullable;\n import javax.net.ssl.SSLSession;\n \n-import static java.util.Collections.unmodifiableSet;\n+import static java.util.Collections.unmodifiableList;\n import static java.util.Objects.requireNonNull;\n \n final class DefaultGrpcServiceContext extends DefaultGrpcMetadata implements GrpcServiceContext {\n \n     private final ConnectionContext connectionContext;\n     private final GrpcExecutionContext executionContext;\n     private final GrpcProtocol protocol;\n-    final Set<GrpcMessageEncoding> supportedEncodings;\n+\n+    final List<ContentCodec> supportedMessageCodings;", "originalCommit": "c50b348928dbb6bd4ee0eff1e0a53939a7ddbe4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI4NDM1Nw==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r529284357", "bodyText": "It's not a set anymore. Consider avoiding a collection name. {@link ContentCodec} codings available ... should be enough.", "author": "idelpivnitskiy", "createdAt": "2020-11-24T08:24:00Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcServiceContext.java", "diffHunk": "@@ -32,13 +33,13 @@\n     GrpcProtocol protocol();\n \n     /**\n-     * The set of {@link GrpcMessageEncoding} encoding used for this\n+     * The set of {@link ContentCodec} codings available for this", "originalCommit": "c50b348928dbb6bd4ee0eff1e0a53939a7ddbe4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI4NDQ4Mg==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r529284482", "bodyText": "same", "author": "idelpivnitskiy", "createdAt": "2020-11-24T08:24:14Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcServiceContext.java", "diffHunk": "@@ -32,13 +33,13 @@\n     GrpcProtocol protocol();\n \n     /**\n-     * The set of {@link GrpcMessageEncoding} encoding used for this\n+     * The set of {@link ContentCodec} codings available for this\n      * <a href=\"https://www.grpc.io\">gRPC</a> call.\n      *\n-     * @return the set of {@link GrpcMessageEncoding} encoding used for this\n+     * @return the set of {@link ContentCodec} codings available for this", "originalCommit": "c50b348928dbb6bd4ee0eff1e0a53939a7ddbe4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI4NTcyMQ==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r529285721", "bodyText": "Consider avoiding clarifying a type of the collection", "author": "idelpivnitskiy", "createdAt": "2020-11-24T08:26:12Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcClientFactory.java", "diffHunk": "@@ -107,23 +110,23 @@ final BlockingClient newBlockingClientForCallFactory(GrpcClientCallFactory clien\n \n     /**\n      * Sets the supported message encodings for this client factory.\n-     * By default only {@link GrpcMessageEncodings#identity()} is supported\n+     * By default only {@link io.servicetalk.encoding.api.ContentCodings#identity()} is supported\n      *\n-     * @param supportedEncodings {@link GrpcMessageEncoding} supported encodings for this client.\n+     * @param codings {@link ContentCodec} supported encodings for this client.\n      * @return {@code this}\n      */\n     public GrpcClientFactory<Client, BlockingClient, Filter, FilterableClient, FilterFactory>\n-    supportedEncodings(final Set<GrpcMessageEncoding> supportedEncodings) {\n-        this.supportedEncodings = unmodifiableSet(supportedEncodings);\n+    supportedMessageCodings(List<ContentCodec> codings) {\n+        this.supportedCodings = unmodifiableList(new ArrayList<>(codings));\n         return this;\n     }\n \n     /**\n-     * Return the list of supported {@link GrpcMessageEncoding}s for this client factory.\n-     * @return the list of supported {@link GrpcMessageEncoding}s for this client factory\n+     * Return the list of supported {@link ContentCodec}s for this client factory.\n+     * @return the list of supported {@link ContentCodec}s for this client factory", "originalCommit": "c50b348928dbb6bd4ee0eff1e0a53939a7ddbe4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI4Njg4MA==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r529286880", "bodyText": "Consider saying that without mentioning the type of the collection: supported {@link ContentCodec}s ....\nFor the first line and @return tag.", "author": "idelpivnitskiy", "createdAt": "2020-11-24T08:27:54Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcSerializationProvider.java", "diffHunk": "@@ -15,36 +15,43 @@\n  */\n package io.servicetalk.grpc.api;\n \n+import io.servicetalk.encoding.api.ContentCodec;\n import io.servicetalk.http.api.HttpDeserializer;\n import io.servicetalk.http.api.HttpSerializer;\n \n-import java.util.Set;\n+import java.util.List;\n \n /**\n  * A provider for <a href=\"https://www.grpc.io\">gRPC</a> serialization/deserialization.\n  */\n public interface GrpcSerializationProvider {\n \n-    Set<GrpcMessageEncoding> supportedEncodings();\n+    /**\n+     * List of supported {@link ContentCodec}s for this {@link GrpcSerializationProvider}.\n+     * Content codings will be used to encoded and decode gRPC messages according to configuration of client and server.\n+     *\n+     * @return list of supported {@link ContentCodec}s for this {@link GrpcSerializationProvider}", "originalCommit": "c50b348928dbb6bd4ee0eff1e0a53939a7ddbe4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAyNDQ0MQ==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r533024441", "bodyText": "This is not fixed, reminder :)", "author": "idelpivnitskiy", "createdAt": "2020-12-01T02:04:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI4Njg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI5MTc3Ng==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r529291776", "bodyText": "Should we allocate a new ArrayList with allowedCodings.size() as an initial capacity?", "author": "idelpivnitskiy", "createdAt": "2020-11-24T08:35:44Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcUtils.java", "diffHunk": "@@ -241,34 +247,33 @@ private static void ensureGrpcStatusReceived(final HttpHeaders headers) {\n         }\n     }\n \n-    static GrpcMessageEncoding readGrpcMessageEncoding(final HttpMetaData httpMetaData,\n-                                                       final Set<GrpcMessageEncoding> allowedEncodings) {\n+    static ContentCodec readGrpcMessageEncoding(final HttpMetaData httpMetaData,\n+                                                final List<ContentCodec> allowedEncodings) {\n         final CharSequence encoding = httpMetaData.headers().get(GRPC_MESSAGE_ENCODING_KEY);\n         if (encoding == null) {\n             return identity();\n         }\n \n-        GrpcMessageEncoding enc = encodingFor(allowedEncodings, encoding.toString());\n+        ContentCodec enc = encodingFor(allowedEncodings, encoding);\n         if (enc == null) {\n-            final String lowercaseEncoding = encoding.toString().toLowerCase();\n-            throw new MessageEncodingException(lowercaseEncoding);\n+            throw new MessageEncodingException(encoding.toString());\n         }\n \n         return enc;\n     }\n \n-    static Set<GrpcMessageEncoding> readGrpcAcceptMessageEncoding(final HttpMetaData httpMetaData,\n-                                                                  final Set<GrpcMessageEncoding> acceptedEncodings) {\n+    static List<ContentCodec> readGrpcAcceptMessageEncoding(final HttpMetaData httpMetaData,\n+                                                            final List<ContentCodec> allowedCodings) {\n         final CharSequence acceptEncodingsHeaderVal = httpMetaData.headers().get(GRPC_ACCEPT_ENCODING_KEY);\n \n         if (acceptEncodingsHeaderVal == null || acceptEncodingsHeaderVal.length() == 0) {\n             return GRPC_ACCEPT_ENCODING_NONE;\n         }\n \n-        Set<GrpcMessageEncoding> knownEncodings = new HashSet<>();\n+        List<ContentCodec> knownEncodings = new ArrayList<>();", "originalCommit": "c50b348928dbb6bd4ee0eff1e0a53939a7ddbe4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI5MzY4NA==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r529293684", "bodyText": "IIUC, allowedList is always a non-null object. We can remove this check. Worst case, the for loop below will generate NPE.", "author": "idelpivnitskiy", "createdAt": "2020-11-24T08:38:46Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcUtils.java", "diffHunk": "@@ -315,13 +329,51 @@ static GrpcMessageEncoding firstMatchingEncodingOrNone(final Set<GrpcMessageEnco\n         return identity();\n     }\n \n+    /**\n+     * Returns the {@link ContentCodec} that matches the {@code name} within the {@code allowedList}.\n+     * if {@code name} is {@code null} or empty it results in {@code null} .\n+     * If {@code name} is {@code 'identity'} this will always result in\n+     * {@link ContentCodings#identity()} regardless of its presence in the {@code allowedList}.\n+     *\n+     * @param allowedList the source list to find a matching codec from.\n+     * @param name the codec name used for the equality predicate.\n+     * @return a codec from the allowed-list that name matches the {@code name}.\n+     */\n+    @Nullable\n+    static ContentCodec encodingFor(final Collection<ContentCodec> allowedList,\n+                                    @Nullable final CharSequence name) {\n+        requireNonNull(allowedList);", "originalCommit": "c50b348928dbb6bd4ee0eff1e0a53939a7ddbe4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTMwMDk1OA==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r529300958", "bodyText": "Here and in all other places where you use negotiateAcceptedEncoding: it can return null and Intellij IDEA complains that you later use serializationProvider.serializerFor(responseEncoding, ...) because serizlizerFor does not expect null here.", "author": "idelpivnitskiy", "createdAt": "2020-11-24T08:50:09Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRouter.java", "diffHunk": "@@ -313,17 +314,17 @@ public Completable closeAsyncGracefully() {\n                     public Single<StreamingHttpResponse> handle(final HttpServiceContext ctx,\n                                                                 final StreamingHttpRequest request,\n                                                                 final StreamingHttpResponseFactory responseFactory) {\n-                        GrpcMessageEncoding responseEncoding;\n+                        ContentCodec responseEncoding;\n                         GrpcServiceContext serviceContext = null;\n \n                         try {\n-                            final Set<GrpcMessageEncoding> supportedEncodings =\n-                                    serializationProvider.supportedEncodings();\n-                            responseEncoding = firstMatchingEncodingOrNone(request, supportedEncodings);\n-                            serviceContext = new DefaultGrpcServiceContext(request.path(), ctx, supportedEncodings);\n+                            final List<ContentCodec> supportedCodings =\n+                                    serializationProvider.supportedMessageCodings();\n+                            responseEncoding = negotiateAcceptedEncoding(request, supportedCodings);", "originalCommit": "c50b348928dbb6bd4ee0eff1e0a53939a7ddbe4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTMwMTk0NA==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r529301944", "bodyText": "This method never returns null", "author": "idelpivnitskiy", "createdAt": "2020-11-24T08:51:42Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcUtils.java", "diffHunk": "@@ -277,36 +282,45 @@ static GrpcMessageEncoding readGrpcMessageEncoding(final HttpMetaData httpMetaDa\n         return knownEncodings;\n     }\n \n-    static GrpcMessageEncoding firstMatchingEncodingOrNone(final HttpMetaData httpMetaData,\n-                                                           final Set<GrpcMessageEncoding> serverSupportedEncodings) {\n-        // Fast path, server has no encodings configured or has only None configured as encoding\n-        if (serverSupportedEncodings.isEmpty() ||\n-                (serverSupportedEncodings.size() == 1 && serverSupportedEncodings.contains(identity()))) {\n+    /**\n+     * Establish a commonly accepted encoding between server and client, according to the supported-codings\n+     * on the server side and the {@code 'Accepted-Encoding'} incoming header on the request.\n+     * <p>\n+     * If no supported codings are configured then the result is always {@code identity}\n+     * If no accepted codings are present in the request then the result is always {@code identity}\n+     * In all other cases, the first matching encoding (that is NOT {@link ContentCodings#identity()}) is preferred,\n+     * otherwise {@code identity} is returned.\n+     *\n+     * @param httpMetaData The client metadata to extract relevant headers from.\n+     * @param allowedCodings The server supported codings as configured.\n+     * @return The {@link ContentCodec} that satisfies both client and server needs, identity otherwise.\n+     */\n+    @Nullable\n+    static ContentCodec negotiateAcceptedEncoding(\n+            final HttpMetaData httpMetaData,\n+            final List<ContentCodec> allowedCodings) {\n+\n+        // Fast path, server has no codings configured or has only identity configured as encoding\n+        if (allowedCodings.isEmpty() ||\n+                (allowedCodings.size() == 1 && allowedCodings.contains(identity()))) {\n             return identity();\n         }\n \n-        Set<GrpcMessageEncoding> clientSupportedEncodings =\n-                readGrpcAcceptMessageEncoding(httpMetaData, serverSupportedEncodings);\n-        return firstMatchingEncodingOrNone(clientSupportedEncodings, serverSupportedEncodings);\n+        List<ContentCodec> clientSupportedEncodings =\n+                readGrpcAcceptMessageEncoding(httpMetaData, allowedCodings);\n+        return negotiateAcceptedEncoding(clientSupportedEncodings, allowedCodings);\n     }\n \n-    static GrpcMessageEncoding firstMatchingEncodingOrNone(final Set<GrpcMessageEncoding> clientSupportedEncodings,\n-                                                           final Set<GrpcMessageEncoding> serverSupportedEncodings) {\n-        // Fast path, Client has no encodings configured, or has None as the only encoding configured\n+    @Nullable", "originalCommit": "c50b348928dbb6bd4ee0eff1e0a53939a7ddbe4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTMwMjAyNA==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r529302024", "bodyText": "This method never returns null", "author": "idelpivnitskiy", "createdAt": "2020-11-24T08:51:50Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcUtils.java", "diffHunk": "@@ -277,36 +282,45 @@ static GrpcMessageEncoding readGrpcMessageEncoding(final HttpMetaData httpMetaDa\n         return knownEncodings;\n     }\n \n-    static GrpcMessageEncoding firstMatchingEncodingOrNone(final HttpMetaData httpMetaData,\n-                                                           final Set<GrpcMessageEncoding> serverSupportedEncodings) {\n-        // Fast path, server has no encodings configured or has only None configured as encoding\n-        if (serverSupportedEncodings.isEmpty() ||\n-                (serverSupportedEncodings.size() == 1 && serverSupportedEncodings.contains(identity()))) {\n+    /**\n+     * Establish a commonly accepted encoding between server and client, according to the supported-codings\n+     * on the server side and the {@code 'Accepted-Encoding'} incoming header on the request.\n+     * <p>\n+     * If no supported codings are configured then the result is always {@code identity}\n+     * If no accepted codings are present in the request then the result is always {@code identity}\n+     * In all other cases, the first matching encoding (that is NOT {@link ContentCodings#identity()}) is preferred,\n+     * otherwise {@code identity} is returned.\n+     *\n+     * @param httpMetaData The client metadata to extract relevant headers from.\n+     * @param allowedCodings The server supported codings as configured.\n+     * @return The {@link ContentCodec} that satisfies both client and server needs, identity otherwise.\n+     */\n+    @Nullable", "originalCommit": "c50b348928dbb6bd4ee0eff1e0a53939a7ddbe4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTMwNTg4OQ==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r529305889", "bodyText": "Consider assigning a new ArrayList<>(supportedCodings). Otherwise, it will modify the existing list which could be already passed to ProtoSerializationProvider ctor. Users can invoke build() multiple times.", "author": "idelpivnitskiy", "createdAt": "2020-11-24T08:57:24Z", "path": "servicetalk-grpc-protobuf/src/main/java/io/servicetalk/grpc/protobuf/ProtoBufSerializationProviderBuilder.java", "diffHunk": "@@ -57,25 +56,27 @@\n     private static final CharSequence GRPC_MESSAGE_ENCODING_KEY = newAsciiString(\"grpc-encoding\");\n     private static final CharSequence APPLICATION_GRPC_PROTO = newAsciiString(\"application/grpc+proto\");\n \n-    private final Map<Class, Map<GrpcMessageEncoding, HttpSerializer>> serializers = new HashMap<>();\n-    private final Map<Class, Map<GrpcMessageEncoding, HttpDeserializer>> deserializers = new HashMap<>();\n+    private final Map<Class, Map<ContentCodec, HttpSerializer>> serializers = new HashMap<>();\n+    private final Map<Class, Map<ContentCodec, HttpDeserializer>> deserializers = new HashMap<>();\n \n-    private final Set<GrpcMessageEncoding> supportedEncodings = new HashSet<>(asList(identity()));\n+    private final List<ContentCodec> supportedCodings = new ArrayList<>(singletonList(identity()));\n \n     /**\n      * Set the supported message encodings for the serializers and deserializers.\n      * The encodings will be advertised on the endpoint's headers and also used to validate each encoded message\n-     * {@link GrpcMessageEncodings#identity()} is always supported regardless of the config passed\n+     * {@link io.servicetalk.encoding.api.ContentCodings#identity()} is always supported regardless of the config passed\n      *\n-     * @param supportedEncodings the set of allowed encodings\n+     * @param supportedCodings the set of allowed encodings\n      * @param <T> Type of {@link MessageLite} to register.\n      * @return {@code this}\n      */\n     public <T extends MessageLite> ProtoBufSerializationProviderBuilder\n-    supportedMessageEncodings(final Set<GrpcMessageEncoding> supportedEncodings) {\n-        this.supportedEncodings.clear();\n-        this.supportedEncodings.addAll(supportedEncodings);\n-        this.supportedEncodings.add(identity()); // Always supported\n+    supportedMessageCodings(final List<ContentCodec> supportedCodings) {\n+        this.supportedCodings.clear();\n+        this.supportedCodings.addAll(supportedCodings);", "originalCommit": "c50b348928dbb6bd4ee0eff1e0a53939a7ddbe4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg1OTk0OQ==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r529859949", "bodyText": "Nice catch", "author": "tkountis", "createdAt": "2020-11-24T20:31:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTMwNTg4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTMwNjU5NQ==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r529306595", "bodyText": "Then we don't need new ArrayList here.", "author": "idelpivnitskiy", "createdAt": "2020-11-24T08:58:19Z", "path": "servicetalk-grpc-protobuf/src/main/java/io/servicetalk/grpc/protobuf/ProtoBufSerializationProviderBuilder.java", "diffHunk": "@@ -57,25 +56,27 @@\n     private static final CharSequence GRPC_MESSAGE_ENCODING_KEY = newAsciiString(\"grpc-encoding\");\n     private static final CharSequence APPLICATION_GRPC_PROTO = newAsciiString(\"application/grpc+proto\");\n \n-    private final Map<Class, Map<GrpcMessageEncoding, HttpSerializer>> serializers = new HashMap<>();\n-    private final Map<Class, Map<GrpcMessageEncoding, HttpDeserializer>> deserializers = new HashMap<>();\n+    private final Map<Class, Map<ContentCodec, HttpSerializer>> serializers = new HashMap<>();\n+    private final Map<Class, Map<ContentCodec, HttpDeserializer>> deserializers = new HashMap<>();\n \n-    private final Set<GrpcMessageEncoding> supportedEncodings = new HashSet<>(asList(identity()));\n+    private final List<ContentCodec> supportedCodings = new ArrayList<>(singletonList(identity()));", "originalCommit": "c50b348928dbb6bd4ee0eff1e0a53939a7ddbe4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTMwODU2Nw==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r529308567", "bodyText": "supportedCodings can be configured after registerMessageType. As the result, both maps will be incorrect.", "author": "idelpivnitskiy", "createdAt": "2020-11-24T08:59:46Z", "path": "servicetalk-grpc-protobuf/src/main/java/io/servicetalk/grpc/protobuf/ProtoBufSerializationProviderBuilder.java", "diffHunk": "@@ -89,14 +90,14 @@\n      */\n     public <T extends MessageLite> ProtoBufSerializationProviderBuilder\n     registerMessageType(Class<T> messageType, Parser<T> parser) {\n-        Map<GrpcMessageEncoding, HttpSerializer> serializersForType = new HashMap<>();\n-        Map<GrpcMessageEncoding, HttpDeserializer> deserializersForType = new HashMap<>();\n-        for (GrpcMessageEncoding grpcMessageEncoding : supportedEncodings) {\n+        Map<ContentCodec, HttpSerializer> serializersForType = new HashMap<>();\n+        Map<ContentCodec, HttpDeserializer> deserializersForType = new HashMap<>();\n+        for (ContentCodec codec : supportedCodings) {", "originalCommit": "c50b348928dbb6bd4ee0eff1e0a53939a7ddbe4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxMTcxNw==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r530011717", "bodyText": "hmm, I was working under the impression that this is only accessible through the generators, so order was guaranteed. But this all is public. Good catch", "author": "tkountis", "createdAt": "2020-11-24T23:37:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTMwODU2Nw=="}], "type": "inlineReview"}, {"oid": "c49ceb4060d64b854db56753e5e1383515578b60", "url": "https://github.com/apple/servicetalk/commit/c49ceb4060d64b854db56753e5e1383515578b60", "message": "Fix comments & other improvements", "committedDate": "2020-11-25T16:05:41Z", "type": "forcePushed"}, {"oid": "ad3c67e938f58c328a04244978ccba8ca26730f6", "url": "https://github.com/apple/servicetalk/commit/ad3c67e938f58c328a04244978ccba8ca26730f6", "message": "Fix comments & other improvements", "committedDate": "2020-11-25T17:13:08Z", "type": "commit"}, {"oid": "ad3c67e938f58c328a04244978ccba8ca26730f6", "url": "https://github.com/apple/servicetalk/commit/ad3c67e938f58c328a04244978ccba8ca26730f6", "message": "Fix comments & other improvements", "committedDate": "2020-11-25T17:13:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjkwNjY5NA==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r532906694", "bodyText": "We should not override the year, we can append or change a region. Examples:\n2018 -> 2018, 2020\n2019 -> 2019-2020\n2018-2019 -> 2018-2020", "author": "idelpivnitskiy", "createdAt": "2020-11-30T21:12:56Z", "path": "servicetalk-buffer-api/src/main/java/io/servicetalk/buffer/api/BufferInputStream.java", "diffHunk": "@@ -1,5 +1,5 @@\n /*\n- * Copyright \u00a9 2018 Apple Inc. and the ServiceTalk project authors\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors", "originalCommit": "ad3c67e938f58c328a04244978ccba8ca26730f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAwNjk4NA==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r533006984", "bodyText": "Good catch to make both paths consistent \ud83c\udf96\ufe0f", "author": "idelpivnitskiy", "createdAt": "2020-12-01T01:10:13Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/AbstractZipContentCodec.java", "diffHunk": "@@ -64,28 +64,29 @@\n     abstract InflaterInputStream newInflaterInputStream(InputStream in) throws IOException;\n \n     @Override\n-    public final Buffer encode(final Buffer src, final int length,\n-                               final BufferAllocator allocator) {\n+    public final Buffer encode(final Buffer src, final int length, final BufferAllocator allocator) {\n         final Buffer dst = allocator.newBuffer(chunkSize);\n         DeflaterOutputStream output = null;\n         try {\n             output = newDeflaterOutputStream(Buffer.asOutputStream(dst));\n \n             if (src.hasArray()) {\n                 output.write(src.array(), src.arrayOffset() + src.readerIndex(), length);\n+                src.readerIndex(src.readerIndex() + length);", "originalCommit": "ad3c67e938f58c328a04244978ccba8ca26730f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAwNzY5Mg==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r533007692", "bodyText": "Here and in all other places: consider using logger API to build a String instead of concatenating manually:\nLOGGER.error(\"Error while decoding with {}\", name(), e);", "author": "idelpivnitskiy", "createdAt": "2020-12-01T01:12:26Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/AbstractZipContentCodec.java", "diffHunk": "@@ -246,6 +262,7 @@ public void onNext(@Nullable final Buffer src) {\n                     // Not enough data to decompress, ask for more\n                     subscription.request(1);\n                 } catch (Exception e) {\n+                    LOGGER.error(\"Error while decoding with \" + name(), e);", "originalCommit": "ad3c67e938f58c328a04244978ccba8ca26730f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAyMDQ2MQ==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r533020461", "bodyText": "Let's defer adding these details in javadoc?", "author": "idelpivnitskiy", "createdAt": "2020-12-01T01:51:51Z", "path": "servicetalk-encoding-api/src/main/java/io/servicetalk/encoding/api/ContentCodec.java", "diffHunk": "@@ -67,6 +72,7 @@ default Buffer decode(Buffer src, BufferAllocator allocator) {\n \n     /**\n      * Take a {@link Buffer} and decode its contents resulting in a {@link Buffer} with the decoded content.\n+     * This call increases the {@code readerIndex} of the {@code src} with the number of bytes read {@code length}.", "originalCommit": "ad3c67e938f58c328a04244978ccba8ca26730f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTcyNDA5OQ==", "url": "https://github.com/apple/servicetalk/pull/1198#discussion_r535724099", "bodyText": "Since we concluded on moving indexes, I kept these changes too.\nI think this is now consistent with other Buffer APIs.", "author": "tkountis", "createdAt": "2020-12-03T23:33:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAyMDQ2MQ=="}], "type": "inlineReview"}, {"oid": "94081bed3877f26bc0915349285fd08d5da16189", "url": "https://github.com/apple/servicetalk/commit/94081bed3877f26bc0915349285fd08d5da16189", "message": "Comments", "committedDate": "2020-12-03T23:29:24Z", "type": "commit"}]}