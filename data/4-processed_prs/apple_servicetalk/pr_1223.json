{"pr_number": 1223, "pr_title": "DNS Client SRV robustness and A* record Publisher support", "pr_createdAt": "2020-11-19T01:28:20Z", "pr_url": "https://github.com/apple/servicetalk/pull/1223", "timeline": [{"oid": "15e300ab16c09c1569169a2c3ecc78d30a5efa9b", "url": "https://github.com/apple/servicetalk/commit/15e300ab16c09c1569169a2c3ecc78d30a5efa9b", "message": "DNS Client SRV robustness and A* record Publisher support\n\nMotivation:\nSRV resolution involves a two phase lookup. First a SRV query, which\nreturns a set of name/port pairs, and then for each pair a A* record\nresolution. If an A* record resolution fails it currently fails the\nouter SRV Publisher. We also do a one-time-lookup at the A* record level\nso we can't detect multiple A* records nor can we detect any changes at\nthe A* record level. When a failure at the SRV level occurs we don't\ncleanup the A* publisher query processing, which may accumulate queued\nitems over subsequent retry attempts.\n\nModifications:\n- DefaultDnsClient SRV resolution should use flatMapMerge to process\nmultiple A* resolution streams in parallel, track changes, and deal with\ndynamic failures.\n- DefaultDnsClient SRV resolution should not let A* resolution failures\npropagate to the SRV level, and instead should be retried as long as\nthere is a corresponding SRV entry.\n- DefaultDnsClient SRV resolution should force innactive events upon\nfailure so that A* record publishers cleanup associated queues/timers.\n- DefaultDnsClient SRV resolution should support a mode that allows\ndeduplication of <host, ip> pairs returned by different A* record\npublishers.\n- DefaultDnsClient SRV resolution should disable Netty's CNAME cache\nbecause it may result in incorrect failures if CNAME TTLs are longer\nthan the SRV entries TTLs they map to.\n- DefaultDnsClientTest and TestRecordStore have been reimplemented to\nallow for direct control in the unit test, rather than implicit\nremoval/addition in the background.\n\nResult:\nMore robust DNS SRV record resolution that can also continiously follow\neach corresponding A* record stream.", "committedDate": "2020-11-19T03:07:24Z", "type": "forcePushed"}, {"oid": "9e31f2e4eb838aa9fa8fed393fff9ff056eae4ee", "url": "https://github.com/apple/servicetalk/commit/9e31f2e4eb838aa9fa8fed393fff9ff056eae4ee", "message": "DNS Client SRV robustness and A* record Publisher support\n\nMotivation:\nSRV resolution involves a two phase lookup. First a SRV query, which\nreturns a set of name/port pairs, and then for each pair a A* record\nresolution. If an A* record resolution fails it currently fails the\nouter SRV Publisher. We also do a one-time-lookup at the A* record level\nso we can't detect multiple A* records nor can we detect any changes at\nthe A* record level. When a failure at the SRV level occurs we don't\ncleanup the A* publisher query processing, which may accumulate queued\nitems over subsequent retry attempts.\n\nModifications:\n- DefaultDnsClient SRV resolution should use flatMapMerge to process\nmultiple A* resolution streams in parallel, track changes, and deal with\ndynamic failures.\n- DefaultDnsClient SRV resolution should not let A* resolution failures\npropagate to the SRV level, and instead should be retried as long as\nthere is a corresponding SRV entry.\n- DefaultDnsClient SRV resolution should force innactive events upon\nfailure so that A* record publishers cleanup associated queues/timers.\n- DefaultDnsClient SRV resolution should support a mode that allows\ndeduplication of <host, ip> pairs returned by different A* record\npublishers.\n- DefaultDnsClient SRV resolution should disable Netty's CNAME cache\nbecause it may result in incorrect failures if CNAME TTLs are longer\nthan the SRV entries TTLs they map to.\n- DefaultDnsClientTest and TestRecordStore have been reimplemented to\nallow for direct control in the unit test, rather than implicit\nremoval/addition in the background.\n\nResult:\nMore robust DNS SRV record resolution that can also continiously follow\neach corresponding A* record stream.", "committedDate": "2020-11-20T01:48:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE2NzUxNQ==", "url": "https://github.com/apple/servicetalk/pull/1223#discussion_r531167515", "bodyText": "nit: \"response payload\" irrelevant here.", "author": "tkountis", "createdAt": "2020-11-26T17:43:42Z", "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/CancelImmediatelySubscriber.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.internal;\n+\n+import io.servicetalk.concurrent.PublisherSource;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class CancelImmediatelySubscriber implements PublisherSource.Subscriber<Object> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CancelImmediatelySubscriber.class);\n+    public static final CancelImmediatelySubscriber INSTANCE = new CancelImmediatelySubscriber();\n+\n+    private CancelImmediatelySubscriber() {\n+        // Singleton\n+    }\n+\n+    @Override\n+    public void onSubscribe(final PublisherSource.Subscription s) {\n+        // Cancel immediately so that the connection can handle this as required.\n+        s.cancel();\n+    }\n+\n+    @Override\n+    public void onNext(final Object obj) {\n+        // Can not be here since we never request.\n+    }\n+\n+    @Override\n+    public void onError(final Throwable t) {\n+        LOGGER.debug(\"Ignoring error from response payload, since subscriber has already cancelled.\", t);", "originalCommit": "9e31f2e4eb838aa9fa8fed393fff9ff056eae4ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI5ODIyOQ==", "url": "https://github.com/apple/servicetalk/pull/1223#discussion_r527298229", "bodyText": "Missed javadoc", "author": "idelpivnitskiy", "createdAt": "2020-11-20T00:24:56Z", "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/CancelImmediatelySubscriber.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.internal;\n+\n+import io.servicetalk.concurrent.PublisherSource;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class CancelImmediatelySubscriber implements PublisherSource.Subscriber<Object> {", "originalCommit": "14ebf5a25e56f93f18735dac9a3f9ef24a8bb198", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1MDMxMg==", "url": "https://github.com/apple/servicetalk/pull/1223#discussion_r536350312", "bodyText": "SrvAddressRemovedException, ClosedServiceDiscovererException, and SrvAggregateList should have serialVersionUID", "author": "idelpivnitskiy", "createdAt": "2020-12-04T20:06:22Z", "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsClient.java", "diffHunk": "@@ -806,4 +912,12 @@ public int size() {\n             super(message);\n         }\n     }\n+\n+    private static final class SrvAddressRemovedException extends RuntimeException {", "originalCommit": "9e31f2e4eb838aa9fa8fed393fff9ff056eae4ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY2NTY4Nw==", "url": "https://github.com/apple/servicetalk/pull/1223#discussion_r537665687", "bodyText": "done", "author": "Scottmitch", "createdAt": "2020-12-07T16:56:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1MDMxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1MjAzMA==", "url": "https://github.com/apple/servicetalk/pull/1223#discussion_r536352030", "bodyText": "Consider adding a message", "author": "idelpivnitskiy", "createdAt": "2020-12-04T20:09:44Z", "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsClient.java", "diffHunk": "@@ -776,6 +805,83 @@ private static ResolvedAddressTypes toNettyType(final DnsResolverAddressTypes dn\n         return hostname -> new ServiceTalkToNettyDnsServerAddressStream(provider.nameServerAddressStream(hostname));\n     }\n \n+    private static final class SrvInactiveCombinerOperator implements\n+                            PublisherOperator<Collection<ServiceDiscovererEvent<InetSocketAddress>>,\n+                                              Collection<ServiceDiscovererEvent<InetSocketAddress>>> {\n+        static final SrvInactiveCombinerOperator EMIT = new SrvInactiveCombinerOperator(true);\n+        static final SrvInactiveCombinerOperator NO_EMIT = new SrvInactiveCombinerOperator(false);\n+        private final boolean emitAggregatedEvents;\n+\n+        private SrvInactiveCombinerOperator(boolean emitAggregatedEvents) {\n+            this.emitAggregatedEvents = emitAggregatedEvents;\n+        }\n+\n+        @Override\n+        public Subscriber<? super Collection<ServiceDiscovererEvent<InetSocketAddress>>> apply(\n+                final Subscriber<? super Collection<ServiceDiscovererEvent<InetSocketAddress>>> subscriber) {\n+            return new Subscriber<Collection<ServiceDiscovererEvent<InetSocketAddress>>>() {\n+                @Nullable\n+                private List<ServiceDiscovererEvent<InetSocketAddress>> aggregatedEvents;\n+                @Nullable\n+                private Subscription subscription;\n+                @Override\n+                public void onSubscribe(final Subscription s) {\n+                    this.subscription = s;\n+                    subscriber.onSubscribe(s);\n+                }\n+\n+                @Override\n+                public void onNext(@Nullable final Collection<ServiceDiscovererEvent<InetSocketAddress>> evts) {\n+                    assert subscription != null;\n+                    if (aggregatedEvents != null) {\n+                        if (evts != null && emitAggregatedEvents) {\n+                            aggregatedEvents.addAll(evts);\n+                        }\n+                        subscription.request(1);\n+                    } else if (evts instanceof SrvAggregateList) {\n+                        aggregatedEvents = (List<ServiceDiscovererEvent<InetSocketAddress>>) evts;\n+                        subscription.request(1);\n+                    } else {\n+                        subscriber.onNext(evts);\n+                    }\n+                }\n+\n+                @Override\n+                public void onError(final Throwable t) {\n+                    try {\n+                        if (aggregatedEvents != null && emitAggregatedEvents) {\n+                            // requestN is OK. We previously didn't deliver the item which gave us inactiveEvents.\n+                            subscriber.onNext(aggregatedEvents);\n+                        }\n+                    } finally {\n+                        subscriber.onError(t);\n+                    }\n+                }\n+\n+                @Override\n+                public void onComplete() {\n+                    subscriber.onComplete();\n+                }\n+            };\n+        }\n+    }\n+\n+    private static final class SrvInactiveEvent<T, A> implements ServiceDiscovererEvent<T> {\n+        private final List<ServiceDiscovererEvent<A>> aggregatedEvents = new SrvAggregateList<>();\n+        @Override\n+        public T address() {\n+            throw new UnsupportedOperationException();", "originalCommit": "9e31f2e4eb838aa9fa8fed393fff9ff056eae4ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY2ODYzMg==", "url": "https://github.com/apple/servicetalk/pull/1223#discussion_r537668632", "bodyText": "done", "author": "Scottmitch", "createdAt": "2020-12-07T16:59:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1MjAzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1NDA4NA==", "url": "https://github.com/apple/servicetalk/pull/1223#discussion_r536354084", "bodyText": "Should we try-catch all invocations of Subscriber methods?", "author": "idelpivnitskiy", "createdAt": "2020-12-04T20:13:48Z", "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsClient.java", "diffHunk": "@@ -776,6 +805,83 @@ private static ResolvedAddressTypes toNettyType(final DnsResolverAddressTypes dn\n         return hostname -> new ServiceTalkToNettyDnsServerAddressStream(provider.nameServerAddressStream(hostname));\n     }\n \n+    private static final class SrvInactiveCombinerOperator implements\n+                            PublisherOperator<Collection<ServiceDiscovererEvent<InetSocketAddress>>,\n+                                              Collection<ServiceDiscovererEvent<InetSocketAddress>>> {\n+        static final SrvInactiveCombinerOperator EMIT = new SrvInactiveCombinerOperator(true);\n+        static final SrvInactiveCombinerOperator NO_EMIT = new SrvInactiveCombinerOperator(false);\n+        private final boolean emitAggregatedEvents;\n+\n+        private SrvInactiveCombinerOperator(boolean emitAggregatedEvents) {\n+            this.emitAggregatedEvents = emitAggregatedEvents;\n+        }\n+\n+        @Override\n+        public Subscriber<? super Collection<ServiceDiscovererEvent<InetSocketAddress>>> apply(\n+                final Subscriber<? super Collection<ServiceDiscovererEvent<InetSocketAddress>>> subscriber) {\n+            return new Subscriber<Collection<ServiceDiscovererEvent<InetSocketAddress>>>() {\n+                @Nullable\n+                private List<ServiceDiscovererEvent<InetSocketAddress>> aggregatedEvents;\n+                @Nullable\n+                private Subscription subscription;\n+                @Override\n+                public void onSubscribe(final Subscription s) {\n+                    this.subscription = s;\n+                    subscriber.onSubscribe(s);", "originalCommit": "9e31f2e4eb838aa9fa8fed393fff9ff056eae4ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc1ODgwNQ==", "url": "https://github.com/apple/servicetalk/pull/1223#discussion_r537758805", "bodyText": "no this isn't necessary/desirable, it is the responsibility of the upstream source to catch exceptions and propagate an onError. propagating the exception is necessary so upstream operator and the source can cleanup appropriately.", "author": "Scottmitch", "createdAt": "2020-12-07T19:10:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1NDA4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1NTMxMw==", "url": "https://github.com/apple/servicetalk/pull/1223#discussion_r536355313", "bodyText": "Is this expected path?", "author": "idelpivnitskiy", "createdAt": "2020-12-04T20:16:20Z", "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsClient.java", "diffHunk": "@@ -776,6 +805,83 @@ private static ResolvedAddressTypes toNettyType(final DnsResolverAddressTypes dn\n         return hostname -> new ServiceTalkToNettyDnsServerAddressStream(provider.nameServerAddressStream(hostname));\n     }\n \n+    private static final class SrvInactiveCombinerOperator implements\n+                            PublisherOperator<Collection<ServiceDiscovererEvent<InetSocketAddress>>,\n+                                              Collection<ServiceDiscovererEvent<InetSocketAddress>>> {\n+        static final SrvInactiveCombinerOperator EMIT = new SrvInactiveCombinerOperator(true);\n+        static final SrvInactiveCombinerOperator NO_EMIT = new SrvInactiveCombinerOperator(false);\n+        private final boolean emitAggregatedEvents;\n+\n+        private SrvInactiveCombinerOperator(boolean emitAggregatedEvents) {\n+            this.emitAggregatedEvents = emitAggregatedEvents;\n+        }\n+\n+        @Override\n+        public Subscriber<? super Collection<ServiceDiscovererEvent<InetSocketAddress>>> apply(\n+                final Subscriber<? super Collection<ServiceDiscovererEvent<InetSocketAddress>>> subscriber) {\n+            return new Subscriber<Collection<ServiceDiscovererEvent<InetSocketAddress>>>() {\n+                @Nullable\n+                private List<ServiceDiscovererEvent<InetSocketAddress>> aggregatedEvents;\n+                @Nullable\n+                private Subscription subscription;\n+                @Override\n+                public void onSubscribe(final Subscription s) {\n+                    this.subscription = s;\n+                    subscriber.onSubscribe(s);\n+                }\n+\n+                @Override\n+                public void onNext(@Nullable final Collection<ServiceDiscovererEvent<InetSocketAddress>> evts) {\n+                    assert subscription != null;\n+                    if (aggregatedEvents != null) {\n+                        if (evts != null && emitAggregatedEvents) {\n+                            aggregatedEvents.addAll(evts);\n+                        }\n+                        subscription.request(1);\n+                    } else if (evts instanceof SrvAggregateList) {\n+                        aggregatedEvents = (List<ServiceDiscovererEvent<InetSocketAddress>>) evts;\n+                        subscription.request(1);\n+                    } else {\n+                        subscriber.onNext(evts);", "originalCommit": "9e31f2e4eb838aa9fa8fed393fff9ff056eae4ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2MDQzNA==", "url": "https://github.com/apple/servicetalk/pull/1223#discussion_r537760434", "bodyText": "yes, I'll add a comment. if there hasn't been an SrvAggregateList event, we should just pass through.", "author": "Scottmitch", "createdAt": "2020-12-07T19:13:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1NTMxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM2MjE2NQ==", "url": "https://github.com/apple/servicetalk/pull/1223#discussion_r536362165", "bodyText": "srvEvent.address().toString() will include port number, but prevAPublisher.name won't. Consider making the msg consistent", "author": "idelpivnitskiy", "createdAt": "2020-12-04T20:30:03Z", "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsClient.java", "diffHunk": "@@ -174,57 +206,63 @@ private DnsDiscoveryObserver newDiscoveryObserver(final String address) {\n     @Override\n     public Publisher<Collection<ServiceDiscovererEvent<InetAddress>>> dnsQuery(final String address) {\n         requireNonNull(address);\n-        return defer(() -> new ARecordPublisher(true, address, newDiscoveryObserver(address)));\n+        return defer(() -> {\n+            ARecordPublisher pub = new ARecordPublisher(address, newDiscoveryObserver(address));\n+            return inactiveEventsOnError ? recoverWithInactiveEvents(pub, false) : pub;\n+        });\n     }\n \n     @Override\n     public Publisher<Collection<ServiceDiscovererEvent<InetSocketAddress>>> dnsSrvQuery(final String serviceName) {\n         requireNonNull(serviceName);\n         return defer(() -> {\n-            // State per subscribe requires defer so each subscribe gets independent state.\n-            final Map<HostAndPort, ARecordPublisher> aRecordMap = new HashMap<>(8);\n-            final DnsDiscoveryObserver discoveryObserver = newDiscoveryObserver(serviceName);\n-            return new SrvRecordPublisher(serviceName, discoveryObserver).flatMapConcatIterable(identity())\n-                    .flatMapMergeSingle(srvEvent -> {\n+        // State per subscribe requires defer so each subscribe gets independent state.\n+        final Map<HostAndPort, ARecordPublisher> aRecordMap = new HashMap<>(8);\n+        final Map<InetSocketAddress, Integer> availableAddresses = srvFilterDuplicateEvents ?\n+                new HashMap<>(8) : emptyMap();\n+        final DnsDiscoveryObserver discoveryObserver = newDiscoveryObserver(serviceName);\n+        // We \"recover\" unconditionally to force inactive events to propagate to all mapped A* publishers to cancel\n+        // any pending scheduled tasks. SrvInactiveCombinerOperator is used to filter the aggregated collection of\n+        // inactive events if necessary.\n+        return recoverWithInactiveEvents(new SrvRecordPublisher(serviceName, discoveryObserver), true)\n+                .flatMapConcatIterable(identity())\n+                .flatMapMerge(srvEvent -> {\n                 assertInEventloop();\n                 if (srvEvent.isAvailable()) {\n-                    final ARecordPublisher aPublisher =\n-                            new ARecordPublisher(false, srvEvent.address().hostName(), discoveryObserver);\n-                    final ARecordPublisher prevAPublisher = aRecordMap.putIfAbsent(srvEvent.address(), aPublisher);\n-                    if (prevAPublisher != null) {\n-                        return failed(new IllegalStateException(\"Only 1 A* record per SRV record is supported. \" +\n-                                srvEvent.address() + \" corresponding to SRV name \" + serviceName +\n-                                \" had a pre-existing A* record:\" + prevAPublisher.name +\n-                                \" when new A* record arrived: \" + aPublisher.name));\n-                    }\n+                    return defer(() -> {\n+                        final ARecordPublisher aPublisher =\n+                                new ARecordPublisher(srvEvent.address().hostName(), discoveryObserver);\n+                        final ARecordPublisher prevAPublisher = aRecordMap.putIfAbsent(srvEvent.address(), aPublisher);\n+                        if (prevAPublisher != null) {\n+                            return newDuplicateSrv(serviceName, srvEvent.address().toString(), prevAPublisher.name);", "originalCommit": "9e31f2e4eb838aa9fa8fed393fff9ff056eae4ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM2NzI0NA==", "url": "https://github.com/apple/servicetalk/pull/1223#discussion_r536367244", "bodyText": "For the purpose of A/AAAA record resolution the port number doesn't matter. Can we use only a hostname as a key?", "author": "idelpivnitskiy", "createdAt": "2020-12-04T20:40:58Z", "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsClient.java", "diffHunk": "@@ -174,57 +206,63 @@ private DnsDiscoveryObserver newDiscoveryObserver(final String address) {\n     @Override\n     public Publisher<Collection<ServiceDiscovererEvent<InetAddress>>> dnsQuery(final String address) {\n         requireNonNull(address);\n-        return defer(() -> new ARecordPublisher(true, address, newDiscoveryObserver(address)));\n+        return defer(() -> {\n+            ARecordPublisher pub = new ARecordPublisher(address, newDiscoveryObserver(address));\n+            return inactiveEventsOnError ? recoverWithInactiveEvents(pub, false) : pub;\n+        });\n     }\n \n     @Override\n     public Publisher<Collection<ServiceDiscovererEvent<InetSocketAddress>>> dnsSrvQuery(final String serviceName) {\n         requireNonNull(serviceName);\n         return defer(() -> {\n-            // State per subscribe requires defer so each subscribe gets independent state.\n-            final Map<HostAndPort, ARecordPublisher> aRecordMap = new HashMap<>(8);\n-            final DnsDiscoveryObserver discoveryObserver = newDiscoveryObserver(serviceName);\n-            return new SrvRecordPublisher(serviceName, discoveryObserver).flatMapConcatIterable(identity())\n-                    .flatMapMergeSingle(srvEvent -> {\n+        // State per subscribe requires defer so each subscribe gets independent state.\n+        final Map<HostAndPort, ARecordPublisher> aRecordMap = new HashMap<>(8);", "originalCommit": "9e31f2e4eb838aa9fa8fed393fff9ff056eae4ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQwNzYyNA==", "url": "https://github.com/apple/servicetalk/pull/1223#discussion_r536407624", "bodyText": "For A/AAAA records we do not retry inside DNS SD, we apply DNS retries at the client level, as part of AutoRetryStrategy. Can we be consistent here?", "author": "idelpivnitskiy", "createdAt": "2020-12-04T21:57:51Z", "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsClient.java", "diffHunk": "@@ -174,57 +206,63 @@ private DnsDiscoveryObserver newDiscoveryObserver(final String address) {\n     @Override\n     public Publisher<Collection<ServiceDiscovererEvent<InetAddress>>> dnsQuery(final String address) {\n         requireNonNull(address);\n-        return defer(() -> new ARecordPublisher(true, address, newDiscoveryObserver(address)));\n+        return defer(() -> {\n+            ARecordPublisher pub = new ARecordPublisher(address, newDiscoveryObserver(address));\n+            return inactiveEventsOnError ? recoverWithInactiveEvents(pub, false) : pub;\n+        });\n     }\n \n     @Override\n     public Publisher<Collection<ServiceDiscovererEvent<InetSocketAddress>>> dnsSrvQuery(final String serviceName) {\n         requireNonNull(serviceName);\n         return defer(() -> {\n-            // State per subscribe requires defer so each subscribe gets independent state.\n-            final Map<HostAndPort, ARecordPublisher> aRecordMap = new HashMap<>(8);\n-            final DnsDiscoveryObserver discoveryObserver = newDiscoveryObserver(serviceName);\n-            return new SrvRecordPublisher(serviceName, discoveryObserver).flatMapConcatIterable(identity())\n-                    .flatMapMergeSingle(srvEvent -> {\n+        // State per subscribe requires defer so each subscribe gets independent state.\n+        final Map<HostAndPort, ARecordPublisher> aRecordMap = new HashMap<>(8);\n+        final Map<InetSocketAddress, Integer> availableAddresses = srvFilterDuplicateEvents ?\n+                new HashMap<>(8) : emptyMap();\n+        final DnsDiscoveryObserver discoveryObserver = newDiscoveryObserver(serviceName);\n+        // We \"recover\" unconditionally to force inactive events to propagate to all mapped A* publishers to cancel\n+        // any pending scheduled tasks. SrvInactiveCombinerOperator is used to filter the aggregated collection of\n+        // inactive events if necessary.\n+        return recoverWithInactiveEvents(new SrvRecordPublisher(serviceName, discoveryObserver), true)\n+                .flatMapConcatIterable(identity())\n+                .flatMapMerge(srvEvent -> {\n                 assertInEventloop();\n                 if (srvEvent.isAvailable()) {\n-                    final ARecordPublisher aPublisher =\n-                            new ARecordPublisher(false, srvEvent.address().hostName(), discoveryObserver);\n-                    final ARecordPublisher prevAPublisher = aRecordMap.putIfAbsent(srvEvent.address(), aPublisher);\n-                    if (prevAPublisher != null) {\n-                        return failed(new IllegalStateException(\"Only 1 A* record per SRV record is supported. \" +\n-                                srvEvent.address() + \" corresponding to SRV name \" + serviceName +\n-                                \" had a pre-existing A* record:\" + prevAPublisher.name +\n-                                \" when new A* record arrived: \" + aPublisher.name));\n-                    }\n+                    return defer(() -> {\n+                        final ARecordPublisher aPublisher =\n+                                new ARecordPublisher(srvEvent.address().hostName(), discoveryObserver);\n+                        final ARecordPublisher prevAPublisher = aRecordMap.putIfAbsent(srvEvent.address(), aPublisher);\n+                        if (prevAPublisher != null) {\n+                            return newDuplicateSrv(serviceName, srvEvent.address().toString(), prevAPublisher.name);\n+                        }\n \n-                    return srvARecordPubToSingle(aPublisher, srvEvent, serviceName);\n+                        Publisher<? extends Collection<ServiceDiscovererEvent<InetAddress>>> returnPub =\n+                                recoverWithInactiveEvents(aPublisher, false);\n+                        return srvFilterDuplicateEvents ?\n+                                srvFilterDups(returnPub, availableAddresses, srvEvent.address().port()) :\n+                                returnPub.map(events -> mapEventList(events, inetAddress ->\n+                                        new InetSocketAddress(inetAddress, srvEvent.address().port())));\n+                    }).retryWhen((i, cause) -> {\n+                        assertInEventloop();\n+                        // If this error is because the SRV entry was detected as inactive, then propagate the error and\n+                        // don't retry. Otherwise this is a resolution exception (e.g. UnknownHostException), and retry.\n+                        return cause == SrvAddressRemovedException.DNS_SRV_ADDR_REMOVED ||\n+                                aRecordMap.remove(srvEvent.address()) == null ?\n+                                Completable.failed(cause) : srvHostNameRepeater.apply(i);", "originalCommit": "9e31f2e4eb838aa9fa8fed393fff9ff056eae4ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4ODAwMQ==", "url": "https://github.com/apple/servicetalk/pull/1223#discussion_r537788001", "bodyText": "There are two levels of lookups. This code propagates failures at the first level (e.g. the DNS server returns nxdomain for the SRV query, netty times it out, etc.). However this code retries on the A record Publishers. if a failure on a single A record publisher is propagated this may lead to not processing complete results, and kill the entire SRV lookup (impacting other A records that are resolving fine) for scenario that maybe temporary (e.g. spurious errors due to DNS reconfiguration and distributed caches, A record TTL is lower than SRV record TTL and gets invalidated first, etc.). Consider the below example, if the error is processed first we wouldn't process subsequent results that maybe successful.\n// SRV records\nSRV (hostname1.com, 9999)\nSRV (hostname2.com, 9999)\nSRV (hostname3.com, 9999)\n\n// DNS records\n<nxdomain/timeout for hostname2>\nA (hostname3.com, 1.2.3.4)\nA (hostname1.com, 1.2.3.5)", "author": "Scottmitch", "createdAt": "2020-12-07T19:53:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQwNzYyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ0MjE1OQ==", "url": "https://github.com/apple/servicetalk/pull/1223#discussion_r536442159", "bodyText": "Consider making it private", "author": "idelpivnitskiy", "createdAt": "2020-12-04T23:25:01Z", "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/SingletonDnsServerAddressStreamProvider.java", "diffHunk": "@@ -25,14 +27,52 @@\n \n     /**\n      * Create a new instance.\n-     * @param stream The singelton to return from {@link #nameServerAddressStream(String)}.\n+     * @param address The address to return from {@link #nameServerAddressStream(String)}.\n      */\n-    public SingletonDnsServerAddressStreamProvider(DnsServerAddressStream stream) {\n-        this.stream = requireNonNull(stream);\n+    public SingletonDnsServerAddressStreamProvider(InetSocketAddress address) {\n+        this.stream = new SingletonDnsServerAddresses(address);\n     }\n \n     @Override\n     public DnsServerAddressStream nameServerAddressStream(String hostname) {\n         return stream;\n     }\n+\n+    /**\n+     * A {@link DnsServerAddressStream} which always returns the same {@link InetSocketAddress}.\n+     */\n+    public static final class SingletonDnsServerAddresses implements DnsServerAddressStream {", "originalCommit": "9e31f2e4eb838aa9fa8fed393fff9ff056eae4ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ0MjgyNQ==", "url": "https://github.com/apple/servicetalk/pull/1223#discussion_r536442825", "bodyText": "We should not override the copyright year", "author": "idelpivnitskiy", "createdAt": "2020-12-04T23:27:03Z", "path": "servicetalk-dns-discovery-netty/src/test/java/io/servicetalk/dns/discovery/netty/DefaultDnsClientTest.java", "diffHunk": "@@ -1,5 +1,5 @@\n /*\n- * Copyright \u00a9 2018 Apple Inc. and the ServiceTalk project authors\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors", "originalCommit": "9e31f2e4eb838aa9fa8fed393fff9ff056eae4ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4ODc2Mw==", "url": "https://github.com/apple/servicetalk/pull/1223#discussion_r537788763", "bodyText": "good catch, file was modified under a different name and moved later.", "author": "Scottmitch", "createdAt": "2020-12-07T19:54:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ0MjgyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ0MzQxMA==", "url": "https://github.com/apple/servicetalk/pull/1223#discussion_r536443410", "bodyText": "We should not override the copyright year", "author": "idelpivnitskiy", "createdAt": "2020-12-04T23:29:05Z", "path": "servicetalk-dns-discovery-netty/src/test/java/io/servicetalk/dns/discovery/netty/TestRecordStore.java", "diffHunk": "@@ -1,5 +1,5 @@\n /*\n- * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors", "originalCommit": "9e31f2e4eb838aa9fa8fed393fff9ff056eae4ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ce50f2ae8cd6d73bdca7a21d6a07a9eb22213485", "url": "https://github.com/apple/servicetalk/commit/ce50f2ae8cd6d73bdca7a21d6a07a9eb22213485", "message": "rebase and update test utilities", "committedDate": "2020-12-07T20:27:32Z", "type": "forcePushed"}, {"oid": "c03217d0eb3ffabeb4c0e71af797ae11d180b3c3", "url": "https://github.com/apple/servicetalk/commit/c03217d0eb3ffabeb4c0e71af797ae11d180b3c3", "message": "DNS Client SRV robustness and A* record Publisher support\n\nMotivation:\nSRV resolution involves a two phase lookup. First a SRV query, which\nreturns a set of name/port pairs, and then for each pair a A* record\nresolution. If an A* record resolution fails it currently fails the\nouter SRV Publisher. We also do a one-time-lookup at the A* record level\nso we can't detect multiple A* records nor can we detect any changes at\nthe A* record level. When a failure at the SRV level occurs we don't\ncleanup the A* publisher query processing, which may accumulate queued\nitems over subsequent retry attempts.\n\nModifications:\n- DefaultDnsClient SRV resolution should use flatMapMerge to process\nmultiple A* resolution streams in parallel, track changes, and deal with\ndynamic failures.\n- DefaultDnsClient SRV resolution should not let A* resolution failures\npropagate to the SRV level, and instead should be retried as long as\nthere is a corresponding SRV entry.\n- DefaultDnsClient SRV resolution should force innactive events upon\nfailure so that A* record publishers cleanup associated queues/timers.\n- DefaultDnsClient SRV resolution should support a mode that allows\ndeduplication of <host, ip> pairs returned by different A* record\npublishers.\n- DefaultDnsClient SRV resolution should disable Netty's CNAME cache\nbecause it may result in incorrect failures if CNAME TTLs are longer\nthan the SRV entries TTLs they map to.\n- DefaultDnsClientTest and TestRecordStore have been reimplemented to\nallow for direct control in the unit test, rather than implicit\nremoval/addition in the background.\n\nResult:\nMore robust DNS SRV record resolution that can also continiously follow\neach corresponding A* record stream.", "committedDate": "2020-12-07T23:20:57Z", "type": "commit"}, {"oid": "f3c065e9e26779108c8d4f23a832a8eb782c0832", "url": "https://github.com/apple/servicetalk/commit/f3c065e9e26779108c8d4f23a832a8eb782c0832", "message": "review comments", "committedDate": "2020-12-07T23:20:57Z", "type": "commit"}, {"oid": "ed62bd9e0d1d71e728f712e31f1d12dc89bd05a2", "url": "https://github.com/apple/servicetalk/commit/ed62bd9e0d1d71e728f712e31f1d12dc89bd05a2", "message": "rebase to main", "committedDate": "2020-12-07T23:22:46Z", "type": "commit"}, {"oid": "ed62bd9e0d1d71e728f712e31f1d12dc89bd05a2", "url": "https://github.com/apple/servicetalk/commit/ed62bd9e0d1d71e728f712e31f1d12dc89bd05a2", "message": "rebase to main", "committedDate": "2020-12-07T23:22:46Z", "type": "forcePushed"}]}