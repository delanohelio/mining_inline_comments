{"pr_number": 1283, "pr_title": "CompletableProcessor and SingleProcessor race condition fix", "pr_createdAt": "2020-12-17T01:44:06Z", "pr_url": "https://github.com/apple/servicetalk/pull/1283", "timeline": [{"oid": "220d434e0181a9ac9e386e84506098bc9b205c83", "url": "https://github.com/apple/servicetalk/commit/220d434e0181a9ac9e386e84506098bc9b205c83", "message": "CompletableProcessor and SingleProcessor race condition fix\n\nMotivation:\nCompletableProcessor and SingleProcessor maintain a queue and an\nindependent state for termination. It is possible that a Subscriber\nmaybe added on different thread than is terminating the Processor, and\nthe terminal state may not be visible yet such that the Subscriber never\ngets terminated.\n\nModifications:\n- The thread adding the the queue should attempt to read/modify state in\ncoordination with the thread terminating to gaurentee the new Subscriber\nwill be terminated.\n- Allow for out of order termination in the event that the processor\ncompletes before the subscribe operation happens.\n\nResult:\nFixes https://github.com/apple/servicetalk/issues/1033", "committedDate": "2020-12-17T01:42:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc0OTg1Nw==", "url": "https://github.com/apple/servicetalk/pull/1283#discussion_r544749857", "bodyText": "Note that this.terminalSignal is no longer atomic and the visibility is provided by the queueUpdater atomic operations. The Subscriber API doesn't allow for concurrent access so this shouldn't violate the API but the value maybe overridden if no external synchronization is provided.", "author": "Scottmitch", "createdAt": "2020-12-17T01:46:29Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/CompletableProcessor.java", "diffHunk": "@@ -84,25 +87,32 @@ public void onError(Throwable t) {\n         terminate(TerminalNotification.error(t));\n     }\n \n-    private void terminate(TerminalNotification terminalSignal) {\n-        if (terminalSignalUpdater.compareAndSet(this, null, terminalSignal)) {\n-            notifyListeners(terminalSignal);\n-        }\n+    private void terminateLateSubscriber(Subscriber subscriber) {\n+        TerminalNotification terminalSignal = this.terminalSignal;\n+        assert terminalSignal != null;\n+        terminalSignal.terminate(subscriber);\n     }\n \n-    private void notifyListeners(TerminalNotification terminalSignal) {\n-        Throwable delayedCause = null;\n-        Subscriber subscriber;\n-        while ((subscriber = subscribers.poll()) != null) {\n-            try {\n-                terminalSignal.terminate(subscriber);\n-            } catch (Throwable cause) {\n-                delayedCause = catchUnexpected(delayedCause, cause);\n+    private void terminate(TerminalNotification terminalSignal) {\n+        if (this.terminalSignal == null) {", "originalCommit": "220d434e0181a9ac9e386e84506098bc9b205c83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE1ODIzNQ==", "url": "https://github.com/apple/servicetalk/pull/1283#discussion_r546158235", "bodyText": "Consider clarifying this in the comment in code", "author": "idelpivnitskiy", "createdAt": "2020-12-19T00:18:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc0OTg1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE2MDkyNA==", "url": "https://github.com/apple/servicetalk/pull/1283#discussion_r546160924", "bodyText": "Actually, it makes me feel a bit uncomfortable that late subscribers may terminate differently. WDYT if instead of a CLOSED node inside ConcurrentStack we will intoduce a subtype TerminalNode which will keep terminalSignal? ConcurrentStack will have 2 generic types: ConcurrentStack<Subscriber, TerminalNotification>. Then instead of top == CLOSED check we can use top instanceOf TerminalNode.", "author": "idelpivnitskiy", "createdAt": "2020-12-19T00:31:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc0OTg1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE4NTU1MA==", "url": "https://github.com/apple/servicetalk/pull/1283#discussion_r546185550", "bodyText": "yes I can do this. the extra memory barriers adds overhead in multithreaded cases, however it still is an improvement over what we had originally with the concurrent queue.\n# non-atomic terminal\nCompletableProcessorBenchmark.mtAdd20Complete  thrpt    5    951658.114 \u00b1  15566.060  ops/s\n\n# atomic terminal (with volatile coordination between threads)\nCompletableProcessorBenchmark.mtAdd20Complete  thrpt    5    715757.301 \u00b1  22471.221  ops/s", "author": "Scottmitch", "createdAt": "2020-12-19T03:45:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc0OTg1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE4Njg2MA==", "url": "https://github.com/apple/servicetalk/pull/1283#discussion_r546186860", "bodyText": "addressed in #1298", "author": "Scottmitch", "createdAt": "2020-12-19T03:59:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc0OTg1Nw=="}], "type": "inlineReview"}, {"oid": "8eb173f2c3f2ae43339088c624f80d869b38ca9f", "url": "https://github.com/apple/servicetalk/commit/8eb173f2c3f2ae43339088c624f80d869b38ca9f", "message": "use long and GAS and IAG for less perf impact on single threaded complete-after-subscribe use cases", "committedDate": "2020-12-17T03:23:59Z", "type": "commit"}, {"oid": "e235249ac28b338ff801a537626e4be328702976", "url": "https://github.com/apple/servicetalk/commit/e235249ac28b338ff801a537626e4be328702976", "message": "add ConcurrentStack, use it in Completable/Single processor", "committedDate": "2020-12-18T09:50:19Z", "type": "commit"}, {"oid": "e235249ac28b338ff801a537626e4be328702976", "url": "https://github.com/apple/servicetalk/commit/e235249ac28b338ff801a537626e4be328702976", "message": "add ConcurrentStack, use it in Completable/Single processor", "committedDate": "2020-12-18T09:50:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE0MDUwMg==", "url": "https://github.com/apple/servicetalk/pull/1283#discussion_r546140502", "bodyText": "This is not safely published to other threads. (eg. volatile). Intended due to method contract?", "author": "tkountis", "createdAt": "2020-12-18T23:11:26Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/ConcurrentStack.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Consumer;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class ConcurrentStack<T> {\n+    private static final Node<?> CLOSED = new Node<>();\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<ConcurrentStack, Node> topUpdater =\n+            newUpdater(ConcurrentStack.class, Node.class, \"top\");\n+    @Nullable\n+    private volatile Node<T> top;\n+\n+    boolean push(T item) {\n+        final Node<T> newTop = new Node<>(item);\n+        Node<T> oldTop;\n+        do {\n+            oldTop = top;\n+            if (oldTop == CLOSED) {\n+                return false;\n+            }\n+            newTop.next = oldTop;\n+        } while (!topUpdater.compareAndSet(this, oldTop, newTop));\n+        return true;\n+    }\n+\n+    @Nullable\n+    T pop() {\n+        for (;;) {\n+            final Node<T> oldTop = top;\n+            if (oldTop == null) {\n+                return null;\n+            } else if (topUpdater.compareAndSet(this, oldTop, oldTop.next)) {\n+                final T item = oldTop.item;\n+                if (item != null) {\n+                    return item;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Best effort removal of {@code item} from this stack.\n+     * @param item The item to remove.\n+     * @return {@code true} if the item was found in this stack and marked for removal. The \"relaxed\" nature of\n+     * this method means {@code true} might be returned in the following scenarios without external synchronization:\n+     * <ul>\n+     *     <li>invoked multiple times with the same {@code item} from different threads</li>\n+     *     <li>{@link #pop()} removes this item from another thread</li>\n+     * </ul>\n+     */\n+    boolean relaxedRemove(T item) {\n+        requireNonNull(item);\n+        Node<T> currTop = top;\n+        while (currTop != null) {\n+            if (item.equals(currTop.item)) {\n+                currTop.item = null; // best effort null out the item. pop/close will discard the Node later.", "originalCommit": "e235249ac28b338ff801a537626e4be328702976", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE0NDk5MA==", "url": "https://github.com/apple/servicetalk/pull/1283#discussion_r546144990", "bodyText": "correct we don't need strong guarantees of removal, mostly just for GC. if we needed stronger guarantees we would have to make item volatile and use atomics here and in pop, but the relaxed semantics are OK and this makes the hot-path (e.g. pop) less expensive.", "author": "Scottmitch", "createdAt": "2020-12-18T23:29:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE0MDUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE0MjEwNQ==", "url": "https://github.com/apple/servicetalk/pull/1283#discussion_r546142105", "bodyText": "counter?", "author": "tkountis", "createdAt": "2020-12-18T23:17:50Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/SingleProcessor.java", "diffHunk": "@@ -88,38 +67,34 @@ public void onError(final Throwable t) {\n         terminate(TerminalNotification.error(t));\n     }\n \n-    private void terminate(@Nullable Object terminalSignal) {\n-        if (terminalSignalUpdater.compareAndSet(this, TERMINAL_NULL, terminalSignal)) {\n-            notifyListeners(terminalSignal);\n-        }\n-    }\n-\n-    private void notifyListeners(@Nullable Object terminalSignal) {\n-        Subscriber<? super T> subscriber;\n-        Throwable delayedCause = null;\n+    private void terminateLateSubscriber(Subscriber<? super T> subscriber) {\n+        Object terminalSignal = this.terminalSignal;\n+        assert terminalSignal != TERMINAL_UNSET;\n         if (terminalSignal instanceof TerminalNotification) {\n             final Throwable error = ((TerminalNotification) terminalSignal).cause();\n-            assert error != null : \"Cause can't be null from TerminalNotification.error(..)\";\n-            while ((subscriber = subscribers.poll()) != null) {\n-                try {\n-                    subscriber.onError(error);\n-                } catch (Throwable cause) {\n-                    delayedCause = catchUnexpected(delayedCause, cause);\n-                }\n-            }\n+            assert error != null;\n+            subscriber.onError(error);\n         } else {\n             @SuppressWarnings(\"unchecked\")\n             final T value = (T) terminalSignal;\n-            while ((subscriber = subscribers.poll()) != null) {\n-                try {\n-                    subscriber.onSuccess(value);\n-                } catch (Throwable cause) {\n-                    delayedCause = catchUnexpected(delayedCause, cause);\n-                }\n-            }\n+            subscriber.onSuccess(value);\n         }\n-        if (delayedCause != null) {\n-            throwException(delayedCause);\n+    }\n+\n+    private void terminate(@Nullable Object terminalSignal) {\n+        if (this.terminalSignal == TERMINAL_UNSET) {\n+            // We must set terminalSignal before counter as we depend upon happens-before relationship for this value", "originalCommit": "e235249ac28b338ff801a537626e4be328702976", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE0NTI0Mg==", "url": "https://github.com/apple/servicetalk/pull/1283#discussion_r546145242", "bodyText": "whoops, old comment let me update.", "author": "Scottmitch", "createdAt": "2020-12-18T23:30:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE0MjEwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE0Mzc2NQ==", "url": "https://github.com/apple/servicetalk/pull/1283#discussion_r546143765", "bodyText": "consider fast-exit when CLOSED", "author": "tkountis", "createdAt": "2020-12-18T23:24:35Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/ConcurrentStack.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Consumer;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class ConcurrentStack<T> {\n+    private static final Node<?> CLOSED = new Node<>();\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<ConcurrentStack, Node> topUpdater =\n+            newUpdater(ConcurrentStack.class, Node.class, \"top\");\n+    @Nullable\n+    private volatile Node<T> top;\n+\n+    boolean push(T item) {\n+        final Node<T> newTop = new Node<>(item);\n+        Node<T> oldTop;\n+        do {\n+            oldTop = top;\n+            if (oldTop == CLOSED) {\n+                return false;\n+            }\n+            newTop.next = oldTop;\n+        } while (!topUpdater.compareAndSet(this, oldTop, newTop));\n+        return true;\n+    }\n+\n+    @Nullable\n+    T pop() {\n+        for (;;) {\n+            final Node<T> oldTop = top;\n+            if (oldTop == null) {", "originalCommit": "e235249ac28b338ff801a537626e4be328702976", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "297c1c2b89ceadb673af24e8a2dcbafbc551de4b", "url": "https://github.com/apple/servicetalk/commit/297c1c2b89ceadb673af24e8a2dcbafbc551de4b", "message": "tkountis review comments", "committedDate": "2020-12-18T23:36:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE0NzMyNw==", "url": "https://github.com/apple/servicetalk/pull/1283#discussion_r546147327", "bodyText": "Should we clarify in the javadoc that this method may return items that were already removed and the usage of the returned item should be idempotent?", "author": "idelpivnitskiy", "createdAt": "2020-12-18T23:39:17Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/ConcurrentStack.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Consumer;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class ConcurrentStack<T> {\n+    private static final Node<?> CLOSED = new Node<>();\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<ConcurrentStack, Node> topUpdater =\n+            newUpdater(ConcurrentStack.class, Node.class, \"top\");\n+    @Nullable\n+    private volatile Node<T> top;\n+\n+    boolean push(T item) {\n+        final Node<T> newTop = new Node<>(item);\n+        Node<T> oldTop;\n+        do {\n+            oldTop = top;\n+            if (oldTop == CLOSED) {\n+                return false;\n+            }\n+            newTop.next = oldTop;\n+        } while (!topUpdater.compareAndSet(this, oldTop, newTop));\n+        return true;\n+    }\n+\n+    @Nullable\n+    T pop() {\n+        for (;;) {\n+            final Node<T> oldTop = top;\n+            if (oldTop == null) {\n+                return null;\n+            } else if (topUpdater.compareAndSet(this, oldTop, oldTop.next)) {\n+                final T item = oldTop.item;\n+                if (item != null) {\n+                    return item;", "originalCommit": "e235249ac28b338ff801a537626e4be328702976", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE2NjQ4Ng==", "url": "https://github.com/apple/servicetalk/pull/1283#discussion_r546166486", "bodyText": "I tired to clarify the \"relaxed\" constraints in the java docs for relaxedRemove. if you don't use relaxedRemove then there are no special cases to consider. any suggestions on how to improve?", "author": "Scottmitch", "createdAt": "2020-12-19T01:03:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE0NzMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE2OTQ1Mg==", "url": "https://github.com/apple/servicetalk/pull/1283#discussion_r546169452", "bodyText": "Should we name it relaxedPop() then and reference #relaxedRemove(T)?", "author": "idelpivnitskiy", "createdAt": "2020-12-19T01:20:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE0NzMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE4Njg4NA==", "url": "https://github.com/apple/servicetalk/pull/1283#discussion_r546186884", "bodyText": "addressed in #1298", "author": "Scottmitch", "createdAt": "2020-12-19T04:00:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE0NzMyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE1MjE1Mg==", "url": "https://github.com/apple/servicetalk/pull/1283#discussion_r546152152", "bodyText": "Not sure if we need, but we can add topUpdater.compareAndSet(this, currTop, currTop.next); before the return as the best effort in case the item was found in the top node. If the CAS returns false, we don't care.\nTo avoid annecessary CAS, we can add a local boolean flag to detect if we found the item in the top or not.", "author": "idelpivnitskiy", "createdAt": "2020-12-18T23:50:33Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/ConcurrentStack.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Consumer;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class ConcurrentStack<T> {\n+    private static final Node<?> CLOSED = new Node<>();\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<ConcurrentStack, Node> topUpdater =\n+            newUpdater(ConcurrentStack.class, Node.class, \"top\");\n+    @Nullable\n+    private volatile Node<T> top;\n+\n+    boolean push(T item) {\n+        final Node<T> newTop = new Node<>(item);\n+        Node<T> oldTop;\n+        do {\n+            oldTop = top;\n+            if (oldTop == CLOSED) {\n+                return false;\n+            }\n+            newTop.next = oldTop;\n+        } while (!topUpdater.compareAndSet(this, oldTop, newTop));\n+        return true;\n+    }\n+\n+    @Nullable\n+    T pop() {\n+        for (;;) {\n+            final Node<T> oldTop = top;\n+            if (oldTop == null) {\n+                return null;\n+            } else if (topUpdater.compareAndSet(this, oldTop, oldTop.next)) {\n+                final T item = oldTop.item;\n+                if (item != null) {\n+                    return item;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Best effort removal of {@code item} from this stack.\n+     * @param item The item to remove.\n+     * @return {@code true} if the item was found in this stack and marked for removal. The \"relaxed\" nature of\n+     * this method means {@code true} might be returned in the following scenarios without external synchronization:\n+     * <ul>\n+     *     <li>invoked multiple times with the same {@code item} from different threads</li>\n+     *     <li>{@link #pop()} removes this item from another thread</li>\n+     * </ul>\n+     */\n+    boolean relaxedRemove(T item) {\n+        requireNonNull(item);\n+        Node<T> currTop = top;\n+        while (currTop != null) {\n+            if (item.equals(currTop.item)) {\n+                currTop.item = null; // best effort null out the item. pop/close will discard the Node later.\n+                return true;", "originalCommit": "e235249ac28b338ff801a537626e4be328702976", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3ODM0OQ==", "url": "https://github.com/apple/servicetalk/pull/1283#discussion_r546178349", "bodyText": "similar comment to #1283 (comment) ... lets punt on trying to patch removals in this implementation.", "author": "Scottmitch", "createdAt": "2020-12-19T02:32:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE1MjE1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE1MzcxMQ==", "url": "https://github.com/apple/servicetalk/pull/1283#discussion_r546153711", "bodyText": "Not sure if it's worth additiona complexity, but we can try to clean up top nodes with null items every time we touch the top.", "author": "idelpivnitskiy", "createdAt": "2020-12-18T23:56:07Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/ConcurrentStack.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Consumer;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class ConcurrentStack<T> {\n+    private static final Node<?> CLOSED = new Node<>();\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<ConcurrentStack, Node> topUpdater =\n+            newUpdater(ConcurrentStack.class, Node.class, \"top\");\n+    @Nullable\n+    private volatile Node<T> top;\n+\n+    boolean push(T item) {\n+        final Node<T> newTop = new Node<>(item);\n+        Node<T> oldTop;\n+        do {\n+            oldTop = top;\n+            if (oldTop == CLOSED) {\n+                return false;\n+            }\n+            newTop.next = oldTop;", "originalCommit": "e235249ac28b338ff801a537626e4be328702976", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3ODA3NQ==", "url": "https://github.com/apple/servicetalk/pull/1283#discussion_r546178075", "bodyText": "I don't think it is worth the complexity as this will only help in specific scenarios and we are assuming small sets. I think if we run into issues with the \"relaxed\" reclamation policy we can provide an alternative implementation which is more strict.", "author": "Scottmitch", "createdAt": "2020-12-19T02:29:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE1MzcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3OTAxMg==", "url": "https://github.com/apple/servicetalk/pull/1283#discussion_r546179012", "bodyText": "sgtm!", "author": "idelpivnitskiy", "createdAt": "2020-12-19T02:38:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE1MzcxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE1Mzk0NA==", "url": "https://github.com/apple/servicetalk/pull/1283#discussion_r546153944", "bodyText": "Same for relaxedRemove, if currTop.item == null we can try to update the top.", "author": "idelpivnitskiy", "createdAt": "2020-12-18T23:57:05Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/ConcurrentStack.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Consumer;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class ConcurrentStack<T> {\n+    private static final Node<?> CLOSED = new Node<>();\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<ConcurrentStack, Node> topUpdater =\n+            newUpdater(ConcurrentStack.class, Node.class, \"top\");\n+    @Nullable\n+    private volatile Node<T> top;\n+\n+    boolean push(T item) {\n+        final Node<T> newTop = new Node<>(item);\n+        Node<T> oldTop;\n+        do {\n+            oldTop = top;\n+            if (oldTop == CLOSED) {\n+                return false;\n+            }\n+            newTop.next = oldTop;\n+        } while (!topUpdater.compareAndSet(this, oldTop, newTop));\n+        return true;\n+    }\n+\n+    @Nullable\n+    T pop() {\n+        for (;;) {\n+            final Node<T> oldTop = top;\n+            if (oldTop == null) {\n+                return null;\n+            } else if (topUpdater.compareAndSet(this, oldTop, oldTop.next)) {\n+                final T item = oldTop.item;\n+                if (item != null) {\n+                    return item;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Best effort removal of {@code item} from this stack.\n+     * @param item The item to remove.\n+     * @return {@code true} if the item was found in this stack and marked for removal. The \"relaxed\" nature of\n+     * this method means {@code true} might be returned in the following scenarios without external synchronization:\n+     * <ul>\n+     *     <li>invoked multiple times with the same {@code item} from different threads</li>\n+     *     <li>{@link #pop()} removes this item from another thread</li>\n+     * </ul>\n+     */\n+    boolean relaxedRemove(T item) {\n+        requireNonNull(item);\n+        Node<T> currTop = top;\n+        while (currTop != null) {\n+            if (item.equals(currTop.item)) {\n+                currTop.item = null; // best effort null out the item. pop/close will discard the Node later.\n+                return true;\n+            } else {", "originalCommit": "e235249ac28b338ff801a537626e4be328702976", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE1NTI4OQ==", "url": "https://github.com/apple/servicetalk/pull/1283#discussion_r546155289", "bodyText": "requireNonNull(closer)?", "author": "idelpivnitskiy", "createdAt": "2020-12-19T00:03:34Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/ConcurrentStack.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Consumer;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class ConcurrentStack<T> {\n+    private static final Node<?> CLOSED = new Node<>();\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<ConcurrentStack, Node> topUpdater =\n+            newUpdater(ConcurrentStack.class, Node.class, \"top\");\n+    @Nullable\n+    private volatile Node<T> top;\n+\n+    boolean push(T item) {\n+        final Node<T> newTop = new Node<>(item);\n+        Node<T> oldTop;\n+        do {\n+            oldTop = top;\n+            if (oldTop == CLOSED) {\n+                return false;\n+            }\n+            newTop.next = oldTop;\n+        } while (!topUpdater.compareAndSet(this, oldTop, newTop));\n+        return true;\n+    }\n+\n+    @Nullable\n+    T pop() {\n+        for (;;) {\n+            final Node<T> oldTop = top;\n+            if (oldTop == null) {\n+                return null;\n+            } else if (topUpdater.compareAndSet(this, oldTop, oldTop.next)) {\n+                final T item = oldTop.item;\n+                if (item != null) {\n+                    return item;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Best effort removal of {@code item} from this stack.\n+     * @param item The item to remove.\n+     * @return {@code true} if the item was found in this stack and marked for removal. The \"relaxed\" nature of\n+     * this method means {@code true} might be returned in the following scenarios without external synchronization:\n+     * <ul>\n+     *     <li>invoked multiple times with the same {@code item} from different threads</li>\n+     *     <li>{@link #pop()} removes this item from another thread</li>\n+     * </ul>\n+     */\n+    boolean relaxedRemove(T item) {\n+        requireNonNull(item);\n+        Node<T> currTop = top;\n+        while (currTop != null) {\n+            if (item.equals(currTop.item)) {\n+                currTop.item = null; // best effort null out the item. pop/close will discard the Node later.\n+                return true;\n+            } else {\n+                currTop = currTop.next;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    void close(Consumer<T> closer) {", "originalCommit": "e235249ac28b338ff801a537626e4be328702976", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE1NTUzMg==", "url": "https://github.com/apple/servicetalk/pull/1283#discussion_r546155532", "bodyText": "CLOSED can be only at the top. Consider removing this check from the loop and fast exit if oldTop == CLOSED.", "author": "idelpivnitskiy", "createdAt": "2020-12-19T00:04:50Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/ConcurrentStack.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Consumer;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class ConcurrentStack<T> {\n+    private static final Node<?> CLOSED = new Node<>();\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<ConcurrentStack, Node> topUpdater =\n+            newUpdater(ConcurrentStack.class, Node.class, \"top\");\n+    @Nullable\n+    private volatile Node<T> top;\n+\n+    boolean push(T item) {\n+        final Node<T> newTop = new Node<>(item);\n+        Node<T> oldTop;\n+        do {\n+            oldTop = top;\n+            if (oldTop == CLOSED) {\n+                return false;\n+            }\n+            newTop.next = oldTop;\n+        } while (!topUpdater.compareAndSet(this, oldTop, newTop));\n+        return true;\n+    }\n+\n+    @Nullable\n+    T pop() {\n+        for (;;) {\n+            final Node<T> oldTop = top;\n+            if (oldTop == null) {\n+                return null;\n+            } else if (topUpdater.compareAndSet(this, oldTop, oldTop.next)) {\n+                final T item = oldTop.item;\n+                if (item != null) {\n+                    return item;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Best effort removal of {@code item} from this stack.\n+     * @param item The item to remove.\n+     * @return {@code true} if the item was found in this stack and marked for removal. The \"relaxed\" nature of\n+     * this method means {@code true} might be returned in the following scenarios without external synchronization:\n+     * <ul>\n+     *     <li>invoked multiple times with the same {@code item} from different threads</li>\n+     *     <li>{@link #pop()} removes this item from another thread</li>\n+     * </ul>\n+     */\n+    boolean relaxedRemove(T item) {\n+        requireNonNull(item);\n+        Node<T> currTop = top;\n+        while (currTop != null) {\n+            if (item.equals(currTop.item)) {\n+                currTop.item = null; // best effort null out the item. pop/close will discard the Node later.\n+                return true;\n+            } else {\n+                currTop = currTop.next;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    void close(Consumer<T> closer) {\n+        @SuppressWarnings(\"unchecked\")\n+        Node<T> oldTop = topUpdater.getAndSet(this, closedNode());\n+        Throwable delayedCause = null;\n+        while (oldTop != null && oldTop != CLOSED) {", "originalCommit": "e235249ac28b338ff801a537626e4be328702976", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE1NTgxOQ==", "url": "https://github.com/apple/servicetalk/pull/1283#discussion_r546155819", "bodyText": "Doesn't look like next variable is useful. Can we remove it and just do oldTop = oldTop.next`?", "author": "idelpivnitskiy", "createdAt": "2020-12-19T00:06:00Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/ConcurrentStack.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Consumer;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class ConcurrentStack<T> {\n+    private static final Node<?> CLOSED = new Node<>();\n+    @SuppressWarnings(\"rawtypes\")\n+    private static final AtomicReferenceFieldUpdater<ConcurrentStack, Node> topUpdater =\n+            newUpdater(ConcurrentStack.class, Node.class, \"top\");\n+    @Nullable\n+    private volatile Node<T> top;\n+\n+    boolean push(T item) {\n+        final Node<T> newTop = new Node<>(item);\n+        Node<T> oldTop;\n+        do {\n+            oldTop = top;\n+            if (oldTop == CLOSED) {\n+                return false;\n+            }\n+            newTop.next = oldTop;\n+        } while (!topUpdater.compareAndSet(this, oldTop, newTop));\n+        return true;\n+    }\n+\n+    @Nullable\n+    T pop() {\n+        for (;;) {\n+            final Node<T> oldTop = top;\n+            if (oldTop == null) {\n+                return null;\n+            } else if (topUpdater.compareAndSet(this, oldTop, oldTop.next)) {\n+                final T item = oldTop.item;\n+                if (item != null) {\n+                    return item;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Best effort removal of {@code item} from this stack.\n+     * @param item The item to remove.\n+     * @return {@code true} if the item was found in this stack and marked for removal. The \"relaxed\" nature of\n+     * this method means {@code true} might be returned in the following scenarios without external synchronization:\n+     * <ul>\n+     *     <li>invoked multiple times with the same {@code item} from different threads</li>\n+     *     <li>{@link #pop()} removes this item from another thread</li>\n+     * </ul>\n+     */\n+    boolean relaxedRemove(T item) {\n+        requireNonNull(item);\n+        Node<T> currTop = top;\n+        while (currTop != null) {\n+            if (item.equals(currTop.item)) {\n+                currTop.item = null; // best effort null out the item. pop/close will discard the Node later.\n+                return true;\n+            } else {\n+                currTop = currTop.next;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    void close(Consumer<T> closer) {\n+        @SuppressWarnings(\"unchecked\")\n+        Node<T> oldTop = topUpdater.getAndSet(this, closedNode());\n+        Throwable delayedCause = null;\n+        while (oldTop != null && oldTop != CLOSED) {\n+            final Node<T> next = oldTop.next;\n+            final T item = oldTop.item;\n+            oldTop = next;", "originalCommit": "e235249ac28b338ff801a537626e4be328702976", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE2MzE4NA==", "url": "https://github.com/apple/servicetalk/pull/1283#discussion_r546163184", "bodyText": "Instead of going back and forth between types, consider using Consumer<Subscriber<...>> type for terminalSignal. Then you can use null instead of TERMINAL_UNSET and simply pass the consumer into the stack.close(...).", "author": "idelpivnitskiy", "createdAt": "2020-12-19T00:44:04Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/SingleProcessor.java", "diffHunk": "@@ -88,38 +67,34 @@ public void onError(final Throwable t) {\n         terminate(TerminalNotification.error(t));\n     }\n \n-    private void terminate(@Nullable Object terminalSignal) {\n-        if (terminalSignalUpdater.compareAndSet(this, TERMINAL_NULL, terminalSignal)) {\n-            notifyListeners(terminalSignal);\n-        }\n-    }\n-\n-    private void notifyListeners(@Nullable Object terminalSignal) {\n-        Subscriber<? super T> subscriber;\n-        Throwable delayedCause = null;\n+    private void terminateLateSubscriber(Subscriber<? super T> subscriber) {\n+        Object terminalSignal = this.terminalSignal;\n+        assert terminalSignal != TERMINAL_UNSET;\n         if (terminalSignal instanceof TerminalNotification) {\n             final Throwable error = ((TerminalNotification) terminalSignal).cause();\n-            assert error != null : \"Cause can't be null from TerminalNotification.error(..)\";\n-            while ((subscriber = subscribers.poll()) != null) {\n-                try {\n-                    subscriber.onError(error);\n-                } catch (Throwable cause) {\n-                    delayedCause = catchUnexpected(delayedCause, cause);\n-                }\n-            }\n+            assert error != null;\n+            subscriber.onError(error);\n         } else {\n             @SuppressWarnings(\"unchecked\")\n             final T value = (T) terminalSignal;\n-            while ((subscriber = subscribers.poll()) != null) {\n-                try {\n-                    subscriber.onSuccess(value);\n-                } catch (Throwable cause) {\n-                    delayedCause = catchUnexpected(delayedCause, cause);\n-                }\n-            }\n+            subscriber.onSuccess(value);\n         }\n-        if (delayedCause != null) {\n-            throwException(delayedCause);\n+    }\n+\n+    private void terminate(@Nullable Object terminalSignal) {\n+        if (this.terminalSignal == TERMINAL_UNSET) {\n+            // We must set terminalSignal before counter as we depend upon happens-before relationship for this value\n+            // to be visible for any future late subscribers.\n+            this.terminalSignal = terminalSignal;\n+            if (terminalSignal instanceof TerminalNotification) {\n+                final Throwable error = ((TerminalNotification) terminalSignal).cause();", "originalCommit": "e235249ac28b338ff801a537626e4be328702976", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3MDYzOQ==", "url": "https://github.com/apple/servicetalk/pull/1283#discussion_r546170639", "bodyText": "interesting suggestion. this makes the code cleaner but may add allocation on the success path.", "author": "Scottmitch", "createdAt": "2020-12-19T01:28:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE2MzE4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3MTYxMg==", "url": "https://github.com/apple/servicetalk/pull/1283#discussion_r546171612", "bodyText": "onSuccess invokes this method and creates a lambda anyway, what will cause additional allocation? Assuming terminal methods are invoked only one time", "author": "idelpivnitskiy", "createdAt": "2020-12-19T01:35:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE2MzE4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3ODI3Mw==", "url": "https://github.com/apple/servicetalk/pull/1283#discussion_r546178273", "bodyText": "good point, you are right let me make this change!", "author": "Scottmitch", "createdAt": "2020-12-19T02:31:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE2MzE4NA=="}], "type": "inlineReview"}]}