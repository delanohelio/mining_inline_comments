{"pr_number": 1115, "pr_title": "Retain addresses on service discovery failure", "pr_createdAt": "2020-08-02T07:07:55Z", "pr_url": "https://github.com/apple/servicetalk/pull/1115", "timeline": [{"oid": "253b274645a92923b2d8a2fe7aca54f220833b47", "url": "https://github.com/apple/servicetalk/commit/253b274645a92923b2d8a2fe7aca54f220833b47", "message": "Retain addresses on service discovery failure\n\n__Motivation__\n\nService discovery errors are retried by clients to avoid transient failures cause request errors. DNS service discoverer eagerly clears addresses for errors of type `UnknownHostException` but such errors can also be transient. This DNS discoverer behavior effectively defeats the retries done by the client as it results in request errors.\nWe should avoid service discovery implementations to react pessimistically to service discovery errors as service discovery results are just a hint and do not effectively represent the current state of the servers. Server availability may change asynchronously and may not accurately be reflected in service discovery result due to delays at multiple levels. Instead, we should assume that all service discovery errors are transient and retain the addresses till a subsequent success from service discovery.\n\n__Modification__\n\nIntroduced a new contract for `ServiceDiscoveryRetryStrategy` and added a default implementation that retains addresses between an SD error and success. Old addresses are retained till a configured percentage of new addresses are removed post retry. This is done because service discovery events are emitted one at a time and hence does not provide a natural boundary which indicates completion of a successful resolution. Users can tune this percentage; the default is 75%.\n\nRemoved DNS service discoverer behavior of clearing addresses on certain errors.\n\n__Result__\n\nClients better tolerate transient service discoverer errors irrespective of individual service discoverer implementation.", "committedDate": "2020-08-02T07:05:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY4NTk2NQ==", "url": "https://github.com/apple/servicetalk/pull/1115#discussion_r464685965", "bodyText": "It was pre-existing, but let's switch to beforeOnNext here to make sure we always clear the error-state earlier.", "author": "idelpivnitskiy", "createdAt": "2020-08-03T22:03:43Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/DefaultSingleAddressHttpClientBuilder.java", "diffHunk": "@@ -213,33 +209,37 @@ private DefaultSingleAddressHttpClientBuilder(@Nullable final U address,\n         final DefaultSingleAddressHttpClientBuilder<U, R> builder;\n         final HttpExecutionContext executionContext;\n         final StreamingHttpRequestResponseFactory reqRespFactory;\n+        final ServiceDiscoveryRetryStrategy<R, ? super ServiceDiscovererEvent<R>> serviceDiscovererRetryStrategy;\n         @Nullable\n         final U proxyAddress;\n \n-        HttpClientBuildContext(final DefaultSingleAddressHttpClientBuilder<U, R> builder,\n-                               final HttpExecutionContext executionContext,\n-                               final StreamingHttpRequestResponseFactory reqRespFactory,\n-                               @Nullable final U proxyAddress) {\n+        HttpClientBuildContext(\n+                final DefaultSingleAddressHttpClientBuilder<U, R> builder, final HttpExecutionContext executionContext,\n+                final StreamingHttpRequestResponseFactory reqRespFactory,\n+                @Nullable final ServiceDiscoveryRetryStrategy<R, ? super ServiceDiscovererEvent<R>> sdRetryStrategy,\n+                @Nullable final U proxyAddress) {\n             this.builder = builder;\n             this.executionContext = executionContext;\n             this.reqRespFactory = reqRespFactory;\n+            this.serviceDiscovererRetryStrategy = sdRetryStrategy == null ?\n+                    DefaultServiceDiscoveryRetryStrategy.Builder.<R>withDefaults(executionContext.executor(),\n+                            ofSeconds(60)).build() : sdRetryStrategy;\n             this.proxyAddress = proxyAddress;\n         }\n \n         Publisher<? extends ServiceDiscovererEvent<R>> discover() {\n             assert builder.address != null : \"Attempted to buildStreaming with an unknown address\";\n-            return builder.serviceDiscoverer.discover(\n-                    proxyAddress != null ? proxyAddress : builder.address);\n+            final Publisher<? extends ServiceDiscovererEvent<R>> sdEvents =\n+                    builder.serviceDiscoverer.discover(proxyAddress != null ? proxyAddress : builder.address);\n+            return serviceDiscovererRetryStrategy.apply(sdEvents);\n         }\n \n         Publisher<? extends ServiceDiscovererEvent<R>> discover(final SdStatusCompletable sdStatus) {\n             assert builder.address != null : \"Attempted to buildStreaming with an unknown address\";\n-            final BiIntFunction<Throwable, ? extends Completable> retryWhen = builder.serviceDiscovererRetryStrategy;\n-            return builder.serviceDiscoverer.discover(proxyAddress != null ? proxyAddress : builder.address)\n-                    .retryWhen((i, t) -> {\n-                        sdStatus.nextError(t);\n-                        return retryWhen.apply(i, t);\n-                    }).whenOnNext(__ -> sdStatus.resetError());\n+            final Publisher<? extends ServiceDiscovererEvent<R>> sdEvents =\n+                    builder.serviceDiscoverer.discover(proxyAddress != null ? proxyAddress : builder.address);\n+            return serviceDiscovererRetryStrategy.apply(sdEvents.beforeOnError(sdStatus::nextError))\n+                    .whenOnNext(__ -> sdStatus.resetError());", "originalCommit": "253b274645a92923b2d8a2fe7aca54f220833b47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwNzcwMA==", "url": "https://github.com/apple/servicetalk/pull/1115#discussion_r465207700", "bodyText": "whenOnNext is an alias for beforeOnNext, but being explicit is better.", "author": "NiteshKant", "createdAt": "2020-08-04T17:19:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY4NTk2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY5MDUwNw==", "url": "https://github.com/apple/servicetalk/pull/1115#discussion_r464690507", "bodyText": "Missed javadoc", "author": "idelpivnitskiy", "createdAt": "2020-08-03T22:15:40Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultServiceDiscoveryRetryStrategy.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscoverer;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.client.api.partition.PartitionAttributes;\n+import io.servicetalk.client.api.partition.PartitionedServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.BiIntFunction;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.function.UnaryOperator;\n+\n+import static io.servicetalk.concurrent.api.Publisher.defer;\n+import static io.servicetalk.concurrent.api.RetryStrategies.retryWithExponentialBackoffAndJitter;\n+import static java.lang.Math.ceil;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Default implementation for {@link ServiceDiscoveryRetryStrategy}.\n+ *\n+ * @param <ResolvedAddress> The type of address after resolution.\n+ * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+ */\n+public final class DefaultServiceDiscoveryRetryStrategy<ResolvedAddress,\n+        E extends ServiceDiscovererEvent<ResolvedAddress>>\n+        implements ServiceDiscoveryRetryStrategy<ResolvedAddress, E> {\n+    private final int retainTillReceivePercentage;\n+    private final UnaryOperator<E> flipAvailability;\n+    private final BiIntFunction<Throwable, ? extends Completable> retryStrategy;\n+\n+    private DefaultServiceDiscoveryRetryStrategy(final int retainTillReceivePercentage,\n+                                                 final UnaryOperator<E> flipAvailability,\n+                                                 final BiIntFunction<Throwable, ? extends Completable> retryStrategy) {\n+        this.retainTillReceivePercentage = retainTillReceivePercentage;\n+        this.flipAvailability = requireNonNull(flipAvailability);\n+        this.retryStrategy = requireNonNull(retryStrategy);\n+    }\n+\n+    @Override\n+    public Publisher<? extends E> apply(final Publisher<? extends E> sdEvents) {\n+        return defer(() -> {\n+            EventsCache<ResolvedAddress, E> eventsCache =\n+                    new EventsCache<>(retainTillReceivePercentage, flipAvailability);\n+            return sdEvents.flatMapConcatIterable(eventsCache::consume)\n+                    .beforeOnError(__ -> eventsCache.errorSeen())\n+                    .retryWhen(retryStrategy);\n+        });\n+    }\n+\n+    /**\n+     * A builder to build instances of {@link DefaultServiceDiscoveryRetryStrategy}.\n+     *\n+     * @param <ResolvedAddress> The type of address after resolution.\n+     * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+     */\n+    public static final class Builder<ResolvedAddress, E extends ServiceDiscovererEvent<ResolvedAddress>> {\n+        // There is no reason for the choice of 75%, it is arbitrary and can be configured by users.\n+        private int retainTillReceivePercentage = 75;\n+        private BiIntFunction<Throwable, ? extends Completable> retryStrategy;\n+        private final UnaryOperator<E> flipAvailability;\n+\n+        private Builder(final BiIntFunction<Throwable, ? extends Completable> retryStrategy,\n+                        final UnaryOperator<E> flipAvailability) {\n+            this.retryStrategy = retryStrategy;\n+            this.flipAvailability = requireNonNull(flipAvailability);\n+        }\n+\n+        /**\n+         * A {@link Publisher} returned from {@link ServiceDiscoverer#discover(Object)} may fail transiently leaving the\n+         * consumer of these events with an option of either disposing the addresses that were provided before the\n+         * error or retain them till a retry succeeds. This option enables retention of addresses after an error is\n+         * observed till the total number of received addresses after an error is {@code retainTillReceivePercentage}\n+         * percent of the addresses that were available before the error was received.\n+         *\n+         * @param retainTillReceivePercentage A percentage of addresses that were received before an error that should\n+         * be received after a success, after which unreceived addresses are removed by sending appropriate\n+         * {@link ServiceDiscovererEvent}s. When set to {@code 0}, addresses are not retained.\n+         * @return {@code this}.\n+         */\n+        public Builder<ResolvedAddress, E> retainAddressesTillSuccess(final int retainTillReceivePercentage) {\n+            if (retainTillReceivePercentage < 0) {\n+                throw new IllegalArgumentException(\"retainTillReceivePercentage: \" + retainTillReceivePercentage +\n+                        \" (expected >= 0)\");\n+            }\n+            this.retainTillReceivePercentage = retainTillReceivePercentage;\n+            return this;\n+        }\n+\n+        public Builder<ResolvedAddress, E> retryStrategy(", "originalCommit": "253b274645a92923b2d8a2fe7aca54f220833b47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY5MTA4Mg==", "url": "https://github.com/apple/servicetalk/pull/1115#discussion_r464691082", "bodyText": "using the passed {@link BiFunction}\n\nThis method doesn't take any arguments, should we say \"pre-configured\" instead of \"passed\" or reword in any other way?", "author": "idelpivnitskiy", "createdAt": "2020-08-03T22:17:23Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultServiceDiscoveryRetryStrategy.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscoverer;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.client.api.partition.PartitionAttributes;\n+import io.servicetalk.client.api.partition.PartitionedServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.BiIntFunction;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.function.UnaryOperator;\n+\n+import static io.servicetalk.concurrent.api.Publisher.defer;\n+import static io.servicetalk.concurrent.api.RetryStrategies.retryWithExponentialBackoffAndJitter;\n+import static java.lang.Math.ceil;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Default implementation for {@link ServiceDiscoveryRetryStrategy}.\n+ *\n+ * @param <ResolvedAddress> The type of address after resolution.\n+ * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+ */\n+public final class DefaultServiceDiscoveryRetryStrategy<ResolvedAddress,\n+        E extends ServiceDiscovererEvent<ResolvedAddress>>\n+        implements ServiceDiscoveryRetryStrategy<ResolvedAddress, E> {\n+    private final int retainTillReceivePercentage;\n+    private final UnaryOperator<E> flipAvailability;\n+    private final BiIntFunction<Throwable, ? extends Completable> retryStrategy;\n+\n+    private DefaultServiceDiscoveryRetryStrategy(final int retainTillReceivePercentage,\n+                                                 final UnaryOperator<E> flipAvailability,\n+                                                 final BiIntFunction<Throwable, ? extends Completable> retryStrategy) {\n+        this.retainTillReceivePercentage = retainTillReceivePercentage;\n+        this.flipAvailability = requireNonNull(flipAvailability);\n+        this.retryStrategy = requireNonNull(retryStrategy);\n+    }\n+\n+    @Override\n+    public Publisher<? extends E> apply(final Publisher<? extends E> sdEvents) {\n+        return defer(() -> {\n+            EventsCache<ResolvedAddress, E> eventsCache =\n+                    new EventsCache<>(retainTillReceivePercentage, flipAvailability);\n+            return sdEvents.flatMapConcatIterable(eventsCache::consume)\n+                    .beforeOnError(__ -> eventsCache.errorSeen())\n+                    .retryWhen(retryStrategy);\n+        });\n+    }\n+\n+    /**\n+     * A builder to build instances of {@link DefaultServiceDiscoveryRetryStrategy}.\n+     *\n+     * @param <ResolvedAddress> The type of address after resolution.\n+     * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+     */\n+    public static final class Builder<ResolvedAddress, E extends ServiceDiscovererEvent<ResolvedAddress>> {\n+        // There is no reason for the choice of 75%, it is arbitrary and can be configured by users.\n+        private int retainTillReceivePercentage = 75;\n+        private BiIntFunction<Throwable, ? extends Completable> retryStrategy;\n+        private final UnaryOperator<E> flipAvailability;\n+\n+        private Builder(final BiIntFunction<Throwable, ? extends Completable> retryStrategy,\n+                        final UnaryOperator<E> flipAvailability) {\n+            this.retryStrategy = retryStrategy;\n+            this.flipAvailability = requireNonNull(flipAvailability);\n+        }\n+\n+        /**\n+         * A {@link Publisher} returned from {@link ServiceDiscoverer#discover(Object)} may fail transiently leaving the\n+         * consumer of these events with an option of either disposing the addresses that were provided before the\n+         * error or retain them till a retry succeeds. This option enables retention of addresses after an error is\n+         * observed till the total number of received addresses after an error is {@code retainTillReceivePercentage}\n+         * percent of the addresses that were available before the error was received.\n+         *\n+         * @param retainTillReceivePercentage A percentage of addresses that were received before an error that should\n+         * be received after a success, after which unreceived addresses are removed by sending appropriate\n+         * {@link ServiceDiscovererEvent}s. When set to {@code 0}, addresses are not retained.\n+         * @return {@code this}.\n+         */\n+        public Builder<ResolvedAddress, E> retainAddressesTillSuccess(final int retainTillReceivePercentage) {\n+            if (retainTillReceivePercentage < 0) {\n+                throw new IllegalArgumentException(\"retainTillReceivePercentage: \" + retainTillReceivePercentage +\n+                        \" (expected >= 0)\");\n+            }\n+            this.retainTillReceivePercentage = retainTillReceivePercentage;\n+            return this;\n+        }\n+\n+        public Builder<ResolvedAddress, E> retryStrategy(\n+                final BiIntFunction<Throwable, ? extends Completable> retryStrategy) {\n+            this.retryStrategy = requireNonNull(retryStrategy);\n+            return this;\n+        }\n+\n+        /**\n+         * Creates a new {@link ServiceDiscoveryRetryStrategy} using the passed {@link BiFunction} which is applied", "originalCommit": "253b274645a92923b2d8a2fe7aca54f220833b47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2NTU5OQ==", "url": "https://github.com/apple/servicetalk/pull/1115#discussion_r465265599", "bodyText": "My bad; this was left over from a refactor.", "author": "NiteshKant", "createdAt": "2020-08-04T19:03:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY5MTA4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY5NTU3NA==", "url": "https://github.com/apple/servicetalk/pull/1115#discussion_r464695574", "bodyText": "Why - 1 is required here? 10 is still allowed value for retryWithExponentialBackoffAndJitter.", "author": "idelpivnitskiy", "createdAt": "2020-08-03T22:30:07Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultServiceDiscoveryRetryStrategy.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscoverer;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.client.api.partition.PartitionAttributes;\n+import io.servicetalk.client.api.partition.PartitionedServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.BiIntFunction;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.function.UnaryOperator;\n+\n+import static io.servicetalk.concurrent.api.Publisher.defer;\n+import static io.servicetalk.concurrent.api.RetryStrategies.retryWithExponentialBackoffAndJitter;\n+import static java.lang.Math.ceil;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Default implementation for {@link ServiceDiscoveryRetryStrategy}.\n+ *\n+ * @param <ResolvedAddress> The type of address after resolution.\n+ * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+ */\n+public final class DefaultServiceDiscoveryRetryStrategy<ResolvedAddress,\n+        E extends ServiceDiscovererEvent<ResolvedAddress>>\n+        implements ServiceDiscoveryRetryStrategy<ResolvedAddress, E> {\n+    private final int retainTillReceivePercentage;\n+    private final UnaryOperator<E> flipAvailability;\n+    private final BiIntFunction<Throwable, ? extends Completable> retryStrategy;\n+\n+    private DefaultServiceDiscoveryRetryStrategy(final int retainTillReceivePercentage,\n+                                                 final UnaryOperator<E> flipAvailability,\n+                                                 final BiIntFunction<Throwable, ? extends Completable> retryStrategy) {\n+        this.retainTillReceivePercentage = retainTillReceivePercentage;\n+        this.flipAvailability = requireNonNull(flipAvailability);\n+        this.retryStrategy = requireNonNull(retryStrategy);\n+    }\n+\n+    @Override\n+    public Publisher<? extends E> apply(final Publisher<? extends E> sdEvents) {\n+        return defer(() -> {\n+            EventsCache<ResolvedAddress, E> eventsCache =\n+                    new EventsCache<>(retainTillReceivePercentage, flipAvailability);\n+            return sdEvents.flatMapConcatIterable(eventsCache::consume)\n+                    .beforeOnError(__ -> eventsCache.errorSeen())\n+                    .retryWhen(retryStrategy);\n+        });\n+    }\n+\n+    /**\n+     * A builder to build instances of {@link DefaultServiceDiscoveryRetryStrategy}.\n+     *\n+     * @param <ResolvedAddress> The type of address after resolution.\n+     * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+     */\n+    public static final class Builder<ResolvedAddress, E extends ServiceDiscovererEvent<ResolvedAddress>> {\n+        // There is no reason for the choice of 75%, it is arbitrary and can be configured by users.\n+        private int retainTillReceivePercentage = 75;\n+        private BiIntFunction<Throwable, ? extends Completable> retryStrategy;\n+        private final UnaryOperator<E> flipAvailability;\n+\n+        private Builder(final BiIntFunction<Throwable, ? extends Completable> retryStrategy,\n+                        final UnaryOperator<E> flipAvailability) {\n+            this.retryStrategy = retryStrategy;\n+            this.flipAvailability = requireNonNull(flipAvailability);\n+        }\n+\n+        /**\n+         * A {@link Publisher} returned from {@link ServiceDiscoverer#discover(Object)} may fail transiently leaving the\n+         * consumer of these events with an option of either disposing the addresses that were provided before the\n+         * error or retain them till a retry succeeds. This option enables retention of addresses after an error is\n+         * observed till the total number of received addresses after an error is {@code retainTillReceivePercentage}\n+         * percent of the addresses that were available before the error was received.\n+         *\n+         * @param retainTillReceivePercentage A percentage of addresses that were received before an error that should\n+         * be received after a success, after which unreceived addresses are removed by sending appropriate\n+         * {@link ServiceDiscovererEvent}s. When set to {@code 0}, addresses are not retained.\n+         * @return {@code this}.\n+         */\n+        public Builder<ResolvedAddress, E> retainAddressesTillSuccess(final int retainTillReceivePercentage) {\n+            if (retainTillReceivePercentage < 0) {\n+                throw new IllegalArgumentException(\"retainTillReceivePercentage: \" + retainTillReceivePercentage +\n+                        \" (expected >= 0)\");\n+            }\n+            this.retainTillReceivePercentage = retainTillReceivePercentage;\n+            return this;\n+        }\n+\n+        public Builder<ResolvedAddress, E> retryStrategy(\n+                final BiIntFunction<Throwable, ? extends Completable> retryStrategy) {\n+            this.retryStrategy = requireNonNull(retryStrategy);\n+            return this;\n+        }\n+\n+        /**\n+         * Creates a new {@link ServiceDiscoveryRetryStrategy} using the passed {@link BiFunction} which is applied\n+         * as-is using {@link Publisher#retryWhen(BiIntFunction)} on the {@link Publisher} passed to\n+         * {@link DefaultServiceDiscoveryRetryStrategy#apply(Publisher)}.\n+         *\n+         * @return A new {@link ServiceDiscoveryRetryStrategy}.\n+         */\n+        public ServiceDiscoveryRetryStrategy<ResolvedAddress, E> build() {\n+            return new DefaultServiceDiscoveryRetryStrategy<>(retainTillReceivePercentage, flipAvailability,\n+                    retryStrategy);\n+        }\n+\n+        /**\n+         * Creates a new builder that uses default retries.\n+         *\n+         * @param executor {@link Executor} to use for retry backoffs.\n+         * @param initialDelay {@link Duration} to use as initial delay for backoffs.\n+         * @param <ResolvedAddress> The type of address after resolution.\n+         * @return A new {@link Builder}.\n+         */\n+        public static <ResolvedAddress> Builder<ResolvedAddress, ServiceDiscovererEvent<ResolvedAddress>>\n+        withDefaults(final Executor executor, final Duration initialDelay) {\n+            return new Builder<>(new IndefiniteRetryStrategy(executor, initialDelay),\n+                    evt -> new DefaultServiceDiscovererEvent<>(evt.address(), !evt.isAvailable()));\n+        }\n+\n+        /**\n+         * Creates a new builder that uses default retries.\n+         *\n+         * @param executor {@link Executor} to use for retry backoffs.\n+         * @param initialDelay {@link Duration} to use as initial delay for backoffs.\n+         * @param <ResolvedAddress> The type of address after resolution.\n+         * @return A new {@link Builder}.\n+         */\n+        public static <ResolvedAddress> Builder<ResolvedAddress, PartitionedServiceDiscovererEvent<ResolvedAddress>>\n+        withDefaultsForPartitions(final Executor executor, final Duration initialDelay) {\n+            return new Builder<>(new IndefiniteRetryStrategy(executor, initialDelay),\n+                    evt -> new PartitionedServiceDiscovererEvent<ResolvedAddress>() {\n+                        @Override\n+                        public PartitionAttributes partitionAddress() {\n+                            return evt.partitionAddress();\n+                        }\n+\n+                        @Override\n+                        public ResolvedAddress address() {\n+                            return evt.address();\n+                        }\n+\n+                        @Override\n+                        public boolean isAvailable() {\n+                            return !evt.isAvailable();\n+                        }\n+                    });\n+        }\n+\n+        /**\n+         * Creates a new builder that uses default retries.\n+         *\n+         * @param executor {@link Executor} to use for retry backoffs.\n+         * @param initialDelay {@link Duration} to use as initial delay for backoffs.\n+         * @param flipAvailability {@link UnaryOperator} that returns a new {@link ServiceDiscovererEvent} that is the\n+         * same as the passed {@link ServiceDiscovererEvent} but with {@link ServiceDiscovererEvent#isAvailable()} value\n+         * flipped.\n+         * @param <ResolvedAddress> The type of address after resolution.\n+         * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+         * @return A new {@link Builder}.\n+         */\n+        public static <ResolvedAddress, E extends ServiceDiscovererEvent<ResolvedAddress>> Builder<ResolvedAddress, E>\n+        withDefaults(final Executor executor, final Duration initialDelay, final UnaryOperator<E> flipAvailability) {\n+            return new Builder<>(new IndefiniteRetryStrategy(executor, initialDelay), flipAvailability);\n+        }\n+    }\n+\n+    private static final class EventsCache<R, E extends ServiceDiscovererEvent<R>> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final Map NONE_RETAINED = emptyMap();\n+\n+        private Map<R, E> retainedAddresses = noneRetained();\n+        private int targetSize;\n+        private final Map<R, E> activeAddresses = new HashMap<>();\n+        private final int retainTillReceivePercentage;\n+        private final UnaryOperator<E> flipAvailability;\n+\n+        EventsCache(final int retainTillReceivePercentage, final UnaryOperator<E> flipAvailability) {\n+            this.retainTillReceivePercentage = retainTillReceivePercentage;\n+            this.flipAvailability = flipAvailability;\n+        }\n+\n+        void errorSeen() {\n+            if (retainedAddresses == NONE_RETAINED) {\n+                retainedAddresses = new HashMap<>(activeAddresses);\n+            } else {\n+                retainedAddresses.putAll(activeAddresses);\n+            }\n+            targetSize = (int) (ceil(retainTillReceivePercentage / 100d) * activeAddresses.size());\n+            activeAddresses.clear();\n+        }\n+\n+        Iterable<E> consume(final E event) {\n+            final R address = event.address();\n+            if (retainedAddresses == NONE_RETAINED) {\n+                if (event.isAvailable()) {\n+                    activeAddresses.put(address, event);\n+                } else {\n+                    activeAddresses.remove(address);\n+                }\n+                return singletonList(event);\n+            }\n+\n+            // we have seen an error and have not fully drained the retained address list\n+            if (event.isAvailable()) {\n+                // new address after a retry\n+                activeAddresses.put(address, event);\n+                final boolean removed = retainedAddresses.remove(address) != null;\n+                if (activeAddresses.size() == targetSize) {\n+                    final List<E> allEvents = new ArrayList<>(retainedAddresses.size() + (removed ? 0 : 1));\n+                    if (!removed) {\n+                        allEvents.add(event);\n+                    }\n+                    for (E removalEvent : retainedAddresses.values()) {\n+                        allEvents.add(flipAvailability.apply(removalEvent));\n+                    }\n+                    retainedAddresses = noneRetained();\n+                    targetSize = 0;\n+                    return allEvents;\n+                }\n+                // If we already had it in retained addresses, then the event can be ignored as the consumer of events\n+                // already knows about the address\n+                return removed ? emptyList() : singletonList(event);\n+            }\n+            // removal must be for a previously added address which would have already removed from the retained\n+            // address list, so we do not need to touch the retainedAddresses\n+            activeAddresses.remove(address);\n+            return singletonList(event);\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private static <R, E extends ServiceDiscovererEvent<R>> Map<R, E> noneRetained() {\n+            return NONE_RETAINED;\n+        }\n+    }\n+\n+    private static final class IndefiniteRetryStrategy implements BiIntFunction<Throwable, Completable> {\n+        private static final int MAX_RETRIES = 10;\n+        private final BiIntFunction<Throwable, Completable> delegate;\n+\n+        IndefiniteRetryStrategy(final Executor executor, final Duration initialDelay) {\n+            delegate = retryWithExponentialBackoffAndJitter(MAX_RETRIES, __ -> true, initialDelay, executor);\n+        }\n+\n+        @Override\n+        public Completable apply(final int count, final Throwable cause) {\n+            // As we are retrying indefinitely (unless closed), cap the backoff on MAX_RETRIES retries to avoid\n+            // impractical backoffs\n+            return delegate.apply(count % (MAX_RETRIES - 1), cause);", "originalCommit": "253b274645a92923b2d8a2fe7aca54f220833b47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI4MzYyMg==", "url": "https://github.com/apple/servicetalk/pull/1115#discussion_r465283622", "bodyText": "hmm .. ya we can use MAX_RETRIES too but we should not let the count % MAX_RETRIES to be 0 as that will trip retryWithExponentialBackoffAndJitter. Let me fix that", "author": "NiteshKant", "createdAt": "2020-08-04T19:33:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY5NTU3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcwMDk2Nw==", "url": "https://github.com/apple/servicetalk/pull/1115#discussion_r464700967", "bodyText": "The executor should be closed after the test.", "author": "idelpivnitskiy", "createdAt": "2020-08-03T22:46:36Z", "path": "servicetalk-http-api/src/test/java/io/servicetalk/http/api/DefaultServiceDiscoveryRetryStrategyTest.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.TestExecutor;\n+import io.servicetalk.concurrent.api.TestPublisher;\n+import io.servicetalk.concurrent.api.TestPublisherSubscriber;\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.http.api.DefaultServiceDiscoveryRetryStrategy.Builder;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.util.List;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+import static io.servicetalk.concurrent.api.Publisher.defer;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.lang.Long.MAX_VALUE;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+\n+public class DefaultServiceDiscoveryRetryStrategyTest {\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+\n+    private final TestExecutor executor;\n+    private final LinkedBlockingQueue<TestPublisher<ServiceDiscovererEvent<String>>> pubs;\n+    private final TestPublisherSubscriber<ServiceDiscovererEvent<String>> subscriber;\n+\n+    public DefaultServiceDiscoveryRetryStrategyTest() {\n+        executor = new TestExecutor();", "originalCommit": "253b274645a92923b2d8a2fe7aca54f220833b47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcwNTU2Mg==", "url": "https://github.com/apple/servicetalk/pull/1115#discussion_r464705562", "bodyText": "Consider testing a use-case for retainAddressesTillSuccess(0).", "author": "idelpivnitskiy", "createdAt": "2020-08-03T23:01:14Z", "path": "servicetalk-http-api/src/test/java/io/servicetalk/http/api/DefaultServiceDiscoveryRetryStrategyTest.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.TestExecutor;\n+import io.servicetalk.concurrent.api.TestPublisher;\n+import io.servicetalk.concurrent.api.TestPublisherSubscriber;\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.http.api.DefaultServiceDiscoveryRetryStrategy.Builder;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.util.List;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+import static io.servicetalk.concurrent.api.Publisher.defer;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.lang.Long.MAX_VALUE;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+\n+public class DefaultServiceDiscoveryRetryStrategyTest {\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+\n+    private final TestExecutor executor;\n+    private final LinkedBlockingQueue<TestPublisher<ServiceDiscovererEvent<String>>> pubs;\n+    private final TestPublisherSubscriber<ServiceDiscovererEvent<String>> subscriber;\n+\n+    public DefaultServiceDiscoveryRetryStrategyTest() {\n+        executor = new TestExecutor();\n+        ServiceDiscoveryRetryStrategy<String, ServiceDiscovererEvent<String>> strategy =\n+                Builder.<String>withDefaults(executor, ofSeconds(1)).retainAddressesTillSuccess(75).build();", "originalCommit": "253b274645a92923b2d8a2fe7aca54f220833b47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI1OTcxMg==", "url": "https://github.com/apple/servicetalk/pull/1115#discussion_r465259712", "bodyText": "Good call; there was a bug \ud83d\ude04\nif (activeAddresses.size() == targetSize) should be if (activeAddresses.size() >= targetSize)", "author": "NiteshKant", "createdAt": "2020-08-04T18:52:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcwNTU2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcwNTk4OA==", "url": "https://github.com/apple/servicetalk/pull/1115#discussion_r464705988", "bodyText": "The comment above says \"should evict addr2\", but evt1 is also evicted. Can you please clarify why this is expected?", "author": "idelpivnitskiy", "createdAt": "2020-08-03T23:02:38Z", "path": "servicetalk-http-api/src/test/java/io/servicetalk/http/api/DefaultServiceDiscoveryRetryStrategyTest.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.TestExecutor;\n+import io.servicetalk.concurrent.api.TestPublisher;\n+import io.servicetalk.concurrent.api.TestPublisherSubscriber;\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.http.api.DefaultServiceDiscoveryRetryStrategy.Builder;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.util.List;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+import static io.servicetalk.concurrent.api.Publisher.defer;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.lang.Long.MAX_VALUE;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+\n+public class DefaultServiceDiscoveryRetryStrategyTest {\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+\n+    private final TestExecutor executor;\n+    private final LinkedBlockingQueue<TestPublisher<ServiceDiscovererEvent<String>>> pubs;\n+    private final TestPublisherSubscriber<ServiceDiscovererEvent<String>> subscriber;\n+\n+    public DefaultServiceDiscoveryRetryStrategyTest() {\n+        executor = new TestExecutor();\n+        ServiceDiscoveryRetryStrategy<String, ServiceDiscovererEvent<String>> strategy =\n+                Builder.<String>withDefaults(executor, ofSeconds(1)).retainAddressesTillSuccess(75).build();\n+        pubs = new LinkedBlockingQueue<>();\n+        subscriber = new TestPublisherSubscriber<>();\n+        toSource(strategy.apply(defer(() -> {\n+            final TestPublisher<ServiceDiscovererEvent<String>> pub = new TestPublisher<>();\n+            pubs.add(pub);\n+            return pub;\n+        }))).subscribe(subscriber);\n+        subscriber.request(MAX_VALUE);\n+    }\n+\n+    @Test\n+    public void errorWithNoAddresses() throws Exception {\n+        TestPublisher<ServiceDiscovererEvent<String>> sdEvents = pubs.take();\n+        sdEvents = triggerRetry(sdEvents);\n+        verifyNoEventsReceived();\n+        sendUpAndVerifyReceive(\"addr1\", sdEvents);\n+    }\n+\n+    @Test\n+    public void newAddressPostRetry() throws Exception {\n+        TestPublisher<ServiceDiscovererEvent<String>> sdEvents = pubs.take();\n+\n+        final DefaultServiceDiscovererEvent<String> evt1 = sendUpAndVerifyReceive(\"addr1\", sdEvents);\n+\n+        sdEvents = triggerRetry(sdEvents);\n+\n+        verifyNoEventsReceived();\n+        final DefaultServiceDiscovererEvent<String> evt2 = new DefaultServiceDiscovererEvent<>(\"addr2\", true);\n+        sdEvents.onNext(evt2);\n+\n+        assertThat(\"Unexpected event received\", subscriber.takeItems(),\n+                containsInAnyOrder(flipAvailable(evt1), evt2));\n+    }\n+\n+    @Test\n+    public void overlapAddressPostRetry() throws Exception {\n+        TestPublisher<ServiceDiscovererEvent<String>> sdEvents = pubs.take();\n+\n+        final DefaultServiceDiscovererEvent<String> evt1 = sendUpAndVerifyReceive(\"addr1\", sdEvents);\n+        final DefaultServiceDiscovererEvent<String> evt2 = sendUpAndVerifyReceive(\"addr2\", sdEvents);\n+\n+        sdEvents = triggerRetry(sdEvents);\n+\n+        verifyNoEventsReceived();\n+\n+        sdEvents.onNext(evt1); // previously existing, should not be emitted\n+        verifyNoEventsReceived();\n+\n+        final DefaultServiceDiscovererEvent<String> evt3 = new DefaultServiceDiscovererEvent<>(\"addr3\", true);\n+        sdEvents.onNext(evt3); // threshold breach, should evict addr2\n+\n+        assertThat(\"Unexpected event received\", subscriber.takeItems(),\n+                containsInAnyOrder(flipAvailable(evt2), evt3));\n+    }\n+\n+    @Test\n+    public void errorWhileRetaining() throws Exception {\n+        TestPublisher<ServiceDiscovererEvent<String>> sdEvents = pubs.take();\n+\n+        final DefaultServiceDiscovererEvent<String> evt1 = sendUpAndVerifyReceive(\"addr1\", sdEvents);\n+        final DefaultServiceDiscovererEvent<String> evt2 = sendUpAndVerifyReceive(\"addr2\", sdEvents);\n+\n+        sdEvents = triggerRetry(sdEvents);\n+\n+        verifyNoEventsReceived();\n+\n+        sdEvents.onNext(evt1); // previously existing, should not be emitted\n+        verifyNoEventsReceived();\n+\n+        sdEvents = triggerRetry(sdEvents); // error while retaining\n+\n+        final DefaultServiceDiscovererEvent<String> evt3 = new DefaultServiceDiscovererEvent<>(\"addr3\", true);\n+        sdEvents.onNext(evt3); // threshold breach, should evict addr2\n+\n+        assertThat(\"Unexpected event received\", subscriber.takeItems(),\n+                containsInAnyOrder(flipAvailable(evt1), flipAvailable(evt2), evt3));", "originalCommit": "253b274645a92923b2d8a2fe7aca54f220833b47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0911d866722ebeb2ad7fc03ea74e244f2b71d29f", "url": "https://github.com/apple/servicetalk/commit/0911d866722ebeb2ad7fc03ea74e244f2b71d29f", "message": "Review comments", "committedDate": "2020-08-04T23:02:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4Mzc2OA==", "url": "https://github.com/apple/servicetalk/pull/1115#discussion_r465383768", "bodyText": "With max approach it will return 1 two times. Not a big deal. But if you don't like it, alternative could be (count % MAX_RETRIES) + 1.\nAlso, IIRC, the power of 2 value will be a bit more optimal for %. How about 8 or 16 instead of 10? Or just a mask of 0x0F?", "author": "idelpivnitskiy", "createdAt": "2020-08-04T23:22:56Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultServiceDiscoveryRetryStrategy.java", "diffHunk": "@@ -261,18 +269,23 @@ void errorSeen() {\n     }\n \n     private static final class IndefiniteRetryStrategy implements BiIntFunction<Throwable, Completable> {\n-        private static final int MAX_RETRIES = 10;\n         private final BiIntFunction<Throwable, Completable> delegate;\n+        private final int maxRetries;\n \n         IndefiniteRetryStrategy(final Executor executor, final Duration initialDelay) {\n-            delegate = retryWithExponentialBackoffAndJitter(MAX_RETRIES, __ -> true, initialDelay, executor);\n+            this(executor, initialDelay, 10);\n+        }\n+\n+        IndefiniteRetryStrategy(final Executor executor, final Duration initialDelay, final int maxRetries) {\n+            delegate = retryWithExponentialBackoffAndJitter(maxRetries, __ -> true, initialDelay, executor);\n+            this.maxRetries = maxRetries;\n         }\n \n         @Override\n         public Completable apply(final int count, final Throwable cause) {\n             // As we are retrying indefinitely (unless closed), cap the backoff on MAX_RETRIES retries to avoid\n             // impractical backoffs\n-            return delegate.apply(count % (MAX_RETRIES - 1), cause);\n+            return delegate.apply(max(1, count % (maxRetries)), cause);", "originalCommit": "0911d866722ebeb2ad7fc03ea74e244f2b71d29f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0NTQ5Nw==", "url": "https://github.com/apple/servicetalk/pull/1115#discussion_r465445497", "bodyText": "Minor ask : Requires upper cap as well retainTillReceivePercentage should not be greater than 100", "author": "connect2gaurav", "createdAt": "2020-08-05T03:09:49Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultServiceDiscoveryRetryStrategy.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscoverer;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.client.api.partition.PartitionAttributes;\n+import io.servicetalk.client.api.partition.PartitionedServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.BiIntFunction;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.function.UnaryOperator;\n+\n+import static io.servicetalk.concurrent.api.Publisher.defer;\n+import static io.servicetalk.concurrent.api.RetryStrategies.retryWithExponentialBackoffAndJitter;\n+import static java.lang.Math.ceil;\n+import static java.lang.Math.max;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Default implementation for {@link ServiceDiscoveryRetryStrategy}.\n+ *\n+ * @param <ResolvedAddress> The type of address after resolution.\n+ * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+ */\n+public final class DefaultServiceDiscoveryRetryStrategy<ResolvedAddress,\n+        E extends ServiceDiscovererEvent<ResolvedAddress>>\n+        implements ServiceDiscoveryRetryStrategy<ResolvedAddress, E> {\n+    private final int retainTillReceivePercentage;\n+    private final UnaryOperator<E> flipAvailability;\n+    private final BiIntFunction<Throwable, ? extends Completable> retryStrategy;\n+\n+    private DefaultServiceDiscoveryRetryStrategy(final int retainTillReceivePercentage,\n+                                                 final UnaryOperator<E> flipAvailability,\n+                                                 final BiIntFunction<Throwable, ? extends Completable> retryStrategy) {\n+        this.retainTillReceivePercentage = retainTillReceivePercentage;\n+        this.flipAvailability = requireNonNull(flipAvailability);\n+        this.retryStrategy = requireNonNull(retryStrategy);\n+    }\n+\n+    @Override\n+    public Publisher<? extends E> apply(final Publisher<? extends E> sdEvents) {\n+        return defer(() -> {\n+            EventsCache<ResolvedAddress, E> eventsCache =\n+                    new EventsCache<>(retainTillReceivePercentage, flipAvailability);\n+            return sdEvents.flatMapConcatIterable(eventsCache::consume)\n+                    .beforeOnError(__ -> eventsCache.errorSeen())\n+                    .retryWhen(retryStrategy);\n+        });\n+    }\n+\n+    /**\n+     * A builder to build instances of {@link DefaultServiceDiscoveryRetryStrategy}.\n+     *\n+     * @param <ResolvedAddress> The type of address after resolution.\n+     * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+     */\n+    public static final class Builder<ResolvedAddress, E extends ServiceDiscovererEvent<ResolvedAddress>> {\n+        // There is no reason for the choice of 75%, it is arbitrary and can be configured by users.\n+        private int retainTillReceivePercentage = 75;\n+        private BiIntFunction<Throwable, ? extends Completable> retryStrategy;\n+        private final UnaryOperator<E> flipAvailability;\n+\n+        private Builder(final BiIntFunction<Throwable, ? extends Completable> retryStrategy,\n+                        final UnaryOperator<E> flipAvailability) {\n+            this.retryStrategy = retryStrategy;\n+            this.flipAvailability = requireNonNull(flipAvailability);\n+        }\n+\n+        /**\n+         * A {@link Publisher} returned from {@link ServiceDiscoverer#discover(Object)} may fail transiently leaving the\n+         * consumer of these events with an option of either disposing the addresses that were provided before the\n+         * error or retain them till a retry succeeds. This option enables retention of addresses after an error is\n+         * observed till the total number of received addresses after an error is {@code retainTillReceivePercentage}\n+         * percent of the addresses that were available before the error was received.\n+         *\n+         * @param retainTillReceivePercentage A percentage of addresses that were received before an error that should\n+         * be received after a success, after which unreceived addresses are removed by sending appropriate\n+         * {@link ServiceDiscovererEvent}s. When set to {@code 0}, addresses are not retained.\n+         * @return {@code this}.\n+         */\n+        public Builder<ResolvedAddress, E> retainAddressesTillSuccess(final int retainTillReceivePercentage) {\n+            if (retainTillReceivePercentage < 0) {", "originalCommit": "0911d866722ebeb2ad7fc03ea74e244f2b71d29f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkwMDQ2Nw==", "url": "https://github.com/apple/servicetalk/pull/1115#discussion_r465900467", "bodyText": "Not adding an upper cap is intentional here as it enables folks to retain older addresses for a longish time.", "author": "NiteshKant", "createdAt": "2020-08-05T17:50:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0NTQ5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0NjIyNg==", "url": "https://github.com/apple/servicetalk/pull/1115#discussion_r465446226", "bodyText": "System.out.println(\"Output for 0\t:\" +(int)Math.ceil(0/100d)); System.out.println(\"Output for 10\t:\" +(int)Math.ceil(10/100d)); System.out.println(\"Output for 75\t:\" +(int)Math.ceil(75/100d)); System.out.println(\"Output for 100\t:\" +(int)Math.ceil(100/100d));\nOutput for 0\t:0 Output for 10\t:1 Output for 75\t:1 Output for 100\t:1\nSeems like Percentage computation is bit off. Irrespective of percentage targetSize = 1 * activeAddresses.size()", "author": "connect2gaurav", "createdAt": "2020-08-05T03:12:29Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultServiceDiscoveryRetryStrategy.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscoverer;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.client.api.partition.PartitionAttributes;\n+import io.servicetalk.client.api.partition.PartitionedServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.BiIntFunction;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.function.UnaryOperator;\n+\n+import static io.servicetalk.concurrent.api.Publisher.defer;\n+import static io.servicetalk.concurrent.api.RetryStrategies.retryWithExponentialBackoffAndJitter;\n+import static java.lang.Math.ceil;\n+import static java.lang.Math.max;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Default implementation for {@link ServiceDiscoveryRetryStrategy}.\n+ *\n+ * @param <ResolvedAddress> The type of address after resolution.\n+ * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+ */\n+public final class DefaultServiceDiscoveryRetryStrategy<ResolvedAddress,\n+        E extends ServiceDiscovererEvent<ResolvedAddress>>\n+        implements ServiceDiscoveryRetryStrategy<ResolvedAddress, E> {\n+    private final int retainTillReceivePercentage;\n+    private final UnaryOperator<E> flipAvailability;\n+    private final BiIntFunction<Throwable, ? extends Completable> retryStrategy;\n+\n+    private DefaultServiceDiscoveryRetryStrategy(final int retainTillReceivePercentage,\n+                                                 final UnaryOperator<E> flipAvailability,\n+                                                 final BiIntFunction<Throwable, ? extends Completable> retryStrategy) {\n+        this.retainTillReceivePercentage = retainTillReceivePercentage;\n+        this.flipAvailability = requireNonNull(flipAvailability);\n+        this.retryStrategy = requireNonNull(retryStrategy);\n+    }\n+\n+    @Override\n+    public Publisher<? extends E> apply(final Publisher<? extends E> sdEvents) {\n+        return defer(() -> {\n+            EventsCache<ResolvedAddress, E> eventsCache =\n+                    new EventsCache<>(retainTillReceivePercentage, flipAvailability);\n+            return sdEvents.flatMapConcatIterable(eventsCache::consume)\n+                    .beforeOnError(__ -> eventsCache.errorSeen())\n+                    .retryWhen(retryStrategy);\n+        });\n+    }\n+\n+    /**\n+     * A builder to build instances of {@link DefaultServiceDiscoveryRetryStrategy}.\n+     *\n+     * @param <ResolvedAddress> The type of address after resolution.\n+     * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+     */\n+    public static final class Builder<ResolvedAddress, E extends ServiceDiscovererEvent<ResolvedAddress>> {\n+        // There is no reason for the choice of 75%, it is arbitrary and can be configured by users.\n+        private int retainTillReceivePercentage = 75;\n+        private BiIntFunction<Throwable, ? extends Completable> retryStrategy;\n+        private final UnaryOperator<E> flipAvailability;\n+\n+        private Builder(final BiIntFunction<Throwable, ? extends Completable> retryStrategy,\n+                        final UnaryOperator<E> flipAvailability) {\n+            this.retryStrategy = retryStrategy;\n+            this.flipAvailability = requireNonNull(flipAvailability);\n+        }\n+\n+        /**\n+         * A {@link Publisher} returned from {@link ServiceDiscoverer#discover(Object)} may fail transiently leaving the\n+         * consumer of these events with an option of either disposing the addresses that were provided before the\n+         * error or retain them till a retry succeeds. This option enables retention of addresses after an error is\n+         * observed till the total number of received addresses after an error is {@code retainTillReceivePercentage}\n+         * percent of the addresses that were available before the error was received.\n+         *\n+         * @param retainTillReceivePercentage A percentage of addresses that were received before an error that should\n+         * be received after a success, after which unreceived addresses are removed by sending appropriate\n+         * {@link ServiceDiscovererEvent}s. When set to {@code 0}, addresses are not retained.\n+         * @return {@code this}.\n+         */\n+        public Builder<ResolvedAddress, E> retainAddressesTillSuccess(final int retainTillReceivePercentage) {\n+            if (retainTillReceivePercentage < 0) {\n+                throw new IllegalArgumentException(\"retainTillReceivePercentage: \" + retainTillReceivePercentage +\n+                        \" (expected >= 0)\");\n+            }\n+            this.retainTillReceivePercentage = retainTillReceivePercentage;\n+            return this;\n+        }\n+\n+        /**\n+         * Specifies a {@link BiFunction} which is applied as-is using {@link Publisher#retryWhen(BiIntFunction)}\n+         * on the {@link Publisher} passed to {@link DefaultServiceDiscoveryRetryStrategy#apply(Publisher)}.\n+         *\n+         * @param retryStrategy A {@link BiFunction} which is applied as-is using\n+         * {@link Publisher#retryWhen(BiIntFunction)} on the {@link Publisher} passed to\n+         * {@link DefaultServiceDiscoveryRetryStrategy#apply(Publisher)}.\n+         * @return {@code this}.\n+         */\n+        public Builder<ResolvedAddress, E> retryStrategy(\n+                final BiIntFunction<Throwable, ? extends Completable> retryStrategy) {\n+            this.retryStrategy = requireNonNull(retryStrategy);\n+            return this;\n+        }\n+\n+        /**\n+         * Creates a new {@link ServiceDiscoveryRetryStrategy}.\n+         *\n+         * @return A new {@link ServiceDiscoveryRetryStrategy}.\n+         */\n+        public ServiceDiscoveryRetryStrategy<ResolvedAddress, E> build() {\n+            return new DefaultServiceDiscoveryRetryStrategy<>(retainTillReceivePercentage, flipAvailability,\n+                    retryStrategy);\n+        }\n+\n+        /**\n+         * Creates a new builder that uses default retries.\n+         *\n+         * @param executor {@link Executor} to use for retry backoffs.\n+         * @param initialDelay {@link Duration} to use as initial delay for backoffs.\n+         * @param <ResolvedAddress> The type of address after resolution.\n+         * @return A new {@link Builder}.\n+         */\n+        public static <ResolvedAddress> Builder<ResolvedAddress, ServiceDiscovererEvent<ResolvedAddress>>\n+        withDefaults(final Executor executor, final Duration initialDelay) {\n+            return new Builder<>(new IndefiniteRetryStrategy(executor, initialDelay),\n+                    evt -> new DefaultServiceDiscovererEvent<>(evt.address(), !evt.isAvailable()));\n+        }\n+\n+        /**\n+         * Creates a new builder that uses default retries.\n+         *\n+         * @param executor {@link Executor} to use for retry backoffs.\n+         * @param initialDelay {@link Duration} to use as initial delay for backoffs.\n+         * @param <ResolvedAddress> The type of address after resolution.\n+         * @return A new {@link Builder}.\n+         */\n+        public static <ResolvedAddress> Builder<ResolvedAddress, PartitionedServiceDiscovererEvent<ResolvedAddress>>\n+        withDefaultsForPartitions(final Executor executor, final Duration initialDelay) {\n+            return new Builder<>(new IndefiniteRetryStrategy(executor, initialDelay),\n+                    evt -> new PartitionedServiceDiscovererEvent<ResolvedAddress>() {\n+                        @Override\n+                        public PartitionAttributes partitionAddress() {\n+                            return evt.partitionAddress();\n+                        }\n+\n+                        @Override\n+                        public ResolvedAddress address() {\n+                            return evt.address();\n+                        }\n+\n+                        @Override\n+                        public boolean isAvailable() {\n+                            return !evt.isAvailable();\n+                        }\n+                    });\n+        }\n+\n+        /**\n+         * Creates a new builder that uses default retries.\n+         *\n+         * @param executor {@link Executor} to use for retry backoffs.\n+         * @param initialDelay {@link Duration} to use as initial delay for backoffs.\n+         * @param flipAvailability {@link UnaryOperator} that returns a new {@link ServiceDiscovererEvent} that is the\n+         * same as the passed {@link ServiceDiscovererEvent} but with {@link ServiceDiscovererEvent#isAvailable()} value\n+         * flipped.\n+         * @param <ResolvedAddress> The type of address after resolution.\n+         * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+         * @return A new {@link Builder}.\n+         */\n+        public static <ResolvedAddress, E extends ServiceDiscovererEvent<ResolvedAddress>> Builder<ResolvedAddress, E>\n+        withDefaults(final Executor executor, final Duration initialDelay, final UnaryOperator<E> flipAvailability) {\n+            return new Builder<>(new IndefiniteRetryStrategy(executor, initialDelay), flipAvailability);\n+        }\n+    }\n+\n+    private static final class EventsCache<R, E extends ServiceDiscovererEvent<R>> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final Map NONE_RETAINED = emptyMap();\n+\n+        private Map<R, E> retainedAddresses = noneRetained();\n+        private int targetSize;\n+        private final Map<R, E> activeAddresses = new HashMap<>();\n+        private final int retainTillReceivePercentage;\n+        private final UnaryOperator<E> flipAvailability;\n+\n+        EventsCache(final int retainTillReceivePercentage, final UnaryOperator<E> flipAvailability) {\n+            this.retainTillReceivePercentage = retainTillReceivePercentage;\n+            this.flipAvailability = flipAvailability;\n+        }\n+\n+        void errorSeen() {\n+            if (retainedAddresses == NONE_RETAINED) {\n+                retainedAddresses = new HashMap<>(activeAddresses);\n+            } else {\n+                retainedAddresses.putAll(activeAddresses);\n+            }\n+            targetSize = (int) (ceil(retainTillReceivePercentage / 100d) * activeAddresses.size());", "originalCommit": "0911d866722ebeb2ad7fc03ea74e244f2b71d29f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkwMDc1Nw==", "url": "https://github.com/apple/servicetalk/pull/1115#discussion_r465900757", "bodyText": "Great catch!\nWrong placement of brackets \ud83d\ude22\nI will fix and add tests, thanks!", "author": "NiteshKant", "createdAt": "2020-08-05T17:50:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0NjIyNg=="}], "type": "inlineReview"}, {"oid": "d710ed5a221bf607f453a94e265d92593bca5fc7", "url": "https://github.com/apple/servicetalk/commit/d710ed5a221bf607f453a94e265d92593bca5fc7", "message": "Review comments", "committedDate": "2020-08-05T17:59:24Z", "type": "commit"}]}