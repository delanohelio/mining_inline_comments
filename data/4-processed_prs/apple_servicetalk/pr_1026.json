{"pr_number": 1026, "pr_title": "ConcurrentUtils cleanup, [Completable|Single]Processor cancel concurrency fix, Simplify Publisher#flatMapConcatIterable", "pr_createdAt": "2020-04-18T03:30:39Z", "pr_url": "https://github.com/apple/servicetalk/pull/1026", "timeline": [{"oid": "12b2aab61ed242cc6232c4c3bd654b2e9fb0055d", "url": "https://github.com/apple/servicetalk/commit/12b2aab61ed242cc6232c4c3bd654b2e9fb0055d", "message": "ConcurrentUtils cleanup, [Completable|Single]Processor cancel\nconcurrency fix, Simplify Publisher#flatMapConcatIterable\n\nMotivation:\nConcurrentUtils has two variables that are public to support locking in a Reactive Stream's context: CONCURRENT_IDLE and CONCURRENT_EMITTING. We should explore if these variables can be made private and instead expose locking methods for better encapsulation and to ensure consistent usage.\n\nPublisher#flatMapMergeSingle was updated in PR #1014 to avoid depending upon queue for visibility of draining/processing elements. We should update the other queue drain methods in ConcurrentUtils to use a consistent strategy.\n\n[Completable|Single]Processor use a single consumer drain lock, but\ncancel may occur from multiple threads. This may result in items\nremaining in the queue for long periods of time until the outer\nprocessor terminates.\n\nModifications:\n- Make ConcurrentUtils defintions private\n- Remove usage of drain*ConsumerQueue methods that don't require the single consumer queue semantics, and can instead use a ConcurrentLinkedQueue for simplified draining. This can also lead to lower memory footprint when queue sizes are anticipated to be small.\n- Use ConcurrentLinkedQueue in [Completable|Single]Processor to avoid\nitems remaining in queue for prolonged periods of time.\n- Simplify Publisher#flatMapConcatIterable as a result of new concurrent\nutilities\n\nResult:\nFixes https://github.com/apple/servicetalk/issues/1023\nFixes https://github.com/apple/servicetalk/issues/1024", "committedDate": "2020-04-18T03:15:53Z", "type": "commit"}, {"oid": "310fee0db4d1d65b9395344c8f8cd42076716ffe", "url": "https://github.com/apple/servicetalk/commit/310fee0db4d1d65b9395344c8f8cd42076716ffe", "message": "simplify loop in PublisherConcatMapIterable", "committedDate": "2020-04-18T21:32:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQyMTk4OA==", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r412421988", "bodyText": "Should we worry about multiple exceptions while we iterate all subscribers? Can we left a comment describing why we take only the first cause and ignore others?", "author": "idelpivnitskiy", "createdAt": "2020-04-21T19:12:43Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/CompletableProcessor.java", "diffHunk": "@@ -111,7 +90,20 @@ private void terminate(TerminalNotification terminalSignal) {\n     }\n \n     private void notifyListeners(TerminalNotification terminalSignal) {\n-        drainSingleConsumerQueueDelayThrow(subscribers, terminalSignal::terminate, drainingTheQueueUpdater, this);\n+        Throwable delayedCause = null;\n+        Subscriber subscriber;\n+        while ((subscriber = subscribers.poll()) != null) {\n+            try {\n+                terminalSignal.terminate(subscriber);\n+            } catch (Throwable cause) {\n+                if (delayedCause == null) {\n+                    delayedCause = cause;", "originalCommit": "310fee0db4d1d65b9395344c8f8cd42076716ffe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ4MTgwNA==", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r412481804", "bodyText": "Ok, I saw this discussion: #1011 (comment)\nCan you please leave a comment in all such places for future contributors to help them understand this decision?", "author": "idelpivnitskiy", "createdAt": "2020-04-21T20:49:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQyMTk4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI5MTAxOQ==", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416291019", "bodyText": "I added a ThrowableUtils#catchUnexpected method to consolidate the usage and make it easier to change later if necessary (and added comments here).", "author": "Scottmitch", "createdAt": "2020-04-28T03:01:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQyMTk4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk3NzgyNA==", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r415977824", "bodyText": "Since we are simplifying this code, we can also remove the \"notify all subscribers in order\" semantics from here. I am pretty sure we do not need it.\nif (subscribers.offer(subscriber)) {\n    TerminalNotification terminalSignal = this.terminalSignal;\n    if (terminalSignal != null && subscribers.remove(subscriber)) {\n        terminalSignal.terminate(subscriber);\n    } else {", "author": "NiteshKant", "createdAt": "2020-04-27T16:48:13Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/CompletableProcessor.java", "diffHunk": "@@ -67,20 +59,7 @@ protected void handleSubscribe(Subscriber subscriber) {\n                 delayedCancellable.delayedCancellable(() -> {\n                     // Cancel in this case will just cleanup references from the queue to ensure we don't prevent GC of\n                     // these references.\n-                    if (!drainingTheQueueUpdater.compareAndSet(this, CONCURRENT_IDLE, CONCURRENT_EMITTING)) {", "originalCommit": "310fee0db4d1d65b9395344c8f8cd42076716ffe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIxMzMyNg==", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416213326", "bodyText": "lets do this as a followup PR as you indicated it changes behavior/semantics and if we do relax constraints would be useful to have explicit PR/commit for release note notification.", "author": "Scottmitch", "createdAt": "2020-04-27T23:17:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk3NzgyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIyNTQ0Mg==", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416225442", "bodyText": "#1033", "author": "Scottmitch", "createdAt": "2020-04-27T23:47:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk3NzgyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk4MjAzOQ==", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r415982039", "bodyText": "perhaps a good time to rename this method to indicate that it throws? eg: finishAndThrow()", "author": "NiteshKant", "createdAt": "2020-04-27T16:53:42Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/CompositeException.java", "diffHunk": "@@ -55,13 +48,30 @@ void add(Throwable toAdd) {\n         if (!suppressed.offer(toAdd)) {\n             addSuppressed(toAdd);\n         }\n+        // if addAllPendingSuppressed has already been called don't bother trying to synchronize/drain the queue\n+        // as it is assumed the exception will be thrown after that method is called.\n     }\n \n     /**\n      * Adds all {@link Throwable}s added using {@link #add(Throwable)} to this {@link CompositeException} using\n      * {@link #addSuppressed(Throwable)}.\n+     * <p>\n+     * It is assumed that {@link #add(Throwable)} won't be called after this method.\n      */\n     void addAllPendingSuppressed() {", "originalCommit": "310fee0db4d1d65b9395344c8f8cd42076716ffe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1MDc2Nw==", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416050767", "bodyText": "rename to tryAcquireEmissionLock?", "author": "NiteshKant", "createdAt": "2020-04-27T18:29:40Z", "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentUtils.java", "diffHunk": "@@ -25,61 +23,52 @@\n  * Utilities which can be used for concurrency.\n  */\n public final class ConcurrentUtils {\n-    private static final int NOT_EXECUTING_EXCLUSIVE = 0;\n-    private static final int EXECUTING_EXCLUSIVE = 1;\n-    private static final int CONCURRENT_EXECUTE_EXCLUSIVE = 2;\n-\n-    public static final int CONCURRENT_IDLE = 0;\n-    public static final int CONCURRENT_EMITTING = 1;\n+    private static final int CONCURRENT_IDLE = 0;\n+    private static final int CONCURRENT_EMITTING = 1;\n+    private static final int CONCURRENT_PENDING = 2;\n \n     private ConcurrentUtils() {\n         // No instances.\n     }\n \n     /**\n-     * Drains the passed single-consumer {@link Queue} and ensures that it is empty before returning.\n-     * This accounts for any additions to the {@link Queue} while drain is in progress.\n-     * Multiple threads can call this method concurrently but only one thread will actively drain the {@link Queue}.\n-     *\n-     * @param queue {@link Queue} to drain.\n-     * @param forEach {@link Consumer} for each item that is drained.\n-     * @param drainActiveUpdater An {@link AtomicIntegerFieldUpdater} for an {@code int} that is used to guard against\n-     * concurrent drains.\n-     * @param flagOwner Holding instance for {@code drainActiveUpdater}.\n-     * @param <T> Type of items stored in the {@link Queue}.\n-     * @param <R> Type of the object holding the {@link int} referred by {@link AtomicIntegerFieldUpdater}.\n-     * @return Number of items drained from the queue.\n+     * Acquire a lock that is exclusively held with no re-entry, but attempts to acquire the lock while it is\n+     * held can be detected by {@link #releasePendingLock(AtomicIntegerFieldUpdater, Object)}.\n+     * @param lockUpdater The {@link AtomicIntegerFieldUpdater} used to control the lock state.\n+     * @param owner The owner of the lock object.\n+     * @param <T> The type of object that owns the lock.\n+     * @return {@code true} if the lock was acquired, {@code false} otherwise.\n      */\n-    public static <T, R> long drainSingleConsumerQueue(final Queue<T> queue, final Consumer<T> forEach,\n-                                                       final AtomicIntegerFieldUpdater<R> drainActiveUpdater,\n-                                                       final R flagOwner) {\n-        long drainedCount = 0;\n-        do {\n-            if (!drainActiveUpdater.compareAndSet(flagOwner, CONCURRENT_IDLE, CONCURRENT_EMITTING)) {\n-                break;\n-            }\n-            try {\n-                T t;\n-                while ((t = queue.poll()) != null) {\n-                    ++drainedCount;\n-                    forEach.accept(t);\n+    public static <T> boolean acquirePendingLock(AtomicIntegerFieldUpdater<T> lockUpdater, T owner) {", "originalCommit": "310fee0db4d1d65b9395344c8f8cd42076716ffe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIxODQwMg==", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416218402", "bodyText": "i agree the existing name isn't ideal. I wanted to convey the lock state is 3 fold and there is a \"hand off\" if failure to acquire.\ndiscussed offline and we will go with tryAcquireLock and releaseLock", "author": "Scottmitch", "createdAt": "2020-04-27T23:29:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1MDc2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1NTEwOA==", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416055108", "bodyText": "This is pre-existing but looks like we will invoke the target onError twice if strategy is Propagate, terminalNotification is non-null (from onError() above) and currentIterator.hasNext() throws.", "author": "NiteshKant", "createdAt": "2020-04-27T18:36:11Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherConcatMapIterable.java", "diffHunk": "@@ -204,53 +194,32 @@ private void tryDrainIterator(Iterator<? extends U> currentIterator, Subscriptio\n                         terminalNotification.terminate(target);", "originalCommit": "310fee0db4d1d65b9395344c8f8cd42076716ffe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIyMDQ4MQ==", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416220481", "bodyText": "good catch .. I'll hard return our early", "author": "Scottmitch", "createdAt": "2020-04-27T23:34:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1NTEwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1Nzk1Nw==", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416057957", "bodyText": "Consider adding a comment that visibility is guaranteed by write/read of emitting lock", "author": "NiteshKant", "createdAt": "2020-04-27T18:40:36Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherConcatMapIterable.java", "diffHunk": "@@ -53,23 +53,25 @@\n     }\n \n     private static final class FlatMapIterableSubscriber<T, U> implements Subscriber<T>, Subscription {\n+        @SuppressWarnings(\"rawtypes\")\n         private static final AtomicLongFieldUpdater<FlatMapIterableSubscriber> requestNUpdater =\n                 AtomicLongFieldUpdater.newUpdater(FlatMapIterableSubscriber.class, \"requestN\");\n+        @SuppressWarnings(\"rawtypes\")\n         private static final AtomicIntegerFieldUpdater<FlatMapIterableSubscriber> emittingUpdater =\n                 AtomicIntegerFieldUpdater.newUpdater(FlatMapIterableSubscriber.class, \"emitting\");\n         private final Function<? super T, ? extends Iterable<? extends U>> mapper;\n         private final Subscriber<? super U> target;\n         @Nullable\n-        private volatile Subscription sourceSubscription;\n+        private Subscription sourceSubscription;\n         @Nullable\n-        private volatile TerminalNotification terminalNotification;\n+        private TerminalNotification terminalNotification;\n         /**\n          * We only ever request a single {@link Iterable} at a time, and wait to request another {@link Iterable} until\n          * {@link Iterator#hasNext()} returns {@code false}. This means we don't need to queue {@link Iterator}s, and\n          * was done because we don't know how many elements will be returned by each {@link Iterator} and so we are as\n          * conservative as we can be about memory consumption.\n          */\n-        private volatile Iterator<? extends U> currentIterator = emptyIterator();\n+        private Iterator<? extends U> currentIterator = emptyIterator();", "originalCommit": "310fee0db4d1d65b9395344c8f8cd42076716ffe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA2NzAxMQ==", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416067011", "bodyText": "This may be a better in a separate PR but the control-flow here is still utterly confusing and there are cases we may throw from a finally block which is a debugging nightmare \ud83d\ude42. It will be good to revisit the control flow at some point.", "author": "NiteshKant", "createdAt": "2020-04-27T18:53:38Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherConcatMapIterable.java", "diffHunk": "@@ -204,53 +194,32 @@ private void tryDrainIterator(Iterator<? extends U> currentIterator, Subscriptio\n                         terminalNotification.terminate(target);\n                     }\n                 } finally {\n-                    requestN = requestNUpdater.accumulateAndGet(this, requestN - initialRequestN,\n+                    currRequestN = requestNUpdater.accumulateAndGet(this, currRequestN - initialRequestN,\n                             FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n-                    if (requestN < 0) {\n+                    if (currRequestN < 0) {\n                         terminated = true;\n                         // We clear out the current iterator to allow for GC, and we don't want to deliver any more data\n                         // because it may be out of order or incomplete ... so simulate a terminated event.\n-                        doCancel(sourceSubscription);\n+                        doCancel();\n                     } else if (!terminated) {\n-                        final Iterator<? extends U> previousIterator;\n                         try {\n-                            if (terminalNotification == null && !hasNext && requestN > 0 &&\n+                            if (terminalNotification == null && !hasNext && currRequestN > 0 &&\n                                     currentIterator != EmptyIterator.instance()) {\n                                 // We only request 1 at a time, and therefore we don't have any outstanding demand, so\n                                 // we will not be getting an onNext call, so we write to the currentIterator variable\n                                 // here before we unlock emitting so visibility to other threads should be taken care of\n                                 // by the write to emitting below (and later read).\n-                                this.currentIterator = previousIterator = EmptyIterator.instance();\n+                                this.currentIterator = EmptyIterator.instance();\n                                 sourceSubscription.request(1);\n-                            } else {\n-                                previousIterator = currentIterator;\n                             }\n                         } finally {\n                             // The lock must be released after we interact with the subscription for thread safety\n                             // reasons.\n-                            emitting = CONCURRENT_IDLE;\n-                        }\n-\n-                        // We may have been cancelled while we were holding the lock, so we need to check if we have\n-                        // been cancelled after we release the lock.\n-                        requestN = this.requestN;\n-\n-                        // We may requested more data while we held the lock. If data was delivered in a re-entry\n-                        // fashion, or if data was delivered on another thread while we held the lock we may have to try\n-                        // to re-acquire the lock and drain the new Iterator.\n-                        currentIterator = this.currentIterator;\n-                        if (previousIterator != currentIterator) {\n-                            // We only want to interact with the iterator inside the lock, and we don't want to exit\n-                            // early if we have seen a terminal event in the mean time, so if there is demand we assume\n-                            // for now that hasNext is true, and we will find out if there is really data if we\n-                            // re-acquire the lock.\n-                            hasNext = requestN > 0;\n+                            releasedLock = releasePendingLock(emittingUpdater, this);\n                         }\n                     }\n                 }\n-            } while (!terminated &&\n-                    (requestN < 0 || (requestN > 0 && hasNext) ||\n-                    (!hasNext && (terminalNotification = this.terminalNotification) != null)));\n+            } while (!terminated && !releasedLock);", "originalCommit": "310fee0db4d1d65b9395344c8f8cd42076716ffe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIyMTE2Mg==", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416221162", "bodyText": "I wanted to minimize change in this PR to focus on the concurrent utilities. lets consider more general simplification as a followup PR.", "author": "Scottmitch", "createdAt": "2020-04-27T23:36:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA2NzAxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIyMjA4NQ==", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416222085", "bodyText": "#1032", "author": "Scottmitch", "createdAt": "2020-04-27T23:38:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA2NzAxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA2ODgwOA==", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416068808", "bodyText": "Use SubscriberUtils.safeOnError in this and other branches here.", "author": "NiteshKant", "createdAt": "2020-04-27T18:56:22Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherConcatMapIterable.java", "diffHunk": "@@ -160,27 +149,28 @@ private void doCancel(Subscription sourceSubscription) {\n             Throw\n         }\n \n-        private void tryDrainIterator(Iterator<? extends U> currentIterator, Subscription sourceSubscription,\n-                                      @Nullable TerminalNotification terminalNotification, long requestN,\n-                                      ErrorHandlingStrategyInDrain errorHandlingStrategyInDrain) {\n+        private void tryDrainIterator(ErrorHandlingStrategyInDrain errorHandlingStrategyInDrain) {\n+            assert sourceSubscription != null;\n             boolean hasNext = false;\n             boolean terminated = false;\n+            boolean releasedLock = false;\n             do {\n-                if (!emittingUpdater.compareAndSet(this, CONCURRENT_IDLE, CONCURRENT_EMITTING)) {\n+                if (!acquirePendingLock(emittingUpdater, this)) {\n                     break;\n                 }\n-                final long initialRequestN = requestN;\n+                long currRequestN = this.requestN;\n+                final long initialRequestN = currRequestN;\n                 try {\n                     try {\n-                        while ((hasNext = currentIterator.hasNext()) && requestN > 0) {\n-                            --requestN;\n+                        while ((hasNext = currentIterator.hasNext()) && currRequestN > 0) {\n+                            --currRequestN;\n                             target.onNext(currentIterator.next());\n                         }\n                     } catch (Throwable cause) {\n                         switch (errorHandlingStrategyInDrain) {\n                             case PropagateAndCancel:\n                                 terminated = true;\n-                                doCancel(sourceSubscription);\n+                                doCancel();\n                                 try {\n                                     target.onError(cause);\n                                 } catch (Throwable cause2) {", "originalCommit": "310fee0db4d1d65b9395344c8f8cd42076716ffe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA3MzQxNQ==", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416073415", "bodyText": "We just need to cancel toAdd if it wasn't cancelled by cancel() above, rite?\n        if (!cancellables.offer(toAdd)) {\n            toAdd.cancel();\n        } else if (isCancelled()) {\n            if (cancellables.remove(toAdd)) {\n                toAdd.cancel();\n            }\n            return false;\n        }\n        return true;", "author": "NiteshKant", "createdAt": "2020-04-27T19:03:29Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/QueueDynamicCompositeCancellable.java", "diffHunk": "@@ -16,50 +16,33 @@\n package io.servicetalk.concurrent.api;\n \n import io.servicetalk.concurrent.Cancellable;\n-import io.servicetalk.concurrent.internal.QueueFullException;\n \n import java.util.Queue;\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n \n-import static io.servicetalk.concurrent.internal.ConcurrentUtils.CONCURRENT_EMITTING;\n-import static io.servicetalk.concurrent.internal.ConcurrentUtils.CONCURRENT_IDLE;\n-import static io.servicetalk.concurrent.internal.ConcurrentUtils.drainSingleConsumerCollectionDelayThrow;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n \n final class QueueDynamicCompositeCancellable implements DynamicCompositeCancellable {\n     private static final AtomicIntegerFieldUpdater<QueueDynamicCompositeCancellable> cancelledUpdater =\n             AtomicIntegerFieldUpdater.newUpdater(QueueDynamicCompositeCancellable.class, \"cancelled\");\n     @SuppressWarnings(\"unused\")\n     private volatile int cancelled;\n \n-    private static final AtomicIntegerFieldUpdater<QueueDynamicCompositeCancellable> drainingUpdater =\n-            AtomicIntegerFieldUpdater.newUpdater(QueueDynamicCompositeCancellable.class, \"draining\");\n-    @SuppressWarnings(\"unused\")\n-    private volatile int draining;\n-\n-    // TODO(scott): consider using a MPSC queue from JCTools once remove is supported.\n-    // https://github.com/JCTools/JCTools/pull/193#issuecomment-329958251\n     private final Queue<Cancellable> cancellables = new ConcurrentLinkedQueue<>();\n \n     @Override\n     public void cancel() {\n-        if (cancelledUpdater.compareAndSet(this, CONCURRENT_IDLE, CONCURRENT_EMITTING)) {\n+        if (cancelledUpdater.compareAndSet(this, 0, 1)) {\n             cancelAll();\n         }\n     }\n \n     @Override\n     public boolean add(Cancellable toAdd) {\n-        if (isCancelled()) {\n-            toAdd.cancel();\n-            return false;\n-        }\n-\n         if (!cancellables.offer(toAdd)) {\n-            throw new QueueFullException(\"cancellables\");\n-        }\n-\n-        if (isCancelled()) {\n+            toAdd.cancel();\n+        } else if (isCancelled()) {\n             cancelAll();", "originalCommit": "310fee0db4d1d65b9395344c8f8cd42076716ffe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIyNTAyOQ==", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416225029", "bodyText": "good question, lets handle this as a followup just to preserve ordering semantics in this PR and make the change more visible if/when it is made #1033", "author": "Scottmitch", "createdAt": "2020-04-27T23:46:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA3MzQxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA4MDE2Mg==", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416080162", "bodyText": "Can we avoid calling cancelAll() here as I suggested above for the queue variant?\nLooks like we can concurrently invoke a Cancellable if cancelAll() is invoked concurrently.", "author": "NiteshKant", "createdAt": "2020-04-27T19:14:17Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/SetDynamicCompositeCancellable.java", "diffHunk": "@@ -17,75 +17,64 @@\n \n import io.servicetalk.concurrent.Cancellable;\n \n-import java.util.Map;\n+import java.util.Iterator;\n+import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n \n-import static io.servicetalk.concurrent.internal.ConcurrentUtils.CONCURRENT_EMITTING;\n-import static io.servicetalk.concurrent.internal.ConcurrentUtils.CONCURRENT_IDLE;\n-import static io.servicetalk.concurrent.internal.ConcurrentUtils.drainSingleConsumerCollectionDelayThrow;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.util.Collections.newSetFromMap;\n \n /**\n  * A {@link Cancellable} that contains other {@link Cancellable}s.\n  * <p>\n  * {@link Cancellable#cancel()} is propagated to all active {@link Cancellable}s. Any new {@link Cancellable} added\n  * after that will be immediately cancelled.\n  */\n-final class MapDynamicCompositeCancellable implements DynamicCompositeCancellable {\n-\n-    private static final AtomicIntegerFieldUpdater<MapDynamicCompositeCancellable> cancelledUpdater =\n-            AtomicIntegerFieldUpdater.newUpdater(MapDynamicCompositeCancellable.class, \"cancelled\");\n+final class SetDynamicCompositeCancellable implements DynamicCompositeCancellable {\n+    private static final AtomicIntegerFieldUpdater<SetDynamicCompositeCancellable> cancelledUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(SetDynamicCompositeCancellable.class, \"cancelled\");\n     @SuppressWarnings(\"unused\")\n     private volatile int cancelled;\n \n-    private static final AtomicIntegerFieldUpdater<MapDynamicCompositeCancellable> drainingUpdater =\n-            AtomicIntegerFieldUpdater.newUpdater(MapDynamicCompositeCancellable.class, \"draining\");\n-    @SuppressWarnings(\"unused\")\n-    private volatile int draining;\n-\n-    private final ConcurrentMap<Cancellable, Cancellable> cancellables;\n+    private final Set<Cancellable> cancellables;\n \n     /**\n      * Create a new instance.\n      */\n-    MapDynamicCompositeCancellable() {\n+    SetDynamicCompositeCancellable() {\n         this(8);\n     }\n \n     /**\n      * Create a new instance.\n-     * @param initialSize The initial size of the internal {@link Map}.\n+     * @param initialSize The initial size of the internal {@link Set}.\n      */\n-    MapDynamicCompositeCancellable(int initialSize) {\n-        cancellables = new ConcurrentHashMap<>(initialSize);\n+    SetDynamicCompositeCancellable(int initialSize) {\n+        cancellables = newSetFromMap(new ConcurrentHashMap<>(initialSize));\n     }\n \n     @Override\n     public void cancel() {\n-        if (cancelledUpdater.compareAndSet(this, CONCURRENT_IDLE, CONCURRENT_EMITTING)) {\n+        if (cancelledUpdater.compareAndSet(this, 0, 1)) {\n             cancelAll();\n         }\n     }\n \n     @Override\n     public boolean add(Cancellable toAdd) {\n-        if (isCancelled()) {\n-            toAdd.cancel();\n+        if (!cancellables.add(toAdd)) {\n+            toAdd.cancel(); // out of memory, or user has implemented equals/hashCode so there is overlap.\n+        } else if (isCancelled()) {\n+            cancelAll();", "originalCommit": "310fee0db4d1d65b9395344c8f8cd42076716ffe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIzMDMxMQ==", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416230311", "bodyText": "good call ... because of the Set interface we can't safely drain from multiple threads and process and item exactly once. This needs to use the tryAcquireLock method and I will fix.", "author": "Scottmitch", "createdAt": "2020-04-28T00:00:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA4MDE2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA4MTMxMA==", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416081310", "bodyText": "Use acquire() and release methods from above here too?", "author": "NiteshKant", "createdAt": "2020-04-27T19:16:09Z", "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentUtils.java", "diffHunk": "@@ -89,13 +78,10 @@ private ConcurrentUtils() {\n      * @param <T> Type of items stored in the {@link Queue}.\n      * @param <R> Type of the object holding the {@link int} referred by {@link AtomicIntegerFieldUpdater}.\n      * @return Number of items drained from the queue.\n-     * @throws RuntimeException All {@link Throwable} thrown by {@code forEach} {@link Consumer} are added as suppressed\n-     * causes.\n      */\n-    public static <T, R> long drainSingleConsumerQueueDelayThrow(final Queue<T> queue, final Consumer<T> forEach,\n-                                                                 final AtomicIntegerFieldUpdater<R> drainActiveUpdater,\n-                                                                 final R flagOwner) {\n-        RuntimeException cause = null;\n+    public static <T, R> long drainSingleConsumerQueue(final Queue<T> queue, final Consumer<T> forEach,\n+                                                       final AtomicIntegerFieldUpdater<R> drainActiveUpdater,\n+                                                       final R flagOwner) {\n         long drainedCount = 0;\n         do {\n             if (!drainActiveUpdater.compareAndSet(flagOwner, CONCURRENT_IDLE, CONCURRENT_EMITTING)) {", "originalCommit": "310fee0db4d1d65b9395344c8f8cd42076716ffe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIzNjUwNQ==", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416236505", "bodyText": "This method is removed in #1014, so lets discuss on that PR and for now I'll avoid touching in this PR.", "author": "Scottmitch", "createdAt": "2020-04-28T00:17:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA4MTMxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA4MjE4OA==", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416082188", "bodyText": "Same suggestion as CompletableProcessor to remove the \"invoke listeners in order\" semantics.", "author": "NiteshKant", "createdAt": "2020-04-27T19:17:33Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/SingleProcessor.java", "diffHunk": "@@ -22,28 +22,24 @@\n import io.servicetalk.concurrent.internal.TerminalNotification;\n \n import java.util.Queue;\n-import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n import javax.annotation.Nullable;\n \n-import static io.servicetalk.concurrent.internal.ConcurrentUtils.CONCURRENT_EMITTING;\n-import static io.servicetalk.concurrent.internal.ConcurrentUtils.CONCURRENT_IDLE;\n-import static io.servicetalk.concurrent.internal.ConcurrentUtils.drainSingleConsumerQueueDelayThrow;\n-import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedLinkedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n \n /**\n  * A {@link Single} which is also a {@link Subscriber}. State of this {@link Single} can be modified by using the\n  * {@link Subscriber} methods which is forwarded to all existing or subsequent {@link Subscriber}s.\n  * @param <T> The type of result of the {@link Single}.\n  */\n final class SingleProcessor<T> extends Single<T> implements Processor<T, T> {", "originalCommit": "310fee0db4d1d65b9395344c8f8cd42076716ffe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIzNjkxNQ==", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416236915", "bodyText": "good point, lets discuss on #1033 and handle semantic change in a follow PR.", "author": "Scottmitch", "createdAt": "2020-04-28T00:18:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA4MjE4OA=="}], "type": "inlineReview"}, {"oid": "3866fd1e0a41d71944928a87fc0e506bdce81f68", "url": "https://github.com/apple/servicetalk/commit/3866fd1e0a41d71944928a87fc0e506bdce81f68", "message": "review comments", "committedDate": "2020-04-28T00:59:48Z", "type": "commit"}, {"oid": "77bdc2c432c65f567edb4d7b4f878a6deea30f6d", "url": "https://github.com/apple/servicetalk/commit/77bdc2c432c65f567edb4d7b4f878a6deea30f6d", "message": "add throwable util for catching unepxected exceptions", "committedDate": "2020-04-28T03:01:14Z", "type": "commit"}, {"oid": "19579756cb03c6ef03c47ccd28aa8ab43770a280", "url": "https://github.com/apple/servicetalk/commit/19579756cb03c6ef03c47ccd28aa8ab43770a280", "message": "avoid break in finally", "committedDate": "2020-04-28T03:36:09Z", "type": "commit"}]}