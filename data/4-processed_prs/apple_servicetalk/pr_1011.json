{"pr_number": 1011, "pr_title": "Add Publisher#flatMapMerge operator", "pr_createdAt": "2020-04-14T16:54:08Z", "pr_url": "https://github.com/apple/servicetalk/pull/1011", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI5MDA2NA==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r408290064", "bodyText": "the API here declares this as a hint for future flexibility, but the current implementation will respect this value.", "author": "Scottmitch", "createdAt": "2020-04-14T16:55:26Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Publisher.java", "diffHunk": "@@ -187,6 +187,72 @@ protected Publisher() {\n         return new ResumePublisher<>(this, nextFactory, executor);\n     }\n \n+    /**\n+     * Each element of this {@link Publisher} is mapped into a {@link Publisher} (potentially of a different type) and\n+     * flatten all signals emitted from each mapped {@link Publisher} into the returned {@link Publisher}.\n+     * <pre>{@code\n+     *     ExecutorService e = ...;\n+     *     List<Future<List<R>>> futures = ...; // assume this is thread safe\n+     *     for (T t : resultOfThisPublisher()) {\n+     *         // Note that flatMap process results in parallel.\n+     *         futures.add(e.submit(() -> {\n+     *             return mapper.apply(t); // Asynchronous result is flatten into a value by this operator.\n+     *         }));\n+     *     }\n+     *     List<R> results = new ArrayList<>(futures.size());\n+     *     // This is an approximation, this operator does not provide any ordering guarantees for the results.\n+     *     for (Future<List<R>> future : futures) {\n+     *         List<R> rList = future.get(); // Throws if the processing for this item failed.\n+     *         results.addAll(rList);\n+     *     }\n+     *     return results;\n+     * }</pre>\n+     * @param mapper Convert each item emitted by this {@link Publisher} into another {@link Publisher}.\n+     * each mapped {@link Publisher}.\n+     * @param <R> The type of mapped {@link Publisher}.\n+     * @return A new {@link Publisher} which flattens the emissions from all mapped {@link Publisher}s.\n+     * @see <a href=\"http://reactivex.io/documentation/operators/flatmap.html\">ReactiveX flatMap operator.</a>\n+     */\n+    public final <R> Publisher<R> flatMapMerge(Function<? super T, ? extends Publisher<? extends R>> mapper) {\n+        return flatMapMerge(mapper, false, 16, 64);\n+    }\n+\n+    /**\n+     * Each element of this {@link Publisher} is mapped into a {@link Publisher} (potentially of a different type) and\n+     * flatten all signals emitted from each mapped {@link Publisher} into the returned {@link Publisher}.\n+     * <pre>{@code\n+     *     ExecutorService e = ...;\n+     *     List<Future<List<R>>> futures = ...; // assume this is thread safe\n+     *     for (T t : resultOfThisPublisher()) {\n+     *         // Note that flatMap process results in parallel.\n+     *         futures.add(e.submit(() -> {\n+     *             return mapper.apply(t); // Asynchronous result is flatten into a value by this operator.\n+     *         }));\n+     *     }\n+     *     List<R> results = new ArrayList<>(futures.size());\n+     *     // This is an approximation, this operator does not provide any ordering guarantees for the results.\n+     *     for (Future<List<R>> future : futures) {\n+     *         List<R> rList = future.get(); // Throws if the processing for this item failed.\n+     *         results.addAll(rList);\n+     *     }\n+     *     return results;\n+     * }</pre>\n+     * @param mapper Convert each item emitted by this {@link Publisher} into another {@link Publisher}.\n+     * @param delayError {@code false} if the returned {@link Publisher} should fail as soon as any of the mapped\n+     * {@link Publisher}s fail. {@code true} to wait until this {@link Publisher} terminates to emit any failures from\n+     * the mapped {@link Publisher}s.\n+     * @param maxConcurrency maximum amount of outstanding upstream {@link Subscription#request(long) demand}.\n+     * @param maxMappedDemandHint hint for the maximum amount of {@link Subscription#request(long) demand} for", "originalCommit": "be25d527238e4859836a399a243c7b82ea148854", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM3NDkwOA==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r408374908", "bodyText": "how could this ever return false ? FlatMapPublisherSubscriber doesn't have an equals implementation and so this will always return true imho.", "author": "normanmaurer", "createdAt": "2020-04-14T19:15:38Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,681 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.EmptySubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Iterator;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.NULL_TOKEN;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.acquirePendingLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releasePendingLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> tryRequestMoreLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"tryRequestMoreLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int tryRequestMoreLock;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile long pendingDemand;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+\n+        /**\n+         * This variable is only accessed within the \"emitting lock\" so we rely upon this to provide visibility to\n+         * other threads.\n+         */\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> pending;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            pending = newUnboundedMpscQueue(min(2, source.maxConcurrency));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                pendingDemandUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtection);\n+                tryRequestMore();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            // Currently we always request maxConcurrency elements from upstream.\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            if (subscribers.add(subscriber)) {", "originalCommit": "be25d527238e4859836a399a243c7b82ea148854", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ0MDU3NQ==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r408440575", "bodyText": "it isn't expected to fail ... but if it did we would be in an inconsistent state if we attempted to modify the other state.", "author": "Scottmitch", "createdAt": "2020-04-14T21:16:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM3NDkwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ0MTEyOQ==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r408441129", "bodyText": "I'll add a throw in an else statement to clarify.", "author": "Scottmitch", "createdAt": "2020-04-14T21:17:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM3NDkwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMzNTE3Mg==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r409335172", "bodyText": "I still don't understand how this ever could return false even in an \"inconsistent state\".", "author": "normanmaurer", "createdAt": "2020-04-16T07:21:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM3NDkwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk4MTUxMw==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r409981513", "bodyText": "as mentioned above it isn't expected to fail, but is somewhat ambiguous from the API perspective where it \"may return false\". is your suggestion to ignore the return value, add an assert, or just add comments instead of the runtime check/exception?", "author": "Scottmitch", "createdAt": "2020-04-17T04:08:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM3NDkwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk4MjUwNw==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r409982507", "bodyText": "I'll just change it to an assert and add a comment. let me know if you had something else in mind.", "author": "Scottmitch", "createdAt": "2020-04-17T04:13:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM3NDkwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM3NzY1Mg==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r408377652", "bodyText": "should we use addSuppressed(...) if delayedCause != null ?", "author": "normanmaurer", "createdAt": "2020-04-14T19:20:37Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,681 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.EmptySubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Iterator;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.NULL_TOKEN;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.acquirePendingLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releasePendingLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> tryRequestMoreLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"tryRequestMoreLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int tryRequestMoreLock;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile long pendingDemand;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+\n+        /**\n+         * This variable is only accessed within the \"emitting lock\" so we rely upon this to provide visibility to\n+         * other threads.\n+         */\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> pending;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            pending = newUnboundedMpscQueue(min(2, source.maxConcurrency));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                pendingDemandUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtection);\n+                tryRequestMore();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            // Currently we always request maxConcurrency elements from upstream.\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            if (subscribers.add(subscriber)) {\n+                for (;;) {\n+                    final int prevActiveMappedSources = activeMappedSources;\n+                    if (prevActiveMappedSources < 0) {\n+                        // We have been cancelled, so in this case we don't want to Subscribe and instead\n+                        // just want to discard the Publisher.\n+                        subscribers.remove(subscriber);\n+                        break;\n+                    } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveMappedSources,\n+                            prevActiveMappedSources + 1)) {\n+                        publisher.subscribeInternal(subscriber);\n+                        tryRequestMore(subscriber);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            Throwable delayedCause = null;\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                for (FlatMapPublisherSubscriber<T, R> subscriber : subscribers) {\n+                    try {\n+                        subscriber.cancelFromUpstream();\n+                    } catch (Throwable c) {\n+                        if (delayedCause == null) {\n+                            delayedCause = c;\n+                        }", "originalCommit": "be25d527238e4859836a399a243c7b82ea148854", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ0MDA0Ng==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r408440046", "bodyText": "throwing from methods in this scope isn't supported, so re-throwing the first cause is a compromise to provide context in the event an exception does happen but doesn't attempting to retain all exceptions that occur along the way. addSuppressed can also be painful for static/cached exceptions.", "author": "Scottmitch", "createdAt": "2020-04-14T21:15:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM3NzY1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMxOTQ0Ng==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r409319446", "bodyText": "Fair enough... that said just because you not use addSuppressed here doesn't mean that a user will not do it later on ;) So in any case special care need to be taken for static / cached exceptions", "author": "normanmaurer", "createdAt": "2020-04-16T06:48:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM3NzY1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM3ODU3NQ==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r408378575", "bodyText": "wouldn't it be better to call releaseEmittingLock() in a finally block ? Just to ensure we can not end up in a limbo state.", "author": "normanmaurer", "createdAt": "2020-04-14T19:22:12Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,681 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.EmptySubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Iterator;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.NULL_TOKEN;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.acquirePendingLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releasePendingLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> tryRequestMoreLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"tryRequestMoreLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int tryRequestMoreLock;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile long pendingDemand;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+\n+        /**\n+         * This variable is only accessed within the \"emitting lock\" so we rely upon this to provide visibility to\n+         * other threads.\n+         */\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> pending;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            pending = newUnboundedMpscQueue(min(2, source.maxConcurrency));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                pendingDemandUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtection);\n+                tryRequestMore();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            // Currently we always request maxConcurrency elements from upstream.\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            if (subscribers.add(subscriber)) {\n+                for (;;) {\n+                    final int prevActiveMappedSources = activeMappedSources;\n+                    if (prevActiveMappedSources < 0) {\n+                        // We have been cancelled, so in this case we don't want to Subscribe and instead\n+                        // just want to discard the Publisher.\n+                        subscribers.remove(subscriber);\n+                        break;\n+                    } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveMappedSources,\n+                            prevActiveMappedSources + 1)) {\n+                        publisher.subscribeInternal(subscriber);\n+                        tryRequestMore(subscriber);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            Throwable delayedCause = null;\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                for (FlatMapPublisherSubscriber<T, R> subscriber : subscribers) {\n+                    try {\n+                        subscriber.cancelFromUpstream();\n+                    } catch (Throwable c) {\n+                        if (delayedCause == null) {\n+                            delayedCause = c;\n+                        }\n+                    }\n+                }\n+                subscribers.clear();\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            if (!pending.offer(item)) {\n+                enqueueAndDrainFail(item);\n+            }\n+            drainPending();\n+        }\n+\n+        private void enqueueAndDrainFail(Object item) {\n+            QueueFullException exception = new QueueFullException(\"pending\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, true, true);\n+            }\n+        }\n+\n+        private boolean acquireEmittingLock() {\n+            return acquirePendingLock(emittingLockUpdater, this);\n+        }\n+\n+        private boolean releaseEmittingLock() {\n+            return releasePendingLock(emittingLockUpdater, this);\n+        }\n+\n+        private void drainPending() {\n+            long emittedCount = 0;\n+            for (;;) {\n+                if (!acquireEmittingLock()) {\n+                    break;\n+                }\n+                Object t;\n+                while ((t = pending.poll()) != null) {\n+                    if (sendToTarget(t)) {\n+                        ++emittedCount;\n+                    }\n+                }\n+                if (releaseEmittingLock()) {", "originalCommit": "be25d527238e4859836a399a243c7b82ea148854", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQzODcwMg==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r408438702", "bodyText": "+1 I'll put in a finally", "author": "Scottmitch", "createdAt": "2020-04-14T21:12:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM3ODU3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM3OTAwMA==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r408379000", "bodyText": "same comment as above... I think we want to call this method in a finally block.", "author": "normanmaurer", "createdAt": "2020-04-14T19:23:01Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,681 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.EmptySubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Iterator;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.NULL_TOKEN;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.acquirePendingLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releasePendingLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> tryRequestMoreLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"tryRequestMoreLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int tryRequestMoreLock;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile long pendingDemand;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+\n+        /**\n+         * This variable is only accessed within the \"emitting lock\" so we rely upon this to provide visibility to\n+         * other threads.\n+         */\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> pending;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            pending = newUnboundedMpscQueue(min(2, source.maxConcurrency));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                pendingDemandUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtection);\n+                tryRequestMore();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            // Currently we always request maxConcurrency elements from upstream.\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            if (subscribers.add(subscriber)) {\n+                for (;;) {\n+                    final int prevActiveMappedSources = activeMappedSources;\n+                    if (prevActiveMappedSources < 0) {\n+                        // We have been cancelled, so in this case we don't want to Subscribe and instead\n+                        // just want to discard the Publisher.\n+                        subscribers.remove(subscriber);\n+                        break;\n+                    } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveMappedSources,\n+                            prevActiveMappedSources + 1)) {\n+                        publisher.subscribeInternal(subscriber);\n+                        tryRequestMore(subscriber);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            Throwable delayedCause = null;\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                for (FlatMapPublisherSubscriber<T, R> subscriber : subscribers) {\n+                    try {\n+                        subscriber.cancelFromUpstream();\n+                    } catch (Throwable c) {\n+                        if (delayedCause == null) {\n+                            delayedCause = c;\n+                        }\n+                    }\n+                }\n+                subscribers.clear();\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            if (!pending.offer(item)) {\n+                enqueueAndDrainFail(item);\n+            }\n+            drainPending();\n+        }\n+\n+        private void enqueueAndDrainFail(Object item) {\n+            QueueFullException exception = new QueueFullException(\"pending\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, true, true);\n+            }\n+        }\n+\n+        private boolean acquireEmittingLock() {\n+            return acquirePendingLock(emittingLockUpdater, this);\n+        }\n+\n+        private boolean releaseEmittingLock() {\n+            return releasePendingLock(emittingLockUpdater, this);\n+        }\n+\n+        private void drainPending() {\n+            long emittedCount = 0;\n+            for (;;) {\n+                if (!acquireEmittingLock()) {\n+                    break;\n+                }\n+                Object t;\n+                while ((t = pending.poll()) != null) {\n+                    if (sendToTarget(t)) {\n+                        ++emittedCount;\n+                    }\n+                }\n+                if (releaseEmittingLock()) {\n+                    break;\n+                }\n+            }\n+\n+            if (emittedCount != 0) {\n+                tryRequestMore();\n+            }\n+        }\n+\n+        private boolean sendToTarget(Object item) {\n+            if (targetTerminated) {\n+                // No notifications past terminal/cancelled\n+                return false;\n+            }\n+            if (item instanceof TerminalNotification) {\n+                targetTerminated = true;\n+                // Load the terminal notification in case an error happened after an onComplete and we override the\n+                // terminal value.\n+                TerminalNotification terminalNotification = this.terminalNotification;\n+                assert terminalNotification != null;\n+                CompositeException de = this.delayedError;\n+                if (de != null) {\n+                    de.addAllPendingSuppressed();\n+                    if (terminalNotification.cause() == de) {\n+                        terminalNotification.terminate(target);\n+                    } else {\n+                        terminalNotification.terminate(target, de);\n+                    }\n+                } else {\n+                    terminalNotification.terminate(target);\n+                }\n+                return false;\n+            }\n+            @SuppressWarnings(\"unchecked\")\n+            final R rItem = item == NULL_TOKEN ? null : (R) item;\n+            target.onNext(rItem);\n+            return true;\n+        }\n+\n+        private boolean acquireTryRequestMoreLock() {\n+            return acquirePendingLock(tryRequestMoreLockUpdater, this);\n+        }\n+\n+        private boolean releaseTryRequestMoreLock() {\n+            return releasePendingLock(tryRequestMoreLockUpdater, this);\n+        }\n+\n+        private void tryRequestMore(FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (acquireTryRequestMoreLock()) {\n+                try {\n+                    final long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                    if (availableRequestN != 0) {\n+                        final int consumedRequestN = subscriber.requestFromUpstream(\n+                                (int) min(source.maxMappedDemand, availableRequestN));\n+                        assert availableRequestN >= consumedRequestN;\n+                        if (consumedRequestN != availableRequestN) {\n+                            giveBackRequestN(availableRequestN - consumedRequestN);\n+                        }\n+                    }\n+                } finally {\n+                    if (!releaseTryRequestMoreLock()) {\n+                        tryRequestMore();\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void tryRequestMore() {\n+            Throwable delayedCause = null;\n+            for (;;) {\n+                if (!acquireTryRequestMoreLock()) {\n+                    break;\n+                }\n+\n+                try {\n+                    final long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                    if (availableRequestN != 0) {\n+                        long remainingRequestN = availableRequestN;\n+                        Iterator<FlatMapPublisherSubscriber<T, R>> itr = subscribers.iterator();\n+                        while (itr.hasNext() && remainingRequestN > 0) {\n+                            remainingRequestN -= itr.next().requestFromUpstream(\n+                                    (int) Math.min(source.maxMappedDemand, remainingRequestN));\n+                        }\n+\n+                        assert availableRequestN >= remainingRequestN && remainingRequestN >= 0;\n+                        if (remainingRequestN > 0) {\n+                            giveBackRequestN(remainingRequestN);\n+                        }\n+                    }\n+                } catch (Throwable cause) {\n+                    if (delayedCause == null) {\n+                        delayedCause = cause;\n+                    }\n+                }\n+                if (releaseTryRequestMoreLock()) {", "originalCommit": "be25d527238e4859836a399a243c7b82ea148854", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQzODcxNg==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r408438716", "bodyText": "+1 I'll put in a finally", "author": "Scottmitch", "createdAt": "2020-04-14T21:12:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM3OTAwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM3OTI2NA==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r408379264", "bodyText": "does this need to be public ?", "author": "normanmaurer", "createdAt": "2020-04-14T19:23:31Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,681 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.EmptySubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Iterator;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.NULL_TOKEN;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.acquirePendingLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releasePendingLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> tryRequestMoreLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"tryRequestMoreLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int tryRequestMoreLock;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile long pendingDemand;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+\n+        /**\n+         * This variable is only accessed within the \"emitting lock\" so we rely upon this to provide visibility to\n+         * other threads.\n+         */\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> pending;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            pending = newUnboundedMpscQueue(min(2, source.maxConcurrency));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                pendingDemandUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtection);\n+                tryRequestMore();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            // Currently we always request maxConcurrency elements from upstream.\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            if (subscribers.add(subscriber)) {\n+                for (;;) {\n+                    final int prevActiveMappedSources = activeMappedSources;\n+                    if (prevActiveMappedSources < 0) {\n+                        // We have been cancelled, so in this case we don't want to Subscribe and instead\n+                        // just want to discard the Publisher.\n+                        subscribers.remove(subscriber);\n+                        break;\n+                    } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveMappedSources,\n+                            prevActiveMappedSources + 1)) {\n+                        publisher.subscribeInternal(subscriber);\n+                        tryRequestMore(subscriber);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            Throwable delayedCause = null;\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                for (FlatMapPublisherSubscriber<T, R> subscriber : subscribers) {\n+                    try {\n+                        subscriber.cancelFromUpstream();\n+                    } catch (Throwable c) {\n+                        if (delayedCause == null) {\n+                            delayedCause = c;\n+                        }\n+                    }\n+                }\n+                subscribers.clear();\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            if (!pending.offer(item)) {\n+                enqueueAndDrainFail(item);\n+            }\n+            drainPending();\n+        }\n+\n+        private void enqueueAndDrainFail(Object item) {\n+            QueueFullException exception = new QueueFullException(\"pending\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, true, true);\n+            }\n+        }\n+\n+        private boolean acquireEmittingLock() {\n+            return acquirePendingLock(emittingLockUpdater, this);\n+        }\n+\n+        private boolean releaseEmittingLock() {\n+            return releasePendingLock(emittingLockUpdater, this);\n+        }\n+\n+        private void drainPending() {\n+            long emittedCount = 0;\n+            for (;;) {\n+                if (!acquireEmittingLock()) {\n+                    break;\n+                }\n+                Object t;\n+                while ((t = pending.poll()) != null) {\n+                    if (sendToTarget(t)) {\n+                        ++emittedCount;\n+                    }\n+                }\n+                if (releaseEmittingLock()) {\n+                    break;\n+                }\n+            }\n+\n+            if (emittedCount != 0) {\n+                tryRequestMore();\n+            }\n+        }\n+\n+        private boolean sendToTarget(Object item) {\n+            if (targetTerminated) {\n+                // No notifications past terminal/cancelled\n+                return false;\n+            }\n+            if (item instanceof TerminalNotification) {\n+                targetTerminated = true;\n+                // Load the terminal notification in case an error happened after an onComplete and we override the\n+                // terminal value.\n+                TerminalNotification terminalNotification = this.terminalNotification;\n+                assert terminalNotification != null;\n+                CompositeException de = this.delayedError;\n+                if (de != null) {\n+                    de.addAllPendingSuppressed();\n+                    if (terminalNotification.cause() == de) {\n+                        terminalNotification.terminate(target);\n+                    } else {\n+                        terminalNotification.terminate(target, de);\n+                    }\n+                } else {\n+                    terminalNotification.terminate(target);\n+                }\n+                return false;\n+            }\n+            @SuppressWarnings(\"unchecked\")\n+            final R rItem = item == NULL_TOKEN ? null : (R) item;\n+            target.onNext(rItem);\n+            return true;\n+        }\n+\n+        private boolean acquireTryRequestMoreLock() {\n+            return acquirePendingLock(tryRequestMoreLockUpdater, this);\n+        }\n+\n+        private boolean releaseTryRequestMoreLock() {\n+            return releasePendingLock(tryRequestMoreLockUpdater, this);\n+        }\n+\n+        private void tryRequestMore(FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (acquireTryRequestMoreLock()) {\n+                try {\n+                    final long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                    if (availableRequestN != 0) {\n+                        final int consumedRequestN = subscriber.requestFromUpstream(\n+                                (int) min(source.maxMappedDemand, availableRequestN));\n+                        assert availableRequestN >= consumedRequestN;\n+                        if (consumedRequestN != availableRequestN) {\n+                            giveBackRequestN(availableRequestN - consumedRequestN);\n+                        }\n+                    }\n+                } finally {\n+                    if (!releaseTryRequestMoreLock()) {\n+                        tryRequestMore();\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void tryRequestMore() {\n+            Throwable delayedCause = null;\n+            for (;;) {\n+                if (!acquireTryRequestMoreLock()) {\n+                    break;\n+                }\n+\n+                try {\n+                    final long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                    if (availableRequestN != 0) {\n+                        long remainingRequestN = availableRequestN;\n+                        Iterator<FlatMapPublisherSubscriber<T, R>> itr = subscribers.iterator();\n+                        while (itr.hasNext() && remainingRequestN > 0) {\n+                            remainingRequestN -= itr.next().requestFromUpstream(\n+                                    (int) Math.min(source.maxMappedDemand, remainingRequestN));\n+                        }\n+\n+                        assert availableRequestN >= remainingRequestN && remainingRequestN >= 0;\n+                        if (remainingRequestN > 0) {\n+                            giveBackRequestN(remainingRequestN);\n+                        }\n+                    }\n+                } catch (Throwable cause) {\n+                    if (delayedCause == null) {\n+                        delayedCause = cause;\n+                    }\n+                }\n+                if (releaseTryRequestMoreLock()) {\n+                    break;\n+                }\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void giveBackRequestN(final long delta) {\n+            pendingDemandUpdater.addAndGet(this, delta);\n+        }\n+\n+        private boolean terminateActiveMappedSources() {\n+            for (;;) {\n+                final int prevActiveMappedSources = activeMappedSources;\n+                // Should always be >= 0, but just in case there is a bug in user code that results in multiple terminal\n+                // events we avoid corrupting our internal state.\n+                if (prevActiveMappedSources < 0 || activeMappedSourcesUpdater.compareAndSet(this,\n+                        prevActiveMappedSources, -prevActiveMappedSources)) {\n+                    return prevActiveMappedSources == 0;\n+                }\n+            }\n+        }\n+\n+        private boolean decrementActiveMappedSources() {\n+            for (;;) {\n+                final int prevActivePublishers = activeMappedSources;\n+                assert prevActivePublishers != 0;\n+                if (prevActivePublishers > 0) {\n+                    if (activeMappedSourcesUpdater.compareAndSet(this, prevActivePublishers,\n+                            prevActivePublishers - 1)) {\n+                        return false;\n+                    }\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActivePublishers,\n+                        prevActivePublishers + 1)) {\n+                    return prevActivePublishers == -1;\n+                }\n+            }\n+        }\n+\n+        private boolean removeSubscriber(final FlatMapPublisherSubscriber<T, R> subscriber,\n+                                         final long requestNGiveBack) {\n+            if (subscribers.remove(subscriber)) {\n+                if (decrementActiveMappedSources()) {\n+                    return true;\n+                }\n+\n+                assert subscription != null;\n+                subscription.request(1);\n+\n+                if (requestNGiveBack > 0) {\n+                    giveBackRequestN(requestNGiveBack);\n+                    tryRequestMore();\n+                }\n+            }\n+            return false;\n+        }\n+\n+        public static final class FlatMapPublisherSubscriber<T, R> implements Subscriber<R> {", "originalCommit": "be25d527238e4859836a399a243c7b82ea148854", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQzODM4OA==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r408438388", "bodyText": "no, good catch!", "author": "Scottmitch", "createdAt": "2020-04-14T21:12:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM3OTI2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ0NDY0NQ==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r408444645", "bodyText": "a key part to understanding the approach is as follows:\nthere is no queuing of signals for the purpose of managing excess demand [1]. instead the demand from downstream is carefully distributed to all mapped publishers. the \"careful\" part means that we need to be able to reclaim demand from mapped publishers when they terminated or are cancelled, otherwise we may deadlock due to not delivering data that was requested. bcz we need to reclaim demand upon cancellation we need to be sure there is no data delivered after this point (to avoid delivering too much data). So the subscription lock provides that coordination and makes sure we only deliver what we are allowed, and give it all back when we terminate/cancel.\n[1] there is an internal queue to manage concurrency requirements of ReactiveStreams (e.g. no concurrent delivery on a Subscriber, this is the same approach taken in Publisher#flatMapMergeSingle)", "author": "Scottmitch", "createdAt": "2020-04-14T21:24:19Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,675 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.EmptySubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Iterator;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.NULL_TOKEN;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.acquirePendingLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releasePendingLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> tryRequestMoreLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"tryRequestMoreLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int tryRequestMoreLock;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile long pendingDemand;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+\n+        /**\n+         * This variable is only accessed within the \"emitting lock\" so we rely upon this to provide visibility to\n+         * other threads.\n+         */\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> pending;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            pending = newUnboundedMpscQueue(min(2, source.maxConcurrency));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                pendingDemandUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtection);\n+                tryRequestMore();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            // Currently we always request maxConcurrency elements from upstream.\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            if (subscribers.add(subscriber)) {\n+                for (;;) {\n+                    final int prevActiveMappedSources = activeMappedSources;\n+                    if (prevActiveMappedSources < 0) {\n+                        // We have been cancelled, so in this case we don't want to Subscribe and instead\n+                        // just want to discard the Publisher.\n+                        subscribers.remove(subscriber);\n+                        break;\n+                    } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveMappedSources,\n+                            prevActiveMappedSources + 1)) {\n+                        publisher.subscribeInternal(subscriber);\n+                        tryRequestMore(subscriber);\n+                        break;\n+                    }\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected failure adding to subscriber Set\");\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            Throwable delayedCause = null;\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                for (FlatMapPublisherSubscriber<T, R> subscriber : subscribers) {\n+                    try {\n+                        subscriber.cancelFromUpstream();\n+                    } catch (Throwable c) {\n+                        if (delayedCause == null) {\n+                            delayedCause = c;\n+                        }\n+                    }\n+                }\n+                subscribers.clear();\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            if (!pending.offer(item)) {\n+                enqueueAndDrainFail(item);\n+            }\n+            drainPending();\n+        }\n+\n+        private void enqueueAndDrainFail(Object item) {\n+            QueueFullException exception = new QueueFullException(\"pending\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, true, true);\n+            }\n+        }\n+\n+        private void drainPending() {\n+            long emittedCount = 0;\n+            Throwable delayedCause = null;\n+            while (acquirePendingLock(emittingLockUpdater, this)) {\n+                try {\n+                    Object t;\n+                    while ((t = pending.poll()) != null) {\n+                        try {\n+                            if (sendToTarget(t)) {\n+                                ++emittedCount;\n+                            }\n+                        } catch (Throwable cause) {\n+                            if (delayedCause == null) {\n+                                delayedCause = cause;\n+                            }\n+                        }\n+                    }\n+                } finally {\n+                    if (releasePendingLock(emittingLockUpdater, this)) {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            if (emittedCount != 0) {\n+                tryRequestMore();\n+            }\n+\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private boolean sendToTarget(Object item) {\n+            if (targetTerminated) {\n+                // No notifications past terminal/cancelled\n+                return false;\n+            }\n+            if (item instanceof TerminalNotification) {\n+                targetTerminated = true;\n+                // Load the terminal notification in case an error happened after an onComplete and we override the\n+                // terminal value.\n+                TerminalNotification terminalNotification = this.terminalNotification;\n+                assert terminalNotification != null;\n+                CompositeException de = this.delayedError;\n+                if (de != null) {\n+                    de.addAllPendingSuppressed();\n+                    if (terminalNotification.cause() == de) {\n+                        terminalNotification.terminate(target);\n+                    } else {\n+                        terminalNotification.terminate(target, de);\n+                    }\n+                } else {\n+                    terminalNotification.terminate(target);\n+                }\n+                return false;\n+            }\n+            @SuppressWarnings(\"unchecked\")\n+            final R rItem = item == NULL_TOKEN ? null : (R) item;\n+            target.onNext(rItem);\n+            return true;\n+        }\n+\n+        private void tryRequestMore(FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (acquirePendingLock(tryRequestMoreLockUpdater, this)) {\n+                try {\n+                    final long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                    if (availableRequestN != 0) {\n+                        final int consumedRequestN = subscriber.requestFromUpstream(\n+                                (int) min(source.maxMappedDemand, availableRequestN));\n+                        assert availableRequestN >= consumedRequestN;\n+                        if (consumedRequestN != availableRequestN) {\n+                            giveBackRequestN(availableRequestN - consumedRequestN);\n+                        }\n+                    }\n+                } finally {\n+                    if (!releasePendingLock(tryRequestMoreLockUpdater, this)) {\n+                        tryRequestMore();\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void tryRequestMore() {\n+            Throwable delayedCause = null;\n+            while (acquirePendingLock(tryRequestMoreLockUpdater, this)) {\n+                try {\n+                    final long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                    if (availableRequestN != 0) {\n+                        long remainingRequestN = availableRequestN;\n+                        Iterator<FlatMapPublisherSubscriber<T, R>> itr = subscribers.iterator();\n+                        while (itr.hasNext() && remainingRequestN > 0) {\n+                            remainingRequestN -= itr.next().requestFromUpstream(\n+                                    (int) Math.min(source.maxMappedDemand, remainingRequestN));\n+                        }\n+\n+                        assert availableRequestN >= remainingRequestN && remainingRequestN >= 0;\n+                        if (remainingRequestN > 0) {\n+                            giveBackRequestN(remainingRequestN);\n+                        }\n+                    }\n+                } catch (Throwable cause) {\n+                    if (delayedCause == null) {\n+                        delayedCause = cause;\n+                    }\n+                } finally {\n+                    if (releasePendingLock(tryRequestMoreLockUpdater, this)) {\n+                        break;\n+                    }\n+                }\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void giveBackRequestN(final long delta) {\n+            pendingDemandUpdater.addAndGet(this, delta);\n+        }\n+\n+        private boolean terminateActiveMappedSources() {\n+            for (;;) {\n+                final int prevActiveMappedSources = activeMappedSources;\n+                // Should always be >= 0, but just in case there is a bug in user code that results in multiple terminal\n+                // events we avoid corrupting our internal state.\n+                if (prevActiveMappedSources < 0 || activeMappedSourcesUpdater.compareAndSet(this,\n+                        prevActiveMappedSources, -prevActiveMappedSources)) {\n+                    return prevActiveMappedSources == 0;\n+                }\n+            }\n+        }\n+\n+        private boolean decrementActiveMappedSources() {\n+            for (;;) {\n+                final int prevActivePublishers = activeMappedSources;\n+                assert prevActivePublishers != 0;\n+                if (prevActivePublishers > 0) {\n+                    if (activeMappedSourcesUpdater.compareAndSet(this, prevActivePublishers,\n+                            prevActivePublishers - 1)) {\n+                        return false;\n+                    }\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActivePublishers,\n+                        prevActivePublishers + 1)) {\n+                    return prevActivePublishers == -1;\n+                }\n+            }\n+        }\n+\n+        private boolean removeSubscriber(final FlatMapPublisherSubscriber<T, R> subscriber,\n+                                         final long requestNGiveBack) {\n+            if (subscribers.remove(subscriber)) {\n+                if (decrementActiveMappedSources()) {\n+                    return true;\n+                }\n+\n+                assert subscription != null;\n+                subscription.request(1);\n+\n+                if (requestNGiveBack > 0) {\n+                    giveBackRequestN(requestNGiveBack);\n+                    tryRequestMore();\n+                }\n+            }\n+            return false;\n+        }\n+\n+        private static final class FlatMapPublisherSubscriber<T, R> implements Subscriber<R> {\n+            private static final Subscription CANCELLED = new EmptySubscription();\n+            private static final Subscription CANCEL_PENDING = new EmptySubscription();\n+            private static final Subscription REQUEST_PENDING = new EmptySubscription();\n+            private static final Subscription PROCESSING_REQUEST = new EmptySubscription();\n+            private static final Subscription PROCESSING_ONNEXT = new EmptySubscription();\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicReferenceFieldUpdater<FlatMapPublisherSubscriber, Subscription>\n+                    subscriptionUpdater = newUpdater(FlatMapPublisherSubscriber.class, Subscription.class,\n+                    \"subscription\");\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicLongFieldUpdater<FlatMapPublisherSubscriber> outstandingDemandUpdater =\n+                    AtomicLongFieldUpdater.newUpdater(FlatMapPublisherSubscriber.class, \"outstandingDemand\");\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicLongFieldUpdater<FlatMapPublisherSubscriber> pendingDemandUpdater =\n+                    AtomicLongFieldUpdater.newUpdater(FlatMapPublisherSubscriber.class, \"pendingDemand\");\n+\n+            private final FlatMapSubscriber<T, R> parent;\n+\n+            @SuppressWarnings(\"unused\")\n+            @Nullable\n+            private volatile Subscription subscription;\n+            private volatile long pendingDemand;\n+            private volatile long outstandingDemand;\n+\n+            FlatMapPublisherSubscriber(FlatMapSubscriber<T, R> parent) {\n+                this.parent = parent;\n+            }\n+\n+            void cancelFromUpstream() {\n+                for (;;) {\n+                    final Subscription prevSubscription = subscription;\n+                    if (prevSubscription == null) {\n+                        if (subscriptionUpdater.compareAndSet(this, null, CANCELLED)) {\n+                            break;\n+                        }\n+                    } else if (prevSubscription == CANCELLED || prevSubscription == CANCEL_PENDING) {\n+                        break;\n+                    } else if (prevSubscription == PROCESSING_ONNEXT || prevSubscription == PROCESSING_REQUEST) {\n+                        if (subscriptionUpdater.compareAndSet(this, prevSubscription, CANCEL_PENDING)) {\n+                            break;\n+                        }\n+                    } else if (subscriptionUpdater.compareAndSet(this, prevSubscription, CANCELLED)) {\n+                        cancelAndGiveBack(prevSubscription);\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            int requestFromUpstream(final int n) {\n+                for (;;) {\n+                    final long prevOutstandingDemand = outstandingDemand;\n+                    if (prevOutstandingDemand < 0) {\n+                        return 0; // we have already been cancelled, or terminated\n+                    }\n+                    final int quotaToUse = (int) min(Long.MAX_VALUE - prevOutstandingDemand,\n+                            min(parent.source.maxMappedDemand - prevOutstandingDemand, n));\n+                    if (quotaToUse == 0) {\n+                        if (outstandingDemandUpdater.compareAndSet(this, prevOutstandingDemand,\n+                                prevOutstandingDemand)) {\n+                            return 0;\n+                        }\n+                    } else if (outstandingDemandUpdater.compareAndSet(this, prevOutstandingDemand,\n+                            prevOutstandingDemand + quotaToUse)) {\n+                        pendingDemandUpdater.addAndGet(this, quotaToUse);\n+                        for (;;) {\n+                            final Subscription prevSubscription = subscription;\n+                            if (prevSubscription == null) {\n+                                if (subscriptionUpdater.compareAndSet(this, null, REQUEST_PENDING)) {\n+                                    break;\n+                                }\n+                            } else if (prevSubscription == CANCELLED || prevSubscription == CANCEL_PENDING) {\n+                                break;\n+                            } else if (prevSubscription == REQUEST_PENDING || prevSubscription == PROCESSING_ONNEXT ||\n+                                    prevSubscription == PROCESSING_REQUEST) {\n+                                if (subscriptionUpdater.compareAndSet(this, prevSubscription, REQUEST_PENDING)) {\n+                                    break;\n+                                }\n+                            } else if (subscriptionUpdater.compareAndSet(this, prevSubscription, PROCESSING_REQUEST)) {\n+                                doRequestMore(prevSubscription);\n+                                break;\n+                            }\n+                        }\n+                        return quotaToUse;\n+                    }\n+                }\n+            }\n+\n+            private void doRequestMore(Subscription prevSubscription) {\n+                long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                for (;;) {\n+                    if (availableRequestN > 0) {\n+                        try {\n+                            prevSubscription.request(availableRequestN);\n+                        } catch (Throwable cause) {\n+                            subscription = CANCELLED;\n+                            cancelAndGiveBack(prevSubscription);\n+                            throw cause;\n+                        }\n+                    }\n+\n+                    final Subscription afterLockSubscription = subscription;\n+                    if (afterLockSubscription == PROCESSING_ONNEXT || afterLockSubscription == CANCELLED) {\n+                        // onNext is allowed to interrupt, and will handle any pending cancel/request events\n+                        // after it completes (otherwise we may drop signals).\n+                        break;\n+                    } else if (afterLockSubscription == CANCEL_PENDING) {\n+                        subscription = CANCELLED;\n+                        cancelAndGiveBack(prevSubscription);\n+                        break;\n+                    } else if (afterLockSubscription == REQUEST_PENDING) {\n+                        if (subscriptionUpdater.compareAndSet(this, REQUEST_PENDING, PROCESSING_REQUEST)) {\n+                            availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                            // continue through next iteration to try to unlock\n+                        }\n+                    } else if (afterLockSubscription == PROCESSING_REQUEST &&\n+                            subscriptionUpdater.compareAndSet(this, PROCESSING_REQUEST, prevSubscription)) {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            private void cancelAndGiveBack(Subscription subscription) {\n+                try {\n+                    subscription.cancel();\n+                } finally {\n+                    giveBackUnusedRequestN();\n+                }\n+            }\n+\n+            private boolean giveBackUnusedRequestN() {\n+                // we need to give back the outstanding amount that has been requested, but not emitted.\n+                // resetting sourceRequestedUpdater must happen unconditionally first, as this stops\n+                // calculateSourceRequested from attempting to request any more.\n+                final long prevOutstandingDemand = outstandingDemandUpdater.getAndSet(this, -1);\n+                return prevOutstandingDemand >= 0 && parent.removeSubscriber(this, prevOutstandingDemand);\n+            }\n+\n+            @Override\n+            public void onSubscribe(final Subscription s) {\n+                for (;;) {\n+                    final Subscription prevSubscription = subscription;\n+                    assert prevSubscription != CANCEL_PENDING && prevSubscription != PROCESSING_ONNEXT &&\n+                            prevSubscription != PROCESSING_REQUEST;\n+                    if (prevSubscription == null) {\n+                        if (subscriptionUpdater.compareAndSet(this, null, s)) {\n+                            break;\n+                        }\n+                    } else if (prevSubscription == REQUEST_PENDING) {\n+                        if (subscriptionUpdater.compareAndSet(this, REQUEST_PENDING, PROCESSING_REQUEST)) {\n+                            doRequestMore(s);\n+                            break;\n+                        }\n+                    } else {\n+                        s.cancel(); // already cancelled or duplicate onSubscribe\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void onNext(@Nullable final R r) {\n+                boolean acquiredLock = false;\n+                for (;;) {\n+                    Subscription prevSubscription = subscription;\n+                    assert prevSubscription != null;\n+                    if (prevSubscription == CANCELLED || prevSubscription == CANCEL_PENDING) {\n+                        // we have already given our undelivered requestN quota up, or will after we unroll process\n+                        // onNext. we are not allowed to deliver more data or else we may violate upstream's requestN.\n+                        break;\n+                    } else if (prevSubscription == PROCESSING_ONNEXT ||\n+                            (acquiredLock = subscriptionUpdater.compareAndSet(this,", "originalCommit": "2d533c935383e063a6217ff7cb2d893d6b3abd9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMzNzM1Mg==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r409337352", "bodyText": "consider adding this as a comment in the code-base.", "author": "normanmaurer", "createdAt": "2020-04-16T07:25:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ0NDY0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk4MTkzNA==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r409981934", "bodyText": "agreed \ud83c\udf7b . I added it to the class level comments.", "author": "Scottmitch", "createdAt": "2020-04-17T04:10:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ0NDY0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMzNDAzMQ==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r409334031", "bodyText": "nit: in other places you always start with an uppercase letter while here you dont.", "author": "normanmaurer", "createdAt": "2020-04-16T07:19:25Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Publisher.java", "diffHunk": "@@ -187,6 +187,72 @@ protected Publisher() {\n         return new ResumePublisher<>(this, nextFactory, executor);\n     }\n \n+    /**\n+     * Each element of this {@link Publisher} is mapped into a {@link Publisher} (potentially of a different type) and\n+     * flatten all signals emitted from each mapped {@link Publisher} into the returned {@link Publisher}.\n+     * <pre>{@code\n+     *     ExecutorService e = ...;\n+     *     List<Future<List<R>>> futures = ...; // assume this is thread safe\n+     *     for (T t : resultOfThisPublisher()) {\n+     *         // Note that flatMap process results in parallel.\n+     *         futures.add(e.submit(() -> {\n+     *             return mapper.apply(t); // Asynchronous result is flatten into a value by this operator.\n+     *         }));\n+     *     }\n+     *     List<R> results = new ArrayList<>(futures.size());\n+     *     // This is an approximation, this operator does not provide any ordering guarantees for the results.\n+     *     for (Future<List<R>> future : futures) {\n+     *         List<R> rList = future.get(); // Throws if the processing for this item failed.\n+     *         results.addAll(rList);\n+     *     }\n+     *     return results;\n+     * }</pre>\n+     * @param mapper Convert each item emitted by this {@link Publisher} into another {@link Publisher}.\n+     * each mapped {@link Publisher}.\n+     * @param <R> The type of mapped {@link Publisher}.\n+     * @return A new {@link Publisher} which flattens the emissions from all mapped {@link Publisher}s.\n+     * @see <a href=\"http://reactivex.io/documentation/operators/flatmap.html\">ReactiveX flatMap operator.</a>\n+     */\n+    public final <R> Publisher<R> flatMapMerge(Function<? super T, ? extends Publisher<? extends R>> mapper) {\n+        return flatMapMerge(mapper, false, 16, 64);\n+    }\n+\n+    /**\n+     * Each element of this {@link Publisher} is mapped into a {@link Publisher} (potentially of a different type) and\n+     * flatten all signals emitted from each mapped {@link Publisher} into the returned {@link Publisher}.\n+     * <pre>{@code\n+     *     ExecutorService e = ...;\n+     *     List<Future<List<R>>> futures = ...; // assume this is thread safe\n+     *     for (T t : resultOfThisPublisher()) {\n+     *         // Note that flatMap process results in parallel.\n+     *         futures.add(e.submit(() -> {\n+     *             return mapper.apply(t); // Asynchronous result is flatten into a value by this operator.\n+     *         }));\n+     *     }\n+     *     List<R> results = new ArrayList<>(futures.size());\n+     *     // This is an approximation, this operator does not provide any ordering guarantees for the results.\n+     *     for (Future<List<R>> future : futures) {\n+     *         List<R> rList = future.get(); // Throws if the processing for this item failed.\n+     *         results.addAll(rList);\n+     *     }\n+     *     return results;\n+     * }</pre>\n+     * @param mapper Convert each item emitted by this {@link Publisher} into another {@link Publisher}.\n+     * @param delayError {@code false} if the returned {@link Publisher} should fail as soon as any of the mapped\n+     * {@link Publisher}s fail. {@code true} to wait until this {@link Publisher} terminates to emit any failures from\n+     * the mapped {@link Publisher}s.\n+     * @param maxConcurrency maximum amount of outstanding upstream {@link Subscription#request(long) demand}.\n+     * @param maxMappedDemandHint hint for the maximum amount of {@link Subscription#request(long) demand} for", "originalCommit": "fee3ceaeffb739c1db2c399a5c5a8a3697f6f8be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQwNTM2OQ==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r410405369", "bodyText": "done", "author": "Scottmitch", "createdAt": "2020-04-17T18:43:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMzNDAzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE2MDkwNg==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r410160906", "bodyText": "nit: you could remove the else", "author": "normanmaurer", "createdAt": "2020-04-17T11:25:15Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.EmptySubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Iterator;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.NULL_TOKEN;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.acquirePendingLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releasePendingLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * This flatMap implementation doesn't rely upon queuing to manage demand. Instead it leases out demand quota\n+ * (capped by {@link #maxMappedDemand}) mapped {@link Publisher}s and reclaims any unused quota when each mapped\n+ * {@link Publisher} is terminated or cancelled. {@link FlatMapSubscriber.FlatMapPublisherSubscriber} carefully manages\n+ * outstanding demand to ensure when quota is reclaimed there are no subsequent\n+ * {@link Subscriber#onNext(Object) signals} to avoid returning inaccurate amounts which would otherwise result in\n+ * deadlock (under delivering {@link Subscriber#onNext(Object) signals}) or violation of\n+ * <a href=\"https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#1.1\">Reactive Streams\n+ * Specification</a> (over delivering {@link Subscriber#onNext(Object) signals}) to the downstream {@link Subscriber}.\n+ *\n+ * @param <T> Type of original {@link Publisher}.\n+ * @param <R> Type of {@link Publisher} returned by the operator.\n+ */\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> tryRequestMoreLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"tryRequestMoreLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int tryRequestMoreLock;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile long pendingDemand;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+\n+        /**\n+         * This variable is only accessed within the \"emitting lock\" so we rely upon this to provide visibility to\n+         * other threads.\n+         */\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> pending;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            pending = newUnboundedMpscQueue(min(2, source.maxConcurrency));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                pendingDemandUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtection);\n+                tryRequestMore();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            // Currently we always request maxConcurrency elements from upstream.\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            final boolean added = subscribers.add(subscriber);\n+            assert added; // FlatMapPublisherSubscriber relies upon object equality and should never fail.\n+            for (;;) {\n+                final int prevActiveMappedSources = activeMappedSources;\n+                if (prevActiveMappedSources < 0) {\n+                    // We have been cancelled, so in this case we don't want to Subscribe and instead\n+                    // just want to discard the Publisher.\n+                    subscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveMappedSources,\n+                        prevActiveMappedSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    tryRequestMore(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            Throwable delayedCause = null;\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                for (FlatMapPublisherSubscriber<T, R> subscriber : subscribers) {\n+                    try {\n+                        subscriber.cancelFromUpstream();\n+                    } catch (Throwable c) {\n+                        if (delayedCause == null) {\n+                            delayedCause = c;\n+                        }\n+                    }\n+                }\n+                subscribers.clear();\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            if (!pending.offer(item)) {\n+                enqueueAndDrainFail(item);\n+            }\n+            drainPending();\n+        }\n+\n+        private void enqueueAndDrainFail(Object item) {\n+            QueueFullException exception = new QueueFullException(\"pending\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, true, true);\n+            }\n+        }\n+\n+        @SuppressWarnings(\"ContinueOrBreakFromFinallyBlock\")\n+        private void drainPending() {\n+            long emittedCount = 0;\n+            Throwable delayedCause = null;\n+            while (acquirePendingLock(emittingLockUpdater, this)) {\n+                try {\n+                    Object t;\n+                    while ((t = pending.poll()) != null) {\n+                        try {\n+                            if (sendToTarget(t)) {\n+                                ++emittedCount;\n+                            }\n+                        } catch (Throwable cause) {\n+                            if (delayedCause == null) {\n+                                delayedCause = cause;\n+                            }\n+                        }\n+                    }\n+                } finally {\n+                    if (releasePendingLock(emittingLockUpdater, this)) {\n+                        // break in finally isn't ideal but we catch Throwable above so we won't modify exception\n+                        // control flow. Also if we didn't catch Throwable and attempt to req-acquire the lock would be\n+                        // poisoned as the owner needs to re-acquire as long as release fails.\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            if (emittedCount != 0) {\n+                tryRequestMore();\n+            }\n+\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private boolean sendToTarget(Object item) {\n+            if (targetTerminated) {\n+                // No notifications past terminal/cancelled\n+                return false;\n+            }\n+            if (item instanceof TerminalNotification) {\n+                targetTerminated = true;\n+                // Load the terminal notification in case an error happened after an onComplete and we override the\n+                // terminal value.\n+                TerminalNotification terminalNotification = this.terminalNotification;\n+                assert terminalNotification != null;\n+                CompositeException de = this.delayedError;\n+                if (de != null) {\n+                    de.addAllPendingSuppressed();\n+                    if (terminalNotification.cause() == de) {\n+                        terminalNotification.terminate(target);\n+                    } else {\n+                        terminalNotification.terminate(target, de);\n+                    }\n+                } else {\n+                    terminalNotification.terminate(target);\n+                }\n+                return false;\n+            }\n+            @SuppressWarnings(\"unchecked\")\n+            final R rItem = item == NULL_TOKEN ? null : (R) item;\n+            target.onNext(rItem);\n+            return true;\n+        }\n+\n+        private void tryRequestMore(FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (acquirePendingLock(tryRequestMoreLockUpdater, this)) {\n+                try {\n+                    final long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                    if (availableRequestN != 0) {\n+                        final int consumedRequestN = subscriber.requestFromUpstream(\n+                                (int) min(source.maxMappedDemand, availableRequestN));\n+                        assert availableRequestN >= consumedRequestN;\n+                        if (consumedRequestN != availableRequestN) {\n+                            giveBackRequestN(availableRequestN - consumedRequestN);\n+                        }\n+                    }\n+                } finally {\n+                    if (!releasePendingLock(tryRequestMoreLockUpdater, this)) {\n+                        tryRequestMore();\n+                    }\n+                }\n+            }\n+        }\n+\n+        @SuppressWarnings(\"ContinueOrBreakFromFinallyBlock\")\n+        private void tryRequestMore() {\n+            Throwable delayedCause = null;\n+            while (acquirePendingLock(tryRequestMoreLockUpdater, this)) {\n+                try {\n+                    final long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                    if (availableRequestN != 0) {\n+                        long remainingRequestN = availableRequestN;\n+                        Iterator<FlatMapPublisherSubscriber<T, R>> itr = subscribers.iterator();\n+                        while (itr.hasNext() && remainingRequestN > 0) {\n+                            remainingRequestN -= itr.next().requestFromUpstream(\n+                                    (int) Math.min(source.maxMappedDemand, remainingRequestN));\n+                        }\n+\n+                        assert availableRequestN >= remainingRequestN && remainingRequestN >= 0;\n+                        if (remainingRequestN > 0) {\n+                            giveBackRequestN(remainingRequestN);\n+                        }\n+                    }\n+                } catch (Throwable cause) {\n+                    if (delayedCause == null) {\n+                        delayedCause = cause;\n+                    }\n+                } finally {\n+                    if (releasePendingLock(tryRequestMoreLockUpdater, this)) {\n+                        // break in finally isn't ideal but we catch Throwable above so we won't modify exception\n+                        // control flow. Also if we didn't catch Throwable and attempt to req-acquire the lock would be\n+                        // poisoned as the owner needs to re-acquire as long as release fails.\n+                        break;\n+                    }\n+                }\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void giveBackRequestN(final long delta) {\n+            pendingDemandUpdater.addAndGet(this, delta);\n+        }\n+\n+        private boolean terminateActiveMappedSources() {\n+            for (;;) {\n+                final int prevActiveMappedSources = activeMappedSources;\n+                // Should always be >= 0, but just in case there is a bug in user code that results in multiple terminal\n+                // events we avoid corrupting our internal state.\n+                if (prevActiveMappedSources < 0 || activeMappedSourcesUpdater.compareAndSet(this,\n+                        prevActiveMappedSources, -prevActiveMappedSources)) {\n+                    return prevActiveMappedSources == 0;\n+                }\n+            }\n+        }\n+\n+        private boolean decrementActiveMappedSources() {\n+            for (;;) {\n+                final int prevActivePublishers = activeMappedSources;\n+                assert prevActivePublishers != 0;\n+                if (prevActivePublishers > 0) {\n+                    if (activeMappedSourcesUpdater.compareAndSet(this, prevActivePublishers,\n+                            prevActivePublishers - 1)) {\n+                        return false;\n+                    }\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActivePublishers,\n+                        prevActivePublishers + 1)) {\n+                    return prevActivePublishers == -1;\n+                }\n+            }\n+        }\n+\n+        private boolean removeSubscriber(final FlatMapPublisherSubscriber<T, R> subscriber,\n+                                         final long requestNGiveBack) {\n+            if (subscribers.remove(subscriber)) {\n+                if (decrementActiveMappedSources()) {\n+                    return true;\n+                }\n+\n+                assert subscription != null;\n+                subscription.request(1);\n+\n+                if (requestNGiveBack > 0) {\n+                    giveBackRequestN(requestNGiveBack);\n+                    tryRequestMore();\n+                }\n+            }\n+            return false;\n+        }\n+\n+        private static final class FlatMapPublisherSubscriber<T, R> implements Subscriber<R> {\n+            private static final Subscription CANCELLED = new EmptySubscription();\n+            private static final Subscription CANCEL_PENDING = new EmptySubscription();\n+            private static final Subscription REQUEST_PENDING = new EmptySubscription();\n+            private static final Subscription PROCESSING_REQUEST = new EmptySubscription();\n+            private static final Subscription PROCESSING_ONNEXT = new EmptySubscription();\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicReferenceFieldUpdater<FlatMapPublisherSubscriber, Subscription>\n+                    subscriptionUpdater = newUpdater(FlatMapPublisherSubscriber.class, Subscription.class,\n+                    \"subscription\");\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicLongFieldUpdater<FlatMapPublisherSubscriber> outstandingDemandUpdater =\n+                    AtomicLongFieldUpdater.newUpdater(FlatMapPublisherSubscriber.class, \"outstandingDemand\");\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicLongFieldUpdater<FlatMapPublisherSubscriber> pendingDemandUpdater =\n+                    AtomicLongFieldUpdater.newUpdater(FlatMapPublisherSubscriber.class, \"pendingDemand\");\n+\n+            private final FlatMapSubscriber<T, R> parent;\n+\n+            @SuppressWarnings(\"unused\")\n+            @Nullable\n+            private volatile Subscription subscription;\n+            private volatile long pendingDemand;\n+            private volatile long outstandingDemand;\n+\n+            FlatMapPublisherSubscriber(FlatMapSubscriber<T, R> parent) {\n+                this.parent = parent;\n+            }\n+\n+            void cancelFromUpstream() {\n+                for (;;) {\n+                    final Subscription prevSubscription = subscription;\n+                    if (prevSubscription == null) {\n+                        if (subscriptionUpdater.compareAndSet(this, null, CANCELLED)) {\n+                            break;\n+                        }\n+                    } else if (prevSubscription == CANCELLED || prevSubscription == CANCEL_PENDING) {\n+                        break;\n+                    } else if (prevSubscription == PROCESSING_ONNEXT || prevSubscription == PROCESSING_REQUEST) {\n+                        if (subscriptionUpdater.compareAndSet(this, prevSubscription, CANCEL_PENDING)) {\n+                            break;\n+                        }\n+                    } else if (subscriptionUpdater.compareAndSet(this, prevSubscription, CANCELLED)) {\n+                        cancelAndGiveBack(prevSubscription);\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            int requestFromUpstream(final int n) {\n+                for (;;) {\n+                    final long prevOutstandingDemand = outstandingDemand;\n+                    if (prevOutstandingDemand < 0) {\n+                        return 0; // we have already been cancelled, or terminated\n+                    }\n+                    final int quotaToUse = (int) min(Long.MAX_VALUE - prevOutstandingDemand,\n+                            min(parent.source.maxMappedDemand - prevOutstandingDemand, n));\n+                    if (quotaToUse == 0) {\n+                        if (outstandingDemandUpdater.compareAndSet(this, prevOutstandingDemand,\n+                                prevOutstandingDemand)) {\n+                            return 0;\n+                        }\n+                    } else if (outstandingDemandUpdater.compareAndSet(this, prevOutstandingDemand,\n+                            prevOutstandingDemand + quotaToUse)) {\n+                        pendingDemandUpdater.addAndGet(this, quotaToUse);\n+                        for (;;) {\n+                            final Subscription prevSubscription = subscription;\n+                            if (prevSubscription == null) {\n+                                if (subscriptionUpdater.compareAndSet(this, null, REQUEST_PENDING)) {\n+                                    break;\n+                                }\n+                            } else if (prevSubscription == CANCELLED || prevSubscription == CANCEL_PENDING) {\n+                                break;\n+                            } else if (prevSubscription == REQUEST_PENDING || prevSubscription == PROCESSING_ONNEXT ||\n+                                    prevSubscription == PROCESSING_REQUEST) {\n+                                if (subscriptionUpdater.compareAndSet(this, prevSubscription, REQUEST_PENDING)) {\n+                                    break;\n+                                }\n+                            } else if (subscriptionUpdater.compareAndSet(this, prevSubscription, PROCESSING_REQUEST)) {\n+                                doRequestMore(prevSubscription);\n+                                break;\n+                            }\n+                        }\n+                        return quotaToUse;\n+                    }\n+                }\n+            }\n+\n+            private void doRequestMore(Subscription prevSubscription) {\n+                long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                for (;;) {\n+                    if (availableRequestN > 0) {\n+                        try {\n+                            prevSubscription.request(availableRequestN);\n+                        } catch (Throwable cause) {\n+                            subscription = CANCELLED;\n+                            cancelAndGiveBack(prevSubscription);\n+                            throw cause;\n+                        }\n+                    }\n+\n+                    final Subscription afterLockSubscription = subscription;\n+                    if (afterLockSubscription == PROCESSING_ONNEXT || afterLockSubscription == CANCELLED) {\n+                        // onNext is allowed to interrupt, and will handle any pending cancel/request events\n+                        // after it completes (otherwise we may drop signals).\n+                        break;\n+                    } else if (afterLockSubscription == CANCEL_PENDING) {", "originalCommit": "f1371888e0d42ed60e7c5ce80eb43544b66458e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM2NzUzOQ==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r410367539", "bodyText": "I will keep the else as it clarifies expectations, avoids accidental fall-through issues as code evolves, and keeps code more vertically compact.", "author": "Scottmitch", "createdAt": "2020-04-17T17:29:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE2MDkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE2MTAwOQ==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r410161009", "bodyText": "nit: you could remove the else", "author": "normanmaurer", "createdAt": "2020-04-17T11:25:31Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.EmptySubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Iterator;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.NULL_TOKEN;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.acquirePendingLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releasePendingLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * This flatMap implementation doesn't rely upon queuing to manage demand. Instead it leases out demand quota\n+ * (capped by {@link #maxMappedDemand}) mapped {@link Publisher}s and reclaims any unused quota when each mapped\n+ * {@link Publisher} is terminated or cancelled. {@link FlatMapSubscriber.FlatMapPublisherSubscriber} carefully manages\n+ * outstanding demand to ensure when quota is reclaimed there are no subsequent\n+ * {@link Subscriber#onNext(Object) signals} to avoid returning inaccurate amounts which would otherwise result in\n+ * deadlock (under delivering {@link Subscriber#onNext(Object) signals}) or violation of\n+ * <a href=\"https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#1.1\">Reactive Streams\n+ * Specification</a> (over delivering {@link Subscriber#onNext(Object) signals}) to the downstream {@link Subscriber}.\n+ *\n+ * @param <T> Type of original {@link Publisher}.\n+ * @param <R> Type of {@link Publisher} returned by the operator.\n+ */\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> tryRequestMoreLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"tryRequestMoreLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int tryRequestMoreLock;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile long pendingDemand;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+\n+        /**\n+         * This variable is only accessed within the \"emitting lock\" so we rely upon this to provide visibility to\n+         * other threads.\n+         */\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> pending;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            pending = newUnboundedMpscQueue(min(2, source.maxConcurrency));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                pendingDemandUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtection);\n+                tryRequestMore();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            // Currently we always request maxConcurrency elements from upstream.\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            final boolean added = subscribers.add(subscriber);\n+            assert added; // FlatMapPublisherSubscriber relies upon object equality and should never fail.\n+            for (;;) {\n+                final int prevActiveMappedSources = activeMappedSources;\n+                if (prevActiveMappedSources < 0) {\n+                    // We have been cancelled, so in this case we don't want to Subscribe and instead\n+                    // just want to discard the Publisher.\n+                    subscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveMappedSources,\n+                        prevActiveMappedSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    tryRequestMore(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            Throwable delayedCause = null;\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                for (FlatMapPublisherSubscriber<T, R> subscriber : subscribers) {\n+                    try {\n+                        subscriber.cancelFromUpstream();\n+                    } catch (Throwable c) {\n+                        if (delayedCause == null) {\n+                            delayedCause = c;\n+                        }\n+                    }\n+                }\n+                subscribers.clear();\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            if (!pending.offer(item)) {\n+                enqueueAndDrainFail(item);\n+            }\n+            drainPending();\n+        }\n+\n+        private void enqueueAndDrainFail(Object item) {\n+            QueueFullException exception = new QueueFullException(\"pending\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, true, true);\n+            }\n+        }\n+\n+        @SuppressWarnings(\"ContinueOrBreakFromFinallyBlock\")\n+        private void drainPending() {\n+            long emittedCount = 0;\n+            Throwable delayedCause = null;\n+            while (acquirePendingLock(emittingLockUpdater, this)) {\n+                try {\n+                    Object t;\n+                    while ((t = pending.poll()) != null) {\n+                        try {\n+                            if (sendToTarget(t)) {\n+                                ++emittedCount;\n+                            }\n+                        } catch (Throwable cause) {\n+                            if (delayedCause == null) {\n+                                delayedCause = cause;\n+                            }\n+                        }\n+                    }\n+                } finally {\n+                    if (releasePendingLock(emittingLockUpdater, this)) {\n+                        // break in finally isn't ideal but we catch Throwable above so we won't modify exception\n+                        // control flow. Also if we didn't catch Throwable and attempt to req-acquire the lock would be\n+                        // poisoned as the owner needs to re-acquire as long as release fails.\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            if (emittedCount != 0) {\n+                tryRequestMore();\n+            }\n+\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private boolean sendToTarget(Object item) {\n+            if (targetTerminated) {\n+                // No notifications past terminal/cancelled\n+                return false;\n+            }\n+            if (item instanceof TerminalNotification) {\n+                targetTerminated = true;\n+                // Load the terminal notification in case an error happened after an onComplete and we override the\n+                // terminal value.\n+                TerminalNotification terminalNotification = this.terminalNotification;\n+                assert terminalNotification != null;\n+                CompositeException de = this.delayedError;\n+                if (de != null) {\n+                    de.addAllPendingSuppressed();\n+                    if (terminalNotification.cause() == de) {\n+                        terminalNotification.terminate(target);\n+                    } else {\n+                        terminalNotification.terminate(target, de);\n+                    }\n+                } else {\n+                    terminalNotification.terminate(target);\n+                }\n+                return false;\n+            }\n+            @SuppressWarnings(\"unchecked\")\n+            final R rItem = item == NULL_TOKEN ? null : (R) item;\n+            target.onNext(rItem);\n+            return true;\n+        }\n+\n+        private void tryRequestMore(FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (acquirePendingLock(tryRequestMoreLockUpdater, this)) {\n+                try {\n+                    final long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                    if (availableRequestN != 0) {\n+                        final int consumedRequestN = subscriber.requestFromUpstream(\n+                                (int) min(source.maxMappedDemand, availableRequestN));\n+                        assert availableRequestN >= consumedRequestN;\n+                        if (consumedRequestN != availableRequestN) {\n+                            giveBackRequestN(availableRequestN - consumedRequestN);\n+                        }\n+                    }\n+                } finally {\n+                    if (!releasePendingLock(tryRequestMoreLockUpdater, this)) {\n+                        tryRequestMore();\n+                    }\n+                }\n+            }\n+        }\n+\n+        @SuppressWarnings(\"ContinueOrBreakFromFinallyBlock\")\n+        private void tryRequestMore() {\n+            Throwable delayedCause = null;\n+            while (acquirePendingLock(tryRequestMoreLockUpdater, this)) {\n+                try {\n+                    final long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                    if (availableRequestN != 0) {\n+                        long remainingRequestN = availableRequestN;\n+                        Iterator<FlatMapPublisherSubscriber<T, R>> itr = subscribers.iterator();\n+                        while (itr.hasNext() && remainingRequestN > 0) {\n+                            remainingRequestN -= itr.next().requestFromUpstream(\n+                                    (int) Math.min(source.maxMappedDemand, remainingRequestN));\n+                        }\n+\n+                        assert availableRequestN >= remainingRequestN && remainingRequestN >= 0;\n+                        if (remainingRequestN > 0) {\n+                            giveBackRequestN(remainingRequestN);\n+                        }\n+                    }\n+                } catch (Throwable cause) {\n+                    if (delayedCause == null) {\n+                        delayedCause = cause;\n+                    }\n+                } finally {\n+                    if (releasePendingLock(tryRequestMoreLockUpdater, this)) {\n+                        // break in finally isn't ideal but we catch Throwable above so we won't modify exception\n+                        // control flow. Also if we didn't catch Throwable and attempt to req-acquire the lock would be\n+                        // poisoned as the owner needs to re-acquire as long as release fails.\n+                        break;\n+                    }\n+                }\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void giveBackRequestN(final long delta) {\n+            pendingDemandUpdater.addAndGet(this, delta);\n+        }\n+\n+        private boolean terminateActiveMappedSources() {\n+            for (;;) {\n+                final int prevActiveMappedSources = activeMappedSources;\n+                // Should always be >= 0, but just in case there is a bug in user code that results in multiple terminal\n+                // events we avoid corrupting our internal state.\n+                if (prevActiveMappedSources < 0 || activeMappedSourcesUpdater.compareAndSet(this,\n+                        prevActiveMappedSources, -prevActiveMappedSources)) {\n+                    return prevActiveMappedSources == 0;\n+                }\n+            }\n+        }\n+\n+        private boolean decrementActiveMappedSources() {\n+            for (;;) {\n+                final int prevActivePublishers = activeMappedSources;\n+                assert prevActivePublishers != 0;\n+                if (prevActivePublishers > 0) {\n+                    if (activeMappedSourcesUpdater.compareAndSet(this, prevActivePublishers,\n+                            prevActivePublishers - 1)) {\n+                        return false;\n+                    }\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActivePublishers,\n+                        prevActivePublishers + 1)) {\n+                    return prevActivePublishers == -1;\n+                }\n+            }\n+        }\n+\n+        private boolean removeSubscriber(final FlatMapPublisherSubscriber<T, R> subscriber,\n+                                         final long requestNGiveBack) {\n+            if (subscribers.remove(subscriber)) {\n+                if (decrementActiveMappedSources()) {\n+                    return true;\n+                }\n+\n+                assert subscription != null;\n+                subscription.request(1);\n+\n+                if (requestNGiveBack > 0) {\n+                    giveBackRequestN(requestNGiveBack);\n+                    tryRequestMore();\n+                }\n+            }\n+            return false;\n+        }\n+\n+        private static final class FlatMapPublisherSubscriber<T, R> implements Subscriber<R> {\n+            private static final Subscription CANCELLED = new EmptySubscription();\n+            private static final Subscription CANCEL_PENDING = new EmptySubscription();\n+            private static final Subscription REQUEST_PENDING = new EmptySubscription();\n+            private static final Subscription PROCESSING_REQUEST = new EmptySubscription();\n+            private static final Subscription PROCESSING_ONNEXT = new EmptySubscription();\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicReferenceFieldUpdater<FlatMapPublisherSubscriber, Subscription>\n+                    subscriptionUpdater = newUpdater(FlatMapPublisherSubscriber.class, Subscription.class,\n+                    \"subscription\");\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicLongFieldUpdater<FlatMapPublisherSubscriber> outstandingDemandUpdater =\n+                    AtomicLongFieldUpdater.newUpdater(FlatMapPublisherSubscriber.class, \"outstandingDemand\");\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicLongFieldUpdater<FlatMapPublisherSubscriber> pendingDemandUpdater =\n+                    AtomicLongFieldUpdater.newUpdater(FlatMapPublisherSubscriber.class, \"pendingDemand\");\n+\n+            private final FlatMapSubscriber<T, R> parent;\n+\n+            @SuppressWarnings(\"unused\")\n+            @Nullable\n+            private volatile Subscription subscription;\n+            private volatile long pendingDemand;\n+            private volatile long outstandingDemand;\n+\n+            FlatMapPublisherSubscriber(FlatMapSubscriber<T, R> parent) {\n+                this.parent = parent;\n+            }\n+\n+            void cancelFromUpstream() {\n+                for (;;) {\n+                    final Subscription prevSubscription = subscription;\n+                    if (prevSubscription == null) {\n+                        if (subscriptionUpdater.compareAndSet(this, null, CANCELLED)) {\n+                            break;\n+                        }\n+                    } else if (prevSubscription == CANCELLED || prevSubscription == CANCEL_PENDING) {\n+                        break;\n+                    } else if (prevSubscription == PROCESSING_ONNEXT || prevSubscription == PROCESSING_REQUEST) {\n+                        if (subscriptionUpdater.compareAndSet(this, prevSubscription, CANCEL_PENDING)) {\n+                            break;\n+                        }\n+                    } else if (subscriptionUpdater.compareAndSet(this, prevSubscription, CANCELLED)) {\n+                        cancelAndGiveBack(prevSubscription);\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            int requestFromUpstream(final int n) {\n+                for (;;) {\n+                    final long prevOutstandingDemand = outstandingDemand;\n+                    if (prevOutstandingDemand < 0) {\n+                        return 0; // we have already been cancelled, or terminated\n+                    }\n+                    final int quotaToUse = (int) min(Long.MAX_VALUE - prevOutstandingDemand,\n+                            min(parent.source.maxMappedDemand - prevOutstandingDemand, n));\n+                    if (quotaToUse == 0) {\n+                        if (outstandingDemandUpdater.compareAndSet(this, prevOutstandingDemand,\n+                                prevOutstandingDemand)) {\n+                            return 0;\n+                        }\n+                    } else if (outstandingDemandUpdater.compareAndSet(this, prevOutstandingDemand,\n+                            prevOutstandingDemand + quotaToUse)) {\n+                        pendingDemandUpdater.addAndGet(this, quotaToUse);\n+                        for (;;) {\n+                            final Subscription prevSubscription = subscription;\n+                            if (prevSubscription == null) {\n+                                if (subscriptionUpdater.compareAndSet(this, null, REQUEST_PENDING)) {\n+                                    break;\n+                                }\n+                            } else if (prevSubscription == CANCELLED || prevSubscription == CANCEL_PENDING) {\n+                                break;\n+                            } else if (prevSubscription == REQUEST_PENDING || prevSubscription == PROCESSING_ONNEXT ||\n+                                    prevSubscription == PROCESSING_REQUEST) {\n+                                if (subscriptionUpdater.compareAndSet(this, prevSubscription, REQUEST_PENDING)) {\n+                                    break;\n+                                }\n+                            } else if (subscriptionUpdater.compareAndSet(this, prevSubscription, PROCESSING_REQUEST)) {\n+                                doRequestMore(prevSubscription);\n+                                break;\n+                            }\n+                        }\n+                        return quotaToUse;\n+                    }\n+                }\n+            }\n+\n+            private void doRequestMore(Subscription prevSubscription) {\n+                long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                for (;;) {\n+                    if (availableRequestN > 0) {\n+                        try {\n+                            prevSubscription.request(availableRequestN);\n+                        } catch (Throwable cause) {\n+                            subscription = CANCELLED;\n+                            cancelAndGiveBack(prevSubscription);\n+                            throw cause;\n+                        }\n+                    }\n+\n+                    final Subscription afterLockSubscription = subscription;\n+                    if (afterLockSubscription == PROCESSING_ONNEXT || afterLockSubscription == CANCELLED) {\n+                        // onNext is allowed to interrupt, and will handle any pending cancel/request events\n+                        // after it completes (otherwise we may drop signals).\n+                        break;\n+                    } else if (afterLockSubscription == CANCEL_PENDING) {\n+                        subscription = CANCELLED;\n+                        cancelAndGiveBack(prevSubscription);\n+                        break;\n+                    } else if (afterLockSubscription == REQUEST_PENDING) {", "originalCommit": "f1371888e0d42ed60e7c5ce80eb43544b66458e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM2NzYyMg==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r410367622", "bodyText": "discussed above", "author": "Scottmitch", "createdAt": "2020-04-17T17:29:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE2MTAwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE2MTQ2NA==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r410161464", "bodyText": "nit: define a static field for -1 to make it more clear why this magic number is used.", "author": "normanmaurer", "createdAt": "2020-04-17T11:26:34Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.EmptySubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Iterator;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.NULL_TOKEN;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.acquirePendingLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releasePendingLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * This flatMap implementation doesn't rely upon queuing to manage demand. Instead it leases out demand quota\n+ * (capped by {@link #maxMappedDemand}) mapped {@link Publisher}s and reclaims any unused quota when each mapped\n+ * {@link Publisher} is terminated or cancelled. {@link FlatMapSubscriber.FlatMapPublisherSubscriber} carefully manages\n+ * outstanding demand to ensure when quota is reclaimed there are no subsequent\n+ * {@link Subscriber#onNext(Object) signals} to avoid returning inaccurate amounts which would otherwise result in\n+ * deadlock (under delivering {@link Subscriber#onNext(Object) signals}) or violation of\n+ * <a href=\"https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#1.1\">Reactive Streams\n+ * Specification</a> (over delivering {@link Subscriber#onNext(Object) signals}) to the downstream {@link Subscriber}.\n+ *\n+ * @param <T> Type of original {@link Publisher}.\n+ * @param <R> Type of {@link Publisher} returned by the operator.\n+ */\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> tryRequestMoreLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"tryRequestMoreLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int tryRequestMoreLock;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile long pendingDemand;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+\n+        /**\n+         * This variable is only accessed within the \"emitting lock\" so we rely upon this to provide visibility to\n+         * other threads.\n+         */\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> pending;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            pending = newUnboundedMpscQueue(min(2, source.maxConcurrency));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                pendingDemandUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtection);\n+                tryRequestMore();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            // Currently we always request maxConcurrency elements from upstream.\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            final boolean added = subscribers.add(subscriber);\n+            assert added; // FlatMapPublisherSubscriber relies upon object equality and should never fail.\n+            for (;;) {\n+                final int prevActiveMappedSources = activeMappedSources;\n+                if (prevActiveMappedSources < 0) {\n+                    // We have been cancelled, so in this case we don't want to Subscribe and instead\n+                    // just want to discard the Publisher.\n+                    subscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveMappedSources,\n+                        prevActiveMappedSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    tryRequestMore(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            Throwable delayedCause = null;\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                for (FlatMapPublisherSubscriber<T, R> subscriber : subscribers) {\n+                    try {\n+                        subscriber.cancelFromUpstream();\n+                    } catch (Throwable c) {\n+                        if (delayedCause == null) {\n+                            delayedCause = c;\n+                        }\n+                    }\n+                }\n+                subscribers.clear();\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            if (!pending.offer(item)) {\n+                enqueueAndDrainFail(item);\n+            }\n+            drainPending();\n+        }\n+\n+        private void enqueueAndDrainFail(Object item) {\n+            QueueFullException exception = new QueueFullException(\"pending\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, true, true);\n+            }\n+        }\n+\n+        @SuppressWarnings(\"ContinueOrBreakFromFinallyBlock\")\n+        private void drainPending() {\n+            long emittedCount = 0;\n+            Throwable delayedCause = null;\n+            while (acquirePendingLock(emittingLockUpdater, this)) {\n+                try {\n+                    Object t;\n+                    while ((t = pending.poll()) != null) {\n+                        try {\n+                            if (sendToTarget(t)) {\n+                                ++emittedCount;\n+                            }\n+                        } catch (Throwable cause) {\n+                            if (delayedCause == null) {\n+                                delayedCause = cause;\n+                            }\n+                        }\n+                    }\n+                } finally {\n+                    if (releasePendingLock(emittingLockUpdater, this)) {\n+                        // break in finally isn't ideal but we catch Throwable above so we won't modify exception\n+                        // control flow. Also if we didn't catch Throwable and attempt to req-acquire the lock would be\n+                        // poisoned as the owner needs to re-acquire as long as release fails.\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            if (emittedCount != 0) {\n+                tryRequestMore();\n+            }\n+\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private boolean sendToTarget(Object item) {\n+            if (targetTerminated) {\n+                // No notifications past terminal/cancelled\n+                return false;\n+            }\n+            if (item instanceof TerminalNotification) {\n+                targetTerminated = true;\n+                // Load the terminal notification in case an error happened after an onComplete and we override the\n+                // terminal value.\n+                TerminalNotification terminalNotification = this.terminalNotification;\n+                assert terminalNotification != null;\n+                CompositeException de = this.delayedError;\n+                if (de != null) {\n+                    de.addAllPendingSuppressed();\n+                    if (terminalNotification.cause() == de) {\n+                        terminalNotification.terminate(target);\n+                    } else {\n+                        terminalNotification.terminate(target, de);\n+                    }\n+                } else {\n+                    terminalNotification.terminate(target);\n+                }\n+                return false;\n+            }\n+            @SuppressWarnings(\"unchecked\")\n+            final R rItem = item == NULL_TOKEN ? null : (R) item;\n+            target.onNext(rItem);\n+            return true;\n+        }\n+\n+        private void tryRequestMore(FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (acquirePendingLock(tryRequestMoreLockUpdater, this)) {\n+                try {\n+                    final long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                    if (availableRequestN != 0) {\n+                        final int consumedRequestN = subscriber.requestFromUpstream(\n+                                (int) min(source.maxMappedDemand, availableRequestN));\n+                        assert availableRequestN >= consumedRequestN;\n+                        if (consumedRequestN != availableRequestN) {\n+                            giveBackRequestN(availableRequestN - consumedRequestN);\n+                        }\n+                    }\n+                } finally {\n+                    if (!releasePendingLock(tryRequestMoreLockUpdater, this)) {\n+                        tryRequestMore();\n+                    }\n+                }\n+            }\n+        }\n+\n+        @SuppressWarnings(\"ContinueOrBreakFromFinallyBlock\")\n+        private void tryRequestMore() {\n+            Throwable delayedCause = null;\n+            while (acquirePendingLock(tryRequestMoreLockUpdater, this)) {\n+                try {\n+                    final long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                    if (availableRequestN != 0) {\n+                        long remainingRequestN = availableRequestN;\n+                        Iterator<FlatMapPublisherSubscriber<T, R>> itr = subscribers.iterator();\n+                        while (itr.hasNext() && remainingRequestN > 0) {\n+                            remainingRequestN -= itr.next().requestFromUpstream(\n+                                    (int) Math.min(source.maxMappedDemand, remainingRequestN));\n+                        }\n+\n+                        assert availableRequestN >= remainingRequestN && remainingRequestN >= 0;\n+                        if (remainingRequestN > 0) {\n+                            giveBackRequestN(remainingRequestN);\n+                        }\n+                    }\n+                } catch (Throwable cause) {\n+                    if (delayedCause == null) {\n+                        delayedCause = cause;\n+                    }\n+                } finally {\n+                    if (releasePendingLock(tryRequestMoreLockUpdater, this)) {\n+                        // break in finally isn't ideal but we catch Throwable above so we won't modify exception\n+                        // control flow. Also if we didn't catch Throwable and attempt to req-acquire the lock would be\n+                        // poisoned as the owner needs to re-acquire as long as release fails.\n+                        break;\n+                    }\n+                }\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void giveBackRequestN(final long delta) {\n+            pendingDemandUpdater.addAndGet(this, delta);\n+        }\n+\n+        private boolean terminateActiveMappedSources() {\n+            for (;;) {\n+                final int prevActiveMappedSources = activeMappedSources;\n+                // Should always be >= 0, but just in case there is a bug in user code that results in multiple terminal\n+                // events we avoid corrupting our internal state.\n+                if (prevActiveMappedSources < 0 || activeMappedSourcesUpdater.compareAndSet(this,\n+                        prevActiveMappedSources, -prevActiveMappedSources)) {\n+                    return prevActiveMappedSources == 0;\n+                }\n+            }\n+        }\n+\n+        private boolean decrementActiveMappedSources() {\n+            for (;;) {\n+                final int prevActivePublishers = activeMappedSources;\n+                assert prevActivePublishers != 0;\n+                if (prevActivePublishers > 0) {\n+                    if (activeMappedSourcesUpdater.compareAndSet(this, prevActivePublishers,\n+                            prevActivePublishers - 1)) {\n+                        return false;\n+                    }\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActivePublishers,\n+                        prevActivePublishers + 1)) {\n+                    return prevActivePublishers == -1;\n+                }\n+            }\n+        }\n+\n+        private boolean removeSubscriber(final FlatMapPublisherSubscriber<T, R> subscriber,\n+                                         final long requestNGiveBack) {\n+            if (subscribers.remove(subscriber)) {\n+                if (decrementActiveMappedSources()) {\n+                    return true;\n+                }\n+\n+                assert subscription != null;\n+                subscription.request(1);\n+\n+                if (requestNGiveBack > 0) {\n+                    giveBackRequestN(requestNGiveBack);\n+                    tryRequestMore();\n+                }\n+            }\n+            return false;\n+        }\n+\n+        private static final class FlatMapPublisherSubscriber<T, R> implements Subscriber<R> {\n+            private static final Subscription CANCELLED = new EmptySubscription();\n+            private static final Subscription CANCEL_PENDING = new EmptySubscription();\n+            private static final Subscription REQUEST_PENDING = new EmptySubscription();\n+            private static final Subscription PROCESSING_REQUEST = new EmptySubscription();\n+            private static final Subscription PROCESSING_ONNEXT = new EmptySubscription();\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicReferenceFieldUpdater<FlatMapPublisherSubscriber, Subscription>\n+                    subscriptionUpdater = newUpdater(FlatMapPublisherSubscriber.class, Subscription.class,\n+                    \"subscription\");\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicLongFieldUpdater<FlatMapPublisherSubscriber> outstandingDemandUpdater =\n+                    AtomicLongFieldUpdater.newUpdater(FlatMapPublisherSubscriber.class, \"outstandingDemand\");\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicLongFieldUpdater<FlatMapPublisherSubscriber> pendingDemandUpdater =\n+                    AtomicLongFieldUpdater.newUpdater(FlatMapPublisherSubscriber.class, \"pendingDemand\");\n+\n+            private final FlatMapSubscriber<T, R> parent;\n+\n+            @SuppressWarnings(\"unused\")\n+            @Nullable\n+            private volatile Subscription subscription;\n+            private volatile long pendingDemand;\n+            private volatile long outstandingDemand;\n+\n+            FlatMapPublisherSubscriber(FlatMapSubscriber<T, R> parent) {\n+                this.parent = parent;\n+            }\n+\n+            void cancelFromUpstream() {\n+                for (;;) {\n+                    final Subscription prevSubscription = subscription;\n+                    if (prevSubscription == null) {\n+                        if (subscriptionUpdater.compareAndSet(this, null, CANCELLED)) {\n+                            break;\n+                        }\n+                    } else if (prevSubscription == CANCELLED || prevSubscription == CANCEL_PENDING) {\n+                        break;\n+                    } else if (prevSubscription == PROCESSING_ONNEXT || prevSubscription == PROCESSING_REQUEST) {\n+                        if (subscriptionUpdater.compareAndSet(this, prevSubscription, CANCEL_PENDING)) {\n+                            break;\n+                        }\n+                    } else if (subscriptionUpdater.compareAndSet(this, prevSubscription, CANCELLED)) {\n+                        cancelAndGiveBack(prevSubscription);\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            int requestFromUpstream(final int n) {\n+                for (;;) {\n+                    final long prevOutstandingDemand = outstandingDemand;\n+                    if (prevOutstandingDemand < 0) {\n+                        return 0; // we have already been cancelled, or terminated\n+                    }\n+                    final int quotaToUse = (int) min(Long.MAX_VALUE - prevOutstandingDemand,\n+                            min(parent.source.maxMappedDemand - prevOutstandingDemand, n));\n+                    if (quotaToUse == 0) {\n+                        if (outstandingDemandUpdater.compareAndSet(this, prevOutstandingDemand,\n+                                prevOutstandingDemand)) {\n+                            return 0;\n+                        }\n+                    } else if (outstandingDemandUpdater.compareAndSet(this, prevOutstandingDemand,\n+                            prevOutstandingDemand + quotaToUse)) {\n+                        pendingDemandUpdater.addAndGet(this, quotaToUse);\n+                        for (;;) {\n+                            final Subscription prevSubscription = subscription;\n+                            if (prevSubscription == null) {\n+                                if (subscriptionUpdater.compareAndSet(this, null, REQUEST_PENDING)) {\n+                                    break;\n+                                }\n+                            } else if (prevSubscription == CANCELLED || prevSubscription == CANCEL_PENDING) {\n+                                break;\n+                            } else if (prevSubscription == REQUEST_PENDING || prevSubscription == PROCESSING_ONNEXT ||\n+                                    prevSubscription == PROCESSING_REQUEST) {\n+                                if (subscriptionUpdater.compareAndSet(this, prevSubscription, REQUEST_PENDING)) {\n+                                    break;\n+                                }\n+                            } else if (subscriptionUpdater.compareAndSet(this, prevSubscription, PROCESSING_REQUEST)) {\n+                                doRequestMore(prevSubscription);\n+                                break;\n+                            }\n+                        }\n+                        return quotaToUse;\n+                    }\n+                }\n+            }\n+\n+            private void doRequestMore(Subscription prevSubscription) {\n+                long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                for (;;) {\n+                    if (availableRequestN > 0) {\n+                        try {\n+                            prevSubscription.request(availableRequestN);\n+                        } catch (Throwable cause) {\n+                            subscription = CANCELLED;\n+                            cancelAndGiveBack(prevSubscription);\n+                            throw cause;\n+                        }\n+                    }\n+\n+                    final Subscription afterLockSubscription = subscription;\n+                    if (afterLockSubscription == PROCESSING_ONNEXT || afterLockSubscription == CANCELLED) {\n+                        // onNext is allowed to interrupt, and will handle any pending cancel/request events\n+                        // after it completes (otherwise we may drop signals).\n+                        break;\n+                    } else if (afterLockSubscription == CANCEL_PENDING) {\n+                        subscription = CANCELLED;\n+                        cancelAndGiveBack(prevSubscription);\n+                        break;\n+                    } else if (afterLockSubscription == REQUEST_PENDING) {\n+                        if (subscriptionUpdater.compareAndSet(this, REQUEST_PENDING, PROCESSING_REQUEST)) {\n+                            availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                            // continue through next iteration to try to unlock\n+                        }\n+                    } else if (afterLockSubscription == PROCESSING_REQUEST &&\n+                            subscriptionUpdater.compareAndSet(this, PROCESSING_REQUEST, prevSubscription)) {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            private void cancelAndGiveBack(Subscription subscription) {\n+                try {\n+                    subscription.cancel();\n+                } finally {\n+                    giveBackUnusedRequestN();\n+                }\n+            }\n+\n+            private boolean giveBackUnusedRequestN() {\n+                // we need to give back the outstanding amount that has been requested, but not emitted.\n+                // resetting sourceRequestedUpdater must happen unconditionally first, as this stops\n+                // calculateSourceRequested from attempting to request any more.\n+                final long prevOutstandingDemand = outstandingDemandUpdater.getAndSet(this, -1);", "originalCommit": "f1371888e0d42ed60e7c5ce80eb43544b66458e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQwNDUzMg==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r410404532", "bodyText": "done", "author": "Scottmitch", "createdAt": "2020-04-17T18:41:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE2MTQ2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE2MTgwNA==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r410161804", "bodyText": "nit: you could remove the else", "author": "normanmaurer", "createdAt": "2020-04-17T11:27:25Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.EmptySubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Iterator;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.NULL_TOKEN;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.acquirePendingLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releasePendingLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * This flatMap implementation doesn't rely upon queuing to manage demand. Instead it leases out demand quota\n+ * (capped by {@link #maxMappedDemand}) mapped {@link Publisher}s and reclaims any unused quota when each mapped\n+ * {@link Publisher} is terminated or cancelled. {@link FlatMapSubscriber.FlatMapPublisherSubscriber} carefully manages\n+ * outstanding demand to ensure when quota is reclaimed there are no subsequent\n+ * {@link Subscriber#onNext(Object) signals} to avoid returning inaccurate amounts which would otherwise result in\n+ * deadlock (under delivering {@link Subscriber#onNext(Object) signals}) or violation of\n+ * <a href=\"https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#1.1\">Reactive Streams\n+ * Specification</a> (over delivering {@link Subscriber#onNext(Object) signals}) to the downstream {@link Subscriber}.\n+ *\n+ * @param <T> Type of original {@link Publisher}.\n+ * @param <R> Type of {@link Publisher} returned by the operator.\n+ */\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> tryRequestMoreLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"tryRequestMoreLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int tryRequestMoreLock;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile long pendingDemand;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+\n+        /**\n+         * This variable is only accessed within the \"emitting lock\" so we rely upon this to provide visibility to\n+         * other threads.\n+         */\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> pending;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            pending = newUnboundedMpscQueue(min(2, source.maxConcurrency));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                pendingDemandUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtection);\n+                tryRequestMore();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            // Currently we always request maxConcurrency elements from upstream.\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            final boolean added = subscribers.add(subscriber);\n+            assert added; // FlatMapPublisherSubscriber relies upon object equality and should never fail.\n+            for (;;) {\n+                final int prevActiveMappedSources = activeMappedSources;\n+                if (prevActiveMappedSources < 0) {\n+                    // We have been cancelled, so in this case we don't want to Subscribe and instead\n+                    // just want to discard the Publisher.\n+                    subscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveMappedSources,\n+                        prevActiveMappedSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    tryRequestMore(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            Throwable delayedCause = null;\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                for (FlatMapPublisherSubscriber<T, R> subscriber : subscribers) {\n+                    try {\n+                        subscriber.cancelFromUpstream();\n+                    } catch (Throwable c) {\n+                        if (delayedCause == null) {\n+                            delayedCause = c;\n+                        }\n+                    }\n+                }\n+                subscribers.clear();\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            if (!pending.offer(item)) {\n+                enqueueAndDrainFail(item);\n+            }\n+            drainPending();\n+        }\n+\n+        private void enqueueAndDrainFail(Object item) {\n+            QueueFullException exception = new QueueFullException(\"pending\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, true, true);\n+            }\n+        }\n+\n+        @SuppressWarnings(\"ContinueOrBreakFromFinallyBlock\")\n+        private void drainPending() {\n+            long emittedCount = 0;\n+            Throwable delayedCause = null;\n+            while (acquirePendingLock(emittingLockUpdater, this)) {\n+                try {\n+                    Object t;\n+                    while ((t = pending.poll()) != null) {\n+                        try {\n+                            if (sendToTarget(t)) {\n+                                ++emittedCount;\n+                            }\n+                        } catch (Throwable cause) {\n+                            if (delayedCause == null) {\n+                                delayedCause = cause;\n+                            }\n+                        }\n+                    }\n+                } finally {\n+                    if (releasePendingLock(emittingLockUpdater, this)) {\n+                        // break in finally isn't ideal but we catch Throwable above so we won't modify exception\n+                        // control flow. Also if we didn't catch Throwable and attempt to req-acquire the lock would be\n+                        // poisoned as the owner needs to re-acquire as long as release fails.\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            if (emittedCount != 0) {\n+                tryRequestMore();\n+            }\n+\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private boolean sendToTarget(Object item) {\n+            if (targetTerminated) {\n+                // No notifications past terminal/cancelled\n+                return false;\n+            }\n+            if (item instanceof TerminalNotification) {\n+                targetTerminated = true;\n+                // Load the terminal notification in case an error happened after an onComplete and we override the\n+                // terminal value.\n+                TerminalNotification terminalNotification = this.terminalNotification;\n+                assert terminalNotification != null;\n+                CompositeException de = this.delayedError;\n+                if (de != null) {\n+                    de.addAllPendingSuppressed();\n+                    if (terminalNotification.cause() == de) {\n+                        terminalNotification.terminate(target);\n+                    } else {\n+                        terminalNotification.terminate(target, de);\n+                    }\n+                } else {\n+                    terminalNotification.terminate(target);\n+                }\n+                return false;\n+            }\n+            @SuppressWarnings(\"unchecked\")\n+            final R rItem = item == NULL_TOKEN ? null : (R) item;\n+            target.onNext(rItem);\n+            return true;\n+        }\n+\n+        private void tryRequestMore(FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (acquirePendingLock(tryRequestMoreLockUpdater, this)) {\n+                try {\n+                    final long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                    if (availableRequestN != 0) {\n+                        final int consumedRequestN = subscriber.requestFromUpstream(\n+                                (int) min(source.maxMappedDemand, availableRequestN));\n+                        assert availableRequestN >= consumedRequestN;\n+                        if (consumedRequestN != availableRequestN) {\n+                            giveBackRequestN(availableRequestN - consumedRequestN);\n+                        }\n+                    }\n+                } finally {\n+                    if (!releasePendingLock(tryRequestMoreLockUpdater, this)) {\n+                        tryRequestMore();\n+                    }\n+                }\n+            }\n+        }\n+\n+        @SuppressWarnings(\"ContinueOrBreakFromFinallyBlock\")\n+        private void tryRequestMore() {\n+            Throwable delayedCause = null;\n+            while (acquirePendingLock(tryRequestMoreLockUpdater, this)) {\n+                try {\n+                    final long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                    if (availableRequestN != 0) {\n+                        long remainingRequestN = availableRequestN;\n+                        Iterator<FlatMapPublisherSubscriber<T, R>> itr = subscribers.iterator();\n+                        while (itr.hasNext() && remainingRequestN > 0) {\n+                            remainingRequestN -= itr.next().requestFromUpstream(\n+                                    (int) Math.min(source.maxMappedDemand, remainingRequestN));\n+                        }\n+\n+                        assert availableRequestN >= remainingRequestN && remainingRequestN >= 0;\n+                        if (remainingRequestN > 0) {\n+                            giveBackRequestN(remainingRequestN);\n+                        }\n+                    }\n+                } catch (Throwable cause) {\n+                    if (delayedCause == null) {\n+                        delayedCause = cause;\n+                    }\n+                } finally {\n+                    if (releasePendingLock(tryRequestMoreLockUpdater, this)) {\n+                        // break in finally isn't ideal but we catch Throwable above so we won't modify exception\n+                        // control flow. Also if we didn't catch Throwable and attempt to req-acquire the lock would be\n+                        // poisoned as the owner needs to re-acquire as long as release fails.\n+                        break;\n+                    }\n+                }\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void giveBackRequestN(final long delta) {\n+            pendingDemandUpdater.addAndGet(this, delta);\n+        }\n+\n+        private boolean terminateActiveMappedSources() {\n+            for (;;) {\n+                final int prevActiveMappedSources = activeMappedSources;\n+                // Should always be >= 0, but just in case there is a bug in user code that results in multiple terminal\n+                // events we avoid corrupting our internal state.\n+                if (prevActiveMappedSources < 0 || activeMappedSourcesUpdater.compareAndSet(this,\n+                        prevActiveMappedSources, -prevActiveMappedSources)) {\n+                    return prevActiveMappedSources == 0;\n+                }\n+            }\n+        }\n+\n+        private boolean decrementActiveMappedSources() {\n+            for (;;) {\n+                final int prevActivePublishers = activeMappedSources;\n+                assert prevActivePublishers != 0;\n+                if (prevActivePublishers > 0) {\n+                    if (activeMappedSourcesUpdater.compareAndSet(this, prevActivePublishers,\n+                            prevActivePublishers - 1)) {\n+                        return false;\n+                    }\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActivePublishers,\n+                        prevActivePublishers + 1)) {\n+                    return prevActivePublishers == -1;\n+                }\n+            }\n+        }\n+\n+        private boolean removeSubscriber(final FlatMapPublisherSubscriber<T, R> subscriber,\n+                                         final long requestNGiveBack) {\n+            if (subscribers.remove(subscriber)) {\n+                if (decrementActiveMappedSources()) {\n+                    return true;\n+                }\n+\n+                assert subscription != null;\n+                subscription.request(1);\n+\n+                if (requestNGiveBack > 0) {\n+                    giveBackRequestN(requestNGiveBack);\n+                    tryRequestMore();\n+                }\n+            }\n+            return false;\n+        }\n+\n+        private static final class FlatMapPublisherSubscriber<T, R> implements Subscriber<R> {\n+            private static final Subscription CANCELLED = new EmptySubscription();\n+            private static final Subscription CANCEL_PENDING = new EmptySubscription();\n+            private static final Subscription REQUEST_PENDING = new EmptySubscription();\n+            private static final Subscription PROCESSING_REQUEST = new EmptySubscription();\n+            private static final Subscription PROCESSING_ONNEXT = new EmptySubscription();\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicReferenceFieldUpdater<FlatMapPublisherSubscriber, Subscription>\n+                    subscriptionUpdater = newUpdater(FlatMapPublisherSubscriber.class, Subscription.class,\n+                    \"subscription\");\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicLongFieldUpdater<FlatMapPublisherSubscriber> outstandingDemandUpdater =\n+                    AtomicLongFieldUpdater.newUpdater(FlatMapPublisherSubscriber.class, \"outstandingDemand\");\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicLongFieldUpdater<FlatMapPublisherSubscriber> pendingDemandUpdater =\n+                    AtomicLongFieldUpdater.newUpdater(FlatMapPublisherSubscriber.class, \"pendingDemand\");\n+\n+            private final FlatMapSubscriber<T, R> parent;\n+\n+            @SuppressWarnings(\"unused\")\n+            @Nullable\n+            private volatile Subscription subscription;\n+            private volatile long pendingDemand;\n+            private volatile long outstandingDemand;\n+\n+            FlatMapPublisherSubscriber(FlatMapSubscriber<T, R> parent) {\n+                this.parent = parent;\n+            }\n+\n+            void cancelFromUpstream() {\n+                for (;;) {\n+                    final Subscription prevSubscription = subscription;\n+                    if (prevSubscription == null) {\n+                        if (subscriptionUpdater.compareAndSet(this, null, CANCELLED)) {\n+                            break;\n+                        }\n+                    } else if (prevSubscription == CANCELLED || prevSubscription == CANCEL_PENDING) {\n+                        break;\n+                    } else if (prevSubscription == PROCESSING_ONNEXT || prevSubscription == PROCESSING_REQUEST) {\n+                        if (subscriptionUpdater.compareAndSet(this, prevSubscription, CANCEL_PENDING)) {\n+                            break;\n+                        }\n+                    } else if (subscriptionUpdater.compareAndSet(this, prevSubscription, CANCELLED)) {\n+                        cancelAndGiveBack(prevSubscription);\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            int requestFromUpstream(final int n) {\n+                for (;;) {\n+                    final long prevOutstandingDemand = outstandingDemand;\n+                    if (prevOutstandingDemand < 0) {\n+                        return 0; // we have already been cancelled, or terminated\n+                    }\n+                    final int quotaToUse = (int) min(Long.MAX_VALUE - prevOutstandingDemand,\n+                            min(parent.source.maxMappedDemand - prevOutstandingDemand, n));\n+                    if (quotaToUse == 0) {\n+                        if (outstandingDemandUpdater.compareAndSet(this, prevOutstandingDemand,\n+                                prevOutstandingDemand)) {\n+                            return 0;\n+                        }\n+                    } else if (outstandingDemandUpdater.compareAndSet(this, prevOutstandingDemand,\n+                            prevOutstandingDemand + quotaToUse)) {\n+                        pendingDemandUpdater.addAndGet(this, quotaToUse);\n+                        for (;;) {\n+                            final Subscription prevSubscription = subscription;\n+                            if (prevSubscription == null) {\n+                                if (subscriptionUpdater.compareAndSet(this, null, REQUEST_PENDING)) {\n+                                    break;\n+                                }\n+                            } else if (prevSubscription == CANCELLED || prevSubscription == CANCEL_PENDING) {\n+                                break;\n+                            } else if (prevSubscription == REQUEST_PENDING || prevSubscription == PROCESSING_ONNEXT ||\n+                                    prevSubscription == PROCESSING_REQUEST) {\n+                                if (subscriptionUpdater.compareAndSet(this, prevSubscription, REQUEST_PENDING)) {\n+                                    break;\n+                                }\n+                            } else if (subscriptionUpdater.compareAndSet(this, prevSubscription, PROCESSING_REQUEST)) {\n+                                doRequestMore(prevSubscription);\n+                                break;\n+                            }\n+                        }\n+                        return quotaToUse;\n+                    }\n+                }\n+            }\n+\n+            private void doRequestMore(Subscription prevSubscription) {\n+                long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                for (;;) {\n+                    if (availableRequestN > 0) {\n+                        try {\n+                            prevSubscription.request(availableRequestN);\n+                        } catch (Throwable cause) {\n+                            subscription = CANCELLED;\n+                            cancelAndGiveBack(prevSubscription);\n+                            throw cause;\n+                        }\n+                    }\n+\n+                    final Subscription afterLockSubscription = subscription;\n+                    if (afterLockSubscription == PROCESSING_ONNEXT || afterLockSubscription == CANCELLED) {\n+                        // onNext is allowed to interrupt, and will handle any pending cancel/request events\n+                        // after it completes (otherwise we may drop signals).\n+                        break;\n+                    } else if (afterLockSubscription == CANCEL_PENDING) {\n+                        subscription = CANCELLED;\n+                        cancelAndGiveBack(prevSubscription);\n+                        break;\n+                    } else if (afterLockSubscription == REQUEST_PENDING) {\n+                        if (subscriptionUpdater.compareAndSet(this, REQUEST_PENDING, PROCESSING_REQUEST)) {\n+                            availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                            // continue through next iteration to try to unlock\n+                        }\n+                    } else if (afterLockSubscription == PROCESSING_REQUEST &&\n+                            subscriptionUpdater.compareAndSet(this, PROCESSING_REQUEST, prevSubscription)) {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            private void cancelAndGiveBack(Subscription subscription) {\n+                try {\n+                    subscription.cancel();\n+                } finally {\n+                    giveBackUnusedRequestN();\n+                }\n+            }\n+\n+            private boolean giveBackUnusedRequestN() {\n+                // we need to give back the outstanding amount that has been requested, but not emitted.\n+                // resetting sourceRequestedUpdater must happen unconditionally first, as this stops\n+                // calculateSourceRequested from attempting to request any more.\n+                final long prevOutstandingDemand = outstandingDemandUpdater.getAndSet(this, -1);\n+                return prevOutstandingDemand >= 0 && parent.removeSubscriber(this, prevOutstandingDemand);\n+            }\n+\n+            @Override\n+            public void onSubscribe(final Subscription s) {\n+                for (;;) {\n+                    final Subscription prevSubscription = subscription;\n+                    assert prevSubscription != CANCEL_PENDING && prevSubscription != PROCESSING_ONNEXT &&\n+                            prevSubscription != PROCESSING_REQUEST;\n+                    if (prevSubscription == null) {\n+                        if (subscriptionUpdater.compareAndSet(this, null, s)) {\n+                            break;\n+                        }\n+                    } else if (prevSubscription == REQUEST_PENDING) {\n+                        if (subscriptionUpdater.compareAndSet(this, REQUEST_PENDING, PROCESSING_REQUEST)) {\n+                            doRequestMore(s);\n+                            break;\n+                        }\n+                    } else {\n+                        s.cancel(); // already cancelled or duplicate onSubscribe\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void onNext(@Nullable final R r) {\n+                boolean acquiredLock = false;\n+                for (;;) {\n+                    Subscription prevSubscription = subscription;\n+                    assert prevSubscription != null;\n+                    if (prevSubscription == CANCELLED || prevSubscription == CANCEL_PENDING) {\n+                        // we have already given our undelivered requestN quota up, or will after we unroll process\n+                        // onNext. we are not allowed to deliver more data or else we may violate upstream's requestN.\n+                        break;\n+                    } else if (prevSubscription == PROCESSING_ONNEXT ||\n+                            (acquiredLock = subscriptionUpdater.compareAndSet(this,\n+                                    prevSubscription, PROCESSING_ONNEXT))) {\n+                        final long newOutstandingDemand = outstandingDemandUpdater.decrementAndGet(this);\n+                        try {\n+                            parent.enqueueAndDrain(r == null ? NULL_TOKEN : r);\n+                        } finally {\n+                            if (acquiredLock) {\n+                                for (;;) {\n+                                    Subscription afterLockSubscription = subscription;\n+                                    assert afterLockSubscription != PROCESSING_REQUEST;\n+                                    if (afterLockSubscription == CANCEL_PENDING) {\n+                                        subscription = CANCELLED; // this is a terminal state.\n+                                        cancelAndGiveBack(prevSubscription);\n+                                        break;\n+                                    } else if (afterLockSubscription == REQUEST_PENDING) {", "originalCommit": "f1371888e0d42ed60e7c5ce80eb43544b66458e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM2NzcwMQ==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r410367701", "bodyText": "discussed above", "author": "Scottmitch", "createdAt": "2020-04-17T17:29:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE2MTgwNA=="}], "type": "inlineReview"}, {"oid": "97d3ca48b7a5e3b67faed9d221eba6d7f6fe5d2b", "url": "https://github.com/apple/servicetalk/commit/97d3ca48b7a5e3b67faed9d221eba6d7f6fe5d2b", "message": "minor cleanup", "committedDate": "2020-04-20T16:44:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjExMTU1Ng==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r412111556", "bodyText": "Is a ConcurrentHashMap good enough as the backing for the Set or do we also need to preserve some sort of \"ordering\" when iterate over all the subscribers later on and so would need some sorted of LinkedHashSet ?", "author": "normanmaurer", "createdAt": "2020-04-21T11:43:42Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,705 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.EmptySubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Iterator;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.NULL_TOKEN;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.acquirePendingLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releasePendingLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * This flatMap implementation doesn't rely upon queuing to manage demand. Instead it leases out demand quota\n+ * (capped by {@link #maxMappedDemand}) mapped {@link Publisher}s and reclaims any unused quota when each mapped\n+ * {@link Publisher} is terminated or cancelled. {@link FlatMapSubscriber.FlatMapPublisherSubscriber} carefully manages\n+ * outstanding demand to ensure when quota is reclaimed there are no subsequent\n+ * {@link Subscriber#onNext(Object) signals} to avoid returning inaccurate amounts which would otherwise result in\n+ * deadlock (under delivering {@link Subscriber#onNext(Object) signals}) or violation of\n+ * <a href=\"https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#1.1\">Reactive Streams\n+ * Specification</a> (over delivering {@link Subscriber#onNext(Object) signals}) to the downstream {@link Subscriber}.\n+ *\n+ * @param <T> Type of original {@link Publisher}.\n+ * @param <R> Type of {@link Publisher} returned by the operator.\n+ */\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 16, 64, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> tryRequestMoreLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"tryRequestMoreLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int tryRequestMoreLock;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile long pendingDemand;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+\n+        /**\n+         * This variable is only accessed within the \"emitting lock\" so we rely upon this to provide visibility to\n+         * other threads.\n+         */\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> pending;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            pending = newUnboundedMpscQueue(min(2, source.maxConcurrency));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                pendingDemandUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtection);\n+                tryRequestMore();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            // Currently we always request maxConcurrency elements from upstream.\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            final boolean added = subscribers.add(subscriber);", "originalCommit": "97d3ca48b7a5e3b67faed9d221eba6d7f6fe5d2b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM2MDM5NA==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r412360394", "bodyText": "Ordering isn't required. Ideally we iterate in a random order to distribute demand uniformly, but a best effort approximation should be \"good enough\" as there is no guarantee about uniform distribution.", "author": "Scottmitch", "createdAt": "2020-04-21T17:42:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjExMTU1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5NzI5NQ==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r424097295", "bodyText": "note that the approach has changed and we no longer iterate over all Subscribers to distribute request n.", "author": "Scottmitch", "createdAt": "2020-05-12T23:50:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjExMTU1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjExMzk4Mw==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r412113983", "bodyText": "is it possible that cancel() and onNext(...) is called concurrently ? If so just iterating over the subscribers and then call clear() is racy as you may miss some subscribers that were added by onNext(...)", "author": "normanmaurer", "createdAt": "2020-04-21T11:47:34Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,705 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.EmptySubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Iterator;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.NULL_TOKEN;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.acquirePendingLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releasePendingLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * This flatMap implementation doesn't rely upon queuing to manage demand. Instead it leases out demand quota\n+ * (capped by {@link #maxMappedDemand}) mapped {@link Publisher}s and reclaims any unused quota when each mapped\n+ * {@link Publisher} is terminated or cancelled. {@link FlatMapSubscriber.FlatMapPublisherSubscriber} carefully manages\n+ * outstanding demand to ensure when quota is reclaimed there are no subsequent\n+ * {@link Subscriber#onNext(Object) signals} to avoid returning inaccurate amounts which would otherwise result in\n+ * deadlock (under delivering {@link Subscriber#onNext(Object) signals}) or violation of\n+ * <a href=\"https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#1.1\">Reactive Streams\n+ * Specification</a> (over delivering {@link Subscriber#onNext(Object) signals}) to the downstream {@link Subscriber}.\n+ *\n+ * @param <T> Type of original {@link Publisher}.\n+ * @param <R> Type of {@link Publisher} returned by the operator.\n+ */\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 16, 64, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> tryRequestMoreLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"tryRequestMoreLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int tryRequestMoreLock;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile long pendingDemand;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+\n+        /**\n+         * This variable is only accessed within the \"emitting lock\" so we rely upon this to provide visibility to\n+         * other threads.\n+         */\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> pending;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            pending = newUnboundedMpscQueue(min(2, source.maxConcurrency));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                pendingDemandUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtection);\n+                tryRequestMore();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            // Currently we always request maxConcurrency elements from upstream.\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            final boolean added = subscribers.add(subscriber);\n+            assert added; // FlatMapPublisherSubscriber relies upon object equality and should never fail.\n+            for (;;) {\n+                final int prevActiveMappedSources = activeMappedSources;\n+                if (prevActiveMappedSources < 0) {\n+                    // We have been cancelled, or already completed and the active count flipped to negative, either way\n+                    // we don't want to Subscribe or retain a reference to this Publisher.\n+                    subscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveMappedSources,\n+                        prevActiveMappedSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    tryRequestMore(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            Throwable delayedCause = null;\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions. This should be Integer.MIN_VALUE to prevent subsequent mapped\n+            // source completion from incrementing the count to 0 or positive as terminateActiveMappedSources flips\n+            // the count to negative to signal to mapped sources we have completed.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                for (FlatMapPublisherSubscriber<T, R> subscriber : subscribers) {", "originalCommit": "97d3ca48b7a5e3b67faed9d221eba6d7f6fe5d2b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM2NDY3MA==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r412364670", "bodyText": "Yes this is possible. I believe this case is accounted for as follows:\n\ncancel() sets activeMappedSources = Integer.MIN_VALUE; before iterating/clearing the map. See comments from onCancel(..):\n\n// Prevent future onNext operations from adding to subscribers which otherwise may result in\n// not cancelling mapped Subscriptions. This should be Integer.MIN_VALUE to prevent subsequent mapped\n// source completion from incrementing the count to 0 or positive as terminateActiveMappedSources flips\n// the count to negative to signal to mapped sources we have completed.\n\n\nonNext(..) attempts to atomically increment activeMappedSources after adding to the map, and removes the entry if failed to increment because negative value is seen (negative values are also used when the FlatMapSubscriber terminates to coordinate with FlatMapPublisherSubscriber completion). See comments from onNext(..):\n\n// We have been cancelled, or already completed and the active count flipped to negative, either way\n// we don't want to Subscribe or retain a reference to this Publisher.", "author": "Scottmitch", "createdAt": "2020-04-21T17:48:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjExMzk4Mw=="}], "type": "inlineReview"}, {"oid": "92bd9728f13959c2a21b58c01a9892f352a58c83", "url": "https://github.com/apple/servicetalk/commit/92bd9728f13959c2a21b58c01a9892f352a58c83", "message": "Add Publisher#flatMapMerge operator\n\nMotivation:\nPublisher#flatMapMerge is a basic building block for each element of a\nPublisher to map into another Publisher.\n\nModifications:\n- Add Publisher#flatMapMerge operator\n\nResult:\nEach item emitted on a Publisher can be mapped to another Publisher.", "committedDate": "2020-04-28T04:24:29Z", "type": "forcePushed"}, {"oid": "8741f487dff9c376a1f46524a4d255054ae552a7", "url": "https://github.com/apple/servicetalk/commit/8741f487dff9c376a1f46524a4d255054ae552a7", "message": "Add Publisher#flatMapMerge operator\n\nMotivation:\nPublisher#flatMapMerge is a basic building block for each element of a\nPublisher to map into another Publisher.\n\nModifications:\n- Add Publisher#flatMapMerge operator\n\nResult:\nEach item emitted on a Publisher can be mapped to another Publisher.", "committedDate": "2020-05-05T15:10:24Z", "type": "forcePushed"}, {"oid": "0a8e4d896b6bc94e92d6e307bc37a8e4d1bf2eef", "url": "https://github.com/apple/servicetalk/commit/0a8e4d896b6bc94e92d6e307bc37a8e4d1bf2eef", "message": "work in progress, change to queue more instead of manage request n\ndemand", "committedDate": "2020-05-09T04:26:54Z", "type": "forcePushed"}, {"oid": "351eac77ea560506f39d9bac2f7ddf86dd9e4c8c", "url": "https://github.com/apple/servicetalk/commit/351eac77ea560506f39d9bac2f7ddf86dd9e4c8c", "message": "work in progress, change to queue more instead of manage request n\ndemand", "committedDate": "2020-05-09T18:08:39Z", "type": "forcePushed"}, {"oid": "09e9d9a298fb49d0af16dc1e87cd462bd9b240d6", "url": "https://github.com/apple/servicetalk/commit/09e9d9a298fb49d0af16dc1e87cd462bd9b240d6", "message": "work in progress, change to queue more instead of manage request n\ndemand", "committedDate": "2020-05-09T19:06:01Z", "type": "forcePushed"}, {"oid": "61de9bb46a49435bc9961bbcded470dde393c0de", "url": "https://github.com/apple/servicetalk/commit/61de9bb46a49435bc9961bbcded470dde393c0de", "message": "work in progress, change to queue more instead of manage request n\ndemand", "committedDate": "2020-05-09T21:33:46Z", "type": "forcePushed"}, {"oid": "e93286d9d832a3cf6275c81edeae08f699ba12bd", "url": "https://github.com/apple/servicetalk/commit/e93286d9d832a3cf6275c81edeae08f699ba12bd", "message": "work in progress, change to queue more instead of manage request n\ndemand", "committedDate": "2020-05-12T01:12:10Z", "type": "forcePushed"}, {"oid": "b987f73abbb9fc30953392f71fdff675c8312bc3", "url": "https://github.com/apple/servicetalk/commit/b987f73abbb9fc30953392f71fdff675c8312bc3", "message": "work in progress, change to queue more instead of manage request n\ndemand", "committedDate": "2020-05-12T01:13:11Z", "type": "forcePushed"}, {"oid": "d5c76b6ddd053ac2d3036fa0fabbe46109a42df5", "url": "https://github.com/apple/servicetalk/commit/d5c76b6ddd053ac2d3036fa0fabbe46109a42df5", "message": "work in progress, change to queue more instead of manage request n\ndemand", "committedDate": "2020-05-12T01:14:16Z", "type": "forcePushed"}, {"oid": "4e3f43a9ba6d9a7bca080a2fbd350488ae7291ef", "url": "https://github.com/apple/servicetalk/commit/4e3f43a9ba6d9a7bca080a2fbd350488ae7291ef", "message": "work in progress, change to queue more instead of manage request n\ndemand", "committedDate": "2020-05-12T18:14:07Z", "type": "forcePushed"}, {"oid": "e88151526677fa7d431b21391f783651bbe09d12", "url": "https://github.com/apple/servicetalk/commit/e88151526677fa7d431b21391f783651bbe09d12", "message": "work in progress, change to queue more instead of manage request n\ndemand", "committedDate": "2020-05-12T21:30:09Z", "type": "forcePushed"}, {"oid": "f43cb45b983a07cb11c3cea16b377df2de70c0d6", "url": "https://github.com/apple/servicetalk/commit/f43cb45b983a07cb11c3cea16b377df2de70c0d6", "message": "change to queue more instead of manage request n demand. this way we\nensure we make progress at the expense of memory, and less coordination\nmanaging request(n) lending/distribution.", "committedDate": "2020-05-12T23:45:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM1NTM2OA==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r424355368", "bodyText": "nit: s/in side/inside/", "author": "normanmaurer", "createdAt": "2020-05-13T11:08:59Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 16, 64, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+\n+        // protected by emitting lock, or only accessed in side the Subscriber thread", "originalCommit": "f43cb45b983a07cb11c3cea16b377df2de70c0d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM1NTcwNw==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r424355707", "bodyText": "nit: should we use some \"non default\" initial capacity ?", "author": "normanmaurer", "createdAt": "2020-05-13T11:09:43Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 16, 64, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+\n+        // protected by emitting lock, or only accessed in side the Subscriber thread\n+        private boolean targetTerminated;\n+        private int upstreamDemand;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            signals = newUnboundedMpscQueue(min(2, source.maxConcurrency * source.maxMappedDemand));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());", "originalCommit": "f43cb45b983a07cb11c3cea16b377df2de70c0d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU4OTc5NQ==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r424589795", "bodyText": "sure will put a cap on the initial capacity.", "author": "Scottmitch", "createdAt": "2020-05-13T16:56:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM1NTcwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM2MjIxNQ==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r424362215", "bodyText": "I wonder if we could just use incrementAndGet(...) and decrement again if its not what we expect. This should be cheaper as this will use XADD when on x86\nSomething like:\n            for (;;) {\n                 final int prevActiveSources = activeMappedSources;\n                 if (prevActiveSources < 0) {\n                     // We have been cancelled, or already completed and the active count flipped to negative, either way\n                     // we don't want to Subscribe or retain a reference to this Publisher.\n                     subscribers.remove(subscriber);\n                     break;\n                 // try to optimistically increment and if the outcome is not what we expect rollback\n                 } else  if (activeMappedSourcesUpdater.incrementAndGet(this) ==  prevActiveSources + 1) {\n                     publisher.subscribeInternal(subscriber);\n                     break;\n                 } else {\n                     // rollback\n                     activeMappedSourcesUpdater.decrementAndGet(this)\n                 }\n             }", "author": "normanmaurer", "createdAt": "2020-05-13T11:23:15Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 16, 64, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+\n+        // protected by emitting lock, or only accessed in side the Subscriber thread\n+        private boolean targetTerminated;\n+        private int upstreamDemand;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            signals = newUnboundedMpscQueue(min(2, source.maxConcurrency * source.maxMappedDemand));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else if (pendingDemandUpdater.getAndAccumulate(this, n,\n+                    FlowControlUtils::addWithOverflowProtectionIfNotNegative) == 0) {\n+                drainPending();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            upstreamDemand = source.maxConcurrency;\n+            subscription.request(upstreamDemand);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            final boolean added = subscribers.add(subscriber);\n+            assert added; // FlatMapPublisherSubscriber relies upon object equality and should never fail.\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                if (prevActiveSources < 0) {\n+                    // We have been cancelled, or already completed and the active count flipped to negative, either way\n+                    // we don't want to Subscribe or retain a reference to this Publisher.\n+                    subscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {", "originalCommit": "f43cb45b983a07cb11c3cea16b377df2de70c0d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU5MzU4Nw==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r424593587", "bodyText": "negative values are meaningful as we use the negative values to signal completion to the mapped sources via terminateActiveMappedSources. optimistically incrementing may result in premature completion. lets investigate this optimization as a followup PR.", "author": "Scottmitch", "createdAt": "2020-05-13T17:02:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM2MjIxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI3OTk3Mw==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r425279973", "bodyText": "actually we don't expect onNext after termination so we may be able to use this approach. However this code is using a consistent approach with PublisherFlatMapSingle and we should keep them inline ... good candidate for followup PR!", "author": "Scottmitch", "createdAt": "2020-05-14T16:41:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM2MjIxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM2MzI0MA==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r424363240", "bodyText": "same comment as above... consider using decrementAndGet(...)", "author": "normanmaurer", "createdAt": "2020-05-13T11:25:24Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 16, 64, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+\n+        // protected by emitting lock, or only accessed in side the Subscriber thread\n+        private boolean targetTerminated;\n+        private int upstreamDemand;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            signals = newUnboundedMpscQueue(min(2, source.maxConcurrency * source.maxMappedDemand));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else if (pendingDemandUpdater.getAndAccumulate(this, n,\n+                    FlowControlUtils::addWithOverflowProtectionIfNotNegative) == 0) {\n+                drainPending();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            upstreamDemand = source.maxConcurrency;\n+            subscription.request(upstreamDemand);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            final boolean added = subscribers.add(subscriber);\n+            assert added; // FlatMapPublisherSubscriber relies upon object equality and should never fail.\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                if (prevActiveSources < 0) {\n+                    // We have been cancelled, or already completed and the active count flipped to negative, either way\n+                    // we don't want to Subscribe or retain a reference to this Publisher.\n+                    subscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            Throwable delayedCause = null;\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions. This should be Integer.MIN_VALUE to prevent subsequent mapped\n+            // source completion from incrementing the count to 0 or positive as terminateActiveMappedSources flips\n+            // the count to negative to signal to mapped sources we have completed.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            pendingDemand = -1;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                for (FlatMapPublisherSubscriber<T, R> subscriber : subscribers) {\n+                    try {\n+                        subscriber.cancelFromUpstream();\n+                    } catch (Throwable cause) {\n+                        delayedCause = catchUnexpected(delayedCause, cause);\n+                    }\n+                }\n+                subscribers.clear();\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private boolean tryDecrementDemand() {\n+            for (;;) {\n+                final long prevPendingDemand = pendingDemand;\n+                if (prevPendingDemand <= 0) {\n+                    return false;\n+                } else if (pendingDemandUpdater.compareAndSet(this, prevPendingDemand, prevPendingDemand - 1)) {", "originalCommit": "f43cb45b983a07cb11c3cea16b377df2de70c0d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM2NDY5NA==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r424364694", "bodyText": "nit: you could remove all the else as in each block you return.", "author": "normanmaurer", "createdAt": "2020-05-13T11:28:17Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 16, 64, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+\n+        // protected by emitting lock, or only accessed in side the Subscriber thread\n+        private boolean targetTerminated;\n+        private int upstreamDemand;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            signals = newUnboundedMpscQueue(min(2, source.maxConcurrency * source.maxMappedDemand));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else if (pendingDemandUpdater.getAndAccumulate(this, n,\n+                    FlowControlUtils::addWithOverflowProtectionIfNotNegative) == 0) {\n+                drainPending();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            upstreamDemand = source.maxConcurrency;\n+            subscription.request(upstreamDemand);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            final boolean added = subscribers.add(subscriber);\n+            assert added; // FlatMapPublisherSubscriber relies upon object equality and should never fail.\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                if (prevActiveSources < 0) {\n+                    // We have been cancelled, or already completed and the active count flipped to negative, either way\n+                    // we don't want to Subscribe or retain a reference to this Publisher.\n+                    subscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            Throwable delayedCause = null;\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions. This should be Integer.MIN_VALUE to prevent subsequent mapped\n+            // source completion from incrementing the count to 0 or positive as terminateActiveMappedSources flips\n+            // the count to negative to signal to mapped sources we have completed.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            pendingDemand = -1;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                for (FlatMapPublisherSubscriber<T, R> subscriber : subscribers) {\n+                    try {\n+                        subscriber.cancelFromUpstream();\n+                    } catch (Throwable cause) {\n+                        delayedCause = catchUnexpected(delayedCause, cause);\n+                    }\n+                }\n+                subscribers.clear();\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private boolean tryDecrementDemand() {\n+            for (;;) {\n+                final long prevPendingDemand = pendingDemand;\n+                if (prevPendingDemand <= 0) {\n+                    return false;\n+                } else if (pendingDemandUpdater.compareAndSet(this, prevPendingDemand, prevPendingDemand - 1)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        private void tryEmitItem(Object item, FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (tryAcquireLock(emittingLockUpdater, this)) { // fast path. no concurrency, try to skip the queue.\n+                try {\n+                    if (subscriber.hasSignalsQueued() || (needsDemand(item) && !tryDecrementDemand())) {\n+                        subscriber.markSignalsQueued();\n+                        enqueueItem(item); // drain isn't necessary. when demand arrives a drain will be attempted.\n+                    } else {\n+                        final boolean demandConsumed = sendToTarget(item);\n+                        assert demandConsumed == needsDemand(item);\n+                    }\n+                } finally {\n+                    if (!releaseLock(emittingLockUpdater, this)) {\n+                        drainPending();\n+                    }\n+                }\n+            } else { // slow path. there is concurrency, go through the queue to avoid concurrent delivery.\n+                subscriber.markSignalsQueued();\n+                enqueueAndDrain(item);\n+            }\n+        }\n+\n+        private void enqueueItem(Object item) {\n+            if (!signals.offer(item)) {\n+                enqueueFailed(item);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            enqueueItem(item);\n+            drainPending();\n+        }\n+\n+        private void enqueueFailed(Object item) {\n+            QueueFullException exception = new QueueFullException(\"signals\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, true, true);\n+            }\n+        }\n+\n+        private void drainPending() {\n+            Throwable delayedCause = null;\n+            boolean tryAcquire = true;\n+            while (tryAcquire && tryAcquireLock(emittingLockUpdater, this)) {\n+                try {\n+                    final long prevPendingDemand = pendingDemandUpdater.getAndSet(this, 0);\n+                    long emittedCount = 0;\n+                    if (prevPendingDemand < 0) {\n+                        // if we have been cancelled then we avoid delivering any signals, but we still deliver error\n+                        // terminals below by making sure emittedCount == prevPendingDemand.\n+                        pendingDemand = emittedCount = prevPendingDemand;\n+                        signals.clear();\n+                    }\n+                    Object t;\n+                    while (emittedCount < prevPendingDemand && (t = signals.poll()) != null) {\n+                        try {\n+                            if (sendToTarget(t)) {\n+                                ++emittedCount;\n+                            }\n+                        } catch (Throwable cause) {\n+                            delayedCause = catchUnexpected(delayedCause, cause);\n+                        }\n+                    }\n+\n+                    // check if a terminal event is pending, or give back demand.\n+                    if (emittedCount == prevPendingDemand) {\n+                        for (;;) {\n+                            try {\n+                                t = signals.peek();\n+                                if (t == MAPPED_SOURCE_COMPLETE) {\n+                                    signals.poll();\n+                                    tryRequestMoreFromUpstream();\n+                                } else if (t instanceof FlatMapPublisherSubscriber) {\n+                                    signals.poll();\n+                                    ((FlatMapPublisherSubscriber<?, ?>) t).replenishDemandAndClearSignalsQueued();\n+                                } else {\n+                                    break;\n+                                }\n+                            } catch (Throwable cause) {\n+                                delayedCause = catchUnexpected(delayedCause, cause);\n+                            }\n+                        }\n+\n+                        if (t instanceof TerminalNotification) {\n+                            sendToTarget((TerminalNotification) t); // if this throws its OK as we have terminated\n+                        } else {\n+                            t = terminalNotification;\n+                            if (t != null && t != complete()) { // don't wait for demand to process an error\n+                                sendToTarget((TerminalNotification) t); // if this throws its OK as we have terminated\n+                            }\n+                        }\n+                    } else {\n+                        assert emittedCount < prevPendingDemand;\n+                        pendingDemandUpdater.accumulateAndGet(this, prevPendingDemand - emittedCount,\n+                                FlowControlUtils::addWithOverflowProtection);\n+                    }\n+                } finally {\n+                    tryAcquire = !releaseLock(emittingLockUpdater, this);\n+                }\n+            }\n+\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void tryRequestMoreFromUpstream() {\n+            if (--upstreamDemand == 0) { // heuristic to replenish demand when it is exhausted.\n+                assert subscription != null;\n+                upstreamDemand = source.maxConcurrency;\n+                subscription.request(source.maxConcurrency);\n+            }\n+        }\n+\n+        private static boolean needsDemand(Object item) {\n+            return item != MAPPED_SOURCE_COMPLETE &&\n+                    !(item instanceof FlatMapPublisherSubscriber) && !(item instanceof TerminalNotification);\n+        }\n+\n+        private boolean sendToTarget(Object item) {\n+            if (targetTerminated) {\n+                // No notifications past terminal/cancelled\n+                return false;\n+            } else if (item == MAPPED_SOURCE_COMPLETE) {\n+                tryRequestMoreFromUpstream();\n+                return false;\n+            } else if (item instanceof TerminalNotification) {\n+                // Load the terminal notification in case an error happened after an onComplete and we override the\n+                // terminal value.\n+                TerminalNotification terminalNotification = this.terminalNotification;\n+                assert terminalNotification != null;\n+                sendToTarget(terminalNotification);\n+                return false;\n+            } else if (item instanceof FlatMapPublisherSubscriber) {", "originalCommit": "f43cb45b983a07cb11c3cea16b377df2de70c0d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU5NDg5NA==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r424594894", "bodyText": "I'll just keep them as it clarifies the clauses are expected to be mutually exclusive and reduces the number of lines.", "author": "Scottmitch", "createdAt": "2020-05-13T17:04:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM2NDY5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM2NTE1Nw==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r424365157", "bodyText": "same comment as above... consider using addAndGet(...) for XADD.", "author": "normanmaurer", "createdAt": "2020-05-13T11:29:16Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 16, 64, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+\n+        // protected by emitting lock, or only accessed in side the Subscriber thread\n+        private boolean targetTerminated;\n+        private int upstreamDemand;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            signals = newUnboundedMpscQueue(min(2, source.maxConcurrency * source.maxMappedDemand));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else if (pendingDemandUpdater.getAndAccumulate(this, n,\n+                    FlowControlUtils::addWithOverflowProtectionIfNotNegative) == 0) {\n+                drainPending();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            upstreamDemand = source.maxConcurrency;\n+            subscription.request(upstreamDemand);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            final boolean added = subscribers.add(subscriber);\n+            assert added; // FlatMapPublisherSubscriber relies upon object equality and should never fail.\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                if (prevActiveSources < 0) {\n+                    // We have been cancelled, or already completed and the active count flipped to negative, either way\n+                    // we don't want to Subscribe or retain a reference to this Publisher.\n+                    subscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            Throwable delayedCause = null;\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions. This should be Integer.MIN_VALUE to prevent subsequent mapped\n+            // source completion from incrementing the count to 0 or positive as terminateActiveMappedSources flips\n+            // the count to negative to signal to mapped sources we have completed.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            pendingDemand = -1;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                for (FlatMapPublisherSubscriber<T, R> subscriber : subscribers) {\n+                    try {\n+                        subscriber.cancelFromUpstream();\n+                    } catch (Throwable cause) {\n+                        delayedCause = catchUnexpected(delayedCause, cause);\n+                    }\n+                }\n+                subscribers.clear();\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private boolean tryDecrementDemand() {\n+            for (;;) {\n+                final long prevPendingDemand = pendingDemand;\n+                if (prevPendingDemand <= 0) {\n+                    return false;\n+                } else if (pendingDemandUpdater.compareAndSet(this, prevPendingDemand, prevPendingDemand - 1)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        private void tryEmitItem(Object item, FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (tryAcquireLock(emittingLockUpdater, this)) { // fast path. no concurrency, try to skip the queue.\n+                try {\n+                    if (subscriber.hasSignalsQueued() || (needsDemand(item) && !tryDecrementDemand())) {\n+                        subscriber.markSignalsQueued();\n+                        enqueueItem(item); // drain isn't necessary. when demand arrives a drain will be attempted.\n+                    } else {\n+                        final boolean demandConsumed = sendToTarget(item);\n+                        assert demandConsumed == needsDemand(item);\n+                    }\n+                } finally {\n+                    if (!releaseLock(emittingLockUpdater, this)) {\n+                        drainPending();\n+                    }\n+                }\n+            } else { // slow path. there is concurrency, go through the queue to avoid concurrent delivery.\n+                subscriber.markSignalsQueued();\n+                enqueueAndDrain(item);\n+            }\n+        }\n+\n+        private void enqueueItem(Object item) {\n+            if (!signals.offer(item)) {\n+                enqueueFailed(item);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            enqueueItem(item);\n+            drainPending();\n+        }\n+\n+        private void enqueueFailed(Object item) {\n+            QueueFullException exception = new QueueFullException(\"signals\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, true, true);\n+            }\n+        }\n+\n+        private void drainPending() {\n+            Throwable delayedCause = null;\n+            boolean tryAcquire = true;\n+            while (tryAcquire && tryAcquireLock(emittingLockUpdater, this)) {\n+                try {\n+                    final long prevPendingDemand = pendingDemandUpdater.getAndSet(this, 0);\n+                    long emittedCount = 0;\n+                    if (prevPendingDemand < 0) {\n+                        // if we have been cancelled then we avoid delivering any signals, but we still deliver error\n+                        // terminals below by making sure emittedCount == prevPendingDemand.\n+                        pendingDemand = emittedCount = prevPendingDemand;\n+                        signals.clear();\n+                    }\n+                    Object t;\n+                    while (emittedCount < prevPendingDemand && (t = signals.poll()) != null) {\n+                        try {\n+                            if (sendToTarget(t)) {\n+                                ++emittedCount;\n+                            }\n+                        } catch (Throwable cause) {\n+                            delayedCause = catchUnexpected(delayedCause, cause);\n+                        }\n+                    }\n+\n+                    // check if a terminal event is pending, or give back demand.\n+                    if (emittedCount == prevPendingDemand) {\n+                        for (;;) {\n+                            try {\n+                                t = signals.peek();\n+                                if (t == MAPPED_SOURCE_COMPLETE) {\n+                                    signals.poll();\n+                                    tryRequestMoreFromUpstream();\n+                                } else if (t instanceof FlatMapPublisherSubscriber) {\n+                                    signals.poll();\n+                                    ((FlatMapPublisherSubscriber<?, ?>) t).replenishDemandAndClearSignalsQueued();\n+                                } else {\n+                                    break;\n+                                }\n+                            } catch (Throwable cause) {\n+                                delayedCause = catchUnexpected(delayedCause, cause);\n+                            }\n+                        }\n+\n+                        if (t instanceof TerminalNotification) {\n+                            sendToTarget((TerminalNotification) t); // if this throws its OK as we have terminated\n+                        } else {\n+                            t = terminalNotification;\n+                            if (t != null && t != complete()) { // don't wait for demand to process an error\n+                                sendToTarget((TerminalNotification) t); // if this throws its OK as we have terminated\n+                            }\n+                        }\n+                    } else {\n+                        assert emittedCount < prevPendingDemand;\n+                        pendingDemandUpdater.accumulateAndGet(this, prevPendingDemand - emittedCount,\n+                                FlowControlUtils::addWithOverflowProtection);\n+                    }\n+                } finally {\n+                    tryAcquire = !releaseLock(emittingLockUpdater, this);\n+                }\n+            }\n+\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void tryRequestMoreFromUpstream() {\n+            if (--upstreamDemand == 0) { // heuristic to replenish demand when it is exhausted.\n+                assert subscription != null;\n+                upstreamDemand = source.maxConcurrency;\n+                subscription.request(source.maxConcurrency);\n+            }\n+        }\n+\n+        private static boolean needsDemand(Object item) {\n+            return item != MAPPED_SOURCE_COMPLETE &&\n+                    !(item instanceof FlatMapPublisherSubscriber) && !(item instanceof TerminalNotification);\n+        }\n+\n+        private boolean sendToTarget(Object item) {\n+            if (targetTerminated) {\n+                // No notifications past terminal/cancelled\n+                return false;\n+            } else if (item == MAPPED_SOURCE_COMPLETE) {\n+                tryRequestMoreFromUpstream();\n+                return false;\n+            } else if (item instanceof TerminalNotification) {\n+                // Load the terminal notification in case an error happened after an onComplete and we override the\n+                // terminal value.\n+                TerminalNotification terminalNotification = this.terminalNotification;\n+                assert terminalNotification != null;\n+                sendToTarget(terminalNotification);\n+                return false;\n+            } else if (item instanceof FlatMapPublisherSubscriber) {\n+                ((FlatMapPublisherSubscriber<?, ?>) item).replenishDemandAndClearSignalsQueued();\n+                return false;\n+            }\n+            target.onNext(unwrapNullUnchecked(item));\n+            return true;\n+        }\n+\n+        private void sendToTarget(TerminalNotification terminalNotification) {\n+            signals.clear();\n+            targetTerminated = true;\n+            CompositeException de = this.delayedError;\n+            if (de != null) {\n+                de.finishAndThrow();\n+                if (terminalNotification.cause() == de) {\n+                    terminalNotification.terminate(target);\n+                } else {\n+                    terminalNotification.terminate(target, de);\n+                }\n+            } else {\n+                terminalNotification.terminate(target);\n+            }\n+        }\n+\n+        private boolean terminateActiveMappedSources() {\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                assert prevActiveSources >= 0; // otherwise we have seen multiple onComplete signals\n+                if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, -prevActiveSources)) {", "originalCommit": "f43cb45b983a07cb11c3cea16b377df2de70c0d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM2NTQzOA==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r424365438", "bodyText": "same comment as above... consider using incrementAndGet() / decrementAndGet()", "author": "normanmaurer", "createdAt": "2020-05-13T11:29:52Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 16, 64, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+\n+        // protected by emitting lock, or only accessed in side the Subscriber thread\n+        private boolean targetTerminated;\n+        private int upstreamDemand;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            signals = newUnboundedMpscQueue(min(2, source.maxConcurrency * source.maxMappedDemand));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else if (pendingDemandUpdater.getAndAccumulate(this, n,\n+                    FlowControlUtils::addWithOverflowProtectionIfNotNegative) == 0) {\n+                drainPending();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            upstreamDemand = source.maxConcurrency;\n+            subscription.request(upstreamDemand);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            final boolean added = subscribers.add(subscriber);\n+            assert added; // FlatMapPublisherSubscriber relies upon object equality and should never fail.\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                if (prevActiveSources < 0) {\n+                    // We have been cancelled, or already completed and the active count flipped to negative, either way\n+                    // we don't want to Subscribe or retain a reference to this Publisher.\n+                    subscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            Throwable delayedCause = null;\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions. This should be Integer.MIN_VALUE to prevent subsequent mapped\n+            // source completion from incrementing the count to 0 or positive as terminateActiveMappedSources flips\n+            // the count to negative to signal to mapped sources we have completed.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            pendingDemand = -1;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                for (FlatMapPublisherSubscriber<T, R> subscriber : subscribers) {\n+                    try {\n+                        subscriber.cancelFromUpstream();\n+                    } catch (Throwable cause) {\n+                        delayedCause = catchUnexpected(delayedCause, cause);\n+                    }\n+                }\n+                subscribers.clear();\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private boolean tryDecrementDemand() {\n+            for (;;) {\n+                final long prevPendingDemand = pendingDemand;\n+                if (prevPendingDemand <= 0) {\n+                    return false;\n+                } else if (pendingDemandUpdater.compareAndSet(this, prevPendingDemand, prevPendingDemand - 1)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        private void tryEmitItem(Object item, FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (tryAcquireLock(emittingLockUpdater, this)) { // fast path. no concurrency, try to skip the queue.\n+                try {\n+                    if (subscriber.hasSignalsQueued() || (needsDemand(item) && !tryDecrementDemand())) {\n+                        subscriber.markSignalsQueued();\n+                        enqueueItem(item); // drain isn't necessary. when demand arrives a drain will be attempted.\n+                    } else {\n+                        final boolean demandConsumed = sendToTarget(item);\n+                        assert demandConsumed == needsDemand(item);\n+                    }\n+                } finally {\n+                    if (!releaseLock(emittingLockUpdater, this)) {\n+                        drainPending();\n+                    }\n+                }\n+            } else { // slow path. there is concurrency, go through the queue to avoid concurrent delivery.\n+                subscriber.markSignalsQueued();\n+                enqueueAndDrain(item);\n+            }\n+        }\n+\n+        private void enqueueItem(Object item) {\n+            if (!signals.offer(item)) {\n+                enqueueFailed(item);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            enqueueItem(item);\n+            drainPending();\n+        }\n+\n+        private void enqueueFailed(Object item) {\n+            QueueFullException exception = new QueueFullException(\"signals\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, true, true);\n+            }\n+        }\n+\n+        private void drainPending() {\n+            Throwable delayedCause = null;\n+            boolean tryAcquire = true;\n+            while (tryAcquire && tryAcquireLock(emittingLockUpdater, this)) {\n+                try {\n+                    final long prevPendingDemand = pendingDemandUpdater.getAndSet(this, 0);\n+                    long emittedCount = 0;\n+                    if (prevPendingDemand < 0) {\n+                        // if we have been cancelled then we avoid delivering any signals, but we still deliver error\n+                        // terminals below by making sure emittedCount == prevPendingDemand.\n+                        pendingDemand = emittedCount = prevPendingDemand;\n+                        signals.clear();\n+                    }\n+                    Object t;\n+                    while (emittedCount < prevPendingDemand && (t = signals.poll()) != null) {\n+                        try {\n+                            if (sendToTarget(t)) {\n+                                ++emittedCount;\n+                            }\n+                        } catch (Throwable cause) {\n+                            delayedCause = catchUnexpected(delayedCause, cause);\n+                        }\n+                    }\n+\n+                    // check if a terminal event is pending, or give back demand.\n+                    if (emittedCount == prevPendingDemand) {\n+                        for (;;) {\n+                            try {\n+                                t = signals.peek();\n+                                if (t == MAPPED_SOURCE_COMPLETE) {\n+                                    signals.poll();\n+                                    tryRequestMoreFromUpstream();\n+                                } else if (t instanceof FlatMapPublisherSubscriber) {\n+                                    signals.poll();\n+                                    ((FlatMapPublisherSubscriber<?, ?>) t).replenishDemandAndClearSignalsQueued();\n+                                } else {\n+                                    break;\n+                                }\n+                            } catch (Throwable cause) {\n+                                delayedCause = catchUnexpected(delayedCause, cause);\n+                            }\n+                        }\n+\n+                        if (t instanceof TerminalNotification) {\n+                            sendToTarget((TerminalNotification) t); // if this throws its OK as we have terminated\n+                        } else {\n+                            t = terminalNotification;\n+                            if (t != null && t != complete()) { // don't wait for demand to process an error\n+                                sendToTarget((TerminalNotification) t); // if this throws its OK as we have terminated\n+                            }\n+                        }\n+                    } else {\n+                        assert emittedCount < prevPendingDemand;\n+                        pendingDemandUpdater.accumulateAndGet(this, prevPendingDemand - emittedCount,\n+                                FlowControlUtils::addWithOverflowProtection);\n+                    }\n+                } finally {\n+                    tryAcquire = !releaseLock(emittingLockUpdater, this);\n+                }\n+            }\n+\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void tryRequestMoreFromUpstream() {\n+            if (--upstreamDemand == 0) { // heuristic to replenish demand when it is exhausted.\n+                assert subscription != null;\n+                upstreamDemand = source.maxConcurrency;\n+                subscription.request(source.maxConcurrency);\n+            }\n+        }\n+\n+        private static boolean needsDemand(Object item) {\n+            return item != MAPPED_SOURCE_COMPLETE &&\n+                    !(item instanceof FlatMapPublisherSubscriber) && !(item instanceof TerminalNotification);\n+        }\n+\n+        private boolean sendToTarget(Object item) {\n+            if (targetTerminated) {\n+                // No notifications past terminal/cancelled\n+                return false;\n+            } else if (item == MAPPED_SOURCE_COMPLETE) {\n+                tryRequestMoreFromUpstream();\n+                return false;\n+            } else if (item instanceof TerminalNotification) {\n+                // Load the terminal notification in case an error happened after an onComplete and we override the\n+                // terminal value.\n+                TerminalNotification terminalNotification = this.terminalNotification;\n+                assert terminalNotification != null;\n+                sendToTarget(terminalNotification);\n+                return false;\n+            } else if (item instanceof FlatMapPublisherSubscriber) {\n+                ((FlatMapPublisherSubscriber<?, ?>) item).replenishDemandAndClearSignalsQueued();\n+                return false;\n+            }\n+            target.onNext(unwrapNullUnchecked(item));\n+            return true;\n+        }\n+\n+        private void sendToTarget(TerminalNotification terminalNotification) {\n+            signals.clear();\n+            targetTerminated = true;\n+            CompositeException de = this.delayedError;\n+            if (de != null) {\n+                de.finishAndThrow();\n+                if (terminalNotification.cause() == de) {\n+                    terminalNotification.terminate(target);\n+                } else {\n+                    terminalNotification.terminate(target, de);\n+                }\n+            } else {\n+                terminalNotification.terminate(target);\n+            }\n+        }\n+\n+        private boolean terminateActiveMappedSources() {\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                assert prevActiveSources >= 0; // otherwise we have seen multiple onComplete signals\n+                if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, -prevActiveSources)) {\n+                    return prevActiveSources == 0;\n+                }\n+            }\n+        }\n+\n+        private boolean decrementActiveMappedSources() {\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                assert prevActiveSources != 0;\n+                if (prevActiveSources > 0) {\n+                    if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources - 1)) {\n+                        return false;\n+                    }\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    return prevActiveSources == -1;\n+                }", "originalCommit": "f43cb45b983a07cb11c3cea16b377df2de70c0d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM2NTcxMA==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r424365710", "bodyText": "nit: final ?", "author": "normanmaurer", "createdAt": "2020-05-13T11:30:26Z", "path": "servicetalk-concurrent-api/src/test/java/io/servicetalk/concurrent/api/PublisherFlatMapMergeTest.java", "diffHunk": "@@ -0,0 +1,799 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.PublisherSource.Subscriber;\n+import io.servicetalk.concurrent.internal.DeliberateException;\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.IntStream;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.PublisherSource.Subscription;\n+import static io.servicetalk.concurrent.api.Publisher.from;\n+import static io.servicetalk.concurrent.api.Publisher.range;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.api.VerificationTestUtils.verifyOriginalAndSuppressedCauses;\n+import static io.servicetalk.concurrent.api.VerificationTestUtils.verifySuppressed;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.sameInstance;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+public class PublisherFlatMapMergeTest {\n+    private static final long TERMINAL_POLL_MS = 10;\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+    @Nullable\n+    private static ExecutorService executorService;\n+    @Nullable\n+    private static Executor executor;\n+\n+    private final TestCollectingPublisherSubscriber<Integer> subscriber = new TestCollectingPublisherSubscriber<>();\n+    private TestPublisher<Integer> publisher = new TestPublisher<>();", "originalCommit": "f43cb45b983a07cb11c3cea16b377df2de70c0d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU5NTQ3NQ==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r424595475", "bodyText": "it is re-assigned in some tests", "author": "Scottmitch", "createdAt": "2020-05-13T17:05:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM2NTcxMA=="}], "type": "inlineReview"}, {"oid": "7093c619b2f0d19dc4a3f7373d86e0f0171f624f", "url": "https://github.com/apple/servicetalk/commit/7093c619b2f0d19dc4a3f7373d86e0f0171f624f", "message": "update transferPendingToSuppressed() method name", "committedDate": "2020-05-15T20:58:47Z", "type": "forcePushed"}, {"oid": "9996ed4b5a3cd8db65bfe1d2c33d042fd0461a7d", "url": "https://github.com/apple/servicetalk/commit/9996ed4b5a3cd8db65bfe1d2c33d042fd0461a7d", "message": "update transferPendingToSuppressed() method name", "committedDate": "2020-06-17T00:44:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzMDQ4MQ==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r436430481", "bodyText": "(potentially of a different type)\n\nFrom the perspective of this method, the types are different (T and R) whether in reality T == R is kindda irrelevant. Do we need to mention this here?", "author": "NiteshKant", "createdAt": "2020-06-08T02:20:51Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Publisher.java", "diffHunk": "@@ -188,6 +188,156 @@ protected Publisher() {\n         return new ResumePublisher<>(this, nextFactory, executor);\n     }\n \n+    /**\n+     * Each element of this {@link Publisher} is mapped into a {@link Publisher} (potentially of a different type) and", "originalCommit": "7093c619b2f0d19dc4a3f7373d86e0f0171f624f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzMDk0NA==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r436430944", "bodyText": "The language here is different than flatMapMergeSingle in general which is like:\n     * Turns every item emitted by this {@link Publisher} into a {@link Single} and emits the items emitted by each of\n     * those {@link Single}s.\n\nCan we be consistent?\nAlso: it is missing the relevant part of the doc from flatMapMergeSingle:\n\"To control the amount of concurrent processing done by this operator see\"", "author": "NiteshKant", "createdAt": "2020-06-08T02:24:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzMDQ4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM1NDY2MA==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r450354660", "bodyText": "I will make them consistent. I prefer using the operator method name in the description (e.g. flatten and map) to make the method/operator naming more clear (otherwise flatMap can be a bit esoteric if you are not familiar with these functional concepts).", "author": "Scottmitch", "createdAt": "2020-07-06T16:52:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzMDQ4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzMjEyMg==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r436432122", "bodyText": "As we are explicitly creating a new Subscriber for each onNext, why do we need explicit Set semantics? Is the intent here, faster lookups?", "author": "NiteshKant", "createdAt": "2020-06-08T02:31:31Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 16, 64, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+\n+        // protected by emitting lock, or only accessed inside the Subscriber thread\n+        private boolean targetTerminated;\n+        private int upstreamDemand;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;", "originalCommit": "7093c619b2f0d19dc4a3f7373d86e0f0171f624f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM2ODc5MA==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r450368790", "bodyText": "Duplicate Subscribers are not supported, mapped Subscribers are removed when they terminate (random order), and the cardinality for the general implementation is not strictly limited. I had a specialized collection for smaller concurrency cardinalities but decided to back this out for now for simplicity.", "author": "Scottmitch", "createdAt": "2020-07-06T17:18:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzMjEyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0ODg1NA==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r452448854", "bodyText": "the approach has changed due to offline discussions. ptal", "author": "Scottmitch", "createdAt": "2020-07-09T19:43:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzMjEyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzMjQxMg==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r436432412", "bodyText": "nit: use the name sourceRequested as we use elsewhere?", "author": "NiteshKant", "createdAt": "2020-06-08T02:33:39Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 16, 64, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+\n+        // protected by emitting lock, or only accessed inside the Subscriber thread\n+        private boolean targetTerminated;\n+        private int upstreamDemand;", "originalCommit": "7093c619b2f0d19dc4a3f7373d86e0f0171f624f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzNjM3OQ==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r436436379", "bodyText": "I think it is super confusing to add the subscriber itself to the signals queue.", "author": "NiteshKant", "createdAt": "2020-06-08T02:58:13Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 16, 64, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+\n+        // protected by emitting lock, or only accessed inside the Subscriber thread\n+        private boolean targetTerminated;\n+        private int upstreamDemand;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            signals = newUnboundedMpscQueue(min(2, source.maxConcurrency * source.maxMappedDemand));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>(min(16, source.maxConcurrency)));\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else if (pendingDemandUpdater.getAndAccumulate(this, n,\n+                    FlowControlUtils::addWithOverflowProtectionIfNotNegative) == 0) {\n+                drainPending();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            upstreamDemand = source.maxConcurrency;\n+            subscription.request(upstreamDemand);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            final boolean added = subscribers.add(subscriber);\n+            assert added; // FlatMapPublisherSubscriber relies upon object equality and should never fail.\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                if (prevActiveSources < 0) {\n+                    // We have been cancelled, or already completed and the active count flipped to negative, either way\n+                    // we don't want to Subscribe or retain a reference to this Publisher.\n+                    subscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            Throwable delayedCause = null;\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions. This should be Integer.MIN_VALUE to prevent subsequent mapped\n+            // source completion from incrementing the count to 0 or positive as terminateActiveMappedSources flips\n+            // the count to negative to signal to mapped sources we have completed.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            pendingDemand = -1;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                for (FlatMapPublisherSubscriber<T, R> subscriber : subscribers) {\n+                    try {\n+                        subscriber.cancelFromUpstream();\n+                    } catch (Throwable cause) {\n+                        delayedCause = catchUnexpected(delayedCause, cause);\n+                    }\n+                }\n+                subscribers.clear();\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private boolean tryDecrementDemand() {\n+            for (;;) {\n+                final long prevPendingDemand = pendingDemand;\n+                if (prevPendingDemand <= 0) {\n+                    return false;\n+                } else if (pendingDemandUpdater.compareAndSet(this, prevPendingDemand, prevPendingDemand - 1)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        private void tryEmitItem(Object item, FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (tryAcquireLock(emittingLockUpdater, this)) { // fast path. no concurrency, try to skip the queue.\n+                try {\n+                    if (subscriber.hasSignalsQueued() || (needsDemand(item) && !tryDecrementDemand())) {\n+                        subscriber.markSignalsQueued();\n+                        enqueueItem(item); // drain isn't necessary. when demand arrives a drain will be attempted.\n+                    } else {\n+                        final boolean demandConsumed = sendToTarget(item);\n+                        assert demandConsumed == needsDemand(item);\n+                    }\n+                } finally {\n+                    if (!releaseLock(emittingLockUpdater, this)) {\n+                        drainPending();\n+                    }\n+                }\n+            } else { // slow path. there is concurrency, go through the queue to avoid concurrent delivery.\n+                subscriber.markSignalsQueued();\n+                enqueueAndDrain(item);\n+            }\n+        }\n+\n+        private void enqueueItem(Object item) {\n+            if (!signals.offer(item)) {\n+                enqueueFailed(item);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            enqueueItem(item);\n+            drainPending();\n+        }\n+\n+        private void enqueueFailed(Object item) {\n+            QueueFullException exception = new QueueFullException(\"signals\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, true, true);\n+            }\n+        }\n+\n+        private void drainPending() {\n+            Throwable delayedCause = null;\n+            boolean tryAcquire = true;\n+            while (tryAcquire && tryAcquireLock(emittingLockUpdater, this)) {\n+                try {\n+                    final long prevPendingDemand = pendingDemandUpdater.getAndSet(this, 0);\n+                    long emittedCount = 0;\n+                    if (prevPendingDemand < 0) {\n+                        // if we have been cancelled then we avoid delivering any signals, but we still deliver error\n+                        // terminals below by making sure emittedCount == prevPendingDemand.\n+                        pendingDemand = emittedCount = prevPendingDemand;\n+                        signals.clear();\n+                    }\n+                    Object t;\n+                    while (emittedCount < prevPendingDemand && (t = signals.poll()) != null) {\n+                        try {\n+                            if (sendToTarget(t)) {\n+                                ++emittedCount;\n+                            }\n+                        } catch (Throwable cause) {\n+                            delayedCause = catchUnexpected(delayedCause, cause);\n+                        }\n+                    }\n+\n+                    // check if a terminal event is pending, or give back demand.\n+                    if (emittedCount == prevPendingDemand) {\n+                        for (;;) {\n+                            try {\n+                                t = signals.peek();\n+                                if (t == MAPPED_SOURCE_COMPLETE) {\n+                                    signals.poll();\n+                                    tryRequestMoreFromUpstream();\n+                                } else if (t instanceof FlatMapPublisherSubscriber) {\n+                                    signals.poll();\n+                                    ((FlatMapPublisherSubscriber<?, ?>) t).replenishDemandAndClearSignalsQueued();\n+                                } else {\n+                                    break;\n+                                }\n+                            } catch (Throwable cause) {\n+                                delayedCause = catchUnexpected(delayedCause, cause);\n+                            }\n+                        }\n+\n+                        if (t instanceof TerminalNotification) {\n+                            sendToTarget((TerminalNotification) t); // if this throws its OK as we have terminated\n+                        } else {\n+                            t = terminalNotification;\n+                            if (t != null && t != complete()) { // don't wait for demand to process an error\n+                                sendToTarget((TerminalNotification) t); // if this throws its OK as we have terminated\n+                            }\n+                        }\n+                    } else {\n+                        assert emittedCount < prevPendingDemand;\n+                        pendingDemandUpdater.accumulateAndGet(this, prevPendingDemand - emittedCount,\n+                                FlowControlUtils::addWithOverflowProtection);\n+                    }\n+                } finally {\n+                    tryAcquire = !releaseLock(emittingLockUpdater, this);\n+                }\n+            }\n+\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void tryRequestMoreFromUpstream() {\n+            if (--upstreamDemand == 0) { // heuristic to replenish demand when it is exhausted.\n+                assert subscription != null;\n+                upstreamDemand = source.maxConcurrency;\n+                subscription.request(source.maxConcurrency);\n+            }\n+        }\n+\n+        private static boolean needsDemand(Object item) {\n+            return item != MAPPED_SOURCE_COMPLETE &&\n+                    !(item instanceof FlatMapPublisherSubscriber) && !(item instanceof TerminalNotification);\n+        }\n+\n+        private boolean sendToTarget(Object item) {\n+            if (targetTerminated) {\n+                // No notifications past terminal/cancelled\n+                return false;\n+            } else if (item == MAPPED_SOURCE_COMPLETE) {\n+                tryRequestMoreFromUpstream();\n+                return false;\n+            } else if (item instanceof TerminalNotification) {\n+                // Load the terminal notification in case an error happened after an onComplete and we override the\n+                // terminal value.\n+                TerminalNotification terminalNotification = this.terminalNotification;\n+                assert terminalNotification != null;\n+                sendToTarget(terminalNotification);\n+                return false;\n+            } else if (item instanceof FlatMapPublisherSubscriber) {\n+                ((FlatMapPublisherSubscriber<?, ?>) item).replenishDemandAndClearSignalsQueued();\n+                return false;\n+            }\n+            target.onNext(unwrapNullUnchecked(item));\n+            return true;\n+        }\n+\n+        private void sendToTarget(TerminalNotification terminalNotification) {\n+            signals.clear();\n+            targetTerminated = true;\n+            CompositeException de = this.delayedError;\n+            if (de != null) {\n+                de.transferPendingToSuppressed();\n+                if (terminalNotification.cause() == de) {\n+                    terminalNotification.terminate(target);\n+                } else {\n+                    terminalNotification.terminate(target, de);\n+                }\n+            } else {\n+                terminalNotification.terminate(target);\n+            }\n+        }\n+\n+        private boolean terminateActiveMappedSources() {\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                assert prevActiveSources >= 0; // otherwise we have seen multiple onComplete signals\n+                if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, -prevActiveSources)) {\n+                    return prevActiveSources == 0;\n+                }\n+            }\n+        }\n+\n+        private boolean decrementActiveMappedSources() {\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                assert prevActiveSources != 0;\n+                if (prevActiveSources > 0) {\n+                    if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources - 1)) {\n+                        return false;\n+                    }\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    return prevActiveSources == -1;\n+                }\n+            }\n+        }\n+\n+        private boolean removeSubscriber(final FlatMapPublisherSubscriber<T, R> subscriber) {\n+            return subscribers.remove(subscriber) && decrementActiveMappedSources();\n+        }\n+\n+        private static final class FlatMapPublisherSubscriber<T, R> implements Subscriber<R> {\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicIntegerFieldUpdater<FlatMapPublisherSubscriber> pendingOnNextUpdater =\n+                    AtomicIntegerFieldUpdater.newUpdater(FlatMapPublisherSubscriber.class, \"pendingOnNext\");\n+\n+            private final FlatMapSubscriber<T, R> parent;\n+            private final DelayedSubscription subscription;\n+            private volatile int pendingOnNext;\n+            /**\n+             * visibility provided by the {@link Subscriber} thread in {@link #onNext(Object)}, and then by\n+             * {@link #pendingDemand} when written to from {@link #replenishDemandAndClearSignalsQueued()} (potentially\n+             * called by a different thread). Demand is exhausted before {@link #replenishDemandAndClearSignalsQueued()}\n+             * is called, and that method triggers {@link #request(long)} and\n+             * <a href=\"https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#1.1\">there\u2019s a\n+             * happens-before relationship between requesting elements and receiving elements</a>.\n+             */\n+            private boolean signalsQueued;\n+\n+            FlatMapPublisherSubscriber(FlatMapSubscriber<T, R> parent) {\n+                this.parent = parent;\n+                subscription = new DelayedSubscription();\n+            }\n+\n+            void cancelFromUpstream() {\n+                subscription.cancel();\n+            }\n+\n+            void replenishDemandAndClearSignalsQueued() {\n+                // clearSignalsQueued must be before pendingOnNext for visibility with onNext.\n+                clearSignalsQueued();\n+                final int prevPendingOnNext = pendingOnNextUpdater.getAndSet(this, 0);\n+                if (prevPendingOnNext > 0) {\n+                    subscription.request(prevPendingOnNext);\n+                }\n+            }\n+\n+            void clearSignalsQueued() {\n+                signalsQueued = false;\n+            }\n+\n+            void markSignalsQueued() {\n+                signalsQueued = true;\n+            }\n+\n+            boolean hasSignalsQueued() {\n+                return signalsQueued;\n+            }\n+\n+            @Override\n+            public void onSubscribe(final Subscription s) {\n+                subscription.delayedSubscription(ConcurrentSubscription.wrap(s));\n+                subscription.request(parent.source.maxMappedDemand);\n+            }\n+\n+            @Override\n+            public void onNext(@Nullable final R r) {\n+                // pendingOnNext must be updated before tryEmitItem for visibility of signalsQueued. signalsQueued\n+                // is updated in replenishDemandAndClearSignalsQueued (potentially from another thread) before\n+                // pendingOnNext is reset and we want signalsQueued to be visible to this thread.\n+                //\n+                // Heuristic which triggers replenishDemandAndClearSignalsQueued when demand is consumed. It must be\n+                // when all demand is consumed in order for clearSignalsQueued to work properly.\n+                final boolean doReplenish = pendingOnNextUpdater.incrementAndGet(this) == parent.source.maxMappedDemand;\n+                parent.tryEmitItem(wrapNull(r), this);\n+                if (doReplenish) {\n+                    parent.tryEmitItem(this, this);", "originalCommit": "7093c619b2f0d19dc4a3f7373d86e0f0171f624f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM3MjAxNw==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r450372017", "bodyText": "This is done to invoke replenishDemandAndClearSignalsQueued after the exhausted demand has been processed to avoid requesting more than max concurrency (the state for demand is maintained in each Subscriber). I added some comments in the code to clarify, does this address the confusion, do you have a suggestion to improve?", "author": "Scottmitch", "createdAt": "2020-07-06T17:24:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzNjM3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzODA0MA==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r436438040", "bodyText": "The approach here to account for the delta between requested and sourceRequested is different than flatMapMergeSingle(). What is the reason to take a different approach as opposed to the established approach which enables reuse of existing utilities => SubscriberUtils.calculateSourceRequested()?", "author": "NiteshKant", "createdAt": "2020-06-08T03:08:46Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 16, 64, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =", "originalCommit": "7093c619b2f0d19dc4a3f7373d86e0f0171f624f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM3NTM4Mg==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r450375382", "bodyText": "This operator is different from flatMapMergeSingle in that the demand isn't tightly coupled between mapped async sources and demand from downstream. The operator's demand on async sources is managed independently from downstream demand and limited by maxMappedDemand, at the cost of queuing internally. Due to these differences the SubscriberUtils.calculateSourceRequested() utilities are not needed in the current implementation.\nA previous implementation we discussed offline was distributing downstream demand to mapped sources (to avoid the queuing) but this requires a heuristic to distribute demand evenly and may lead to \"dead locks\" if some mapped sources don't deliver signals in a timely manner.", "author": "Scottmitch", "createdAt": "2020-07-06T17:31:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzODA0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0ODY1Mw==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r452448653", "bodyText": "the approach has changed due to offline discussions. ptal.", "author": "Scottmitch", "createdAt": "2020-07-09T19:42:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzODA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkwMDc0Ng==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r443900746", "bodyText": "It seems we are only requesting more from upstream if all the previously emitted Publishers from flatMap have completed. This means that one pending work can hold up from potentially doing more work. Is this intentional?", "author": "NiteshKant", "createdAt": "2020-06-23T00:48:43Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 16, 64, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+\n+        // protected by emitting lock, or only accessed inside the Subscriber thread\n+        private boolean targetTerminated;\n+        private int upstreamDemand;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            signals = newUnboundedMpscQueue(min(2, source.maxConcurrency * source.maxMappedDemand));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>(min(16, source.maxConcurrency)));\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else if (pendingDemandUpdater.getAndAccumulate(this, n,\n+                    FlowControlUtils::addWithOverflowProtectionIfNotNegative) == 0) {\n+                drainPending();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            upstreamDemand = source.maxConcurrency;\n+            subscription.request(upstreamDemand);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            final boolean added = subscribers.add(subscriber);\n+            assert added; // FlatMapPublisherSubscriber relies upon object equality and should never fail.\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                if (prevActiveSources < 0) {\n+                    // We have been cancelled, or already completed and the active count flipped to negative, either way\n+                    // we don't want to Subscribe or retain a reference to this Publisher.\n+                    subscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            Throwable delayedCause = null;\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions. This should be Integer.MIN_VALUE to prevent subsequent mapped\n+            // source completion from incrementing the count to 0 or positive as terminateActiveMappedSources flips\n+            // the count to negative to signal to mapped sources we have completed.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            pendingDemand = -1;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                for (FlatMapPublisherSubscriber<T, R> subscriber : subscribers) {\n+                    try {\n+                        subscriber.cancelFromUpstream();\n+                    } catch (Throwable cause) {\n+                        delayedCause = catchUnexpected(delayedCause, cause);\n+                    }\n+                }\n+                subscribers.clear();\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private boolean tryDecrementDemand() {\n+            for (;;) {\n+                final long prevPendingDemand = pendingDemand;\n+                if (prevPendingDemand <= 0) {\n+                    return false;\n+                } else if (pendingDemandUpdater.compareAndSet(this, prevPendingDemand, prevPendingDemand - 1)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        private void tryEmitItem(Object item, FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (tryAcquireLock(emittingLockUpdater, this)) { // fast path. no concurrency, try to skip the queue.\n+                try {\n+                    if (subscriber.hasSignalsQueued() || (needsDemand(item) && !tryDecrementDemand())) {\n+                        subscriber.markSignalsQueued();\n+                        enqueueItem(item); // drain isn't necessary. when demand arrives a drain will be attempted.\n+                    } else {\n+                        final boolean demandConsumed = sendToTarget(item);\n+                        assert demandConsumed == needsDemand(item);\n+                    }\n+                } finally {\n+                    if (!releaseLock(emittingLockUpdater, this)) {\n+                        drainPending();\n+                    }\n+                }\n+            } else { // slow path. there is concurrency, go through the queue to avoid concurrent delivery.\n+                subscriber.markSignalsQueued();\n+                enqueueAndDrain(item);\n+            }\n+        }\n+\n+        private void enqueueItem(Object item) {\n+            if (!signals.offer(item)) {\n+                enqueueFailed(item);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            enqueueItem(item);\n+            drainPending();\n+        }\n+\n+        private void enqueueFailed(Object item) {\n+            QueueFullException exception = new QueueFullException(\"signals\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, true, true);\n+            }\n+        }\n+\n+        private void drainPending() {\n+            Throwable delayedCause = null;\n+            boolean tryAcquire = true;\n+            while (tryAcquire && tryAcquireLock(emittingLockUpdater, this)) {\n+                try {\n+                    final long prevPendingDemand = pendingDemandUpdater.getAndSet(this, 0);\n+                    long emittedCount = 0;\n+                    if (prevPendingDemand < 0) {\n+                        // if we have been cancelled then we avoid delivering any signals, but we still deliver error\n+                        // terminals below by making sure emittedCount == prevPendingDemand.\n+                        pendingDemand = emittedCount = prevPendingDemand;\n+                        signals.clear();\n+                    }\n+                    Object t;\n+                    while (emittedCount < prevPendingDemand && (t = signals.poll()) != null) {\n+                        try {\n+                            if (sendToTarget(t)) {\n+                                ++emittedCount;\n+                            }\n+                        } catch (Throwable cause) {\n+                            delayedCause = catchUnexpected(delayedCause, cause);\n+                        }\n+                    }\n+\n+                    // check if a terminal event is pending, or give back demand.\n+                    if (emittedCount == prevPendingDemand) {\n+                        for (;;) {\n+                            try {\n+                                t = signals.peek();\n+                                if (t == MAPPED_SOURCE_COMPLETE) {\n+                                    signals.poll();\n+                                    tryRequestMoreFromUpstream();\n+                                } else if (t instanceof FlatMapPublisherSubscriber) {\n+                                    signals.poll();\n+                                    ((FlatMapPublisherSubscriber<?, ?>) t).replenishDemandAndClearSignalsQueued();\n+                                } else {\n+                                    break;\n+                                }\n+                            } catch (Throwable cause) {\n+                                delayedCause = catchUnexpected(delayedCause, cause);\n+                            }\n+                        }\n+\n+                        if (t instanceof TerminalNotification) {\n+                            sendToTarget((TerminalNotification) t); // if this throws its OK as we have terminated\n+                        } else {\n+                            t = terminalNotification;\n+                            if (t != null && t != complete()) { // don't wait for demand to process an error\n+                                sendToTarget((TerminalNotification) t); // if this throws its OK as we have terminated\n+                            }\n+                        }\n+                    } else {\n+                        assert emittedCount < prevPendingDemand;\n+                        pendingDemandUpdater.accumulateAndGet(this, prevPendingDemand - emittedCount,\n+                                FlowControlUtils::addWithOverflowProtection);\n+                    }\n+                } finally {\n+                    tryAcquire = !releaseLock(emittingLockUpdater, this);\n+                }\n+            }\n+\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void tryRequestMoreFromUpstream() {\n+            if (--upstreamDemand == 0) { // heuristic to replenish demand when it is exhausted.", "originalCommit": "9996ed4b5a3cd8db65bfe1d2c33d042fd0461a7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQwMjQzMw==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r450402433", "bodyText": "Good question. This is not intentional and the motivation for this heuristic was to batch demand to avoid request(1) when each mapped source completes. I'll switch to batching demand within the draining of the signal delivery queue. Unless there is concurrency on completion this will digress to request(1) but we can enhance later with something more sophisticated batching (e.g. configurable heuristic).", "author": "Scottmitch", "createdAt": "2020-07-06T18:23:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkwMDc0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ1MDc1Ng==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r444450756", "bodyText": "This approach of child Publishers requesting maxMappedDemand irrespective of downstream demand will tend to have larger buffers irrespective of how items are requested.\nAn alternative approach could be to take a minMappedDemand and then split the downstream demand across maxConcurrency number of sources.\n\nFor maxConcurrency == 8 and downstream demand 16; we request 2 from each child Publisher.\nEach time a child Publisher emits as much as requested we split the remaining demand again in maxConcurrency. If maxConcurrency > downstream demand then request minMappedDemand.\n\nThis approach should result in smaller queues since we request depending on actual downstream demand as opposed to static maxMappedDemand. Additionally, we can default to lower defaults; maxConcurrency: 8 and minMappedDemand: 1. The negative is that if we do not have as many items as maxConcurrency we end up requesting in smaller chunks.\nWDYT?", "author": "NiteshKant", "createdAt": "2020-06-23T19:16:32Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 16, 64, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+\n+        // protected by emitting lock, or only accessed inside the Subscriber thread\n+        private boolean targetTerminated;\n+        private int upstreamDemand;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            signals = newUnboundedMpscQueue(min(2, source.maxConcurrency * source.maxMappedDemand));", "originalCommit": "9996ed4b5a3cd8db65bfe1d2c33d042fd0461a7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTk4MTMzOA==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r451981338", "bodyText": "discussed offline and adopted this approach with trade-offs documented in javadocs", "author": "Scottmitch", "createdAt": "2020-07-09T05:59:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ1MDc1Ng=="}], "type": "inlineReview"}, {"oid": "22d13254273fbefa315134f571f9397f0d29bbd9", "url": "https://github.com/apple/servicetalk/commit/22d13254273fbefa315134f571f9397f0d29bbd9", "message": "first cut, adjust mapped demand to account for downstream demand", "committedDate": "2020-07-09T05:32:04Z", "type": "forcePushed"}, {"oid": "899fd50f31612ccaede56a21176897600a3c0dfb", "url": "https://github.com/apple/servicetalk/commit/899fd50f31612ccaede56a21176897600a3c0dfb", "message": "first cut, adjust mapped demand to account for downstream demand", "committedDate": "2020-07-09T05:56:27Z", "type": "forcePushed"}, {"oid": "d093ba0ab90f1f68b8283cae0bf7b481f84cd338", "url": "https://github.com/apple/servicetalk/commit/d093ba0ab90f1f68b8283cae0bf7b481f84cd338", "message": "first cut, adjust mapped demand to account for downstream demand", "committedDate": "2020-07-09T06:13:01Z", "type": "forcePushed"}, {"oid": "5c7a1b18a399929747b22e7c2d8ea16740b227d1", "url": "https://github.com/apple/servicetalk/commit/5c7a1b18a399929747b22e7c2d8ea16740b227d1", "message": "first cut, adjust mapped demand to account for downstream demand", "committedDate": "2020-07-09T15:44:57Z", "type": "forcePushed"}, {"oid": "0fa00306b986d647b69e9ead71e915494ea62db2", "url": "https://github.com/apple/servicetalk/commit/0fa00306b986d647b69e9ead71e915494ea62db2", "message": "first cut, adjust mapped demand to account for downstream demand", "committedDate": "2020-07-11T14:11:41Z", "type": "forcePushed"}, {"oid": "75967e13b40d74222d713365f3b7a28068ce30b6", "url": "https://github.com/apple/servicetalk/commit/75967e13b40d74222d713365f3b7a28068ce30b6", "message": "first cut, adjust mapped demand to account for downstream demand", "committedDate": "2020-07-29T00:25:48Z", "type": "forcePushed"}, {"oid": "5bf903babe582ed3a0eba43fe2b5ccf19653a19c", "url": "https://github.com/apple/servicetalk/commit/5bf903babe582ed3a0eba43fe2b5ccf19653a19c", "message": "first cut, adjust mapped demand to account for downstream demand", "committedDate": "2020-07-29T00:30:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ1NDg0MQ==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r460454841", "bodyText": "The signalsQueued flag here is to essentially cache the state that there is not enough pendingDemand to emit, rite?\nThis will be effective for cases when demand < maxConcurrency. Seems pretty premature (1 volatile read/cas vs extra state management) for a specific case or am I missing something?", "author": "NiteshKant", "createdAt": "2020-07-25T22:59:05Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,661 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * Implementation of {@link Publisher#flatMapMerge(Function)}.\n+ * <p>\n+ * This implementation makes some trade-offs that may have performance/memory impacts. Demand distributed to mapped\n+ * {@link Publisher}s is dynamic and correlates to downstream demand. This dynamic behavior is targeted toward use cases\n+ * where:\n+ * <ul>\n+ *     <li>{@link Subscriber#onNext(Object) onNext Objects} consume non trivial amount of memory relative to the memory\n+ *     to manage the {@link FlatMapSubscriber#hungrySubscribers} queue (e.g. network buffer, serialized POJO)</li>\n+ *     <li>downstream demand is available before signals from mapped sources are available\n+ *     (e.g. over a network boundary)</li>\n+ * </ul>\n+ * Scenarios where downstream demand is provided in small/slow increments relative to the amount of signals from mapped\n+ * Sources, or mapped Sources are backed by in memory content are expected to incur some additional overhead for\n+ * {@link FlatMapSubscriber#hungrySubscribers queue} management.\n+ *\n+ * @param <T> Type of original {@link Publisher}.\n+ * @param <R> Type of {@link Publisher} returned by the operator.\n+ */\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int minMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 8, 8, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int minMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (minMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"minMappedDemand: \" + minMappedDemand + \" (expected >0)\");\n+        }\n+        this.minMappedDemand = minMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> requestingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"requestingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> mappedDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"mappedDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int requestingLock;\n+        private volatile long pendingDemand;\n+        private volatile long mappedDemand;\n+\n+        // protected by emitting lock, or only accessed inside the Subscriber thread\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final DynamicCompositeCancellable cancellableSubscribers;\n+        private final Queue<FlatMapPublisherSubscriber<T, R>> hungrySubscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            signals = newUnboundedMpscQueue(4);\n+            hungrySubscribers = newUnboundedMpscQueue(4);\n+            cancellableSubscribers = new SetDynamicCompositeCancellable(min(16, source.maxConcurrency));\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                // If we transitioned from no demand, to some demand, then we should try to drain the queues which\n+                // may have signals pending due to previous over-request.\n+                if (pendingDemandUpdater.getAndAccumulate(this, n,\n+                        FlowControlUtils::addWithOverflowProtectionIfNotNegative) == 0) {\n+                    drainPending();\n+                }\n+                if (mappedDemandUpdater.getAndAccumulate(this, n,\n+                        FlowControlUtils::addWithOverflowProtection) == 0) {\n+                    distributeMappedDemand();\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            if (!cancellableSubscribers.add(subscriber)) {\n+                return;\n+            }\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                if (prevActiveSources < 0) {\n+                    // We have been cancelled, or already completed and the active count flipped to negative, either\n+                    // way we don't want to Subscribe or retain a reference to this Publisher.\n+                    cancellableSubscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private long reserveMappedDemand() {\n+            return mappedDemandUpdater.getAndSet(this, 0);\n+        }\n+\n+        private int reserveMappedDemandQuota() {\n+            for (;;) {\n+                final long prevDemand = mappedDemand;\n+                if (prevDemand <= 0) {\n+                    return 0;\n+                }\n+                final int quota = calculateRequestNQuota(prevDemand);\n+                if (mappedDemandUpdater.compareAndSet(this, prevDemand, prevDemand - quota)) {\n+                    return quota;\n+                }\n+            }\n+        }\n+\n+        private void distributeMappedDemand(FlatMapPublisherSubscriber<T, R> hungrySubscriber) {\n+            final int quota = reserveMappedDemandQuota();\n+            if (quota > 0) {\n+                final int usedQuota = hungrySubscriber.request(quota);\n+                if (usedQuota < quota && mappedDemandUpdater.getAndAccumulate(this, quota - usedQuota,\n+                        FlowControlUtils::addWithOverflowProtection) == 0) {\n+                    // If we gave some back and transitioned from 0 demand, we need to try to distribute demand\n+                    // in case other hungry subscribers were added in the mean time\n+                    // (since we have not acquired the requestingLock).\n+                    distributeMappedDemand();\n+                }\n+            } else { // slow path. no demand, add to queue and process later when demand arrives.\n+                hungrySubscribers.add(hungrySubscriber);\n+                distributeMappedDemand();\n+            }\n+        }\n+\n+        private void distributeMappedDemand() {\n+            Throwable delayedCause = null;\n+            boolean tryAcquire = true;\n+            while (tryAcquire && tryAcquireLock(requestingLockUpdater, this)) {\n+                try {\n+                    final long availableRequestN = reserveMappedDemand();\n+                    if (availableRequestN > 0) {\n+                        long remainingRequestN = availableRequestN;\n+                        final int quota = calculateRequestNQuota(availableRequestN);\n+                        FlatMapPublisherSubscriber<T, R> hungrySubscriber;\n+                        while ((hungrySubscriber = hungrySubscribers.poll()) != null) {\n+                            remainingRequestN -= hungrySubscriber.request(quota);\n+                        }\n+                        if (remainingRequestN > 0) {\n+                            mappedDemandUpdater.accumulateAndGet(this, remainingRequestN,\n+                                    FlowControlUtils::addWithOverflowProtection);\n+                        }\n+                    }\n+                } catch (Throwable cause) {\n+                    delayedCause = catchUnexpected(delayedCause, cause);\n+                } finally {\n+                    tryAcquire = !releaseLock(requestingLockUpdater, this);\n+                }\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private int calculateRequestNQuota(long availableRequestN) {\n+            // Get an approximate quota to distribute to each active mapped subscriber. If\n+            // activeMappedSources changes (subscriber added or terminated) we will re-distribute.\n+            final int prevActiveSources = activeMappedSources;\n+            return (int) min(Integer.MAX_VALUE,\n+                    max(prevActiveSources > 0 ? availableRequestN / prevActiveSources : availableRequestN,\n+                            source.minMappedDemand));\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions. This should be Integer.MIN_VALUE to prevent subsequent mapped\n+            // source completion from incrementing the count to 0 or positive as terminateActiveMappedSources flips\n+            // the count to negative to signal to mapped sources we have completed.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            pendingDemand = -1;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                cancellableSubscribers.cancel();\n+                // Don't bother clearing out hungrySubscribers or signals (which require additional concurrency control)\n+                // because it is assumed this Subscriber will be dereferenced and eligible for GC [1].\n+                // [1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#3.13\n+            }\n+        }\n+\n+        private boolean tryDecrementPendingDemand() {\n+            for (;;) {\n+                final long prevDemand = pendingDemand;\n+                if (prevDemand <= 0) {\n+                    return false;\n+                } else if (pendingDemandUpdater.compareAndSet(this, prevDemand, prevDemand - 1)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        private void tryEmitItem(Object item, FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (tryAcquireLock(emittingLockUpdater, this)) { // fast path. no concurrency, try to skip the queue.\n+                try {\n+                    if (subscriber.hasSignalsQueued() || (needsDemand(item) && !tryDecrementPendingDemand())) {", "originalCommit": "0fa00306b986d647b69e9ead71e915494ea62db2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUyODQzMA==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r464528430", "bodyText": "No, signalsQueued is to avoid out of order delivery of signals relative to each mapped publisher. Either we go through the queue for all signals and ordering is provided by the queue, or if we may skip the queue (like we are doing now) we need to check if there maybe items already queued (in which case we need to go through the queue to preserve ordering). The signalsQueued flag is currently cleared after demand is exhausted as we anyways need a reference to the FlatMapPublisherSubscriber to request more demand. We could potentially clear this flag earlier but we would need a reference to the FlatMapPublisherSubscriber while processing onNext which would require object allocation.", "author": "Scottmitch", "createdAt": "2020-08-03T16:37:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ1NDg0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTQ4MzA0NQ==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r491483045", "bodyText": "Ok lets add a comment explaining that this is done to preserve order per Subscriber.", "author": "NiteshKant", "createdAt": "2020-09-19T18:56:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ1NDg0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ1NTc0OQ==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r460455749", "bodyText": "but we still deliver error\n\ndo we need to?", "author": "NiteshKant", "createdAt": "2020-07-25T23:12:13Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,661 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * Implementation of {@link Publisher#flatMapMerge(Function)}.\n+ * <p>\n+ * This implementation makes some trade-offs that may have performance/memory impacts. Demand distributed to mapped\n+ * {@link Publisher}s is dynamic and correlates to downstream demand. This dynamic behavior is targeted toward use cases\n+ * where:\n+ * <ul>\n+ *     <li>{@link Subscriber#onNext(Object) onNext Objects} consume non trivial amount of memory relative to the memory\n+ *     to manage the {@link FlatMapSubscriber#hungrySubscribers} queue (e.g. network buffer, serialized POJO)</li>\n+ *     <li>downstream demand is available before signals from mapped sources are available\n+ *     (e.g. over a network boundary)</li>\n+ * </ul>\n+ * Scenarios where downstream demand is provided in small/slow increments relative to the amount of signals from mapped\n+ * Sources, or mapped Sources are backed by in memory content are expected to incur some additional overhead for\n+ * {@link FlatMapSubscriber#hungrySubscribers queue} management.\n+ *\n+ * @param <T> Type of original {@link Publisher}.\n+ * @param <R> Type of {@link Publisher} returned by the operator.\n+ */\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int minMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 8, 8, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int minMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (minMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"minMappedDemand: \" + minMappedDemand + \" (expected >0)\");\n+        }\n+        this.minMappedDemand = minMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> requestingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"requestingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> mappedDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"mappedDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int requestingLock;\n+        private volatile long pendingDemand;\n+        private volatile long mappedDemand;\n+\n+        // protected by emitting lock, or only accessed inside the Subscriber thread\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final DynamicCompositeCancellable cancellableSubscribers;\n+        private final Queue<FlatMapPublisherSubscriber<T, R>> hungrySubscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            signals = newUnboundedMpscQueue(4);\n+            hungrySubscribers = newUnboundedMpscQueue(4);\n+            cancellableSubscribers = new SetDynamicCompositeCancellable(min(16, source.maxConcurrency));\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                // If we transitioned from no demand, to some demand, then we should try to drain the queues which\n+                // may have signals pending due to previous over-request.\n+                if (pendingDemandUpdater.getAndAccumulate(this, n,\n+                        FlowControlUtils::addWithOverflowProtectionIfNotNegative) == 0) {\n+                    drainPending();\n+                }\n+                if (mappedDemandUpdater.getAndAccumulate(this, n,\n+                        FlowControlUtils::addWithOverflowProtection) == 0) {\n+                    distributeMappedDemand();\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            if (!cancellableSubscribers.add(subscriber)) {\n+                return;\n+            }\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                if (prevActiveSources < 0) {\n+                    // We have been cancelled, or already completed and the active count flipped to negative, either\n+                    // way we don't want to Subscribe or retain a reference to this Publisher.\n+                    cancellableSubscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private long reserveMappedDemand() {\n+            return mappedDemandUpdater.getAndSet(this, 0);\n+        }\n+\n+        private int reserveMappedDemandQuota() {\n+            for (;;) {\n+                final long prevDemand = mappedDemand;\n+                if (prevDemand <= 0) {\n+                    return 0;\n+                }\n+                final int quota = calculateRequestNQuota(prevDemand);\n+                if (mappedDemandUpdater.compareAndSet(this, prevDemand, prevDemand - quota)) {\n+                    return quota;\n+                }\n+            }\n+        }\n+\n+        private void distributeMappedDemand(FlatMapPublisherSubscriber<T, R> hungrySubscriber) {\n+            final int quota = reserveMappedDemandQuota();\n+            if (quota > 0) {\n+                final int usedQuota = hungrySubscriber.request(quota);\n+                if (usedQuota < quota && mappedDemandUpdater.getAndAccumulate(this, quota - usedQuota,\n+                        FlowControlUtils::addWithOverflowProtection) == 0) {\n+                    // If we gave some back and transitioned from 0 demand, we need to try to distribute demand\n+                    // in case other hungry subscribers were added in the mean time\n+                    // (since we have not acquired the requestingLock).\n+                    distributeMappedDemand();\n+                }\n+            } else { // slow path. no demand, add to queue and process later when demand arrives.\n+                hungrySubscribers.add(hungrySubscriber);\n+                distributeMappedDemand();\n+            }\n+        }\n+\n+        private void distributeMappedDemand() {\n+            Throwable delayedCause = null;\n+            boolean tryAcquire = true;\n+            while (tryAcquire && tryAcquireLock(requestingLockUpdater, this)) {\n+                try {\n+                    final long availableRequestN = reserveMappedDemand();\n+                    if (availableRequestN > 0) {\n+                        long remainingRequestN = availableRequestN;\n+                        final int quota = calculateRequestNQuota(availableRequestN);\n+                        FlatMapPublisherSubscriber<T, R> hungrySubscriber;\n+                        while ((hungrySubscriber = hungrySubscribers.poll()) != null) {\n+                            remainingRequestN -= hungrySubscriber.request(quota);\n+                        }\n+                        if (remainingRequestN > 0) {\n+                            mappedDemandUpdater.accumulateAndGet(this, remainingRequestN,\n+                                    FlowControlUtils::addWithOverflowProtection);\n+                        }\n+                    }\n+                } catch (Throwable cause) {\n+                    delayedCause = catchUnexpected(delayedCause, cause);\n+                } finally {\n+                    tryAcquire = !releaseLock(requestingLockUpdater, this);\n+                }\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private int calculateRequestNQuota(long availableRequestN) {\n+            // Get an approximate quota to distribute to each active mapped subscriber. If\n+            // activeMappedSources changes (subscriber added or terminated) we will re-distribute.\n+            final int prevActiveSources = activeMappedSources;\n+            return (int) min(Integer.MAX_VALUE,\n+                    max(prevActiveSources > 0 ? availableRequestN / prevActiveSources : availableRequestN,\n+                            source.minMappedDemand));\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions. This should be Integer.MIN_VALUE to prevent subsequent mapped\n+            // source completion from incrementing the count to 0 or positive as terminateActiveMappedSources flips\n+            // the count to negative to signal to mapped sources we have completed.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            pendingDemand = -1;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                cancellableSubscribers.cancel();\n+                // Don't bother clearing out hungrySubscribers or signals (which require additional concurrency control)\n+                // because it is assumed this Subscriber will be dereferenced and eligible for GC [1].\n+                // [1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#3.13\n+            }\n+        }\n+\n+        private boolean tryDecrementPendingDemand() {\n+            for (;;) {\n+                final long prevDemand = pendingDemand;\n+                if (prevDemand <= 0) {\n+                    return false;\n+                } else if (pendingDemandUpdater.compareAndSet(this, prevDemand, prevDemand - 1)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        private void tryEmitItem(Object item, FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (tryAcquireLock(emittingLockUpdater, this)) { // fast path. no concurrency, try to skip the queue.\n+                try {\n+                    if (subscriber.hasSignalsQueued() || (needsDemand(item) && !tryDecrementPendingDemand())) {\n+                        subscriber.markSignalsQueued();\n+                        enqueueItem(item); // drain isn't necessary. when demand arrives a drain will be attempted.\n+                    } else if (item == MAPPED_SOURCE_COMPLETE) {\n+                        requestMoreFromUpstream(1);\n+                    } else {\n+                        final boolean demandConsumed = sendToTarget(item);\n+                        assert demandConsumed == needsDemand(item);\n+                    }\n+                } finally {\n+                    if (!releaseLock(emittingLockUpdater, this)) {\n+                        drainPending();\n+                    }\n+                }\n+            } else { // slow path. there is concurrency, go through the queue to avoid concurrent delivery.\n+                subscriber.markSignalsQueued();\n+                enqueueAndDrain(item);\n+            }\n+        }\n+\n+        private void enqueueItem(Object item) {\n+            if (!signals.offer(item)) {\n+                enqueueFailed(item);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            enqueueItem(item);\n+            drainPending();\n+        }\n+\n+        private void enqueueFailed(Object item) {\n+            QueueFullException exception = new QueueFullException(\"signals\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, true, true);\n+            }\n+        }\n+\n+        private void drainPending() {\n+            Throwable delayedCause = null;\n+            boolean tryAcquire = true;\n+            int mappedSourcesCompleted = 0;\n+            while (tryAcquire && tryAcquireLock(emittingLockUpdater, this)) {\n+                try {\n+                    final long prevDemand = pendingDemandUpdater.getAndSet(this, 0);\n+                    long emittedCount = 0;\n+                    if (prevDemand < 0) {\n+                        // if we have been cancelled then we avoid delivering any signals, but we still deliver error", "originalCommit": "0fa00306b986d647b69e9ead71e915494ea62db2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczMjU5Nw==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r464732597", "bodyText": "this code isn't quite correct, thx for bringing my attention to this. the comment is meant to reference a cancel that is generated internally (e.g. if delayError=false and a mapped source fails, or failure to enqueue. The goal is to be consistent with PublisherFlatMapSingle however we have to manage demand in this case which makes it a bit more involved (which is where the bug is, currently discarding signals and delivering terminal out of order).", "author": "Scottmitch", "createdAt": "2020-08-04T00:34:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ1NTc0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEyMjE0NA==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r464122144", "bodyText": "My suggestion was to be fair by distributing the availableRequestN into maxConcurrency. This approach is partial towards early Publishers as it is distributing demand into active sources. The effect is magnified for the below pathological case:\nCountDownLatch latch = new CountDownLatch(1);\nSourceAdapters.toSource(Publisher.range(1, 100)\n        .flatMapMerge(integer -> {\n            System.out.println(\"Emitting next publisher for integer: \" + integer);\n            return Publisher.<Integer>never().beforeRequest(n -> System.out.println(\"Item: \" + integer + \", requested => \" + n));\n        }, 5, 1))\n        .subscribe(new PublisherSource.Subscriber<Integer>() {\n            @Override\n            public void onSubscribe(final PublisherSource.Subscription subscription) {\n                subscription.request(10);\n            }\n\n            @Override\n            public void onNext(@Nullable final Integer integer) {\n                System.out.println(\"Next => \" + integer);\n            }\n\n            @Override\n            public void onError(final Throwable t) {\n                latch.countDown();\n            }\n\n            @Override\n            public void onComplete() {\n                latch.countDown();\n            }\n        });\nlatch.await();\nThe above results in only requesting from the first source. Perhaps an easy fix is to always request 1 but it is still unfair. Are there any reservations to distribute based on maxConcurrency as opposed to active sources?", "author": "NiteshKant", "createdAt": "2020-08-02T20:51:02Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,661 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * Implementation of {@link Publisher#flatMapMerge(Function)}.\n+ * <p>\n+ * This implementation makes some trade-offs that may have performance/memory impacts. Demand distributed to mapped\n+ * {@link Publisher}s is dynamic and correlates to downstream demand. This dynamic behavior is targeted toward use cases\n+ * where:\n+ * <ul>\n+ *     <li>{@link Subscriber#onNext(Object) onNext Objects} consume non trivial amount of memory relative to the memory\n+ *     to manage the {@link FlatMapSubscriber#hungrySubscribers} queue (e.g. network buffer, serialized POJO)</li>\n+ *     <li>downstream demand is available before signals from mapped sources are available\n+ *     (e.g. over a network boundary)</li>\n+ * </ul>\n+ * Scenarios where downstream demand is provided in small/slow increments relative to the amount of signals from mapped\n+ * Sources, or mapped Sources are backed by in memory content are expected to incur some additional overhead for\n+ * {@link FlatMapSubscriber#hungrySubscribers queue} management.\n+ *\n+ * @param <T> Type of original {@link Publisher}.\n+ * @param <R> Type of {@link Publisher} returned by the operator.\n+ */\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int minMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 8, 8, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int minMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (minMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"minMappedDemand: \" + minMappedDemand + \" (expected >0)\");\n+        }\n+        this.minMappedDemand = minMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> requestingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"requestingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> mappedDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"mappedDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int requestingLock;\n+        private volatile long pendingDemand;\n+        private volatile long mappedDemand;\n+\n+        // protected by emitting lock, or only accessed inside the Subscriber thread\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final DynamicCompositeCancellable cancellableSubscribers;\n+        private final Queue<FlatMapPublisherSubscriber<T, R>> hungrySubscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            signals = newUnboundedMpscQueue(4);\n+            hungrySubscribers = newUnboundedMpscQueue(4);\n+            cancellableSubscribers = new SetDynamicCompositeCancellable(min(16, source.maxConcurrency));\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                // If we transitioned from no demand, to some demand, then we should try to drain the queues which\n+                // may have signals pending due to previous over-request.\n+                if (pendingDemandUpdater.getAndAccumulate(this, n,\n+                        FlowControlUtils::addWithOverflowProtectionIfNotNegative) == 0) {\n+                    drainPending();\n+                }\n+                if (mappedDemandUpdater.getAndAccumulate(this, n,\n+                        FlowControlUtils::addWithOverflowProtection) == 0) {\n+                    distributeMappedDemand();\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            if (!cancellableSubscribers.add(subscriber)) {\n+                return;\n+            }\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                if (prevActiveSources < 0) {\n+                    // We have been cancelled, or already completed and the active count flipped to negative, either\n+                    // way we don't want to Subscribe or retain a reference to this Publisher.\n+                    cancellableSubscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private long reserveMappedDemand() {\n+            return mappedDemandUpdater.getAndSet(this, 0);\n+        }\n+\n+        private int reserveMappedDemandQuota() {\n+            for (;;) {\n+                final long prevDemand = mappedDemand;\n+                if (prevDemand <= 0) {\n+                    return 0;\n+                }\n+                final int quota = calculateRequestNQuota(prevDemand);\n+                if (mappedDemandUpdater.compareAndSet(this, prevDemand, prevDemand - quota)) {\n+                    return quota;\n+                }\n+            }\n+        }\n+\n+        private void distributeMappedDemand(FlatMapPublisherSubscriber<T, R> hungrySubscriber) {\n+            final int quota = reserveMappedDemandQuota();\n+            if (quota > 0) {\n+                final int usedQuota = hungrySubscriber.request(quota);\n+                if (usedQuota < quota && mappedDemandUpdater.getAndAccumulate(this, quota - usedQuota,\n+                        FlowControlUtils::addWithOverflowProtection) == 0) {\n+                    // If we gave some back and transitioned from 0 demand, we need to try to distribute demand\n+                    // in case other hungry subscribers were added in the mean time\n+                    // (since we have not acquired the requestingLock).\n+                    distributeMappedDemand();\n+                }\n+            } else { // slow path. no demand, add to queue and process later when demand arrives.\n+                hungrySubscribers.add(hungrySubscriber);\n+                distributeMappedDemand();\n+            }\n+        }\n+\n+        private void distributeMappedDemand() {\n+            Throwable delayedCause = null;\n+            boolean tryAcquire = true;\n+            while (tryAcquire && tryAcquireLock(requestingLockUpdater, this)) {\n+                try {\n+                    final long availableRequestN = reserveMappedDemand();\n+                    if (availableRequestN > 0) {\n+                        long remainingRequestN = availableRequestN;\n+                        final int quota = calculateRequestNQuota(availableRequestN);\n+                        FlatMapPublisherSubscriber<T, R> hungrySubscriber;\n+                        while ((hungrySubscriber = hungrySubscribers.poll()) != null) {\n+                            remainingRequestN -= hungrySubscriber.request(quota);\n+                        }\n+                        if (remainingRequestN > 0) {\n+                            mappedDemandUpdater.accumulateAndGet(this, remainingRequestN,\n+                                    FlowControlUtils::addWithOverflowProtection);\n+                        }\n+                    }\n+                } catch (Throwable cause) {\n+                    delayedCause = catchUnexpected(delayedCause, cause);\n+                } finally {\n+                    tryAcquire = !releaseLock(requestingLockUpdater, this);\n+                }\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private int calculateRequestNQuota(long availableRequestN) {\n+            // Get an approximate quota to distribute to each active mapped subscriber. If\n+            // activeMappedSources changes (subscriber added or terminated) we will re-distribute.\n+            final int prevActiveSources = activeMappedSources;\n+            return (int) min(Integer.MAX_VALUE,\n+                    max(prevActiveSources > 0 ? availableRequestN / prevActiveSources : availableRequestN,", "originalCommit": "5bf903babe582ed3a0eba43fe2b5ccf19653a19c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY4MTE2OA==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r464681168", "bodyText": "the mappedDemand accounting is not quite right and needs some fixing. the intention was to at least distribute minMappedDemand to each source so that each source is allowed to produce data while capping the queue size at minMappedDemand * maxConcurrency. let me re-work this a bit.\nusing availableRequestN was an optimization geared toward steady state to get a more accurate estimate which should result in larger demand chunks being distributed and less re-distribution events. It would be unfair during non-steady state as you indicated and is not critical so I will remove it.", "author": "Scottmitch", "createdAt": "2020-08-03T21:51:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEyMjE0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEyMjMwMQ==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r464122301", "bodyText": "The subscription is a ConcurrentSubscription which means we can concurrently request more items. Can we go to a simpler model of not going through the queue to request more items from upstream and instead just request(1) every time a source completes?", "author": "NiteshKant", "createdAt": "2020-08-02T20:52:57Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,661 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * Implementation of {@link Publisher#flatMapMerge(Function)}.\n+ * <p>\n+ * This implementation makes some trade-offs that may have performance/memory impacts. Demand distributed to mapped\n+ * {@link Publisher}s is dynamic and correlates to downstream demand. This dynamic behavior is targeted toward use cases\n+ * where:\n+ * <ul>\n+ *     <li>{@link Subscriber#onNext(Object) onNext Objects} consume non trivial amount of memory relative to the memory\n+ *     to manage the {@link FlatMapSubscriber#hungrySubscribers} queue (e.g. network buffer, serialized POJO)</li>\n+ *     <li>downstream demand is available before signals from mapped sources are available\n+ *     (e.g. over a network boundary)</li>\n+ * </ul>\n+ * Scenarios where downstream demand is provided in small/slow increments relative to the amount of signals from mapped\n+ * Sources, or mapped Sources are backed by in memory content are expected to incur some additional overhead for\n+ * {@link FlatMapSubscriber#hungrySubscribers queue} management.\n+ *\n+ * @param <T> Type of original {@link Publisher}.\n+ * @param <R> Type of {@link Publisher} returned by the operator.\n+ */\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int minMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 8, 8, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int minMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (minMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"minMappedDemand: \" + minMappedDemand + \" (expected >0)\");\n+        }\n+        this.minMappedDemand = minMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> requestingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"requestingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> mappedDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"mappedDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int requestingLock;\n+        private volatile long pendingDemand;\n+        private volatile long mappedDemand;\n+\n+        // protected by emitting lock, or only accessed inside the Subscriber thread\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final DynamicCompositeCancellable cancellableSubscribers;\n+        private final Queue<FlatMapPublisherSubscriber<T, R>> hungrySubscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            signals = newUnboundedMpscQueue(4);\n+            hungrySubscribers = newUnboundedMpscQueue(4);\n+            cancellableSubscribers = new SetDynamicCompositeCancellable(min(16, source.maxConcurrency));\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                // If we transitioned from no demand, to some demand, then we should try to drain the queues which\n+                // may have signals pending due to previous over-request.\n+                if (pendingDemandUpdater.getAndAccumulate(this, n,\n+                        FlowControlUtils::addWithOverflowProtectionIfNotNegative) == 0) {\n+                    drainPending();\n+                }\n+                if (mappedDemandUpdater.getAndAccumulate(this, n,\n+                        FlowControlUtils::addWithOverflowProtection) == 0) {\n+                    distributeMappedDemand();\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            if (!cancellableSubscribers.add(subscriber)) {\n+                return;\n+            }\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                if (prevActiveSources < 0) {\n+                    // We have been cancelled, or already completed and the active count flipped to negative, either\n+                    // way we don't want to Subscribe or retain a reference to this Publisher.\n+                    cancellableSubscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private long reserveMappedDemand() {\n+            return mappedDemandUpdater.getAndSet(this, 0);\n+        }\n+\n+        private int reserveMappedDemandQuota() {\n+            for (;;) {\n+                final long prevDemand = mappedDemand;\n+                if (prevDemand <= 0) {\n+                    return 0;\n+                }\n+                final int quota = calculateRequestNQuota(prevDemand);\n+                if (mappedDemandUpdater.compareAndSet(this, prevDemand, prevDemand - quota)) {\n+                    return quota;\n+                }\n+            }\n+        }\n+\n+        private void distributeMappedDemand(FlatMapPublisherSubscriber<T, R> hungrySubscriber) {\n+            final int quota = reserveMappedDemandQuota();\n+            if (quota > 0) {\n+                final int usedQuota = hungrySubscriber.request(quota);\n+                if (usedQuota < quota && mappedDemandUpdater.getAndAccumulate(this, quota - usedQuota,\n+                        FlowControlUtils::addWithOverflowProtection) == 0) {\n+                    // If we gave some back and transitioned from 0 demand, we need to try to distribute demand\n+                    // in case other hungry subscribers were added in the mean time\n+                    // (since we have not acquired the requestingLock).\n+                    distributeMappedDemand();\n+                }\n+            } else { // slow path. no demand, add to queue and process later when demand arrives.\n+                hungrySubscribers.add(hungrySubscriber);\n+                distributeMappedDemand();\n+            }\n+        }\n+\n+        private void distributeMappedDemand() {\n+            Throwable delayedCause = null;\n+            boolean tryAcquire = true;\n+            while (tryAcquire && tryAcquireLock(requestingLockUpdater, this)) {\n+                try {\n+                    final long availableRequestN = reserveMappedDemand();\n+                    if (availableRequestN > 0) {\n+                        long remainingRequestN = availableRequestN;\n+                        final int quota = calculateRequestNQuota(availableRequestN);\n+                        FlatMapPublisherSubscriber<T, R> hungrySubscriber;\n+                        while ((hungrySubscriber = hungrySubscribers.poll()) != null) {\n+                            remainingRequestN -= hungrySubscriber.request(quota);\n+                        }\n+                        if (remainingRequestN > 0) {\n+                            mappedDemandUpdater.accumulateAndGet(this, remainingRequestN,\n+                                    FlowControlUtils::addWithOverflowProtection);\n+                        }\n+                    }\n+                } catch (Throwable cause) {\n+                    delayedCause = catchUnexpected(delayedCause, cause);\n+                } finally {\n+                    tryAcquire = !releaseLock(requestingLockUpdater, this);\n+                }\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private int calculateRequestNQuota(long availableRequestN) {\n+            // Get an approximate quota to distribute to each active mapped subscriber. If\n+            // activeMappedSources changes (subscriber added or terminated) we will re-distribute.\n+            final int prevActiveSources = activeMappedSources;\n+            return (int) min(Integer.MAX_VALUE,\n+                    max(prevActiveSources > 0 ? availableRequestN / prevActiveSources : availableRequestN,\n+                            source.minMappedDemand));\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions. This should be Integer.MIN_VALUE to prevent subsequent mapped\n+            // source completion from incrementing the count to 0 or positive as terminateActiveMappedSources flips\n+            // the count to negative to signal to mapped sources we have completed.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            pendingDemand = -1;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                cancellableSubscribers.cancel();\n+                // Don't bother clearing out hungrySubscribers or signals (which require additional concurrency control)\n+                // because it is assumed this Subscriber will be dereferenced and eligible for GC [1].\n+                // [1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#3.13\n+            }\n+        }\n+\n+        private boolean tryDecrementPendingDemand() {\n+            for (;;) {\n+                final long prevDemand = pendingDemand;\n+                if (prevDemand <= 0) {\n+                    return false;\n+                } else if (pendingDemandUpdater.compareAndSet(this, prevDemand, prevDemand - 1)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        private void tryEmitItem(Object item, FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (tryAcquireLock(emittingLockUpdater, this)) { // fast path. no concurrency, try to skip the queue.\n+                try {\n+                    if (subscriber.hasSignalsQueued() || (needsDemand(item) && !tryDecrementPendingDemand())) {\n+                        subscriber.markSignalsQueued();\n+                        enqueueItem(item); // drain isn't necessary. when demand arrives a drain will be attempted.\n+                    } else if (item == MAPPED_SOURCE_COMPLETE) {\n+                        requestMoreFromUpstream(1);\n+                    } else {\n+                        final boolean demandConsumed = sendToTarget(item);\n+                        assert demandConsumed == needsDemand(item);\n+                    }\n+                } finally {\n+                    if (!releaseLock(emittingLockUpdater, this)) {\n+                        drainPending();\n+                    }\n+                }\n+            } else { // slow path. there is concurrency, go through the queue to avoid concurrent delivery.\n+                subscriber.markSignalsQueued();\n+                enqueueAndDrain(item);\n+            }\n+        }\n+\n+        private void enqueueItem(Object item) {\n+            if (!signals.offer(item)) {\n+                enqueueFailed(item);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            enqueueItem(item);\n+            drainPending();\n+        }\n+\n+        private void enqueueFailed(Object item) {\n+            QueueFullException exception = new QueueFullException(\"signals\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, true, true);\n+            }\n+        }\n+\n+        private void drainPending() {\n+            Throwable delayedCause = null;\n+            boolean tryAcquire = true;\n+            int mappedSourcesCompleted = 0;\n+            while (tryAcquire && tryAcquireLock(emittingLockUpdater, this)) {\n+                try {\n+                    final long prevDemand = pendingDemandUpdater.getAndSet(this, 0);\n+                    long emittedCount = 0;\n+                    if (prevDemand < 0) {\n+                        // if we have been cancelled then we avoid delivering any signals, but we still deliver error\n+                        // terminals below by making sure emittedCount == prevDemand.\n+                        pendingDemand = emittedCount = prevDemand;\n+                        signals.clear();\n+                    }\n+                    Object t;\n+                    while (emittedCount < prevDemand && (t = signals.poll()) != null) {\n+                        try {\n+                            if (t == MAPPED_SOURCE_COMPLETE) {\n+                                ++mappedSourcesCompleted;\n+                            } else if (sendToTarget(t)) {\n+                                ++emittedCount;\n+                            }\n+                        } catch (Throwable cause) {\n+                            delayedCause = catchUnexpected(delayedCause, cause);\n+                        }\n+                    }\n+\n+                    // check if a terminal event is pending, or give back demand.\n+                    if (emittedCount == prevDemand) {\n+                        for (;;) {\n+                            try {\n+                                t = signals.peek();\n+                                if (t == MAPPED_SOURCE_COMPLETE) {\n+                                    signals.poll();\n+                                    ++mappedSourcesCompleted;\n+                                } else if (t instanceof FlatMapPublisherSubscriber) {\n+                                    signals.poll();\n+                                    @SuppressWarnings(\"unchecked\")\n+                                    final FlatMapPublisherSubscriber<T, R> hungrySubscriber =\n+                                            (FlatMapPublisherSubscriber<T, R>) t;\n+                                    distributeMappedDemand(hungrySubscriber);\n+                                } else {\n+                                    break;\n+                                }\n+                            } catch (Throwable cause) {\n+                                delayedCause = catchUnexpected(delayedCause, cause);\n+                            }\n+                        }\n+\n+                        if (t instanceof TerminalNotification) {\n+                            sendToTarget((TerminalNotification) t); // if this throws its OK as we have terminated\n+                        } else {\n+                            t = terminalNotification;\n+                            if (t != null && t != complete()) { // don't wait for demand to process an error\n+                                sendToTarget((TerminalNotification) t); // if this throws its OK as we have terminated\n+                            }\n+                        }\n+                    } else {\n+                        assert emittedCount < prevDemand;\n+                        pendingDemandUpdater.accumulateAndGet(this, prevDemand - emittedCount,\n+                                FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n+                    }\n+                } finally {\n+                    tryAcquire = !releaseLock(emittingLockUpdater, this);\n+                }\n+            }\n+\n+            if (mappedSourcesCompleted != 0) {\n+                requestMoreFromUpstream(mappedSourcesCompleted);", "originalCommit": "5bf903babe582ed3a0eba43fe2b5ccf19653a19c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcxNDgwMQ==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r464714801", "bodyText": "The subscription is a ConcurrentSubscription which means we can concurrently request more items. Can we go to a simpler model of not going through the queue ...\n\nConcurrentSubscription is responsible for concurrency control, and in this case the call isn't inside a critical section. I will move the other call to requestMoreFromUpstream outside the critical block to make it consistent.\nRequesting upstream isn't strictly tied to \"going through the queue\" but focused on waiting until events are delivered downstream (we skip the queue if no concurrency) to keep the queue bounded (we should be requesting minMappedDemand when a new mapped source is delivered ... request code has been updated to fix this).", "author": "Scottmitch", "createdAt": "2020-08-03T23:31:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEyMjMwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAwODY1OQ==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r497008659", "bodyText": "the original question is a duplicate of #1011 (comment) and discussed/resolved below. lets open a new thread if there are still questions on this topic.", "author": "Scottmitch", "createdAt": "2020-09-29T19:59:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEyMjMwMQ=="}], "type": "inlineReview"}, {"oid": "bc190ba77b5383b92ac7567c2bb0083834d93c2b", "url": "https://github.com/apple/servicetalk/commit/bc190ba77b5383b92ac7567c2bb0083834d93c2b", "message": "correct javadocs for FLowControlUtils method", "committedDate": "2020-08-05T22:56:48Z", "type": "forcePushed"}, {"oid": "dbd705d1b7ef776dc0d9b08bc4d2dca163020ff0", "url": "https://github.com/apple/servicetalk/commit/dbd705d1b7ef776dc0d9b08bc4d2dca163020ff0", "message": "remove hungrySubscriber queue, make sure we always give demand to mapped sources optimistically to avoid deadlock", "committedDate": "2020-09-15T20:55:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3MzE5OQ==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r479673199", "bodyText": "Looks like these suppressions aren't required anymore.", "author": "NiteshKant", "createdAt": "2020-08-29T17:47:53Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,688 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * Implementation of {@link Publisher#flatMapMerge(Function)}.\n+ * <p>\n+ * This implementation makes some trade-offs that may have performance/memory impacts. Demand distributed to mapped\n+ * {@link Publisher}s is dynamic and correlates to downstream demand. This dynamic behavior is targeted toward use cases\n+ * where:\n+ * <ul>\n+ *     <li>{@link Subscriber#onNext(Object) onNext Objects} consume non trivial amount of memory relative to the memory\n+ *     to manage the {@link FlatMapSubscriber#hungrySubscribers} queue (e.g. network buffer, serialized POJO)</li>\n+ *     <li>downstream demand is available before signals from mapped sources are available\n+ *     (e.g. over a network boundary)</li>\n+ * </ul>\n+ * Scenarios where downstream demand is provided in small/slow increments relative to the amount of signals from mapped\n+ * Sources, or mapped Sources are backed by in memory content are expected to incur some additional overhead for\n+ * {@link FlatMapSubscriber#hungrySubscribers queue} management.\n+ *\n+ * @param <T> Type of original {@link Publisher}.\n+ * @param <R> Type of {@link Publisher} returned by the operator.\n+ */\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int minMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 8, 8, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int minMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (minMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"minMappedDemand: \" + minMappedDemand + \" (expected >0)\");\n+        }\n+        this.minMappedDemand = minMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> requestingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"requestingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> mappedDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"mappedDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")", "originalCommit": "bc190ba77b5383b92ac7567c2bb0083834d93c2b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE5NTUyOA==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r496195528", "bodyText": "I will update to UnusedDeclaration since they are not directly assigned we get a different warning if the suppression is completely removed.", "author": "Scottmitch", "createdAt": "2020-09-28T19:53:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3MzE5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTQ4Mjc3Mw==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r491482773", "bodyText": "The return type is effectively used as  boolean as we do not consume partial n. Can we change this to a boolean?", "author": "NiteshKant", "createdAt": "2020-09-19T18:54:01Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * Implementation of {@link Publisher#flatMapMerge(Function)}.\n+ * <p>\n+ * This implementation makes some trade-offs that may have performance/memory impacts. Demand distributed to mapped\n+ * {@link Publisher}s is dynamic and correlates to downstream demand. This dynamic behavior is targeted toward use cases\n+ * where:\n+ * <ul>\n+ *     <li>{@link Subscriber#onNext(Object) onNext Objects} consume non trivial amount of memory relative to the memory\n+ *     for managing demand through the {@link FlatMapSubscriber#signals} queue (network buffer, serialized POJO)</li>\n+ *     <li>downstream demand is available before signals from mapped sources are available\n+ *     (e.g. over a network boundary)</li>\n+ * </ul>\n+ * Scenarios where downstream demand is provided in small/slow increments relative to the amount of signals from mapped\n+ * Sources, or mapped Sources are backed by in memory content are expected to incur some additional overhead for\n+ * managing demand through the {@link FlatMapSubscriber#signals} queue.\n+ *\n+ * @param <T> Type of original {@link Publisher}.\n+ * @param <R> Type of {@link Publisher} returned by the operator.\n+ */\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private static final int MIN_MAPPED_DEMAND = 1;\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 8, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> mappedDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"mappedDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+        private volatile long mappedDemand;\n+\n+        // protected by emitting lock, or only accessed inside the Subscriber thread\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final DynamicCompositeCancellable cancellableSubscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            signals = newUnboundedMpscQueue(4);\n+            cancellableSubscribers = new SetDynamicCompositeCancellable(min(16, source.maxConcurrency));\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true, true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                // If we transitioned from no demand, to some demand, then we should try to drain the queues which\n+                // may have signals pending due to previous over-request.\n+                if (pendingDemandUpdater.getAndAccumulate(this, n,\n+                        FlowControlUtils::addWithOverflowProtectionIfNotNegative) == 0) {\n+                    drainPending();\n+                }\n+                incMappedDemand(n);\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            if (!cancellableSubscribers.add(subscriber)) {\n+                return;\n+            }\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                if (prevActiveSources < 0) {\n+                    // We have been cancelled, or already completed and the active count flipped to negative, either\n+                    // way we don't want to Subscribe or retain a reference to this Publisher.\n+                    cancellableSubscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, true)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean fromUpstream) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, !fromUpstream, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(!fromUpstream, true);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void incMappedDemand(long n) {\n+            assert n > 0;\n+            mappedDemandUpdater.getAndAccumulate(this, n, FlowControlUtils::addWithUnderOverflowProtection);\n+        }\n+\n+        private int reserveMappedDemandQuota() {\n+            for (;;) {\n+                final long prevDemand = mappedDemand;\n+                if (prevDemand <= 0) {\n+                    // mappedDemand is allowed to go negative here in order to distribute MIN_MAPPED_DEMAND demand to\n+                    // each source. This is to avoid a single mapped source (or set of sources) not making any progress\n+                    // with the demand they were given, taking demand away from sources that could make progress. The\n+                    // negative value ensures that if a source completes with unused demand it doesn't result in\n+                    // artificially giving back \"negative\" demand and keeps the maximum queue size should be bound\n+                    // to (maxConcurrency * minMappedDemand).\n+                    if (mappedDemandUpdater.compareAndSet(this, prevDemand, prevDemand - MIN_MAPPED_DEMAND)) {\n+                        return MIN_MAPPED_DEMAND;\n+                    }\n+                } else {\n+                    final int quota = calculateRequestNQuota(prevDemand);\n+                    if (mappedDemandUpdater.compareAndSet(this, prevDemand, prevDemand - quota)) {\n+                        return quota;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void distributeMappedDemand(FlatMapPublisherSubscriber<T, R> hungrySubscriber) {\n+            final int quota = reserveMappedDemandQuota();\n+            final int usedQuota = hungrySubscriber.request(quota);\n+            if (usedQuota < quota) {\n+                incMappedDemand(quota - usedQuota);\n+            }\n+        }\n+\n+        private int calculateRequestNQuota(long availableRequestN) {\n+            // Get an approximate quota to distribute to each active mapped subscriber.\n+            return (int) min(Integer.MAX_VALUE, max(availableRequestN / source.maxConcurrency, MIN_MAPPED_DEMAND));\n+        }\n+\n+        private void doCancel(boolean cancelSubscription, boolean invalidatePendingDemand) {\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions. This should be Integer.MIN_VALUE to prevent subsequent mapped\n+            // source completion from incrementing the count to 0 or positive as terminateActiveMappedSources flips\n+            // the count to negative to signal to mapped sources we have completed.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            if (invalidatePendingDemand) {\n+                pendingDemand = -1;\n+            }\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                cancellableSubscribers.cancel();\n+                // Don't bother clearing out signals (which require additional concurrency control) because it is\n+                // assumed this Subscriber will be dereferenced and eligible for GC [1].\n+                // [1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#3.13\n+            }\n+        }\n+\n+        private boolean tryDecrementPendingDemand() {\n+            for (;;) {\n+                final long prevDemand = pendingDemand;\n+                if (prevDemand <= 0) {\n+                    return false;\n+                } else if (pendingDemandUpdater.compareAndSet(this, prevDemand, prevDemand - 1)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        private void tryEmitItem(Object item, FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (tryAcquireLock(emittingLockUpdater, this)) { // fast path. no concurrency, try to skip the queue.\n+                boolean mappedSourcesCompleted = false;\n+                try {\n+                    if (subscriber.hasSignalsQueued() || (needsDemand(item) && !tryDecrementPendingDemand())) {\n+                        subscriber.markSignalsQueued();\n+                        enqueueItem(item); // drain isn't necessary. when demand arrives a drain will be attempted.\n+                    } else if (item == MAPPED_SOURCE_COMPLETE) {\n+                        mappedSourcesCompleted = true;\n+                    } else {\n+                        final boolean demandConsumed = sendToTarget(item);\n+                        assert demandConsumed == needsDemand(item);\n+                    }\n+                } finally {\n+                    if (!releaseLock(emittingLockUpdater, this)) {\n+                        drainPending();\n+                    }\n+                }\n+                if (mappedSourcesCompleted) { // request more from upstream outside the critical section.\n+                    requestMoreFromUpstream(1);\n+                }\n+            } else { // slow path. there is concurrency, go through the queue to avoid concurrent delivery.\n+                subscriber.markSignalsQueued();\n+                enqueueAndDrain(item);\n+            }\n+        }\n+\n+        private void enqueueItem(Object item) {\n+            if (!signals.offer(item)) {\n+                enqueueFailed(item);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            enqueueItem(item);\n+            drainPending();\n+        }\n+\n+        private void enqueueFailed(Object item) {\n+            QueueFullException exception = new QueueFullException(\"signals\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, false);\n+            }\n+        }\n+\n+        private void drainPending() {\n+            Throwable delayedCause = null;\n+            boolean tryAcquire = true;\n+            int mappedSourcesCompleted = 0;\n+            while (tryAcquire && tryAcquireLock(emittingLockUpdater, this)) {\n+                try {\n+                    final long prevDemand = pendingDemandUpdater.getAndSet(this, 0);\n+                    long emittedCount = 0;\n+                    if (prevDemand < 0) {\n+                        pendingDemand = prevDemand;\n+                        // Don't wait for demand to deliver the terminalNotification if present. The queued signals\n+                        // maybe from optimistic demand, but the error is from an event that needs immediate propagation\n+                        // (e.g. illegal requestN, failure to enqueue).\n+                        TerminalNotification t = terminalNotification;\n+                        if (t != null && t != complete()) {\n+                            sendToTarget(t); // if this throws its OK as we have terminated\n+                        }\n+                    } else {\n+                        Object t;\n+                        while (emittedCount < prevDemand && (t = signals.poll()) != null) {\n+                            try {\n+                                if (t == MAPPED_SOURCE_COMPLETE) {\n+                                    ++mappedSourcesCompleted;\n+                                } else if (sendToTarget(t)) {\n+                                    ++emittedCount;\n+                                }\n+                            } catch (Throwable cause) {\n+                                delayedCause = catchUnexpected(delayedCause, cause);\n+                            }\n+                        }\n+\n+                        // check if a terminal event is pending, or give back demand.\n+                        if (emittedCount == prevDemand) {\n+                            for (;;) {\n+                                try {\n+                                    t = signals.peek();\n+                                    if (t == MAPPED_SOURCE_COMPLETE) {\n+                                        signals.poll();\n+                                        ++mappedSourcesCompleted;\n+                                    } else if (t instanceof FlatMapPublisherSubscriber) {\n+                                        signals.poll();\n+                                        @SuppressWarnings(\"unchecked\")\n+                                        final FlatMapPublisherSubscriber<T, R> hungrySubscriber =\n+                                                (FlatMapPublisherSubscriber<T, R>) t;\n+                                        distributeMappedDemand(hungrySubscriber);\n+                                    } else {\n+                                        break;\n+                                    }\n+                                } catch (Throwable cause) {\n+                                    delayedCause = catchUnexpected(delayedCause, cause);\n+                                }\n+                            }\n+\n+                            if (t instanceof TerminalNotification) {\n+                                sendToTarget((TerminalNotification) t); // if this throws its OK as we have terminated\n+                            }\n+                        } else {\n+                            assert emittedCount < prevDemand;\n+                            pendingDemandUpdater.accumulateAndGet(this, prevDemand - emittedCount,\n+                                    FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n+                        }\n+                    }\n+                } finally {\n+                    tryAcquire = !releaseLock(emittingLockUpdater, this);\n+                }\n+            }\n+\n+            if (mappedSourcesCompleted != 0) {\n+                requestMoreFromUpstream(mappedSourcesCompleted);\n+            }\n+\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void requestMoreFromUpstream(int mappedSourcesCompleted) {\n+            assert mappedSourcesCompleted > 0;\n+            assert subscription != null;\n+            subscription.request(mappedSourcesCompleted);\n+        }\n+\n+        private static boolean needsDemand(Object item) {\n+            return item != MAPPED_SOURCE_COMPLETE &&\n+                    !(item instanceof FlatMapPublisherSubscriber) && !(item instanceof TerminalNotification);\n+        }\n+\n+        private boolean sendToTarget(Object item) {\n+            assert item != MAPPED_SOURCE_COMPLETE;\n+            if (targetTerminated) {\n+                return false;\n+            } else if (item instanceof TerminalNotification) {\n+                TerminalNotification terminalNotification;\n+                if (item == complete() && (terminalNotification = this.terminalNotification) != null) {\n+                    // Load the terminal notification in case an error happened after an onComplete and we override the\n+                    // terminal value.\n+                    sendToTarget(terminalNotification);\n+                } else {\n+                    sendToTarget((TerminalNotification) item);\n+                }\n+                return false;\n+            } else if (item instanceof FlatMapPublisherSubscriber) {\n+                @SuppressWarnings(\"unchecked\")\n+                final FlatMapPublisherSubscriber<T, R> hungrySubscriber = (FlatMapPublisherSubscriber<T, R>) item;\n+                distributeMappedDemand(hungrySubscriber);\n+                return false;\n+            }\n+            target.onNext(unwrapNullUnchecked(item));\n+            return true;\n+        }\n+\n+        private void sendToTarget(TerminalNotification terminalNotification) {\n+            signals.clear();\n+            targetTerminated = true;\n+            CompositeException de = this.delayedError;\n+            if (de != null) {\n+                de.transferPendingToSuppressed();\n+                if (terminalNotification.cause() == de) {\n+                    terminalNotification.terminate(target);\n+                } else {\n+                    terminalNotification.terminate(target, de);\n+                }\n+            } else {\n+                terminalNotification.terminate(target);\n+            }\n+        }\n+\n+        private boolean terminateActiveMappedSources() {\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                assert prevActiveSources >= 0; // otherwise we have seen multiple onComplete signals\n+                if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, -prevActiveSources)) {\n+                    return prevActiveSources == 0;\n+                }\n+            }\n+        }\n+\n+        private boolean decrementActiveMappedSources() {\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                assert prevActiveSources != 0;\n+                if (prevActiveSources > 0) {\n+                    if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources - 1)) {\n+                        return false;\n+                    }\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    return prevActiveSources == -1;\n+                }\n+            }\n+        }\n+\n+        private boolean removeSubscriber(final FlatMapPublisherSubscriber<T, R> subscriber, int unusedDemand) {\n+            if (cancellableSubscribers.remove(subscriber) && decrementActiveMappedSources()) {\n+                return true;\n+            } else if (unusedDemand > 0) {\n+                incMappedDemand(unusedDemand);\n+            }\n+            return false;\n+        }\n+\n+        private static final class FlatMapPublisherSubscriber<T, R> implements Subscriber<R>, Cancellable {\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicIntegerFieldUpdater<FlatMapPublisherSubscriber> pendingDemandUpdater =\n+                    AtomicIntegerFieldUpdater.newUpdater(FlatMapPublisherSubscriber.class, \"innerPendingDemand\");\n+\n+            private final FlatMapSubscriber<T, R> parent;\n+            private final DelayedSubscription subscription;\n+            private volatile int innerPendingDemand;\n+            /**\n+             * visibility provided by the {@link Subscriber} thread in {@link #onNext(Object)}, and\n+             * demand is exhausted before {@link #request(long)} is called, and that method triggers\n+             * {@link Subscription#request(long)} which provides a\n+             * <a href=\"https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#1.1\">\n+             * happens-before relationship between requesting elements and receiving elements</a>.\n+             */\n+            private boolean signalsQueued;\n+\n+            FlatMapPublisherSubscriber(FlatMapSubscriber<T, R> parent) {\n+                this.parent = parent;\n+                subscription = new DelayedSubscription();\n+            }\n+\n+            @Override\n+            public void cancel() {\n+                subscription.cancel();\n+            }\n+\n+            int request(int n) {", "originalCommit": "acf1824e3eb85a637139297c89e4c9e3c2ed5533", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTQ4MzE0Mw==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r491483143", "bodyText": "nit: we are attempting drain upon release which is the typical pattern. Suggest removing the comment.", "author": "NiteshKant", "createdAt": "2020-09-19T18:58:14Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * Implementation of {@link Publisher#flatMapMerge(Function)}.\n+ * <p>\n+ * This implementation makes some trade-offs that may have performance/memory impacts. Demand distributed to mapped\n+ * {@link Publisher}s is dynamic and correlates to downstream demand. This dynamic behavior is targeted toward use cases\n+ * where:\n+ * <ul>\n+ *     <li>{@link Subscriber#onNext(Object) onNext Objects} consume non trivial amount of memory relative to the memory\n+ *     for managing demand through the {@link FlatMapSubscriber#signals} queue (network buffer, serialized POJO)</li>\n+ *     <li>downstream demand is available before signals from mapped sources are available\n+ *     (e.g. over a network boundary)</li>\n+ * </ul>\n+ * Scenarios where downstream demand is provided in small/slow increments relative to the amount of signals from mapped\n+ * Sources, or mapped Sources are backed by in memory content are expected to incur some additional overhead for\n+ * managing demand through the {@link FlatMapSubscriber#signals} queue.\n+ *\n+ * @param <T> Type of original {@link Publisher}.\n+ * @param <R> Type of {@link Publisher} returned by the operator.\n+ */\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private static final int MIN_MAPPED_DEMAND = 1;\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 8, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> mappedDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"mappedDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+        private volatile long mappedDemand;\n+\n+        // protected by emitting lock, or only accessed inside the Subscriber thread\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final DynamicCompositeCancellable cancellableSubscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            signals = newUnboundedMpscQueue(4);\n+            cancellableSubscribers = new SetDynamicCompositeCancellable(min(16, source.maxConcurrency));\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true, true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                // If we transitioned from no demand, to some demand, then we should try to drain the queues which\n+                // may have signals pending due to previous over-request.\n+                if (pendingDemandUpdater.getAndAccumulate(this, n,\n+                        FlowControlUtils::addWithOverflowProtectionIfNotNegative) == 0) {\n+                    drainPending();\n+                }\n+                incMappedDemand(n);\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            if (!cancellableSubscribers.add(subscriber)) {\n+                return;\n+            }\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                if (prevActiveSources < 0) {\n+                    // We have been cancelled, or already completed and the active count flipped to negative, either\n+                    // way we don't want to Subscribe or retain a reference to this Publisher.\n+                    cancellableSubscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, true)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean fromUpstream) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, !fromUpstream, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(!fromUpstream, true);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void incMappedDemand(long n) {\n+            assert n > 0;\n+            mappedDemandUpdater.getAndAccumulate(this, n, FlowControlUtils::addWithUnderOverflowProtection);\n+        }\n+\n+        private int reserveMappedDemandQuota() {\n+            for (;;) {\n+                final long prevDemand = mappedDemand;\n+                if (prevDemand <= 0) {\n+                    // mappedDemand is allowed to go negative here in order to distribute MIN_MAPPED_DEMAND demand to\n+                    // each source. This is to avoid a single mapped source (or set of sources) not making any progress\n+                    // with the demand they were given, taking demand away from sources that could make progress. The\n+                    // negative value ensures that if a source completes with unused demand it doesn't result in\n+                    // artificially giving back \"negative\" demand and keeps the maximum queue size should be bound\n+                    // to (maxConcurrency * minMappedDemand).\n+                    if (mappedDemandUpdater.compareAndSet(this, prevDemand, prevDemand - MIN_MAPPED_DEMAND)) {\n+                        return MIN_MAPPED_DEMAND;\n+                    }\n+                } else {\n+                    final int quota = calculateRequestNQuota(prevDemand);\n+                    if (mappedDemandUpdater.compareAndSet(this, prevDemand, prevDemand - quota)) {\n+                        return quota;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void distributeMappedDemand(FlatMapPublisherSubscriber<T, R> hungrySubscriber) {\n+            final int quota = reserveMappedDemandQuota();\n+            final int usedQuota = hungrySubscriber.request(quota);\n+            if (usedQuota < quota) {\n+                incMappedDemand(quota - usedQuota);\n+            }\n+        }\n+\n+        private int calculateRequestNQuota(long availableRequestN) {\n+            // Get an approximate quota to distribute to each active mapped subscriber.\n+            return (int) min(Integer.MAX_VALUE, max(availableRequestN / source.maxConcurrency, MIN_MAPPED_DEMAND));\n+        }\n+\n+        private void doCancel(boolean cancelSubscription, boolean invalidatePendingDemand) {\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions. This should be Integer.MIN_VALUE to prevent subsequent mapped\n+            // source completion from incrementing the count to 0 or positive as terminateActiveMappedSources flips\n+            // the count to negative to signal to mapped sources we have completed.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            if (invalidatePendingDemand) {\n+                pendingDemand = -1;\n+            }\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                cancellableSubscribers.cancel();\n+                // Don't bother clearing out signals (which require additional concurrency control) because it is\n+                // assumed this Subscriber will be dereferenced and eligible for GC [1].\n+                // [1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#3.13\n+            }\n+        }\n+\n+        private boolean tryDecrementPendingDemand() {\n+            for (;;) {\n+                final long prevDemand = pendingDemand;\n+                if (prevDemand <= 0) {\n+                    return false;\n+                } else if (pendingDemandUpdater.compareAndSet(this, prevDemand, prevDemand - 1)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        private void tryEmitItem(Object item, FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (tryAcquireLock(emittingLockUpdater, this)) { // fast path. no concurrency, try to skip the queue.\n+                boolean mappedSourcesCompleted = false;\n+                try {\n+                    if (subscriber.hasSignalsQueued() || (needsDemand(item) && !tryDecrementPendingDemand())) {\n+                        subscriber.markSignalsQueued();\n+                        enqueueItem(item); // drain isn't necessary. when demand arrives a drain will be attempted.", "originalCommit": "acf1824e3eb85a637139297c89e4c9e3c2ed5533", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY4MzI0OQ==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r494683249", "bodyText": "As the subscription in this case is wrapped into a ConcurrentSubscription, I don't think there is a need to go through the queue for MAPPED_SOURCE_COMPLETE. Each completion can just request(1) and the batching if any could come from ConcurrentSubscription. Removing this special item will reduce the conditionals in the drain loop thus reducing cognitive overhead.", "author": "NiteshKant", "createdAt": "2020-09-25T00:35:20Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * Implementation of {@link Publisher#flatMapMerge(Function)}.\n+ * <p>\n+ * This implementation makes some trade-offs that may have performance/memory impacts. Demand distributed to mapped\n+ * {@link Publisher}s is dynamic and correlates to downstream demand. This dynamic behavior is targeted toward use cases\n+ * where:\n+ * <ul>\n+ *     <li>{@link Subscriber#onNext(Object) onNext Objects} consume non trivial amount of memory relative to the memory\n+ *     for managing demand through the {@link FlatMapSubscriber#signals} queue (network buffer, serialized POJO)</li>\n+ *     <li>downstream demand is available before signals from mapped sources are available\n+ *     (e.g. over a network boundary)</li>\n+ * </ul>\n+ * Scenarios where downstream demand is provided in small/slow increments relative to the amount of signals from mapped\n+ * Sources, or mapped Sources are backed by in memory content are expected to incur some additional overhead for\n+ * managing demand through the {@link FlatMapSubscriber#signals} queue.\n+ *\n+ * @param <T> Type of original {@link Publisher}.\n+ * @param <R> Type of {@link Publisher} returned by the operator.\n+ */\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private static final int MIN_MAPPED_DEMAND = 1;\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 8, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> mappedDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"mappedDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+        private volatile long mappedDemand;\n+\n+        // protected by emitting lock, or only accessed inside the Subscriber thread\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final DynamicCompositeCancellable cancellableSubscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            signals = newUnboundedMpscQueue(4);\n+            cancellableSubscribers = new SetDynamicCompositeCancellable(min(16, source.maxConcurrency));\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true, true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                // If we transitioned from no demand, to some demand, then we should try to drain the queues which\n+                // may have signals pending due to previous over-request.\n+                if (pendingDemandUpdater.getAndAccumulate(this, n,\n+                        FlowControlUtils::addWithOverflowProtectionIfNotNegative) == 0) {\n+                    drainPending();\n+                }\n+                incMappedDemand(n);\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            if (!cancellableSubscribers.add(subscriber)) {\n+                return;\n+            }\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                if (prevActiveSources < 0) {\n+                    // We have been cancelled, or already completed and the active count flipped to negative, either\n+                    // way we don't want to Subscribe or retain a reference to this Publisher.\n+                    cancellableSubscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, true)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean fromUpstream) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, !fromUpstream, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(!fromUpstream, true);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void incMappedDemand(long n) {\n+            assert n > 0;\n+            mappedDemandUpdater.getAndAccumulate(this, n, FlowControlUtils::addWithUnderOverflowProtection);\n+        }\n+\n+        private int reserveMappedDemandQuota() {\n+            for (;;) {\n+                final long prevDemand = mappedDemand;\n+                if (prevDemand <= 0) {\n+                    // mappedDemand is allowed to go negative here in order to distribute MIN_MAPPED_DEMAND demand to\n+                    // each source. This is to avoid a single mapped source (or set of sources) not making any progress\n+                    // with the demand they were given, taking demand away from sources that could make progress. The\n+                    // negative value ensures that if a source completes with unused demand it doesn't result in\n+                    // artificially giving back \"negative\" demand and keeps the maximum queue size should be bound\n+                    // to (maxConcurrency * minMappedDemand).\n+                    if (mappedDemandUpdater.compareAndSet(this, prevDemand, prevDemand - MIN_MAPPED_DEMAND)) {\n+                        return MIN_MAPPED_DEMAND;\n+                    }\n+                } else {\n+                    final int quota = calculateRequestNQuota(prevDemand);\n+                    if (mappedDemandUpdater.compareAndSet(this, prevDemand, prevDemand - quota)) {\n+                        return quota;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void distributeMappedDemand(FlatMapPublisherSubscriber<T, R> hungrySubscriber) {\n+            final int quota = reserveMappedDemandQuota();\n+            final int usedQuota = hungrySubscriber.request(quota);\n+            if (usedQuota < quota) {\n+                incMappedDemand(quota - usedQuota);\n+            }\n+        }\n+\n+        private int calculateRequestNQuota(long availableRequestN) {\n+            // Get an approximate quota to distribute to each active mapped subscriber.\n+            return (int) min(Integer.MAX_VALUE, max(availableRequestN / source.maxConcurrency, MIN_MAPPED_DEMAND));\n+        }\n+\n+        private void doCancel(boolean cancelSubscription, boolean invalidatePendingDemand) {\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions. This should be Integer.MIN_VALUE to prevent subsequent mapped\n+            // source completion from incrementing the count to 0 or positive as terminateActiveMappedSources flips\n+            // the count to negative to signal to mapped sources we have completed.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            if (invalidatePendingDemand) {\n+                pendingDemand = -1;\n+            }\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                cancellableSubscribers.cancel();\n+                // Don't bother clearing out signals (which require additional concurrency control) because it is\n+                // assumed this Subscriber will be dereferenced and eligible for GC [1].\n+                // [1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#3.13\n+            }\n+        }\n+\n+        private boolean tryDecrementPendingDemand() {\n+            for (;;) {\n+                final long prevDemand = pendingDemand;\n+                if (prevDemand <= 0) {\n+                    return false;\n+                } else if (pendingDemandUpdater.compareAndSet(this, prevDemand, prevDemand - 1)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        private void tryEmitItem(Object item, FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (tryAcquireLock(emittingLockUpdater, this)) { // fast path. no concurrency, try to skip the queue.\n+                boolean mappedSourcesCompleted = false;\n+                try {\n+                    if (subscriber.hasSignalsQueued() || (needsDemand(item) && !tryDecrementPendingDemand())) {\n+                        subscriber.markSignalsQueued();\n+                        enqueueItem(item); // drain isn't necessary. when demand arrives a drain will be attempted.\n+                    } else if (item == MAPPED_SOURCE_COMPLETE) {\n+                        mappedSourcesCompleted = true;\n+                    } else {\n+                        final boolean demandConsumed = sendToTarget(item);\n+                        assert demandConsumed == needsDemand(item);\n+                    }\n+                } finally {\n+                    if (!releaseLock(emittingLockUpdater, this)) {\n+                        drainPending();\n+                    }\n+                }\n+                if (mappedSourcesCompleted) { // request more from upstream outside the critical section.\n+                    requestMoreFromUpstream(1);\n+                }\n+            } else { // slow path. there is concurrency, go through the queue to avoid concurrent delivery.\n+                subscriber.markSignalsQueued();\n+                enqueueAndDrain(item);\n+            }\n+        }\n+\n+        private void enqueueItem(Object item) {\n+            if (!signals.offer(item)) {\n+                enqueueFailed(item);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            enqueueItem(item);\n+            drainPending();\n+        }\n+\n+        private void enqueueFailed(Object item) {\n+            QueueFullException exception = new QueueFullException(\"signals\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, false);\n+            }\n+        }\n+\n+        private void drainPending() {\n+            Throwable delayedCause = null;\n+            boolean tryAcquire = true;\n+            int mappedSourcesCompleted = 0;\n+            while (tryAcquire && tryAcquireLock(emittingLockUpdater, this)) {\n+                try {\n+                    final long prevDemand = pendingDemandUpdater.getAndSet(this, 0);\n+                    long emittedCount = 0;\n+                    if (prevDemand < 0) {\n+                        pendingDemand = prevDemand;\n+                        // Don't wait for demand to deliver the terminalNotification if present. The queued signals\n+                        // maybe from optimistic demand, but the error is from an event that needs immediate propagation\n+                        // (e.g. illegal requestN, failure to enqueue).\n+                        TerminalNotification t = terminalNotification;\n+                        if (t != null && t != complete()) {\n+                            sendToTarget(t); // if this throws its OK as we have terminated\n+                        }\n+                    } else {\n+                        Object t;\n+                        while (emittedCount < prevDemand && (t = signals.poll()) != null) {\n+                            try {\n+                                if (t == MAPPED_SOURCE_COMPLETE) {\n+                                    ++mappedSourcesCompleted;\n+                                } else if (sendToTarget(t)) {\n+                                    ++emittedCount;\n+                                }\n+                            } catch (Throwable cause) {\n+                                delayedCause = catchUnexpected(delayedCause, cause);\n+                            }\n+                        }\n+\n+                        // check if a terminal event is pending, or give back demand.\n+                        if (emittedCount == prevDemand) {\n+                            for (;;) {\n+                                try {\n+                                    t = signals.peek();\n+                                    if (t == MAPPED_SOURCE_COMPLETE) {\n+                                        signals.poll();\n+                                        ++mappedSourcesCompleted;\n+                                    } else if (t instanceof FlatMapPublisherSubscriber) {\n+                                        signals.poll();\n+                                        @SuppressWarnings(\"unchecked\")\n+                                        final FlatMapPublisherSubscriber<T, R> hungrySubscriber =\n+                                                (FlatMapPublisherSubscriber<T, R>) t;\n+                                        distributeMappedDemand(hungrySubscriber);\n+                                    } else {\n+                                        break;\n+                                    }\n+                                } catch (Throwable cause) {\n+                                    delayedCause = catchUnexpected(delayedCause, cause);\n+                                }\n+                            }\n+\n+                            if (t instanceof TerminalNotification) {\n+                                sendToTarget((TerminalNotification) t); // if this throws its OK as we have terminated\n+                            }\n+                        } else {\n+                            assert emittedCount < prevDemand;\n+                            pendingDemandUpdater.accumulateAndGet(this, prevDemand - emittedCount,\n+                                    FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n+                        }\n+                    }\n+                } finally {\n+                    tryAcquire = !releaseLock(emittingLockUpdater, this);\n+                }\n+            }\n+\n+            if (mappedSourcesCompleted != 0) {\n+                requestMoreFromUpstream(mappedSourcesCompleted);\n+            }\n+\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void requestMoreFromUpstream(int mappedSourcesCompleted) {\n+            assert mappedSourcesCompleted > 0;\n+            assert subscription != null;\n+            subscription.request(mappedSourcesCompleted);\n+        }\n+\n+        private static boolean needsDemand(Object item) {\n+            return item != MAPPED_SOURCE_COMPLETE &&\n+                    !(item instanceof FlatMapPublisherSubscriber) && !(item instanceof TerminalNotification);\n+        }\n+\n+        private boolean sendToTarget(Object item) {\n+            assert item != MAPPED_SOURCE_COMPLETE;\n+            if (targetTerminated) {\n+                return false;\n+            } else if (item instanceof TerminalNotification) {\n+                TerminalNotification terminalNotification;\n+                if (item == complete() && (terminalNotification = this.terminalNotification) != null) {\n+                    // Load the terminal notification in case an error happened after an onComplete and we override the\n+                    // terminal value.\n+                    sendToTarget(terminalNotification);\n+                } else {\n+                    sendToTarget((TerminalNotification) item);\n+                }\n+                return false;\n+            } else if (item instanceof FlatMapPublisherSubscriber) {\n+                @SuppressWarnings(\"unchecked\")\n+                final FlatMapPublisherSubscriber<T, R> hungrySubscriber = (FlatMapPublisherSubscriber<T, R>) item;\n+                distributeMappedDemand(hungrySubscriber);\n+                return false;\n+            }\n+            target.onNext(unwrapNullUnchecked(item));\n+            return true;\n+        }\n+\n+        private void sendToTarget(TerminalNotification terminalNotification) {\n+            signals.clear();\n+            targetTerminated = true;\n+            CompositeException de = this.delayedError;\n+            if (de != null) {\n+                de.transferPendingToSuppressed();\n+                if (terminalNotification.cause() == de) {\n+                    terminalNotification.terminate(target);\n+                } else {\n+                    terminalNotification.terminate(target, de);\n+                }\n+            } else {\n+                terminalNotification.terminate(target);\n+            }\n+        }\n+\n+        private boolean terminateActiveMappedSources() {\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                assert prevActiveSources >= 0; // otherwise we have seen multiple onComplete signals\n+                if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, -prevActiveSources)) {\n+                    return prevActiveSources == 0;\n+                }\n+            }\n+        }\n+\n+        private boolean decrementActiveMappedSources() {\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                assert prevActiveSources != 0;\n+                if (prevActiveSources > 0) {\n+                    if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources - 1)) {\n+                        return false;\n+                    }\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    return prevActiveSources == -1;\n+                }\n+            }\n+        }\n+\n+        private boolean removeSubscriber(final FlatMapPublisherSubscriber<T, R> subscriber, int unusedDemand) {\n+            if (cancellableSubscribers.remove(subscriber) && decrementActiveMappedSources()) {\n+                return true;\n+            } else if (unusedDemand > 0) {\n+                incMappedDemand(unusedDemand);\n+            }\n+            return false;\n+        }\n+\n+        private static final class FlatMapPublisherSubscriber<T, R> implements Subscriber<R>, Cancellable {\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicIntegerFieldUpdater<FlatMapPublisherSubscriber> pendingDemandUpdater =\n+                    AtomicIntegerFieldUpdater.newUpdater(FlatMapPublisherSubscriber.class, \"innerPendingDemand\");\n+\n+            private final FlatMapSubscriber<T, R> parent;\n+            private final DelayedSubscription subscription;\n+            private volatile int innerPendingDemand;\n+            /**\n+             * visibility provided by the {@link Subscriber} thread in {@link #onNext(Object)}, and\n+             * demand is exhausted before {@link #request(long)} is called, and that method triggers\n+             * {@link Subscription#request(long)} which provides a\n+             * <a href=\"https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#1.1\">\n+             * happens-before relationship between requesting elements and receiving elements</a>.\n+             */\n+            private boolean signalsQueued;\n+\n+            FlatMapPublisherSubscriber(FlatMapSubscriber<T, R> parent) {\n+                this.parent = parent;\n+                subscription = new DelayedSubscription();\n+            }\n+\n+            @Override\n+            public void cancel() {\n+                subscription.cancel();\n+            }\n+\n+            int request(int n) {\n+                assert n > 0;\n+                if (!pendingDemandUpdater.compareAndSet(this, 0, n)) {\n+                    return 0;\n+                }\n+                signalsQueued = false;\n+                subscription.request(n);\n+                return n;\n+            }\n+\n+            void markSignalsQueued() {\n+                signalsQueued = true;\n+            }\n+\n+            boolean hasSignalsQueued() {\n+                return signalsQueued;\n+            }\n+\n+            @Override\n+            public void onSubscribe(final Subscription s) {\n+                subscription.delayedSubscription(ConcurrentSubscription.wrap(s));\n+                // RequestN management for mapped sources is \"approximate\" as it is divided between mapped sources. More\n+                // demand may be distributed than is requested from downstream in order to avoid deadlock scenarios.\n+                // To accommodate for the \"approximate\" mapped demand we maintain a signal queue (bounded by the\n+                // concurrency). This presents an opportunity to decouple downstream requestN requests from iterating\n+                // all active mapped sources and instead optimistically give out demand here and replenish demand after\n+                // signals are delivered to the downstream subscriber (based upon available demand is available).\n+                parent.distributeMappedDemand(this);\n+            }\n+\n+            @Override\n+            public void onNext(@Nullable final R r) {\n+                parent.tryEmitItem(wrapNull(r), this);\n+                final int pendingDemand = pendingDemandUpdater.decrementAndGet(this);\n+                if (pendingDemand == 0) {\n+                    // Emit this item to signify this Subscriber is hungry for more demand when it is available.\n+                    parent.tryEmitItem(this, this);\n+                } else if (pendingDemand < 0) {\n+                    throw new IllegalStateException(\"Too many onNext signals for Subscriber: \" + this +\n+                            \" pendingDemand: \" + pendingDemand);\n+                }\n+            }\n+\n+            @Override\n+            public void onError(final Throwable t) {\n+                if (!parent.source.delayError) {\n+                    // Make sure errors aren't delivered out of order relative to onNext signals which maybe queued.\n+                    try {\n+                        parent.doCancel(true, false);\n+                    } finally {\n+                        parent.tryEmitItem(TerminalNotification.error(t), this);\n+                    }\n+                } else {\n+                    CompositeException de = parent.delayedError;\n+                    if (de == null) {\n+                        de = new CompositeException(t);\n+                        if (!delayedErrorUpdater.compareAndSet(parent, null, de)) {\n+                            de = parent.delayedError;\n+                            assert de != null;\n+                            de.add(t);\n+                        }\n+                    } else {\n+                        de.add(t);\n+                    }\n+                    if (parent.removeSubscriber(this, pendingDemandUpdater.getAndSet(this, -1))) {\n+                        parent.enqueueAndDrain(TerminalNotification.error(de));\n+                    } else {\n+                        parent.tryEmitItem(MAPPED_SOURCE_COMPLETE, this);\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void onComplete() {\n+                if (parent.removeSubscriber(this, pendingDemandUpdater.getAndSet(this, -1))) {\n+                    parent.enqueueAndDrain(complete());\n+                } else {\n+                    parent.tryEmitItem(MAPPED_SOURCE_COMPLETE, this);", "originalCommit": "acf1824e3eb85a637139297c89e4c9e3c2ed5533", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI0NjQzNw==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r496246437", "bodyText": "MAPPED_SOURCE_COMPLETE going through the queue isn't for concurrency control on the Subscription but instead to bound how much data we queue. In order to avoid deadlock scenarios we always give some demand to mapped sources which means queued data should be expected in low downstream demand scenarios. Due to this we simplify demand management and request more from the mapped source in its subscriber's onSubscribe method (as opposed to trying to avoid distributing demand when downstream demand is 0). If we don't go through the queue here we will have to adjust when we requestN flow. I'll add a unit test to demonstrate the behavior and we can consider changes to control flow in a followup PR.", "author": "Scottmitch", "createdAt": "2020-09-28T21:36:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY4MzI0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk3OTkyOA==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r496979928", "bodyText": "discussed offline, fine as is.", "author": "Scottmitch", "createdAt": "2020-09-29T19:16:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY4MzI0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY4NzQ1NA==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r494687454", "bodyText": "Unrelated but the DynamicCompositeCancellable also return true if they were not able to add the Cancellable. Perhaps that is a bug.", "author": "NiteshKant", "createdAt": "2020-09-25T00:50:46Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * Implementation of {@link Publisher#flatMapMerge(Function)}.\n+ * <p>\n+ * This implementation makes some trade-offs that may have performance/memory impacts. Demand distributed to mapped\n+ * {@link Publisher}s is dynamic and correlates to downstream demand. This dynamic behavior is targeted toward use cases\n+ * where:\n+ * <ul>\n+ *     <li>{@link Subscriber#onNext(Object) onNext Objects} consume non trivial amount of memory relative to the memory\n+ *     for managing demand through the {@link FlatMapSubscriber#signals} queue (network buffer, serialized POJO)</li>\n+ *     <li>downstream demand is available before signals from mapped sources are available\n+ *     (e.g. over a network boundary)</li>\n+ * </ul>\n+ * Scenarios where downstream demand is provided in small/slow increments relative to the amount of signals from mapped\n+ * Sources, or mapped Sources are backed by in memory content are expected to incur some additional overhead for\n+ * managing demand through the {@link FlatMapSubscriber#signals} queue.\n+ *\n+ * @param <T> Type of original {@link Publisher}.\n+ * @param <R> Type of {@link Publisher} returned by the operator.\n+ */\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private static final int MIN_MAPPED_DEMAND = 1;\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 8, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> mappedDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"mappedDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+        private volatile long mappedDemand;\n+\n+        // protected by emitting lock, or only accessed inside the Subscriber thread\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final DynamicCompositeCancellable cancellableSubscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            signals = newUnboundedMpscQueue(4);\n+            cancellableSubscribers = new SetDynamicCompositeCancellable(min(16, source.maxConcurrency));\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true, true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                // If we transitioned from no demand, to some demand, then we should try to drain the queues which\n+                // may have signals pending due to previous over-request.\n+                if (pendingDemandUpdater.getAndAccumulate(this, n,\n+                        FlowControlUtils::addWithOverflowProtectionIfNotNegative) == 0) {\n+                    drainPending();\n+                }\n+                incMappedDemand(n);\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            if (!cancellableSubscribers.add(subscriber)) {", "originalCommit": "acf1824e3eb85a637139297c89e4c9e3c2ed5533", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI1NzYxOQ==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r496257619", "bodyText": "Good catch! #1159", "author": "Scottmitch", "createdAt": "2020-09-28T21:52:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY4NzQ1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY5MjkzOA==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r494692938", "bodyText": "I don't think this is required, i.e. have dual mode whether errors skip the queue or not based on pendingDemand being negative.\nThe context is spread out to call-sites of doCancel() and makes the control flow too hard to follow.", "author": "NiteshKant", "createdAt": "2020-09-25T01:13:45Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * Implementation of {@link Publisher#flatMapMerge(Function)}.\n+ * <p>\n+ * This implementation makes some trade-offs that may have performance/memory impacts. Demand distributed to mapped\n+ * {@link Publisher}s is dynamic and correlates to downstream demand. This dynamic behavior is targeted toward use cases\n+ * where:\n+ * <ul>\n+ *     <li>{@link Subscriber#onNext(Object) onNext Objects} consume non trivial amount of memory relative to the memory\n+ *     for managing demand through the {@link FlatMapSubscriber#signals} queue (network buffer, serialized POJO)</li>\n+ *     <li>downstream demand is available before signals from mapped sources are available\n+ *     (e.g. over a network boundary)</li>\n+ * </ul>\n+ * Scenarios where downstream demand is provided in small/slow increments relative to the amount of signals from mapped\n+ * Sources, or mapped Sources are backed by in memory content are expected to incur some additional overhead for\n+ * managing demand through the {@link FlatMapSubscriber#signals} queue.\n+ *\n+ * @param <T> Type of original {@link Publisher}.\n+ * @param <R> Type of {@link Publisher} returned by the operator.\n+ */\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private static final int MIN_MAPPED_DEMAND = 1;\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 8, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> mappedDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"mappedDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+        private volatile long mappedDemand;\n+\n+        // protected by emitting lock, or only accessed inside the Subscriber thread\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final DynamicCompositeCancellable cancellableSubscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            signals = newUnboundedMpscQueue(4);\n+            cancellableSubscribers = new SetDynamicCompositeCancellable(min(16, source.maxConcurrency));\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true, true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                // If we transitioned from no demand, to some demand, then we should try to drain the queues which\n+                // may have signals pending due to previous over-request.\n+                if (pendingDemandUpdater.getAndAccumulate(this, n,\n+                        FlowControlUtils::addWithOverflowProtectionIfNotNegative) == 0) {\n+                    drainPending();\n+                }\n+                incMappedDemand(n);\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            if (!cancellableSubscribers.add(subscriber)) {\n+                return;\n+            }\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                if (prevActiveSources < 0) {\n+                    // We have been cancelled, or already completed and the active count flipped to negative, either\n+                    // way we don't want to Subscribe or retain a reference to this Publisher.\n+                    cancellableSubscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, true)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean fromUpstream) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, !fromUpstream, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(!fromUpstream, true);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void incMappedDemand(long n) {\n+            assert n > 0;\n+            mappedDemandUpdater.getAndAccumulate(this, n, FlowControlUtils::addWithUnderOverflowProtection);\n+        }\n+\n+        private int reserveMappedDemandQuota() {\n+            for (;;) {\n+                final long prevDemand = mappedDemand;\n+                if (prevDemand <= 0) {\n+                    // mappedDemand is allowed to go negative here in order to distribute MIN_MAPPED_DEMAND demand to\n+                    // each source. This is to avoid a single mapped source (or set of sources) not making any progress\n+                    // with the demand they were given, taking demand away from sources that could make progress. The\n+                    // negative value ensures that if a source completes with unused demand it doesn't result in\n+                    // artificially giving back \"negative\" demand and keeps the maximum queue size should be bound\n+                    // to (maxConcurrency * minMappedDemand).\n+                    if (mappedDemandUpdater.compareAndSet(this, prevDemand, prevDemand - MIN_MAPPED_DEMAND)) {\n+                        return MIN_MAPPED_DEMAND;\n+                    }\n+                } else {\n+                    final int quota = calculateRequestNQuota(prevDemand);\n+                    if (mappedDemandUpdater.compareAndSet(this, prevDemand, prevDemand - quota)) {\n+                        return quota;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void distributeMappedDemand(FlatMapPublisherSubscriber<T, R> hungrySubscriber) {\n+            final int quota = reserveMappedDemandQuota();\n+            final int usedQuota = hungrySubscriber.request(quota);\n+            if (usedQuota < quota) {\n+                incMappedDemand(quota - usedQuota);\n+            }\n+        }\n+\n+        private int calculateRequestNQuota(long availableRequestN) {\n+            // Get an approximate quota to distribute to each active mapped subscriber.\n+            return (int) min(Integer.MAX_VALUE, max(availableRequestN / source.maxConcurrency, MIN_MAPPED_DEMAND));\n+        }\n+\n+        private void doCancel(boolean cancelSubscription, boolean invalidatePendingDemand) {\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions. This should be Integer.MIN_VALUE to prevent subsequent mapped\n+            // source completion from incrementing the count to 0 or positive as terminateActiveMappedSources flips\n+            // the count to negative to signal to mapped sources we have completed.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            if (invalidatePendingDemand) {\n+                pendingDemand = -1;\n+            }\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                cancellableSubscribers.cancel();\n+                // Don't bother clearing out signals (which require additional concurrency control) because it is\n+                // assumed this Subscriber will be dereferenced and eligible for GC [1].\n+                // [1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#3.13\n+            }\n+        }\n+\n+        private boolean tryDecrementPendingDemand() {\n+            for (;;) {\n+                final long prevDemand = pendingDemand;\n+                if (prevDemand <= 0) {\n+                    return false;\n+                } else if (pendingDemandUpdater.compareAndSet(this, prevDemand, prevDemand - 1)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        private void tryEmitItem(Object item, FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (tryAcquireLock(emittingLockUpdater, this)) { // fast path. no concurrency, try to skip the queue.\n+                boolean mappedSourcesCompleted = false;\n+                try {\n+                    if (subscriber.hasSignalsQueued() || (needsDemand(item) && !tryDecrementPendingDemand())) {\n+                        subscriber.markSignalsQueued();\n+                        enqueueItem(item); // drain isn't necessary. when demand arrives a drain will be attempted.\n+                    } else if (item == MAPPED_SOURCE_COMPLETE) {\n+                        mappedSourcesCompleted = true;\n+                    } else {\n+                        final boolean demandConsumed = sendToTarget(item);\n+                        assert demandConsumed == needsDemand(item);\n+                    }\n+                } finally {\n+                    if (!releaseLock(emittingLockUpdater, this)) {\n+                        drainPending();\n+                    }\n+                }\n+                if (mappedSourcesCompleted) { // request more from upstream outside the critical section.\n+                    requestMoreFromUpstream(1);\n+                }\n+            } else { // slow path. there is concurrency, go through the queue to avoid concurrent delivery.\n+                subscriber.markSignalsQueued();\n+                enqueueAndDrain(item);\n+            }\n+        }\n+\n+        private void enqueueItem(Object item) {\n+            if (!signals.offer(item)) {\n+                enqueueFailed(item);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            enqueueItem(item);\n+            drainPending();\n+        }\n+\n+        private void enqueueFailed(Object item) {\n+            QueueFullException exception = new QueueFullException(\"signals\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, false);\n+            }\n+        }\n+\n+        private void drainPending() {\n+            Throwable delayedCause = null;\n+            boolean tryAcquire = true;\n+            int mappedSourcesCompleted = 0;\n+            while (tryAcquire && tryAcquireLock(emittingLockUpdater, this)) {\n+                try {\n+                    final long prevDemand = pendingDemandUpdater.getAndSet(this, 0);\n+                    long emittedCount = 0;\n+                    if (prevDemand < 0) {\n+                        pendingDemand = prevDemand;\n+                        // Don't wait for demand to deliver the terminalNotification if present. The queued signals", "originalCommit": "acf1824e3eb85a637139297c89e4c9e3c2ed5533", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzE1ODQ2OQ==", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r497158469", "bodyText": "discussed details offline and clarified the failure scenarios we are accommodating for with this code. fine as is.", "author": "Scottmitch", "createdAt": "2020-09-29T23:57:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY5MjkzOA=="}], "type": "inlineReview"}, {"oid": "64ef837e515755872016c7f19ae0d6dbc1ddec75", "url": "https://github.com/apple/servicetalk/commit/64ef837e515755872016c7f19ae0d6dbc1ddec75", "message": "Add Publisher#flatMapMerge operator\n\nMotivation:\nPublisher#flatMapMerge is a basic building block for each element of a\nPublisher to map into another Publisher.\n\nModifications:\n- Add Publisher#flatMapMerge operator\n\nResult:\nEach item emitted on a Publisher can be mapped to another Publisher.", "committedDate": "2020-09-29T19:06:32Z", "type": "commit"}, {"oid": "0d9dc5013d4d2ba4e4cd90dda1a3b60c67fde92c", "url": "https://github.com/apple/servicetalk/commit/0d9dc5013d4d2ba4e4cd90dda1a3b60c67fde92c", "message": "change to queue more instead of manage request n demand. this way we\nensure we make progress at the expense of memory, and less coordination\nmanaging request(n) lending/distribution.", "committedDate": "2020-09-29T19:06:32Z", "type": "commit"}, {"oid": "a998b67385a3a58aa1e25feef1b30b2d58fd0e00", "url": "https://github.com/apple/servicetalk/commit/a998b67385a3a58aa1e25feef1b30b2d58fd0e00", "message": "review comments", "committedDate": "2020-09-29T19:06:32Z", "type": "commit"}, {"oid": "75db20e0be1a43ca3c81d5c7a32fe262dca1072f", "url": "https://github.com/apple/servicetalk/commit/75db20e0be1a43ca3c81d5c7a32fe262dca1072f", "message": "update transferPendingToSuppressed() method name", "committedDate": "2020-09-29T19:06:32Z", "type": "commit"}, {"oid": "ee838d0460174656bb32c7b1aa740524c7236b18", "url": "https://github.com/apple/servicetalk/commit/ee838d0460174656bb32c7b1aa740524c7236b18", "message": "review comments", "committedDate": "2020-09-29T19:06:32Z", "type": "commit"}, {"oid": "d20fd92e86eede6b920d306d393255178b632d3d", "url": "https://github.com/apple/servicetalk/commit/d20fd92e86eede6b920d306d393255178b632d3d", "message": "first cut, adjust mapped demand to account for downstream demand", "committedDate": "2020-09-29T19:06:32Z", "type": "commit"}, {"oid": "07cecbf0813869f0ea823a0f228aa3696ddb9658", "url": "https://github.com/apple/servicetalk/commit/07cecbf0813869f0ea823a0f228aa3696ddb9658", "message": "review comments, correct mapped request demand distribution, out of order mapped error delivery", "committedDate": "2020-09-29T19:06:32Z", "type": "commit"}, {"oid": "e1f62532eb2d79c735b1a19dd2e02ca938aae79f", "url": "https://github.com/apple/servicetalk/commit/e1f62532eb2d79c735b1a19dd2e02ca938aae79f", "message": "correct javadocs for FLowControlUtils method", "committedDate": "2020-09-29T19:06:32Z", "type": "commit"}, {"oid": "ef94510d7e204a7c4bd676224c80787530cc9b0c", "url": "https://github.com/apple/servicetalk/commit/ef94510d7e204a7c4bd676224c80787530cc9b0c", "message": "remove hungrySubscriber queue, make sure we always give demand to mapped sources optimistically to avoid deadlock", "committedDate": "2020-09-29T19:06:32Z", "type": "commit"}, {"oid": "ed385f2feacc426891bb2ba9c36c820df1a23e6c", "url": "https://github.com/apple/servicetalk/commit/ed385f2feacc426891bb2ba9c36c820df1a23e6c", "message": "remove method in mapped subscriber", "committedDate": "2020-09-29T19:06:32Z", "type": "commit"}, {"oid": "9d9c3247541030744fc3386799099fadcc28431d", "url": "https://github.com/apple/servicetalk/commit/9d9c3247541030744fc3386799099fadcc28431d", "message": "review comments", "committedDate": "2020-09-29T19:06:33Z", "type": "commit"}, {"oid": "9d9c3247541030744fc3386799099fadcc28431d", "url": "https://github.com/apple/servicetalk/commit/9d9c3247541030744fc3386799099fadcc28431d", "message": "review comments", "committedDate": "2020-09-29T19:06:33Z", "type": "forcePushed"}]}