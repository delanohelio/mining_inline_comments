{"pr_number": 1285, "pr_title": "Handle `close_notify` TLS alert", "pr_createdAt": "2020-12-18T01:41:04Z", "pr_url": "https://github.com/apple/servicetalk/pull/1285", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUxOTk5OQ==", "url": "https://github.com/apple/servicetalk/pull/1285#discussion_r545519999", "bodyText": "@Scottmitch as we discussed here, I will submit a PR to rename it to StepVerifiers.\nI will keep it without static import. In the context of PublisherStepVerifierTest, create(from(\"foo\", \"bar\")) looks ok. But when the test is related to some business logic, things like create(conn.read()) are a bit confusing. Not clear what are we creating. Something like Verifiers.stepVerifier(...) might be a better option.", "author": "idelpivnitskiy", "createdAt": "2020-12-18T01:47:43Z", "path": "servicetalk-transport-netty-internal/src/test/java/io/servicetalk/transport/netty/internal/SslCloseNotifyAlertClientHandlingTest.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.netty.internal;\n+\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.test.FirstSteps;\n+\n+import org.junit.Test;\n+\n+import java.nio.channels.ClosedChannelException;\n+\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessor;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+\n+public class SslCloseNotifyAlertClientHandlingTest extends AbstractSslCloseNotifyAlertHandlingTest {\n+\n+    public SslCloseNotifyAlertClientHandlingTest() throws Exception {\n+        super(true);\n+    }\n+\n+    @Test\n+    public void afterExchangeIdleConnection() {\n+        sendRequest();\n+        FirstSteps.create(conn.read())", "originalCommit": "acf2139a663319fe53eabdc0a80a0bc82e360a97", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUyMzAxMA==", "url": "https://github.com/apple/servicetalk/pull/1285#discussion_r545523010", "bodyText": "Renaming: #1286", "author": "idelpivnitskiy", "createdAt": "2020-12-18T01:57:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUxOTk5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU0Nzk2NA==", "url": "https://github.com/apple/servicetalk/pull/1285#discussion_r545547964", "bodyText": "I'm fine with a more descriptive method name (e.g. Verifiers.stepVerifier). now is the time before we release \ud83d\udc4d  feel free to open a PR.", "author": "Scottmitch", "createdAt": "2020-12-18T03:20:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUxOTk5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczMjQxMA==", "url": "https://github.com/apple/servicetalk/pull/1285#discussion_r545732410", "bodyText": "Verifiers: #1290", "author": "idelpivnitskiy", "createdAt": "2020-12-18T10:12:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUxOTk5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUyMDY4Nw==", "url": "https://github.com/apple/servicetalk/pull/1285#discussion_r545520687", "bodyText": "It looks enough for me to call closeHandler.closeChannelOutbound here. It will generate ChannelOutputShutdownEvent, triggering channelOutboundListener.channelClosed. WDYT?", "author": "idelpivnitskiy", "createdAt": "2020-12-18T01:49:38Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java", "diffHunk": "@@ -641,8 +642,17 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n                 connection.closeHandler.channelClosedOutbound(ctx);\n                 connection.channelOutboundListener.channelClosed(StacklessClosedChannelException.newInstance(\n                         DefaultNettyConnection.class, \"userEventTriggered(ChannelOutputShutdownEvent)\"));\n+            } else if (evt == SslCloseCompletionEvent.SUCCESS) {\n+                // Received \"close_notify\" alert from the peer: https://tools.ietf.org/html/rfc5246#section-7.2.1.\n+                // This message notifies that the sender will not send any more messages on this connection.\n+\n+                // Notify close handler first to enhance error reporting and prevent LB from selecting this connection\n+                connection.closeHandler.channelClosedInbound(ctx);\n+                // We MUST respond with a \"close_notify\" alert and close down the connection immediately,\n+                // discarding any pending writes.\n+                connection.closeHandler.closeChannelOutbound(ctx.channel());", "originalCommit": "acf2139a663319fe53eabdc0a80a0bc82e360a97", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU0MDUxMw==", "url": "https://github.com/apple/servicetalk/pull/1285#discussion_r545540513", "bodyText": "looks like the CloseHandler owns the responsibility of calling shutdownOutput() and the associated state machine around it. for H2 this will currently close the channel more abruptly with close() which may mean the local peer won't finish sending currently buffered/pending data. despite the spec saying close down the connection immediately, discarding any pending writes.we can make a best effort to flush our queues without losing much...\n         @Override\n         void closeChannelOutbound(final Channel channel) {\n-            channel.close();\n+            channel.writeAndFlush(EmptyBuffer.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);\n         }\nwe may want to inject a similar event at the ServiceTalk layer to catch any inflight signals (which maybe offloaded). however we wouldn't want lack of demand (or cancellation) to prevent the cleanup process (so maybe not worth the trouble). it would be good to test this at the protocol layer as I recall similar misses in Netty.", "author": "Scottmitch", "createdAt": "2020-12-18T02:53:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUyMDY4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcyMjM3OQ==", "url": "https://github.com/apple/servicetalk/pull/1285#discussion_r545722379", "bodyText": "I think channel.close() for h2 is fine. This will happen for the stream only, not for the parent connection. For the parent channel, I think it's netty responsibility to handle this event and fail all subsequent attempts to create new child channels.\nWhy should we try to flush any data if the spec says that we must discard them and close immediately? IIUC, the remote peer that generated close_nofity alert won't be able to ready any new data on that connection because the SSLEngine is already closed.", "author": "idelpivnitskiy", "createdAt": "2020-12-18T09:53:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUyMDY4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA2OTg3Mw==", "url": "https://github.com/apple/servicetalk/pull/1285#discussion_r546069873", "bodyText": "IIRC immediately closing the channel makes it so that netty itself cannot followup with any fatal alerts or close_notify which makes debugging harder.\nwe should verify that the receiver can still get fatal alerts and meaningful exceptions (e.g. certificate expired, invalid cert, etc.)", "author": "Scottmitch", "createdAt": "2020-12-18T20:16:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUyMDY4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjEwNjg2Ng==", "url": "https://github.com/apple/servicetalk/pull/1285#discussion_r546106866", "bodyText": "SslHandler intercepts close() and emits close_notify alert. It was not intercepting half-closure (shoutdown output), but we handle it manually in RequestResponseCloseHandler.", "author": "idelpivnitskiy", "createdAt": "2020-12-18T21:48:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUyMDY4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUyMTQzMA==", "url": "https://github.com/apple/servicetalk/pull/1285#discussion_r545521430", "bodyText": "An example of when FirstSteps.create overloads for sources are useful. It's a bit annoying to use fromSource everywhere.", "author": "idelpivnitskiy", "createdAt": "2020-12-18T01:52:05Z", "path": "servicetalk-transport-netty-internal/src/test/java/io/servicetalk/transport/netty/internal/SslCloseNotifyAlertClientHandlingTest.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.netty.internal;\n+\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.test.FirstSteps;\n+\n+import org.junit.Test;\n+\n+import java.nio.channels.ClosedChannelException;\n+\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessor;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+\n+public class SslCloseNotifyAlertClientHandlingTest extends AbstractSslCloseNotifyAlertHandlingTest {\n+\n+    public SslCloseNotifyAlertClientHandlingTest() throws Exception {\n+        super(true);\n+    }\n+\n+    @Test\n+    public void afterExchangeIdleConnection() {\n+        sendRequest();\n+        FirstSteps.create(conn.read())\n+                .then(() -> channel.writeInbound(BEGIN))\n+                .expectNext(BEGIN)\n+                .then(() -> channel.writeInbound(END))\n+                .expectNext(END)\n+                .expectComplete()\n+                .verify();\n+        closeNotifyAndVerifyClosing();\n+    }\n+\n+    @Test\n+    public void afterRequestBeforeReadingResponse() {\n+        sendRequest();\n+        FirstSteps.create(conn.read())\n+                .then(this::closeNotifyAndVerifyClosing)\n+                .expectError(ClosedChannelException.class)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void afterRequestWhileReadingResponse() {\n+        sendRequest();\n+        FirstSteps.create(conn.read())\n+                .then(() -> channel.writeInbound(BEGIN))\n+                .expectNext(BEGIN)\n+                .then(this::closeNotifyAndVerifyClosing)\n+                .expectError(ClosedChannelException.class)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void whileWritingRequestBeforeReadingResponse() {\n+        PublisherSource.Processor<String, String> writeSource = newPublisherProcessor();\n+        FirstSteps.create(conn.write(fromSource(writeSource)).merge(conn.read()))\n+                .then(() -> {\n+                    // Start writing request\n+                    writeMsg(writeSource, BEGIN);\n+                    closeNotifyAndVerifyClosing();\n+                })\n+                .expectError(ClosedChannelException.class)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void whileWritingRequestAndReadingResponse() {\n+        PublisherSource.Processor<String, String> writeSource = newPublisherProcessor();\n+        FirstSteps.create(conn.write(fromSource(writeSource)).merge(conn.read()))", "originalCommit": "acf2139a663319fe53eabdc0a80a0bc82e360a97", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU0NzU0Mg==", "url": "https://github.com/apple/servicetalk/pull/1285#discussion_r545547542", "bodyText": "gotcha, we can add method overloads for the Source types if we will make use of them.", "author": "Scottmitch", "createdAt": "2020-12-18T03:19:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUyMTQzMA=="}], "type": "inlineReview"}, {"oid": "1a7a61cd360f4e8bf8e9733889d1bd82f45b6c3d", "url": "https://github.com/apple/servicetalk/commit/1a7a61cd360f4e8bf8e9733889d1bd82f45b6c3d", "message": "Handle `close_notify` TLS alert\n\nMotivation:\n\nTLS protocol defined `close_notify` alert message [1], which notifies that the\nsender will not send any more messages on this connection. `SslHandler`\ngenerates `SslCloseCompletionEvent` in this case, then transport emits\n`ChannelInputShutdownReadComplete` event when the FIN is received. There is a\nrace between these 2 user events and sending a new request on the client-side.\nWe MUST close down the connection immediately, discarding any pending writes,\nand preventing new requests. We should also mark that the connection is\nclosing asap to prevent LB from selecting this connection.\n\n1. https://tools.ietf.org/html/rfc5246#section-7.2.1\n\nModifications:\n\n- Handle `SslCloseCompletionEvent` in `DefaultNettyConnection`;\n- Add tests to verify client and server behavior when `SslCloseCompletionEvent`\nis received;\n\nResult:\n\nThe connection transitions to the \"closing\" state as soon as the\n`SslCloseCompletionEvent` is observed, preventing new writes on this connection\nand failing the first write, making failures retryable.", "committedDate": "2020-12-18T02:33:14Z", "type": "commit"}, {"oid": "25568178150c9dcc82df432976bb9f752e50e250", "url": "https://github.com/apple/servicetalk/commit/25568178150c9dcc82df432976bb9f752e50e250", "message": "Rename `FirstSteps` -> `StepVerifiers`", "committedDate": "2020-12-18T02:34:12Z", "type": "commit"}, {"oid": "25568178150c9dcc82df432976bb9f752e50e250", "url": "https://github.com/apple/servicetalk/commit/25568178150c9dcc82df432976bb9f752e50e250", "message": "Rename `FirstSteps` -> `StepVerifiers`", "committedDate": "2020-12-18T02:34:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUzNjQ1Nw==", "url": "https://github.com/apple/servicetalk/pull/1285#discussion_r545536457", "bodyText": "this is the first time we are introducing multiple calls to channelClosedInbound. consider clarifying in the API docs that the method is idempotent.", "author": "Scottmitch", "createdAt": "2020-12-18T02:40:39Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java", "diffHunk": "@@ -641,8 +642,17 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n                 connection.closeHandler.channelClosedOutbound(ctx);\n                 connection.channelOutboundListener.channelClosed(StacklessClosedChannelException.newInstance(\n                         DefaultNettyConnection.class, \"userEventTriggered(ChannelOutputShutdownEvent)\"));\n+            } else if (evt == SslCloseCompletionEvent.SUCCESS) {\n+                // Received \"close_notify\" alert from the peer: https://tools.ietf.org/html/rfc5246#section-7.2.1.\n+                // This message notifies that the sender will not send any more messages on this connection.\n+\n+                // Notify close handler first to enhance error reporting and prevent LB from selecting this connection\n+                connection.closeHandler.channelClosedInbound(ctx);", "originalCommit": "25568178150c9dcc82df432976bb9f752e50e250", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU0MTA5OQ==", "url": "https://github.com/apple/servicetalk/pull/1285#discussion_r545541099", "bodyText": "hooray for new test utilities \ud83c\udf89\nnit: use static import?", "author": "Scottmitch", "createdAt": "2020-12-18T02:55:50Z", "path": "servicetalk-transport-netty-internal/src/test/java/io/servicetalk/transport/netty/internal/AbstractSslCloseNotifyAlertHandlingTest.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Copyright \u00a9 2018-2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.netty.internal;\n+\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.test.StepVerifiers;\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.logging.api.LogLevel;\n+import io.servicetalk.transport.api.ConnectionInfo.Protocol;\n+import io.servicetalk.transport.netty.internal.NoopTransportObserver.NoopConnectionObserver;\n+\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.ssl.SslCloseCompletionEvent;\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import static io.servicetalk.buffer.netty.BufferAllocators.DEFAULT_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Executors.immediate;\n+import static io.servicetalk.transport.netty.internal.CloseHandler.forPipelinedRequestResponse;\n+import static io.servicetalk.transport.netty.internal.FlushStrategies.defaultFlushStrategy;\n+import static io.servicetalk.transport.netty.internal.OffloadAllExecutionStrategy.OFFLOAD_ALL_STRATEGY;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+\n+abstract class AbstractSslCloseNotifyAlertHandlingTest {\n+\n+    private static final WireLoggingInitializer WIRE_LOGGING_INITIALIZER =\n+            new WireLoggingInitializer(\"servicetalk-tests-wire-logger\", LogLevel.TRACE, () -> true);\n+\n+    protected static final String BEGIN = \"MSG_BEGIN\";\n+    protected static final String END = \"MSG_END\";\n+\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+\n+    protected final EmbeddedDuplexChannel channel;\n+    protected final DefaultNettyConnection<String, String> conn;\n+\n+    AbstractSslCloseNotifyAlertHandlingTest(boolean isClient) throws Exception {\n+        channel = new EmbeddedDuplexChannel(false);\n+        final CloseHandler closeHandler = forPipelinedRequestResponse(isClient, channel.config());\n+        conn = DefaultNettyConnection.<String, String>initChannel(channel, DEFAULT_ALLOCATOR, immediate(),\n+                END::equals, closeHandler, defaultFlushStrategy(), null,\n+                WIRE_LOGGING_INITIALIZER.andThen(ch -> ch.pipeline().addLast(new ChannelDuplexHandler() {\n+                    @Override\n+                    public void channelRead(final ChannelHandlerContext ctx, final Object msg) {\n+                        if (BEGIN.equals(msg)) {\n+                            closeHandler.protocolPayloadBeginInbound(ctx);\n+                        }\n+                        ctx.fireChannelRead(msg);\n+                        if (END.equals(msg)) {\n+                            closeHandler.protocolPayloadEndInbound(ctx);\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void write(final ChannelHandlerContext ctx, final Object msg, final ChannelPromise promise) {\n+                        if (BEGIN.equals(msg)) {\n+                            closeHandler.protocolPayloadBeginOutbound(ctx);\n+                        }\n+                        if (END.equals(msg)) {\n+                            closeHandler.protocolPayloadEndOutbound(ctx);\n+                            promise.addListener(f -> {\n+                                if (f.isSuccess()) {\n+                                    closeHandler.protocolPayloadEndOutboundSuccess(ctx);\n+                                }\n+                            });\n+                        }\n+                        ctx.write(msg, promise);\n+                    }\n+                })), OFFLOAD_ALL_STRATEGY, mock(Protocol.class), NoopConnectionObserver.INSTANCE, isClient)\n+                .toFuture().get();\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        try {\n+            // Make sure the connection and channel are closed after each test:\n+            assertThat(\"Underlying Channel is not closed\", channel.isOpen(), is(false));\n+            assertThat(\"Unexpected inbound messages\", channel.inboundMessages(), hasSize(0));\n+            assertThat(\"Unexpected outbound messages\", channel.outboundMessages(), hasSize(0));\n+            StepVerifiers.create(conn.onClose()).expectComplete().verify();", "originalCommit": "25568178150c9dcc82df432976bb9f752e50e250", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU0MTcxNw==", "url": "https://github.com/apple/servicetalk/pull/1285#discussion_r545541717", "bodyText": "OFFLOAD_ALL_STRATEGY -> consider parameterizing to cover different cases (specifically no-offload).", "author": "Scottmitch", "createdAt": "2020-12-18T02:57:56Z", "path": "servicetalk-transport-netty-internal/src/test/java/io/servicetalk/transport/netty/internal/AbstractSslCloseNotifyAlertHandlingTest.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Copyright \u00a9 2018-2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.netty.internal;\n+\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.test.StepVerifiers;\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.logging.api.LogLevel;\n+import io.servicetalk.transport.api.ConnectionInfo.Protocol;\n+import io.servicetalk.transport.netty.internal.NoopTransportObserver.NoopConnectionObserver;\n+\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.ssl.SslCloseCompletionEvent;\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import static io.servicetalk.buffer.netty.BufferAllocators.DEFAULT_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Executors.immediate;\n+import static io.servicetalk.transport.netty.internal.CloseHandler.forPipelinedRequestResponse;\n+import static io.servicetalk.transport.netty.internal.FlushStrategies.defaultFlushStrategy;\n+import static io.servicetalk.transport.netty.internal.OffloadAllExecutionStrategy.OFFLOAD_ALL_STRATEGY;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+\n+abstract class AbstractSslCloseNotifyAlertHandlingTest {\n+\n+    private static final WireLoggingInitializer WIRE_LOGGING_INITIALIZER =\n+            new WireLoggingInitializer(\"servicetalk-tests-wire-logger\", LogLevel.TRACE, () -> true);\n+\n+    protected static final String BEGIN = \"MSG_BEGIN\";\n+    protected static final String END = \"MSG_END\";\n+\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+\n+    protected final EmbeddedDuplexChannel channel;\n+    protected final DefaultNettyConnection<String, String> conn;\n+\n+    AbstractSslCloseNotifyAlertHandlingTest(boolean isClient) throws Exception {\n+        channel = new EmbeddedDuplexChannel(false);\n+        final CloseHandler closeHandler = forPipelinedRequestResponse(isClient, channel.config());\n+        conn = DefaultNettyConnection.<String, String>initChannel(channel, DEFAULT_ALLOCATOR, immediate(),\n+                END::equals, closeHandler, defaultFlushStrategy(), null,\n+                WIRE_LOGGING_INITIALIZER.andThen(ch -> ch.pipeline().addLast(new ChannelDuplexHandler() {\n+                    @Override\n+                    public void channelRead(final ChannelHandlerContext ctx, final Object msg) {\n+                        if (BEGIN.equals(msg)) {\n+                            closeHandler.protocolPayloadBeginInbound(ctx);\n+                        }\n+                        ctx.fireChannelRead(msg);\n+                        if (END.equals(msg)) {\n+                            closeHandler.protocolPayloadEndInbound(ctx);\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void write(final ChannelHandlerContext ctx, final Object msg, final ChannelPromise promise) {\n+                        if (BEGIN.equals(msg)) {\n+                            closeHandler.protocolPayloadBeginOutbound(ctx);\n+                        }\n+                        if (END.equals(msg)) {\n+                            closeHandler.protocolPayloadEndOutbound(ctx);\n+                            promise.addListener(f -> {\n+                                if (f.isSuccess()) {\n+                                    closeHandler.protocolPayloadEndOutboundSuccess(ctx);\n+                                }\n+                            });\n+                        }\n+                        ctx.write(msg, promise);\n+                    }\n+                })), OFFLOAD_ALL_STRATEGY, mock(Protocol.class), NoopConnectionObserver.INSTANCE, isClient)", "originalCommit": "25568178150c9dcc82df432976bb9f752e50e250", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTcyMjQ1Mw==", "url": "https://github.com/apple/servicetalk/pull/1285#discussion_r545722453", "bodyText": "We previously agreed not to use offloading with embedded channels because it does not have a proper event loop and offloading leads to flaky tests. Actually, the OFFLOAD_ALL_STRATEGY in this case is noop, because I pass immediate() executor for offloading. I can create a real noop ExecutionStrategy to avoid confusion.", "author": "idelpivnitskiy", "createdAt": "2020-12-18T09:53:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU0MTcxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA2NDA2Mw==", "url": "https://github.com/apple/servicetalk/pull/1285#discussion_r546064063", "bodyText": "not suggesting we need to enhance EmbeddedChannel to be thread safe. the reason I suggested using different executors was to ensure expectations around dropping data are consistently validated.", "author": "Scottmitch", "createdAt": "2020-12-18T20:02:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU0MTcxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU0NjgxOQ==", "url": "https://github.com/apple/servicetalk/pull/1285#discussion_r545546819", "bodyText": "can you add a test case that verifies a Retryable exception is delivered if the first write fails due to prior close_notify being received?", "author": "Scottmitch", "createdAt": "2020-12-18T03:16:36Z", "path": "servicetalk-transport-netty-internal/src/test/java/io/servicetalk/transport/netty/internal/SslCloseNotifyAlertClientHandlingTest.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.netty.internal;\n+\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.test.StepVerifiers;\n+\n+import org.junit.Test;\n+\n+import java.nio.channels.ClosedChannelException;\n+\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessor;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+\n+public class SslCloseNotifyAlertClientHandlingTest extends AbstractSslCloseNotifyAlertHandlingTest {", "originalCommit": "25568178150c9dcc82df432976bb9f752e50e250", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczMTg1Ng==", "url": "https://github.com/apple/servicetalk/pull/1285#discussion_r545731856", "bodyText": "I've enhanced existing tests to expect a correct subtype of ChannelClosedException where it's appropriate. It covers the suggested use-case.", "author": "idelpivnitskiy", "createdAt": "2020-12-18T10:11:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU0NjgxOQ=="}], "type": "inlineReview"}, {"oid": "3d11b597fed6a619a2bef804a93afedfd444ef61", "url": "https://github.com/apple/servicetalk/commit/3d11b597fed6a619a2bef804a93afedfd444ef61", "message": "Address comments", "committedDate": "2020-12-18T10:09:29Z", "type": "commit"}]}