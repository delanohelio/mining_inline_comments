{"pr_number": 912, "pr_title": "Support `router-api` annotations for gRPC services", "pr_createdAt": "2020-01-08T18:42:21Z", "pr_url": "https://github.com/apple/servicetalk/pull/912", "timeline": [{"oid": "3ebf63350515b3bbfeacfc2060170f1ffa9746cf", "url": "https://github.com/apple/servicetalk/commit/3ebf63350515b3bbfeacfc2060170f1ffa9746cf", "message": "Support `router-api` annotations for gRPC services\n\nMotivation:\n\ngRPC should support annotations that help to configure\nthe execution strategy per service or per route. Also,\ngRPC should compute the effective execution strategy\nbased on the main execution strategy from the builder\nconfiguration and from the route configuration.\n\nModifications:\n\n- Parse annotations from `route-api` module;\n- Compute difference between execution strategy on\nthe builder and on the route;\n- Add tests to verify that offloading works correctly\nfor different execution strategy configurations;\n- Add tests to verify that misconfiguration of\n`route-api` annotations will be explained to the user;\n- Adjust gRPC codegen for new features;\n- Fix tests;\n\nResult:\n\ngRPC routes correctly support per-route execution\nstrategy configuration.", "committedDate": "2020-01-08T18:39:51Z", "type": "commit"}, {"oid": "a4ac0e732c085787c16545da936ec3313ba746e0", "url": "https://github.com/apple/servicetalk/commit/a4ac0e732c085787c16545da936ec3313ba746e0", "message": "Use RouteExecutionStrategyFactory for Jersey", "committedDate": "2020-01-08T18:39:51Z", "type": "commit"}, {"oid": "1ff46887c987e1670c25b16642f86bd0d6564877", "url": "https://github.com/apple/servicetalk/commit/1ff46887c987e1670c25b16642f86bd0d6564877", "message": "Do not compare with noOffloadsStrategy() by reference", "committedDate": "2020-01-08T18:56:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM5MjMyOA==", "url": "https://github.com/apple/servicetalk/pull/912#discussion_r364392328", "bodyText": "We can not compare with noOffloadsStrategy() by reference, because we may receive a noOffloadsStrategy() which is wrapped by DefaultGrpcExecutionStrategy here or users may give their own implementation of the strategy without offloading.\n@NiteshKant WDYT about introducing something like boolean HttpExecutionStrategy.isNoOffloading()? Or maybe even promoting this method to ExecutionStrategy interface. That will help us to avoid duplication of noOffloads method impl, we will be able to use it in DefaultHttpExecutionStrategy.offloadService in addition to diff == null check, and users will have an easy way to check that there is no offloading.", "author": "idelpivnitskiy", "createdAt": "2020-01-08T19:02:38Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/HttpExecutionStrategies.java", "diffHunk": "@@ -117,10 +117,10 @@ public static Builder customStrategyBuilder() {\n     public static HttpExecutionStrategy difference(final Executor fallback,\n                                                    final HttpExecutionStrategy left,\n                                                    final HttpExecutionStrategy right) {\n-        if (left.equals(right) || right == noOffloadsStrategy()) {\n+        if (left.equals(right) || noOffloads(right)) {\n             return null;\n         }\n-        if (left == noOffloadsStrategy()) {\n+        if (noOffloads(left)) {", "originalCommit": "1ff46887c987e1670c25b16642f86bd0d6564877", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAxMjk1OQ==", "url": "https://github.com/apple/servicetalk/pull/912#discussion_r365012959", "bodyText": "I do not think that we will have many users checking presence/absence of no-offloads so I do not think we should promote this to a public API. The code repetition in jersey code is perhaps we can avoid by using this difference() method in jersey? There shouldn't be a reason for us to be different in behavior between routers. Is changing jersey to use the common difference() method here something you are thinking of doing?", "author": "NiteshKant", "createdAt": "2020-01-09T23:39:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM5MjMyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI1NTc1OQ==", "url": "https://github.com/apple/servicetalk/pull/912#discussion_r367255759", "bodyText": "I see that the PR #682 changes jersey router to use its own impl of difference function instead of the HttpExecutionStrategies.difference. If I change EndpointEnhancingRequestFilter to use HttpExecutionStrategies.difference, some tests in jersey module fail.", "author": "idelpivnitskiy", "createdAt": "2020-01-16T06:51:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM5MjMyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc4NzQxOA==", "url": "https://github.com/apple/servicetalk/pull/912#discussion_r367787418", "bodyText": "We can fix the tests if they are inaccurate or do not align with gRPC, there isn't a reason why they should be different. It is OK to do this in a follow up but we should look at reducing special cases between modules which makes it hard to reason about behavior later.", "author": "NiteshKant", "createdAt": "2020-01-17T06:36:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM5MjMyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA3MjQ1Ng==", "url": "https://github.com/apple/servicetalk/pull/912#discussion_r368072456", "bodyText": "Created an issue #924", "author": "idelpivnitskiy", "createdAt": "2020-01-17T18:22:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM5MjMyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQwMTA3Mg==", "url": "https://github.com/apple/servicetalk/pull/912#discussion_r364401072", "bodyText": "I see that Single and Completable have before/afterOnSubscribe, but doesn't have whenOnSubscribe (but Publisher has it). If they were missed, I can add them in a follow-up or create a \"good first issue\".\n@NiteshKant wdyt?\nAlso, we don't have whenSubscriber for all 3 async sources and Publisher.whenSubscription, but before/after* variants are exist.", "author": "idelpivnitskiy", "createdAt": "2020-01-08T19:22:13Z", "path": "servicetalk-grpc-netty/src/test/java/io/servicetalk/grpc/netty/ExecutionStrategyTestServices.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.grpc.netty;\n+\n+import io.servicetalk.concurrent.BlockingIterable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.grpc.api.GrpcPayloadWriter;\n+import io.servicetalk.grpc.api.GrpcServiceContext;\n+import io.servicetalk.grpc.netty.TesterProto.TestRequest;\n+import io.servicetalk.grpc.netty.TesterProto.TestResponse;\n+import io.servicetalk.grpc.netty.TesterProto.Tester.BlockingTesterService;\n+import io.servicetalk.grpc.netty.TesterProto.Tester.TesterService;\n+import io.servicetalk.router.api.NoOffloadsRouteExecutionStrategy;\n+import io.servicetalk.router.api.RouteExecutionStrategy;\n+\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+\n+/**\n+ * Each service method responds with {@link TestResponse} that encodes:\n+ * {@code <handle-thread-name>#<handle-executor-name>#<request-thread-name>#<response-thread-name>}.\n+ * <p>\n+ * Note: {@code <request-thread-name>/<response-thread-name>} is not {@code null} only when request/response is\n+ * asynchronous.\n+ * <p>\n+ * Use {@link ThreadInfo#parse(TestResponse)} to parse {@link TestResponse}.\n+ */\n+public final class ExecutionStrategyTestServices {\n+\n+    static final String NULL = \"null\";\n+\n+    static final TesterService DEFAULT_STRATEGY_ASYNC_SERVICE = new DefaultStrategyAsyncService();\n+    static final TesterService CLASS_EXEC_ID_STRATEGY_ASYNC_SERVICE = new ClassExecIdStrategyAsyncService();\n+    static final TesterService CLASS_NO_OFFLOADS_STRATEGY_ASYNC_SERVICE = new ClassNoOffloadsStrategyAsyncService();\n+    static final TesterService METHOD_NO_OFFLOADS_STRATEGY_ASYNC_SERVICE = new MethodNoOffloadsStrategyAsyncService();\n+\n+    static final BlockingTesterService DEFAULT_STRATEGY_BLOCKING_SERVICE = new DefaultStrategyBlockingService();\n+    static final BlockingTesterService CLASS_EXEC_ID_STRATEGY_BLOCKING_SERVICE =\n+            new ClassExecIdStrategyBlockingService();\n+    static final BlockingTesterService CLASS_NO_OFFLOADS_STRATEGY_BLOCKING_SERVICE =\n+            new ClassNoOffloadsStrategyBlockingService();\n+    static final BlockingTesterService METHOD_NO_OFFLOADS_STRATEGY_BLOCKING_SERVICE =\n+            new MethodNoOffloadsStrategyBlockingService();\n+\n+    private ExecutionStrategyTestServices() {\n+        // No instances\n+    }\n+\n+    private static String threadName() {\n+        return Thread.currentThread().getName();\n+    }\n+\n+    static final class ThreadInfo {\n+        final String handleExecutorName;\n+        final String handleThreadName;\n+        String requestOnSubscribeThreadName = NULL;\n+        String requestOnNextThreadName = NULL;\n+        String responseOnSubscribeThreadName = NULL;\n+        String responseOnNextThreadName = NULL;\n+\n+        ThreadInfo(final GrpcServiceContext ctx) {\n+            this.handleExecutorName = ctx.executionContext().executor().toString();\n+            this.handleThreadName = threadName();\n+        }\n+\n+        ThreadInfo(final String handleExecutorName, final String handleThreadName,\n+                   final String requestOnSubscribeThreadName, final String requestOnNextThreadName,\n+                   final String responseOnSubscribeThreadName, final String responseOnNextThreadName) {\n+            this.handleExecutorName = handleExecutorName;\n+            this.handleThreadName = handleThreadName;\n+            this.requestOnSubscribeThreadName = requestOnSubscribeThreadName;\n+            this.requestOnNextThreadName = requestOnNextThreadName;\n+            this.responseOnSubscribeThreadName = responseOnSubscribeThreadName;\n+            this.responseOnNextThreadName = responseOnNextThreadName;\n+        }\n+\n+        TestResponse encode() {\n+            return TestResponse.newBuilder().setMessage(handleExecutorName + '#' + handleThreadName + '#' +\n+                    requestOnSubscribeThreadName + '#' + requestOnNextThreadName + '#' +\n+                    responseOnSubscribeThreadName + '#' + responseOnNextThreadName).build();\n+        }\n+\n+        static ThreadInfo parse(final TestResponse response) {\n+            final String[] components = response.getMessage().split(\"#\");\n+            assert components.length == 6;\n+            return new ThreadInfo(components[0], components[1], components[2], components[3], components[4],\n+                    components[5]);\n+        }\n+    }\n+\n+    /// Async API:\n+\n+    private static class EsAsyncService implements TesterService {\n+\n+        @Override\n+        public Single<TestResponse> test(final GrpcServiceContext ctx, final TestRequest request) {\n+            final ThreadInfo threadInfo = new ThreadInfo(ctx);\n+            return succeeded(threadInfo)\n+                    .afterOnSubscribe(__ -> threadInfo.responseOnSubscribeThreadName = threadName())", "originalCommit": "1ff46887c987e1670c25b16642f86bd0d6564877", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY2NDg1MA==", "url": "https://github.com/apple/servicetalk/pull/912#discussion_r367664850", "bodyText": "It may have got missed, creating a good first issue SGTM", "author": "NiteshKant", "createdAt": "2020-01-16T21:41:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQwMTA3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE4NjI3MQ==", "url": "https://github.com/apple/servicetalk/pull/912#discussion_r368186271", "bodyText": "#926", "author": "idelpivnitskiy", "createdAt": "2020-01-18T00:17:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQwMTA3Mg=="}], "type": "inlineReview"}, {"oid": "5cb2127d357546d3c5f0c2cb13b79df48775be95", "url": "https://github.com/apple/servicetalk/commit/5cb2127d357546d3c5f0c2cb13b79df48775be95", "message": "Merge remote-tracking branch 'upstream/master' into grpc-annotations", "committedDate": "2020-01-08T20:52:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUwODk1OA==", "url": "https://github.com/apple/servicetalk/pull/912#discussion_r364508958", "bodyText": "Did anything change that we do not need the assert now?\nIf the assert is not required, then this method can be inlined in the constructor.", "author": "NiteshKant", "createdAt": "2020-01-09T00:24:48Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/BlockingStreamingToStreamingService.java", "diffHunk": "@@ -65,9 +65,7 @@\n     }\n \n     private static HttpExecutionStrategy serviceInvocationStrategy(final HttpExecutionStrategyInfluencer influencer) {\n-        HttpExecutionStrategy httpExecutionStrategy = influencer.influenceStrategy(DEFAULT_STRATEGY);\n-        assert httpExecutionStrategy.isMetadataReceiveOffloaded() : \"This will deadlock!\";\n-        return httpExecutionStrategy;\n+        return influencer.influenceStrategy(DEFAULT_STRATEGY);", "originalCommit": "5cb2127d357546d3c5f0c2cb13b79df48775be95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI2NTgyNg==", "url": "https://github.com/apple/servicetalk/pull/912#discussion_r367265826", "bodyText": "Previously, we used this conversion service as part of the computation of the main strategy for the builder. Therefore, we tried to prevent the case when users could misconfigure execution strategy for the blocking service.\nFor gRPC, we use this service between the router and the final RPC method and we may already be on executor thread.\nI will inline it.", "author": "idelpivnitskiy", "createdAt": "2020-01-16T07:28:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUwODk1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUxMDM2NQ==", "url": "https://github.com/apple/servicetalk/pull/912#discussion_r364510365", "bodyText": "Consider adding a comment as to why we are doing the difference of strategies.", "author": "NiteshKant", "createdAt": "2020-01-09T00:30:29Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultHttpExecutionStrategy.java", "diffHunk": "@@ -126,25 +127,31 @@ public StreamingHttpService offloadService(final Executor fallback, final Stream\n             public Single<StreamingHttpResponse> handle(final HttpServiceContext ctx,\n                                                         StreamingHttpRequest request,\n                                                         final StreamingHttpResponseFactory responseFactory) {\n-                HttpServiceContext wrappedCtx =\n+                final HttpExecutionStrategy diff = difference(fallback, ctx.executionContext().executionStrategy(),", "originalCommit": "5cb2127d357546d3c5f0c2cb13b79df48775be95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUxMTkwMg==", "url": "https://github.com/apple/servicetalk/pull/912#discussion_r364511902", "bodyText": "Consider adding a test that passes strategy here to verify that offloadService() does not offload in that case.", "author": "NiteshKant", "createdAt": "2020-01-09T00:36:48Z", "path": "servicetalk-http-api/src/test/java/io/servicetalk/http/api/DefaultHttpExecutionStrategyTest.java", "diffHunk": "@@ -179,7 +180,9 @@ public void wrapService() throws Exception {\n         DefaultStreamingHttpRequestResponseFactory respFactory =\n                 new DefaultStreamingHttpRequestResponseFactory(DEFAULT_ALLOCATOR, INSTANCE, HTTP_1_1);\n         TestHttpServiceContext ctx = new TestHttpServiceContext(INSTANCE, respFactory,\n-                new ExecutionContextToHttpExecutionContext(contextRule, strategy));\n+                // Use noOffloadsStrategy() for the ctx to indicate that there was no offloading before.", "originalCommit": "5cb2127d357546d3c5f0c2cb13b79df48775be95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg5NDA1Mw==", "url": "https://github.com/apple/servicetalk/pull/912#discussion_r364894053", "bodyText": "Remove empty try-with-resources and simply call close():\nGrpcServers.forAddress(localAddress(0)).listenAndAwait(serviceFactory).close();", "author": "NiteshKant", "createdAt": "2020-01-09T18:29:19Z", "path": "servicetalk-grpc-netty/src/test/java/io/servicetalk/grpc/netty/ExecutionStrategyConfigurationFailuresTest.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.grpc.netty;\n+\n+import io.servicetalk.concurrent.BlockingIterable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.grpc.api.GrpcExecutionStrategy;\n+import io.servicetalk.grpc.api.GrpcPayloadWriter;\n+import io.servicetalk.grpc.api.GrpcServiceContext;\n+import io.servicetalk.grpc.netty.TesterProto.Tester.BlockingTesterService;\n+import io.servicetalk.grpc.netty.TesterProto.Tester.ServiceFactory;\n+import io.servicetalk.grpc.netty.TesterProto.Tester.TesterService;\n+import io.servicetalk.router.api.NoOffloadsRouteExecutionStrategy;\n+import io.servicetalk.router.api.RouteExecutionStrategy;\n+import io.servicetalk.router.api.RouteExecutionStrategyFactory;\n+import io.servicetalk.transport.api.ServerContext;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+import static io.servicetalk.grpc.api.GrpcExecutionStrategies.noOffloadsStrategy;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.localAddress;\n+import static org.hamcrest.Matchers.allOf;\n+import static org.hamcrest.Matchers.containsString;\n+\n+public class ExecutionStrategyConfigurationFailuresTest {\n+\n+    @NoOffloadsRouteExecutionStrategy\n+    private static final class MisconfiguredService implements TesterService {\n+\n+        @Override\n+        @NoOffloadsRouteExecutionStrategy\n+        @RouteExecutionStrategy(id = \"test\")\n+        public Single<TesterProto.TestResponse> test(final GrpcServiceContext ctx,\n+                                                     final TesterProto.TestRequest request) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        @RouteExecutionStrategy(id = \"\")\n+        public Publisher<TesterProto.TestResponse> testBiDiStream(final GrpcServiceContext ctx,\n+                                                                  final Publisher<TesterProto.TestRequest> request) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        @RouteExecutionStrategy(id = \"unknown\")\n+        public Publisher<TesterProto.TestResponse> testResponseStream(final GrpcServiceContext ctx,\n+                                                                      final TesterProto.TestRequest request) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        @RouteExecutionStrategy(id = \"test\")\n+        public Single<TesterProto.TestResponse> testRequestStream(final GrpcServiceContext ctx,\n+                                                                  final Publisher<TesterProto.TestRequest> request) {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    @NoOffloadsRouteExecutionStrategy\n+    private static final class MisconfiguredBlockingService implements BlockingTesterService {\n+\n+        @Override\n+        @NoOffloadsRouteExecutionStrategy\n+        @RouteExecutionStrategy(id = \"test\")\n+        public TesterProto.TestResponse test(final GrpcServiceContext ctx, final TesterProto.TestRequest request) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        @RouteExecutionStrategy(id = \"\")\n+        public void testBiDiStream(final GrpcServiceContext ctx,\n+                                   final BlockingIterable<TesterProto.TestRequest> request,\n+                                   final GrpcPayloadWriter<TesterProto.TestResponse> responseWriter) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        @RouteExecutionStrategy(id = \"unknown\")\n+        public void testResponseStream(final GrpcServiceContext ctx, final TesterProto.TestRequest request,\n+                                       final GrpcPayloadWriter<TesterProto.TestResponse> responseWriter) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        @RouteExecutionStrategy(id = \"test\")\n+        public TesterProto.TestResponse testRequestStream(final GrpcServiceContext ctx,\n+                                                          final BlockingIterable<TesterProto.TestRequest> request) {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    private static final TesterService MISCONFIGURED_SERVICE = new MisconfiguredService();\n+    private static final BlockingTesterService MISCONFIGURED_BLOCKING_SERVICE = new MisconfiguredBlockingService();\n+    private static final RouteExecutionStrategyFactory<GrpcExecutionStrategy> STRATEGY_FACTORY =\n+            id -> \"test\".equals(id) ? noOffloadsStrategy() : null;\n+\n+    @Rule\n+    public final ExpectedException expected = ExpectedException.none();\n+\n+    @Test\n+    public void usingServiceFactoryAsyncService() throws Exception {\n+        usingServiceFactory(new ServiceFactory(MISCONFIGURED_SERVICE));\n+    }\n+\n+    @Test\n+    public void usingServiceFactoryBlockingService() throws Exception {\n+        usingServiceFactory(new ServiceFactory(MISCONFIGURED_BLOCKING_SERVICE));\n+    }\n+\n+    private void usingServiceFactory(final ServiceFactory serviceFactory) throws Exception {\n+        expected.expect(IllegalStateException.class);\n+        expected.expectMessage(allOf(\n+                containsString(\"test(\"),\n+                containsString(\"testBiDiStream(\"),\n+                containsString(\"testResponseStream(\"),\n+                containsString(\"testRequestStream(\")));\n+\n+        GrpcServers.forAddress(localAddress(0)).listenAndAwait(serviceFactory);\n+    }\n+\n+    @Test\n+    public void usingServiceFactoryWithStrategyFactoryAsyncService() throws Exception {\n+        usingServiceFactoryWithStrategyFactory(new ServiceFactory(MISCONFIGURED_SERVICE, STRATEGY_FACTORY));\n+    }\n+\n+    @Test\n+    public void usingServiceFactoryWithStrategyFactoryBlockingService() throws Exception {\n+        usingServiceFactoryWithStrategyFactory(new ServiceFactory(MISCONFIGURED_BLOCKING_SERVICE, STRATEGY_FACTORY));\n+    }\n+\n+    private void usingServiceFactoryWithStrategyFactory(final ServiceFactory serviceFactory) throws Exception {\n+        expected.expect(IllegalStateException.class);\n+        expected.expectMessage(allOf(\n+                containsString(\"test(\"),\n+                containsString(\"testBiDiStream(\"),\n+                containsString(\"testResponseStream(\")));\n+\n+        GrpcServers.forAddress(localAddress(0)).listenAndAwait(serviceFactory);\n+    }\n+\n+    @Test\n+    public void usingServiceFactoryBuilderAsyncService() throws Exception {\n+        usingServiceFactoryBuilder(new ServiceFactory.Builder()\n+                .testRequestStream(MISCONFIGURED_SERVICE).build());\n+    }\n+\n+    @Test\n+    public void usingServiceFactoryBuilderBlockingService() throws Exception {\n+        usingServiceFactoryBuilder(new ServiceFactory.Builder()\n+                .testRequestStreamBlocking(MISCONFIGURED_BLOCKING_SERVICE).build());\n+    }\n+\n+    private void usingServiceFactoryBuilder(final ServiceFactory serviceFactory) throws Exception {\n+        expected.expect(IllegalStateException.class);\n+        expected.expectMessage(allOf(\n+                containsString(\"Failed to create execution strategy ID\"),\n+                containsString(\"testRequestStream(\")));\n+\n+        GrpcServers.forAddress(localAddress(0)).listenAndAwait(serviceFactory);\n+    }\n+\n+    @Test\n+    public void usingServiceFactoryBuilderWithStrategyFactoryAsyncService() throws Exception {\n+        usingServiceFactoryBuilderWithStrategyFactory(new ServiceFactory.Builder(STRATEGY_FACTORY)\n+                .testRequestStream(MISCONFIGURED_SERVICE).build());\n+    }\n+\n+    @Test\n+    public void usingServiceFactoryBuilderWithStrategyFactoryBlockingService() throws Exception {\n+        usingServiceFactoryBuilderWithStrategyFactory(new ServiceFactory.Builder(STRATEGY_FACTORY)\n+                .testRequestStreamBlocking(MISCONFIGURED_BLOCKING_SERVICE).build());\n+    }\n+\n+    private static void usingServiceFactoryBuilderWithStrategyFactory(final ServiceFactory serviceFactory)\n+            throws Exception {\n+        try (ServerContext server = GrpcServers.forAddress(localAddress(0))", "originalCommit": "5cb2127d357546d3c5f0c2cb13b79df48775be95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg5NzUyMg==", "url": "https://github.com/apple/servicetalk/pull/912#discussion_r364897522", "bodyText": "Add this constant in Words? and strategyFactoryType in Types?", "author": "NiteshKant", "createdAt": "2020-01-09T18:37:07Z", "path": "servicetalk-grpc-protoc/src/main/java/io/servicetalk/grpc/protoc/Generator.java", "diffHunk": "@@ -309,13 +311,25 @@ private void addServiceFactory(final State state, final TypeSpec.Builder service\n         final ClassName builderClass = serviceFactoryClass.nestedClass(Builder);\n         final ClassName serviceFromRoutesClass = builderClass.nestedClass(state.serviceClass.simpleName() +\n                 \"FromRoutes\");\n+        final TypeName strategyFactoryType = ParameterizedTypeName.get(RouteExecutionStrategyFactory,\n+                GrpcExecutionStrategy);\n+        final String strategyFactoryName = \"strategyFactory\";", "originalCommit": "5cb2127d357546d3c5f0c2cb13b79df48775be95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg5ODM1Nw==", "url": "https://github.com/apple/servicetalk/pull/912#discussion_r364898357", "bodyText": "Is null in any case a valid return value? Should we instead have this method throw new IllegalArgumentException(\"unknown strategy: \" + id)", "author": "NiteshKant", "createdAt": "2020-01-09T18:39:12Z", "path": "servicetalk-router-api/src/main/java/io/servicetalk/router/api/RouteExecutionStrategyFactory.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.router.api;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A factory that creates execution strategy for different {@link RouteExecutionStrategy#id() id}s of\n+ * {@link RouteExecutionStrategy} annotation.\n+ *\n+ * @param <ES> protocol-specific execution strategy implementation\n+ */\n+@FunctionalInterface\n+public interface RouteExecutionStrategyFactory<ES> {\n+\n+    /**\n+     * Gets an execution strategy for the specified {@code id}{@link RouteExecutionStrategy#id() id} of\n+     * {@link RouteExecutionStrategy} annotation.\n+     *\n+     * @param id of {@link RouteExecutionStrategy}\n+     * @return {@link ES} implementation or {@code null}\n+     */\n+    @Nullable", "originalCommit": "5cb2127d357546d3c5f0c2cb13b79df48775be95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUzOTcxOQ==", "url": "https://github.com/apple/servicetalk/pull/912#discussion_r367539719", "bodyText": "This is a good point. We use __ -> null as a default factory in Jersey. However, we have an error processing check that makes sure the factory provides an execution strategy for all ids. Let me try to use IllegalArgumentException instead.", "author": "idelpivnitskiy", "createdAt": "2020-01-16T17:03:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg5ODM1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg5OTcyMQ==", "url": "https://github.com/apple/servicetalk/pull/912#discussion_r364899721", "bodyText": "Use $T.class instead of $L.getClass() like we do for input/output type here?", "author": "NiteshKant", "createdAt": "2020-01-09T18:42:13Z", "path": "servicetalk-grpc-protoc/src/main/java/io/servicetalk/grpc/protoc/Generator.java", "diffHunk": "@@ -342,9 +356,9 @@ private void addServiceFactory(final State state, final TypeSpec.Builder service\n                             .addModifiers(PUBLIC)\n                             .addParameter(rpcInterface.className, rpc, FINAL)\n                             .returns(builderClass)\n-                            .addStatement(\"$L($T.$L, $L.wrap($L::$L, $L), $T.class, $T.class, $L)\",\n-                                    addRouteMethodName, rpcInterface.className, RPC_PATH, routeInterfaceClass,\n-                                    rpc, routeName, rpc, inClass, outClass, serializationProvider)\n+                            .addStatement(\"$L($T.$L, $L.getClass(), $S, $L.wrap($L::$L, $L), $T.class, $T.class, $L)\",", "originalCommit": "5cb2127d357546d3c5f0c2cb13b79df48775be95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUyMTY4Mw==", "url": "https://github.com/apple/servicetalk/pull/912#discussion_r367521683", "bodyText": "We cannot use $T.class here because we need an actual implementation provided by the user (that is annotated), instead of just an rpc static interface.", "author": "idelpivnitskiy", "createdAt": "2020-01-16T16:31:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg5OTcyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA0ODkwNw==", "url": "https://github.com/apple/servicetalk/pull/912#discussion_r368048907", "bodyText": "got it, thanks", "author": "NiteshKant", "createdAt": "2020-01-17T17:22:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDg5OTcyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDkwNDY5Ng==", "url": "https://github.com/apple/servicetalk/pull/912#discussion_r364904696", "bodyText": "Try avoiding user-visible changes such as these when they are unrelated to the PR description.", "author": "NiteshKant", "createdAt": "2020-01-09T18:51:35Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/GlobalExecutionContext.java", "diffHunk": "@@ -60,7 +60,7 @@ public static ExecutionContext globalExecutionContext() {\n         static {\n             final IoExecutor ioExecutor = createIoExecutor(new IoThreadFactory(\"servicetalk-global-io-executor\", true));\n             final Executor executor = newCachedThreadExecutor(\n-                    new DefaultThreadFactory(\"servicetalk-global-executor\", true, NORM_PRIORITY));\n+                    new DefaultThreadFactory(\"servicetalk-global-executor-\", true, NORM_PRIORITY));", "originalCommit": "5cb2127d357546d3c5f0c2cb13b79df48775be95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDkwNjQwNw==", "url": "https://github.com/apple/servicetalk/pull/912#discussion_r364906407", "bodyText": "nit: use a more meaningful name; serviceClass", "author": "NiteshKant", "createdAt": "2020-01-09T18:55:36Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcRoutes.java", "diffHunk": "@@ -138,10 +164,18 @@ protected GrpcService newServiceFromRoutes(final AllGrpcRoutes routes) {\n         };\n     }\n \n+    @Nullable\n+    private GrpcExecutionStrategy executionStrategy(final Method method, final Class<?> clazz) {\n+        return getAndValidateRouteExecutionStrategyAnnotationIfPresent(method, clazz, strategyFactory, errors,\n+                noOffloadsStrategy());\n+    }\n+\n     /**\n      * Adds a {@link Route} to this factory.\n      *\n      * @param path for this route.\n+     * @param clazz {@link Class} of the gRPC service.", "originalCommit": "5cb2127d357546d3c5f0c2cb13b79df48775be95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk4ODE1MA==", "url": "https://github.com/apple/servicetalk/pull/912#discussion_r364988150", "bodyText": "Spotbugs doesn't like this for some reason for me locally, complaining about:\nBug type RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE (click for details)\u00a0In class \nio.servicetalk.grpc.netty.ExecutionStrategyTest$RouteApi\u00a0In method \nio.servicetalk.grpc.netty.ExecutionStrategyTest$RouteApi.extractResponse(Callable)\u00a0Value loaded from iter\u00a0Return \nvalue of io.servicetalk.concurrent.BlockingIterable.iterator() of type io.servicetalk.concurrent.BlockingIterator\u00a0At \nExecutionStrategyTest.java:[line 214]\u00a0Redundant null check at ExecutionStrategyTest.java:[line 218]\n--\n\n\n\n\nCan you add an exclusion for this:\n  <Match>\n    <Class name=\"io.servicetalk.grpc.netty.ExecutionStrategyTest$RouteApi\"/>\n    <Method name=\"extractResponse\"/>\n    <Bug pattern=\"RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE\"/>\n  </Match>", "author": "NiteshKant", "createdAt": "2020-01-09T22:19:40Z", "path": "servicetalk-grpc-netty/src/test/java/io/servicetalk/grpc/netty/ExecutionStrategyTest.java", "diffHunk": "@@ -0,0 +1,573 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.grpc.netty;\n+\n+import io.servicetalk.concurrent.BlockingIterable;\n+import io.servicetalk.concurrent.BlockingIterator;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.ExecutorRule;\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.grpc.api.GrpcServerBuilder;\n+import io.servicetalk.grpc.netty.ExecutionStrategyTestServices.ThreadInfo;\n+import io.servicetalk.grpc.netty.TesterProto.TestRequest;\n+import io.servicetalk.grpc.netty.TesterProto.TestResponse;\n+import io.servicetalk.grpc.netty.TesterProto.Tester.BlockingTesterClient;\n+import io.servicetalk.grpc.netty.TesterProto.Tester.ClientFactory;\n+import io.servicetalk.grpc.netty.TesterProto.Tester.ServiceFactory;\n+import io.servicetalk.transport.api.ServerContext;\n+\n+import org.junit.After;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+\n+import static io.servicetalk.grpc.api.GrpcExecutionStrategies.defaultStrategy;\n+import static io.servicetalk.grpc.api.GrpcExecutionStrategies.noOffloadsStrategy;\n+import static io.servicetalk.grpc.netty.ExecutionStrategyTestServices.CLASS_EXEC_ID_STRATEGY_ASYNC_SERVICE;\n+import static io.servicetalk.grpc.netty.ExecutionStrategyTestServices.CLASS_EXEC_ID_STRATEGY_BLOCKING_SERVICE;\n+import static io.servicetalk.grpc.netty.ExecutionStrategyTestServices.CLASS_NO_OFFLOADS_STRATEGY_ASYNC_SERVICE;\n+import static io.servicetalk.grpc.netty.ExecutionStrategyTestServices.CLASS_NO_OFFLOADS_STRATEGY_BLOCKING_SERVICE;\n+import static io.servicetalk.grpc.netty.ExecutionStrategyTestServices.DEFAULT_STRATEGY_ASYNC_SERVICE;\n+import static io.servicetalk.grpc.netty.ExecutionStrategyTestServices.DEFAULT_STRATEGY_BLOCKING_SERVICE;\n+import static io.servicetalk.grpc.netty.ExecutionStrategyTestServices.METHOD_NO_OFFLOADS_STRATEGY_ASYNC_SERVICE;\n+import static io.servicetalk.grpc.netty.ExecutionStrategyTestServices.METHOD_NO_OFFLOADS_STRATEGY_BLOCKING_SERVICE;\n+import static io.servicetalk.grpc.netty.ExecutionStrategyTestServices.NULL;\n+import static io.servicetalk.grpc.netty.ExecutionStrategyTestServices.ThreadInfo.parse;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.localAddress;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.serverHostAndPort;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.unmodifiableList;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.startsWith;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assume.assumeFalse;\n+\n+@RunWith(Parameterized.class)\n+public class ExecutionStrategyTest {\n+\n+    private static final String BUILDER_EXEC_NAME_PREFIX = \"builder-executor-\";\n+    private static final String ROUTE_EXEC_NAME_PREFIX = \"route-executor-\";\n+\n+    @ClassRule\n+    public static final ExecutorRule<Executor> BUILDER_EXEC = ExecutorRule.withNamePrefix(BUILDER_EXEC_NAME_PREFIX);\n+\n+    @ClassRule\n+    public static final ExecutorRule<Executor> ROUTE_EXEC = ExecutorRule.withNamePrefix(ROUTE_EXEC_NAME_PREFIX);\n+\n+    private static final TestRequest REQUEST = TestRequest.newBuilder().setName(\"name\").build();\n+\n+    private enum BuilderExecutionStrategy {\n+        DEFAULT {\n+            @Override\n+            void configureBuilderExecutionStrategy(GrpcServerBuilder builder) {\n+                // noop\n+            }\n+        },\n+        CUSTOM {\n+            @Override\n+            void configureBuilderExecutionStrategy(GrpcServerBuilder builder) {\n+                builder.executionStrategy(defaultStrategy(BUILDER_EXEC.executor()));\n+            }\n+        },\n+        NO_OFFLOADS {\n+            @Override\n+            void configureBuilderExecutionStrategy(GrpcServerBuilder builder) {\n+                builder.executionStrategy(noOffloadsStrategy());\n+            }\n+        };\n+\n+        abstract void configureBuilderExecutionStrategy(GrpcServerBuilder builder);\n+    }\n+\n+    private enum RouteExecutionStrategy {\n+        ASYNC_DEFAULT {\n+            @Override\n+            ServiceFactory getServiceFactory() {\n+                return new ServiceFactory(DEFAULT_STRATEGY_ASYNC_SERVICE);\n+            }\n+        },\n+        ASYNC_CLASS_EXEC_ID {\n+            @Override\n+            ServiceFactory getServiceFactory() {\n+                return new ServiceFactory(CLASS_EXEC_ID_STRATEGY_ASYNC_SERVICE,\n+                        __ -> defaultStrategy(ROUTE_EXEC.executor()));\n+            }\n+        },\n+        ASYNC_CLASS_NO_OFFLOADS {\n+            @Override\n+            ServiceFactory getServiceFactory() {\n+                return new ServiceFactory(CLASS_NO_OFFLOADS_STRATEGY_ASYNC_SERVICE);\n+            }\n+        },\n+        ASYNC_METHOD_NO_OFFLOADS {\n+            @Override\n+            ServiceFactory getServiceFactory() {\n+                return new ServiceFactory(METHOD_NO_OFFLOADS_STRATEGY_ASYNC_SERVICE);\n+            }\n+        },\n+        ASYNC_SERVICE_FACTORY_NO_OFFLOADS {\n+            @Override\n+            ServiceFactory getServiceFactory() {\n+                return new ServiceFactory.Builder()\n+                        .test(noOffloadsStrategy(), DEFAULT_STRATEGY_ASYNC_SERVICE)\n+                        .testBiDiStream(noOffloadsStrategy(), DEFAULT_STRATEGY_ASYNC_SERVICE)\n+                        .testResponseStream(noOffloadsStrategy(), DEFAULT_STRATEGY_ASYNC_SERVICE)\n+                        .testRequestStream(noOffloadsStrategy(), DEFAULT_STRATEGY_ASYNC_SERVICE)\n+                        .build();\n+            }\n+        },\n+        BLOCKING_DEFAULT {\n+            @Override\n+            ServiceFactory getServiceFactory() {\n+                return new ServiceFactory(DEFAULT_STRATEGY_BLOCKING_SERVICE);\n+            }\n+        },\n+        BLOCKING_CLASS_EXEC_ID {\n+            @Override\n+            ServiceFactory getServiceFactory() {\n+                return new ServiceFactory(CLASS_EXEC_ID_STRATEGY_BLOCKING_SERVICE,\n+                        __ -> defaultStrategy(ROUTE_EXEC.executor()));\n+            }\n+        },\n+        BLOCKING_CLASS_NO_OFFLOADS {\n+            @Override\n+            ServiceFactory getServiceFactory() {\n+                return new ServiceFactory(CLASS_NO_OFFLOADS_STRATEGY_BLOCKING_SERVICE);\n+            }\n+        },\n+        BLOCKING_METHOD_NO_OFFLOADS {\n+            @Override\n+            ServiceFactory getServiceFactory() {\n+                return new ServiceFactory(METHOD_NO_OFFLOADS_STRATEGY_BLOCKING_SERVICE);\n+            }\n+        },\n+        BLOCKING_SERVICE_FACTORY_NO_OFFLOADS {\n+            @Override\n+            ServiceFactory getServiceFactory() {\n+                return new ServiceFactory.Builder()\n+                        .testBlocking(noOffloadsStrategy(), DEFAULT_STRATEGY_BLOCKING_SERVICE)\n+                        .testBiDiStreamBlocking(noOffloadsStrategy(), DEFAULT_STRATEGY_BLOCKING_SERVICE)\n+                        .testResponseStreamBlocking(noOffloadsStrategy(), DEFAULT_STRATEGY_BLOCKING_SERVICE)\n+                        .testRequestStreamBlocking(noOffloadsStrategy(), DEFAULT_STRATEGY_BLOCKING_SERVICE)\n+                        .build();\n+            }\n+        };\n+\n+        abstract ServiceFactory getServiceFactory();\n+    }\n+\n+    private enum RouteApi {\n+        TEST {\n+            @Override\n+            TestResponse execute(BlockingTesterClient client) throws Exception {\n+                return client.test(REQUEST);\n+            }\n+        },\n+        TEST_BI_DI_STREAM {\n+            @Override\n+            TestResponse execute(BlockingTesterClient client) throws Exception {\n+                return extractResponse(() -> client.testBiDiStream(singletonList(REQUEST)));\n+            }\n+        },\n+        TEST_RESPONSE_STREAM {\n+            @Override\n+            TestResponse execute(BlockingTesterClient client) throws Exception {\n+                return extractResponse(() -> client.testResponseStream(REQUEST));\n+            }\n+        },\n+        TEST_REQUEST_STREAM {\n+            @Override\n+            TestResponse execute(BlockingTesterClient client) throws Exception {\n+                return client.testRequestStream(singletonList(REQUEST));\n+            }\n+        };\n+\n+        abstract TestResponse execute(BlockingTesterClient client) throws Exception;\n+\n+        private static TestResponse extractResponse(Callable<BlockingIterable<TestResponse>> clientCall)\n+                throws Exception {\n+            try (BlockingIterator<TestResponse> iter = clientCall.call().iterator()) {\n+                TestResponse response = iter.next();", "originalCommit": "5cb2127d357546d3c5f0c2cb13b79df48775be95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAwMTA2Nw==", "url": "https://github.com/apple/servicetalk/pull/912#discussion_r365001067", "bodyText": "It seems that we can remove these publishOn/subscribeOn usage from all methods in this class now. I tried it locally and the build is happy. Do you want to make this change here since you are doing related change in one method?\n--- a/servicetalk-http-api/src/main/java/io/servicetalk/http/api/NoOffloadsHttpExecutionStrategy.java\n+++ b/servicetalk-http-api/src/main/java/io/servicetalk/http/api/NoOffloadsHttpExecutionStrategy.java\n@@ -48,18 +48,14 @@ final class NoOffloadsHttpExecutionStrategy implements HttpExecutionStrategy {\n     public <FS> Single<StreamingHttpResponse> invokeClient(\n             final Executor fallback, final Publisher<Object> flattenedRequest, final FS flushStrategy,\n             final ClientInvoker<FS> client) {\n-        Publisher<Object> flatReq = flattenedRequest.subscribeOnOverride(immediate());\n-        return client.invokeClient(flatReq, flushStrategy)\n-                .map(response -> response.transformRawPayloadBody(p -> p.publishOnOverride(immediate())))\n-                .publishOnOverride(immediate());\n+        return client.invokeClient(flattenedRequest, flushStrategy);\n     }\n \n     @Override\n     public Publisher<Object> invokeService(final Executor fallback, final StreamingHttpRequest request,\n                                            final Function<StreamingHttpRequest, Publisher<Object>> service,\n                                            final BiFunction<Throwable, Executor, Publisher<Object>> errorHandler) {\n-        return service.apply(request.transformRawPayloadBody(payload -> payload.publishOnOverride(immediate())))\n-                .subscribeOnOverride(immediate());\n+        return service.apply(request);\n     }\n \n     @Override\n@@ -68,10 +64,7 @@ final class NoOffloadsHttpExecutionStrategy implements HttpExecutionStrategy {\n             // Always use fallback as the Executor as this strategy does not specify an Executor.\n             HttpServiceContext wrappedCtx =\n                     new ExecutionContextOverridingServiceContext(ctx, NoOffloadsHttpExecutionStrategy.this, fallback);\n-            request = request.transformRawPayloadBody(p -> p.publishOn(immediate()));\n-            return handler.handle(wrappedCtx, request, responseFactory)\n-                    .map(r -> r.transformRawPayloadBody(p -> p.subscribeOn(immediate())))\n-                    .subscribeOn(immediate());\n+            return handler.handle(wrappedCtx, request, responseFactory);\n         };\n     }\n \n@@ -102,22 +95,22 @@ final class NoOffloadsHttpExecutionStrategy implements HttpExecutionStrategy {\n \n     @Override\n     public <T> Single<T> offloadSend(final Executor fallback, final Single<T> original) {\n-        return original.subscribeOnOverride(immediate());\n+        return original;\n     }\n \n     @Override\n     public <T> Single<T> offloadReceive(final Executor fallback, final Single<T> original) {\n-        return original.publishOnOverride(immediate());\n+        return original;\n     }\n \n     @Override\n     public <T> Publisher<T> offloadSend(final Executor fallback, final Publisher<T> original) {\n-        return original.subscribeOnOverride(immediate());\n+        return original;\n     }\n \n     @Override\n     public <T> Publisher<T> offloadReceive(final Executor fallback, final Publisher<T> original) {\n-        return original.publishOnOverride(immediate());\n+        return original;\n     }\n \n     @Override", "author": "NiteshKant", "createdAt": "2020-01-09T22:57:41Z", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/NoOffloadsHttpExecutionStrategy.java", "diffHunk": "@@ -68,10 +68,10 @@ public StreamingHttpService offloadService(final Executor fallback, final Stream\n             // Always use fallback as the Executor as this strategy does not specify an Executor.\n             HttpServiceContext wrappedCtx =\n                     new ExecutionContextOverridingServiceContext(ctx, NoOffloadsHttpExecutionStrategy.this, fallback);\n-            request = request.transformRawPayloadBody(p -> p.publishOnOverride(immediate()));\n+            request = request.transformRawPayloadBody(p -> p.publishOn(immediate()));", "originalCommit": "5cb2127d357546d3c5f0c2cb13b79df48775be95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAwNzU0OA==", "url": "https://github.com/apple/servicetalk/pull/912#discussion_r365007548", "bodyText": "I am not yet convinced that the failure is due to the race you mention here, can we dig a bit deeper to see why are we consistently seeing exceptions without this change in the test here?", "author": "NiteshKant", "createdAt": "2020-01-09T23:20:01Z", "path": "servicetalk-grpc-netty/src/test/java/io/servicetalk/grpc/netty/ProtocolCompatibilityTest.java", "diffHunk": "@@ -716,45 +717,56 @@ private CompatResponse response(final int value) {\n                 }\n                 return computeResponse(value);\n             }\n-        }).appendServiceFilter(delegate -> new Compat.CompatServiceFilter(delegate) {\n-            @Override\n-            public Publisher<CompatResponse> bidirectionalStreamingCall(final GrpcServiceContext ctx,\n-                                                                        final Publisher<CompatRequest> req) {\n-                maybeThrowFromFilter();\n-                return delegate().bidirectionalStreamingCall(ctx, req);\n-            }\n+        };\n+        final ServiceFactory serviceFactory = strategy == defaultStrategy() ? new ServiceFactory(compatService) :\n+                new ServiceFactory.Builder().bidirectionalStreamingCall(strategy, compatService)\n+                        .clientStreamingCall(strategy, compatService)\n+                        .scalarCall(strategy, compatService)\n+                        .serverStreamingCall(strategy, compatService)\n+                        .build();\n+\n+        // FIXME(idel): remove condition around appendServiceFilter when WSS or filters execution strategy will be fixed", "originalCommit": "5cb2127d357546d3c5f0c2cb13b79df48775be95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUzMzY0Mg==", "url": "https://github.com/apple/servicetalk/pull/912#discussion_r367533642", "bodyText": "As we discussed offline, when the offloading is enabled, it's expected that the client may receive either grpc-exception first or see that server closed the connection. See grpcJavaToServiceTalkErrorInStreamingResponse as an example.\nTests with noOffloadsStrategy() always expect grpc-exception. Only tests with *NoOffload suffix are affected by this FIXME and it will be removed when we fix wrapping routes with filters because currently, filters override route's execution strategy.", "author": "idelpivnitskiy", "createdAt": "2020-01-16T16:52:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAwNzU0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAxMzMzNw==", "url": "https://github.com/apple/servicetalk/pull/912#discussion_r365013337", "bodyText": "I am assuming that code here is just refactored from existing jersey classes, so haven't reviewed this here. Is there anything specific you want me to look at?", "author": "NiteshKant", "createdAt": "2020-01-09T23:41:27Z", "path": "servicetalk-router-utils-internal/src/main/java/io/servicetalk/router/utils/internal/RouteExecutionStrategyUtils.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.router.utils.internal;\n+\n+import io.servicetalk.router.api.NoOffloadsRouteExecutionStrategy;\n+import io.servicetalk.router.api.RouteExecutionStrategy;\n+import io.servicetalk.router.api.RouteExecutionStrategyFactory;\n+import io.servicetalk.transport.api.ExecutionStrategy;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Method;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+\n+import static java.util.Arrays.stream;\n+\n+/**\n+ * Utilities to handle {@link RouteExecutionStrategy} annotation.\n+ */\n+public final class RouteExecutionStrategyUtils {", "originalCommit": "5cb2127d357546d3c5f0c2cb13b79df48775be95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e9252e47292cf269b739d278ef64830c1753b2da", "url": "https://github.com/apple/servicetalk/commit/e9252e47292cf269b739d278ef64830c1753b2da", "message": "Merge remote-tracking branch 'upstream/master' into grpc-annotations", "committedDate": "2020-01-16T01:18:27Z", "type": "commit"}, {"oid": "3db9fff4586fd0557f130a640c5c33773b88829a", "url": "https://github.com/apple/servicetalk/commit/3db9fff4586fd0557f130a640c5c33773b88829a", "message": "Address comments", "committedDate": "2020-01-16T16:38:06Z", "type": "commit"}, {"oid": "8494d0df5df22e064d80bdb0d95ddc8962da5422", "url": "https://github.com/apple/servicetalk/commit/8494d0df5df22e064d80bdb0d95ddc8962da5422", "message": "Make NoOffloadsHttpExecutionStrategy NOOP", "committedDate": "2020-01-16T16:38:07Z", "type": "commit"}, {"oid": "c5c26f9d1d223c6cd3042d90fc46d73e3f26579a", "url": "https://github.com/apple/servicetalk/commit/c5c26f9d1d223c6cd3042d90fc46d73e3f26579a", "message": "RouteExecutionStrategyFactory should return non-null values", "committedDate": "2020-01-16T20:46:40Z", "type": "commit"}, {"oid": "a69a8cd13f3b40eebb6d8941689dc5a6e2685664", "url": "https://github.com/apple/servicetalk/commit/a69a8cd13f3b40eebb6d8941689dc5a6e2685664", "message": "Use non-null RouteExecutionStrategyFactory in Jersey", "committedDate": "2020-01-16T20:46:54Z", "type": "commit"}, {"oid": "21cdc386803b4c7792264b7966ec103f27ca1983", "url": "https://github.com/apple/servicetalk/commit/21cdc386803b4c7792264b7966ec103f27ca1983", "message": "Add DefaultHttpExecutionStrategyTest.wrapServiceThatWasAlreadyOffloaded", "committedDate": "2020-01-16T21:30:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA0ODA3NQ==", "url": "https://github.com/apple/servicetalk/pull/912#discussion_r368048075", "bodyText": "This is only used in tests, can we move it to testFixtures. It seems providing a common factory implementation is more work than a simple lambda =>\n__ -> throw new IllegalArgumentException(\"Unknown execution strategy id: \" + id);", "author": "NiteshKant", "createdAt": "2020-01-17T17:20:49Z", "path": "servicetalk-router-utils-internal/src/main/java/io/servicetalk/router/utils/internal/DefaultRouteExecutionStrategyFactory.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.router.utils.internal;\n+\n+import io.servicetalk.router.api.RouteExecutionStrategy;\n+import io.servicetalk.router.api.RouteExecutionStrategyFactory;\n+import io.servicetalk.transport.api.ExecutionStrategy;\n+\n+/**\n+ * Implementation of {@link RouteExecutionStrategyFactory} that always throws {@link IllegalArgumentException}.\n+ * This should be used as a default strategy factory when users did not provide their own implementation.\n+ *\n+ * @param <ES> protocol-specific execution strategy implementation\n+ */\n+public final class DefaultRouteExecutionStrategyFactory<ES extends ExecutionStrategy>", "originalCommit": "21cdc386803b4c7792264b7966ec103f27ca1983", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA3MDIzOA==", "url": "https://github.com/apple/servicetalk/pull/912#discussion_r368070238", "bodyText": "No, it's not only for tests, we use it as a default factory in jersey router and grpc ServiceFactory.", "author": "idelpivnitskiy", "createdAt": "2020-01-17T18:16:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA0ODA3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwMjcwOA==", "url": "https://github.com/apple/servicetalk/pull/912#discussion_r368102708", "bodyText": "Hmm .. somehow did not see that. I still think the whole static raw-types and methods for rawtypes casting is more of a pain than convenience. I would suggest just use the lambda in the different routers.", "author": "NiteshKant", "createdAt": "2020-01-17T19:35:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA0ODA3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE2NDgxOQ==", "url": "https://github.com/apple/servicetalk/pull/912#discussion_r368164819", "bodyText": "I also use getUsingDefaultStrategyFactory method in jersey to handle it's conversion between the map to factory and handle @Nonnull properly: https://github.com/apple/servicetalk/pull/912/files/21cdc386803b4c7792264b7966ec103f27ca1983#diff-25d1a53373d0d3bfc4ab2d26e22c13fdR223\nThis class is in servicetalk-router-utils-internal module that helps to consolidate repeated lambda and utils.\nCan we keep it?", "author": "idelpivnitskiy", "createdAt": "2020-01-17T22:37:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA0ODA3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE2NTE5MA==", "url": "https://github.com/apple/servicetalk/pull/912#discussion_r368165190", "bodyText": "Yep did not notice that it is an internal class, did not notice before. Sounds good to keep.", "author": "NiteshKant", "createdAt": "2020-01-17T22:38:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA0ODA3NQ=="}], "type": "inlineReview"}]}