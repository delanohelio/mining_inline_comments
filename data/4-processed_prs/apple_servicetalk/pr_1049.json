{"pr_number": 1049, "pr_title": "Introduce HTTP Zipkin reporter", "pr_createdAt": "2020-05-13T06:40:27Z", "pr_url": "https://github.com/apple/servicetalk/pull/1049", "timeline": [{"oid": "e4efbb99f624584411b816e91826315230dc5506", "url": "https://github.com/apple/servicetalk/commit/e4efbb99f624584411b816e91826315230dc5506", "message": "Introduce HTTP Zipkin reporter\n\n__Motivation__\n\nWe do not currently provide a zipkin reporter implementation for HTTP collectors. Providing an HTTP reporter using ServiceTalk HTTP client will be useful when ServiceTalk HTTP client is used otherwise in applications.\n\n__Modification__\n\nAdd an `HttpReporter` with configurable batching strategy.\n\n__Result__\n\nUsers can use ServiceTalk HTTP client to publish spans to a Zipkin collector.", "committedDate": "2020-05-13T06:39:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMxNjU3NQ==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424316575", "bodyText": "private ?", "author": "normanmaurer", "createdAt": "2020-05-13T09:54:43Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/Codec.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+\n+/**\n+ * Zipkin data formats for reporting of {@link Span}s.\n+ */\n+public enum Codec {\n+    /**\n+     * Zipkin V1 JSON format.\n+     */\n+    JSON_V1(SpanBytesEncoder.JSON_V1),\n+    /**\n+     * Zipkin V2 JSON format.\n+     */\n+    JSON_V2(SpanBytesEncoder.JSON_V2),\n+    /**\n+     * Zipkin V2 THRIFT format.\n+     */\n+    THRIFT(SpanBytesEncoder.THRIFT),\n+    /**\n+     * Zipkin V2 protocol buffers V3 format.\n+     */\n+    PROTO3(SpanBytesEncoder.PROTO3);\n+\n+    private final SpanBytesEncoder encoder;\n+\n+    Codec(SpanBytesEncoder encoder) {", "originalCommit": "e4efbb99f624584411b816e91826315230dc5506", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU4NzE4OQ==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424587189", "bodyText": "As this is an enum constructors are by default private", "author": "NiteshKant", "createdAt": "2020-05-13T16:52:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMxNjU3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMxNzUzNw==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424317537", "bodyText": "nit: consider marking as final so we ensure it is really set at some point.", "author": "normanmaurer", "createdAt": "2020-05-13T09:56:18Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.SingleAddressHttpClientBuilder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Nonnull;\n+\n+import static io.servicetalk.concurrent.api.AsyncCloseables.newCompositeCloseable;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.BufferStrategies.forCountOrTime;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessorDropHeadOnOverflow;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.http.api.CharSequences.newAsciiString;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_TYPE;\n+import static io.servicetalk.http.api.HttpHeaderValues.APPLICATION_JSON;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to an HTTP endpoint with a configurable encoding {@link Codec}.\n+ */\n+public final class HttpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HttpReporter.class);\n+    static final String V1_PATH = \"/api/v1/spans\";\n+    static final String V2_PATH = \"/api/v2/spans\";\n+    static final CharSequence THRIFT_CONTENT_TYPE = newAsciiString(\"application/x-thrift\");\n+    static final CharSequence PROTO_CONTENT_TYPE = newAsciiString(\"application/protobuf\");\n+\n+    private final PublisherSource.Processor<Span, Span> buffer;\n+    private final AsyncCloseable closeable;\n+\n+    private volatile boolean closeInitiated;\n+\n+    private HttpReporter(final Builder builder) {\n+        final HttpClient client = builder.clientBuilder.build();\n+        SpanBytesEncoder spanEncoder = builder.codec.spanBytesEncoder();\n+        final String path;\n+        final CharSequence contentType;\n+        switch (builder.codec) {\n+            case JSON_V1:\n+                path = V1_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case JSON_V2:\n+                path = V2_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case THRIFT:\n+                path = V2_PATH;\n+                contentType = THRIFT_CONTENT_TYPE;\n+                break;\n+            case PROTO3:\n+                path = V2_PATH;\n+                contentType = PROTO_CONTENT_TYPE;\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown codec: \" + builder.codec);\n+        }\n+        final BufferAllocator allocator = client.executionContext().bufferAllocator();\n+        Publisher<Buffer> spans;", "originalCommit": "e4efbb99f624584411b816e91826315230dc5506", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMxOTEzOQ==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424319139", "bodyText": "consider storing the value into a static final field and use it in newSpan(...) and verifySpan(...). This way it is less error-prone once we refactor", "author": "normanmaurer", "createdAt": "2020-05-13T09:58:53Z", "path": "servicetalk-opentracing-zipkin-publisher/src/test/java/io/servicetalk/opentracing/zipkin/publisher/reporter/SpanUtils.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import zipkin2.Span;\n+\n+import java.util.Map;\n+\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+final class SpanUtils {\n+    private SpanUtils() {\n+        // no instances\n+    }\n+\n+    static Span newSpan() {\n+        return Span.newBuilder()\n+                .name(\"test operation\")\n+                .traceId(\"1234\")\n+                .id(2)\n+                .timestamp(123456789L)\n+                .duration(SECONDS.toMicros(1))\n+                .putTag(\"stringKey\", \"string\")\n+                .putTag(\"boolKey\", String.valueOf(true))\n+                .putTag(\"shortKey\", String.valueOf(Short.MAX_VALUE))\n+                .putTag(\"intKey\", String.valueOf(Integer.MAX_VALUE))\n+                .putTag(\"longKey\", String.valueOf(Long.MAX_VALUE))\n+                .putTag(\"floatKey\", String.valueOf(Float.MAX_VALUE))\n+                .putTag(\"doubleKey\", String.valueOf(Double.MAX_VALUE))\n+                .addAnnotation(System.currentTimeMillis() * 1000, \"some event happened\")\n+                .build();\n+    }\n+\n+    static void verifySpan(final Span span) {\n+        assertEquals(\"test operation\", span.name());\n+        assertEquals(\"0000000000001234\", span.traceId());\n+        assertEquals(\"0000000000000002\", span.id());\n+        assertEquals(123456789L, (long) span.timestamp());", "originalCommit": "e4efbb99f624584411b816e91826315230dc5506", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0f4583663656a92aae310ebfee570188cf506515", "url": "https://github.com/apple/servicetalk/commit/0f4583663656a92aae310ebfee570188cf506515", "message": "Review comments", "committedDate": "2020-05-13T16:51:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYxNzQ3Mg==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424617472", "bodyText": "Should it be ListenableAsyncCloseable and GracefulAutoCloseable? The same question for UdpReporter.", "author": "idelpivnitskiy", "createdAt": "2020-05-13T17:42:07Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.SingleAddressHttpClientBuilder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Nonnull;\n+\n+import static io.servicetalk.concurrent.api.AsyncCloseables.newCompositeCloseable;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.BufferStrategies.forCountOrTime;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessorDropHeadOnOverflow;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.http.api.CharSequences.newAsciiString;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_TYPE;\n+import static io.servicetalk.http.api.HttpHeaderValues.APPLICATION_JSON;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to an HTTP endpoint with a configurable encoding {@link Codec}.\n+ */\n+public final class HttpReporter extends Component implements Reporter<Span>, AsyncCloseable {", "originalCommit": "0f4583663656a92aae310ebfee570188cf506515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY0Mzc3Ng==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424643776", "bodyText": "The Component abstract class also defines check() method that always returns OK. I think we should override this method and return CheckResult.failed(Throwable) after this reporter is closed.", "author": "idelpivnitskiy", "createdAt": "2020-05-13T18:25:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYxNzQ3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4NjcyMw==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424686723", "bodyText": "Since a Reporter is designed to be passed to generator of spans (ZipkinPublisher) which then owns its lifecycle, we do not need to have this as ListenableAsyncCloseable. Same reason why we do not need the additional blocking close methods but they just come with Component.\nIn general, intermediate entities do not need to provide listen functionality for closure. Only entities which are directly owned by the user needs to provide this functionality.", "author": "NiteshKant", "createdAt": "2020-05-13T19:41:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYxNzQ3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4NzY1MQ==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424687651", "bodyText": "good call on the check() method. Since, we do not use this method and UdpReporter currently does not maintain the close state, I will defer this change for UdpReporter", "author": "NiteshKant", "createdAt": "2020-05-13T19:43:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYxNzQ3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc3MjM4NQ==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424772385", "bodyText": "Let's use channel.isActive() for UdpReporter#check() as we do for UdpReporter#report(Span)?", "author": "idelpivnitskiy", "createdAt": "2020-05-13T22:43:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYxNzQ3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgzMzQwOA==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424833408", "bodyText": "As I said I will prefer to do the UdpReporter in a separate PR; feel free to send a follow up.", "author": "NiteshKant", "createdAt": "2020-05-14T02:18:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYxNzQ3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTMzNDM3NQ==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r425334375", "bodyText": "#1054", "author": "idelpivnitskiy", "createdAt": "2020-05-14T18:06:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYxNzQ3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYxODk2Ng==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424618966", "bodyText": "This method may be static.", "author": "idelpivnitskiy", "createdAt": "2020-05-13T17:44:35Z", "path": "servicetalk-opentracing-zipkin-publisher/src/test/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporterTest.java", "diffHunk": "@@ -71,66 +70,38 @@ public void tearDown() {\n \n     @Test\n     public void testJsonV1RoundTrip() throws Exception {\n-        testRoundTrip(UdpReporter.Codec.JSON_V1, SpanBytesDecoder.JSON_V1);\n+        testRoundTrip(Codec.JSON_V1, SpanBytesDecoder.JSON_V1);\n     }\n \n     @Test\n     public void testJsonV2RoundTrip() throws Exception {\n-        testRoundTrip(UdpReporter.Codec.JSON_V2, SpanBytesDecoder.JSON_V2);\n+        testRoundTrip(Codec.JSON_V2, SpanBytesDecoder.JSON_V2);\n     }\n \n     @Test\n     public void testThriftRoundTrip() throws Exception {\n-        testRoundTrip(UdpReporter.Codec.THRIFT, SpanBytesDecoder.THRIFT);\n+        testRoundTrip(Codec.THRIFT, SpanBytesDecoder.THRIFT);\n     }\n \n     @Test\n     public void testProto3RoundTrip() throws Exception {\n-        testRoundTrip(UdpReporter.Codec.PROTO3, SpanBytesDecoder.PROTO3);\n+        testRoundTrip(Codec.PROTO3, SpanBytesDecoder.PROTO3);\n     }\n \n-    private void testRoundTrip(UdpReporter.Codec codec, SpanBytesDecoder decoder) throws Exception {\n+    private void testRoundTrip(Codec codec, SpanBytesDecoder decoder) throws Exception {\n         try (TestReceiver receiver = new TestReceiver(decoder)) {\n             try (UdpReporter reporter = buildReporter((InetSocketAddress) receiver.channel.localAddress(), codec)) {\n-                Span span = Span.newBuilder()\n-                        .name(\"test operation\")\n-                        .traceId(\"1234\")\n-                        .id(2)\n-                        .timestamp(123456789L)\n-                        .duration(SECONDS.toMicros(1))\n-                        .putTag(\"stringKey\", \"string\")\n-                        .putTag(\"boolKey\", String.valueOf(true))\n-                        .putTag(\"shortKey\", String.valueOf(Short.MAX_VALUE))\n-                        .putTag(\"intKey\", String.valueOf(Integer.MAX_VALUE))\n-                        .putTag(\"longKey\", String.valueOf(Long.MAX_VALUE))\n-                        .putTag(\"floatKey\", String.valueOf(Float.MAX_VALUE))\n-                        .putTag(\"doubleKey\", String.valueOf(Double.MAX_VALUE))\n-                        .addAnnotation(System.currentTimeMillis() * 1000, \"some event happened\")\n-                        .build();\n-                reporter.report(span);\n+                reporter.report(newSpan());\n             }\n \n             Span span = receiver.queue.take();\n \n             assertNotNull(span);\n-            assertEquals(\"test operation\", span.name());\n-            assertEquals(\"0000000000001234\", span.traceId());\n-            assertEquals(\"0000000000000002\", span.id());\n-            assertEquals(123456789L, (long) span.timestamp());\n-            assertEquals(1000 * 1000, (long) span.duration());\n-            Map<String, String> tags = span.tags();\n-            assertEquals(\"string\", tags.get(\"stringKey\"));\n-            assertEquals(Boolean.TRUE.toString(), tags.get(\"boolKey\"));\n-            assertEquals(String.valueOf(Short.MAX_VALUE), tags.get(\"shortKey\"));\n-            assertEquals(String.valueOf(Integer.MAX_VALUE), tags.get(\"intKey\"));\n-            assertEquals(String.valueOf(Long.MAX_VALUE), tags.get(\"longKey\"));\n-            assertEquals(String.valueOf(Float.MAX_VALUE), tags.get(\"floatKey\"));\n-            assertEquals(String.valueOf(Double.MAX_VALUE), tags.get(\"doubleKey\"));\n-            assertTrue(span.annotations().stream().anyMatch(a -> a.value().equals(\"some event happened\")));\n+            verifySpan(span);\n         }\n     }\n \n-    private UdpReporter buildReporter(InetSocketAddress remoteAddress, UdpReporter.Codec codec) {\n+    private UdpReporter buildReporter(InetSocketAddress remoteAddress, Codec codec) {", "originalCommit": "0f4583663656a92aae310ebfee570188cf506515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYyMDkyOA==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424620928", "bodyText": "Not related to this PR, but while you are here, can you please fix the close() method in line 137? The method is synchronous, but it doesn't wait until close future completes.", "author": "idelpivnitskiy", "createdAt": "2020-05-13T17:47:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYxODk2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYyMTY5Nw==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424621697", "bodyText": "\ud83d\udc4d\nwhile you are here, can you please change the logger name in the same way in UdpReporter?", "author": "idelpivnitskiy", "createdAt": "2020-05-13T17:49:09Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -45,8 +45,7 @@\n  * A publisher of {@link io.opentracing.Span}s to the zipkin transport.\n  */\n public final class ZipkinPublisher implements InMemorySpanEventListener, AsyncCloseable, Closeable {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(ZipkinPublisher.class);\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ZipkinPublisher.class);", "originalCommit": "0f4583663656a92aae310ebfee570188cf506515", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYyOTk5Mg==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424629992", "bodyText": "This test misses another verifyRequest after the second reporter.report(newSpan()). To prevent that, consider enhancing newSpan and verifySpan utils to compare a provided name or id. e.g.:\nSpan s = newSnap(\"somename\");\nverifySpan(s, \"somename\");", "author": "idelpivnitskiy", "createdAt": "2020-05-13T18:02:45Z", "path": "servicetalk-opentracing-zipkin-publisher/src/test/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporterTest.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.concurrent.api.AsyncCloseables;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.http.api.HttpRequest;\n+import io.servicetalk.opentracing.zipkin.publisher.reporter.HttpReporter.Builder;\n+import io.servicetalk.transport.api.ServerContext;\n+\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesDecoder;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.function.UnaryOperator;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.http.netty.HttpClients.forSingleAddress;\n+import static io.servicetalk.http.netty.HttpServers.forAddress;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.HttpReporter.V1_PATH;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.HttpReporter.V2_PATH;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.SpanUtils.newSpan;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.SpanUtils.verifySpan;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.localAddress;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.serverHostAndPort;\n+import static java.time.Duration.ofMillis;\n+import static java.util.Arrays.asList;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.junit.Assert.assertThrows;\n+\n+@RunWith(Parameterized.class)\n+public class HttpReporterTest {\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+\n+    private final BlockingQueue<HttpRequest> receivedRequests;\n+    private final ServerContext context;\n+    private final Codec codec;\n+    @Nullable\n+    private HttpReporter reporter;\n+\n+    public HttpReporterTest(final Codec codec) throws Exception {\n+        this.codec = codec;\n+        receivedRequests = new LinkedBlockingQueue<>();\n+        this.context = forAddress(localAddress(0))\n+                .listenBlockingAndAwait((ctx, request, responseFactory) -> {\n+                    receivedRequests.add(request);\n+                    return responseFactory.ok();\n+                });\n+    }\n+\n+    @Parameterized.Parameters(name = \"codec: {0}\")\n+    public static Collection<Codec> data() {\n+        return asList(Codec.values());\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        CompositeCloseable closeable = AsyncCloseables.newCompositeCloseable();\n+        if (reporter != null) {\n+            closeable.append(reporter);\n+        }\n+        closeable.append(context);\n+        closeable.closeGracefully();\n+    }\n+\n+    @Test\n+    public void disableBatching() throws Exception {\n+        HttpReporter reporter = initReporter(Builder::disableSpanBatching);\n+        reporter.report(newSpan());\n+        List<Span> spans = verifyRequest(receivedRequests.take(), false);\n+        assertThat(\"Unexpected spans received.\", spans, hasSize(1));\n+        verifySpan(spans.get(0));\n+        reporter.report(newSpan());\n+        assertThat(\"Unexpected spans received.\", spans, hasSize(1));\n+        verifySpan(spans.get(0));", "originalCommit": "0f4583663656a92aae310ebfee570188cf506515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDczMjEzMQ==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424732131", "bodyText": "good catch", "author": "NiteshKant", "createdAt": "2020-05-13T21:08:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYyOTk5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY0MDU1OQ==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424640559", "bodyText": "Consider changing closeable type to CompositeCloseable. Then you can use closeable.close() which does the same.", "author": "idelpivnitskiy", "createdAt": "2020-05-13T18:20:19Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.SingleAddressHttpClientBuilder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Nonnull;\n+\n+import static io.servicetalk.concurrent.api.AsyncCloseables.newCompositeCloseable;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.BufferStrategies.forCountOrTime;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessorDropHeadOnOverflow;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.http.api.CharSequences.newAsciiString;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_TYPE;\n+import static io.servicetalk.http.api.HttpHeaderValues.APPLICATION_JSON;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to an HTTP endpoint with a configurable encoding {@link Codec}.\n+ */\n+public final class HttpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HttpReporter.class);\n+    static final String V1_PATH = \"/api/v1/spans\";\n+    static final String V2_PATH = \"/api/v2/spans\";\n+    static final CharSequence THRIFT_CONTENT_TYPE = newAsciiString(\"application/x-thrift\");\n+    static final CharSequence PROTO_CONTENT_TYPE = newAsciiString(\"application/protobuf\");\n+\n+    private final PublisherSource.Processor<Span, Span> buffer;\n+    private final AsyncCloseable closeable;\n+\n+    private volatile boolean closeInitiated;\n+\n+    private HttpReporter(final Builder builder) {\n+        final HttpClient client = builder.clientBuilder.build();\n+        SpanBytesEncoder spanEncoder = builder.codec.spanBytesEncoder();\n+        final String path;\n+        final CharSequence contentType;\n+        switch (builder.codec) {\n+            case JSON_V1:\n+                path = V1_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case JSON_V2:\n+                path = V2_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case THRIFT:\n+                path = V2_PATH;\n+                contentType = THRIFT_CONTENT_TYPE;\n+                break;\n+            case PROTO3:\n+                path = V2_PATH;\n+                contentType = PROTO_CONTENT_TYPE;\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown codec: \" + builder.codec);\n+        }\n+        final BufferAllocator allocator = client.executionContext().bufferAllocator();\n+        final Publisher<Buffer> spans;\n+        if (builder.disableBatching) {\n+            buffer = newPublisherProcessorDropHeadOnOverflow(builder.maxConcurrentReports);\n+            spans = fromSource(buffer).map(span -> allocator.wrap(spanEncoder.encode(span)));\n+        } else {\n+            buffer = newPublisherProcessorDropHeadOnOverflow(builder.batchSizeHint * builder.maxConcurrentReports);\n+            spans = fromSource(buffer)\n+                    .buffer(forCountOrTime(builder.batchSizeHint, builder.maxBatchDuration,\n+                            () -> new ListAccumulator(builder.batchSizeHint), client.executionContext().executor()))\n+                    .filter(accumulate -> !accumulate.isEmpty())\n+                    .map(bufferedSpans -> allocator.wrap(spanEncoder.encodeList(bufferedSpans)));\n+        }\n+\n+        final CompletableSource.Processor spansTerminated = newCompletableProcessor();\n+        toSource(spans.flatMapCompletable(encodedSpans -> reportSpans(client, encodedSpans, path, contentType),\n+                builder.maxConcurrentReports)).subscribe(spansTerminated);\n+\n+        CompositeCloseable closeable = newCompositeCloseable();\n+        closeable.append(toAsyncCloseable(graceful -> {\n+            closeInitiated = true;\n+            try {\n+                buffer.onComplete();\n+            } catch (Throwable t) {\n+                LOGGER.error(\"Failed to dispose request buffer. Ignoring.\", t);\n+            }\n+            return graceful ? fromSource(spansTerminated) : completed();\n+        }));\n+        closeable.append(client);\n+        this.closeable = closeable;\n+    }\n+\n+    private Completable reportSpans(final HttpClient client, final Buffer encodedSpans, final String path,\n+                                    final CharSequence contentType) {\n+        return client.request(client.post(path).addHeader(CONTENT_TYPE, contentType).payloadBody(encodedSpans))\n+                .ignoreElement()\n+                .onErrorResume(cause -> {\n+                    LOGGER.error(\"Failed to send a span, ignoring.\", cause);\n+                    return completed();\n+                });\n+    }\n+\n+    /**\n+     * A builder to create a new {@link HttpReporter}.\n+     */\n+    public static final class Builder {\n+        private Codec codec = Codec.JSON_V2;\n+        private final SingleAddressHttpClientBuilder<?, ?> clientBuilder;\n+        private boolean disableBatching;\n+        private int batchSizeHint = 16;\n+        private int maxConcurrentReports = 32;\n+        private Duration maxBatchDuration = ofSeconds(30);\n+\n+        /**\n+         * Create a new {@link Builder} using the passed {@link SingleAddressHttpClientBuilder}.\n+         *\n+         * @param clientBuilder the collector SocketAddress\n+         */\n+        public Builder(final SingleAddressHttpClientBuilder<?, ?> clientBuilder) {\n+            this.clientBuilder = clientBuilder;\n+        }\n+\n+        /**\n+         * Sets the {@link Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        public Builder maxConcurrentReports(final int maxConcurrentReports) {\n+            this.maxConcurrentReports = maxConcurrentReports;\n+            return this;\n+        }\n+\n+        /**\n+         * Configure batching of spans before sending it to the zipkin collector.\n+         *\n+         * @param batchSizeHint Hint of how many spans should be batched together.\n+         * @param maxBatchDuration {@link Duration} of time to wait for {@code batchSizeHint} spans in a batch.\n+         * @return {@code this}.\n+         */\n+        public Builder batchSpans(final int batchSizeHint, final Duration maxBatchDuration) {\n+            if (batchSizeHint <= 0) {\n+                throw new IllegalArgumentException(\"batchSizeHint: \" + batchSizeHint + \" (expected > 0)\");\n+            }\n+            disableBatching = false;\n+            this.batchSizeHint = batchSizeHint;\n+            this.maxBatchDuration = requireNonNull(maxBatchDuration);\n+            return this;\n+        }\n+\n+        /**\n+         * Disable batching of spans before sending them to the zipkin collector.\n+         *\n+         * @return {@code this}.\n+         */\n+        public Builder disableSpanBatching() {\n+            disableBatching = true;\n+            return this;\n+        }\n+\n+        /**\n+         * Builds a new {@link HttpReporter} instance with this builder's options.\n+         *\n+         * @return a new {@link HttpReporter}\n+         */\n+        public HttpReporter build() {\n+            return new HttpReporter(this);\n+        }\n+    }\n+\n+    @Override\n+    public void report(final Span span) {\n+        if (closeInitiated) {\n+            throw new IllegalStateException(\"Span: \" + span + \" reported after reporter \" + this + \" is closed.\");\n+        }\n+        buffer.onNext(span);\n+    }\n+\n+    @Override\n+    public void close() {\n+        awaitTermination(closeable.closeAsync().toFuture());", "originalCommit": "0f4583663656a92aae310ebfee570188cf506515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcxMjAyNA==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424712024", "bodyText": "Actually, CompositeCloseable.close() throws Exception and this method can only throw IoException so it is more work to use that method.", "author": "NiteshKant", "createdAt": "2020-05-13T20:29:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY0MDU1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY0NDkwNQ==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424644905", "bodyText": "Consider providing path and content-type as pkg-private methods on Codec enum.", "author": "idelpivnitskiy", "createdAt": "2020-05-13T18:27:29Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.SingleAddressHttpClientBuilder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Nonnull;\n+\n+import static io.servicetalk.concurrent.api.AsyncCloseables.newCompositeCloseable;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.BufferStrategies.forCountOrTime;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessorDropHeadOnOverflow;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.http.api.CharSequences.newAsciiString;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_TYPE;\n+import static io.servicetalk.http.api.HttpHeaderValues.APPLICATION_JSON;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to an HTTP endpoint with a configurable encoding {@link Codec}.\n+ */\n+public final class HttpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HttpReporter.class);\n+    static final String V1_PATH = \"/api/v1/spans\";\n+    static final String V2_PATH = \"/api/v2/spans\";\n+    static final CharSequence THRIFT_CONTENT_TYPE = newAsciiString(\"application/x-thrift\");\n+    static final CharSequence PROTO_CONTENT_TYPE = newAsciiString(\"application/protobuf\");\n+\n+    private final PublisherSource.Processor<Span, Span> buffer;\n+    private final AsyncCloseable closeable;\n+\n+    private volatile boolean closeInitiated;\n+\n+    private HttpReporter(final Builder builder) {\n+        final HttpClient client = builder.clientBuilder.build();\n+        SpanBytesEncoder spanEncoder = builder.codec.spanBytesEncoder();\n+        final String path;\n+        final CharSequence contentType;\n+        switch (builder.codec) {\n+            case JSON_V1:\n+                path = V1_PATH;\n+                contentType = APPLICATION_JSON;", "originalCommit": "0f4583663656a92aae310ebfee570188cf506515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcwNjY5NQ==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424706695", "bodyText": "The Codec is for serialization whereas these details are specifically for HTTP reporting (does not apply for UDP). So, even though it is convenient, I will avoid adding these two the enum", "author": "NiteshKant", "createdAt": "2020-05-13T20:18:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY0NDkwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY0NjAzMw==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424646033", "bodyText": "Consider saving reference for builder.codec in a final local variable to prevent concurrent state modifications between spanEncoder and switch.", "author": "idelpivnitskiy", "createdAt": "2020-05-13T18:29:11Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.SingleAddressHttpClientBuilder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Nonnull;\n+\n+import static io.servicetalk.concurrent.api.AsyncCloseables.newCompositeCloseable;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.BufferStrategies.forCountOrTime;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessorDropHeadOnOverflow;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.http.api.CharSequences.newAsciiString;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_TYPE;\n+import static io.servicetalk.http.api.HttpHeaderValues.APPLICATION_JSON;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to an HTTP endpoint with a configurable encoding {@link Codec}.\n+ */\n+public final class HttpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HttpReporter.class);\n+    static final String V1_PATH = \"/api/v1/spans\";\n+    static final String V2_PATH = \"/api/v2/spans\";\n+    static final CharSequence THRIFT_CONTENT_TYPE = newAsciiString(\"application/x-thrift\");\n+    static final CharSequence PROTO_CONTENT_TYPE = newAsciiString(\"application/protobuf\");\n+\n+    private final PublisherSource.Processor<Span, Span> buffer;\n+    private final AsyncCloseable closeable;\n+\n+    private volatile boolean closeInitiated;\n+\n+    private HttpReporter(final Builder builder) {\n+        final HttpClient client = builder.clientBuilder.build();\n+        SpanBytesEncoder spanEncoder = builder.codec.spanBytesEncoder();", "originalCommit": "0f4583663656a92aae310ebfee570188cf506515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcwNjIzMw==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424706233", "bodyText": "you mean to handle the case if builder is used concurrently? I will refrain from such defensive programming as we do not expect builders to be used concurrently.", "author": "NiteshKant", "createdAt": "2020-05-13T20:17:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY0NjAzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY0ODcwMA==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424648700", "bodyText": "Consider creating CompositeCloseable upfront and appending the client asap. Then try-catch the whole ctor and close the closeable in case of any errors.", "author": "idelpivnitskiy", "createdAt": "2020-05-13T18:33:41Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.SingleAddressHttpClientBuilder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Nonnull;\n+\n+import static io.servicetalk.concurrent.api.AsyncCloseables.newCompositeCloseable;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.BufferStrategies.forCountOrTime;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessorDropHeadOnOverflow;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.http.api.CharSequences.newAsciiString;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_TYPE;\n+import static io.servicetalk.http.api.HttpHeaderValues.APPLICATION_JSON;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to an HTTP endpoint with a configurable encoding {@link Codec}.\n+ */\n+public final class HttpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HttpReporter.class);\n+    static final String V1_PATH = \"/api/v1/spans\";\n+    static final String V2_PATH = \"/api/v2/spans\";\n+    static final CharSequence THRIFT_CONTENT_TYPE = newAsciiString(\"application/x-thrift\");\n+    static final CharSequence PROTO_CONTENT_TYPE = newAsciiString(\"application/protobuf\");\n+\n+    private final PublisherSource.Processor<Span, Span> buffer;\n+    private final AsyncCloseable closeable;\n+\n+    private volatile boolean closeInitiated;\n+\n+    private HttpReporter(final Builder builder) {\n+        final HttpClient client = builder.clientBuilder.build();", "originalCommit": "0f4583663656a92aae310ebfee570188cf506515", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1MDA2Mw==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424650063", "bodyText": "No javadoc on this method.", "author": "idelpivnitskiy", "createdAt": "2020-05-13T18:36:09Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.SingleAddressHttpClientBuilder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Nonnull;\n+\n+import static io.servicetalk.concurrent.api.AsyncCloseables.newCompositeCloseable;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.BufferStrategies.forCountOrTime;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessorDropHeadOnOverflow;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.http.api.CharSequences.newAsciiString;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_TYPE;\n+import static io.servicetalk.http.api.HttpHeaderValues.APPLICATION_JSON;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to an HTTP endpoint with a configurable encoding {@link Codec}.\n+ */\n+public final class HttpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HttpReporter.class);\n+    static final String V1_PATH = \"/api/v1/spans\";\n+    static final String V2_PATH = \"/api/v2/spans\";\n+    static final CharSequence THRIFT_CONTENT_TYPE = newAsciiString(\"application/x-thrift\");\n+    static final CharSequence PROTO_CONTENT_TYPE = newAsciiString(\"application/protobuf\");\n+\n+    private final PublisherSource.Processor<Span, Span> buffer;\n+    private final AsyncCloseable closeable;\n+\n+    private volatile boolean closeInitiated;\n+\n+    private HttpReporter(final Builder builder) {\n+        final HttpClient client = builder.clientBuilder.build();\n+        SpanBytesEncoder spanEncoder = builder.codec.spanBytesEncoder();\n+        final String path;\n+        final CharSequence contentType;\n+        switch (builder.codec) {\n+            case JSON_V1:\n+                path = V1_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case JSON_V2:\n+                path = V2_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case THRIFT:\n+                path = V2_PATH;\n+                contentType = THRIFT_CONTENT_TYPE;\n+                break;\n+            case PROTO3:\n+                path = V2_PATH;\n+                contentType = PROTO_CONTENT_TYPE;\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown codec: \" + builder.codec);\n+        }\n+        final BufferAllocator allocator = client.executionContext().bufferAllocator();\n+        final Publisher<Buffer> spans;\n+        if (builder.disableBatching) {\n+            buffer = newPublisherProcessorDropHeadOnOverflow(builder.maxConcurrentReports);\n+            spans = fromSource(buffer).map(span -> allocator.wrap(spanEncoder.encode(span)));\n+        } else {\n+            buffer = newPublisherProcessorDropHeadOnOverflow(builder.batchSizeHint * builder.maxConcurrentReports);\n+            spans = fromSource(buffer)\n+                    .buffer(forCountOrTime(builder.batchSizeHint, builder.maxBatchDuration,\n+                            () -> new ListAccumulator(builder.batchSizeHint), client.executionContext().executor()))\n+                    .filter(accumulate -> !accumulate.isEmpty())\n+                    .map(bufferedSpans -> allocator.wrap(spanEncoder.encodeList(bufferedSpans)));\n+        }\n+\n+        final CompletableSource.Processor spansTerminated = newCompletableProcessor();\n+        toSource(spans.flatMapCompletable(encodedSpans -> reportSpans(client, encodedSpans, path, contentType),\n+                builder.maxConcurrentReports)).subscribe(spansTerminated);\n+\n+        CompositeCloseable closeable = newCompositeCloseable();\n+        closeable.append(toAsyncCloseable(graceful -> {\n+            closeInitiated = true;\n+            try {\n+                buffer.onComplete();\n+            } catch (Throwable t) {\n+                LOGGER.error(\"Failed to dispose request buffer. Ignoring.\", t);\n+            }\n+            return graceful ? fromSource(spansTerminated) : completed();\n+        }));\n+        closeable.append(client);\n+        this.closeable = closeable;\n+    }\n+\n+    private Completable reportSpans(final HttpClient client, final Buffer encodedSpans, final String path,\n+                                    final CharSequence contentType) {\n+        return client.request(client.post(path).addHeader(CONTENT_TYPE, contentType).payloadBody(encodedSpans))\n+                .ignoreElement()\n+                .onErrorResume(cause -> {\n+                    LOGGER.error(\"Failed to send a span, ignoring.\", cause);\n+                    return completed();\n+                });\n+    }\n+\n+    /**\n+     * A builder to create a new {@link HttpReporter}.\n+     */\n+    public static final class Builder {\n+        private Codec codec = Codec.JSON_V2;\n+        private final SingleAddressHttpClientBuilder<?, ?> clientBuilder;\n+        private boolean disableBatching;\n+        private int batchSizeHint = 16;\n+        private int maxConcurrentReports = 32;\n+        private Duration maxBatchDuration = ofSeconds(30);\n+\n+        /**\n+         * Create a new {@link Builder} using the passed {@link SingleAddressHttpClientBuilder}.\n+         *\n+         * @param clientBuilder the collector SocketAddress\n+         */\n+        public Builder(final SingleAddressHttpClientBuilder<?, ?> clientBuilder) {\n+            this.clientBuilder = clientBuilder;\n+        }\n+\n+        /**\n+         * Sets the {@link Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        public Builder maxConcurrentReports(final int maxConcurrentReports) {", "originalCommit": "0f4583663656a92aae310ebfee570188cf506515", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1NjI4Mw==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424656283", "bodyText": "When batching is disabled, does it matter what is the maximum number of items to buffer for the PublisherProcessor? We always subscribe and deliver items asap. Looks like in this case we can avoid having a queue or minimize its size.", "author": "idelpivnitskiy", "createdAt": "2020-05-13T18:46:41Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.SingleAddressHttpClientBuilder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Nonnull;\n+\n+import static io.servicetalk.concurrent.api.AsyncCloseables.newCompositeCloseable;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.BufferStrategies.forCountOrTime;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessorDropHeadOnOverflow;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.http.api.CharSequences.newAsciiString;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_TYPE;\n+import static io.servicetalk.http.api.HttpHeaderValues.APPLICATION_JSON;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to an HTTP endpoint with a configurable encoding {@link Codec}.\n+ */\n+public final class HttpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HttpReporter.class);\n+    static final String V1_PATH = \"/api/v1/spans\";\n+    static final String V2_PATH = \"/api/v2/spans\";\n+    static final CharSequence THRIFT_CONTENT_TYPE = newAsciiString(\"application/x-thrift\");\n+    static final CharSequence PROTO_CONTENT_TYPE = newAsciiString(\"application/protobuf\");\n+\n+    private final PublisherSource.Processor<Span, Span> buffer;\n+    private final AsyncCloseable closeable;\n+\n+    private volatile boolean closeInitiated;\n+\n+    private HttpReporter(final Builder builder) {\n+        final HttpClient client = builder.clientBuilder.build();\n+        SpanBytesEncoder spanEncoder = builder.codec.spanBytesEncoder();\n+        final String path;\n+        final CharSequence contentType;\n+        switch (builder.codec) {\n+            case JSON_V1:\n+                path = V1_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case JSON_V2:\n+                path = V2_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case THRIFT:\n+                path = V2_PATH;\n+                contentType = THRIFT_CONTENT_TYPE;\n+                break;\n+            case PROTO3:\n+                path = V2_PATH;\n+                contentType = PROTO_CONTENT_TYPE;\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown codec: \" + builder.codec);\n+        }\n+        final BufferAllocator allocator = client.executionContext().bufferAllocator();\n+        final Publisher<Buffer> spans;\n+        if (builder.disableBatching) {\n+            buffer = newPublisherProcessorDropHeadOnOverflow(builder.maxConcurrentReports);", "originalCommit": "0f4583663656a92aae310ebfee570188cf506515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcwOTA3Mw==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424709073", "bodyText": "We always subscribe and deliver items asap.\n\nNot really, items requested from the Processor depends on the concurrency on flatMap below. Buffer in the Processor is to bound the otherwise unbounded production of Spans. Concretely if maxConcurrentReports is 1 then we will take 1 Span send it to the collector over HTTP and when that response completes we will pick the next Span. This approach bounds memory by rejecting older spans when the collector endpoint is slow.", "author": "NiteshKant", "createdAt": "2020-05-13T20:23:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1NjI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1NDg3MA==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424754870", "bodyText": "to put it another way ... a limit is needed for back pressure and bounding memory. buffer is providing an in memory queue and there maybe an impedance mismatch between producing spans inside the application, and the client's ability to consume/send those spans.", "author": "Scottmitch", "createdAt": "2020-05-13T21:58:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1NjI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc3MTY1Nw==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424771657", "bodyText": "I see, thanks for explaining.", "author": "idelpivnitskiy", "createdAt": "2020-05-13T22:41:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1NjI4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1Njc0MQ==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424656741", "bodyText": "Can you please left a comment why we need to multiply batchSizeHint and maxConcurrentReports?", "author": "idelpivnitskiy", "createdAt": "2020-05-13T18:47:31Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.SingleAddressHttpClientBuilder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Nonnull;\n+\n+import static io.servicetalk.concurrent.api.AsyncCloseables.newCompositeCloseable;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.BufferStrategies.forCountOrTime;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessorDropHeadOnOverflow;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.http.api.CharSequences.newAsciiString;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_TYPE;\n+import static io.servicetalk.http.api.HttpHeaderValues.APPLICATION_JSON;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to an HTTP endpoint with a configurable encoding {@link Codec}.\n+ */\n+public final class HttpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HttpReporter.class);\n+    static final String V1_PATH = \"/api/v1/spans\";\n+    static final String V2_PATH = \"/api/v2/spans\";\n+    static final CharSequence THRIFT_CONTENT_TYPE = newAsciiString(\"application/x-thrift\");\n+    static final CharSequence PROTO_CONTENT_TYPE = newAsciiString(\"application/protobuf\");\n+\n+    private final PublisherSource.Processor<Span, Span> buffer;\n+    private final AsyncCloseable closeable;\n+\n+    private volatile boolean closeInitiated;\n+\n+    private HttpReporter(final Builder builder) {\n+        final HttpClient client = builder.clientBuilder.build();\n+        SpanBytesEncoder spanEncoder = builder.codec.spanBytesEncoder();\n+        final String path;\n+        final CharSequence contentType;\n+        switch (builder.codec) {\n+            case JSON_V1:\n+                path = V1_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case JSON_V2:\n+                path = V2_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case THRIFT:\n+                path = V2_PATH;\n+                contentType = THRIFT_CONTENT_TYPE;\n+                break;\n+            case PROTO3:\n+                path = V2_PATH;\n+                contentType = PROTO_CONTENT_TYPE;\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown codec: \" + builder.codec);\n+        }\n+        final BufferAllocator allocator = client.executionContext().bufferAllocator();\n+        final Publisher<Buffer> spans;\n+        if (builder.disableBatching) {\n+            buffer = newPublisherProcessorDropHeadOnOverflow(builder.maxConcurrentReports);\n+            spans = fromSource(buffer).map(span -> allocator.wrap(spanEncoder.encode(span)));\n+        } else {\n+            buffer = newPublisherProcessorDropHeadOnOverflow(builder.batchSizeHint * builder.maxConcurrentReports);", "originalCommit": "0f4583663656a92aae310ebfee570188cf506515", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2MTI2NA==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424661264", "bodyText": "This test verifies the same span twice.", "author": "idelpivnitskiy", "createdAt": "2020-05-13T18:55:00Z", "path": "servicetalk-opentracing-zipkin-publisher/src/test/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporterTest.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.concurrent.api.AsyncCloseables;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.http.api.HttpRequest;\n+import io.servicetalk.opentracing.zipkin.publisher.reporter.HttpReporter.Builder;\n+import io.servicetalk.transport.api.ServerContext;\n+\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesDecoder;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.function.UnaryOperator;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.http.netty.HttpClients.forSingleAddress;\n+import static io.servicetalk.http.netty.HttpServers.forAddress;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.HttpReporter.V1_PATH;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.HttpReporter.V2_PATH;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.SpanUtils.newSpan;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.SpanUtils.verifySpan;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.localAddress;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.serverHostAndPort;\n+import static java.time.Duration.ofMillis;\n+import static java.util.Arrays.asList;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.junit.Assert.assertThrows;\n+\n+@RunWith(Parameterized.class)\n+public class HttpReporterTest {\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+\n+    private final BlockingQueue<HttpRequest> receivedRequests;\n+    private final ServerContext context;\n+    private final Codec codec;\n+    @Nullable\n+    private HttpReporter reporter;\n+\n+    public HttpReporterTest(final Codec codec) throws Exception {\n+        this.codec = codec;\n+        receivedRequests = new LinkedBlockingQueue<>();\n+        this.context = forAddress(localAddress(0))\n+                .listenBlockingAndAwait((ctx, request, responseFactory) -> {\n+                    receivedRequests.add(request);\n+                    return responseFactory.ok();\n+                });\n+    }\n+\n+    @Parameterized.Parameters(name = \"codec: {0}\")\n+    public static Collection<Codec> data() {\n+        return asList(Codec.values());\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        CompositeCloseable closeable = AsyncCloseables.newCompositeCloseable();\n+        if (reporter != null) {\n+            closeable.append(reporter);\n+        }\n+        closeable.append(context);\n+        closeable.closeGracefully();\n+    }\n+\n+    @Test\n+    public void disableBatching() throws Exception {\n+        HttpReporter reporter = initReporter(Builder::disableSpanBatching);\n+        reporter.report(newSpan());\n+        List<Span> spans = verifyRequest(receivedRequests.take(), false);\n+        assertThat(\"Unexpected spans received.\", spans, hasSize(1));\n+        verifySpan(spans.get(0));\n+        reporter.report(newSpan());\n+        assertThat(\"Unexpected spans received.\", spans, hasSize(1));\n+        verifySpan(spans.get(0));\n+    }\n+\n+    @Test\n+    public void batching() throws Exception {\n+        HttpReporter reporter = initReporter(builder -> builder.batchSpans(2, ofMillis(200)));\n+        reporter.report(newSpan());\n+        reporter.report(newSpan());\n+        List<Span> spans = verifyRequest(receivedRequests.take(), true);\n+        assertThat(\"Unexpected spans received.\", spans, hasSize(2));\n+        verifySpan(spans.get(0));\n+        verifySpan(spans.get(0));", "originalCommit": "0f4583663656a92aae310ebfee570188cf506515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2MzU5MA==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424663590", "bodyText": "Consider verifying that the second batching request also works as expected and we do not send the old values again.", "author": "idelpivnitskiy", "createdAt": "2020-05-13T18:58:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2MTI2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDczMjE1OQ==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424732159", "bodyText": "good catch", "author": "NiteshKant", "createdAt": "2020-05-13T21:08:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2MTI2NA=="}], "type": "inlineReview"}, {"oid": "c6a328dd6b43e5baf254f530d7fd91fb0a6b0026", "url": "https://github.com/apple/servicetalk/commit/c6a328dd6b43e5baf254f530d7fd91fb0a6b0026", "message": "Review comments", "committedDate": "2020-05-13T21:18:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1ODAwNg==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424758006", "bodyText": "since this is best effort, and in practice may not be triggered, does it make sense to drop this this check to avoid providing a false sense of security (e.g. it triggers in tests, but not in real world)?", "author": "Scottmitch", "createdAt": "2020-05-13T22:05:36Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.SingleAddressHttpClientBuilder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.CheckResult;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Function;\n+import javax.annotation.Nonnull;\n+\n+import static io.servicetalk.concurrent.api.AsyncCloseables.newCompositeCloseable;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.BufferStrategies.forCountOrTime;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessorDropHeadOnOverflow;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.http.api.CharSequences.newAsciiString;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_TYPE;\n+import static io.servicetalk.http.api.HttpHeaderValues.APPLICATION_JSON;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+import static zipkin2.CheckResult.OK;\n+import static zipkin2.CheckResult.failed;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to an HTTP endpoint with a configurable encoding {@link Codec}.\n+ */\n+public final class HttpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HttpReporter.class);\n+    static final String V1_PATH = \"/api/v1/spans\";\n+    static final String V2_PATH = \"/api/v2/spans\";\n+    static final CharSequence THRIFT_CONTENT_TYPE = newAsciiString(\"application/x-thrift\");\n+    static final CharSequence PROTO_CONTENT_TYPE = newAsciiString(\"application/protobuf\");\n+\n+    private final PublisherSource.Processor<Span, Span> buffer;\n+    private final CompositeCloseable closeable;\n+\n+    private volatile boolean closeInitiated;\n+\n+    private HttpReporter(final Builder builder) {\n+        closeable = newCompositeCloseable();\n+        final HttpClient client = closeable.append(builder.clientBuilder.build());\n+        try {\n+            buffer = initReporter(builder, client);\n+        } catch (Throwable t) {\n+            try {\n+                closeable.close();\n+            } catch (Exception e) {\n+                LOGGER.error(\"Failed to close the client.\", e);\n+            }\n+            throw t;\n+        }\n+    }\n+\n+    @Override\n+    public CheckResult check() {\n+        return closeInitiated ? OK : failed(new IllegalStateException(\"Reporter is closed.\"));\n+    }\n+\n+    @Override\n+    public void report(final Span span) {\n+        if (closeInitiated) {", "originalCommit": "c6a328dd6b43e5baf254f530d7fd91fb0a6b0026", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc4NjcxMg==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424786712", "bodyText": "and in practice may not be triggered,\n\nI think you are saying that in practice it won't be triggered when the usage is as expected, i.e. no spans are reported after the reporter is closed.  I don't think we can assume expected usage. This is a trade-off between being extremely defensive (making sure no spans can be reported after closure, even when they are concurrent) at the cost of complexity and performance or a best-effort check to provide visibility when an inadvertent misuse has happened, like the same HttpReporter instance is shared across multiple ZipkinPublishers.\nThis trade-off seems reasonable to me.", "author": "NiteshKant", "createdAt": "2020-05-13T23:25:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1ODAwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg1NjU0MQ==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424856541", "bodyText": "To clarify \"best effort\" was meant to highlight even if it isn't used as expected this code may not provide the desired result (e.g. throwing an error). It depends upon a happens-before relationship between closing and reporting which may or may-not exist. I'm suggesting just removing the check because it isn't required from the API contract, there is no guarantee it will throw (e.g. silently dropping data may happen anyways and should be tolerated, users can't rely upon this class detecting use-after-close which may not be clear from code inspection or their unit tests that have different lifetimes/barriers), and it introduces code into the hot path.", "author": "Scottmitch", "createdAt": "2020-05-14T03:55:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1ODAwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg5NTYxOQ==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424895619", "bodyText": "I understood your suggestion.\nI think you are overlooking that this field is volatile?", "author": "NiteshKant", "createdAt": "2020-05-14T06:22:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1ODAwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc2MDY5Mw==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424760693", "bodyText": "optional: consider removing this additional state and set batchSizeHint < 0 to indicate disabled", "author": "Scottmitch", "createdAt": "2020-05-13T22:11:54Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.SingleAddressHttpClientBuilder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.CheckResult;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Function;\n+import javax.annotation.Nonnull;\n+\n+import static io.servicetalk.concurrent.api.AsyncCloseables.newCompositeCloseable;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.BufferStrategies.forCountOrTime;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessorDropHeadOnOverflow;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.http.api.CharSequences.newAsciiString;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_TYPE;\n+import static io.servicetalk.http.api.HttpHeaderValues.APPLICATION_JSON;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+import static zipkin2.CheckResult.OK;\n+import static zipkin2.CheckResult.failed;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to an HTTP endpoint with a configurable encoding {@link Codec}.\n+ */\n+public final class HttpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HttpReporter.class);\n+    static final String V1_PATH = \"/api/v1/spans\";\n+    static final String V2_PATH = \"/api/v2/spans\";\n+    static final CharSequence THRIFT_CONTENT_TYPE = newAsciiString(\"application/x-thrift\");\n+    static final CharSequence PROTO_CONTENT_TYPE = newAsciiString(\"application/protobuf\");\n+\n+    private final PublisherSource.Processor<Span, Span> buffer;\n+    private final CompositeCloseable closeable;\n+\n+    private volatile boolean closeInitiated;\n+\n+    private HttpReporter(final Builder builder) {\n+        closeable = newCompositeCloseable();\n+        final HttpClient client = closeable.append(builder.clientBuilder.build());\n+        try {\n+            buffer = initReporter(builder, client);\n+        } catch (Throwable t) {\n+            try {\n+                closeable.close();\n+            } catch (Exception e) {\n+                LOGGER.error(\"Failed to close the client.\", e);\n+            }\n+            throw t;\n+        }\n+    }\n+\n+    @Override\n+    public CheckResult check() {\n+        return closeInitiated ? OK : failed(new IllegalStateException(\"Reporter is closed.\"));\n+    }\n+\n+    @Override\n+    public void report(final Span span) {\n+        if (closeInitiated) {\n+            throw new IllegalStateException(\"Span: \" + span + \" reported after reporter \" + this + \" is closed.\");\n+        }\n+        buffer.onNext(span);\n+    }\n+\n+    @Override\n+    public void close() {\n+        awaitTermination(closeable.closeAsync().toFuture());\n+    }\n+\n+    @Override\n+    public Completable closeAsync() {\n+        return closeable.closeAsync();\n+    }\n+\n+    @Override\n+    public Completable closeAsyncGracefully() {\n+        return closeable.closeAsyncGracefully();\n+    }\n+\n+    private PublisherSource.Processor<Span, Span> initReporter(final Builder builder, final HttpClient client) {\n+        final PublisherSource.Processor<Span, Span> buffer;\n+        SpanBytesEncoder spanEncoder = builder.codec.spanBytesEncoder();\n+        final BufferAllocator allocator = client.executionContext().bufferAllocator();\n+        final Publisher<Buffer> spans;\n+        if (builder.disableBatching) {\n+            buffer = newPublisherProcessorDropHeadOnOverflow(builder.maxConcurrentReports);\n+            spans = fromSource(buffer).map(span -> allocator.wrap(spanEncoder.encode(span)));\n+        } else {\n+            // As we send maxConcurrentReports number of parallel requests, each with roughly batchSizeHint number of\n+            // spans, we hold a maximum of that many Spans in-memory that we can send in parallel to the collector.\n+            buffer = newPublisherProcessorDropHeadOnOverflow(builder.batchSizeHint * builder.maxConcurrentReports);\n+            spans = fromSource(buffer)\n+                    .buffer(forCountOrTime(builder.batchSizeHint, builder.maxBatchDuration,\n+                            () -> new ListAccumulator(builder.batchSizeHint), client.executionContext().executor()))\n+                    .filter(accumulate -> !accumulate.isEmpty())\n+                    .map(bufferedSpans -> allocator.wrap(spanEncoder.encodeList(bufferedSpans)));\n+        }\n+\n+        final CompletableSource.Processor spansTerminated = newCompletableProcessor();\n+        toSource(spans.flatMapCompletable(encodedSpansReporter(client, builder.codec), builder.maxConcurrentReports))\n+                .subscribe(spansTerminated);\n+\n+        closeable.prepend(toAsyncCloseable(graceful -> {\n+            closeInitiated = true;\n+            try {\n+                buffer.onComplete();\n+            } catch (Throwable t) {\n+                LOGGER.error(\"Failed to dispose request buffer. Ignoring.\", t);\n+            }\n+            return graceful ? fromSource(spansTerminated) : completed();\n+        }));\n+\n+        return buffer;\n+    }\n+\n+    private static Function<Buffer, Completable> encodedSpansReporter(final HttpClient client, final Codec codec) {\n+        final String path;\n+        final CharSequence contentType;\n+        switch (codec) {\n+            case JSON_V1:\n+                path = V1_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case JSON_V2:\n+                path = V2_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case THRIFT:\n+                path = V2_PATH;\n+                contentType = THRIFT_CONTENT_TYPE;\n+                break;\n+            case PROTO3:\n+                path = V2_PATH;\n+                contentType = PROTO_CONTENT_TYPE;\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown codec: \" + codec);\n+        }\n+        return encodedSpans -> client.request(\n+                client.post(path).addHeader(CONTENT_TYPE, contentType).payloadBody(encodedSpans))\n+                .ignoreElement()\n+                .onErrorResume(cause -> {\n+                    LOGGER.error(\"Failed to send a span, ignoring.\", cause);\n+                    return completed();\n+                });\n+    }\n+\n+    /**\n+     * A builder to create a new {@link HttpReporter}.\n+     */\n+    public static final class Builder {\n+        private Codec codec = Codec.JSON_V2;\n+        private final SingleAddressHttpClientBuilder<?, ?> clientBuilder;\n+        private boolean disableBatching;", "originalCommit": "c6a328dd6b43e5baf254f530d7fd91fb0a6b0026", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgzMzEwMw==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424833103", "bodyText": "Since this is a builder I would prefer being explicit as opposed to overloading a field.", "author": "NiteshKant", "createdAt": "2020-05-14T02:17:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc2MDY5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc2MDk2OA==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424760968", "bodyText": "ListAccumulator seems like a very common use case, does it make sense to make this more accessible to avoid future duplication (possibly followup PR)?", "author": "Scottmitch", "createdAt": "2020-05-13T22:12:41Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.SingleAddressHttpClientBuilder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.CheckResult;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Function;\n+import javax.annotation.Nonnull;\n+\n+import static io.servicetalk.concurrent.api.AsyncCloseables.newCompositeCloseable;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.BufferStrategies.forCountOrTime;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessorDropHeadOnOverflow;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.http.api.CharSequences.newAsciiString;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_TYPE;\n+import static io.servicetalk.http.api.HttpHeaderValues.APPLICATION_JSON;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+import static zipkin2.CheckResult.OK;\n+import static zipkin2.CheckResult.failed;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to an HTTP endpoint with a configurable encoding {@link Codec}.\n+ */\n+public final class HttpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HttpReporter.class);\n+    static final String V1_PATH = \"/api/v1/spans\";\n+    static final String V2_PATH = \"/api/v2/spans\";\n+    static final CharSequence THRIFT_CONTENT_TYPE = newAsciiString(\"application/x-thrift\");\n+    static final CharSequence PROTO_CONTENT_TYPE = newAsciiString(\"application/protobuf\");\n+\n+    private final PublisherSource.Processor<Span, Span> buffer;\n+    private final CompositeCloseable closeable;\n+\n+    private volatile boolean closeInitiated;\n+\n+    private HttpReporter(final Builder builder) {\n+        closeable = newCompositeCloseable();\n+        final HttpClient client = closeable.append(builder.clientBuilder.build());\n+        try {\n+            buffer = initReporter(builder, client);\n+        } catch (Throwable t) {\n+            try {\n+                closeable.close();\n+            } catch (Exception e) {\n+                LOGGER.error(\"Failed to close the client.\", e);\n+            }\n+            throw t;\n+        }\n+    }\n+\n+    @Override\n+    public CheckResult check() {\n+        return closeInitiated ? OK : failed(new IllegalStateException(\"Reporter is closed.\"));\n+    }\n+\n+    @Override\n+    public void report(final Span span) {\n+        if (closeInitiated) {\n+            throw new IllegalStateException(\"Span: \" + span + \" reported after reporter \" + this + \" is closed.\");\n+        }\n+        buffer.onNext(span);\n+    }\n+\n+    @Override\n+    public void close() {\n+        awaitTermination(closeable.closeAsync().toFuture());\n+    }\n+\n+    @Override\n+    public Completable closeAsync() {\n+        return closeable.closeAsync();\n+    }\n+\n+    @Override\n+    public Completable closeAsyncGracefully() {\n+        return closeable.closeAsyncGracefully();\n+    }\n+\n+    private PublisherSource.Processor<Span, Span> initReporter(final Builder builder, final HttpClient client) {\n+        final PublisherSource.Processor<Span, Span> buffer;\n+        SpanBytesEncoder spanEncoder = builder.codec.spanBytesEncoder();\n+        final BufferAllocator allocator = client.executionContext().bufferAllocator();\n+        final Publisher<Buffer> spans;\n+        if (builder.disableBatching) {\n+            buffer = newPublisherProcessorDropHeadOnOverflow(builder.maxConcurrentReports);\n+            spans = fromSource(buffer).map(span -> allocator.wrap(spanEncoder.encode(span)));\n+        } else {\n+            // As we send maxConcurrentReports number of parallel requests, each with roughly batchSizeHint number of\n+            // spans, we hold a maximum of that many Spans in-memory that we can send in parallel to the collector.\n+            buffer = newPublisherProcessorDropHeadOnOverflow(builder.batchSizeHint * builder.maxConcurrentReports);\n+            spans = fromSource(buffer)\n+                    .buffer(forCountOrTime(builder.batchSizeHint, builder.maxBatchDuration,\n+                            () -> new ListAccumulator(builder.batchSizeHint), client.executionContext().executor()))\n+                    .filter(accumulate -> !accumulate.isEmpty())\n+                    .map(bufferedSpans -> allocator.wrap(spanEncoder.encodeList(bufferedSpans)));\n+        }\n+\n+        final CompletableSource.Processor spansTerminated = newCompletableProcessor();\n+        toSource(spans.flatMapCompletable(encodedSpansReporter(client, builder.codec), builder.maxConcurrentReports))\n+                .subscribe(spansTerminated);\n+\n+        closeable.prepend(toAsyncCloseable(graceful -> {\n+            closeInitiated = true;\n+            try {\n+                buffer.onComplete();\n+            } catch (Throwable t) {\n+                LOGGER.error(\"Failed to dispose request buffer. Ignoring.\", t);\n+            }\n+            return graceful ? fromSource(spansTerminated) : completed();\n+        }));\n+\n+        return buffer;\n+    }\n+\n+    private static Function<Buffer, Completable> encodedSpansReporter(final HttpClient client, final Codec codec) {\n+        final String path;\n+        final CharSequence contentType;\n+        switch (codec) {\n+            case JSON_V1:\n+                path = V1_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case JSON_V2:\n+                path = V2_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case THRIFT:\n+                path = V2_PATH;\n+                contentType = THRIFT_CONTENT_TYPE;\n+                break;\n+            case PROTO3:\n+                path = V2_PATH;\n+                contentType = PROTO_CONTENT_TYPE;\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown codec: \" + codec);\n+        }\n+        return encodedSpans -> client.request(\n+                client.post(path).addHeader(CONTENT_TYPE, contentType).payloadBody(encodedSpans))\n+                .ignoreElement()\n+                .onErrorResume(cause -> {\n+                    LOGGER.error(\"Failed to send a span, ignoring.\", cause);\n+                    return completed();\n+                });\n+    }\n+\n+    /**\n+     * A builder to create a new {@link HttpReporter}.\n+     */\n+    public static final class Builder {\n+        private Codec codec = Codec.JSON_V2;\n+        private final SingleAddressHttpClientBuilder<?, ?> clientBuilder;\n+        private boolean disableBatching;\n+        private int batchSizeHint = 16;\n+        private int maxConcurrentReports = 32;\n+        private Duration maxBatchDuration = ofSeconds(30);\n+\n+        /**\n+         * Create a new {@link Builder} using the passed {@link SingleAddressHttpClientBuilder}.\n+         *\n+         * @param clientBuilder the collector SocketAddress\n+         */\n+        public Builder(final SingleAddressHttpClientBuilder<?, ?> clientBuilder) {\n+            this.clientBuilder = clientBuilder;\n+        }\n+\n+        /**\n+         * Sets the {@link Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the maximum number of concurrent requests that will be made to the zipkin collector at any time.\n+         *\n+         * @param maxConcurrentReports maximum number of concurrent requests that will be made to the zipkin collector\n+         * at any time.\n+         * @return {@code this}.\n+         */\n+        public Builder maxConcurrentReports(final int maxConcurrentReports) {\n+            if (maxConcurrentReports <= 0) {\n+                throw new IllegalArgumentException(\"maxConcurrentReports: \" + maxConcurrentReports + \" (expected > 0)\");\n+            }\n+            this.maxConcurrentReports = maxConcurrentReports;\n+            return this;\n+        }\n+\n+        /**\n+         * Configure batching of spans before sending it to the zipkin collector.\n+         *\n+         * @param batchSizeHint Hint of how many spans should be batched together.\n+         * @param maxBatchDuration {@link Duration} of time to wait for {@code batchSizeHint} spans in a batch.\n+         * @return {@code this}.\n+         */\n+        public Builder batchSpans(final int batchSizeHint, final Duration maxBatchDuration) {\n+            if (batchSizeHint <= 0) {\n+                throw new IllegalArgumentException(\"batchSizeHint: \" + batchSizeHint + \" (expected > 0)\");\n+            }\n+            disableBatching = false;\n+            this.batchSizeHint = batchSizeHint;\n+            this.maxBatchDuration = requireNonNull(maxBatchDuration);\n+            return this;\n+        }\n+\n+        /**\n+         * Disable batching of spans before sending them to the zipkin collector.\n+         *\n+         * @return {@code this}.\n+         */\n+        public Builder disableSpanBatching() {\n+            disableBatching = true;\n+            return this;\n+        }\n+\n+        /**\n+         * Builds a new {@link HttpReporter} instance with this builder's options.\n+         *\n+         * @return a new {@link HttpReporter}\n+         */\n+        public HttpReporter build() {\n+            return new HttpReporter(this);\n+        }\n+    }\n+\n+    private static final class ListAccumulator implements Accumulator<Span, List<Span>> {", "originalCommit": "c6a328dd6b43e5baf254f530d7fd91fb0a6b0026", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgzMjkzNw==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424832937", "bodyText": "In this case, the span encoder APIs are unnecessarily restrictive that they need a List. Our general methods return an Iterable which should be generally useful apart from speicific semantics of lets say a Set.", "author": "NiteshKant", "createdAt": "2020-05-14T02:17:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc2MDk2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc3MzQwMg==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424773402", "bodyText": "Consider also an assert for reporter.check() before assertThrows.", "author": "idelpivnitskiy", "createdAt": "2020-05-13T22:46:03Z", "path": "servicetalk-opentracing-zipkin-publisher/src/test/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporterTest.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.concurrent.api.AsyncCloseables;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.http.api.HttpRequest;\n+import io.servicetalk.opentracing.zipkin.publisher.reporter.HttpReporter.Builder;\n+import io.servicetalk.transport.api.ServerContext;\n+\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesDecoder;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.function.UnaryOperator;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.http.netty.HttpClients.forSingleAddress;\n+import static io.servicetalk.http.netty.HttpServers.forAddress;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.HttpReporter.V1_PATH;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.HttpReporter.V2_PATH;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.SpanUtils.newSpan;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.SpanUtils.verifySpan;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.localAddress;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.serverHostAndPort;\n+import static java.time.Duration.ofMillis;\n+import static java.util.Arrays.asList;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.junit.Assert.assertThrows;\n+\n+@RunWith(Parameterized.class)\n+public class HttpReporterTest {\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+\n+    private final BlockingQueue<HttpRequest> receivedRequests;\n+    private final ServerContext context;\n+    private final Codec codec;\n+    @Nullable\n+    private HttpReporter reporter;\n+\n+    public HttpReporterTest(final Codec codec) throws Exception {\n+        this.codec = codec;\n+        receivedRequests = new LinkedBlockingQueue<>();\n+        this.context = forAddress(localAddress(0))\n+                .listenBlockingAndAwait((ctx, request, responseFactory) -> {\n+                    receivedRequests.add(request);\n+                    return responseFactory.ok();\n+                });\n+    }\n+\n+    @Parameterized.Parameters(name = \"codec: {0}\")\n+    public static Collection<Codec> data() {\n+        return asList(Codec.values());\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        CompositeCloseable closeable = AsyncCloseables.newCompositeCloseable();\n+        if (reporter != null) {\n+            closeable.append(reporter);\n+        }\n+        closeable.append(context);\n+        closeable.closeGracefully();\n+    }\n+\n+    @Test\n+    public void disableBatching() throws Exception {\n+        HttpReporter reporter = initReporter(Builder::disableSpanBatching);\n+        reporter.report(newSpan(\"1\"));\n+        List<Span> spans = verifyRequest(receivedRequests.take(), false);\n+        assertThat(\"Unexpected spans received.\", spans, hasSize(1));\n+        verifySpan(spans.get(0), \"1\");\n+\n+        reporter.report(newSpan(\"2\"));\n+        List<Span> spans2 = verifyRequest(receivedRequests.take(), false);\n+        assertThat(\"Unexpected spans received.\", spans, hasSize(1));\n+        verifySpan(spans2.get(0), \"2\");\n+    }\n+\n+    @Test\n+    public void batching() throws Exception {\n+        HttpReporter reporter = initReporter(builder -> builder.batchSpans(2, ofMillis(200)));\n+        reporter.report(newSpan(\"1\"));\n+        reporter.report(newSpan(\"2\"));\n+        List<Span> spans = verifyRequest(receivedRequests.take(), true);\n+        assertThat(\"Unexpected spans received.\", spans, hasSize(2));\n+        verifySpan(spans.get(0), \"1\");\n+        verifySpan(spans.get(1), \"2\");\n+    }\n+\n+    @Test\n+    public void reportAfterClose() {\n+        HttpReporter reporter = initReporter(Builder::disableSpanBatching);\n+        reporter.close();\n+        assertThrows(\"Report post close accepted.\", IllegalStateException.class,\n+                () -> reporter.report(newSpan(\"1\")));", "originalCommit": "c6a328dd6b43e5baf254f530d7fd91fb0a6b0026", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg0MTY2MA==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424841660", "bodyText": "Good call, there was a bug \ud83e\udd15", "author": "NiteshKant", "createdAt": "2020-05-14T02:52:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc3MzQwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc3NDY0Mw==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424774643", "bodyText": "Let's also add a second batching report:\nreporter.report(newSpan(\"3\"));\nreporter.report(newSpan(\"4\"));\nList<Span> spans2 = verifyRequest(receivedRequests.take(), true);\nassertThat(\"Unexpected spans received.\", spans2, hasSize(2));\nverifySpan(spans2.get(0), \"3\");\nverifySpan(spans2.get(1), \"4\");\nIt will confirm that we discard the spans that are already sent.", "author": "idelpivnitskiy", "createdAt": "2020-05-13T22:49:30Z", "path": "servicetalk-opentracing-zipkin-publisher/src/test/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporterTest.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.concurrent.api.AsyncCloseables;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.http.api.HttpRequest;\n+import io.servicetalk.opentracing.zipkin.publisher.reporter.HttpReporter.Builder;\n+import io.servicetalk.transport.api.ServerContext;\n+\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesDecoder;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.function.UnaryOperator;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.http.netty.HttpClients.forSingleAddress;\n+import static io.servicetalk.http.netty.HttpServers.forAddress;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.HttpReporter.V1_PATH;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.HttpReporter.V2_PATH;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.SpanUtils.newSpan;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.SpanUtils.verifySpan;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.localAddress;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.serverHostAndPort;\n+import static java.time.Duration.ofMillis;\n+import static java.util.Arrays.asList;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.junit.Assert.assertThrows;\n+\n+@RunWith(Parameterized.class)\n+public class HttpReporterTest {\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+\n+    private final BlockingQueue<HttpRequest> receivedRequests;\n+    private final ServerContext context;\n+    private final Codec codec;\n+    @Nullable\n+    private HttpReporter reporter;\n+\n+    public HttpReporterTest(final Codec codec) throws Exception {\n+        this.codec = codec;\n+        receivedRequests = new LinkedBlockingQueue<>();\n+        this.context = forAddress(localAddress(0))\n+                .listenBlockingAndAwait((ctx, request, responseFactory) -> {\n+                    receivedRequests.add(request);\n+                    return responseFactory.ok();\n+                });\n+    }\n+\n+    @Parameterized.Parameters(name = \"codec: {0}\")\n+    public static Collection<Codec> data() {\n+        return asList(Codec.values());\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        CompositeCloseable closeable = AsyncCloseables.newCompositeCloseable();\n+        if (reporter != null) {\n+            closeable.append(reporter);\n+        }\n+        closeable.append(context);\n+        closeable.closeGracefully();\n+    }\n+\n+    @Test\n+    public void disableBatching() throws Exception {\n+        HttpReporter reporter = initReporter(Builder::disableSpanBatching);\n+        reporter.report(newSpan(\"1\"));\n+        List<Span> spans = verifyRequest(receivedRequests.take(), false);\n+        assertThat(\"Unexpected spans received.\", spans, hasSize(1));\n+        verifySpan(spans.get(0), \"1\");\n+\n+        reporter.report(newSpan(\"2\"));\n+        List<Span> spans2 = verifyRequest(receivedRequests.take(), false);\n+        assertThat(\"Unexpected spans received.\", spans, hasSize(1));\n+        verifySpan(spans2.get(0), \"2\");\n+    }\n+\n+    @Test\n+    public void batching() throws Exception {\n+        HttpReporter reporter = initReporter(builder -> builder.batchSpans(2, ofMillis(200)));\n+        reporter.report(newSpan(\"1\"));\n+        reporter.report(newSpan(\"2\"));\n+        List<Span> spans = verifyRequest(receivedRequests.take(), true);\n+        assertThat(\"Unexpected spans received.\", spans, hasSize(2));\n+        verifySpan(spans.get(0), \"1\");\n+        verifySpan(spans.get(1), \"2\");", "originalCommit": "c6a328dd6b43e5baf254f530d7fd91fb0a6b0026", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgzNDM5MA==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424834390", "bodyText": "Verifying items sent to a Processor is consumed once or not is a Processor test. I do not see value in doing it here as those spans not emitted in the next request sent does not mean they will never be emitted.", "author": "NiteshKant", "createdAt": "2020-05-14T02:22:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc3NDY0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc3NTc0MA==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424775740", "bodyText": "Before we ignoreElement, should we log (at warn or error level) any response statuses that are not SUCCESSFUL_2XX?", "author": "idelpivnitskiy", "createdAt": "2020-05-13T22:52:29Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.SingleAddressHttpClientBuilder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.CheckResult;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Function;\n+import javax.annotation.Nonnull;\n+\n+import static io.servicetalk.concurrent.api.AsyncCloseables.newCompositeCloseable;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.BufferStrategies.forCountOrTime;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessorDropHeadOnOverflow;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.http.api.CharSequences.newAsciiString;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_TYPE;\n+import static io.servicetalk.http.api.HttpHeaderValues.APPLICATION_JSON;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+import static zipkin2.CheckResult.OK;\n+import static zipkin2.CheckResult.failed;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to an HTTP endpoint with a configurable encoding {@link Codec}.\n+ */\n+public final class HttpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HttpReporter.class);\n+    static final String V1_PATH = \"/api/v1/spans\";\n+    static final String V2_PATH = \"/api/v2/spans\";\n+    static final CharSequence THRIFT_CONTENT_TYPE = newAsciiString(\"application/x-thrift\");\n+    static final CharSequence PROTO_CONTENT_TYPE = newAsciiString(\"application/protobuf\");\n+\n+    private final PublisherSource.Processor<Span, Span> buffer;\n+    private final CompositeCloseable closeable;\n+\n+    private volatile boolean closeInitiated;\n+\n+    private HttpReporter(final Builder builder) {\n+        closeable = newCompositeCloseable();\n+        final HttpClient client = closeable.append(builder.clientBuilder.build());\n+        try {\n+            buffer = initReporter(builder, client);\n+        } catch (Throwable t) {\n+            try {\n+                closeable.close();\n+            } catch (Exception e) {\n+                LOGGER.error(\"Failed to close the client.\", e);\n+            }\n+            throw t;\n+        }\n+    }\n+\n+    @Override\n+    public CheckResult check() {\n+        return closeInitiated ? OK : failed(new IllegalStateException(\"Reporter is closed.\"));\n+    }\n+\n+    @Override\n+    public void report(final Span span) {\n+        if (closeInitiated) {\n+            throw new IllegalStateException(\"Span: \" + span + \" reported after reporter \" + this + \" is closed.\");\n+        }\n+        buffer.onNext(span);\n+    }\n+\n+    @Override\n+    public void close() {\n+        awaitTermination(closeable.closeAsync().toFuture());\n+    }\n+\n+    @Override\n+    public Completable closeAsync() {\n+        return closeable.closeAsync();\n+    }\n+\n+    @Override\n+    public Completable closeAsyncGracefully() {\n+        return closeable.closeAsyncGracefully();\n+    }\n+\n+    private PublisherSource.Processor<Span, Span> initReporter(final Builder builder, final HttpClient client) {\n+        final PublisherSource.Processor<Span, Span> buffer;\n+        SpanBytesEncoder spanEncoder = builder.codec.spanBytesEncoder();\n+        final BufferAllocator allocator = client.executionContext().bufferAllocator();\n+        final Publisher<Buffer> spans;\n+        if (builder.disableBatching) {\n+            buffer = newPublisherProcessorDropHeadOnOverflow(builder.maxConcurrentReports);\n+            spans = fromSource(buffer).map(span -> allocator.wrap(spanEncoder.encode(span)));\n+        } else {\n+            // As we send maxConcurrentReports number of parallel requests, each with roughly batchSizeHint number of\n+            // spans, we hold a maximum of that many Spans in-memory that we can send in parallel to the collector.\n+            buffer = newPublisherProcessorDropHeadOnOverflow(builder.batchSizeHint * builder.maxConcurrentReports);\n+            spans = fromSource(buffer)\n+                    .buffer(forCountOrTime(builder.batchSizeHint, builder.maxBatchDuration,\n+                            () -> new ListAccumulator(builder.batchSizeHint), client.executionContext().executor()))\n+                    .filter(accumulate -> !accumulate.isEmpty())\n+                    .map(bufferedSpans -> allocator.wrap(spanEncoder.encodeList(bufferedSpans)));\n+        }\n+\n+        final CompletableSource.Processor spansTerminated = newCompletableProcessor();\n+        toSource(spans.flatMapCompletable(encodedSpansReporter(client, builder.codec), builder.maxConcurrentReports))\n+                .subscribe(spansTerminated);\n+\n+        closeable.prepend(toAsyncCloseable(graceful -> {\n+            closeInitiated = true;\n+            try {\n+                buffer.onComplete();\n+            } catch (Throwable t) {\n+                LOGGER.error(\"Failed to dispose request buffer. Ignoring.\", t);\n+            }\n+            return graceful ? fromSource(spansTerminated) : completed();\n+        }));\n+\n+        return buffer;\n+    }\n+\n+    private static Function<Buffer, Completable> encodedSpansReporter(final HttpClient client, final Codec codec) {\n+        final String path;\n+        final CharSequence contentType;\n+        switch (codec) {\n+            case JSON_V1:\n+                path = V1_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case JSON_V2:\n+                path = V2_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case THRIFT:\n+                path = V2_PATH;\n+                contentType = THRIFT_CONTENT_TYPE;\n+                break;\n+            case PROTO3:\n+                path = V2_PATH;\n+                contentType = PROTO_CONTENT_TYPE;\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown codec: \" + codec);\n+        }\n+        return encodedSpans -> client.request(\n+                client.post(path).addHeader(CONTENT_TYPE, contentType).payloadBody(encodedSpans))\n+                .ignoreElement()", "originalCommit": "c6a328dd6b43e5baf254f530d7fd91fb0a6b0026", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgzNDg3NQ==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424834875", "bodyText": "Good point, lemme add a  log.", "author": "NiteshKant", "createdAt": "2020-05-14T02:24:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc3NTc0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc3NTc4Mw==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424775783", "bodyText": "Consider adding a test that verifies we recover from errors.", "author": "idelpivnitskiy", "createdAt": "2020-05-13T22:52:35Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.SingleAddressHttpClientBuilder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.CheckResult;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Function;\n+import javax.annotation.Nonnull;\n+\n+import static io.servicetalk.concurrent.api.AsyncCloseables.newCompositeCloseable;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.BufferStrategies.forCountOrTime;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessorDropHeadOnOverflow;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.http.api.CharSequences.newAsciiString;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_TYPE;\n+import static io.servicetalk.http.api.HttpHeaderValues.APPLICATION_JSON;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+import static zipkin2.CheckResult.OK;\n+import static zipkin2.CheckResult.failed;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to an HTTP endpoint with a configurable encoding {@link Codec}.\n+ */\n+public final class HttpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HttpReporter.class);\n+    static final String V1_PATH = \"/api/v1/spans\";\n+    static final String V2_PATH = \"/api/v2/spans\";\n+    static final CharSequence THRIFT_CONTENT_TYPE = newAsciiString(\"application/x-thrift\");\n+    static final CharSequence PROTO_CONTENT_TYPE = newAsciiString(\"application/protobuf\");\n+\n+    private final PublisherSource.Processor<Span, Span> buffer;\n+    private final CompositeCloseable closeable;\n+\n+    private volatile boolean closeInitiated;\n+\n+    private HttpReporter(final Builder builder) {\n+        closeable = newCompositeCloseable();\n+        final HttpClient client = closeable.append(builder.clientBuilder.build());\n+        try {\n+            buffer = initReporter(builder, client);\n+        } catch (Throwable t) {\n+            try {\n+                closeable.close();\n+            } catch (Exception e) {\n+                LOGGER.error(\"Failed to close the client.\", e);\n+            }\n+            throw t;\n+        }\n+    }\n+\n+    @Override\n+    public CheckResult check() {\n+        return closeInitiated ? OK : failed(new IllegalStateException(\"Reporter is closed.\"));\n+    }\n+\n+    @Override\n+    public void report(final Span span) {\n+        if (closeInitiated) {\n+            throw new IllegalStateException(\"Span: \" + span + \" reported after reporter \" + this + \" is closed.\");\n+        }\n+        buffer.onNext(span);\n+    }\n+\n+    @Override\n+    public void close() {\n+        awaitTermination(closeable.closeAsync().toFuture());\n+    }\n+\n+    @Override\n+    public Completable closeAsync() {\n+        return closeable.closeAsync();\n+    }\n+\n+    @Override\n+    public Completable closeAsyncGracefully() {\n+        return closeable.closeAsyncGracefully();\n+    }\n+\n+    private PublisherSource.Processor<Span, Span> initReporter(final Builder builder, final HttpClient client) {\n+        final PublisherSource.Processor<Span, Span> buffer;\n+        SpanBytesEncoder spanEncoder = builder.codec.spanBytesEncoder();\n+        final BufferAllocator allocator = client.executionContext().bufferAllocator();\n+        final Publisher<Buffer> spans;\n+        if (builder.disableBatching) {\n+            buffer = newPublisherProcessorDropHeadOnOverflow(builder.maxConcurrentReports);\n+            spans = fromSource(buffer).map(span -> allocator.wrap(spanEncoder.encode(span)));\n+        } else {\n+            // As we send maxConcurrentReports number of parallel requests, each with roughly batchSizeHint number of\n+            // spans, we hold a maximum of that many Spans in-memory that we can send in parallel to the collector.\n+            buffer = newPublisherProcessorDropHeadOnOverflow(builder.batchSizeHint * builder.maxConcurrentReports);\n+            spans = fromSource(buffer)\n+                    .buffer(forCountOrTime(builder.batchSizeHint, builder.maxBatchDuration,\n+                            () -> new ListAccumulator(builder.batchSizeHint), client.executionContext().executor()))\n+                    .filter(accumulate -> !accumulate.isEmpty())\n+                    .map(bufferedSpans -> allocator.wrap(spanEncoder.encodeList(bufferedSpans)));\n+        }\n+\n+        final CompletableSource.Processor spansTerminated = newCompletableProcessor();\n+        toSource(spans.flatMapCompletable(encodedSpansReporter(client, builder.codec), builder.maxConcurrentReports))\n+                .subscribe(spansTerminated);\n+\n+        closeable.prepend(toAsyncCloseable(graceful -> {\n+            closeInitiated = true;\n+            try {\n+                buffer.onComplete();\n+            } catch (Throwable t) {\n+                LOGGER.error(\"Failed to dispose request buffer. Ignoring.\", t);\n+            }\n+            return graceful ? fromSource(spansTerminated) : completed();\n+        }));\n+\n+        return buffer;\n+    }\n+\n+    private static Function<Buffer, Completable> encodedSpansReporter(final HttpClient client, final Codec codec) {\n+        final String path;\n+        final CharSequence contentType;\n+        switch (codec) {\n+            case JSON_V1:\n+                path = V1_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case JSON_V2:\n+                path = V2_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case THRIFT:\n+                path = V2_PATH;\n+                contentType = THRIFT_CONTENT_TYPE;\n+                break;\n+            case PROTO3:\n+                path = V2_PATH;\n+                contentType = PROTO_CONTENT_TYPE;\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown codec: \" + codec);\n+        }\n+        return encodedSpans -> client.request(\n+                client.post(path).addHeader(CONTENT_TYPE, contentType).payloadBody(encodedSpans))\n+                .ignoreElement()\n+                .onErrorResume(cause -> {\n+                    LOGGER.error(\"Failed to send a span, ignoring.\", cause);", "originalCommit": "c6a328dd6b43e5baf254f530d7fd91fb0a6b0026", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "258392693fe4b99237f17ccabf1a7a0c026126c3", "url": "https://github.com/apple/servicetalk/commit/258392693fe4b99237f17ccabf1a7a0c026126c3", "message": "Review comments", "committedDate": "2020-05-14T02:52:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2Njk5NA==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424866994", "bodyText": "That may log any secret header values (auth tokens). Consider not logging all the headers. Status code and maybe a payload body should be enough.", "author": "idelpivnitskiy", "createdAt": "2020-05-14T04:40:50Z", "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -177,6 +179,13 @@ public Completable closeAsyncGracefully() {\n         }\n         return encodedSpans -> client.request(\n                 client.post(path).addHeader(CONTENT_TYPE, contentType).payloadBody(encodedSpans))\n+                .beforeOnSuccess(response -> {\n+                    HttpResponseStatus status = response.status();\n+                    if (status.statusClass() != SUCCESSFUL_2XX) {\n+                        LOGGER.info(\"Unexpected response from the collector. Response headers: {}\",\n+                                response.toString((__, headerValue) -> headerValue));", "originalCommit": "258392693fe4b99237f17ccabf1a7a0c026126c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI5NTQwNw==", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r425295407", "bodyText": "This is for response and there is a trade-off b/w this log being of limited usefulness and may  disclose more than necessary information. Sending secrets in a response header is somewhat less likely as compared to providing more information about the error in a header. So, I would like to keep this log here to aid debuggability.", "author": "NiteshKant", "createdAt": "2020-05-14T17:05:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2Njk5NA=="}], "type": "inlineReview"}]}