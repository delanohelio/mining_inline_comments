{"pr_number": 1000, "pr_title": "Completable#concatWith(Completable) remove atomic operation", "pr_createdAt": "2020-04-03T16:20:33Z", "pr_url": "https://github.com/apple/servicetalk/pull/1000", "timeline": [{"oid": "015ed7328a90fd9f78178d723e766178ea217e8f", "url": "https://github.com/apple/servicetalk/commit/015ed7328a90fd9f78178d723e766178ea217e8f", "message": "Completable#concatWith(Completable) remove atomic operation\n\nMotivation:\nCompletable#concatWith(Completable) currently uses an atomic operation to transition subscribe() from the first Completable to the second. However this is done in the contex of a Subscriber and the events should be sequenced in a [serial](https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#1.3) fashion.\n\nModifications:\n- Completable#concatWith(Completable) to use a regular variable instead of volatile/atomic operation to switch subscribers\n\nResult:\nLess atomic operations in Completable#concatWith(Completable).", "committedDate": "2020-04-03T16:20:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzEzODY5NA==", "url": "https://github.com/apple/servicetalk/pull/1000#discussion_r403138694", "bodyText": "This is an interesting one.\nWe are using the same Subscriber instance across different sources. RS spec mentions that all methods of a Subscriber must be invoked serially(Rule 1.3) and a Subscriber should ensure delivery of signals happens-before processing of signals(Rule 2.11) however, there is no mention of a rule where subscribe() should happen-before delivery of signals to the Subscriber.\nSo, here there is nothing guaranteeing from the spec that their is a memory barrier between call to next.subscribeInternal(this) and onComplete() from the next source. So, it may be that we will see nextSubscribed as false and subscribe again.\nInterestingly I had this conversation before but it wasn't clear whether a rule is required to be added to the spec or existing rules cover this case. So \ud83c\udf7f \ud83d\ude04", "author": "NiteshKant", "createdAt": "2020-04-03T16:45:56Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/CompletableConcatWithCompletable.java", "diffHunk": "@@ -63,14 +62,11 @@ protected void handleSubscribe(Subscriber subscriber, SignalOffloader offloader,\n     }\n \n     private static final class ConcatWithSubscriber implements Subscriber {\n-        private static final AtomicIntegerFieldUpdater<ConcatWithSubscriber> subscribedToNextUpdater =\n-                AtomicIntegerFieldUpdater.newUpdater(ConcatWithSubscriber.class, \"subscribedToNext\");\n         private final Subscriber target;\n         private final Completable next;\n         @Nullable\n         private SequentialCancellable sequentialCancellable;\n-        @SuppressWarnings(\"unused\")\n-        private volatile int subscribedToNext;\n+        private boolean nextSubscribed;", "originalCommit": "015ed7328a90fd9f78178d723e766178ea217e8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzMwNjUxMQ==", "url": "https://github.com/apple/servicetalk/pull/1000#discussion_r403306511", "bodyText": "I recall discussing this previously as well. IIUC the \"shared subscriber\" scenario is equivalent to the following:\nclass MySubscriber<T> implements Subscriber<T> {\n  // not final, so no constructor barriers\n  Object externalState;\n  int internalState;\n\n  MySubscriber(Object state) {\n    externalState = state;\n    internalState = 5;\n  }\n  \n  onNext(T) {\n    // is externalState, internalState visible?\n  }\n}\n\nPublisher<T> pub = ...;\npub.subscribe(new MySubscriber<>(\"outside\"));\nIf there is no happens-before relationship all non-final state in MySubscriber may not be visible when its Subscriber methods are invoked, which doesn't seem like desirable semantics from RS.\nRelated considerations:\n\nreactive-streams examples use non-final state. In this case the state happens to be set to the default value, but if there is no happens before the explicit initialization to false could happen at some later time and be visible after the Subscriber has set the value to true.\nsequentialCancellable in this class would also have the same issue (e.g. non final state used across subscribes).\nAll our other concat operator implementations operate in the same way as this PR.\n\nSuggested path forward:\n\nuse a consistent approach internally. This PR makes our approach consistent and is less change the the other direction which involves investigating all other local state (shared across subscribes or initialized in the construction, ...).\nopen another discussion with the RS folks to discuss the above. Revisit if we need to make more broad changes.", "author": "Scottmitch", "createdAt": "2020-04-03T20:24:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzEzODY5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM2MTEwOA==", "url": "https://github.com/apple/servicetalk/pull/1000#discussion_r403361108", "bodyText": "Good points about non-final state!\nI have created this in RS:\nreactive-streams/reactive-streams-jvm#486\nAnd I agree we should go ahead with this change to make things consistent.", "author": "NiteshKant", "createdAt": "2020-04-03T22:12:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzEzODY5NA=="}], "type": "inlineReview"}]}