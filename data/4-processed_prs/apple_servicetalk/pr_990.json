{"pr_number": 990, "pr_title": "Add `whenFinally(TerminalSignalConsumer)` for Publisher, Single, Completable", "pr_createdAt": "2020-03-31T18:08:53Z", "pr_url": "https://github.com/apple/servicetalk/pull/990", "timeline": [{"oid": "01112f20a3704b97951c158c42b844a24d340e7a", "url": "https://github.com/apple/servicetalk/commit/01112f20a3704b97951c158c42b844a24d340e7a", "message": "Add `whenFinally(TerminalSignalConsumer)` for Publisher, Single, Completable\n\nMotivation:\n\n`whenFinally(Runnable)` does not allow users to understand which final event\nhappened. When they add multiple operators for each individual event users\nhave to manually protect from possible concurrency between `whenCancel` and\n`whenOnComplete/whenOnError`.\n\nModification:\n\n- Add `whenFinally(TerminalSignalConsumer)` operator for Publisher, Single,\nCompletable;\n- Enhance tests to account for different final signals;\n- Add `TerminalSignalConsumer.from(Runnable)`;\n- Use `TerminalSignalConsumer.from(Runnable)` in\n`BeforeFinallyOnHttpResponseOperatorTest`;\n\nResult:\n\nUsers can pass `TerminalSignalConsumer` to `whenFinally` operator and make\nsure only a single callback will be invoked.", "committedDate": "2020-03-31T18:06:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTExNTM0Mg==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401115342", "bodyText": "Do we need to keep beforeFinally(Runnable)? Should we remove it and users can use beforeFinally(TerminalSignalConsumer.from(doFinally))  themselves.", "author": "idelpivnitskiy", "createdAt": "2020-03-31T18:12:30Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Completable.java", "diffHunk": "@@ -757,8 +798,45 @@ public final Completable beforeCancel(Runnable onCancel) {\n      * </ul>\n      * for Subscriptions/{@link Subscriber}s of the returned {@link Completable}. <strong>MUST NOT</strong> throw.\n      * @return The new {@link Completable}.\n+     *\n+     * @see <a href=\"http://reactivex.io/documentation/operators/do.html\">ReactiveX do operator.</a>\n      */\n     public final Completable beforeFinally(Runnable doFinally) {\n+        return beforeFinally(TerminalSignalConsumer.from(doFinally));", "originalCommit": "01112f20a3704b97951c158c42b844a24d340e7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM3MzAzNw==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401373037", "bodyText": "Runnable flavors are useful for state cleanups where type of termination does not matter. So, I will suggest to keep these methods.", "author": "NiteshKant", "createdAt": "2020-04-01T06:00:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTExNTM0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTExNjQ0Mg==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401116442", "bodyText": "Here we have an inconsistency between Single.whenOnSuccess(Consumer<? super T>) and TerminalSignalConsumer.onComplete() that does not provide T. Should we have a different TerminalSignalConsumer for Single?", "author": "idelpivnitskiy", "createdAt": "2020-03-31T18:14:21Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Single.java", "diffHunk": "@@ -294,6 +294,46 @@ public final Completable flatMapCompletable(Function<? super T, ? extends Comple\n         return afterFinally(doFinally);\n     }\n \n+    /**\n+     * Invokes an appropriate terminal signal of the {@link TerminalSignalConsumer}, when any of the following terminal\n+     * methods are called:\n+     * <ul>\n+     *     <li>{@link Subscriber#onSuccess(Object)} - invokes {@link TerminalSignalConsumer#onComplete()}</li>", "originalCommit": "01112f20a3704b97951c158c42b844a24d340e7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM4Nzk3Ng==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401387976", "bodyText": "Ya I think so as onComplete() does not match the name (onSuccess()) too.", "author": "NiteshKant", "createdAt": "2020-04-01T06:42:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTExNjQ0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkwMTQzMQ==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401901431", "bodyText": "If we will have something like SingleTerminalSignalConsumer, WDYT about having a TerminalSignalConsumer for each async source independently?\n\nCompletableTerminalSignalConsumer\nSingleTerminalSignalConsumer\nPublisherTerminalSignalConsumer\n\nAlso, WDYT about promoting all of them to servicetalk-concurrent module where we keep all interfaces for async sources?\n\nCompletableSource.TerminalSignalConsumer\nSingleSource.TerminalSignalConsumer\nPublisherSource.TerminalSignalConsumer", "author": "idelpivnitskiy", "createdAt": "2020-04-01T20:51:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTExNjQ0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkwMjY4Mg==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401902682", "bodyText": "Moving them to servicetalk-concurrent module will also help to hide from(Runnable) from public API and share it between concurrent-api and http-utils.", "author": "idelpivnitskiy", "createdAt": "2020-04-01T20:53:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTExNjQ0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3NzA5MA==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401977090", "bodyText": "I am hesitant to push this to concurrent module just for reuse of an implementation. This interface is specific to operators and not to the sources.\nAs we do not expect new callbacks on Completable and the terminal callbacks are the same b/w Publisher and Completable, I think it is less justified to add different interfaces for Publisher and Completable. I would suggest keeping the current TerminalSignalConsumer  as-is, use it for Publisher and Completable and create a Single specific interface which can be an inner class in concurrent.api.Single", "author": "NiteshKant", "createdAt": "2020-04-01T23:57:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTExNjQ0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTExODY1MQ==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401118651", "bodyText": "Here we have a small naming inconsistency between TerminalSignalConsumer API and other when* operators:\n\nwhenOnComplete(Runnable) matches with TerminalSignalConsumer#onComplete();\nwhenOnError(Consumer<Throwable>) matches with TerminalSignalConsumer#onError(Throwable);\n\nwhenCancel(Runnable) does not have On in the middle to match with TerminalSignalConsumer#onCancel().\nIt's ok for me, just want to highlight this naming inconsistency. WDYT?", "author": "idelpivnitskiy", "createdAt": "2020-03-31T18:18:12Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Publisher.java", "diffHunk": "@@ -1499,6 +1540,42 @@ public final Completable flatMapCompletableDelayError(Function<? super T, ? exte\n      * @see <a href=\"http://reactivex.io/documentation/operators/do.html\">ReactiveX do operator.</a>\n      */\n     public final Publisher<T> beforeFinally(Runnable doFinally) {\n+        return beforeFinally(TerminalSignalConsumer.from(doFinally));\n+    }\n+\n+    /**\n+     * Invokes an appropriate terminal signal of the {@link TerminalSignalConsumer} <strong>before</strong> any of the\n+     * following terminal methods are called:\n+     * <ul>\n+     *     <li>{@link Subscriber#onComplete()} - invokes {@link TerminalSignalConsumer#onComplete()}</li>\n+     *     <li>{@link Subscriber#onError(Throwable)} - invokes {@link TerminalSignalConsumer#onError(Throwable)}</li>\n+     *     <li>{@link Subscription#cancel()} - invokes {@link TerminalSignalConsumer#onCancel()}</li>", "originalCommit": "01112f20a3704b97951c158c42b844a24d340e7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM5MTU0MA==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401391540", "bodyText": "The operator names are following the pattern before/when/after[actual method name] so I think whenCancel() is correct. We can rename TerminalSignalConsumer#onCancel() to cancel() to match the pattern", "author": "NiteshKant", "createdAt": "2020-04-01T06:51:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTExODY1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2NDQxMQ==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401464411", "bodyText": "cancel() sounds like it \"cancels\" something which seems to be no the case or I am missing something ?", "author": "normanmaurer", "createdAt": "2020-04-01T09:06:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTExODY1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc3NzI2Mw==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401777263", "bodyText": "Ya its just a conflict between following names of the callbacks these methods represent (TerminalSignalConsumer#cancel() here is invoked when Subscription#cancel() is called) or changing names to make it more meaningful in this context. We went with following callback names which seems easier to correlate.", "author": "NiteshKant", "createdAt": "2020-04-01T17:13:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTExODY1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjA1NDUxNw==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r402054517", "bodyText": "Renamed to TerminalSignalConsumer#cancel()", "author": "idelpivnitskiy", "createdAt": "2020-04-02T05:09:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTExODY1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEyMDk2Mw==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401120963", "bodyText": "Tried to place RunnableTerminalSignalConsumer in some internal module to avoid adding this API, but the module structure did not allow me to reuse this class in concurrent-api and http-utils.", "author": "idelpivnitskiy", "createdAt": "2020-03-31T18:22:08Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/TerminalSignalConsumer.java", "diffHunk": "@@ -40,4 +42,14 @@ default void onError(Throwable throwable) {\n      */\n     default void onCancel() {\n     }\n+\n+    /**\n+     * Creates a new {@link TerminalSignalConsumer} from {@link Runnable}.\n+     *\n+     * @param onFinally a {@link Runnable} to run on any terminal signal\n+     * @return a new {@link TerminalSignalConsumer} from {@link Runnable}\n+     */\n+    static TerminalSignalConsumer from(Runnable onFinally) {\n+        return new RunnableTerminalSignalConsumer(onFinally);", "originalCommit": "01112f20a3704b97951c158c42b844a24d340e7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM3NDc3OA==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401374778", "bodyText": "It seems Ok to me to add as a public method.", "author": "NiteshKant", "createdAt": "2020-04-01T06:05:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEyMDk2Mw=="}], "type": "inlineReview"}, {"oid": "d151a291a2c7cd5c106d4dee8d49c45b142b45fa", "url": "https://github.com/apple/servicetalk/commit/d151a291a2c7cd5c106d4dee8d49c45b142b45fa", "message": "Fix checkstyle errors", "committedDate": "2020-03-31T18:27:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM3NTQyMg==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401375422", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Creates a new {@link TerminalSignalConsumer} from {@link Runnable}.\n          \n          \n            \n                 * Adapts the passed {@link Runnable} to a {@link TerminalSignalConsumer} such that {@link Runnable#run()} \n          \n          \n            \n                 * is invoked for each call to {@link TerminalSignalConsumer#onError()}, {@link TerminalSignalConsumer#onComplete()} and {@link TerminalSignalConsumer#onCancel()}.", "author": "NiteshKant", "createdAt": "2020-04-01T06:07:36Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/TerminalSignalConsumer.java", "diffHunk": "@@ -40,4 +42,14 @@ default void onError(Throwable throwable) {\n      */\n     default void onCancel() {\n     }\n+\n+    /**\n+     * Creates a new {@link TerminalSignalConsumer} from {@link Runnable}.", "originalCommit": "d151a291a2c7cd5c106d4dee8d49c45b142b45fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2OTUyMQ==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401469521", "bodyText": "This should be {@link TerminalSignalConsumer#onError(Throwable)}", "author": "normanmaurer", "createdAt": "2020-04-01T09:15:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM3NTQyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM3NTgwMg==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401375802", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param onFinally a {@link Runnable} to run on any terminal signal\n          \n          \n            \n                 * @param onFinally a {@link Runnable} to adapt to the returned {@link TerminalSignalConsumer} such that {@link Runnable#run()} is invoked for each call to {@link TerminalSignalConsumer#onError()}, {@link TerminalSignalConsumer#onComplete()} and {@link TerminalSignalConsumer#onCancel()}", "author": "NiteshKant", "createdAt": "2020-04-01T06:08:48Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/TerminalSignalConsumer.java", "diffHunk": "@@ -40,4 +42,14 @@ default void onError(Throwable throwable) {\n      */\n     default void onCancel() {\n     }\n+\n+    /**\n+     * Creates a new {@link TerminalSignalConsumer} from {@link Runnable}.\n+     *\n+     * @param onFinally a {@link Runnable} to run on any terminal signal", "originalCommit": "d151a291a2c7cd5c106d4dee8d49c45b142b45fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2OTI5MQ==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401469291", "bodyText": "This should be {@link {@link TerminalSignalConsumer#onError(Throwable)}}", "author": "normanmaurer", "createdAt": "2020-04-01T09:14:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM3NTgwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM3NjMzMg==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401376332", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return a new {@link TerminalSignalConsumer} from {@link Runnable}\n          \n          \n            \n                 * @return a {@link TerminalSignalConsumer} that adapts the passed {@link Runnable}.", "author": "NiteshKant", "createdAt": "2020-04-01T06:10:18Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/TerminalSignalConsumer.java", "diffHunk": "@@ -40,4 +42,14 @@ default void onError(Throwable throwable) {\n      */\n     default void onCancel() {\n     }\n+\n+    /**\n+     * Creates a new {@link TerminalSignalConsumer} from {@link Runnable}.\n+     *\n+     * @param onFinally a {@link Runnable} to run on any terminal signal\n+     * @return a new {@link TerminalSignalConsumer} from {@link Runnable}", "originalCommit": "d151a291a2c7cd5c106d4dee8d49c45b142b45fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM3Njk4Nw==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401376987", "bodyText": "Does this have to implement TerminalSignalConsumer?\nAlso, this does not follow the typical pattern where in such classes we provide static factory methods instead of exposing the concrete implementations.", "author": "NiteshKant", "createdAt": "2020-04-01T06:12:15Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/TerminalSignalConsumers.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+final class TerminalSignalConsumers implements TerminalSignalConsumer {", "originalCommit": "d151a291a2c7cd5c106d4dee8d49c45b142b45fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkyNDE4NQ==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401924185", "bodyText": "Does this have to implement TerminalSignalConsumer?\n\nNo, this is a leftover from intermediate iteration. This upper-level class used to be RunnableTerminalSignalConsumer. Thanks for the catch.", "author": "idelpivnitskiy", "createdAt": "2020-04-01T21:35:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM3Njk4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkyNTcxMg==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401925712", "bodyText": "Btw, because TerminalSignalConsumer has all its methods as default noop impl, it's very easy to forget about them. Was bitten by this twice. Should we remove default implementations? If users don't need all 3 signals they can use alternative operators. If they need only 2 signals, it's not a big deal to provide a noop impl for the signal you are not interested in.", "author": "idelpivnitskiy", "createdAt": "2020-04-01T21:38:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM3Njk4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM3ODEyNg==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401378126", "bodyText": "deletage -> delegate", "author": "NiteshKant", "createdAt": "2020-04-01T06:15:31Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/TerminalSignalConsumers.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+final class TerminalSignalConsumers implements TerminalSignalConsumer {\n+\n+    static final class RunnableTerminalSignalConsumer implements TerminalSignalConsumer {\n+\n+        private final Runnable onFinally;\n+\n+        RunnableTerminalSignalConsumer(Runnable onFinally) {\n+            this.onFinally = requireNonNull(onFinally);\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            onFinally.run();\n+        }\n+\n+        @Override\n+        public void onError(final Throwable throwable) {\n+            onFinally.run();\n+        }\n+\n+        @Override\n+        public void onCancel() {\n+            onFinally.run();\n+        }\n+    }\n+\n+    static final class CompleteTerminalSignalConsumer implements TerminalSignalConsumer {\n+\n+        private static final AtomicIntegerFieldUpdater<TerminalSignalConsumers.CompleteTerminalSignalConsumer>\n+                completeUpdater = AtomicIntegerFieldUpdater.newUpdater(\n+                        TerminalSignalConsumers.CompleteTerminalSignalConsumer.class, \"complete\");\n+        @SuppressWarnings(\"unused\")\n+        private volatile int complete;\n+\n+        private final TerminalSignalConsumer deletage;", "originalCommit": "d151a291a2c7cd5c106d4dee8d49c45b142b45fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM3ODMwMA==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401378300", "bodyText": "CompleteTerminalSignalConsumer => DelegatingTerminalSignalConsumer?\nI am on the fence for wrapping here to make sure that we only invoke the said methods once. Altenratively you can leave the state in respective operators as they are today and if you want to share code of invoking these methods, you can create static methods here like:\nstatic <T> void invokeOnCompleteIfNotDone(TerminalSignalConsumer target, AtomicIntegerFieldUpdater<T> doneUpdater,\n                                          final T owner) {\n    if (doneUpdater.compareAndSet(owner, 0, 1)) {\n        target.onComplete();\n    }\n}", "author": "NiteshKant", "createdAt": "2020-04-01T06:16:06Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/TerminalSignalConsumers.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+final class TerminalSignalConsumers implements TerminalSignalConsumer {\n+\n+    static final class RunnableTerminalSignalConsumer implements TerminalSignalConsumer {\n+\n+        private final Runnable onFinally;\n+\n+        RunnableTerminalSignalConsumer(Runnable onFinally) {\n+            this.onFinally = requireNonNull(onFinally);\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            onFinally.run();\n+        }\n+\n+        @Override\n+        public void onError(final Throwable throwable) {\n+            onFinally.run();\n+        }\n+\n+        @Override\n+        public void onCancel() {\n+            onFinally.run();\n+        }\n+    }\n+\n+    static final class CompleteTerminalSignalConsumer implements TerminalSignalConsumer {", "originalCommit": "d151a291a2c7cd5c106d4dee8d49c45b142b45fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg5ODE0MQ==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401898141", "bodyText": "I tried this approach first and it worked well for (Before|After)FinallyPublisher, but similar operators for Completable and Single use BeforeCancellable. It required me to create a new Cancellable implementation or pass a lambda to BeforeCancellable that will keep references to the state outside of that lambda. Not a big deal but introduces a similar need for wrapping.\nThis approach also wraps, but at the same time helps to reduce duplication between operators of maintaining atomic state and allows me to pass only references to the doFinally::onCancel for BeforeCancellable.", "author": "idelpivnitskiy", "createdAt": "2020-04-01T20:44:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM3ODMwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjA1NDgwNg==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r402054806", "bodyText": "Because we have Single.TerminalSignalConsumer now this wrapped doesn't make sense anymore. Reverted the previous approach.", "author": "idelpivnitskiy", "createdAt": "2020-04-02T05:10:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM3ODMwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM4MTYzNA==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401381634", "bodyText": "nit: name complete is misleading as there is a method here onComplete() which may indicate that this state resembles calling that method. You can instead use a name like done", "author": "NiteshKant", "createdAt": "2020-04-01T06:25:28Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/TerminalSignalConsumers.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+final class TerminalSignalConsumers implements TerminalSignalConsumer {\n+\n+    static final class RunnableTerminalSignalConsumer implements TerminalSignalConsumer {\n+\n+        private final Runnable onFinally;\n+\n+        RunnableTerminalSignalConsumer(Runnable onFinally) {\n+            this.onFinally = requireNonNull(onFinally);\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            onFinally.run();\n+        }\n+\n+        @Override\n+        public void onError(final Throwable throwable) {\n+            onFinally.run();\n+        }\n+\n+        @Override\n+        public void onCancel() {\n+            onFinally.run();\n+        }\n+    }\n+\n+    static final class CompleteTerminalSignalConsumer implements TerminalSignalConsumer {\n+\n+        private static final AtomicIntegerFieldUpdater<TerminalSignalConsumers.CompleteTerminalSignalConsumer>\n+                completeUpdater = AtomicIntegerFieldUpdater.newUpdater(\n+                        TerminalSignalConsumers.CompleteTerminalSignalConsumer.class, \"complete\");\n+        @SuppressWarnings(\"unused\")\n+        private volatile int complete;", "originalCommit": "d151a291a2c7cd5c106d4dee8d49c45b142b45fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM4NDgwMw==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401384803", "bodyText": "Similar comment for other methods here and in other sources.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Invokes the {@code whenFinally} {@link Runnable} argument <strong>before</strong> any of the following terminal\n          \n          \n            \n                 * Invokes the corresponding method on {@code whenFinally} {@link TerminalSignalConsumer} argument <strong>before</strong> any of the following terminal", "author": "NiteshKant", "createdAt": "2020-04-01T06:34:04Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Completable.java", "diffHunk": "@@ -757,8 +798,45 @@ public final Completable beforeCancel(Runnable onCancel) {\n      * </ul>\n      * for Subscriptions/{@link Subscriber}s of the returned {@link Completable}. <strong>MUST NOT</strong> throw.\n      * @return The new {@link Completable}.\n+     *\n+     * @see <a href=\"http://reactivex.io/documentation/operators/do.html\">ReactiveX do operator.</a>\n      */\n     public final Completable beforeFinally(Runnable doFinally) {\n+        return beforeFinally(TerminalSignalConsumer.from(doFinally));\n+    }\n+\n+    /**\n+     * Invokes the {@code whenFinally} {@link Runnable} argument <strong>before</strong> any of the following terminal", "originalCommit": "d151a291a2c7cd5c106d4dee8d49c45b142b45fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM4NjU0NA==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401386544", "bodyText": "Similar comment for other methods here and in other sources.\nThe semantics here do not really match try-finally now as the code paths are different for error vs completion:\n     *  try {\n     *      resultOfThisCompletable();\n     *  } catch(Throwable t) {\n     *      doFinally.onError(t);\n     *      nextOperation(); // Maybe notifying of cancellation, or termination\n     *      return;\n     *  }\n     *  doFinally.onComplete(); \n     *  nextOperation(); // Maybe notifying of cancellation, or termination", "author": "NiteshKant", "createdAt": "2020-04-01T06:38:28Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Completable.java", "diffHunk": "@@ -757,8 +798,45 @@ public final Completable beforeCancel(Runnable onCancel) {\n      * </ul>\n      * for Subscriptions/{@link Subscriber}s of the returned {@link Completable}. <strong>MUST NOT</strong> throw.\n      * @return The new {@link Completable}.\n+     *\n+     * @see <a href=\"http://reactivex.io/documentation/operators/do.html\">ReactiveX do operator.</a>\n      */\n     public final Completable beforeFinally(Runnable doFinally) {\n+        return beforeFinally(TerminalSignalConsumer.from(doFinally));\n+    }\n+\n+    /**\n+     * Invokes the {@code whenFinally} {@link Runnable} argument <strong>before</strong> any of the following terminal\n+     * methods are called:\n+     * <ul>\n+     *     <li>{@link Subscriber#onComplete()} - invokes {@link TerminalSignalConsumer#onComplete()}</li>\n+     *     <li>{@link Subscriber#onError(Throwable)} - invokes {@link TerminalSignalConsumer#onError(Throwable)}</li>\n+     *     <li>{@link Cancellable#cancel()} - invokes {@link TerminalSignalConsumer#onCancel()}</li>\n+     * </ul>\n+     * for Subscriptions/{@link Subscriber}s of the returned {@link Completable}.\n+     * <p>\n+     * From a sequential programming point of view this method is roughly equivalent to the following:\n+     * <pre>{@code\n+     *  try {\n+     *      resultOfThisCompletable();\n+     *  } finally {\n+     *      doFinally.onTerminalSignal(); // Invokes an appropriate terminal signal", "originalCommit": "d151a291a2c7cd5c106d4dee8d49c45b142b45fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM4ODc5OA==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401388798", "bodyText": "Fields can be final", "author": "NiteshKant", "createdAt": "2020-04-01T06:44:16Z", "path": "servicetalk-concurrent-api/src/testFixtures/java/io/servicetalk/concurrent/api/TerminalSignalConsumerMock.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import org.mockito.Mockito;\n+\n+import static org.mockito.AdditionalAnswers.delegatesTo;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+/**\n+ * Mocked {@link TerminalSignalConsumer} that helps to verify that only a single terminal method was invoked.\n+ */\n+public final class TerminalSignalConsumerMock implements TerminalSignalConsumer {\n+\n+    private Runnable runnable;", "originalCommit": "d151a291a2c7cd5c106d4dee8d49c45b142b45fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM4OTU2Nw==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401389567", "bodyText": "What is the use of the Runnable here?", "author": "NiteshKant", "createdAt": "2020-04-01T06:46:21Z", "path": "servicetalk-concurrent-api/src/testFixtures/java/io/servicetalk/concurrent/api/TerminalSignalConsumerMock.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import org.mockito.Mockito;\n+\n+import static org.mockito.AdditionalAnswers.delegatesTo;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+/**\n+ * Mocked {@link TerminalSignalConsumer} that helps to verify that only a single terminal method was invoked.\n+ */\n+public final class TerminalSignalConsumerMock implements TerminalSignalConsumer {\n+\n+    private Runnable runnable;\n+    private TerminalSignalConsumer signalConsumer;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public TerminalSignalConsumerMock() {\n+        runnable = Mockito.mock(Runnable.class);", "originalCommit": "d151a291a2c7cd5c106d4dee8d49c45b142b45fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2ODA2MA==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401968060", "bodyText": "Trying to test that RunnableTerminalSignalConsumer delegates to this Runnable correctly and invokes it only once.", "author": "idelpivnitskiy", "createdAt": "2020-04-01T23:28:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM4OTU2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM4OTg0Nw==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401389847", "bodyText": "You can use Mockito.verifyNoMoreInteractions(signalConsumer); to verify that no other methods are invoked on the mock.", "author": "NiteshKant", "createdAt": "2020-04-01T06:47:02Z", "path": "servicetalk-concurrent-api/src/testFixtures/java/io/servicetalk/concurrent/api/TerminalSignalConsumerMock.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import org.mockito.Mockito;\n+\n+import static org.mockito.AdditionalAnswers.delegatesTo;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+/**\n+ * Mocked {@link TerminalSignalConsumer} that helps to verify that only a single terminal method was invoked.\n+ */\n+public final class TerminalSignalConsumerMock implements TerminalSignalConsumer {\n+\n+    private Runnable runnable;\n+    private TerminalSignalConsumer signalConsumer;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public TerminalSignalConsumerMock() {\n+        runnable = Mockito.mock(Runnable.class);\n+        signalConsumer = Mockito.mock(TerminalSignalConsumer.class, delegatesTo(TerminalSignalConsumer.from(runnable)));\n+    }\n+\n+    @Override\n+    public void onComplete() {\n+        signalConsumer.onComplete();\n+    }\n+\n+    @Override\n+    public void onError(final Throwable throwable) {\n+        signalConsumer.onError(throwable);\n+    }\n+\n+    @Override\n+    public void onCancel() {\n+        signalConsumer.onCancel();\n+    }\n+\n+    /**\n+     * Verifies that only {@link TerminalSignalConsumer#onComplete()} was invoked and no other methods.\n+     */\n+    public void verifyOnComplete() {\n+        verify(signalConsumer).onComplete();\n+        verify(signalConsumer, never()).onError(any(Throwable.class));", "originalCommit": "d151a291a2c7cd5c106d4dee8d49c45b142b45fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM5MDUwOQ==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401390509", "bodyText": "I am not really sure about this class if you remove the Runnable reference and use Mockito.verifyNoMoreInteractions(signalConsumer);. It is more intuitive if the verification is done inside the test as opposed to inside a common method like this.", "author": "NiteshKant", "createdAt": "2020-04-01T06:48:36Z", "path": "servicetalk-concurrent-api/src/testFixtures/java/io/servicetalk/concurrent/api/TerminalSignalConsumerMock.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import org.mockito.Mockito;\n+\n+import static org.mockito.AdditionalAnswers.delegatesTo;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+/**\n+ * Mocked {@link TerminalSignalConsumer} that helps to verify that only a single terminal method was invoked.\n+ */\n+public final class TerminalSignalConsumerMock implements TerminalSignalConsumer {", "originalCommit": "d151a291a2c7cd5c106d4dee8d49c45b142b45fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2ODczMw==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401968733", "bodyText": "Agreed, if I will have a different TerminalSignalConsumer for Single it will have even less sense. Let me remove it.", "author": "idelpivnitskiy", "createdAt": "2020-04-01T23:30:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM5MDUwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2NjMxMg==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401466312", "bodyText": "nit: static import ?", "author": "normanmaurer", "createdAt": "2020-04-01T09:09:50Z", "path": "servicetalk-concurrent-api/src/testFixtures/java/io/servicetalk/concurrent/api/TerminalSignalConsumerMock.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import org.mockito.Mockito;\n+\n+import static org.mockito.AdditionalAnswers.delegatesTo;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+/**\n+ * Mocked {@link TerminalSignalConsumer} that helps to verify that only a single terminal method was invoked.\n+ */\n+public final class TerminalSignalConsumerMock implements TerminalSignalConsumer {\n+\n+    private Runnable runnable;\n+    private TerminalSignalConsumer signalConsumer;\n+\n+    /**\n+     * Creates a new instance.\n+     */\n+    public TerminalSignalConsumerMock() {\n+        runnable = Mockito.mock(Runnable.class);", "originalCommit": "d151a291a2c7cd5c106d4dee8d49c45b142b45fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2Njg4OQ==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401466889", "bodyText": "nit: final", "author": "normanmaurer", "createdAt": "2020-04-01T09:10:48Z", "path": "servicetalk-concurrent-api/src/test/java/io/servicetalk/concurrent/api/single/AbstractWhenFinallyTest.java", "diffHunk": "@@ -39,46 +38,41 @@\n     @Rule\n     public final ExpectedException thrown = ExpectedException.none();\n \n-    private Runnable doFinally;\n-\n-    @Before\n-    public void setUp() throws Exception {\n-        doFinally = mock(Runnable.class);\n-    }\n+    private TerminalSignalConsumerMock doFinally = new TerminalSignalConsumerMock();", "originalCommit": "d151a291a2c7cd5c106d4dee8d49c45b142b45fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2NzEwNQ==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401467105", "bodyText": "nit: final", "author": "normanmaurer", "createdAt": "2020-04-01T09:11:10Z", "path": "servicetalk-concurrent-api/src/test/java/io/servicetalk/concurrent/api/publisher/AbstractWhenFinallyTest.java", "diffHunk": "@@ -46,13 +45,8 @@\n \n     final TestPublisher<String> publisher = new TestPublisher<>();\n     final TestPublisherSubscriber<String> subscriber = new TestPublisherSubscriber<>();\n-    private Runnable doFinally;\n     final TestSubscription subscription = new TestSubscription();\n-\n-    @Before\n-    public void setUp() throws Exception {\n-        doFinally = mock(Runnable.class);\n-    }\n+    private TerminalSignalConsumerMock doFinally = new TerminalSignalConsumerMock();", "originalCommit": "d151a291a2c7cd5c106d4dee8d49c45b142b45fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2NzMzNw==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401467337", "bodyText": "nit: final", "author": "normanmaurer", "createdAt": "2020-04-01T09:11:36Z", "path": "servicetalk-concurrent-api/src/test/java/io/servicetalk/concurrent/api/completable/AbstractWhenFinallyTest.java", "diffHunk": "@@ -38,46 +37,41 @@\n     @Rule\n     public final ExpectedException thrown = ExpectedException.none();\n \n-    private Runnable doFinally;\n-\n-    @Before\n-    public void setUp() throws Exception {\n-        doFinally = mock(Runnable.class);\n-    }\n+    private TerminalSignalConsumerMock doFinally = new TerminalSignalConsumerMock();", "originalCommit": "d151a291a2c7cd5c106d4dee8d49c45b142b45fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2Nzc1Mg==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401467752", "bodyText": "deletage -> delegate (just as @NiteshKant also mentioned above)", "author": "normanmaurer", "createdAt": "2020-04-01T09:12:14Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/TerminalSignalConsumers.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+final class TerminalSignalConsumers implements TerminalSignalConsumer {\n+\n+    static final class RunnableTerminalSignalConsumer implements TerminalSignalConsumer {\n+\n+        private final Runnable onFinally;\n+\n+        RunnableTerminalSignalConsumer(Runnable onFinally) {\n+            this.onFinally = requireNonNull(onFinally);\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            onFinally.run();\n+        }\n+\n+        @Override\n+        public void onError(final Throwable throwable) {\n+            onFinally.run();\n+        }\n+\n+        @Override\n+        public void onCancel() {\n+            onFinally.run();\n+        }\n+    }\n+\n+    static final class CompleteTerminalSignalConsumer implements TerminalSignalConsumer {\n+\n+        private static final AtomicIntegerFieldUpdater<TerminalSignalConsumers.CompleteTerminalSignalConsumer>\n+                completeUpdater = AtomicIntegerFieldUpdater.newUpdater(\n+                        TerminalSignalConsumers.CompleteTerminalSignalConsumer.class, \"complete\");\n+        @SuppressWarnings(\"unused\")\n+        private volatile int complete;\n+\n+        private final TerminalSignalConsumer deletage;\n+\n+        CompleteTerminalSignalConsumer(final TerminalSignalConsumer deletage) {", "originalCommit": "d151a291a2c7cd5c106d4dee8d49c45b142b45fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2ODEwNA==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401468104", "bodyText": "nit: as this one is internal anyway you could also extend AtomicInteger directly.", "author": "normanmaurer", "createdAt": "2020-04-01T09:12:51Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/TerminalSignalConsumers.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+final class TerminalSignalConsumers implements TerminalSignalConsumer {\n+\n+    static final class RunnableTerminalSignalConsumer implements TerminalSignalConsumer {\n+\n+        private final Runnable onFinally;\n+\n+        RunnableTerminalSignalConsumer(Runnable onFinally) {\n+            this.onFinally = requireNonNull(onFinally);\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            onFinally.run();\n+        }\n+\n+        @Override\n+        public void onError(final Throwable throwable) {\n+            onFinally.run();\n+        }\n+\n+        @Override\n+        public void onCancel() {\n+            onFinally.run();\n+        }\n+    }\n+\n+    static final class CompleteTerminalSignalConsumer implements TerminalSignalConsumer {\n+\n+        private static final AtomicIntegerFieldUpdater<TerminalSignalConsumers.CompleteTerminalSignalConsumer>\n+                completeUpdater = AtomicIntegerFieldUpdater.newUpdater(\n+                        TerminalSignalConsumers.CompleteTerminalSignalConsumer.class, \"complete\");", "originalCommit": "d151a291a2c7cd5c106d4dee8d49c45b142b45fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2NjMwNg==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401966306", "bodyText": "Thanks for the tip. Didn't know AtomicInteger is not final.\nLet me use the pattern with AtomicIntegerFieldUpdater we have everywhere else in the codebase.", "author": "idelpivnitskiy", "createdAt": "2020-04-01T23:22:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2ODEwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2ODMzMw==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401468333", "bodyText": "nit: remove final to be consistent ?", "author": "normanmaurer", "createdAt": "2020-04-01T09:13:14Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/TerminalSignalConsumers.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+final class TerminalSignalConsumers implements TerminalSignalConsumer {\n+\n+    static final class RunnableTerminalSignalConsumer implements TerminalSignalConsumer {\n+\n+        private final Runnable onFinally;\n+\n+        RunnableTerminalSignalConsumer(Runnable onFinally) {\n+            this.onFinally = requireNonNull(onFinally);\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            onFinally.run();\n+        }\n+\n+        @Override\n+        public void onError(final Throwable throwable) {", "originalCommit": "d151a291a2c7cd5c106d4dee8d49c45b142b45fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2NzA5Nw==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401967097", "bodyText": "I will add final in RunnableTerminalSignalConsumer ctor to be consistent.", "author": "idelpivnitskiy", "createdAt": "2020-04-01T23:25:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ2ODMzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ3MDg5NQ==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r401470895", "bodyText": "@idelpivnitskiy cool... I didn't know you can use `{@code...} with multiple lines..", "author": "normanmaurer", "createdAt": "2020-04-01T09:17:28Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Completable.java", "diffHunk": "@@ -215,6 +215,47 @@ public final Completable whenFinally(Runnable doFinally) {\n         return afterFinally(doFinally);\n     }\n \n+    /**\n+     * Invokes an appropriate terminal signal of the {@link TerminalSignalConsumer}, when any of the following terminal\n+     * methods are called:\n+     * <ul>\n+     *     <li>{@link Subscriber#onComplete()} - invokes {@link TerminalSignalConsumer#onComplete()}</li>\n+     *     <li>{@link Subscriber#onError(Throwable)} - invokes {@link TerminalSignalConsumer#onError(Throwable)}</li>\n+     *     <li>{@link Cancellable#cancel()} - invokes {@link TerminalSignalConsumer#onCancel()}</li>\n+     * </ul>\n+     * for Subscriptions/{@link Subscriber}s of the returned {@link Completable}.\n+     * <p>\n+     * The order in which {@code whenFinally} will be invoked relative to the above methods is undefined. If you need\n+     * strict ordering see {@link #beforeFinally(TerminalSignalConsumer)} and\n+     * {@link #afterFinally(TerminalSignalConsumer)}.\n+     * <p>\n+     * From a sequential programming point of view this method is roughly equivalent to the following:\n+     * <pre>{@code", "originalCommit": "d151a291a2c7cd5c106d4dee8d49c45b142b45fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ee9980b3d0e67747572d7e08a258a8942a89a8cf", "url": "https://github.com/apple/servicetalk/commit/ee9980b3d0e67747572d7e08a258a8942a89a8cf", "message": "Address comments for code", "committedDate": "2020-04-01T23:26:08Z", "type": "commit"}, {"oid": "16a2c0865f01b76b2b44440550473daf985e01be", "url": "https://github.com/apple/servicetalk/commit/16a2c0865f01b76b2b44440550473daf985e01be", "message": "Address comments for tests", "committedDate": "2020-04-01T23:49:31Z", "type": "commit"}, {"oid": "2314f695613d42e53e3fe6b265b19ff484ceb821", "url": "https://github.com/apple/servicetalk/commit/2314f695613d42e53e3fe6b265b19ff484ceb821", "message": "Add Single.TerminalSignalConsumer", "committedDate": "2020-04-02T01:07:02Z", "type": "commit"}, {"oid": "3f1d3351ad29d64c156cc8a272b740c3488b84e0", "url": "https://github.com/apple/servicetalk/commit/3f1d3351ad29d64c156cc8a272b740c3488b84e0", "message": "Remove AtomicTerminalSignalConsumer", "committedDate": "2020-04-02T01:20:40Z", "type": "commit"}, {"oid": "c37633fe6522f6317506c33c6156cef5f2007c8f", "url": "https://github.com/apple/servicetalk/commit/c37633fe6522f6317506c33c6156cef5f2007c8f", "message": "fix checkstyle", "committedDate": "2020-04-02T05:08:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM4OTgwOQ==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r402389809", "bodyText": "(pre-existing): BeforeCancellable -> consider renaming to ComposedCancellable or as the \"before\" naming convention clashes with the different operators that use is (e.g. this is an After operator that uses a Before class).", "author": "Scottmitch", "createdAt": "2020-04-02T15:09:20Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/AfterFinallyCompletable.java", "diffHunk": "@@ -23,43 +23,49 @@\n \n final class AfterFinallyCompletable extends AbstractSynchronousCompletableOperator {\n \n-    private final Runnable runnable;\n+    private final TerminalSignalConsumer doFinally;\n \n-    AfterFinallyCompletable(Completable original, Runnable runnable, Executor executor) {\n+    AfterFinallyCompletable(Completable original, TerminalSignalConsumer doFinally, Executor executor) {\n         super(original, executor);\n-        this.runnable = requireNonNull(runnable);\n+        this.doFinally = requireNonNull(doFinally);\n     }\n \n     @Override\n     public Subscriber apply(final Subscriber subscriber) {\n-        return new AfterFinallyCompletableSubscriber(subscriber, runnable);\n+        return new AfterFinallyCompletableSubscriber(subscriber, doFinally);\n     }\n \n     private static final class AfterFinallyCompletableSubscriber implements Subscriber {\n         private final Subscriber original;\n-        private final Runnable runnable;\n+        private final TerminalSignalConsumer doFinally;\n \n-        private static final AtomicIntegerFieldUpdater<AfterFinallyCompletableSubscriber> completeUpdater =\n-                AtomicIntegerFieldUpdater.newUpdater(AfterFinallyCompletableSubscriber.class, \"complete\");\n+        private static final AtomicIntegerFieldUpdater<AfterFinallyCompletableSubscriber> doneUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(AfterFinallyCompletableSubscriber.class, \"done\");\n         @SuppressWarnings(\"unused\")\n-        private volatile int complete;\n+        private volatile int done;\n \n-        AfterFinallyCompletableSubscriber(Subscriber original, Runnable runnable) {\n+        AfterFinallyCompletableSubscriber(Subscriber original, TerminalSignalConsumer doFinally) {\n             this.original = original;\n-            this.runnable = runnable;\n+            this.doFinally = doFinally;\n         }\n \n         @Override\n         public void onSubscribe(Cancellable originalCancellable) {\n-            original.onSubscribe(new BeforeCancellable(originalCancellable, this::afterFinally));\n+            original.onSubscribe(new BeforeCancellable(originalCancellable, () -> {", "originalCommit": "c37633fe6522f6317506c33c6156cef5f2007c8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM5NDYzOQ==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r402394639", "bodyText": "consider moving this new code down in the class as this interface isn't a central feature of the outer class.", "author": "Scottmitch", "createdAt": "2020-04-02T15:15:34Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Single.java", "diffHunk": "@@ -64,6 +64,76 @@\n  * @param <T> Type of the result of the single.\n  */\n public abstract class Single<T> {\n+\n+    /**\n+     * Callback interface on which only a single method is ever called matching the terminal outcome of the associated\n+     * {@link Single} and {@link Cancellable}.\n+     *\n+     * @param <T> Type of the result of the {@link Single}.\n+     */\n+    public interface TerminalSignalConsumer<T> {", "originalCommit": "c37633fe6522f6317506c33c6156cef5f2007c8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQyMDc2Nw==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r402420767", "bodyText": "if we still expose the Runnable variants can we hide TerminalSignalConsumer.from for now?", "author": "Scottmitch", "createdAt": "2020-04-02T15:51:02Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Single.java", "diffHunk": "@@ -670,6 +780,45 @@ public final Completable flatMapCompletable(Function<? super T, ? extends Comple\n      * @return The new {@link Single}.\n      */\n     public final Single<T> beforeFinally(Runnable doFinally) {\n+        return beforeFinally(TerminalSignalConsumer.from(doFinally));", "originalCommit": "c37633fe6522f6317506c33c6156cef5f2007c8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "03b35954c0f2759dd02b5885a0bf1c2df2de51b4", "url": "https://github.com/apple/servicetalk/commit/03b35954c0f2759dd02b5885a0bf1c2df2de51b4", "message": "rename: BeforeCancellable -> ComposedCancellable", "committedDate": "2020-04-02T17:48:23Z", "type": "commit"}, {"oid": "6fd39a0faab651d3921cf0dd3f83f43de746a293", "url": "https://github.com/apple/servicetalk/commit/6fd39a0faab651d3921cf0dd3f83f43de746a293", "message": "Move Single.TerminalSignalConsumer at the end of Single class", "committedDate": "2020-04-02T17:49:23Z", "type": "commit"}, {"oid": "d1d9c422ccfc839f7cae8b6202bb8768e8dd2979", "url": "https://github.com/apple/servicetalk/commit/d1d9c422ccfc839f7cae8b6202bb8768e8dd2979", "message": "Remove TerminalSignalConsumer.from(Runnable)", "committedDate": "2020-04-02T22:21:53Z", "type": "commit"}, {"oid": "ce82326031595fd73d5d3be54541f4b84d55fe9a", "url": "https://github.com/apple/servicetalk/commit/ce82326031595fd73d5d3be54541f4b84d55fe9a", "message": "Merge remote-tracking branch 'upstream/master' into whenFinally-TSC", "committedDate": "2020-04-03T01:05:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIzNjU0MQ==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r403236541", "bodyText": "These documentation change also need to be made for all other *Finally methods here that take a TerminalSignalConsumer.", "author": "NiteshKant", "createdAt": "2020-04-03T18:42:53Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Completable.java", "diffHunk": "@@ -757,8 +798,48 @@ public final Completable beforeCancel(Runnable onCancel) {\n      * </ul>\n      * for Subscriptions/{@link Subscriber}s of the returned {@link Completable}. <strong>MUST NOT</strong> throw.\n      * @return The new {@link Completable}.\n+     *\n+     * @see <a href=\"http://reactivex.io/documentation/operators/do.html\">ReactiveX do operator.</a>\n      */\n     public final Completable beforeFinally(Runnable doFinally) {\n+        return beforeFinally(new RunnableTerminalSignalConsumer(doFinally));\n+    }\n+\n+    /**\n+     * Invokes the corresponding method on {@code beforeFinally} {@link TerminalSignalConsumer} argument\n+     * <strong>before</strong> any of the following terminal methods are called:\n+     * <ul>\n+     *     <li>{@link Subscriber#onComplete()} - invokes {@link TerminalSignalConsumer#onComplete()}</li>\n+     *     <li>{@link Subscriber#onError(Throwable)} - invokes {@link TerminalSignalConsumer#onError(Throwable)}</li>\n+     *     <li>{@link Cancellable#cancel()} - invokes {@link TerminalSignalConsumer#cancel()}</li>\n+     * </ul>\n+     * for Subscriptions/{@link Subscriber}s of the returned {@link Completable}.\n+     * <p>\n+     * From a sequential programming point of view this method is roughly equivalent to the following:\n+     * <pre>{@code\n+     *  try {\n+     *      resultOfThisCompletable();\n+     *  } catch(Throwable t) {\n+     *      doFinally.onError(t);", "originalCommit": "ce82326031595fd73d5d3be54541f4b84d55fe9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM0NTcxNA==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r403345714", "bodyText": "I used this pattern for beforeFinally(TerminalSignalConsumer) for Completable, Single, and Publisher as it represents logic of BeforeFinallyCompletableSubscriber.\nwhenFinally(TerminalSignalConsumer) and afterFinally(TerminalSignalConsumer) use another control flow, like in AfterFinallyCompletableSubscriber:\n@Override\npublic void onComplete() {\n    try {\n        original.onComplete();\n    } finally {\n        doFinally.onComplete();\n    }\n}\nJavadoc for Completable.afterFinally(TerminalSignalConsumer) written in the same way:\n     * <pre>{@code\n     *  try {\n     *      resultOfThisCompletable();\n     *  } finally {\n     *      nextOperation(); // Maybe notifying of cancellation, or termination\n     *      doFinally.onTerminalSignal(); // Invokes the corresponding terminal signal\n     *  }\n     * }</pre>\n\nWe do not try-catch for afterFinally/whenFinally and always touch TerminalSignalConsumer in finally block.\nI use doFinally.onTerminalSignal() instead of doFinally.onCompete() because the same patters works for onError and cancel.\nCan you please clarify how the javadoc for afterFinally/whenFinally should change?", "author": "idelpivnitskiy", "createdAt": "2020-04-03T21:29:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIzNjU0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM5MjQ1MQ==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r403392451", "bodyText": "Discussed offline, the control flow in javadoc is not related to the actual implementation of Subscriber and should represent a similar behavior for sequential programming. Updated.", "author": "idelpivnitskiy", "createdAt": "2020-04-04T00:13:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIzNjU0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI0OTU3MQ==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r403249571", "bodyText": "Same comment as Completable, please follow the example there to correctly represent control flow.", "author": "NiteshKant", "createdAt": "2020-04-03T19:01:47Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Publisher.java", "diffHunk": "@@ -697,6 +697,47 @@ public final Completable flatMapCompletableDelayError(Function<? super T, ? exte\n         return afterFinally(doFinally);\n     }\n \n+    /**\n+     * Invokes the corresponding method on {@code whenFinally} {@link TerminalSignalConsumer} argument when any of the\n+     * following terminal methods are called:\n+     * <ul>\n+     *     <li>{@link Subscriber#onComplete()} - invokes {@link TerminalSignalConsumer#onComplete()}</li>\n+     *     <li>{@link Subscriber#onError(Throwable)} - invokes {@link TerminalSignalConsumer#onError(Throwable)}</li>\n+     *     <li>{@link Subscription#cancel()} - invokes {@link TerminalSignalConsumer#cancel()}</li>\n+     * </ul>\n+     * for {@link Subscription}s/{@link Subscriber}s of the returned {@link Publisher}.\n+     * <p>\n+     * The order in which {@code whenFinally} will be invoked relative to the above methods is undefined. If you need\n+     * strict ordering see {@link #beforeFinally(TerminalSignalConsumer)} and\n+     * {@link #afterFinally(TerminalSignalConsumer)}.\n+     * <p>\n+     * From a sequential programming point of view this method is roughly equivalent to the following:\n+     * <pre>{@code\n+     *  try {\n+     *      List<T> results = resultOfThisPublisher();\n+     *  } finally {\n+     *      // NOTE: The order of operations here is not guaranteed by this method!\n+     *      nextOperation(); // Maybe notifying of cancellation, or termination\n+     *      doFinally.onTerminalSignal(); // Invokes the corresponding terminal signal", "originalCommit": "ce82326031595fd73d5d3be54541f4b84d55fe9a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI0OTgyNQ==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r403249825", "bodyText": "Same comment as Completable, please follow the example there to correctly represent control flow.", "author": "NiteshKant", "createdAt": "2020-04-03T19:02:07Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Single.java", "diffHunk": "@@ -294,6 +295,46 @@ public final Completable flatMapCompletable(Function<? super T, ? extends Comple\n         return afterFinally(doFinally);\n     }\n \n+    /**\n+     * Invokes the corresponding method on {@code whenFinally} {@link TerminalSignalConsumer} argument when any of the\n+     * following terminal methods are called:\n+     * <ul>\n+     *     <li>{@link Subscriber#onSuccess(Object)} - invokes {@link TerminalSignalConsumer#onSuccess(Object)}</li>\n+     *     <li>{@link Subscriber#onError(Throwable)} - invokes {@link TerminalSignalConsumer#onError(Throwable)}</li>\n+     *     <li>{@link Cancellable#cancel()} - invokes {@link TerminalSignalConsumer#cancel()}</li>\n+     * </ul>\n+     * for Subscriptions/{@link Subscriber}s of the returned {@link Single}.\n+     * <p>\n+     * The order in which {@code whenFinally} will be invoked relative to the above methods is undefined. If you need\n+     * strict ordering see {@link #beforeFinally(TerminalSignalConsumer)} and\n+     * {@link #afterFinally(TerminalSignalConsumer)}.\n+     * <p>\n+     * From a sequential programming point of view this method is roughly equivalent to the following:\n+     * <pre>{@code\n+     *  try {\n+     *      T result = resultOfThisSingle();\n+     *  } finally {\n+     *      // NOTE: The order of operations here is not guaranteed by this method!\n+     *      nextOperation(); // Maybe notifying of cancellation, or termination\n+     *      doFinally.onTerminalSignal(); // Invokes the corresponding terminal signal", "originalCommit": "ce82326031595fd73d5d3be54541f4b84d55fe9a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI1MzAwMg==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r403253002", "bodyText": "This seems wrong as Subscription does not have an onError()", "author": "NiteshKant", "createdAt": "2020-04-03T19:07:23Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/TerminalSignalConsumer.java", "diffHunk": "@@ -16,28 +16,25 @@\n package io.servicetalk.concurrent.api;\n \n /**\n- * Callback interface on which only a single method is ever called matching the terminal outcome of the associated\n- * {@code Source} and {@code Subscription}.\n+ * Callback interface for {@link Publisher} and {@link Completable} on which only a single method is ever called\n+ * matching the terminal outcome of the associated {@code Source} and {@code Subscription}.\n  */\n public interface TerminalSignalConsumer {\n \n     /**\n      * Callback to signal completion of the {@code Subscription} for this {@code Subscriber}.\n      */\n-    default void onComplete() {\n-    }\n+    void onComplete();\n \n     /**\n-     * Callback to receive an {@link Throwable error} for this {@code Subscriber}.\n+     * Callback to signal an {@link Throwable error} of the {@code Subscription} for this {@code Subscriber}.", "originalCommit": "ce82326031595fd73d5d3be54541f4b84d55fe9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM0MTQ2OQ==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r403341469", "bodyText": "I tried to follow the pattern we have above for onComplete() to make them consistent:\n\nCallback to signal completion of the {@code Subscription} for this {@code Subscriber}.\n\nOnly Subscriber has onComplete/onError but it owns the Subscription for the source. Should we change Subscription to Source in both places?\n\nCallback to signal completion of the {@code Source} for this {@code Subscriber}.\nCallback to signal {@link Throwable error} of the {@code Source} for this {@code Subscriber}.", "author": "idelpivnitskiy", "createdAt": "2020-04-03T21:19:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI1MzAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM2NjkwNw==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r403366907", "bodyText": "Oh didn't notice the above usage, its a :dumpster fire: \ud83d\ude04\n/**\n * A contract that provides discrete callbacks for various ways in which a\n * {@link PublisherSource.Subscriber} or a {@link CompletableSource.Subscriber} can terminate.\n */\npublic interface TerminalSignalConsumer {\n\n    /**\n     * Callback to indicate termination via {@link PublisherSource.Subscriber#onComplete()} or\n     * {@link CompletableSource.Subscriber#onComplete()}.\n     */\n    default void onComplete() {\n    }\n\n    /**\n     * Callback to indicate termination via {@link PublisherSource.Subscriber#onError(Throwable)} or\n     * {@link CompletableSource.Subscriber#onError(Throwable)}.\n     *\n     * @param throwable the {@link Exception} observed.\n     */\n    default void onError(Throwable throwable) {\n    }\n\n    /**\n     * Callback to indicate termination via {@link Cancellable#cancel()}.\n     */\n    default void onCancel() {\n    }\n}\nNote that I have removed the \"exactly once semantics\" from the doc here as it is more appropriate in the operators that use this (and it is dependent on a subscribe call).\nAlso, use similar language on the Single.TerminalSignalConsumer", "author": "NiteshKant", "createdAt": "2020-04-03T22:30:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI1MzAwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI1MzI3NA==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r403253274", "bodyText": "Perhaps just convert Subscription to Cancellable as Subscription extends Cancellable", "author": "NiteshKant", "createdAt": "2020-04-03T19:07:54Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/TerminalSignalConsumer.java", "diffHunk": "@@ -16,28 +16,25 @@\n package io.servicetalk.concurrent.api;\n \n /**\n- * Callback interface on which only a single method is ever called matching the terminal outcome of the associated\n- * {@code Source} and {@code Subscription}.\n+ * Callback interface for {@link Publisher} and {@link Completable} on which only a single method is ever called\n+ * matching the terminal outcome of the associated {@code Source} and {@code Subscription}.\n  */\n public interface TerminalSignalConsumer {\n \n     /**\n      * Callback to signal completion of the {@code Subscription} for this {@code Subscriber}.\n      */\n-    default void onComplete() {\n-    }\n+    void onComplete();\n \n     /**\n-     * Callback to receive an {@link Throwable error} for this {@code Subscriber}.\n+     * Callback to signal an {@link Throwable error} of the {@code Subscription} for this {@code Subscriber}.\n      *\n-     * @param throwable the {@link Exception} observed.\n+     * @param throwable the observed {@link Throwable}.\n      */\n-    default void onError(Throwable throwable) {\n-    }\n+    void onError(Throwable throwable);\n \n     /**\n-     * Callback to signal cancellation of the {@code Subscription} for this {@code Subscriber}.\n+     * Callback to signal cancellation of the {@code Subscription} by this {@code Subscriber}.", "originalCommit": "ce82326031595fd73d5d3be54541f4b84d55fe9a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM2NzUzNw==", "url": "https://github.com/apple/servicetalk/pull/990#discussion_r403367537", "bodyText": "(Same suggestion for Publisher and Completable methods)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param doFinally an appropriate method of {@link TerminalSignalConsumer} is invoked exactly once, when any of the\n          \n          \n            \n                 * @param doFinally For each subscribe of the returned {@link Single}, at most one method of this {@link TerminalSignalConsumer} will be invoked.\n          \n      \n    \n    \n  \n\nI think we can remove the below method mappings now as I have suggested to add them to TerminalSignalConsumer.", "author": "NiteshKant", "createdAt": "2020-04-03T22:32:49Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Single.java", "diffHunk": "@@ -294,6 +295,46 @@ public final Completable flatMapCompletable(Function<? super T, ? extends Comple\n         return afterFinally(doFinally);\n     }\n \n+    /**\n+     * Invokes the corresponding method on {@code whenFinally} {@link TerminalSignalConsumer} argument when any of the\n+     * following terminal methods are called:\n+     * <ul>\n+     *     <li>{@link Subscriber#onSuccess(Object)} - invokes {@link TerminalSignalConsumer#onSuccess(Object)}</li>\n+     *     <li>{@link Subscriber#onError(Throwable)} - invokes {@link TerminalSignalConsumer#onError(Throwable)}</li>\n+     *     <li>{@link Cancellable#cancel()} - invokes {@link TerminalSignalConsumer#cancel()}</li>\n+     * </ul>\n+     * for Subscriptions/{@link Subscriber}s of the returned {@link Single}.\n+     * <p>\n+     * The order in which {@code whenFinally} will be invoked relative to the above methods is undefined. If you need\n+     * strict ordering see {@link #beforeFinally(TerminalSignalConsumer)} and\n+     * {@link #afterFinally(TerminalSignalConsumer)}.\n+     * <p>\n+     * From a sequential programming point of view this method is roughly equivalent to the following:\n+     * <pre>{@code\n+     *  try {\n+     *      T result = resultOfThisSingle();\n+     *  } finally {\n+     *      // NOTE: The order of operations here is not guaranteed by this method!\n+     *      nextOperation(); // Maybe notifying of cancellation, or termination\n+     *      doFinally.onTerminalSignal(); // Invokes the corresponding terminal signal\n+     *  }\n+     * }</pre>\n+     * @param doFinally an appropriate method of {@link TerminalSignalConsumer} is invoked exactly once, when any of the", "originalCommit": "ce82326031595fd73d5d3be54541f4b84d55fe9a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d62fa96888c4d24a2c2837375da65143397932ac", "url": "https://github.com/apple/servicetalk/commit/d62fa96888c4d24a2c2837375da65143397932ac", "message": "Address review comments for javadoc", "committedDate": "2020-04-03T23:13:14Z", "type": "commit"}, {"oid": "8fe68014c85bef69704abb56b5753974ec92cfa5", "url": "https://github.com/apple/servicetalk/commit/8fe68014c85bef69704abb56b5753974ec92cfa5", "message": "fix control flow for whenFinally(TSC) javadoc", "committedDate": "2020-04-04T00:12:04Z", "type": "commit"}]}