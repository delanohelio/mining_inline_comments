{"pr_number": 1221, "pr_title": "[Retry|Repeat]Strategies add jitter delta methods ", "pr_createdAt": "2020-11-18T22:26:19Z", "pr_url": "https://github.com/apple/servicetalk/pull/1221", "timeline": [{"oid": "07ba14fa05caf932f90c9dae66f66aceb9ab69de", "url": "https://github.com/apple/servicetalk/commit/07ba14fa05caf932f90c9dae66f66aceb9ab69de", "message": "[Retry|Repeat]Strategies add jitter delta methods\n\nMotivation:\n[Retry|Repeat]Strategies provides utility methods with strategies that\ncan apply a jitter to a delay scheme (e.g. fixed, exponential). However\nwe currently only offer \"Full Jitter\" variants which vary delay in the\nrange [0, max delay]. This works well to maximize variance of client\nrequest arrival for exclusive resource operations (e.g. all clients\nattempt to lock the same row in a DB) but may not be optimal in cases\nwhich don't require mutual exclusion and instead value more predictable\nand faster repeat intervals.\nthe jitter is applied in a non conventional scheme which allows the\ndelay to vary from [0, max delay], instead of [delay-jitter,\ndelay+jitter].\n\nModifications:\n- [Retry|Repeat]Strategies rename the existing jitter methods to\n\"FullJitter\"\n- [Retry|Repeat]Strategies now include an alternative jitter method\nwhich applies a delta to the base distribution\n[delay-jitter, delay+jitter].\n\nResult:\nMore options to apply jitter in [Retry|Repeat]Strategies", "committedDate": "2020-11-19T02:29:13Z", "type": "forcePushed"}, {"oid": "d15bc457cad3fe6bd508819c2d579e7bbfcefa8f", "url": "https://github.com/apple/servicetalk/commit/d15bc457cad3fe6bd508819c2d579e7bbfcefa8f", "message": "[Retry|Repeat]Strategies add jitter delta methods\n\nMotivation:\n[Retry|Repeat]Strategies provides utility methods with strategies that\ncan apply a jitter to a delay scheme (e.g. fixed, exponential). However\nwe currently only offer \"Full Jitter\" variants which vary delay in the\nrange [0, max delay]. This works well to maximize variance of client\nrequest arrival for exclusive resource operations (e.g. all clients\nattempt to lock the same row in a DB) but may not be optimal in cases\nwhich don't require mutual exclusion and instead value more predictable\nand faster repeat intervals.\nthe jitter is applied in a non conventional scheme which allows the\ndelay to vary from [0, max delay], instead of [delay-jitter,\ndelay+jitter].\n\nModifications:\n- [Retry|Repeat]Strategies rename the existing jitter methods to\n\"FullJitter\"\n- [Retry|Repeat]Strategies now include an alternative jitter method\n\"DeltaJitter\" which applies a delta to the base distribution\n[delay-jitter, delay+jitter].\n\nResult:\nMore options to apply jitter in [Retry|Repeat]Strategies", "committedDate": "2020-11-19T02:37:24Z", "type": "forcePushed"}, {"oid": "80f7a4a7fb5a92a37e96a06304c7b4a7ab53ae24", "url": "https://github.com/apple/servicetalk/commit/80f7a4a7fb5a92a37e96a06304c7b4a7ab53ae24", "message": "[Retry|Repeat]Strategies add jitter delta methods\n\nMotivation:\n[Retry|Repeat]Strategies provides utility methods with strategies that\ncan apply a jitter to a delay scheme (e.g. fixed, exponential). However\nwe currently only offer \"Full Jitter\" variants which vary delay in the\nrange [0, max delay]. This works well to maximize variance of client\nrequest arrival for exclusive resource operations (e.g. all clients\nattempt to lock the same row in a DB) but may not be optimal in cases\nwhich don't require mutual exclusion and instead value more predictable\nand faster repeat intervals.\nthe jitter is applied in a non conventional scheme which allows the\ndelay to vary from [0, max delay], instead of [delay-jitter,\ndelay+jitter].\n\nModifications:\n- [Retry|Repeat]Strategies rename the existing jitter methods to\n\"FullJitter\"\n- [Retry|Repeat]Strategies now include an alternative jitter method\n\"DeltaJitter\" which applies a delta to the base distribution\n[delay-jitter, delay+jitter].\n\nResult:\nMore options to apply jitter in [Retry|Repeat]Strategies", "committedDate": "2020-11-19T02:56:27Z", "type": "forcePushed"}, {"oid": "45af3b065570ed7e45c29d78e86f6e64a8845a87", "url": "https://github.com/apple/servicetalk/commit/45af3b065570ed7e45c29d78e86f6e64a8845a87", "message": "[Retry|Repeat]Strategies add jitter delta methods\n\nMotivation:\n[Retry|Repeat]Strategies provides utility methods with strategies that\ncan apply a jitter to a delay scheme (e.g. fixed, exponential). However\nwe currently only offer \"Full Jitter\" variants which vary delay in the\nrange [0, max delay]. This works well to maximize variance of client\nrequest arrival for exclusive resource operations (e.g. all clients\nattempt to lock the same row in a DB) but may not be optimal in cases\nwhich don't require mutual exclusion and instead value more predictable\nand faster repeat intervals.\nthe jitter is applied in a non conventional scheme which allows the\ndelay to vary from [0, max delay], instead of [delay-jitter,\ndelay+jitter].\n\nModifications:\n- [Retry|Repeat]Strategies rename the existing jitter methods to\n\"FullJitter\"\n- [Retry|Repeat]Strategies now include an alternative jitter method\n\"DeltaJitter\" which applies a delta to the base distribution\n[delay-jitter, delay+jitter].\n\nResult:\nMore options to apply jitter in [Retry|Repeat]Strategies", "committedDate": "2020-11-19T03:28:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzNDQwNw==", "url": "https://github.com/apple/servicetalk/pull/1221#discussion_r527134407", "bodyText": "nit: shifted javadoc line", "author": "idelpivnitskiy", "createdAt": "2020-11-19T19:14:20Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/RetryStrategies.java", "diffHunk": "@@ -53,19 +55,14 @@ private RetryStrategies() {\n         requireNonNull(timerExecutor);\n         requireNonNull(causeFilter);\n         final long delayNanos = delay.toNanos();\n-        return (retryCount, cause) -> {\n-            if (retryCount > maxRetries || !causeFilter.test(cause)) {\n-                return failed(cause);\n-            }\n-            return timerExecutor.timer(delayNanos, NANOSECONDS);\n-        };\n+        return (retryCount, cause) -> retryCount <= maxRetries && causeFilter.test(cause) ?\n+                timerExecutor.timer(delayNanos, NANOSECONDS) : failed(cause);\n     }\n \n     /**\n      * Creates a new retry function that adds the passed constant {@link Duration} as a delay between retries.\n      * This additionally adds a \"Full Jitter\" for the backoff as described\n-     * <a href=\"https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/\">here</a>.\n-     *\n+     *      * <a href=\"https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter\">here</a>.", "originalCommit": "45af3b065570ed7e45c29d78e86f6e64a8845a87", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE0NDcxMQ==", "url": "https://github.com/apple/servicetalk/pull/1221#discussion_r527144711", "bodyText": "Consider splitting in 2 different checks and clarify passed/expected values in the exception messages:\nif (jitterNanos > delayNanos) {\n    throw new IllegalArgumentException(\"jitter (\" + jitterNanos + \"ns) cannot be greater than delay (\" + delayNanos + \"ns)\");\n}\nif (Long.MAX_VALUE - delayNanos < jitterNanos) {\n    throw new IllegalArgumentException(\"jitter (\" + jitterNanos + \"ns) would result in Long overflow for the passed delay (\" + delayNanos + \"ns)\");\n}\nIt will help users understand why values are incorrect.", "author": "idelpivnitskiy", "createdAt": "2020-11-19T19:30:49Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/RetryStrategies.java", "diffHunk": "@@ -75,22 +72,79 @@ private RetryStrategies() {\n      * a {@link Completable} that terminates successfully when the source has to be retried or terminates with error\n      * if the source should not be retried for the passed {@link Throwable}\n      */\n-    public static BiIntFunction<Throwable, Completable> retryWithConstantBackoffAndJitter(\n+    public static BiIntFunction<Throwable, Completable> retryWithConstantBackoffFullJitter(\n             final int maxRetries,\n             final Predicate<Throwable> causeFilter,\n             final Duration delay,\n             final Executor timerExecutor) {\n+        checkMaxRetries(maxRetries);\n+        requireNonNull(timerExecutor);\n+        requireNonNull(causeFilter);\n+        final long delayNanos = delay.toNanos();\n+        return (retryCount, cause) -> retryCount <= maxRetries && causeFilter.test(cause) ?\n+                timerExecutor.timer(current().nextLong(0, delayNanos), NANOSECONDS) : failed(cause);\n+    }\n \n+    /**\n+     * Creates a new retry function that adds the passed constant {@link Duration} as a delay between retries.\n+     *\n+     * @param maxRetries Maximum number of allowed retries, after which the returned {@link BiIntFunction} will return\n+     * a failed {@link Completable} with the passed {@link Throwable} as the cause\n+     * @param causeFilter A {@link Predicate} that selects whether a {@link Throwable} cause should be retried\n+     * @param delay Constant {@link Duration} of delay between retries\n+     * @param jitter The jitter to apply to {@code delay} on each retry.\n+     * @param timerExecutor {@link Executor} to be used to schedule timers for backoff\n+     * @return A {@link BiIntFunction} to be used for retries which given a retry count and a {@link Throwable} returns\n+     * a {@link Completable} that terminates successfully when the source has to be retried or terminates with error\n+     * if the source should not be retried for the passed {@link Throwable}\n+     */\n+    public static BiIntFunction<Throwable, Completable> retryWithConstantBackoffDeltaJitter(\n+            final int maxRetries,\n+            final Predicate<Throwable> causeFilter,\n+            final Duration delay,\n+            final Duration jitter,\n+            final Executor timerExecutor) {\n         checkMaxRetries(maxRetries);\n         requireNonNull(timerExecutor);\n         requireNonNull(causeFilter);\n         final long delayNanos = delay.toNanos();\n-        return (retryCount, cause) -> {\n-            if (retryCount > maxRetries || !causeFilter.test(cause)) {\n-                return failed(cause);\n-            }\n-            return timerExecutor.timer(ThreadLocalRandom.current().nextLong(0, delayNanos), NANOSECONDS);\n-        };\n+        final long jitterNanos = jitter.toNanos();\n+        if (jitterNanos > delayNanos || Long.MAX_VALUE - delayNanos < jitterNanos) {\n+            throw new IllegalArgumentException(\"jitter would result in [under|over]flow\");", "originalCommit": "45af3b065570ed7e45c29d78e86f6e64a8845a87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE3MTY5Ng==", "url": "https://github.com/apple/servicetalk/pull/1221#discussion_r527171696", "bodyText": "I'll extract the check into a common method and add the delay/jitter for additional context.", "author": "Scottmitch", "createdAt": "2020-11-19T20:18:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE0NDcxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE0NjY0MQ==", "url": "https://github.com/apple/servicetalk/pull/1221#discussion_r527146641", "bodyText": "All other methods always have maxRetries as the first argument. Not sure need an overload without maxRetries, because having it helps users think about it. If they are sure they want to retry indefinitely, they can pass Long.MAX_VALUE, which will work for 100s of years in production.", "author": "idelpivnitskiy", "createdAt": "2020-11-19T19:34:09Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/RetryStrategies.java", "diffHunk": "@@ -75,22 +72,79 @@ private RetryStrategies() {\n      * a {@link Completable} that terminates successfully when the source has to be retried or terminates with error\n      * if the source should not be retried for the passed {@link Throwable}\n      */\n-    public static BiIntFunction<Throwable, Completable> retryWithConstantBackoffAndJitter(\n+    public static BiIntFunction<Throwable, Completable> retryWithConstantBackoffFullJitter(\n             final int maxRetries,\n             final Predicate<Throwable> causeFilter,\n             final Duration delay,\n             final Executor timerExecutor) {\n+        checkMaxRetries(maxRetries);\n+        requireNonNull(timerExecutor);\n+        requireNonNull(causeFilter);\n+        final long delayNanos = delay.toNanos();\n+        return (retryCount, cause) -> retryCount <= maxRetries && causeFilter.test(cause) ?\n+                timerExecutor.timer(current().nextLong(0, delayNanos), NANOSECONDS) : failed(cause);\n+    }\n \n+    /**\n+     * Creates a new retry function that adds the passed constant {@link Duration} as a delay between retries.\n+     *\n+     * @param maxRetries Maximum number of allowed retries, after which the returned {@link BiIntFunction} will return\n+     * a failed {@link Completable} with the passed {@link Throwable} as the cause\n+     * @param causeFilter A {@link Predicate} that selects whether a {@link Throwable} cause should be retried\n+     * @param delay Constant {@link Duration} of delay between retries\n+     * @param jitter The jitter to apply to {@code delay} on each retry.\n+     * @param timerExecutor {@link Executor} to be used to schedule timers for backoff\n+     * @return A {@link BiIntFunction} to be used for retries which given a retry count and a {@link Throwable} returns\n+     * a {@link Completable} that terminates successfully when the source has to be retried or terminates with error\n+     * if the source should not be retried for the passed {@link Throwable}\n+     */\n+    public static BiIntFunction<Throwable, Completable> retryWithConstantBackoffDeltaJitter(\n+            final int maxRetries,\n+            final Predicate<Throwable> causeFilter,\n+            final Duration delay,\n+            final Duration jitter,\n+            final Executor timerExecutor) {\n         checkMaxRetries(maxRetries);\n         requireNonNull(timerExecutor);\n         requireNonNull(causeFilter);\n         final long delayNanos = delay.toNanos();\n-        return (retryCount, cause) -> {\n-            if (retryCount > maxRetries || !causeFilter.test(cause)) {\n-                return failed(cause);\n-            }\n-            return timerExecutor.timer(ThreadLocalRandom.current().nextLong(0, delayNanos), NANOSECONDS);\n-        };\n+        final long jitterNanos = jitter.toNanos();\n+        if (jitterNanos > delayNanos || Long.MAX_VALUE - delayNanos < jitterNanos) {\n+            throw new IllegalArgumentException(\"jitter would result in [under|over]flow\");\n+        }\n+        final long lowerBound = delayNanos - jitterNanos;\n+        final long upperBound = delayNanos + jitterNanos;\n+        return (retryCount, cause) -> retryCount <= maxRetries && causeFilter.test(cause) ?\n+                timerExecutor.timer(current().nextLong(lowerBound, upperBound), NANOSECONDS) : failed(cause);\n+    }\n+\n+    /**\n+     * Creates a new retry function that adds the passed constant {@link Duration} as a delay between retries.\n+     *\n+     * @param causeFilter A {@link Predicate} that selects whether a {@link Throwable} cause should be retried\n+     * @param delay Constant {@link Duration} of delay between retries\n+     * @param jitter The jitter to apply to {@code delay} on each retry.\n+     * @param timerExecutor {@link Executor} to be used to schedule timers for backoff\n+     * @return A {@link BiIntFunction} to be used for retries which given a retry count and a {@link Throwable} returns\n+     * a {@link Completable} that terminates successfully when the source has to be retried or terminates with error\n+     * if the source should not be retried for the passed {@link Throwable}\n+     */\n+    public static BiIntFunction<Throwable, Completable> retryWithConstantBackoffDeltaJitter(", "originalCommit": "45af3b065570ed7e45c29d78e86f6e64a8845a87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE3Mzg0NQ==", "url": "https://github.com/apple/servicetalk/pull/1221#discussion_r527173845", "bodyText": "we have a few cases were the intention is to retry indefinitely (e.g. until cancelled). I don't think we can infer users also don't have similar use cases, and if they do need a limit they can use the corresponding method.", "author": "Scottmitch", "createdAt": "2020-11-19T20:22:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE0NjY0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE0OTA3MQ==", "url": "https://github.com/apple/servicetalk/pull/1221#discussion_r527149071", "bodyText": "If we are changing API here, users should also specify a cap for the upper bound. It doesn't make sense to let it grow to hours, which may happen after a few retries if the initalDelay is high enough.", "author": "idelpivnitskiy", "createdAt": "2020-11-19T19:38:21Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/RetryStrategies.java", "diffHunk": "@@ -145,26 +194,61 @@ private RetryStrategies() {\n      * a {@link Completable} that terminates successfully when the source has to be retried or terminates with error\n      * if the source should not be retried for the passed {@link Throwable}\n      */\n-    public static BiIntFunction<Throwable, Completable> retryWithExponentialBackoffAndJitter(\n+    public static BiIntFunction<Throwable, Completable> retryWithExponentialBackoffFullJitter(\n             final int maxRetries,\n             final Predicate<Throwable> causeFilter,\n             final Duration initialDelay,\n             final Executor timerExecutor) {\n+        checkMaxRetries(maxRetries);\n+        requireNonNull(timerExecutor);\n+        requireNonNull(causeFilter);\n+        final long initialDelayNanos = initialDelay.toNanos();\n+        return (retryCount, cause) -> retryCount <= maxRetries && causeFilter.test(cause) ?\n+                timerExecutor.timer(current().nextLong(0, initialDelayNanos << (retryCount - 1)), NANOSECONDS) :", "originalCommit": "45af3b065570ed7e45c29d78e86f6e64a8845a87", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE1MDg1OA==", "url": "https://github.com/apple/servicetalk/pull/1221#discussion_r527150858", "bodyText": "We should verify initialDelay and jitter values, otherwise they may cause underflow for the first retry.\nWe may also compute the max possible value based on maxRetries and make sure it won't cause overflow.\nThe cap for baseDelayNanos may be useful here as well.", "author": "idelpivnitskiy", "createdAt": "2020-11-19T19:41:18Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/RetryStrategies.java", "diffHunk": "@@ -145,26 +194,61 @@ private RetryStrategies() {\n      * a {@link Completable} that terminates successfully when the source has to be retried or terminates with error\n      * if the source should not be retried for the passed {@link Throwable}\n      */\n-    public static BiIntFunction<Throwable, Completable> retryWithExponentialBackoffAndJitter(\n+    public static BiIntFunction<Throwable, Completable> retryWithExponentialBackoffFullJitter(\n             final int maxRetries,\n             final Predicate<Throwable> causeFilter,\n             final Duration initialDelay,\n             final Executor timerExecutor) {\n+        checkMaxRetries(maxRetries);\n+        requireNonNull(timerExecutor);\n+        requireNonNull(causeFilter);\n+        final long initialDelayNanos = initialDelay.toNanos();\n+        return (retryCount, cause) -> retryCount <= maxRetries && causeFilter.test(cause) ?\n+                timerExecutor.timer(current().nextLong(0, initialDelayNanos << (retryCount - 1)), NANOSECONDS) :\n+                failed(cause);\n+    }\n \n+    /**\n+     * Creates a new retry function that adds a delay between retries. For first retry, the delay is\n+     * {@code initialDelay} which is increased exponentially for subsequent retries.\n+     * <p>\n+     * This method may not attempt to check for overflow if the retry count is high enough that an exponential delay\n+     * causes {@link Long} overflow.\n+     *\n+     * @param maxRetries Maximum number of allowed retries, after which the returned {@link BiIntFunction} will return\n+     * a failed {@link Completable} with the passed {@link Throwable} as the cause\n+     * @param causeFilter A {@link Predicate} that selects whether a {@link Throwable} cause should be retried\n+     * @param initialDelay Delay {@link Duration} for the first retry and increased exponentially with each retry\n+     * @param jitter The jitter to apply to {@code delay} on each retry.\n+     * @param timerExecutor {@link Executor} to be used to schedule timers for backoff\n+     * @return A {@link BiIntFunction} to be used for retries which given a retry count and a {@link Throwable} returns\n+     * a {@link Completable} that terminates successfully when the source has to be retried or terminates with error\n+     * if the source should not be retried for the passed {@link Throwable}\n+     */\n+    public static BiIntFunction<Throwable, Completable> retryWithExponentialBackoffDeltaJitter(\n+            final int maxRetries,\n+            final Predicate<Throwable> causeFilter,\n+            final Duration initialDelay,\n+            final Duration jitter,\n+            final Executor timerExecutor) {\n         checkMaxRetries(maxRetries);\n         requireNonNull(timerExecutor);\n         requireNonNull(causeFilter);\n         final long initialDelayNanos = initialDelay.toNanos();\n+        final long jitterNanos = jitter.toNanos();", "originalCommit": "45af3b065570ed7e45c29d78e86f6e64a8845a87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzNzQyOQ==", "url": "https://github.com/apple/servicetalk/pull/1221#discussion_r527237429", "bodyText": "related to your other comment I added support for maxDelay and prevent overflow.", "author": "Scottmitch", "createdAt": "2020-11-19T22:13:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE1MDg1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE1NzY4Mw==", "url": "https://github.com/apple/servicetalk/pull/1221#discussion_r527157683", "bodyText": "Same comments apply for RepeatStrategies.\nLooks like the repeatWithConstantBackoffFullJitter variant is missed.", "author": "idelpivnitskiy", "createdAt": "2020-11-19T19:52:49Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/RepeatStrategies.java", "diffHunk": "@@ -62,14 +65,66 @@ private RepeatStrategies() {\n      */\n     public static IntFunction<Completable> repeatWithConstantBackoff(final int maxRepeats, final Duration backoff,\n                                                                      final Executor timerExecutor) {\n+        checkMaxRetries(maxRepeats);\n         requireNonNull(timerExecutor);\n         final long backoffNanos = backoff.toNanos();\n-        return repeatCount -> {\n-            if (repeatCount > maxRepeats) {\n-                return terminateRepeat();\n-            }\n-            return timerExecutor.timer(backoffNanos, NANOSECONDS);\n-        };\n+        return repeatCount -> repeatCount <= maxRepeats ?\n+                timerExecutor.timer(backoffNanos, NANOSECONDS) : terminateRepeat();\n+    }\n+\n+    /**\n+     * Creates a new repeat function that adds the passed constant {@link Duration} as delay between repeats.\n+     *\n+     * @param maxRepeats Maximum number of allowed repeats, after which the returned {@link IntFunction} will return\n+     *                   a failed {@link Completable} with {@link TerminateRepeatException} as the cause.\n+     * @param backoff Constant {@link Duration} of backoff between repeats.\n+     * @param jitter The jitter to apply to {@code backoff} on each repeat.\n+     * @param timerExecutor {@link Executor} to be used to schedule timers for backoff.\n+     *\n+     * @return An {@link IntFunction} to be used for repeats which given a repeat count returns a {@link Completable}\n+     * that terminates successfully when the source has to be repeated or terminates with error if the source should not\n+     * be repeated.\n+     */\n+    public static IntFunction<Completable> repeatWithConstantBackoffDeltaJitter(final int maxRepeats,\n+                                                                                final Duration backoff,\n+                                                                                final Duration jitter,\n+                                                                                final Executor timerExecutor) {\n+        checkMaxRetries(maxRepeats);\n+        requireNonNull(timerExecutor);\n+        final long backoffNanos = backoff.toNanos();\n+        final long jitterNanos = jitter.toNanos();\n+        if (jitterNanos > backoffNanos || Long.MAX_VALUE - backoffNanos < jitterNanos) {\n+            throw new IllegalArgumentException(\"jitter would result in [under|over]flow\");\n+        }\n+        final long lowerBound = backoffNanos - jitterNanos;\n+        final long upperBound = backoffNanos + jitterNanos;\n+        return repeatCount -> repeatCount <= maxRepeats ?\n+                timerExecutor.timer(current().nextLong(lowerBound, upperBound), NANOSECONDS) : terminateRepeat();\n+    }\n+\n+    /**\n+     * Creates a new repeat function that adds the passed constant {@link Duration} as delay between repeats.\n+     *\n+     * @param backoff Constant {@link Duration} of backoff between repeats.\n+     * @param jitter The jitter to apply to {@code backoff} on each repeat.\n+     * @param timerExecutor {@link Executor} to be used to schedule timers for backoff.\n+     *\n+     * @return An {@link IntFunction} to be used for repeats which given a repeat count returns a {@link Completable}\n+     * that terminates successfully when the source has to be repeated or terminates with error if the source should not\n+     * be repeated.\n+     */\n+    public static IntFunction<Completable> repeatWithConstantBackoffDeltaJitter(final Duration backoff,", "originalCommit": "45af3b065570ed7e45c29d78e86f6e64a8845a87", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2MDMwOA==", "url": "https://github.com/apple/servicetalk/pull/1221#discussion_r527160308", "bodyText": "Consider having at least one test for retry and repeat strategies with full jitter.", "author": "idelpivnitskiy", "createdAt": "2020-11-19T19:57:22Z", "path": "servicetalk-concurrent-api/src/test/java/io/servicetalk/concurrent/api/RetryStrategiesTest.java", "diffHunk": "@@ -122,14 +124,15 @@ public void testExpBackoffWithJitter() throws Exception {\n     @Test\n     public void testExpBackoffWithJitterMaxRetries() throws Exception {\n         Duration backoff = ofSeconds(1);\n-        testMaxRetries(retryWithExponentialBackoffAndJitter(1, cause -> true, backoff, timerExecutor),\n-                () -> verifyDelayWithJitter(backoff.toNanos(), 1));\n+        Duration jitter = ofMillis(10);\n+        testMaxRetries(retryWithExponentialBackoffDeltaJitter(1, cause -> true, backoff, jitter, timerExecutor),\n+                () -> verifyDelayWithJitter(backoff.toNanos(), jitter.toNanos(), 1));\n     }\n \n     @Test\n     public void testExpBackoffWithJitterCauseFilter() {\n-        testCauseFilter(retryWithExponentialBackoffAndJitter(1,\n-                cause -> cause instanceof IllegalStateException, ofSeconds(1), timerExecutor));\n+        testCauseFilter(retryWithExponentialBackoffDeltaJitter(1,", "originalCommit": "45af3b065570ed7e45c29d78e86f6e64a8845a87", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2MjA1NQ==", "url": "https://github.com/apple/servicetalk/pull/1221#discussion_r527162055", "bodyText": "Why lowering the base from 60 to 10?", "author": "idelpivnitskiy", "createdAt": "2020-11-19T20:00:33Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/DefaultPartitionedHttpClientBuilder.java", "diffHunk": "@@ -99,7 +99,7 @@ public StreamingHttpClient buildStreaming() {\n                 new DefaultSingleAddressHttpClientBuilder.RetryingServiceDiscoverer<>(serviceDiscoverer,\n                         serviceDiscovererRetryStrategy == null ?\n                                 DefaultServiceDiscoveryRetryStrategy.Builder.<R>withDefaultsForPartitions(\n-                                        buildContext.executionContext.executor(), ofSeconds(60)).build() :\n+                                        buildContext.executionContext.executor(), ofSeconds(10), ofSeconds(5)).build() :", "originalCommit": "45af3b065570ed7e45c29d78e86f6e64a8845a87", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI0NzAzNA==", "url": "https://github.com/apple/servicetalk/pull/1221#discussion_r527247034", "bodyText": "faster recovery by default.", "author": "Scottmitch", "createdAt": "2020-11-19T22:29:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2MjA1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2MjUxNg==", "url": "https://github.com/apple/servicetalk/pull/1221#discussion_r527162516", "bodyText": "Consider creating 2 plg-private constants that we can share between partitioned and single-address clients to make sure the values are always consistent.", "author": "idelpivnitskiy", "createdAt": "2020-11-19T20:01:31Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/DefaultSingleAddressHttpClientBuilder.java", "diffHunk": "@@ -368,7 +368,7 @@ private static StreamingHttpClientFilterFactory appendFilter(\n                 new RetryingServiceDiscoverer<>(new StatusAwareServiceDiscoverer<>(serviceDiscoverer, sdStatus),\n                         serviceDiscovererRetryStrategy == null ?\n                                 DefaultServiceDiscoveryRetryStrategy.Builder.<R>withDefaults(exec.executor(),\n-                                        ofSeconds(60)).build()\n+                                        ofSeconds(10), ofSeconds(5)).build()", "originalCommit": "45af3b065570ed7e45c29d78e86f6e64a8845a87", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4092a4c8a0f5624a39368df24abaf3e143410030", "url": "https://github.com/apple/servicetalk/commit/4092a4c8a0f5624a39368df24abaf3e143410030", "message": "[Retry|Repeat]Strategies add jitter delta methods\n\nMotivation:\n[Retry|Repeat]Strategies provides utility methods with strategies that\ncan apply a jitter to a delay scheme (e.g. fixed, exponential). However\nwe currently only offer \"Full Jitter\" variants which vary delay in the\nrange [0, max delay]. This works well to maximize variance of client\nrequest arrival for exclusive resource operations (e.g. all clients\nattempt to lock the same row in a DB) but may not be optimal in cases\nwhich don't require mutual exclusion and instead value more predictable\nand faster repeat intervals.\n\nModifications:\n- [Retry|Repeat]Strategies rename the existing jitter methods to\n\"FullJitter\"\n- [Retry|Repeat]Strategies now include an alternative jitter method\n\"DeltaJitter\" which applies a delta to the base distribution\n[delay-jitter, delay+jitter].\n\nResult:\nMore options to apply jitter in [Retry|Repeat]Strategies", "committedDate": "2020-11-19T22:53:58Z", "type": "commit"}, {"oid": "4092a4c8a0f5624a39368df24abaf3e143410030", "url": "https://github.com/apple/servicetalk/commit/4092a4c8a0f5624a39368df24abaf3e143410030", "message": "[Retry|Repeat]Strategies add jitter delta methods\n\nMotivation:\n[Retry|Repeat]Strategies provides utility methods with strategies that\ncan apply a jitter to a delay scheme (e.g. fixed, exponential). However\nwe currently only offer \"Full Jitter\" variants which vary delay in the\nrange [0, max delay]. This works well to maximize variance of client\nrequest arrival for exclusive resource operations (e.g. all clients\nattempt to lock the same row in a DB) but may not be optimal in cases\nwhich don't require mutual exclusion and instead value more predictable\nand faster repeat intervals.\n\nModifications:\n- [Retry|Repeat]Strategies rename the existing jitter methods to\n\"FullJitter\"\n- [Retry|Repeat]Strategies now include an alternative jitter method\n\"DeltaJitter\" which applies a delta to the base distribution\n[delay-jitter, delay+jitter].\n\nResult:\nMore options to apply jitter in [Retry|Repeat]Strategies", "committedDate": "2020-11-19T22:53:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI4MjExMw==", "url": "https://github.com/apple/servicetalk/pull/1221#discussion_r527282113", "bodyText": "If we're adding a retryWithConstantBackoffDeltaJitter variant without maxRetries, we should add the same variant for other strategies.", "author": "idelpivnitskiy", "createdAt": "2020-11-19T23:56:24Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/RetryStrategies.java", "diffHunk": "@@ -45,128 +49,165 @@ private RetryStrategies() {\n      * a {@link Completable} that terminates successfully when the source has to be retried or terminates with error\n      * if the source should not be retried for the passed {@link Throwable}\n      */\n-    public static BiIntFunction<Throwable, Completable> retryWithConstantBackoff(final int maxRetries,\n-                                                                                 final Predicate<Throwable> causeFilter,\n-                                                                                 final Duration delay,\n-                                                                                 final Executor timerExecutor) {\n+    public static BiIntFunction<Throwable, Completable> retryWithConstantBackoffFullJitter(\n+            final int maxRetries,\n+            final Predicate<Throwable> causeFilter,\n+            final Duration delay,\n+            final Executor timerExecutor) {\n         checkMaxRetries(maxRetries);\n         requireNonNull(timerExecutor);\n         requireNonNull(causeFilter);\n         final long delayNanos = delay.toNanos();\n-        return (retryCount, cause) -> {\n-            if (retryCount > maxRetries || !causeFilter.test(cause)) {\n-                return failed(cause);\n-            }\n-            return timerExecutor.timer(delayNanos, NANOSECONDS);\n-        };\n+        return (retryCount, cause) -> retryCount <= maxRetries && causeFilter.test(cause) ?\n+                timerExecutor.timer(current().nextLong(0, delayNanos), NANOSECONDS) : failed(cause);\n     }\n \n     /**\n      * Creates a new retry function that adds the passed constant {@link Duration} as a delay between retries.\n-     * This additionally adds a \"Full Jitter\" for the backoff as described\n-     * <a href=\"https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/\">here</a>.\n      *\n      * @param maxRetries Maximum number of allowed retries, after which the returned {@link BiIntFunction} will return\n      * a failed {@link Completable} with the passed {@link Throwable} as the cause\n      * @param causeFilter A {@link Predicate} that selects whether a {@link Throwable} cause should be retried\n      * @param delay Constant {@link Duration} of delay between retries\n+     * @param jitter The jitter to apply to {@code delay} on each retry.\n      * @param timerExecutor {@link Executor} to be used to schedule timers for backoff\n      * @return A {@link BiIntFunction} to be used for retries which given a retry count and a {@link Throwable} returns\n      * a {@link Completable} that terminates successfully when the source has to be retried or terminates with error\n      * if the source should not be retried for the passed {@link Throwable}\n      */\n-    public static BiIntFunction<Throwable, Completable> retryWithConstantBackoffAndJitter(\n+    public static BiIntFunction<Throwable, Completable> retryWithConstantBackoffDeltaJitter(\n             final int maxRetries,\n             final Predicate<Throwable> causeFilter,\n             final Duration delay,\n+            final Duration jitter,\n             final Executor timerExecutor) {\n-\n         checkMaxRetries(maxRetries);\n         requireNonNull(timerExecutor);\n         requireNonNull(causeFilter);\n         final long delayNanos = delay.toNanos();\n-        return (retryCount, cause) -> {\n-            if (retryCount > maxRetries || !causeFilter.test(cause)) {\n-                return failed(cause);\n-            }\n-            return timerExecutor.timer(ThreadLocalRandom.current().nextLong(0, delayNanos), NANOSECONDS);\n-        };\n+        final long jitterNanos = jitter.toNanos();\n+        checkJitterDelta(jitterNanos, delayNanos);\n+        final long lowerBound = delayNanos - jitterNanos;\n+        final long upperBound = delayNanos + jitterNanos;\n+        return (retryCount, cause) -> retryCount <= maxRetries && causeFilter.test(cause) ?\n+                timerExecutor.timer(current().nextLong(lowerBound, upperBound), NANOSECONDS) : failed(cause);\n+    }\n+\n+    /**\n+     * Creates a new retry function that adds the passed constant {@link Duration} as a delay between retries.\n+     *\n+     * @param causeFilter A {@link Predicate} that selects whether a {@link Throwable} cause should be retried\n+     * @param delay Constant {@link Duration} of delay between retries\n+     * @param jitter The jitter to apply to {@code delay} on each retry.\n+     * @param timerExecutor {@link Executor} to be used to schedule timers for backoff\n+     * @return A {@link BiIntFunction} to be used for retries which given a retry count and a {@link Throwable} returns\n+     * a {@link Completable} that terminates successfully when the source has to be retried or terminates with error\n+     * if the source should not be retried for the passed {@link Throwable}\n+     */\n+    public static BiIntFunction<Throwable, Completable> retryWithConstantBackoffDeltaJitter(", "originalCommit": "4092a4c8a0f5624a39368df24abaf3e143410030", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzMyOTE1NQ==", "url": "https://github.com/apple/servicetalk/pull/1221#discussion_r527329155", "bodyText": "done", "author": "Scottmitch", "createdAt": "2020-11-20T01:07:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI4MjExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI4MzM4OA==", "url": "https://github.com/apple/servicetalk/pull/1221#discussion_r527283388", "bodyText": "Good catch with maxInitialShift!", "author": "idelpivnitskiy", "createdAt": "2020-11-20T00:00:10Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/RetryStrategies.java", "diffHunk": "@@ -45,128 +49,165 @@ private RetryStrategies() {\n      * a {@link Completable} that terminates successfully when the source has to be retried or terminates with error\n      * if the source should not be retried for the passed {@link Throwable}\n      */\n-    public static BiIntFunction<Throwable, Completable> retryWithConstantBackoff(final int maxRetries,\n-                                                                                 final Predicate<Throwable> causeFilter,\n-                                                                                 final Duration delay,\n-                                                                                 final Executor timerExecutor) {\n+    public static BiIntFunction<Throwable, Completable> retryWithConstantBackoffFullJitter(\n+            final int maxRetries,\n+            final Predicate<Throwable> causeFilter,\n+            final Duration delay,\n+            final Executor timerExecutor) {\n         checkMaxRetries(maxRetries);\n         requireNonNull(timerExecutor);\n         requireNonNull(causeFilter);\n         final long delayNanos = delay.toNanos();\n-        return (retryCount, cause) -> {\n-            if (retryCount > maxRetries || !causeFilter.test(cause)) {\n-                return failed(cause);\n-            }\n-            return timerExecutor.timer(delayNanos, NANOSECONDS);\n-        };\n+        return (retryCount, cause) -> retryCount <= maxRetries && causeFilter.test(cause) ?\n+                timerExecutor.timer(current().nextLong(0, delayNanos), NANOSECONDS) : failed(cause);\n     }\n \n     /**\n      * Creates a new retry function that adds the passed constant {@link Duration} as a delay between retries.\n-     * This additionally adds a \"Full Jitter\" for the backoff as described\n-     * <a href=\"https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/\">here</a>.\n      *\n      * @param maxRetries Maximum number of allowed retries, after which the returned {@link BiIntFunction} will return\n      * a failed {@link Completable} with the passed {@link Throwable} as the cause\n      * @param causeFilter A {@link Predicate} that selects whether a {@link Throwable} cause should be retried\n      * @param delay Constant {@link Duration} of delay between retries\n+     * @param jitter The jitter to apply to {@code delay} on each retry.\n      * @param timerExecutor {@link Executor} to be used to schedule timers for backoff\n      * @return A {@link BiIntFunction} to be used for retries which given a retry count and a {@link Throwable} returns\n      * a {@link Completable} that terminates successfully when the source has to be retried or terminates with error\n      * if the source should not be retried for the passed {@link Throwable}\n      */\n-    public static BiIntFunction<Throwable, Completable> retryWithConstantBackoffAndJitter(\n+    public static BiIntFunction<Throwable, Completable> retryWithConstantBackoffDeltaJitter(\n             final int maxRetries,\n             final Predicate<Throwable> causeFilter,\n             final Duration delay,\n+            final Duration jitter,\n             final Executor timerExecutor) {\n-\n         checkMaxRetries(maxRetries);\n         requireNonNull(timerExecutor);\n         requireNonNull(causeFilter);\n         final long delayNanos = delay.toNanos();\n-        return (retryCount, cause) -> {\n-            if (retryCount > maxRetries || !causeFilter.test(cause)) {\n-                return failed(cause);\n-            }\n-            return timerExecutor.timer(ThreadLocalRandom.current().nextLong(0, delayNanos), NANOSECONDS);\n-        };\n+        final long jitterNanos = jitter.toNanos();\n+        checkJitterDelta(jitterNanos, delayNanos);\n+        final long lowerBound = delayNanos - jitterNanos;\n+        final long upperBound = delayNanos + jitterNanos;\n+        return (retryCount, cause) -> retryCount <= maxRetries && causeFilter.test(cause) ?\n+                timerExecutor.timer(current().nextLong(lowerBound, upperBound), NANOSECONDS) : failed(cause);\n+    }\n+\n+    /**\n+     * Creates a new retry function that adds the passed constant {@link Duration} as a delay between retries.\n+     *\n+     * @param causeFilter A {@link Predicate} that selects whether a {@link Throwable} cause should be retried\n+     * @param delay Constant {@link Duration} of delay between retries\n+     * @param jitter The jitter to apply to {@code delay} on each retry.\n+     * @param timerExecutor {@link Executor} to be used to schedule timers for backoff\n+     * @return A {@link BiIntFunction} to be used for retries which given a retry count and a {@link Throwable} returns\n+     * a {@link Completable} that terminates successfully when the source has to be retried or terminates with error\n+     * if the source should not be retried for the passed {@link Throwable}\n+     */\n+    public static BiIntFunction<Throwable, Completable> retryWithConstantBackoffDeltaJitter(\n+            final Predicate<Throwable> causeFilter,\n+            final Duration delay,\n+            final Duration jitter,\n+            final Executor timerExecutor) {\n+        requireNonNull(timerExecutor);\n+        requireNonNull(causeFilter);\n+        final long delayNanos = delay.toNanos();\n+        final long jitterNanos = jitter.toNanos();\n+        checkJitterDelta(jitterNanos, delayNanos);\n+        final long lowerBound = delayNanos - jitterNanos;\n+        final long upperBound = delayNanos + jitterNanos;\n+        return (retryCount, cause) -> causeFilter.test(cause) ?\n+                timerExecutor.timer(current().nextLong(lowerBound, upperBound), NANOSECONDS) : failed(cause);\n     }\n \n     /**\n      * Creates a new retry function that adds a delay between retries. For first retry, the delay is\n      * {@code initialDelay} which is increased exponentially for subsequent retries.\n-     * <p>\n-     * This method may not attempt to check for overflow if the retry count is high enough that an exponential delay\n-     * causes {@link Long} overflow.\n+     * This additionally adds a \"Full Jitter\" for the backoff as described\n+     * <a href=\"https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter\">here</a>.\n      *\n      * @param maxRetries Maximum number of allowed retries, after which the returned {@link BiIntFunction} will return\n      * a failed {@link Completable} with the passed {@link Throwable} as the cause\n      * @param causeFilter A {@link Predicate} that selects whether a {@link Throwable} cause should be retried\n      * @param initialDelay Delay {@link Duration} for the first retry and increased exponentially with each retry\n+     * @param maxDelay The maximum amount of delay that will be introduced.\n      * @param timerExecutor {@link Executor} to be used to schedule timers for backoff\n      * @return A {@link BiIntFunction} to be used for retries which given a retry count and a {@link Throwable} returns\n      * a {@link Completable} that terminates successfully when the source has to be retried or terminates with error\n      * if the source should not be retried for the passed {@link Throwable}\n      */\n-    public static BiIntFunction<Throwable, Completable> retryWithExponentialBackoff(\n+    public static BiIntFunction<Throwable, Completable> retryWithExponentialBackoffFullJitter(\n             final int maxRetries,\n             final Predicate<Throwable> causeFilter,\n             final Duration initialDelay,\n+            final Duration maxDelay,\n             final Executor timerExecutor) {\n-\n-        checkMaxRetries(maxRetries);\n         requireNonNull(timerExecutor);\n         requireNonNull(causeFilter);\n         final long initialDelayNanos = initialDelay.toNanos();\n-        return (retryCount, cause) -> {\n-            if (retryCount > maxRetries || !causeFilter.test(cause)) {\n-                return failed(cause);\n-            }\n-            return timerExecutor.timer(initialDelayNanos << (retryCount - 1), NANOSECONDS);\n-        };\n+        final long maxDelayNanos = maxDelay.toNanos();\n+        final long maxInitialShift = maxShift(initialDelayNanos);\n+        return (retryCount, cause) -> retryCount <= maxRetries && causeFilter.test(cause) ?\n+                timerExecutor.timer(current().nextLong(0,\n+                        min(maxDelayNanos, initialDelayNanos << min(maxInitialShift, retryCount - 1))), NANOSECONDS) :", "originalCommit": "4092a4c8a0f5624a39368df24abaf3e143410030", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI4NDgwNw==", "url": "https://github.com/apple/servicetalk/pull/1221#discussion_r527284807", "bodyText": "I think we should take max here instead of min", "author": "idelpivnitskiy", "createdAt": "2020-11-20T00:04:21Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/RetryStrategies.java", "diffHunk": "@@ -45,128 +49,165 @@ private RetryStrategies() {\n      * a {@link Completable} that terminates successfully when the source has to be retried or terminates with error\n      * if the source should not be retried for the passed {@link Throwable}\n      */\n-    public static BiIntFunction<Throwable, Completable> retryWithConstantBackoff(final int maxRetries,\n-                                                                                 final Predicate<Throwable> causeFilter,\n-                                                                                 final Duration delay,\n-                                                                                 final Executor timerExecutor) {\n+    public static BiIntFunction<Throwable, Completable> retryWithConstantBackoffFullJitter(\n+            final int maxRetries,\n+            final Predicate<Throwable> causeFilter,\n+            final Duration delay,\n+            final Executor timerExecutor) {\n         checkMaxRetries(maxRetries);\n         requireNonNull(timerExecutor);\n         requireNonNull(causeFilter);\n         final long delayNanos = delay.toNanos();\n-        return (retryCount, cause) -> {\n-            if (retryCount > maxRetries || !causeFilter.test(cause)) {\n-                return failed(cause);\n-            }\n-            return timerExecutor.timer(delayNanos, NANOSECONDS);\n-        };\n+        return (retryCount, cause) -> retryCount <= maxRetries && causeFilter.test(cause) ?\n+                timerExecutor.timer(current().nextLong(0, delayNanos), NANOSECONDS) : failed(cause);\n     }\n \n     /**\n      * Creates a new retry function that adds the passed constant {@link Duration} as a delay between retries.\n-     * This additionally adds a \"Full Jitter\" for the backoff as described\n-     * <a href=\"https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/\">here</a>.\n      *\n      * @param maxRetries Maximum number of allowed retries, after which the returned {@link BiIntFunction} will return\n      * a failed {@link Completable} with the passed {@link Throwable} as the cause\n      * @param causeFilter A {@link Predicate} that selects whether a {@link Throwable} cause should be retried\n      * @param delay Constant {@link Duration} of delay between retries\n+     * @param jitter The jitter to apply to {@code delay} on each retry.\n      * @param timerExecutor {@link Executor} to be used to schedule timers for backoff\n      * @return A {@link BiIntFunction} to be used for retries which given a retry count and a {@link Throwable} returns\n      * a {@link Completable} that terminates successfully when the source has to be retried or terminates with error\n      * if the source should not be retried for the passed {@link Throwable}\n      */\n-    public static BiIntFunction<Throwable, Completable> retryWithConstantBackoffAndJitter(\n+    public static BiIntFunction<Throwable, Completable> retryWithConstantBackoffDeltaJitter(\n             final int maxRetries,\n             final Predicate<Throwable> causeFilter,\n             final Duration delay,\n+            final Duration jitter,\n             final Executor timerExecutor) {\n-\n         checkMaxRetries(maxRetries);\n         requireNonNull(timerExecutor);\n         requireNonNull(causeFilter);\n         final long delayNanos = delay.toNanos();\n-        return (retryCount, cause) -> {\n-            if (retryCount > maxRetries || !causeFilter.test(cause)) {\n-                return failed(cause);\n-            }\n-            return timerExecutor.timer(ThreadLocalRandom.current().nextLong(0, delayNanos), NANOSECONDS);\n-        };\n+        final long jitterNanos = jitter.toNanos();\n+        checkJitterDelta(jitterNanos, delayNanos);\n+        final long lowerBound = delayNanos - jitterNanos;\n+        final long upperBound = delayNanos + jitterNanos;\n+        return (retryCount, cause) -> retryCount <= maxRetries && causeFilter.test(cause) ?\n+                timerExecutor.timer(current().nextLong(lowerBound, upperBound), NANOSECONDS) : failed(cause);\n+    }\n+\n+    /**\n+     * Creates a new retry function that adds the passed constant {@link Duration} as a delay between retries.\n+     *\n+     * @param causeFilter A {@link Predicate} that selects whether a {@link Throwable} cause should be retried\n+     * @param delay Constant {@link Duration} of delay between retries\n+     * @param jitter The jitter to apply to {@code delay} on each retry.\n+     * @param timerExecutor {@link Executor} to be used to schedule timers for backoff\n+     * @return A {@link BiIntFunction} to be used for retries which given a retry count and a {@link Throwable} returns\n+     * a {@link Completable} that terminates successfully when the source has to be retried or terminates with error\n+     * if the source should not be retried for the passed {@link Throwable}\n+     */\n+    public static BiIntFunction<Throwable, Completable> retryWithConstantBackoffDeltaJitter(\n+            final Predicate<Throwable> causeFilter,\n+            final Duration delay,\n+            final Duration jitter,\n+            final Executor timerExecutor) {\n+        requireNonNull(timerExecutor);\n+        requireNonNull(causeFilter);\n+        final long delayNanos = delay.toNanos();\n+        final long jitterNanos = jitter.toNanos();\n+        checkJitterDelta(jitterNanos, delayNanos);\n+        final long lowerBound = delayNanos - jitterNanos;\n+        final long upperBound = delayNanos + jitterNanos;\n+        return (retryCount, cause) -> causeFilter.test(cause) ?\n+                timerExecutor.timer(current().nextLong(lowerBound, upperBound), NANOSECONDS) : failed(cause);\n     }\n \n     /**\n      * Creates a new retry function that adds a delay between retries. For first retry, the delay is\n      * {@code initialDelay} which is increased exponentially for subsequent retries.\n-     * <p>\n-     * This method may not attempt to check for overflow if the retry count is high enough that an exponential delay\n-     * causes {@link Long} overflow.\n+     * This additionally adds a \"Full Jitter\" for the backoff as described\n+     * <a href=\"https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter\">here</a>.\n      *\n      * @param maxRetries Maximum number of allowed retries, after which the returned {@link BiIntFunction} will return\n      * a failed {@link Completable} with the passed {@link Throwable} as the cause\n      * @param causeFilter A {@link Predicate} that selects whether a {@link Throwable} cause should be retried\n      * @param initialDelay Delay {@link Duration} for the first retry and increased exponentially with each retry\n+     * @param maxDelay The maximum amount of delay that will be introduced.\n      * @param timerExecutor {@link Executor} to be used to schedule timers for backoff\n      * @return A {@link BiIntFunction} to be used for retries which given a retry count and a {@link Throwable} returns\n      * a {@link Completable} that terminates successfully when the source has to be retried or terminates with error\n      * if the source should not be retried for the passed {@link Throwable}\n      */\n-    public static BiIntFunction<Throwable, Completable> retryWithExponentialBackoff(\n+    public static BiIntFunction<Throwable, Completable> retryWithExponentialBackoffFullJitter(\n             final int maxRetries,\n             final Predicate<Throwable> causeFilter,\n             final Duration initialDelay,\n+            final Duration maxDelay,\n             final Executor timerExecutor) {\n-\n-        checkMaxRetries(maxRetries);\n         requireNonNull(timerExecutor);\n         requireNonNull(causeFilter);\n         final long initialDelayNanos = initialDelay.toNanos();\n-        return (retryCount, cause) -> {\n-            if (retryCount > maxRetries || !causeFilter.test(cause)) {\n-                return failed(cause);\n-            }\n-            return timerExecutor.timer(initialDelayNanos << (retryCount - 1), NANOSECONDS);\n-        };\n+        final long maxDelayNanos = maxDelay.toNanos();\n+        final long maxInitialShift = maxShift(initialDelayNanos);\n+        return (retryCount, cause) -> retryCount <= maxRetries && causeFilter.test(cause) ?\n+                timerExecutor.timer(current().nextLong(0,\n+                        min(maxDelayNanos, initialDelayNanos << min(maxInitialShift, retryCount - 1))), NANOSECONDS) :\n+                failed(cause);\n     }\n \n     /**\n      * Creates a new retry function that adds a delay between retries. For first retry, the delay is\n      * {@code initialDelay} which is increased exponentially for subsequent retries.\n-     * This additionally adds a \"Full Jitter\" for the backoff as described\n-     * <a href=\"https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/\">here</a>.\n-     * <p>\n-     * This method may not attempt to check for overflow if the retry count is high enough that an exponential delay\n-     * causes {@link Long} overflow.\n      *\n      * @param maxRetries Maximum number of allowed retries, after which the returned {@link BiIntFunction} will return\n      * a failed {@link Completable} with the passed {@link Throwable} as the cause\n      * @param causeFilter A {@link Predicate} that selects whether a {@link Throwable} cause should be retried\n      * @param initialDelay Delay {@link Duration} for the first retry and increased exponentially with each retry\n+     * @param jitter The jitter to apply to {@code delay} on each retry.\n+     * @param maxDelay The maximum amount of delay that will be introduced.\n      * @param timerExecutor {@link Executor} to be used to schedule timers for backoff\n      * @return A {@link BiIntFunction} to be used for retries which given a retry count and a {@link Throwable} returns\n      * a {@link Completable} that terminates successfully when the source has to be retried or terminates with error\n      * if the source should not be retried for the passed {@link Throwable}\n      */\n-    public static BiIntFunction<Throwable, Completable> retryWithExponentialBackoffAndJitter(\n+    public static BiIntFunction<Throwable, Completable> retryWithExponentialBackoffDeltaJitter(\n             final int maxRetries,\n             final Predicate<Throwable> causeFilter,\n             final Duration initialDelay,\n+            final Duration jitter,\n+            final Duration maxDelay,\n             final Executor timerExecutor) {\n-\n         checkMaxRetries(maxRetries);\n         requireNonNull(timerExecutor);\n         requireNonNull(causeFilter);\n         final long initialDelayNanos = initialDelay.toNanos();\n+        final long jitterNanos = jitter.toNanos();\n+        final long maxDelayNanos = maxDelay.toNanos();\n+        final long maxInitialShift = maxShift(initialDelayNanos);\n         return (retryCount, cause) -> {\n             if (retryCount > maxRetries || !causeFilter.test(cause)) {\n                 return failed(cause);\n             }\n-            return timerExecutor.timer(ThreadLocalRandom.current().nextLong(0, initialDelayNanos << (retryCount - 1)),\n+            final long baseDelayNanos = initialDelayNanos << min(maxInitialShift, retryCount - 1);\n+            return timerExecutor.timer(\n+                    current().nextLong(min(0, baseDelayNanos - jitterNanos),", "originalCommit": "4092a4c8a0f5624a39368df24abaf3e143410030", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI5MTM2Nw==", "url": "https://github.com/apple/servicetalk/pull/1221#discussion_r527291367", "bodyText": "min -> max, and overloads without maxRepeats similar to RetryStrategies.", "author": "idelpivnitskiy", "createdAt": "2020-11-20T00:16:50Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/RepeatStrategies.java", "diffHunk": "@@ -53,80 +58,139 @@ private RepeatStrategies() {\n      *\n      * @param maxRepeats Maximum number of allowed repeats, after which the returned {@link IntFunction} will return\n      *                   a failed {@link Completable} with {@link TerminateRepeatException} as the cause.\n-     * @param backoff Constant {@link Duration} of backoff between repeats.\n-     * @param timerExecutor {@link Executor} to be used to schedule timers for backoff.\n+     * @param delay Constant {@link Duration} of delay between repeats.\n+     * @param timerExecutor {@link Executor} to be used to schedule timers for delay.\n      *\n      * @return An {@link IntFunction} to be used for repeats which given a repeat count returns a {@link Completable}\n      * that terminates successfully when the source has to be repeated or terminates with error if the source should not\n      * be repeated.\n      */\n-    public static IntFunction<Completable> repeatWithConstantBackoff(final int maxRepeats, final Duration backoff,\n-                                                                     final Executor timerExecutor) {\n+    public static IntFunction<Completable> repeatWithConstantBackoffFullJitter(final int maxRepeats,\n+                                                                               final Duration delay,\n+                                                                               final Executor timerExecutor) {\n+        checkMaxRetries(maxRepeats);\n         requireNonNull(timerExecutor);\n-        final long backoffNanos = backoff.toNanos();\n-        return repeatCount -> {\n-            if (repeatCount > maxRepeats) {\n-                return terminateRepeat();\n-            }\n-            return timerExecutor.timer(backoffNanos, NANOSECONDS);\n-        };\n+        final long delayNanos = delay.toNanos();\n+        return repeatCount -> repeatCount <= maxRepeats ?\n+                timerExecutor.timer(current().nextLong(0, delayNanos), NANOSECONDS) : terminateRepeat();\n+    }\n+\n+    /**\n+     * Creates a new repeat function that adds the passed constant {@link Duration} as delay between repeats.\n+     *\n+     * @param maxRepeats Maximum number of allowed repeats, after which the returned {@link IntFunction} will return\n+     *                   a failed {@link Completable} with {@link TerminateRepeatException} as the cause.\n+     * @param delay Constant {@link Duration} of delay between repeats.\n+     * @param jitter The jitter to apply to {@code delay} on each repeat.\n+     * @param timerExecutor {@link Executor} to be used to schedule timers for delay.\n+     *\n+     * @return An {@link IntFunction} to be used for repeats which given a repeat count returns a {@link Completable}\n+     * that terminates successfully when the source has to be repeated or terminates with error if the source should not\n+     * be repeated.\n+     */\n+    public static IntFunction<Completable> repeatWithConstantBackoffDeltaJitter(final int maxRepeats,\n+                                                                                final Duration delay,\n+                                                                                final Duration jitter,\n+                                                                                final Executor timerExecutor) {\n+        checkMaxRetries(maxRepeats);\n+        requireNonNull(timerExecutor);\n+        final long delayNanos = delay.toNanos();\n+        final long jitterNanos = jitter.toNanos();\n+        checkJitterDelta(jitterNanos, delayNanos);\n+        final long lowerBound = delayNanos - jitterNanos;\n+        final long upperBound = delayNanos + jitterNanos;\n+        return repeatCount -> repeatCount <= maxRepeats ?\n+                timerExecutor.timer(current().nextLong(lowerBound, upperBound), NANOSECONDS) : terminateRepeat();\n+    }\n+\n+    /**\n+     * Creates a new repeat function that adds the passed constant {@link Duration} as delay between repeats.\n+     *\n+     * @param delay Constant {@link Duration} of delay between repeats.\n+     * @param jitter The jitter to apply to {@code delay} on each repeat.\n+     * @param timerExecutor {@link Executor} to be used to schedule timers for delay.\n+     *\n+     * @return An {@link IntFunction} to be used for repeats which given a repeat count returns a {@link Completable}\n+     * that terminates successfully when the source has to be repeated or terminates with error if the source should not\n+     * be repeated.\n+     */\n+    public static IntFunction<Completable> repeatWithConstantBackoffDeltaJitter(final Duration delay,\n+                                                                                final Duration jitter,\n+                                                                                final Executor timerExecutor) {\n+        requireNonNull(timerExecutor);\n+        final long delayNanos = delay.toNanos();\n+        final long jitterNanos = jitter.toNanos();\n+        checkJitterDelta(jitterNanos, delayNanos);\n+        final long lowerBound = delayNanos - jitterNanos;\n+        final long upperBound = delayNanos + jitterNanos;\n+        return repeatCount -> timerExecutor.timer(current().nextLong(lowerBound, upperBound), NANOSECONDS);\n     }\n \n     /**\n      * Creates a new repeat function that adds a delay between repeats. For first repeat, the delay is\n-     * {@code initialDelay} which is increased exponentially for subsequent repeats. <p>\n-     * This method may not attempt to check for overflow if the repeat count is high enough that an exponential\n-     * delay causes {@link Long} overflow.\n+     * {@code initialDelay} which is increased exponentially for subsequent repeats.\n+     * This additionally adds a \"Full Jitter\" for the backoff as described\n+     * <a href=\"https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/\">here</a>.\n      *\n      * @param maxRepeats Maximum number of allowed repeats, after which the returned {@link IntFunction} will return\n-     * a failed {@link Completable} with {@link TerminateRepeatException} as the cause.\n+     *                   a failed {@link Completable} with {@link TerminateRepeatException} as the cause.\n      * @param initialDelay Delay {@link Duration} for the first repeat and increased exponentially with each repeat.\n+     * @param maxDelay The maximum amount of delay that will be introduced.\n      * @param timerExecutor {@link Executor} to be used to schedule timers for backoff.\n      *\n      * @return An {@link IntFunction} to be used for repeats which given a repeat count returns a {@link Completable}\n      * that terminates successfully when the source has to be repeated or terminates with error if the source should not\n      * be repeated.\n      */\n-    public static IntFunction<Completable> repeatWithExponentialBackoff(final int maxRepeats,\n-                                                                        final Duration initialDelay,\n-                                                                        final Executor timerExecutor) {\n+    public static IntFunction<Completable> repeatWithExponentialBackoffFullJitter(final int maxRepeats,\n+                                                                                  final Duration initialDelay,\n+                                                                                  final Duration maxDelay,\n+                                                                                  final Executor timerExecutor) {\n+        checkMaxRetries(maxRepeats);\n         requireNonNull(timerExecutor);\n         final long initialDelayNanos = initialDelay.toNanos();\n-        return repeatCount -> {\n-            if (repeatCount > maxRepeats) {\n-                return terminateRepeat();\n-            }\n-            return timerExecutor.timer(initialDelayNanos << (repeatCount - 1), NANOSECONDS);\n-        };\n+        final long maxDelayNanos = maxDelay.toNanos();\n+        final long maxInitialShift = maxShift(initialDelayNanos);\n+        return repeatCount -> repeatCount <= maxRepeats ?\n+                timerExecutor.timer(current().nextLong(0,\n+                        min(maxDelayNanos, initialDelayNanos << min(maxInitialShift, repeatCount - 1))), NANOSECONDS) :\n+                terminateRepeat();\n     }\n \n     /**\n      * Creates a new repeat function that adds a delay between repeats. For first repeat, the delay is\n      * {@code initialDelay} which is increased exponentially for subsequent repeats.\n-     * This additionally adds a \"Full Jitter\" for the backoff as described\n-     * <a href=\"https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/\">here</a>.<p>\n-     * This method may not attempt to check for overflow if the repeat count is high enough that an exponential delay\n-     * causes {@link Long} overflow.\n      *\n      * @param maxRepeats Maximum number of allowed repeats, after which the returned {@link IntFunction} will return\n      *                   a failed {@link Completable} with {@link TerminateRepeatException} as the cause.\n      * @param initialDelay Delay {@link Duration} for the first repeat and increased exponentially with each repeat.\n+     * @param jitter The jitter to apply to {@code initialDelay} on each repeat.\n+     * @param maxDelay The maximum amount of delay that will be introduced.\n      * @param timerExecutor {@link Executor} to be used to schedule timers for backoff.\n      *\n      * @return An {@link IntFunction} to be used for repeats which given a repeat count returns a {@link Completable}\n      * that terminates successfully when the source has to be repeated or terminates with error if the source should not\n      * be repeated.\n      */\n-    public static IntFunction<Completable> repeatWithExponentialBackoffAndJitter(final int maxRepeats,\n-                                                                                 final Duration initialDelay,\n-                                                                                 final Executor timerExecutor) {\n+    public static IntFunction<Completable> repeatWithExponentialBackoffDeltaJitter(final int maxRepeats,\n+                                                                                   final Duration initialDelay,\n+                                                                                   final Duration jitter,\n+                                                                                   final Duration maxDelay,\n+                                                                                   final Executor timerExecutor) {\n+        checkMaxRetries(maxRepeats);\n         requireNonNull(timerExecutor);\n         final long initialDelayNanos = initialDelay.toNanos();\n+        final long jitterNanos = jitter.toNanos();\n+        final long maxDelayNanos = maxDelay.toNanos();\n+        final long maxInitialShift = maxShift(initialDelayNanos);\n         return repeatCount -> {\n             if (repeatCount > maxRepeats) {\n                 return terminateRepeat();\n             }\n-            return timerExecutor.timer(ThreadLocalRandom.current().nextLong(0, initialDelayNanos << (repeatCount - 1)),\n+            final long baseDelayNanos = initialDelayNanos << min(maxInitialShift, repeatCount - 1);\n+            return timerExecutor.timer(\n+                    current().nextLong(min(0, baseDelayNanos - jitterNanos),", "originalCommit": "4092a4c8a0f5624a39368df24abaf3e143410030", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1d68adba852c403ea9b6990b7db90fdf311d5e0b", "url": "https://github.com/apple/servicetalk/commit/1d68adba852c403ea9b6990b7db90fdf311d5e0b", "message": "review comments", "committedDate": "2020-11-20T01:06:39Z", "type": "commit"}]}