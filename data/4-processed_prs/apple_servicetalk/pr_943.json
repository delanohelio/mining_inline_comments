{"pr_number": 943, "pr_title": "Optimize `ProtoBufSerializationProvider` by minimizing copying", "pr_createdAt": "2020-02-20T17:25:53Z", "pr_url": "https://github.com/apple/servicetalk/pull/943", "timeline": [{"oid": "e0dcea54c75ac779a0bf7011c5dff728969cbc06", "url": "https://github.com/apple/servicetalk/commit/e0dcea54c75ac779a0bf7011c5dff728969cbc06", "message": "Optimize `ProtoBufSerializationProvider` by minimizing copying\n\nMotivation:\n\nCurrent implementation of `ProtoBufSerializationProvider` has a\nfew performance issues:\n1. `ProtoDeserializer` may create an intermediate copy of composite\nbuffers and then copy it again inside proto parser.\n2. `DefaultSerializer.DEFAULT_SIZE_ESTIMATOR` inaccurately predicts\nsize for destination `Buffer`. For aggregated API we may use\n`getSerializedSize()` to allocate enough bytes for destination\n`Buffer`.\n3. `MessageLite.writeTo(OutputStream)` creates internal copy of\ndata that could be avoided if we create `CodedOutputStream` from\ninternal data storage of destination `Buffer`.\n\nModifications:\n\n- Create optimized version of `CodedInputStream` for\n`ProtoDeserializer` to do less copying during proto deserialization;\n- Provide number of `bytesEstimate` for serialization for aggregated\nAPI;\n- Create optimized version of `CodedOutputStream` for\n`ProtoSerializer` to do less copying during proto serialization;\n\nResults:\n\nLess copying during protobuf serialization/deserialization leads to\nimproved throughput by 5-15% on the gRPC client and server when\nthey (de)serialize 16Kb payload body.", "committedDate": "2020-02-20T01:17:24Z", "type": "commit"}, {"oid": "acb742cab2dde59acba468dfc840907cca5b3662", "url": "https://github.com/apple/servicetalk/commit/acb742cab2dde59acba468dfc840907cca5b3662", "message": "add comment for METADATA_SIZE", "committedDate": "2020-02-20T17:27:12Z", "type": "commit"}, {"oid": "2ce88ebbf332e284532c9d794815948ee1096d0f", "url": "https://github.com/apple/servicetalk/commit/2ce88ebbf332e284532c9d794815948ee1096d0f", "message": "update copyright headers", "committedDate": "2020-02-20T18:12:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNzM2OQ==", "url": "https://github.com/apple/servicetalk/pull/943#discussion_r382337369", "bodyText": "Is this check necessary since we will only be in this else block if toDeserialize.nioBufferCount() > 1?", "author": "NiteshKant", "createdAt": "2020-02-21T00:35:13Z", "path": "servicetalk-grpc-protobuf/src/main/java/io/servicetalk/grpc/protobuf/ProtoBufSerializationProvider.java", "diffHunk": "@@ -146,7 +150,22 @@ private static boolean isCompressed(Buffer buffer) throws SerializationException\n \n                     final T t;\n                     try {\n-                        t = parser.parseFrom(toDeserialize.toNioBuffer(toDeserialize.readerIndex(), lengthOfData));\n+                        final CodedInputStream in;\n+                        if (toDeserialize.nioBufferCount() == 1) {\n+                            in = CodedInputStream.newInstance(toDeserialize.toNioBuffer(toDeserialize.readerIndex(),\n+                                    lengthOfData));\n+                        } else {\n+                            // Aggregated payload body may consist of multiple Buffers. In this case,\n+                            // CompositeBuffer.toNioBuffer(idx, length) may return a single ByteBuffer (when requested\n+                            // length < components[0].length) or create a new ByteBuffer and copy multiple components\n+                            // into it. Later, proto parser will copy data from this temporary ByteBuffer again.\n+                            // To avoid unnecessary copying, we use newCodedInputStream(buffers, lengthOfData).\n+                            final ByteBuffer[] buffers = toDeserialize.toNioBuffers(toDeserialize.readerIndex(),\n+                                    lengthOfData);\n+                            in = buffers.length == 1 ? CodedInputStream.newInstance(buffers[0]) :", "originalCommit": "2ce88ebbf332e284532c9d794815948ee1096d0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3NjUwNg==", "url": "https://github.com/apple/servicetalk/pull/943#discussion_r382376506", "bodyText": "Yes, this is described in the comment above. toDeserialize.nioBufferCount() does not account for a requested length. We may be in a situation when the CompositeBuffer has 2 or more buffers internally (and those buffers may contain multiple proto messages), but we request only a few bytes (single proto message) that could be read from the first internal buffer. In this case, toDeserialize.toNioBuffers(..., length) may return an array that has only the first internal ByteBuffer, not all the internal buffers.", "author": "idelpivnitskiy", "createdAt": "2020-02-21T03:10:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNzM2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0MjE2NA==", "url": "https://github.com/apple/servicetalk/pull/943#discussion_r382342164", "bodyText": "Wondering why we can not use ByteString.unsafeWrap() and aliasing for toDeserialize.nioBufferCount() == 1 case also? We are pretty sure that the buffer will not be mutated between creation of CodedInputStream and usage by the parser.", "author": "NiteshKant", "createdAt": "2020-02-21T00:52:43Z", "path": "servicetalk-grpc-protobuf/src/main/java/io/servicetalk/grpc/protobuf/ProtoBufSerializationProvider.java", "diffHunk": "@@ -186,6 +205,23 @@ private static boolean isCompressed(Buffer buffer) throws SerializationException\n             }\n         }\n \n+        private static CodedInputStream newCodedInputStream(final ByteBuffer[] buffers, final int lengthOfData) {\n+            // Because we allocated a new internal ByteBuffer that will never be mutated we may just wrap it and\n+            // enable aliasing to avoid an extra copying inside parser for a deserialized message.\n+            final CodedInputStream in = unsafeWrap(mergeByteBuffers(buffers, lengthOfData)).newCodedInput();", "originalCommit": "2ce88ebbf332e284532c9d794815948ee1096d0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3MzM4Ng==", "url": "https://github.com/apple/servicetalk/pull/943#discussion_r382373386", "bodyText": "If toDeserialize.nioBufferCount() == 1, the Buffer will not create a new copy when we do toDeserialize.toNioBuffer(...). Instead, it will return a ByteBuffer wrapper that shares the same internal array.\nBecause users have a way to access the original Buffer using http filters, we can not guarantee that they do not modify the internal array. Therefore, by default we need to be safe. However, we can provide a configuration option for ProtoBufSerializationProviderBuilder and GrpcClientBuilder/GrpcServerBuilder to do zero-copying deserialization when users sure that they do not touch the payload body in any other way.", "author": "idelpivnitskiy", "createdAt": "2020-02-21T02:57:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0MjE2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0MzA1Ng==", "url": "https://github.com/apple/servicetalk/pull/943#discussion_r382343056", "bodyText": "If the size is not memoized, getSerializedSize() will use reflection to calculate the size. Is that worth the size optimization here?", "author": "NiteshKant", "createdAt": "2020-02-21T00:55:35Z", "path": "servicetalk-grpc-protobuf/src/main/java/io/servicetalk/grpc/protobuf/ProtoBufSerializationProviderBuilder.java", "diffHunk": "@@ -155,7 +157,7 @@ public GrpcSerializationProvider build() {\n         @Override\n         public Buffer serialize(final HttpHeaders headers, final T value, final BufferAllocator allocator) {\n             addContentHeaders(headers);\n-            return serializer.serialize(value, allocator);\n+            return serializer.serialize(value, allocator, METADATA_SIZE + value.getSerializedSize());", "originalCommit": "2ce88ebbf332e284532c9d794815948ee1096d0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3ODM2OA==", "url": "https://github.com/apple/servicetalk/pull/943#discussion_r382378368", "bodyText": "We invoke getSerializedSize() anyway to fill in the metadata later. So, we do not pay the reflection cost twice. Without this, profiling shows that we frequently expand the buffer during writeTo because it can not fit the serialized proto.", "author": "idelpivnitskiy", "createdAt": "2020-02-21T03:19:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0MzA1Ng=="}], "type": "inlineReview"}]}