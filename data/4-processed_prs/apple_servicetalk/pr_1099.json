{"pr_number": 1099, "pr_title": "Security handshake observability", "pr_createdAt": "2020-07-19T17:06:17Z", "pr_url": "https://github.com/apple/servicetalk/pull/1099", "timeline": [{"oid": "04281cb1c4deb3942ab14abc50d22e687b544e0f", "url": "https://github.com/apple/servicetalk/commit/04281cb1c4deb3942ab14abc50d22e687b544e0f", "message": "Implement SecurityHandshakeObserver", "committedDate": "2020-07-17T18:21:19Z", "type": "commit"}, {"oid": "47153596b8e58a8ec776d0f7c4dc1dd061e8add5", "url": "https://github.com/apple/servicetalk/commit/47153596b8e58a8ec776d0f7c4dc1dd061e8add5", "message": "Test SecurityHandshakeObserver", "committedDate": "2020-07-17T18:21:33Z", "type": "commit"}, {"oid": "e56af97bc5465a1a4a309b33648e31218ba7c84d", "url": "https://github.com/apple/servicetalk/commit/e56af97bc5465a1a4a309b33648e31218ba7c84d", "message": "Test SecurityHandshakeObserver in a separate class", "committedDate": "2020-07-17T18:54:28Z", "type": "commit"}, {"oid": "f70c7cece44149c9b5f1bec0c38c2b00c9c1321f", "url": "https://github.com/apple/servicetalk/commit/f70c7cece44149c9b5f1bec0c38c2b00c9c1321f", "message": "Add SecureTcpTransportObserverErrorsTest", "committedDate": "2020-07-18T02:06:59Z", "type": "commit"}, {"oid": "e72b73f6cb65ed565f69b95ab73b117d0fb2f779", "url": "https://github.com/apple/servicetalk/commit/e72b73f6cb65ed565f69b95ab73b117d0fb2f779", "message": "Fix checkstyle errors", "committedDate": "2020-07-18T02:10:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY3MDgzNg==", "url": "https://github.com/apple/servicetalk/pull/1099#discussion_r457670836", "bodyText": "nit: Rename observable to observeSsl", "author": "NiteshKant", "createdAt": "2020-07-20T20:25:17Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DeferSslHandler.java", "diffHunk": "@@ -20,22 +20,29 @@\n import io.netty.channel.ChannelHandler;\n import io.netty.handler.ssl.SslHandler;\n \n+import static io.servicetalk.transport.netty.internal.TransportObserverUtils.reportSecurityHandshakeStarting;\n+\n /**\n  * A {@link ChannelHandler} that holds a place in a pipeline, allowing us to defer adding the {@link SslHandler}.\n  */\n-public class DeferSslHandler extends ChannelDuplexHandler {\n+public final class DeferSslHandler extends ChannelDuplexHandler {\n     private final Channel channel;\n     private final SslHandler handler;\n+    private final boolean observable;\n \n-    DeferSslHandler(final Channel channel, final SslHandler handler) {\n+    DeferSslHandler(final Channel channel, final SslHandler handler, final boolean observable) {", "originalCommit": "e72b73f6cb65ed565f69b95ab73b117d0fb2f779", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc4NjIzMw==", "url": "https://github.com/apple/servicetalk/pull/1099#discussion_r457786233", "bodyText": "rename to handshakeStartNotified to indicate that this does not reflect handshake start state but the notification to the observer.", "author": "NiteshKant", "createdAt": "2020-07-21T01:43:22Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/TransportObserverInitializer.java", "diffHunk": "@@ -16,46 +16,93 @@\n package io.servicetalk.transport.netty.internal;\n \n import io.servicetalk.transport.api.ConnectionObserver;\n+import io.servicetalk.transport.api.ConnectionObserver.SecurityHandshakeObserver;\n import io.servicetalk.transport.api.TransportObserver;\n \n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.ByteBufHolder;\n import io.netty.channel.Channel;\n import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPipeline;\n import io.netty.channel.ChannelPromise;\n+import io.netty.handler.ssl.SslHandshakeCompletionEvent;\n \n+import javax.net.ssl.SSLSession;\n+\n+import static io.servicetalk.transport.netty.internal.NettyPipelineSslUtils.extractSslSession;\n+import static io.servicetalk.transport.netty.internal.TransportObserverUtils.assignConnectionError;\n import static io.servicetalk.transport.netty.internal.TransportObserverUtils.assignConnectionObserver;\n+import static io.servicetalk.transport.netty.internal.TransportObserverUtils.securityHandshakeObserver;\n import static java.util.Objects.requireNonNull;\n \n /**\n  * A {@link ChannelInitializer} that registers a {@link ConnectionObserver} for all channels.\n  */\n public final class TransportObserverInitializer implements ChannelInitializer {\n \n+    /**\n+     * Tells which side is using secure connection.\n+     */\n+    public enum SecureSide {\n+        CLIENT,\n+        SERVER,\n+        NONE\n+    }\n+\n     private final TransportObserver transportObserver;\n+    private final SecureSide secureSide;\n \n     /**\n      * Creates a new instance.\n      *\n      * @param transportObserver {@link TransportObserver} to initialize for the channel\n+     * @param secureSide tells which side is using secure connection\n      */\n-    public TransportObserverInitializer(final TransportObserver transportObserver) {\n+    public TransportObserverInitializer(final TransportObserver transportObserver, final SecureSide secureSide) {\n         this.transportObserver = requireNonNull(transportObserver);\n+        this.secureSide = secureSide;\n     }\n \n     @Override\n     public void init(final Channel channel) {\n         final ConnectionObserver observer = requireNonNull(transportObserver.onNewConnection());\n         assignConnectionObserver(channel, observer);\n-        channel.pipeline().addLast(new TransportObserverChannelHandler(observer));\n+        final ChannelPipeline pipeline = channel.pipeline();\n+        pipeline.addLast(new TransportObserverHandler(observer, secureSide));\n     }\n \n-    private static final class TransportObserverChannelHandler extends ChannelDuplexHandler {\n+    private static final class TransportObserverHandler extends ChannelDuplexHandler {\n         private final ConnectionObserver observer;\n+        private final SecureSide secure;\n+        private boolean handshakeStarted;", "originalCommit": "e72b73f6cb65ed565f69b95ab73b117d0fb2f779", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc4NjM1Mg==", "url": "https://github.com/apple/servicetalk/pull/1099#discussion_r457786352", "bodyText": "Set this before sending the callback to account for reentrancy?", "author": "NiteshKant", "createdAt": "2020-07-21T01:43:47Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/TransportObserverInitializer.java", "diffHunk": "@@ -16,46 +16,93 @@\n package io.servicetalk.transport.netty.internal;\n \n import io.servicetalk.transport.api.ConnectionObserver;\n+import io.servicetalk.transport.api.ConnectionObserver.SecurityHandshakeObserver;\n import io.servicetalk.transport.api.TransportObserver;\n \n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.ByteBufHolder;\n import io.netty.channel.Channel;\n import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPipeline;\n import io.netty.channel.ChannelPromise;\n+import io.netty.handler.ssl.SslHandshakeCompletionEvent;\n \n+import javax.net.ssl.SSLSession;\n+\n+import static io.servicetalk.transport.netty.internal.NettyPipelineSslUtils.extractSslSession;\n+import static io.servicetalk.transport.netty.internal.TransportObserverUtils.assignConnectionError;\n import static io.servicetalk.transport.netty.internal.TransportObserverUtils.assignConnectionObserver;\n+import static io.servicetalk.transport.netty.internal.TransportObserverUtils.securityHandshakeObserver;\n import static java.util.Objects.requireNonNull;\n \n /**\n  * A {@link ChannelInitializer} that registers a {@link ConnectionObserver} for all channels.\n  */\n public final class TransportObserverInitializer implements ChannelInitializer {\n \n+    /**\n+     * Tells which side is using secure connection.\n+     */\n+    public enum SecureSide {\n+        CLIENT,\n+        SERVER,\n+        NONE\n+    }\n+\n     private final TransportObserver transportObserver;\n+    private final SecureSide secureSide;\n \n     /**\n      * Creates a new instance.\n      *\n      * @param transportObserver {@link TransportObserver} to initialize for the channel\n+     * @param secureSide tells which side is using secure connection\n      */\n-    public TransportObserverInitializer(final TransportObserver transportObserver) {\n+    public TransportObserverInitializer(final TransportObserver transportObserver, final SecureSide secureSide) {\n         this.transportObserver = requireNonNull(transportObserver);\n+        this.secureSide = secureSide;\n     }\n \n     @Override\n     public void init(final Channel channel) {\n         final ConnectionObserver observer = requireNonNull(transportObserver.onNewConnection());\n         assignConnectionObserver(channel, observer);\n-        channel.pipeline().addLast(new TransportObserverChannelHandler(observer));\n+        final ChannelPipeline pipeline = channel.pipeline();\n+        pipeline.addLast(new TransportObserverHandler(observer, secureSide));\n     }\n \n-    private static final class TransportObserverChannelHandler extends ChannelDuplexHandler {\n+    private static final class TransportObserverHandler extends ChannelDuplexHandler {\n         private final ConnectionObserver observer;\n+        private final SecureSide secure;\n+        private boolean handshakeStarted;\n \n-        TransportObserverChannelHandler(final ConnectionObserver observer) {\n+        TransportObserverHandler(final ConnectionObserver observer, final SecureSide secure) {\n             this.observer = observer;\n+            this.secure = secure;\n+        }\n+\n+        @Override\n+        public void handlerAdded(final ChannelHandlerContext ctx) {\n+            if (secure != SecureSide.NONE && ctx.channel().isActive()) {\n+                reportSecurityHandshakeStarting(ctx.channel());\n+            }\n+        }\n+\n+        @Override\n+        public void channelActive(final ChannelHandlerContext ctx) {\n+            if (secure == SecureSide.CLIENT) {\n+                reportSecurityHandshakeStarting(ctx.channel());\n+            }\n+            ctx.fireChannelActive();\n+        }\n+\n+        void reportSecurityHandshakeStarting(final Channel channel) {\n+            if (!handshakeStarted) {\n+                TransportObserverUtils.reportSecurityHandshakeStarting(channel);\n+                handshakeStarted = true;", "originalCommit": "e72b73f6cb65ed565f69b95ab73b117d0fb2f779", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc4Njc3Ng==", "url": "https://github.com/apple/servicetalk/pull/1099#discussion_r457786776", "bodyText": "Why is the condition in handlerAdded and channelActive different?\nIf this is valid, then add a comment to explain the same.", "author": "NiteshKant", "createdAt": "2020-07-21T01:45:16Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/TransportObserverInitializer.java", "diffHunk": "@@ -16,46 +16,93 @@\n package io.servicetalk.transport.netty.internal;\n \n import io.servicetalk.transport.api.ConnectionObserver;\n+import io.servicetalk.transport.api.ConnectionObserver.SecurityHandshakeObserver;\n import io.servicetalk.transport.api.TransportObserver;\n \n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.ByteBufHolder;\n import io.netty.channel.Channel;\n import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPipeline;\n import io.netty.channel.ChannelPromise;\n+import io.netty.handler.ssl.SslHandshakeCompletionEvent;\n \n+import javax.net.ssl.SSLSession;\n+\n+import static io.servicetalk.transport.netty.internal.NettyPipelineSslUtils.extractSslSession;\n+import static io.servicetalk.transport.netty.internal.TransportObserverUtils.assignConnectionError;\n import static io.servicetalk.transport.netty.internal.TransportObserverUtils.assignConnectionObserver;\n+import static io.servicetalk.transport.netty.internal.TransportObserverUtils.securityHandshakeObserver;\n import static java.util.Objects.requireNonNull;\n \n /**\n  * A {@link ChannelInitializer} that registers a {@link ConnectionObserver} for all channels.\n  */\n public final class TransportObserverInitializer implements ChannelInitializer {\n \n+    /**\n+     * Tells which side is using secure connection.\n+     */\n+    public enum SecureSide {\n+        CLIENT,\n+        SERVER,\n+        NONE\n+    }\n+\n     private final TransportObserver transportObserver;\n+    private final SecureSide secureSide;\n \n     /**\n      * Creates a new instance.\n      *\n      * @param transportObserver {@link TransportObserver} to initialize for the channel\n+     * @param secureSide tells which side is using secure connection\n      */\n-    public TransportObserverInitializer(final TransportObserver transportObserver) {\n+    public TransportObserverInitializer(final TransportObserver transportObserver, final SecureSide secureSide) {\n         this.transportObserver = requireNonNull(transportObserver);\n+        this.secureSide = secureSide;\n     }\n \n     @Override\n     public void init(final Channel channel) {\n         final ConnectionObserver observer = requireNonNull(transportObserver.onNewConnection());\n         assignConnectionObserver(channel, observer);\n-        channel.pipeline().addLast(new TransportObserverChannelHandler(observer));\n+        final ChannelPipeline pipeline = channel.pipeline();\n+        pipeline.addLast(new TransportObserverHandler(observer, secureSide));\n     }\n \n-    private static final class TransportObserverChannelHandler extends ChannelDuplexHandler {\n+    private static final class TransportObserverHandler extends ChannelDuplexHandler {\n         private final ConnectionObserver observer;\n+        private final SecureSide secure;\n+        private boolean handshakeStarted;\n \n-        TransportObserverChannelHandler(final ConnectionObserver observer) {\n+        TransportObserverHandler(final ConnectionObserver observer, final SecureSide secure) {\n             this.observer = observer;\n+            this.secure = secure;\n+        }\n+\n+        @Override\n+        public void handlerAdded(final ChannelHandlerContext ctx) {\n+            if (secure != SecureSide.NONE && ctx.channel().isActive()) {\n+                reportSecurityHandshakeStarting(ctx.channel());\n+            }\n+        }\n+\n+        @Override\n+        public void channelActive(final ChannelHandlerContext ctx) {\n+            if (secure == SecureSide.CLIENT) {", "originalCommit": "e72b73f6cb65ed565f69b95ab73b117d0fb2f779", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM1MzAzNg==", "url": "https://github.com/apple/servicetalk/pull/1099#discussion_r458353036", "bodyText": "That was my overthinking :) Channel is already active when server adds a handler. Therefore, there is no need to expect channelActive on the server-side. But we can make conditions the same with no side-effects. Thanks!", "author": "idelpivnitskiy", "createdAt": "2020-07-21T19:59:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc4Njc3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc4ODYyMg==", "url": "https://github.com/apple/servicetalk/pull/1099#discussion_r457788622", "bodyText": "We are already intercepting this event and extract SSL session in DefaultNettyConnection, can we do these callbacks there instead of adding another handler?", "author": "NiteshKant", "createdAt": "2020-07-21T01:51:42Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/TransportObserverInitializer.java", "diffHunk": "@@ -92,4 +139,32 @@ public void flush(final ChannelHandlerContext ctx) {\n             ctx.flush();\n         }\n     }\n+\n+    @Sharable\n+    static final class SecurityHandshakeObserverHandler extends ChannelDuplexHandler {\n+\n+        static final SecurityHandshakeObserverHandler INSTANCE = new SecurityHandshakeObserverHandler();\n+\n+        private SecurityHandshakeObserverHandler() {\n+            // Singleton\n+        }\n+\n+        @Override\n+        public void userEventTriggered(final ChannelHandlerContext ctx, final Object evt) {\n+            if (evt instanceof SslHandshakeCompletionEvent) {\n+                final Channel channel = ctx.channel();\n+                final SecurityHandshakeObserver observer = securityHandshakeObserver(channel);\n+                assert observer != null;\n+                final SSLSession sslSession = extractSslSession(ctx.pipeline(), (SslHandshakeCompletionEvent) evt,", "originalCommit": "e72b73f6cb65ed565f69b95ab73b117d0fb2f779", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM1NTE0MQ==", "url": "https://github.com/apple/servicetalk/pull/1099#discussion_r458355141", "bodyText": "There is H2ParentConnectionContext that also performs a similar logic, but this class is from servicetalk-http-netty.\nThe goal to have SecurityHandshakeObserverHandler is to encapsulate everything related to transport observer in servicetalk-transport-netty-internal. For users who are interested in observability, it looks like small and acceptable overhead.", "author": "idelpivnitskiy", "createdAt": "2020-07-21T20:03:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc4ODYyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQwODk2Nw==", "url": "https://github.com/apple/servicetalk/pull/1099#discussion_r458408967", "bodyText": "Moved this logic to NettyPipelineSslUtils.extractSslSession instead: e118cd1", "author": "idelpivnitskiy", "createdAt": "2020-07-21T21:49:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc4ODYyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc4OTk0NQ==", "url": "https://github.com/apple/servicetalk/pull/1099#discussion_r457789945", "bodyText": "The name is confusing since TLS can not be on one side.\nI think this enum is overloaded to give two piece of information:\n\nWhether TLS is enabled.\nWhether this initializer is used by client/server.\n\nTo avoid confusion caused by this overload, I would suggest splitting this into two fields:\n\nboolean isSecure\nboolean forClient\n\nThis is similar to what we do for security config.", "author": "NiteshKant", "createdAt": "2020-07-21T01:56:09Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/TransportObserverInitializer.java", "diffHunk": "@@ -16,46 +16,93 @@\n package io.servicetalk.transport.netty.internal;\n \n import io.servicetalk.transport.api.ConnectionObserver;\n+import io.servicetalk.transport.api.ConnectionObserver.SecurityHandshakeObserver;\n import io.servicetalk.transport.api.TransportObserver;\n \n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.ByteBufHolder;\n import io.netty.channel.Channel;\n import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPipeline;\n import io.netty.channel.ChannelPromise;\n+import io.netty.handler.ssl.SslHandshakeCompletionEvent;\n \n+import javax.net.ssl.SSLSession;\n+\n+import static io.servicetalk.transport.netty.internal.NettyPipelineSslUtils.extractSslSession;\n+import static io.servicetalk.transport.netty.internal.TransportObserverUtils.assignConnectionError;\n import static io.servicetalk.transport.netty.internal.TransportObserverUtils.assignConnectionObserver;\n+import static io.servicetalk.transport.netty.internal.TransportObserverUtils.securityHandshakeObserver;\n import static java.util.Objects.requireNonNull;\n \n /**\n  * A {@link ChannelInitializer} that registers a {@link ConnectionObserver} for all channels.\n  */\n public final class TransportObserverInitializer implements ChannelInitializer {\n \n+    /**\n+     * Tells which side is using secure connection.\n+     */\n+    public enum SecureSide {", "originalCommit": "e72b73f6cb65ed565f69b95ab73b117d0fb2f779", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5c0481484501cc689842d0902bf1a9895ae516a8", "url": "https://github.com/apple/servicetalk/commit/5c0481484501cc689842d0902bf1a9895ae516a8", "message": "Address comments", "committedDate": "2020-07-21T18:40:03Z", "type": "commit"}, {"oid": "8b3518173bf28915537ebe5f9117d0531fbfab40", "url": "https://github.com/apple/servicetalk/commit/8b3518173bf28915537ebe5f9117d0531fbfab40", "message": "Fix a test that fails on JDK8", "committedDate": "2020-07-21T19:56:28Z", "type": "commit"}, {"oid": "cc619f8fbe25623f874ce9b3e73811a593ceeda0", "url": "https://github.com/apple/servicetalk/commit/cc619f8fbe25623f874ce9b3e73811a593ceeda0", "message": "Revert `final` from DeferSslHandler, otherwise we can not mock it", "committedDate": "2020-07-21T20:21:17Z", "type": "commit"}, {"oid": "e118cd1c3dbf862f5d4a4e8fe1467bffdfdeb7db", "url": "https://github.com/apple/servicetalk/commit/e118cd1c3dbf862f5d4a4e8fe1467bffdfdeb7db", "message": "Remove SecurityHandshakeObserverHandler and add observability hooks to NettyPipelineSslUtils.extractSslSession", "committedDate": "2020-07-21T21:43:00Z", "type": "commit"}, {"oid": "533d53f6b39ec010f3e6040f0af825cc605b7773", "url": "https://github.com/apple/servicetalk/commit/533d53f6b39ec010f3e6040f0af825cc605b7773", "message": "Small fixes", "committedDate": "2020-07-21T21:48:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ1NjAyMQ==", "url": "https://github.com/apple/servicetalk/pull/1099#discussion_r458456021", "bodyText": "Since extractSslSession sounds like a method with no side effects; I would suggest either renaming the method or create an overload which explicitly says that it emits observer events.", "author": "NiteshKant", "createdAt": "2020-07-21T23:59:22Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/NettyPipelineSslUtils.java", "diffHunk": "@@ -55,17 +61,33 @@ public static boolean isSslEnabled(ChannelPipeline pipeline) {\n     public static SSLSession extractSslSession(ChannelPipeline pipeline,", "originalCommit": "533d53f6b39ec010f3e6040f0af825cc605b7773", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fb4ffa4e28455d888351c8f6552acabfe9e401ea", "url": "https://github.com/apple/servicetalk/commit/fb4ffa4e28455d888351c8f6552acabfe9e401ea", "message": "Rename NettyPipelineSslUtils.extractSslSession", "committedDate": "2020-07-22T01:11:04Z", "type": "commit"}]}