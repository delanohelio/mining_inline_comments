{"pr_number": 976, "pr_title": "NettyChannelPublisher cancel active subscriber should terminate", "pr_createdAt": "2020-03-23T16:20:11Z", "pr_url": "https://github.com/apple/servicetalk/pull/976", "timeline": [{"oid": "3cf0a1c97111b957f6c26634efda2fa96ed40b26", "url": "https://github.com/apple/servicetalk/commit/3cf0a1c97111b957f6c26634efda2fa96ed40b26", "message": "NettyChannelPublisher cancel active subscriber should terminate\n\nMotivation:\nNettyChannelPublisher allows for resubscribes, and delivers queued data to the new Subscriber. If the previous Subscriber consumed some data and cancelled this may lead to the new Subscriber receiveing partial data from the last request.\n\nModifications:\n- NettyChannelPublisher should discard any pending data, and deliver an error to new Subscribers if a previously active Subscriber cancels.\n\nResult:\nResubscribes to NettyChannelPublisher won't get partial data for previous requests, like in the case of client pipelinining.", "committedDate": "2020-03-23T16:19:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY2MDMzNw==", "url": "https://github.com/apple/servicetalk/pull/976#discussion_r396660337", "bodyText": "Can you also add a test that does a channelRead() between cancel() and re-subscribe? That will re-initialize the pending queue.", "author": "NiteshKant", "createdAt": "2020-03-23T18:18:20Z", "path": "servicetalk-transport-netty-internal/src/test/java/io/servicetalk/transport/netty/internal/NettyChannelPublisherTest.java", "diffHunk": "@@ -111,6 +113,27 @@ public void tearDown() throws Exception {\n         }\n     }\n \n+    @Test\n+    public void testCancelThenResubscribeDeliversErrorAndNotQueuedData() throws InterruptedException {\n+        TestCollectingPublisherSubscriber<Integer> subscriber1 = new TestCollectingPublisherSubscriber<>();\n+        TestCollectingPublisherSubscriber<Integer> subscriber2 = new TestCollectingPublisherSubscriber<>();\n+        toSource(publisher).subscribe(subscriber1);\n+        Subscription subscription1 = subscriber1.awaitSubscription();\n+        subscription1.request(1);\n+\n+        assertFalse(channel.writeInbound(1));\n+        Integer next = subscriber1.takeOnNext();\n+        assertThat(next, is(1));\n+        assertFalse(channel.writeInbound(2)); // this write should be queued, because there isn't any requestN demand.\n+\n+        subscription1.cancel(); // cancel of active subscription should clear the queue and fail future Subscribers.\n+\n+        toSource(publisher).subscribe(subscriber2);", "originalCommit": "3cf0a1c97111b957f6c26634efda2fa96ed40b26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgyNDgxMw==", "url": "https://github.com/apple/servicetalk/pull/976#discussion_r396824813", "bodyText": "The cancel operation does a shutdownInput so no more data should be delivered by Netty via channelRead. EmbeddedChannel throws ClosedChannelException if I try to deliver more data, and I will add a test for this.", "author": "Scottmitch", "createdAt": "2020-03-23T23:44:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY2MDMzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUyNTY2MA==", "url": "https://github.com/apple/servicetalk/pull/976#discussion_r397525660", "bodyText": "The case I was trying to get to was when data is enqueued in the channel when cancel() happens in which case Netty should deliver data first and then the shutdown. We do not have to go out of our way to verify the scenario but looks like having a handler that buffers data could do the trick?", "author": "NiteshKant", "createdAt": "2020-03-24T23:36:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY2MDMzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU3ODkwNw==", "url": "https://github.com/apple/servicetalk/pull/976#discussion_r397578907", "bodyText": "good call ... I was trying to get away with avoiding additional conditional in channelRead but it is helpful to avoid this case.", "author": "Scottmitch", "createdAt": "2020-03-25T02:46:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY2MDMzNw=="}], "type": "inlineReview"}, {"oid": "5ebb001e0311bfa10888e2f97eee931cdc12015b", "url": "https://github.com/apple/servicetalk/commit/5ebb001e0311bfa10888e2f97eee931cdc12015b", "message": "review comments", "committedDate": "2020-03-23T23:45:47Z", "type": "commit"}, {"oid": "5ebb001e0311bfa10888e2f97eee931cdc12015b", "url": "https://github.com/apple/servicetalk/commit/5ebb001e0311bfa10888e2f97eee931cdc12015b", "message": "review comments", "committedDate": "2020-03-23T23:45:47Z", "type": "forcePushed"}, {"oid": "b9b9d85852e388fdccb43e58dbb64559f7be47f8", "url": "https://github.com/apple/servicetalk/commit/b9b9d85852e388fdccb43e58dbb64559f7be47f8", "message": "more robust handling of fatalError and queuing", "committedDate": "2020-03-25T02:56:32Z", "type": "commit"}, {"oid": "1ad4912e9344eb326009e5908f7cd2d9a472e583", "url": "https://github.com/apple/servicetalk/commit/1ad4912e9344eb326009e5908f7cd2d9a472e583", "message": "fix checkstyle", "committedDate": "2020-03-25T03:47:53Z", "type": "commit"}]}