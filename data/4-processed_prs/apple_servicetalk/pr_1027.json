{"pr_number": 1027, "pr_title": "Add `Publisher#buffer` operator", "pr_createdAt": "2020-04-18T23:55:53Z", "pr_url": "https://github.com/apple/servicetalk/pull/1027", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE0ODczNA==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r411148734", "bodyText": "nit: add java doc", "author": "normanmaurer", "createdAt": "2020-04-20T07:18:10Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Collectors.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.CompletableSource.Subscriber;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.handleExceptionFromOnSubscribe;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n+\n+/**\n+ * A factory for creating a {@link Collector} factory and an optional buffer boundaries {@link Publisher} for\n+ * typical buffering needs.\n+ */\n+final class Collectors {\n+\n+    private Collectors() {\n+        // no instances\n+    }\n+\n+    static <T> CollectorFactory<T> forSizeOrDuration(final int bufferSize, final Duration duration,\n+                                                     final Executor executor) {\n+        SizeBasedSignal sizeBasedSignal = new SizeBasedSignal(bufferSize);\n+        return new DefaultCollectorFactory<>(sizeBasedSignal,\n+                sizeBasedSignal.ambWith(executor.timer(duration).beforeOnComplete(sizeBasedSignal::reset))\n+                        .repeat(__ -> true));\n+    }\n+\n+    /**\n+     * A {@link Supplier} of {@link Collector}s and a {@link Publisher} of buffer boundaries.\n+     *\n+     * @param <T> Type of items collected.\n+     */\n+    interface CollectorFactory<T> extends Supplier<Collector<T, Iterable<T>>> {\n+        Publisher<?> boundaries();", "originalCommit": "58ed3709d478a988f43f6607b808763f8a556dc4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE0OTk0OQ==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r411149949", "bodyText": "nit: I think we should throw in add after close was called. This should be part of the interface contract imho", "author": "normanmaurer", "createdAt": "2020-04-20T07:20:17Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Collectors.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.CompletableSource.Subscriber;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.handleExceptionFromOnSubscribe;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n+\n+/**\n+ * A factory for creating a {@link Collector} factory and an optional buffer boundaries {@link Publisher} for\n+ * typical buffering needs.\n+ */\n+final class Collectors {\n+\n+    private Collectors() {\n+        // no instances\n+    }\n+\n+    static <T> CollectorFactory<T> forSizeOrDuration(final int bufferSize, final Duration duration,\n+                                                     final Executor executor) {\n+        SizeBasedSignal sizeBasedSignal = new SizeBasedSignal(bufferSize);\n+        return new DefaultCollectorFactory<>(sizeBasedSignal,\n+                sizeBasedSignal.ambWith(executor.timer(duration).beforeOnComplete(sizeBasedSignal::reset))\n+                        .repeat(__ -> true));\n+    }\n+\n+    /**\n+     * A {@link Supplier} of {@link Collector}s and a {@link Publisher} of buffer boundaries.\n+     *\n+     * @param <T> Type of items collected.\n+     */\n+    interface CollectorFactory<T> extends Supplier<Collector<T, Iterable<T>>> {\n+        Publisher<?> boundaries();\n+    }\n+\n+    private static final class DefaultCollectorFactory<T> implements CollectorFactory<T> {\n+        private final SizeBasedSignal sizeBasedSignal;\n+        private final Publisher<?> boundaries;\n+\n+        DefaultCollectorFactory(final SizeBasedSignal sizeBasedSignal, final Publisher<?> boundaries) {\n+            this.sizeBasedSignal = sizeBasedSignal;\n+            this.boundaries = boundaries;\n+        }\n+\n+        @Override\n+        public Publisher<?> boundaries() {\n+            return boundaries;\n+        }\n+\n+        @Override\n+        public Collector<T, Iterable<T>> get() {\n+            return new ListCollector<>(sizeBasedSignal);\n+        }\n+    }\n+\n+    private static final class ListCollector<T> implements Collector<T, Iterable<T>> {\n+        private final List<T> buffer = new ArrayList<>();\n+        private final SizeBasedSignal sizeBasedSignal;\n+\n+        ListCollector(final SizeBasedSignal sizeBasedSignal) {\n+            this.sizeBasedSignal = sizeBasedSignal;\n+        }\n+\n+        @Override\n+        public void add(@Nullable final T t) {\n+            try {\n+                buffer.add(t);\n+            } finally {\n+                sizeBasedSignal.itemAdded();\n+            }\n+        }\n+\n+        @Override\n+        public Iterable<T> close() {", "originalCommit": "58ed3709d478a988f43f6607b808763f8a556dc4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE1MDQ5Mg==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r411150492", "bodyText": "ensure this is positive ?", "author": "normanmaurer", "createdAt": "2020-04-20T07:21:11Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Collectors.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.CompletableSource.Subscriber;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.handleExceptionFromOnSubscribe;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n+\n+/**\n+ * A factory for creating a {@link Collector} factory and an optional buffer boundaries {@link Publisher} for\n+ * typical buffering needs.\n+ */\n+final class Collectors {\n+\n+    private Collectors() {\n+        // no instances\n+    }\n+\n+    static <T> CollectorFactory<T> forSizeOrDuration(final int bufferSize, final Duration duration,\n+                                                     final Executor executor) {\n+        SizeBasedSignal sizeBasedSignal = new SizeBasedSignal(bufferSize);\n+        return new DefaultCollectorFactory<>(sizeBasedSignal,\n+                sizeBasedSignal.ambWith(executor.timer(duration).beforeOnComplete(sizeBasedSignal::reset))\n+                        .repeat(__ -> true));\n+    }\n+\n+    /**\n+     * A {@link Supplier} of {@link Collector}s and a {@link Publisher} of buffer boundaries.\n+     *\n+     * @param <T> Type of items collected.\n+     */\n+    interface CollectorFactory<T> extends Supplier<Collector<T, Iterable<T>>> {\n+        Publisher<?> boundaries();\n+    }\n+\n+    private static final class DefaultCollectorFactory<T> implements CollectorFactory<T> {\n+        private final SizeBasedSignal sizeBasedSignal;\n+        private final Publisher<?> boundaries;\n+\n+        DefaultCollectorFactory(final SizeBasedSignal sizeBasedSignal, final Publisher<?> boundaries) {\n+            this.sizeBasedSignal = sizeBasedSignal;\n+            this.boundaries = boundaries;\n+        }\n+\n+        @Override\n+        public Publisher<?> boundaries() {\n+            return boundaries;\n+        }\n+\n+        @Override\n+        public Collector<T, Iterable<T>> get() {\n+            return new ListCollector<>(sizeBasedSignal);\n+        }\n+    }\n+\n+    private static final class ListCollector<T> implements Collector<T, Iterable<T>> {\n+        private final List<T> buffer = new ArrayList<>();\n+        private final SizeBasedSignal sizeBasedSignal;\n+\n+        ListCollector(final SizeBasedSignal sizeBasedSignal) {\n+            this.sizeBasedSignal = sizeBasedSignal;\n+        }\n+\n+        @Override\n+        public void add(@Nullable final T t) {\n+            try {\n+                buffer.add(t);\n+            } finally {\n+                sizeBasedSignal.itemAdded();\n+            }\n+        }\n+\n+        @Override\n+        public Iterable<T> close() {\n+            return buffer;\n+        }\n+    }\n+\n+    private static final class SizeBasedSignal extends Completable {\n+        private static final AtomicIntegerFieldUpdater<SizeBasedSignal> pendingUpdater =\n+                newUpdater(SizeBasedSignal.class, \"pending\");\n+        private static final AtomicReferenceFieldUpdater<SizeBasedSignal, Subscriber> currentSubUpdater =\n+                AtomicReferenceFieldUpdater.newUpdater(SizeBasedSignal.class, Subscriber.class, \"currentSub\");\n+\n+        private final int bufferSize;\n+\n+        private volatile int pending;\n+        @Nullable\n+        private volatile Subscriber currentSub;\n+\n+        SizeBasedSignal(final int bufferSize) {\n+            this.bufferSize = bufferSize;", "originalCommit": "58ed3709d478a988f43f6607b808763f8a556dc4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE1NTM3OQ==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r411155379", "bodyText": "nit: this. to make it consistent", "author": "normanmaurer", "createdAt": "2020-04-20T07:29:57Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherBuffer.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n+\n+final class PublisherBuffer<T, B> extends AbstractAsynchronousPublisherOperator<T, B> {\n+\n+    private final Publisher<Collector<T, B>> bufferBoundaries;\n+    private final Supplier<Collector<T, B>> collectorFactory;\n+    private final int bufferSizeHint;\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final Publisher<?> bufferBoundaries, final Supplier<Collector<T, B>> collectorFactory) {\n+        this(original, executor, bufferBoundaries, collectorFactory, 16);\n+    }\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final Publisher<?> bufferBoundaries, final Supplier<Collector<T, B>> collectorFactory,\n+                    final int bufferSizeHint) {\n+        super(original, executor);\n+        if (bufferSizeHint <= 0) {\n+            throw new IllegalArgumentException(\"bufferSizeHint: \" + bufferSizeHint + \"(expected > 0)\");\n+        }\n+        this.collectorFactory = requireNonNull(collectorFactory);\n+        this.bufferBoundaries = bufferBoundaries.map(__ -> collectorFactory.get());\n+        this.bufferSizeHint = bufferSizeHint;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super B> subscriber) {\n+        return new BufferSubscriber<>(bufferBoundaries, subscriber, collectorFactory.get(), bufferSizeHint);\n+    }\n+\n+    private static final class BufferSubscriber<T, B> implements Subscriber<T> {\n+        private static final Object ADDING = new Object();\n+        private static final Object TERMINATED = new Object();\n+\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BufferSubscriber> pendingItemsUpdater =\n+                newUpdater(BufferSubscriber.class, \"pendingItems\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BufferSubscriber> pendingBuffersUpdater =\n+                newUpdater(BufferSubscriber.class, \"pendingBuffers\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<BufferSubscriber, Object> maybeCollectorUpdater =\n+                AtomicReferenceFieldUpdater.newUpdater(BufferSubscriber.class, Object.class,\n+                        \"maybeCollector\");\n+        private final Publisher<Collector<T, B>> boundaries;\n+        private final DelayedSubscription tSubscription;\n+        private final BoundariesSubscriber boundariesSubscriber;\n+        private final int bufferSizeHint;\n+        private volatile long pendingItems;\n+        private volatile long pendingBuffers;\n+        /**\n+         * Following values are assigned to this variable:\n+         * <ul>\n+         *     <li>{@link #ADDING} when {@link #onNext(Object)} is adding an item to the active buffer.</li>\n+         *     <li>An instance of {@link DelayedTermination} if the source should be terminated after emitting\n+         *     the buffer contained in that {@link DelayedTermination}.</li>\n+         *     <li>{@link #TERMINATED} if the target subscriber has been terminated.</li>\n+         *     <li>A {@link Collector} representing the current buffer.</li>\n+         * </ul>\n+         */\n+        @SuppressWarnings({\"FieldCanBeLocal\", \"FieldMayBeFinal\"})\n+        private volatile Object maybeCollector;\n+\n+        BufferSubscriber(final Publisher<Collector<T, B>> boundaries, final Subscriber<? super B> target,\n+                         final Collector<T, B> firstCollector, final int bufferSizeHint) {\n+            this.boundaries = boundaries;\n+            tSubscription = new DelayedSubscription();", "originalCommit": "58ed3709d478a988f43f6607b808763f8a556dc4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE1NTQyNQ==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r411155425", "bodyText": "nit: this. to make it consistent", "author": "normanmaurer", "createdAt": "2020-04-20T07:30:01Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherBuffer.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n+\n+final class PublisherBuffer<T, B> extends AbstractAsynchronousPublisherOperator<T, B> {\n+\n+    private final Publisher<Collector<T, B>> bufferBoundaries;\n+    private final Supplier<Collector<T, B>> collectorFactory;\n+    private final int bufferSizeHint;\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final Publisher<?> bufferBoundaries, final Supplier<Collector<T, B>> collectorFactory) {\n+        this(original, executor, bufferBoundaries, collectorFactory, 16);\n+    }\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final Publisher<?> bufferBoundaries, final Supplier<Collector<T, B>> collectorFactory,\n+                    final int bufferSizeHint) {\n+        super(original, executor);\n+        if (bufferSizeHint <= 0) {\n+            throw new IllegalArgumentException(\"bufferSizeHint: \" + bufferSizeHint + \"(expected > 0)\");\n+        }\n+        this.collectorFactory = requireNonNull(collectorFactory);\n+        this.bufferBoundaries = bufferBoundaries.map(__ -> collectorFactory.get());\n+        this.bufferSizeHint = bufferSizeHint;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super B> subscriber) {\n+        return new BufferSubscriber<>(bufferBoundaries, subscriber, collectorFactory.get(), bufferSizeHint);\n+    }\n+\n+    private static final class BufferSubscriber<T, B> implements Subscriber<T> {\n+        private static final Object ADDING = new Object();\n+        private static final Object TERMINATED = new Object();\n+\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BufferSubscriber> pendingItemsUpdater =\n+                newUpdater(BufferSubscriber.class, \"pendingItems\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BufferSubscriber> pendingBuffersUpdater =\n+                newUpdater(BufferSubscriber.class, \"pendingBuffers\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<BufferSubscriber, Object> maybeCollectorUpdater =\n+                AtomicReferenceFieldUpdater.newUpdater(BufferSubscriber.class, Object.class,\n+                        \"maybeCollector\");\n+        private final Publisher<Collector<T, B>> boundaries;\n+        private final DelayedSubscription tSubscription;\n+        private final BoundariesSubscriber boundariesSubscriber;\n+        private final int bufferSizeHint;\n+        private volatile long pendingItems;\n+        private volatile long pendingBuffers;\n+        /**\n+         * Following values are assigned to this variable:\n+         * <ul>\n+         *     <li>{@link #ADDING} when {@link #onNext(Object)} is adding an item to the active buffer.</li>\n+         *     <li>An instance of {@link DelayedTermination} if the source should be terminated after emitting\n+         *     the buffer contained in that {@link DelayedTermination}.</li>\n+         *     <li>{@link #TERMINATED} if the target subscriber has been terminated.</li>\n+         *     <li>A {@link Collector} representing the current buffer.</li>\n+         * </ul>\n+         */\n+        @SuppressWarnings({\"FieldCanBeLocal\", \"FieldMayBeFinal\"})\n+        private volatile Object maybeCollector;\n+\n+        BufferSubscriber(final Publisher<Collector<T, B>> boundaries, final Subscriber<? super B> target,\n+                         final Collector<T, B> firstCollector, final int bufferSizeHint) {\n+            this.boundaries = boundaries;\n+            tSubscription = new DelayedSubscription();\n+            this.boundariesSubscriber = new BoundariesSubscriber(target, tSubscription);\n+            this.bufferSizeHint = bufferSizeHint;\n+            maybeCollector = requireNonNull(firstCollector);", "originalCommit": "58ed3709d478a988f43f6607b808763f8a556dc4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUzNDg4MA==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r411534880", "bodyText": "buffer -> consider using collector instead of introducing new terminology.\n(general comment for this API)", "author": "Scottmitch", "createdAt": "2020-04-20T16:51:36Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Collector.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A collector of items.\n+ * <p>\n+ * None of the methods on a collector instance should be invoked concurrently.\n+ *\n+ * @param <T> Type of the individual items.\n+ * @param <B> Type of the buffer as returned by {@link #close()}.\n+ */\n+public interface Collector<T, B> {\n+\n+    /**\n+     * Adds the passed item {@code t} to the buffer.", "originalCommit": "58ed3709d478a988f43f6607b808763f8a556dc4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUzNjc3Mw==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r411536773", "bodyText": "IHMO we should use an alternative name for this method as close it implies lifetime and we may not always call this method (e.g. Subscription#cancel() may mean we don't need/care to call this). For example collect() or finish() has less ambigiuty around life time and existing close() concepts in java (e.g. AutoClosable, close idempotency, etc...).", "author": "Scottmitch", "createdAt": "2020-04-20T16:54:29Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Collector.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A collector of items.\n+ * <p>\n+ * None of the methods on a collector instance should be invoked concurrently.\n+ *\n+ * @param <T> Type of the individual items.\n+ * @param <B> Type of the buffer as returned by {@link #close()}.\n+ */\n+public interface Collector<T, B> {\n+\n+    /**\n+     * Adds the passed item {@code t} to the buffer.\n+     *\n+     * @param t Item to be added to the buffer.\n+     */\n+    void add(@Nullable T t);\n+\n+    /**\n+     * Closes this {@link Collector} and no further calls are made to this {@link Collector}.\n+     * <p>\n+     * This method should be called at most once for any instance of a {@link Collector}\n+     *\n+     * @return The buffer {@link B} which contains all items {@link #add(Object)} added} to this {@link Collector}\n+     * till now.\n+     */\n+    B close();", "originalCommit": "58ed3709d478a988f43f6607b808763f8a556dc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjEwNDkxNg==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r412104916", "bodyText": "Big +1... This also fits well with my comment about what to do once it was closed in terms of checks", "author": "normanmaurer", "createdAt": "2020-04-21T11:32:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUzNjc3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU0ODI3MA==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r411548270", "bodyText": "From the perspective of a general \"collector\" API, have you ruled out an approach inspired by the JDK's Stream API? Is the intention to use this API in other areas where we do aggregation (e.g. Publisher#collect(..)).\n * @param <T> the type of input elements to the reduction operation\n * @param <A> the mutable accumulation type of the reduction operation (often\n *            hidden as an implementation detail)\n * @param <R> the result type of the reduction operation\n */\npublic interface Collector<T, A, R> {\n  Supplier<A> collectorSupplier();\n  BiConsumer<A, T> collectorAccumulator();\n\n  // BinaryOperator<A> combiner(); - only needed for parallelism IIUC, not necessary for us\n\n  Function<A, R> collectorFinisher();\n}", "author": "Scottmitch", "createdAt": "2020-04-20T17:11:45Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Collector.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A collector of items.\n+ * <p>\n+ * None of the methods on a collector instance should be invoked concurrently.\n+ *\n+ * @param <T> Type of the individual items.\n+ * @param <B> Type of the buffer as returned by {@link #close()}.\n+ */\n+public interface Collector<T, B> {", "originalCommit": "58ed3709d478a988f43f6607b808763f8a556dc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM5MzQ2OA==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r413393468", "bodyText": "Thanks for pointing to this, I did not consider drawing inspiration from the JDK API.\nDifferent components of this Collector interface is what we have, although in different places. I think a value of using this API is if we can use java.util.stream.Collector as-is such that the java.util.stream.Collectors can also be used as-is. It fits perfectly for collect() methods such that one can use publisher.collect(Collectors.toList())\nThe buffer() operator although has an additional argument of the boundaries Publisher which makes it different. II was experimenting with the package-private class of Collectors below on how to make the usage easier. Let me try something different on these lines but I will keep the collect() operator changes as a separate exercise.", "author": "NiteshKant", "createdAt": "2020-04-22T23:09:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU0ODI3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU2MjQ3NQ==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r411562475", "bodyText": "few observations:\n\nif a subscriber synchronously cancels we will still emit signals\nthe duplicate subscription detection below can be defeated by the second onSubscribe call synchronously cancelling", "author": "Scottmitch", "createdAt": "2020-04-20T17:33:21Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Collectors.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.CompletableSource.Subscriber;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.handleExceptionFromOnSubscribe;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n+\n+/**\n+ * A factory for creating a {@link Collector} factory and an optional buffer boundaries {@link Publisher} for\n+ * typical buffering needs.\n+ */\n+final class Collectors {\n+\n+    private Collectors() {\n+        // no instances\n+    }\n+\n+    static <T> CollectorFactory<T> forSizeOrDuration(final int bufferSize, final Duration duration,\n+                                                     final Executor executor) {\n+        SizeBasedSignal sizeBasedSignal = new SizeBasedSignal(bufferSize);\n+        return new DefaultCollectorFactory<>(sizeBasedSignal,\n+                sizeBasedSignal.ambWith(executor.timer(duration).beforeOnComplete(sizeBasedSignal::reset))\n+                        .repeat(__ -> true));\n+    }\n+\n+    /**\n+     * A {@link Supplier} of {@link Collector}s and a {@link Publisher} of buffer boundaries.\n+     *\n+     * @param <T> Type of items collected.\n+     */\n+    interface CollectorFactory<T> extends Supplier<Collector<T, Iterable<T>>> {\n+        Publisher<?> boundaries();\n+    }\n+\n+    private static final class DefaultCollectorFactory<T> implements CollectorFactory<T> {\n+        private final SizeBasedSignal sizeBasedSignal;\n+        private final Publisher<?> boundaries;\n+\n+        DefaultCollectorFactory(final SizeBasedSignal sizeBasedSignal, final Publisher<?> boundaries) {\n+            this.sizeBasedSignal = sizeBasedSignal;\n+            this.boundaries = boundaries;\n+        }\n+\n+        @Override\n+        public Publisher<?> boundaries() {\n+            return boundaries;\n+        }\n+\n+        @Override\n+        public Collector<T, Iterable<T>> get() {\n+            return new ListCollector<>(sizeBasedSignal);\n+        }\n+    }\n+\n+    private static final class ListCollector<T> implements Collector<T, Iterable<T>> {\n+        private final List<T> buffer = new ArrayList<>();\n+        private final SizeBasedSignal sizeBasedSignal;\n+\n+        ListCollector(final SizeBasedSignal sizeBasedSignal) {\n+            this.sizeBasedSignal = sizeBasedSignal;\n+        }\n+\n+        @Override\n+        public void add(@Nullable final T t) {\n+            try {\n+                buffer.add(t);\n+            } finally {\n+                sizeBasedSignal.itemAdded();\n+            }\n+        }\n+\n+        @Override\n+        public Iterable<T> close() {\n+            return buffer;\n+        }\n+    }\n+\n+    private static final class SizeBasedSignal extends Completable {\n+        private static final AtomicIntegerFieldUpdater<SizeBasedSignal> pendingUpdater =\n+                newUpdater(SizeBasedSignal.class, \"pending\");\n+        private static final AtomicReferenceFieldUpdater<SizeBasedSignal, Subscriber> currentSubUpdater =\n+                AtomicReferenceFieldUpdater.newUpdater(SizeBasedSignal.class, Subscriber.class, \"currentSub\");\n+\n+        private final int bufferSize;\n+\n+        private volatile int pending;\n+        @Nullable\n+        private volatile Subscriber currentSub;\n+\n+        SizeBasedSignal(final int bufferSize) {\n+            this.bufferSize = bufferSize;\n+        }\n+\n+        @Override\n+        protected void handleSubscribe(final Subscriber subscriber) {\n+            try {\n+                subscriber.onSubscribe(() ->\n+                        currentSubUpdater.compareAndSet(SizeBasedSignal.this, subscriber, null));", "originalCommit": "58ed3709d478a988f43f6607b808763f8a556dc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM5NzIwNw==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r413397207", "bodyText": "Good catch, lemme move the onSubscribe() after the CAS.", "author": "NiteshKant", "createdAt": "2020-04-22T23:19:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU2MjQ3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU3MjA3Nw==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r411572077", "bodyText": "will a regular volatile write be sufficient, if not plz add comments.\nis there an dependency on which needs to be written first? IIUC the pending needs to be written before currentSub so the zero-ed pending count will be visible on the re-subscribe? if so plz add comments.", "author": "Scottmitch", "createdAt": "2020-04-20T17:47:56Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Collectors.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.CompletableSource.Subscriber;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.handleExceptionFromOnSubscribe;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n+\n+/**\n+ * A factory for creating a {@link Collector} factory and an optional buffer boundaries {@link Publisher} for\n+ * typical buffering needs.\n+ */\n+final class Collectors {\n+\n+    private Collectors() {\n+        // no instances\n+    }\n+\n+    static <T> CollectorFactory<T> forSizeOrDuration(final int bufferSize, final Duration duration,\n+                                                     final Executor executor) {\n+        SizeBasedSignal sizeBasedSignal = new SizeBasedSignal(bufferSize);\n+        return new DefaultCollectorFactory<>(sizeBasedSignal,\n+                sizeBasedSignal.ambWith(executor.timer(duration).beforeOnComplete(sizeBasedSignal::reset))\n+                        .repeat(__ -> true));\n+    }\n+\n+    /**\n+     * A {@link Supplier} of {@link Collector}s and a {@link Publisher} of buffer boundaries.\n+     *\n+     * @param <T> Type of items collected.\n+     */\n+    interface CollectorFactory<T> extends Supplier<Collector<T, Iterable<T>>> {\n+        Publisher<?> boundaries();\n+    }\n+\n+    private static final class DefaultCollectorFactory<T> implements CollectorFactory<T> {\n+        private final SizeBasedSignal sizeBasedSignal;\n+        private final Publisher<?> boundaries;\n+\n+        DefaultCollectorFactory(final SizeBasedSignal sizeBasedSignal, final Publisher<?> boundaries) {\n+            this.sizeBasedSignal = sizeBasedSignal;\n+            this.boundaries = boundaries;\n+        }\n+\n+        @Override\n+        public Publisher<?> boundaries() {\n+            return boundaries;\n+        }\n+\n+        @Override\n+        public Collector<T, Iterable<T>> get() {\n+            return new ListCollector<>(sizeBasedSignal);\n+        }\n+    }\n+\n+    private static final class ListCollector<T> implements Collector<T, Iterable<T>> {\n+        private final List<T> buffer = new ArrayList<>();\n+        private final SizeBasedSignal sizeBasedSignal;\n+\n+        ListCollector(final SizeBasedSignal sizeBasedSignal) {\n+            this.sizeBasedSignal = sizeBasedSignal;\n+        }\n+\n+        @Override\n+        public void add(@Nullable final T t) {\n+            try {\n+                buffer.add(t);\n+            } finally {\n+                sizeBasedSignal.itemAdded();\n+            }\n+        }\n+\n+        @Override\n+        public Iterable<T> close() {\n+            return buffer;\n+        }\n+    }\n+\n+    private static final class SizeBasedSignal extends Completable {\n+        private static final AtomicIntegerFieldUpdater<SizeBasedSignal> pendingUpdater =\n+                newUpdater(SizeBasedSignal.class, \"pending\");\n+        private static final AtomicReferenceFieldUpdater<SizeBasedSignal, Subscriber> currentSubUpdater =\n+                AtomicReferenceFieldUpdater.newUpdater(SizeBasedSignal.class, Subscriber.class, \"currentSub\");\n+\n+        private final int bufferSize;\n+\n+        private volatile int pending;\n+        @Nullable\n+        private volatile Subscriber currentSub;\n+\n+        SizeBasedSignal(final int bufferSize) {\n+            this.bufferSize = bufferSize;\n+        }\n+\n+        @Override\n+        protected void handleSubscribe(final Subscriber subscriber) {\n+            try {\n+                subscriber.onSubscribe(() ->\n+                        currentSubUpdater.compareAndSet(SizeBasedSignal.this, subscriber, null));\n+            } catch (Throwable t) {\n+                handleExceptionFromOnSubscribe(subscriber, t);\n+                return;\n+            }\n+            for (;;) {\n+                Subscriber cSub = currentSub;\n+                if (cSub == null) {\n+                    if (currentSubUpdater.compareAndSet(this, null, subscriber)) {\n+                        tryEmitSignal();\n+                        break;\n+                    }\n+                } else {\n+                    subscriber.onError(new DuplicateSubscribeException(cSub, subscriber));\n+                    break;\n+                }\n+            }\n+        }\n+\n+        void reset() {\n+            pendingUpdater.getAndSet(this, 0);", "originalCommit": "58ed3709d478a988f43f6607b808763f8a556dc4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY0OTU4OQ==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r411649589", "bodyText": "SizeBasedSignal and Publisher<?> (SizeBasedSignal.ambWith(timer(..))) share state across subscribe operations which may lead to signals \"bleeding\" between re-subscribes.\ninitial conditions -> bufferSize=100, currentSub=subscriber1\nT1 - itemAdded()\n  pendingUpdater.IAG(this) -> 100\n  tryEmitSignal()\n  cPending = pending -> 100\n  pendingUpdater.CAS(this, cPending, 0) -> true\n\nT2 - timer fire\n  amb cancels other subscribers\n  currentSubUpdater.CAS(subscriber, null) -> true\n  beforeOnComplete(sizeBasedSignal::reset)\n  pending = 0\n  currentSub = null\n  signal completion to Buffer operator\n  repeat()\n  subscribe(subscriber2)\n  handleSubscribe(subscriber2)\n  currentSubUpdater.CAS(null, subscriber2) -> true\n\nT1 - currentSubUpdater.GAS(this, null) -> subscriber2\n  subscriber2.onComplete()\n// subscriber2 was terminated but no timer fired and the number of items != 100 for that subscribe\n\nwith the \"external signals\" IIUC the desire/intention is to have the state span subscribes, but it complicates state management and control flow. Is it sufficient to keep the state constrained to the subscribe and re-create it as necessary (e.g. cancel/restart timer if the count triggers first)?", "author": "Scottmitch", "createdAt": "2020-04-20T19:54:49Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Collectors.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.CompletableSource.Subscriber;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.handleExceptionFromOnSubscribe;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n+\n+/**\n+ * A factory for creating a {@link Collector} factory and an optional buffer boundaries {@link Publisher} for\n+ * typical buffering needs.\n+ */\n+final class Collectors {\n+\n+    private Collectors() {\n+        // no instances\n+    }\n+\n+    static <T> CollectorFactory<T> forSizeOrDuration(final int bufferSize, final Duration duration,\n+                                                     final Executor executor) {\n+        SizeBasedSignal sizeBasedSignal = new SizeBasedSignal(bufferSize);\n+        return new DefaultCollectorFactory<>(sizeBasedSignal,\n+                sizeBasedSignal.ambWith(executor.timer(duration).beforeOnComplete(sizeBasedSignal::reset))\n+                        .repeat(__ -> true));\n+    }\n+\n+    /**\n+     * A {@link Supplier} of {@link Collector}s and a {@link Publisher} of buffer boundaries.\n+     *\n+     * @param <T> Type of items collected.\n+     */\n+    interface CollectorFactory<T> extends Supplier<Collector<T, Iterable<T>>> {\n+        Publisher<?> boundaries();\n+    }\n+\n+    private static final class DefaultCollectorFactory<T> implements CollectorFactory<T> {\n+        private final SizeBasedSignal sizeBasedSignal;\n+        private final Publisher<?> boundaries;\n+\n+        DefaultCollectorFactory(final SizeBasedSignal sizeBasedSignal, final Publisher<?> boundaries) {\n+            this.sizeBasedSignal = sizeBasedSignal;\n+            this.boundaries = boundaries;\n+        }\n+\n+        @Override\n+        public Publisher<?> boundaries() {\n+            return boundaries;\n+        }\n+\n+        @Override\n+        public Collector<T, Iterable<T>> get() {\n+            return new ListCollector<>(sizeBasedSignal);\n+        }\n+    }\n+\n+    private static final class ListCollector<T> implements Collector<T, Iterable<T>> {\n+        private final List<T> buffer = new ArrayList<>();\n+        private final SizeBasedSignal sizeBasedSignal;\n+\n+        ListCollector(final SizeBasedSignal sizeBasedSignal) {\n+            this.sizeBasedSignal = sizeBasedSignal;\n+        }\n+\n+        @Override\n+        public void add(@Nullable final T t) {\n+            try {\n+                buffer.add(t);\n+            } finally {\n+                sizeBasedSignal.itemAdded();\n+            }\n+        }\n+\n+        @Override\n+        public Iterable<T> close() {\n+            return buffer;\n+        }\n+    }\n+\n+    private static final class SizeBasedSignal extends Completable {\n+        private static final AtomicIntegerFieldUpdater<SizeBasedSignal> pendingUpdater =\n+                newUpdater(SizeBasedSignal.class, \"pending\");\n+        private static final AtomicReferenceFieldUpdater<SizeBasedSignal, Subscriber> currentSubUpdater =\n+                AtomicReferenceFieldUpdater.newUpdater(SizeBasedSignal.class, Subscriber.class, \"currentSub\");\n+\n+        private final int bufferSize;\n+\n+        private volatile int pending;\n+        @Nullable\n+        private volatile Subscriber currentSub;\n+\n+        SizeBasedSignal(final int bufferSize) {\n+            this.bufferSize = bufferSize;\n+        }\n+\n+        @Override\n+        protected void handleSubscribe(final Subscriber subscriber) {\n+            try {\n+                subscriber.onSubscribe(() ->\n+                        currentSubUpdater.compareAndSet(SizeBasedSignal.this, subscriber, null));\n+            } catch (Throwable t) {\n+                handleExceptionFromOnSubscribe(subscriber, t);\n+                return;\n+            }\n+            for (;;) {\n+                Subscriber cSub = currentSub;\n+                if (cSub == null) {\n+                    if (currentSubUpdater.compareAndSet(this, null, subscriber)) {\n+                        tryEmitSignal();\n+                        break;\n+                    }\n+                } else {\n+                    subscriber.onError(new DuplicateSubscribeException(cSub, subscriber));\n+                    break;\n+                }\n+            }\n+        }\n+\n+        void reset() {\n+            pendingUpdater.getAndSet(this, 0);\n+            currentSubUpdater.getAndSet(this, null);\n+        }\n+\n+        void itemAdded() {\n+            if (pendingUpdater.incrementAndGet(this) >= bufferSize) {\n+                tryEmitSignal();\n+            }\n+        }\n+\n+        private void tryEmitSignal() {\n+            for (;;) {\n+                final int cPending = pending;\n+                if (cPending < bufferSize) {\n+                    break;\n+                }\n+                if (pendingUpdater.compareAndSet(this, cPending, 0)) {\n+                    Subscriber subscriber = currentSubUpdater.getAndSet(this, null);", "originalCommit": "58ed3709d478a988f43f6607b808763f8a556dc4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY1NzY5OQ==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r411657699", "bodyText": "do a CAS here to make sure the subscriber hasn't changed and visibility in case we haven't seen an update from another thread?", "author": "Scottmitch", "createdAt": "2020-04-20T20:08:21Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Collectors.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.CompletableSource.Subscriber;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.handleExceptionFromOnSubscribe;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n+\n+/**\n+ * A factory for creating a {@link Collector} factory and an optional buffer boundaries {@link Publisher} for\n+ * typical buffering needs.\n+ */\n+final class Collectors {\n+\n+    private Collectors() {\n+        // no instances\n+    }\n+\n+    static <T> CollectorFactory<T> forSizeOrDuration(final int bufferSize, final Duration duration,\n+                                                     final Executor executor) {\n+        SizeBasedSignal sizeBasedSignal = new SizeBasedSignal(bufferSize);\n+        return new DefaultCollectorFactory<>(sizeBasedSignal,\n+                sizeBasedSignal.ambWith(executor.timer(duration).beforeOnComplete(sizeBasedSignal::reset))\n+                        .repeat(__ -> true));\n+    }\n+\n+    /**\n+     * A {@link Supplier} of {@link Collector}s and a {@link Publisher} of buffer boundaries.\n+     *\n+     * @param <T> Type of items collected.\n+     */\n+    interface CollectorFactory<T> extends Supplier<Collector<T, Iterable<T>>> {\n+        Publisher<?> boundaries();\n+    }\n+\n+    private static final class DefaultCollectorFactory<T> implements CollectorFactory<T> {\n+        private final SizeBasedSignal sizeBasedSignal;\n+        private final Publisher<?> boundaries;\n+\n+        DefaultCollectorFactory(final SizeBasedSignal sizeBasedSignal, final Publisher<?> boundaries) {\n+            this.sizeBasedSignal = sizeBasedSignal;\n+            this.boundaries = boundaries;\n+        }\n+\n+        @Override\n+        public Publisher<?> boundaries() {\n+            return boundaries;\n+        }\n+\n+        @Override\n+        public Collector<T, Iterable<T>> get() {\n+            return new ListCollector<>(sizeBasedSignal);\n+        }\n+    }\n+\n+    private static final class ListCollector<T> implements Collector<T, Iterable<T>> {\n+        private final List<T> buffer = new ArrayList<>();\n+        private final SizeBasedSignal sizeBasedSignal;\n+\n+        ListCollector(final SizeBasedSignal sizeBasedSignal) {\n+            this.sizeBasedSignal = sizeBasedSignal;\n+        }\n+\n+        @Override\n+        public void add(@Nullable final T t) {\n+            try {\n+                buffer.add(t);\n+            } finally {\n+                sizeBasedSignal.itemAdded();\n+            }\n+        }\n+\n+        @Override\n+        public Iterable<T> close() {\n+            return buffer;\n+        }\n+    }\n+\n+    private static final class SizeBasedSignal extends Completable {\n+        private static final AtomicIntegerFieldUpdater<SizeBasedSignal> pendingUpdater =\n+                newUpdater(SizeBasedSignal.class, \"pending\");\n+        private static final AtomicReferenceFieldUpdater<SizeBasedSignal, Subscriber> currentSubUpdater =\n+                AtomicReferenceFieldUpdater.newUpdater(SizeBasedSignal.class, Subscriber.class, \"currentSub\");\n+\n+        private final int bufferSize;\n+\n+        private volatile int pending;\n+        @Nullable\n+        private volatile Subscriber currentSub;\n+\n+        SizeBasedSignal(final int bufferSize) {\n+            this.bufferSize = bufferSize;\n+        }\n+\n+        @Override\n+        protected void handleSubscribe(final Subscriber subscriber) {\n+            try {\n+                subscriber.onSubscribe(() ->\n+                        currentSubUpdater.compareAndSet(SizeBasedSignal.this, subscriber, null));\n+            } catch (Throwable t) {\n+                handleExceptionFromOnSubscribe(subscriber, t);\n+                return;\n+            }\n+            for (;;) {\n+                Subscriber cSub = currentSub;\n+                if (cSub == null) {\n+                    if (currentSubUpdater.compareAndSet(this, null, subscriber)) {\n+                        tryEmitSignal();\n+                        break;\n+                    }\n+                } else {", "originalCommit": "58ed3709d478a988f43f6607b808763f8a556dc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM5OTIxOA==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r413399218", "bodyText": "Since this is an internal implementation, I am taking some liberties around expected usage. Concurrent subscribes are not expected unless the original Publisher is subscribed concurrently. There is a basic problem with the buffer API that the state of collector is detached from the subscribe of the boundaries Publisher. Based on your above feedback of the Collector API I maybe able to remove that problem, so let me revisit these edge cases after the API changes.", "author": "NiteshKant", "createdAt": "2020-04-22T23:23:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY1NzY5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY2MDM1NQ==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r411660355", "bodyText": "won't this let the pending count for the previous buffer \"bleed\" into the next buffer (e.g. on the next re-subscribe the buffer will immediately terminate with potentially empty contents)?", "author": "Scottmitch", "createdAt": "2020-04-20T20:12:49Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Collectors.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.CompletableSource.Subscriber;\n+import io.servicetalk.concurrent.internal.DuplicateSubscribeException;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.handleExceptionFromOnSubscribe;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n+\n+/**\n+ * A factory for creating a {@link Collector} factory and an optional buffer boundaries {@link Publisher} for\n+ * typical buffering needs.\n+ */\n+final class Collectors {\n+\n+    private Collectors() {\n+        // no instances\n+    }\n+\n+    static <T> CollectorFactory<T> forSizeOrDuration(final int bufferSize, final Duration duration,\n+                                                     final Executor executor) {\n+        SizeBasedSignal sizeBasedSignal = new SizeBasedSignal(bufferSize);\n+        return new DefaultCollectorFactory<>(sizeBasedSignal,\n+                sizeBasedSignal.ambWith(executor.timer(duration).beforeOnComplete(sizeBasedSignal::reset))\n+                        .repeat(__ -> true));\n+    }\n+\n+    /**\n+     * A {@link Supplier} of {@link Collector}s and a {@link Publisher} of buffer boundaries.\n+     *\n+     * @param <T> Type of items collected.\n+     */\n+    interface CollectorFactory<T> extends Supplier<Collector<T, Iterable<T>>> {\n+        Publisher<?> boundaries();\n+    }\n+\n+    private static final class DefaultCollectorFactory<T> implements CollectorFactory<T> {\n+        private final SizeBasedSignal sizeBasedSignal;\n+        private final Publisher<?> boundaries;\n+\n+        DefaultCollectorFactory(final SizeBasedSignal sizeBasedSignal, final Publisher<?> boundaries) {\n+            this.sizeBasedSignal = sizeBasedSignal;\n+            this.boundaries = boundaries;\n+        }\n+\n+        @Override\n+        public Publisher<?> boundaries() {\n+            return boundaries;\n+        }\n+\n+        @Override\n+        public Collector<T, Iterable<T>> get() {\n+            return new ListCollector<>(sizeBasedSignal);\n+        }\n+    }\n+\n+    private static final class ListCollector<T> implements Collector<T, Iterable<T>> {\n+        private final List<T> buffer = new ArrayList<>();\n+        private final SizeBasedSignal sizeBasedSignal;\n+\n+        ListCollector(final SizeBasedSignal sizeBasedSignal) {\n+            this.sizeBasedSignal = sizeBasedSignal;\n+        }\n+\n+        @Override\n+        public void add(@Nullable final T t) {\n+            try {\n+                buffer.add(t);\n+            } finally {\n+                sizeBasedSignal.itemAdded();\n+            }\n+        }\n+\n+        @Override\n+        public Iterable<T> close() {\n+            return buffer;\n+        }\n+    }\n+\n+    private static final class SizeBasedSignal extends Completable {\n+        private static final AtomicIntegerFieldUpdater<SizeBasedSignal> pendingUpdater =\n+                newUpdater(SizeBasedSignal.class, \"pending\");\n+        private static final AtomicReferenceFieldUpdater<SizeBasedSignal, Subscriber> currentSubUpdater =\n+                AtomicReferenceFieldUpdater.newUpdater(SizeBasedSignal.class, Subscriber.class, \"currentSub\");\n+\n+        private final int bufferSize;\n+\n+        private volatile int pending;\n+        @Nullable\n+        private volatile Subscriber currentSub;\n+\n+        SizeBasedSignal(final int bufferSize) {\n+            this.bufferSize = bufferSize;\n+        }\n+\n+        @Override\n+        protected void handleSubscribe(final Subscriber subscriber) {\n+            try {\n+                subscriber.onSubscribe(() ->\n+                        currentSubUpdater.compareAndSet(SizeBasedSignal.this, subscriber, null));\n+            } catch (Throwable t) {\n+                handleExceptionFromOnSubscribe(subscriber, t);\n+                return;\n+            }\n+            for (;;) {\n+                Subscriber cSub = currentSub;\n+                if (cSub == null) {\n+                    if (currentSubUpdater.compareAndSet(this, null, subscriber)) {\n+                        tryEmitSignal();\n+                        break;\n+                    }\n+                } else {\n+                    subscriber.onError(new DuplicateSubscribeException(cSub, subscriber));\n+                    break;\n+                }\n+            }\n+        }\n+\n+        void reset() {\n+            pendingUpdater.getAndSet(this, 0);\n+            currentSubUpdater.getAndSet(this, null);\n+        }\n+\n+        void itemAdded() {\n+            if (pendingUpdater.incrementAndGet(this) >= bufferSize) {\n+                tryEmitSignal();\n+            }\n+        }\n+\n+        private void tryEmitSignal() {\n+            for (;;) {\n+                final int cPending = pending;\n+                if (cPending < bufferSize) {\n+                    break;\n+                }\n+                if (pendingUpdater.compareAndSet(this, cPending, 0)) {\n+                    Subscriber subscriber = currentSubUpdater.getAndSet(this, null);\n+                    if (subscriber != null) {\n+                        subscriber.onComplete();\n+                    } else {\n+                        pendingUpdater.addAndGet(this, cPending);", "originalCommit": "58ed3709d478a988f43f6607b808763f8a556dc4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY4MjYzOQ==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r411682639", "bodyText": "nit: kill these suppressions? I don't see these warnings pop up.", "author": "Scottmitch", "createdAt": "2020-04-20T20:50:02Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherBuffer.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n+\n+final class PublisherBuffer<T, B> extends AbstractAsynchronousPublisherOperator<T, B> {\n+\n+    private final Publisher<Collector<T, B>> bufferBoundaries;\n+    private final Supplier<Collector<T, B>> collectorFactory;\n+    private final int bufferSizeHint;\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final Publisher<?> bufferBoundaries, final Supplier<Collector<T, B>> collectorFactory) {\n+        this(original, executor, bufferBoundaries, collectorFactory, 16);\n+    }\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final Publisher<?> bufferBoundaries, final Supplier<Collector<T, B>> collectorFactory,\n+                    final int bufferSizeHint) {\n+        super(original, executor);\n+        if (bufferSizeHint <= 0) {\n+            throw new IllegalArgumentException(\"bufferSizeHint: \" + bufferSizeHint + \"(expected > 0)\");\n+        }\n+        this.collectorFactory = requireNonNull(collectorFactory);\n+        this.bufferBoundaries = bufferBoundaries.map(__ -> collectorFactory.get());\n+        this.bufferSizeHint = bufferSizeHint;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super B> subscriber) {\n+        return new BufferSubscriber<>(bufferBoundaries, subscriber, collectorFactory.get(), bufferSizeHint);\n+    }\n+\n+    private static final class BufferSubscriber<T, B> implements Subscriber<T> {\n+        private static final Object ADDING = new Object();\n+        private static final Object TERMINATED = new Object();\n+\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BufferSubscriber> pendingItemsUpdater =\n+                newUpdater(BufferSubscriber.class, \"pendingItems\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BufferSubscriber> pendingBuffersUpdater =\n+                newUpdater(BufferSubscriber.class, \"pendingBuffers\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<BufferSubscriber, Object> maybeCollectorUpdater =\n+                AtomicReferenceFieldUpdater.newUpdater(BufferSubscriber.class, Object.class,\n+                        \"maybeCollector\");\n+        private final Publisher<Collector<T, B>> boundaries;\n+        private final DelayedSubscription tSubscription;\n+        private final BoundariesSubscriber boundariesSubscriber;\n+        private final int bufferSizeHint;\n+        private volatile long pendingItems;\n+        private volatile long pendingBuffers;\n+        /**\n+         * Following values are assigned to this variable:\n+         * <ul>\n+         *     <li>{@link #ADDING} when {@link #onNext(Object)} is adding an item to the active buffer.</li>\n+         *     <li>An instance of {@link DelayedTermination} if the source should be terminated after emitting\n+         *     the buffer contained in that {@link DelayedTermination}.</li>\n+         *     <li>{@link #TERMINATED} if the target subscriber has been terminated.</li>\n+         *     <li>A {@link Collector} representing the current buffer.</li>\n+         * </ul>\n+         */\n+        @SuppressWarnings({\"FieldCanBeLocal\", \"FieldMayBeFinal\"})", "originalCommit": "58ed3709d478a988f43f6607b808763f8a556dc4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMzY0MQ==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r411723641", "bodyText": "is it possible that collector.add(t) may cause re-entry? some custom source, strange situation?", "author": "Scottmitch", "createdAt": "2020-04-20T22:05:39Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherBuffer.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n+\n+final class PublisherBuffer<T, B> extends AbstractAsynchronousPublisherOperator<T, B> {\n+\n+    private final Publisher<Collector<T, B>> bufferBoundaries;\n+    private final Supplier<Collector<T, B>> collectorFactory;\n+    private final int bufferSizeHint;\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final Publisher<?> bufferBoundaries, final Supplier<Collector<T, B>> collectorFactory) {\n+        this(original, executor, bufferBoundaries, collectorFactory, 16);\n+    }\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final Publisher<?> bufferBoundaries, final Supplier<Collector<T, B>> collectorFactory,\n+                    final int bufferSizeHint) {\n+        super(original, executor);\n+        if (bufferSizeHint <= 0) {\n+            throw new IllegalArgumentException(\"bufferSizeHint: \" + bufferSizeHint + \"(expected > 0)\");\n+        }\n+        this.collectorFactory = requireNonNull(collectorFactory);\n+        this.bufferBoundaries = bufferBoundaries.map(__ -> collectorFactory.get());\n+        this.bufferSizeHint = bufferSizeHint;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super B> subscriber) {\n+        return new BufferSubscriber<>(bufferBoundaries, subscriber, collectorFactory.get(), bufferSizeHint);\n+    }\n+\n+    private static final class BufferSubscriber<T, B> implements Subscriber<T> {\n+        private static final Object ADDING = new Object();\n+        private static final Object TERMINATED = new Object();\n+\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BufferSubscriber> pendingItemsUpdater =\n+                newUpdater(BufferSubscriber.class, \"pendingItems\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BufferSubscriber> pendingBuffersUpdater =\n+                newUpdater(BufferSubscriber.class, \"pendingBuffers\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<BufferSubscriber, Object> maybeCollectorUpdater =\n+                AtomicReferenceFieldUpdater.newUpdater(BufferSubscriber.class, Object.class,\n+                        \"maybeCollector\");\n+        private final Publisher<Collector<T, B>> boundaries;\n+        private final DelayedSubscription tSubscription;\n+        private final BoundariesSubscriber boundariesSubscriber;\n+        private final int bufferSizeHint;\n+        private volatile long pendingItems;\n+        private volatile long pendingBuffers;\n+        /**\n+         * Following values are assigned to this variable:\n+         * <ul>\n+         *     <li>{@link #ADDING} when {@link #onNext(Object)} is adding an item to the active buffer.</li>\n+         *     <li>An instance of {@link DelayedTermination} if the source should be terminated after emitting\n+         *     the buffer contained in that {@link DelayedTermination}.</li>\n+         *     <li>{@link #TERMINATED} if the target subscriber has been terminated.</li>\n+         *     <li>A {@link Collector} representing the current buffer.</li>\n+         * </ul>\n+         */\n+        @SuppressWarnings({\"FieldCanBeLocal\", \"FieldMayBeFinal\"})\n+        private volatile Object maybeCollector;\n+\n+        BufferSubscriber(final Publisher<Collector<T, B>> boundaries, final Subscriber<? super B> target,\n+                         final Collector<T, B> firstCollector, final int bufferSizeHint) {\n+            this.boundaries = boundaries;\n+            tSubscription = new DelayedSubscription();\n+            this.boundariesSubscriber = new BoundariesSubscriber(target, tSubscription);\n+            this.bufferSizeHint = bufferSizeHint;\n+            maybeCollector = requireNonNull(firstCollector);\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription subscription) {\n+            tSubscription.delayedSubscription(subscription);\n+            toSource(boundaries).subscribe(boundariesSubscriber);\n+            requestMore();\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            long pending = pendingItemsUpdater.decrementAndGet(this);\n+            for (;;) {\n+                final Object cMaybeCollector = maybeCollector;\n+                assert cMaybeCollector != ADDING;", "originalCommit": "58ed3709d478a988f43f6607b808763f8a556dc4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTczOTk0Mw==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r411739943", "bodyText": "nit: put on previous line", "author": "Scottmitch", "createdAt": "2020-04-20T22:41:33Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherBuffer.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n+\n+final class PublisherBuffer<T, B> extends AbstractAsynchronousPublisherOperator<T, B> {\n+\n+    private final Publisher<Collector<T, B>> bufferBoundaries;\n+    private final Supplier<Collector<T, B>> collectorFactory;\n+    private final int bufferSizeHint;\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final Publisher<?> bufferBoundaries, final Supplier<Collector<T, B>> collectorFactory) {\n+        this(original, executor, bufferBoundaries, collectorFactory, 16);\n+    }\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final Publisher<?> bufferBoundaries, final Supplier<Collector<T, B>> collectorFactory,\n+                    final int bufferSizeHint) {\n+        super(original, executor);\n+        if (bufferSizeHint <= 0) {\n+            throw new IllegalArgumentException(\"bufferSizeHint: \" + bufferSizeHint + \"(expected > 0)\");\n+        }\n+        this.collectorFactory = requireNonNull(collectorFactory);\n+        this.bufferBoundaries = bufferBoundaries.map(__ -> collectorFactory.get());\n+        this.bufferSizeHint = bufferSizeHint;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super B> subscriber) {\n+        return new BufferSubscriber<>(bufferBoundaries, subscriber, collectorFactory.get(), bufferSizeHint);\n+    }\n+\n+    private static final class BufferSubscriber<T, B> implements Subscriber<T> {\n+        private static final Object ADDING = new Object();\n+        private static final Object TERMINATED = new Object();\n+\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BufferSubscriber> pendingItemsUpdater =\n+                newUpdater(BufferSubscriber.class, \"pendingItems\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BufferSubscriber> pendingBuffersUpdater =\n+                newUpdater(BufferSubscriber.class, \"pendingBuffers\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<BufferSubscriber, Object> maybeCollectorUpdater =\n+                AtomicReferenceFieldUpdater.newUpdater(BufferSubscriber.class, Object.class,\n+                        \"maybeCollector\");\n+        private final Publisher<Collector<T, B>> boundaries;\n+        private final DelayedSubscription tSubscription;\n+        private final BoundariesSubscriber boundariesSubscriber;\n+        private final int bufferSizeHint;\n+        private volatile long pendingItems;\n+        private volatile long pendingBuffers;\n+        /**\n+         * Following values are assigned to this variable:\n+         * <ul>\n+         *     <li>{@link #ADDING} when {@link #onNext(Object)} is adding an item to the active buffer.</li>\n+         *     <li>An instance of {@link DelayedTermination} if the source should be terminated after emitting\n+         *     the buffer contained in that {@link DelayedTermination}.</li>\n+         *     <li>{@link #TERMINATED} if the target subscriber has been terminated.</li>\n+         *     <li>A {@link Collector} representing the current buffer.</li>\n+         * </ul>\n+         */\n+        @SuppressWarnings({\"FieldCanBeLocal\", \"FieldMayBeFinal\"})\n+        private volatile Object maybeCollector;\n+\n+        BufferSubscriber(final Publisher<Collector<T, B>> boundaries, final Subscriber<? super B> target,\n+                         final Collector<T, B> firstCollector, final int bufferSizeHint) {\n+            this.boundaries = boundaries;\n+            tSubscription = new DelayedSubscription();\n+            this.boundariesSubscriber = new BoundariesSubscriber(target, tSubscription);\n+            this.bufferSizeHint = bufferSizeHint;\n+            maybeCollector = requireNonNull(firstCollector);\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription subscription) {\n+            tSubscription.delayedSubscription(subscription);\n+            toSource(boundaries).subscribe(boundariesSubscriber);\n+            requestMore();\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            long pending = pendingItemsUpdater.decrementAndGet(this);\n+            for (;;) {\n+                final Object cMaybeCollector = maybeCollector;\n+                assert cMaybeCollector != ADDING;\n+                if (cMaybeCollector == TERMINATED || cMaybeCollector instanceof DelayedTermination) {\n+                    return;\n+                }\n+                assert cMaybeCollector instanceof Collector;\n+                if (maybeCollectorUpdater.compareAndSet(this, cMaybeCollector, ADDING)) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    final Collector<T, B> collector = (Collector<T, B>) cMaybeCollector;\n+                    collector.add(t);\n+                    for (;;) {\n+                        final Object ccMaybeCollector = maybeCollector;\n+                        if (ccMaybeCollector == ADDING &&\n+                                maybeCollectorUpdater.compareAndSet(this, ADDING, collector)) {\n+                            break;\n+                        }\n+                        if (ccMaybeCollector == TERMINATED) {\n+                            return;\n+                        }\n+                        if (ccMaybeCollector instanceof DelayedTermination) {\n+                            DelayedTermination cDelayedTerm = (DelayedTermination) ccMaybeCollector;\n+                            assert cDelayedTerm.isMaybeCollectorAdding();\n+                            // Termination was scheduled while we were adding; so discard the ADDING collector inside\n+                            // the cDelayedTerm and use the collector that we added the item in.\n+                            DelayedTermination nextTerm = cDelayedTerm.copyUsing(collector);\n+                            if (maybeCollectorUpdater.compareAndSet(this, ccMaybeCollector, nextTerm)) {\n+                                boundariesSubscriber.tryTerminate(nextTerm);\n+                                return;\n+                            }\n+                        }\n+                    }\n+                    break;\n+                }\n+            }\n+\n+            if (pending == 0) {\n+                requestMore();\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            boundariesSubscriber.terminateFromItemsSource(TerminalNotification.error(t));\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            boundariesSubscriber.terminateFromItemsSource(TerminalNotification.complete());\n+        }\n+\n+        private void requestMore() {\n+            pendingItemsUpdater.accumulateAndGet(this, bufferSizeHint, FlowControlUtils::addWithOverflowProtection);\n+            tSubscription.request(bufferSizeHint);\n+        }\n+\n+        private final class BoundariesSubscriber extends DelayedCancellable\n+                implements Subscriber<Collector<T, B>> {", "originalCommit": "58ed3709d478a988f43f6607b808763f8a556dc4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0NTQxMg==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r411745412", "bodyText": "for cMaybeCollector == ADDING should we hand-off to BufferSubscriber so it can deliver target.onNext? otherwise we may get unlucky and synchronize data delivery with buffer delivery and not actually deliver anything in the pathological case.\nWithout some sort of hand-off (or atomic state check on both threads) the visibility on maybeCollector between BufferSubscriber thread and the BoundariesSubscriber thread isn't clear. If BoundariesSubscriber sees ADDING, when will it see another value?", "author": "Scottmitch", "createdAt": "2020-04-20T22:54:27Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherBuffer.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n+\n+final class PublisherBuffer<T, B> extends AbstractAsynchronousPublisherOperator<T, B> {\n+\n+    private final Publisher<Collector<T, B>> bufferBoundaries;\n+    private final Supplier<Collector<T, B>> collectorFactory;\n+    private final int bufferSizeHint;\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final Publisher<?> bufferBoundaries, final Supplier<Collector<T, B>> collectorFactory) {\n+        this(original, executor, bufferBoundaries, collectorFactory, 16);\n+    }\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final Publisher<?> bufferBoundaries, final Supplier<Collector<T, B>> collectorFactory,\n+                    final int bufferSizeHint) {\n+        super(original, executor);\n+        if (bufferSizeHint <= 0) {\n+            throw new IllegalArgumentException(\"bufferSizeHint: \" + bufferSizeHint + \"(expected > 0)\");\n+        }\n+        this.collectorFactory = requireNonNull(collectorFactory);\n+        this.bufferBoundaries = bufferBoundaries.map(__ -> collectorFactory.get());\n+        this.bufferSizeHint = bufferSizeHint;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super B> subscriber) {\n+        return new BufferSubscriber<>(bufferBoundaries, subscriber, collectorFactory.get(), bufferSizeHint);\n+    }\n+\n+    private static final class BufferSubscriber<T, B> implements Subscriber<T> {\n+        private static final Object ADDING = new Object();\n+        private static final Object TERMINATED = new Object();\n+\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BufferSubscriber> pendingItemsUpdater =\n+                newUpdater(BufferSubscriber.class, \"pendingItems\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BufferSubscriber> pendingBuffersUpdater =\n+                newUpdater(BufferSubscriber.class, \"pendingBuffers\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<BufferSubscriber, Object> maybeCollectorUpdater =\n+                AtomicReferenceFieldUpdater.newUpdater(BufferSubscriber.class, Object.class,\n+                        \"maybeCollector\");\n+        private final Publisher<Collector<T, B>> boundaries;\n+        private final DelayedSubscription tSubscription;\n+        private final BoundariesSubscriber boundariesSubscriber;\n+        private final int bufferSizeHint;\n+        private volatile long pendingItems;\n+        private volatile long pendingBuffers;\n+        /**\n+         * Following values are assigned to this variable:\n+         * <ul>\n+         *     <li>{@link #ADDING} when {@link #onNext(Object)} is adding an item to the active buffer.</li>\n+         *     <li>An instance of {@link DelayedTermination} if the source should be terminated after emitting\n+         *     the buffer contained in that {@link DelayedTermination}.</li>\n+         *     <li>{@link #TERMINATED} if the target subscriber has been terminated.</li>\n+         *     <li>A {@link Collector} representing the current buffer.</li>\n+         * </ul>\n+         */\n+        @SuppressWarnings({\"FieldCanBeLocal\", \"FieldMayBeFinal\"})\n+        private volatile Object maybeCollector;\n+\n+        BufferSubscriber(final Publisher<Collector<T, B>> boundaries, final Subscriber<? super B> target,\n+                         final Collector<T, B> firstCollector, final int bufferSizeHint) {\n+            this.boundaries = boundaries;\n+            tSubscription = new DelayedSubscription();\n+            this.boundariesSubscriber = new BoundariesSubscriber(target, tSubscription);\n+            this.bufferSizeHint = bufferSizeHint;\n+            maybeCollector = requireNonNull(firstCollector);\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription subscription) {\n+            tSubscription.delayedSubscription(subscription);\n+            toSource(boundaries).subscribe(boundariesSubscriber);\n+            requestMore();\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            long pending = pendingItemsUpdater.decrementAndGet(this);\n+            for (;;) {\n+                final Object cMaybeCollector = maybeCollector;\n+                assert cMaybeCollector != ADDING;\n+                if (cMaybeCollector == TERMINATED || cMaybeCollector instanceof DelayedTermination) {\n+                    return;\n+                }\n+                assert cMaybeCollector instanceof Collector;\n+                if (maybeCollectorUpdater.compareAndSet(this, cMaybeCollector, ADDING)) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    final Collector<T, B> collector = (Collector<T, B>) cMaybeCollector;\n+                    collector.add(t);\n+                    for (;;) {\n+                        final Object ccMaybeCollector = maybeCollector;\n+                        if (ccMaybeCollector == ADDING &&\n+                                maybeCollectorUpdater.compareAndSet(this, ADDING, collector)) {\n+                            break;\n+                        }\n+                        if (ccMaybeCollector == TERMINATED) {\n+                            return;\n+                        }\n+                        if (ccMaybeCollector instanceof DelayedTermination) {\n+                            DelayedTermination cDelayedTerm = (DelayedTermination) ccMaybeCollector;\n+                            assert cDelayedTerm.isMaybeCollectorAdding();\n+                            // Termination was scheduled while we were adding; so discard the ADDING collector inside\n+                            // the cDelayedTerm and use the collector that we added the item in.\n+                            DelayedTermination nextTerm = cDelayedTerm.copyUsing(collector);\n+                            if (maybeCollectorUpdater.compareAndSet(this, ccMaybeCollector, nextTerm)) {\n+                                boundariesSubscriber.tryTerminate(nextTerm);\n+                                return;\n+                            }\n+                        }\n+                    }\n+                    break;\n+                }\n+            }\n+\n+            if (pending == 0) {\n+                requestMore();\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            boundariesSubscriber.terminateFromItemsSource(TerminalNotification.error(t));\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            boundariesSubscriber.terminateFromItemsSource(TerminalNotification.complete());\n+        }\n+\n+        private void requestMore() {\n+            pendingItemsUpdater.accumulateAndGet(this, bufferSizeHint, FlowControlUtils::addWithOverflowProtection);\n+            tSubscription.request(bufferSizeHint);\n+        }\n+\n+        private final class BoundariesSubscriber extends DelayedCancellable\n+                implements Subscriber<Collector<T, B>> {\n+            private final Subscriber<? super B> target;\n+            private final Cancellable tCancellable;\n+\n+            BoundariesSubscriber(final Subscriber<? super B> target, final Cancellable tCancellable) {\n+                this.target = target;\n+                this.tCancellable = tCancellable;\n+            }\n+\n+            @Override\n+            public void onSubscribe(final Subscription subscription) {\n+                ConcurrentSubscription bs = ConcurrentSubscription.wrap(new Subscription() {\n+                    @Override\n+                    public void request(final long n) {\n+                        if (!isRequestNValid(n)) {\n+                            // This code is deliberately not intending to avoid potentially concurrent calls to the\n+                            // subscriber as the specification is already violated. This avoids complicating this\n+                            // state machine for unexpected specification violations.\n+                            Object oldUpdater = maybeCollectorUpdater.getAndSet(BufferSubscriber.this, TERMINATED);\n+                            if (oldUpdater != TERMINATED) {\n+                                subscription.cancel();\n+                                safeOnError(target, newExceptionForInvalidRequestN(n));\n+                            }\n+                            return;\n+                        }\n+                        if (pendingBuffersUpdater.getAndAccumulate(BufferSubscriber.this, n,\n+                                FlowControlUtils::addWithOverflowProtection) == 0) {\n+                            Object cMaybeCollector = maybeCollector;\n+                            if (cMaybeCollector instanceof DelayedTermination) {\n+                                tryTerminate((DelayedTermination) cMaybeCollector);\n+                                // as we are in the process of terminating do not send this request-n upstream.\n+                                return;\n+                            }\n+                        }\n+                        subscription.request(n);\n+                    }\n+\n+                    @Override\n+                    public void cancel() {\n+                        try {\n+                            subscription.cancel();\n+                        } finally {\n+                            tCancellable.cancel();\n+                        }\n+                    }\n+                });\n+                delayedCancellable(bs);\n+                target.onSubscribe(bs);\n+            }\n+\n+            @Override\n+            public void onNext(@Nullable final Collector<T, B> collector) {\n+                for (;;) {\n+                    final Object cMaybeCollector = maybeCollector;\n+                    if (cMaybeCollector == ADDING || cMaybeCollector == TERMINATED\n+                            || cMaybeCollector instanceof DelayedTermination) {\n+                        // If we are ADDING then we will try emitting in the next cycle", "originalCommit": "58ed3709d478a988f43f6607b808763f8a556dc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQxMjAxMQ==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r413412011", "bodyText": "There is an inherent assumption here that the boundaries are repetitive (time based component) otherwise the signals (items and boundaries) coming concurrently can not guarantee that the items land into a buffer that is emitted. This is the reason why only size based variant is not provided which actually can be a much simpler synchronous implementation.\nSo, this approach leverages that assumption such that an item added to the buffer will either be emitted to the current emission or next.", "author": "NiteshKant", "createdAt": "2020-04-22T23:57:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0NTQxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ1Mjk4OQ==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r413452989", "bodyText": "Publisher#buffer(..) exposes a Publisher<?> for arbitrary signals so this could be driven by any type of event (maybe even an even that fires only upon certain amount of data that is produced which would make dropping Collector problematic). Even if the events are periodic the \"next cycle\" may not come for some time, or as mentioned you may get unlucky and have data be synchronized with timer (e.g. imagine lots of data being delivered). It would provide more predictable behavior to hand-off the latest Collector to ensure some data gets delivered as close to the boundary as possible, and it would be difficult avoid/understand these types of concurrency issues.", "author": "Scottmitch", "createdAt": "2020-04-23T01:58:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0NTQxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAwNzU4NA==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r417007584", "bodyText": "@Scottmitch here the case is that the item is emitted concurrently with a boundary.\nSince, item is concurrently emitted, users should not have any expectation of which boundary the item should belong. We have the flexibility to determine whether the item should belong to the previous boundary or next. This code is making the decision of adding the item to the next boundary and handing-off the emission to the boundary source, which happens on the next boundary emission.", "author": "NiteshKant", "createdAt": "2020-04-29T00:39:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0NTQxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc2OTcxOQ==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r411769719", "bodyText": "if BufferSubscriber#onNext calling Collector#add(..) throws, BoundariesSubscriber#terminate will get called (assuming the source delivers an onError signal) and a DelayedTermination will be CASed in to maybeCollectorUpdater but will never be processed.", "author": "Scottmitch", "createdAt": "2020-04-20T23:52:31Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherBuffer.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n+\n+final class PublisherBuffer<T, B> extends AbstractAsynchronousPublisherOperator<T, B> {\n+\n+    private final Publisher<Collector<T, B>> bufferBoundaries;\n+    private final Supplier<Collector<T, B>> collectorFactory;\n+    private final int bufferSizeHint;\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final Publisher<?> bufferBoundaries, final Supplier<Collector<T, B>> collectorFactory) {\n+        this(original, executor, bufferBoundaries, collectorFactory, 16);\n+    }\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final Publisher<?> bufferBoundaries, final Supplier<Collector<T, B>> collectorFactory,\n+                    final int bufferSizeHint) {\n+        super(original, executor);\n+        if (bufferSizeHint <= 0) {\n+            throw new IllegalArgumentException(\"bufferSizeHint: \" + bufferSizeHint + \"(expected > 0)\");\n+        }\n+        this.collectorFactory = requireNonNull(collectorFactory);\n+        this.bufferBoundaries = bufferBoundaries.map(__ -> collectorFactory.get());\n+        this.bufferSizeHint = bufferSizeHint;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super B> subscriber) {\n+        return new BufferSubscriber<>(bufferBoundaries, subscriber, collectorFactory.get(), bufferSizeHint);\n+    }\n+\n+    private static final class BufferSubscriber<T, B> implements Subscriber<T> {\n+        private static final Object ADDING = new Object();\n+        private static final Object TERMINATED = new Object();\n+\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BufferSubscriber> pendingItemsUpdater =\n+                newUpdater(BufferSubscriber.class, \"pendingItems\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BufferSubscriber> pendingBuffersUpdater =\n+                newUpdater(BufferSubscriber.class, \"pendingBuffers\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<BufferSubscriber, Object> maybeCollectorUpdater =\n+                AtomicReferenceFieldUpdater.newUpdater(BufferSubscriber.class, Object.class,\n+                        \"maybeCollector\");\n+        private final Publisher<Collector<T, B>> boundaries;\n+        private final DelayedSubscription tSubscription;\n+        private final BoundariesSubscriber boundariesSubscriber;\n+        private final int bufferSizeHint;\n+        private volatile long pendingItems;\n+        private volatile long pendingBuffers;\n+        /**\n+         * Following values are assigned to this variable:\n+         * <ul>\n+         *     <li>{@link #ADDING} when {@link #onNext(Object)} is adding an item to the active buffer.</li>\n+         *     <li>An instance of {@link DelayedTermination} if the source should be terminated after emitting\n+         *     the buffer contained in that {@link DelayedTermination}.</li>\n+         *     <li>{@link #TERMINATED} if the target subscriber has been terminated.</li>\n+         *     <li>A {@link Collector} representing the current buffer.</li>\n+         * </ul>\n+         */\n+        @SuppressWarnings({\"FieldCanBeLocal\", \"FieldMayBeFinal\"})\n+        private volatile Object maybeCollector;\n+\n+        BufferSubscriber(final Publisher<Collector<T, B>> boundaries, final Subscriber<? super B> target,\n+                         final Collector<T, B> firstCollector, final int bufferSizeHint) {\n+            this.boundaries = boundaries;\n+            tSubscription = new DelayedSubscription();\n+            this.boundariesSubscriber = new BoundariesSubscriber(target, tSubscription);\n+            this.bufferSizeHint = bufferSizeHint;\n+            maybeCollector = requireNonNull(firstCollector);\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription subscription) {\n+            tSubscription.delayedSubscription(subscription);\n+            toSource(boundaries).subscribe(boundariesSubscriber);\n+            requestMore();\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            long pending = pendingItemsUpdater.decrementAndGet(this);\n+            for (;;) {\n+                final Object cMaybeCollector = maybeCollector;\n+                assert cMaybeCollector != ADDING;\n+                if (cMaybeCollector == TERMINATED || cMaybeCollector instanceof DelayedTermination) {\n+                    return;\n+                }\n+                assert cMaybeCollector instanceof Collector;\n+                if (maybeCollectorUpdater.compareAndSet(this, cMaybeCollector, ADDING)) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    final Collector<T, B> collector = (Collector<T, B>) cMaybeCollector;\n+                    collector.add(t);\n+                    for (;;) {\n+                        final Object ccMaybeCollector = maybeCollector;\n+                        if (ccMaybeCollector == ADDING &&\n+                                maybeCollectorUpdater.compareAndSet(this, ADDING, collector)) {\n+                            break;\n+                        }\n+                        if (ccMaybeCollector == TERMINATED) {\n+                            return;\n+                        }\n+                        if (ccMaybeCollector instanceof DelayedTermination) {\n+                            DelayedTermination cDelayedTerm = (DelayedTermination) ccMaybeCollector;\n+                            assert cDelayedTerm.isMaybeCollectorAdding();\n+                            // Termination was scheduled while we were adding; so discard the ADDING collector inside\n+                            // the cDelayedTerm and use the collector that we added the item in.\n+                            DelayedTermination nextTerm = cDelayedTerm.copyUsing(collector);\n+                            if (maybeCollectorUpdater.compareAndSet(this, ccMaybeCollector, nextTerm)) {\n+                                boundariesSubscriber.tryTerminate(nextTerm);\n+                                return;\n+                            }\n+                        }\n+                    }\n+                    break;\n+                }\n+            }\n+\n+            if (pending == 0) {\n+                requestMore();\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            boundariesSubscriber.terminateFromItemsSource(TerminalNotification.error(t));\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            boundariesSubscriber.terminateFromItemsSource(TerminalNotification.complete());\n+        }\n+\n+        private void requestMore() {\n+            pendingItemsUpdater.accumulateAndGet(this, bufferSizeHint, FlowControlUtils::addWithOverflowProtection);\n+            tSubscription.request(bufferSizeHint);\n+        }\n+\n+        private final class BoundariesSubscriber extends DelayedCancellable\n+                implements Subscriber<Collector<T, B>> {\n+            private final Subscriber<? super B> target;\n+            private final Cancellable tCancellable;\n+\n+            BoundariesSubscriber(final Subscriber<? super B> target, final Cancellable tCancellable) {\n+                this.target = target;\n+                this.tCancellable = tCancellable;\n+            }\n+\n+            @Override\n+            public void onSubscribe(final Subscription subscription) {\n+                ConcurrentSubscription bs = ConcurrentSubscription.wrap(new Subscription() {\n+                    @Override\n+                    public void request(final long n) {\n+                        if (!isRequestNValid(n)) {\n+                            // This code is deliberately not intending to avoid potentially concurrent calls to the\n+                            // subscriber as the specification is already violated. This avoids complicating this\n+                            // state machine for unexpected specification violations.\n+                            Object oldUpdater = maybeCollectorUpdater.getAndSet(BufferSubscriber.this, TERMINATED);\n+                            if (oldUpdater != TERMINATED) {\n+                                subscription.cancel();\n+                                safeOnError(target, newExceptionForInvalidRequestN(n));\n+                            }\n+                            return;\n+                        }\n+                        if (pendingBuffersUpdater.getAndAccumulate(BufferSubscriber.this, n,\n+                                FlowControlUtils::addWithOverflowProtection) == 0) {\n+                            Object cMaybeCollector = maybeCollector;\n+                            if (cMaybeCollector instanceof DelayedTermination) {\n+                                tryTerminate((DelayedTermination) cMaybeCollector);\n+                                // as we are in the process of terminating do not send this request-n upstream.\n+                                return;\n+                            }\n+                        }\n+                        subscription.request(n);\n+                    }\n+\n+                    @Override\n+                    public void cancel() {\n+                        try {\n+                            subscription.cancel();\n+                        } finally {\n+                            tCancellable.cancel();\n+                        }\n+                    }\n+                });\n+                delayedCancellable(bs);\n+                target.onSubscribe(bs);\n+            }\n+\n+            @Override\n+            public void onNext(@Nullable final Collector<T, B> collector) {\n+                for (;;) {\n+                    final Object cMaybeCollector = maybeCollector;\n+                    if (cMaybeCollector == ADDING || cMaybeCollector == TERMINATED\n+                            || cMaybeCollector instanceof DelayedTermination) {\n+                        // If we are ADDING then we will try emitting in the next cycle\n+                        // If we are terminated or scheduled to terminate, no more buffering is to be done.\n+                        return;\n+                    }\n+                    if (maybeCollectorUpdater.compareAndSet(BufferSubscriber.this, cMaybeCollector, collector)) {\n+                        if (cMaybeCollector instanceof Collector) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            Collector<T, B> oldCollector = (Collector<T, B>) cMaybeCollector;\n+                            pendingBuffersUpdater.decrementAndGet(BufferSubscriber.this);\n+                            target.onNext(oldCollector.close());\n+                        }\n+                        return;\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void onError(final Throwable t) {\n+                terminateFromBoundariesSource(TerminalNotification.error(t));\n+            }\n+\n+            @Override\n+            public void onComplete() {\n+                terminateFromBoundariesSource(TerminalNotification.complete());\n+            }\n+\n+            void terminateFromItemsSource(final TerminalNotification terminalNotification) {\n+                terminate(this, terminalNotification);\n+            }\n+\n+            private void terminateFromBoundariesSource(final TerminalNotification terminalNotification) {\n+                terminate(tCancellable, terminalNotification);\n+            }\n+\n+            private void terminate(final Cancellable cancellable, final TerminalNotification terminalNotification) {\n+                for (;;) {\n+                    final Object cMaybeCollector = maybeCollector;\n+                    if (cMaybeCollector == TERMINATED || cMaybeCollector instanceof DelayedTermination) {\n+                        cancellable.cancel();\n+                        return;\n+                    }\n+                    DelayedTermination delayedTermination =\n+                            new DelayedTermination(cMaybeCollector, terminalNotification, cancellable);\n+                    if (maybeCollectorUpdater.compareAndSet(\n+                            BufferSubscriber.this, cMaybeCollector, delayedTermination)) {\n+                        // If we raced with ADDING then hand-off termination to ADDING\n+                        if (cMaybeCollector != ADDING) {", "originalCommit": "58ed3709d478a988f43f6607b808763f8a556dc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQxMzA0Ng==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r413413046", "bodyText": "good catch; in this case, we can overwrite ADDING.", "author": "NiteshKant", "createdAt": "2020-04-23T00:00:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc2OTcxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc3NTA5MA==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r411775090", "bodyText": "IIUC we may concurrently invoke methods on target\nT1 - BoundariesSubscriber#onNext(collector)\n  cMaybeCollector = maybeCollector -> Collector\n  maybeCollectorUpdater.CAS(cMaybeCollector, collector) -> true\n  target.onNext(..)\n\nT2 - BufferSubscriber#onError(..)\n  terminateFromItemsSource(..)\n  cMaybeCollector = maybeCollector -> Collector\n  maybeCollectorUpdater.CAS(cMaybeCollector, DelayedTermination) -> true\n  tryTerminate()\n  cPendingBuffers = pendingBuffers -> 100 (>0)\n  pendingBuffersUpdater.CAS(100, 99) -> true\n  cMaybeCollector = maybeCollector -> DelayedTermination\n  target.onError(..)\n  // target.onError and target.onNext concurrently invoked", "author": "Scottmitch", "createdAt": "2020-04-21T00:07:41Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherBuffer.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n+\n+final class PublisherBuffer<T, B> extends AbstractAsynchronousPublisherOperator<T, B> {\n+\n+    private final Publisher<Collector<T, B>> bufferBoundaries;\n+    private final Supplier<Collector<T, B>> collectorFactory;\n+    private final int bufferSizeHint;\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final Publisher<?> bufferBoundaries, final Supplier<Collector<T, B>> collectorFactory) {\n+        this(original, executor, bufferBoundaries, collectorFactory, 16);\n+    }\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final Publisher<?> bufferBoundaries, final Supplier<Collector<T, B>> collectorFactory,\n+                    final int bufferSizeHint) {\n+        super(original, executor);\n+        if (bufferSizeHint <= 0) {\n+            throw new IllegalArgumentException(\"bufferSizeHint: \" + bufferSizeHint + \"(expected > 0)\");\n+        }\n+        this.collectorFactory = requireNonNull(collectorFactory);\n+        this.bufferBoundaries = bufferBoundaries.map(__ -> collectorFactory.get());\n+        this.bufferSizeHint = bufferSizeHint;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super B> subscriber) {\n+        return new BufferSubscriber<>(bufferBoundaries, subscriber, collectorFactory.get(), bufferSizeHint);\n+    }\n+\n+    private static final class BufferSubscriber<T, B> implements Subscriber<T> {\n+        private static final Object ADDING = new Object();\n+        private static final Object TERMINATED = new Object();\n+\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BufferSubscriber> pendingItemsUpdater =\n+                newUpdater(BufferSubscriber.class, \"pendingItems\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BufferSubscriber> pendingBuffersUpdater =\n+                newUpdater(BufferSubscriber.class, \"pendingBuffers\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<BufferSubscriber, Object> maybeCollectorUpdater =\n+                AtomicReferenceFieldUpdater.newUpdater(BufferSubscriber.class, Object.class,\n+                        \"maybeCollector\");\n+        private final Publisher<Collector<T, B>> boundaries;\n+        private final DelayedSubscription tSubscription;\n+        private final BoundariesSubscriber boundariesSubscriber;\n+        private final int bufferSizeHint;\n+        private volatile long pendingItems;\n+        private volatile long pendingBuffers;\n+        /**\n+         * Following values are assigned to this variable:\n+         * <ul>\n+         *     <li>{@link #ADDING} when {@link #onNext(Object)} is adding an item to the active buffer.</li>\n+         *     <li>An instance of {@link DelayedTermination} if the source should be terminated after emitting\n+         *     the buffer contained in that {@link DelayedTermination}.</li>\n+         *     <li>{@link #TERMINATED} if the target subscriber has been terminated.</li>\n+         *     <li>A {@link Collector} representing the current buffer.</li>\n+         * </ul>\n+         */\n+        @SuppressWarnings({\"FieldCanBeLocal\", \"FieldMayBeFinal\"})\n+        private volatile Object maybeCollector;\n+\n+        BufferSubscriber(final Publisher<Collector<T, B>> boundaries, final Subscriber<? super B> target,\n+                         final Collector<T, B> firstCollector, final int bufferSizeHint) {\n+            this.boundaries = boundaries;\n+            tSubscription = new DelayedSubscription();\n+            this.boundariesSubscriber = new BoundariesSubscriber(target, tSubscription);\n+            this.bufferSizeHint = bufferSizeHint;\n+            maybeCollector = requireNonNull(firstCollector);\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription subscription) {\n+            tSubscription.delayedSubscription(subscription);\n+            toSource(boundaries).subscribe(boundariesSubscriber);\n+            requestMore();\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            long pending = pendingItemsUpdater.decrementAndGet(this);\n+            for (;;) {\n+                final Object cMaybeCollector = maybeCollector;\n+                assert cMaybeCollector != ADDING;\n+                if (cMaybeCollector == TERMINATED || cMaybeCollector instanceof DelayedTermination) {\n+                    return;\n+                }\n+                assert cMaybeCollector instanceof Collector;\n+                if (maybeCollectorUpdater.compareAndSet(this, cMaybeCollector, ADDING)) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    final Collector<T, B> collector = (Collector<T, B>) cMaybeCollector;\n+                    collector.add(t);\n+                    for (;;) {\n+                        final Object ccMaybeCollector = maybeCollector;\n+                        if (ccMaybeCollector == ADDING &&\n+                                maybeCollectorUpdater.compareAndSet(this, ADDING, collector)) {\n+                            break;\n+                        }\n+                        if (ccMaybeCollector == TERMINATED) {\n+                            return;\n+                        }\n+                        if (ccMaybeCollector instanceof DelayedTermination) {\n+                            DelayedTermination cDelayedTerm = (DelayedTermination) ccMaybeCollector;\n+                            assert cDelayedTerm.isMaybeCollectorAdding();\n+                            // Termination was scheduled while we were adding; so discard the ADDING collector inside\n+                            // the cDelayedTerm and use the collector that we added the item in.\n+                            DelayedTermination nextTerm = cDelayedTerm.copyUsing(collector);\n+                            if (maybeCollectorUpdater.compareAndSet(this, ccMaybeCollector, nextTerm)) {\n+                                boundariesSubscriber.tryTerminate(nextTerm);\n+                                return;\n+                            }\n+                        }\n+                    }\n+                    break;\n+                }\n+            }\n+\n+            if (pending == 0) {\n+                requestMore();\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            boundariesSubscriber.terminateFromItemsSource(TerminalNotification.error(t));\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            boundariesSubscriber.terminateFromItemsSource(TerminalNotification.complete());\n+        }\n+\n+        private void requestMore() {\n+            pendingItemsUpdater.accumulateAndGet(this, bufferSizeHint, FlowControlUtils::addWithOverflowProtection);\n+            tSubscription.request(bufferSizeHint);\n+        }\n+\n+        private final class BoundariesSubscriber extends DelayedCancellable\n+                implements Subscriber<Collector<T, B>> {\n+            private final Subscriber<? super B> target;\n+            private final Cancellable tCancellable;\n+\n+            BoundariesSubscriber(final Subscriber<? super B> target, final Cancellable tCancellable) {\n+                this.target = target;\n+                this.tCancellable = tCancellable;\n+            }\n+\n+            @Override\n+            public void onSubscribe(final Subscription subscription) {\n+                ConcurrentSubscription bs = ConcurrentSubscription.wrap(new Subscription() {\n+                    @Override\n+                    public void request(final long n) {\n+                        if (!isRequestNValid(n)) {\n+                            // This code is deliberately not intending to avoid potentially concurrent calls to the\n+                            // subscriber as the specification is already violated. This avoids complicating this\n+                            // state machine for unexpected specification violations.\n+                            Object oldUpdater = maybeCollectorUpdater.getAndSet(BufferSubscriber.this, TERMINATED);\n+                            if (oldUpdater != TERMINATED) {\n+                                subscription.cancel();\n+                                safeOnError(target, newExceptionForInvalidRequestN(n));\n+                            }\n+                            return;\n+                        }\n+                        if (pendingBuffersUpdater.getAndAccumulate(BufferSubscriber.this, n,\n+                                FlowControlUtils::addWithOverflowProtection) == 0) {\n+                            Object cMaybeCollector = maybeCollector;\n+                            if (cMaybeCollector instanceof DelayedTermination) {\n+                                tryTerminate((DelayedTermination) cMaybeCollector);\n+                                // as we are in the process of terminating do not send this request-n upstream.\n+                                return;\n+                            }\n+                        }\n+                        subscription.request(n);\n+                    }\n+\n+                    @Override\n+                    public void cancel() {\n+                        try {\n+                            subscription.cancel();\n+                        } finally {\n+                            tCancellable.cancel();\n+                        }\n+                    }\n+                });\n+                delayedCancellable(bs);\n+                target.onSubscribe(bs);\n+            }\n+\n+            @Override\n+            public void onNext(@Nullable final Collector<T, B> collector) {\n+                for (;;) {\n+                    final Object cMaybeCollector = maybeCollector;\n+                    if (cMaybeCollector == ADDING || cMaybeCollector == TERMINATED\n+                            || cMaybeCollector instanceof DelayedTermination) {\n+                        // If we are ADDING then we will try emitting in the next cycle\n+                        // If we are terminated or scheduled to terminate, no more buffering is to be done.\n+                        return;\n+                    }\n+                    if (maybeCollectorUpdater.compareAndSet(BufferSubscriber.this, cMaybeCollector, collector)) {\n+                        if (cMaybeCollector instanceof Collector) {\n+                            @SuppressWarnings(\"unchecked\")\n+                            Collector<T, B> oldCollector = (Collector<T, B>) cMaybeCollector;\n+                            pendingBuffersUpdater.decrementAndGet(BufferSubscriber.this);\n+                            target.onNext(oldCollector.close());\n+                        }\n+                        return;\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void onError(final Throwable t) {\n+                terminateFromBoundariesSource(TerminalNotification.error(t));\n+            }\n+\n+            @Override\n+            public void onComplete() {\n+                terminateFromBoundariesSource(TerminalNotification.complete());\n+            }\n+\n+            void terminateFromItemsSource(final TerminalNotification terminalNotification) {\n+                terminate(this, terminalNotification);\n+            }\n+\n+            private void terminateFromBoundariesSource(final TerminalNotification terminalNotification) {\n+                terminate(tCancellable, terminalNotification);\n+            }\n+\n+            private void terminate(final Cancellable cancellable, final TerminalNotification terminalNotification) {\n+                for (;;) {\n+                    final Object cMaybeCollector = maybeCollector;\n+                    if (cMaybeCollector == TERMINATED || cMaybeCollector instanceof DelayedTermination) {\n+                        cancellable.cancel();\n+                        return;\n+                    }\n+                    DelayedTermination delayedTermination =\n+                            new DelayedTermination(cMaybeCollector, terminalNotification, cancellable);\n+                    if (maybeCollectorUpdater.compareAndSet(\n+                            BufferSubscriber.this, cMaybeCollector, delayedTermination)) {\n+                        // If we raced with ADDING then hand-off termination to ADDING\n+                        if (cMaybeCollector != ADDING) {\n+                            tryTerminate(delayedTermination);\n+                        }\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            void tryTerminate(final DelayedTermination delayedTermination) {\n+                for (;;) {\n+                    final long cPendingBuffers = pendingBuffers;\n+                    if (cPendingBuffers <= 0) {\n+                        return;\n+                    }\n+                    if (pendingBuffersUpdater.compareAndSet(\n+                            BufferSubscriber.this, cPendingBuffers, cPendingBuffers - 1)) {\n+                        for (;;) {\n+                            final Object cMaybeCollector = maybeCollector;\n+                            if (cMaybeCollector == TERMINATED) {\n+                                return;\n+                            }\n+                            assert cMaybeCollector == delayedTermination;\n+                            if (maybeCollectorUpdater.compareAndSet(\n+                                    BufferSubscriber.this, delayedTermination, TERMINATED)) {\n+                                delayedTermination.terminate(target);", "originalCommit": "58ed3709d478a988f43f6607b808763f8a556dc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQxNDA0Mg==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r413414042", "bodyText": "good catch; lemme fix", "author": "NiteshKant", "createdAt": "2020-04-23T00:02:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc3NTA5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc3NTUyNg==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r411775526", "bodyText": "IIUC tSubscription may be concurrently invoked.\nT1 - requestMore()\n  tSubscription.request() //  in invoked in outer `Subscriber`s `onNext`/`onSubscribe`\n\nT2 - target.onSubscribe(bs)\n  bs.cancel()\n  tCancellable.cancel() // tCancellable == tSubscription", "author": "Scottmitch", "createdAt": "2020-04-21T00:08:44Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherBuffer.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n+\n+final class PublisherBuffer<T, B> extends AbstractAsynchronousPublisherOperator<T, B> {\n+\n+    private final Publisher<Collector<T, B>> bufferBoundaries;\n+    private final Supplier<Collector<T, B>> collectorFactory;\n+    private final int bufferSizeHint;\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final Publisher<?> bufferBoundaries, final Supplier<Collector<T, B>> collectorFactory) {\n+        this(original, executor, bufferBoundaries, collectorFactory, 16);\n+    }\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final Publisher<?> bufferBoundaries, final Supplier<Collector<T, B>> collectorFactory,\n+                    final int bufferSizeHint) {\n+        super(original, executor);\n+        if (bufferSizeHint <= 0) {\n+            throw new IllegalArgumentException(\"bufferSizeHint: \" + bufferSizeHint + \"(expected > 0)\");\n+        }\n+        this.collectorFactory = requireNonNull(collectorFactory);\n+        this.bufferBoundaries = bufferBoundaries.map(__ -> collectorFactory.get());\n+        this.bufferSizeHint = bufferSizeHint;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super B> subscriber) {\n+        return new BufferSubscriber<>(bufferBoundaries, subscriber, collectorFactory.get(), bufferSizeHint);\n+    }\n+\n+    private static final class BufferSubscriber<T, B> implements Subscriber<T> {\n+        private static final Object ADDING = new Object();\n+        private static final Object TERMINATED = new Object();\n+\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BufferSubscriber> pendingItemsUpdater =\n+                newUpdater(BufferSubscriber.class, \"pendingItems\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BufferSubscriber> pendingBuffersUpdater =\n+                newUpdater(BufferSubscriber.class, \"pendingBuffers\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<BufferSubscriber, Object> maybeCollectorUpdater =\n+                AtomicReferenceFieldUpdater.newUpdater(BufferSubscriber.class, Object.class,\n+                        \"maybeCollector\");\n+        private final Publisher<Collector<T, B>> boundaries;\n+        private final DelayedSubscription tSubscription;\n+        private final BoundariesSubscriber boundariesSubscriber;\n+        private final int bufferSizeHint;\n+        private volatile long pendingItems;\n+        private volatile long pendingBuffers;\n+        /**\n+         * Following values are assigned to this variable:\n+         * <ul>\n+         *     <li>{@link #ADDING} when {@link #onNext(Object)} is adding an item to the active buffer.</li>\n+         *     <li>An instance of {@link DelayedTermination} if the source should be terminated after emitting\n+         *     the buffer contained in that {@link DelayedTermination}.</li>\n+         *     <li>{@link #TERMINATED} if the target subscriber has been terminated.</li>\n+         *     <li>A {@link Collector} representing the current buffer.</li>\n+         * </ul>\n+         */\n+        @SuppressWarnings({\"FieldCanBeLocal\", \"FieldMayBeFinal\"})\n+        private volatile Object maybeCollector;\n+\n+        BufferSubscriber(final Publisher<Collector<T, B>> boundaries, final Subscriber<? super B> target,\n+                         final Collector<T, B> firstCollector, final int bufferSizeHint) {\n+            this.boundaries = boundaries;\n+            tSubscription = new DelayedSubscription();\n+            this.boundariesSubscriber = new BoundariesSubscriber(target, tSubscription);\n+            this.bufferSizeHint = bufferSizeHint;\n+            maybeCollector = requireNonNull(firstCollector);\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription subscription) {\n+            tSubscription.delayedSubscription(subscription);\n+            toSource(boundaries).subscribe(boundariesSubscriber);\n+            requestMore();\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            long pending = pendingItemsUpdater.decrementAndGet(this);\n+            for (;;) {\n+                final Object cMaybeCollector = maybeCollector;\n+                assert cMaybeCollector != ADDING;\n+                if (cMaybeCollector == TERMINATED || cMaybeCollector instanceof DelayedTermination) {\n+                    return;\n+                }\n+                assert cMaybeCollector instanceof Collector;\n+                if (maybeCollectorUpdater.compareAndSet(this, cMaybeCollector, ADDING)) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    final Collector<T, B> collector = (Collector<T, B>) cMaybeCollector;\n+                    collector.add(t);\n+                    for (;;) {\n+                        final Object ccMaybeCollector = maybeCollector;\n+                        if (ccMaybeCollector == ADDING &&\n+                                maybeCollectorUpdater.compareAndSet(this, ADDING, collector)) {\n+                            break;\n+                        }\n+                        if (ccMaybeCollector == TERMINATED) {\n+                            return;\n+                        }\n+                        if (ccMaybeCollector instanceof DelayedTermination) {\n+                            DelayedTermination cDelayedTerm = (DelayedTermination) ccMaybeCollector;\n+                            assert cDelayedTerm.isMaybeCollectorAdding();\n+                            // Termination was scheduled while we were adding; so discard the ADDING collector inside\n+                            // the cDelayedTerm and use the collector that we added the item in.\n+                            DelayedTermination nextTerm = cDelayedTerm.copyUsing(collector);\n+                            if (maybeCollectorUpdater.compareAndSet(this, ccMaybeCollector, nextTerm)) {\n+                                boundariesSubscriber.tryTerminate(nextTerm);\n+                                return;\n+                            }\n+                        }\n+                    }\n+                    break;\n+                }\n+            }\n+\n+            if (pending == 0) {\n+                requestMore();\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            boundariesSubscriber.terminateFromItemsSource(TerminalNotification.error(t));\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            boundariesSubscriber.terminateFromItemsSource(TerminalNotification.complete());\n+        }\n+\n+        private void requestMore() {\n+            pendingItemsUpdater.accumulateAndGet(this, bufferSizeHint, FlowControlUtils::addWithOverflowProtection);\n+            tSubscription.request(bufferSizeHint);\n+        }\n+\n+        private final class BoundariesSubscriber extends DelayedCancellable\n+                implements Subscriber<Collector<T, B>> {\n+            private final Subscriber<? super B> target;\n+            private final Cancellable tCancellable;\n+\n+            BoundariesSubscriber(final Subscriber<? super B> target, final Cancellable tCancellable) {\n+                this.target = target;\n+                this.tCancellable = tCancellable;\n+            }\n+\n+            @Override\n+            public void onSubscribe(final Subscription subscription) {\n+                ConcurrentSubscription bs = ConcurrentSubscription.wrap(new Subscription() {\n+                    @Override\n+                    public void request(final long n) {\n+                        if (!isRequestNValid(n)) {\n+                            // This code is deliberately not intending to avoid potentially concurrent calls to the\n+                            // subscriber as the specification is already violated. This avoids complicating this\n+                            // state machine for unexpected specification violations.\n+                            Object oldUpdater = maybeCollectorUpdater.getAndSet(BufferSubscriber.this, TERMINATED);\n+                            if (oldUpdater != TERMINATED) {\n+                                subscription.cancel();\n+                                safeOnError(target, newExceptionForInvalidRequestN(n));\n+                            }\n+                            return;\n+                        }\n+                        if (pendingBuffersUpdater.getAndAccumulate(BufferSubscriber.this, n,\n+                                FlowControlUtils::addWithOverflowProtection) == 0) {\n+                            Object cMaybeCollector = maybeCollector;\n+                            if (cMaybeCollector instanceof DelayedTermination) {\n+                                tryTerminate((DelayedTermination) cMaybeCollector);\n+                                // as we are in the process of terminating do not send this request-n upstream.\n+                                return;\n+                            }\n+                        }\n+                        subscription.request(n);\n+                    }\n+\n+                    @Override\n+                    public void cancel() {\n+                        try {\n+                            subscription.cancel();\n+                        } finally {\n+                            tCancellable.cancel();", "originalCommit": "58ed3709d478a988f43f6607b808763f8a556dc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQwNzYxNA==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r413407614", "bodyText": "hmm I intended to wrap it with ConcurrentSubscription but I think it got lost in between; will do.", "author": "NiteshKant", "createdAt": "2020-04-22T23:45:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc3NTUyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc4MDYwOA==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r411780608", "bodyText": "onError maybe delivered to BufferSubscriber, but it isn't clear what provides visibility here such that the event will be delivered.\nT1 - BufferSubscriber#onError(..)\n  boundariesSubscriber.terminateFromItemsSource\n  terminate(this, terminalNotification)\n  maybeCollectorUpdater.CAS(null, DelayedTermination)\n  tryTerminate(..)\n  cPendingBuffers = pendingBuffers -> 0\n  return;\n  \n// Some later time...\nT2 - BoundariesSubscriber#onSubscribe\n  target.onSubscribe(bs)\n  bs.request(1)\n  pendingBuffersUpdater.GAA() -> 1\n  cMaybeCollector = maybeCollector -> null // no-visibility?\n  subscription.request(1)\n\n...\n  BoundariesSubscriber#onNext(..)\n  cMaybeCollector = maybeCollector -> DelayedTermination\n  return;\n\nthe unconditional dependency on pendingBuffersUpdater has a nice side effect the way the code is currently structured in that it also prevents onError from coming before onSubscribe, but has some other un-intended consequences.", "author": "Scottmitch", "createdAt": "2020-04-21T00:23:41Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherBuffer.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.newExceptionForInvalidRequestN;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n+\n+final class PublisherBuffer<T, B> extends AbstractAsynchronousPublisherOperator<T, B> {\n+\n+    private final Publisher<Collector<T, B>> bufferBoundaries;\n+    private final Supplier<Collector<T, B>> collectorFactory;\n+    private final int bufferSizeHint;\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final Publisher<?> bufferBoundaries, final Supplier<Collector<T, B>> collectorFactory) {\n+        this(original, executor, bufferBoundaries, collectorFactory, 16);\n+    }\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final Publisher<?> bufferBoundaries, final Supplier<Collector<T, B>> collectorFactory,\n+                    final int bufferSizeHint) {\n+        super(original, executor);\n+        if (bufferSizeHint <= 0) {\n+            throw new IllegalArgumentException(\"bufferSizeHint: \" + bufferSizeHint + \"(expected > 0)\");\n+        }\n+        this.collectorFactory = requireNonNull(collectorFactory);\n+        this.bufferBoundaries = bufferBoundaries.map(__ -> collectorFactory.get());\n+        this.bufferSizeHint = bufferSizeHint;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super B> subscriber) {\n+        return new BufferSubscriber<>(bufferBoundaries, subscriber, collectorFactory.get(), bufferSizeHint);\n+    }\n+\n+    private static final class BufferSubscriber<T, B> implements Subscriber<T> {\n+        private static final Object ADDING = new Object();\n+        private static final Object TERMINATED = new Object();\n+\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BufferSubscriber> pendingItemsUpdater =\n+                newUpdater(BufferSubscriber.class, \"pendingItems\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BufferSubscriber> pendingBuffersUpdater =\n+                newUpdater(BufferSubscriber.class, \"pendingBuffers\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<BufferSubscriber, Object> maybeCollectorUpdater =\n+                AtomicReferenceFieldUpdater.newUpdater(BufferSubscriber.class, Object.class,\n+                        \"maybeCollector\");\n+        private final Publisher<Collector<T, B>> boundaries;\n+        private final DelayedSubscription tSubscription;\n+        private final BoundariesSubscriber boundariesSubscriber;\n+        private final int bufferSizeHint;\n+        private volatile long pendingItems;\n+        private volatile long pendingBuffers;\n+        /**\n+         * Following values are assigned to this variable:\n+         * <ul>\n+         *     <li>{@link #ADDING} when {@link #onNext(Object)} is adding an item to the active buffer.</li>\n+         *     <li>An instance of {@link DelayedTermination} if the source should be terminated after emitting\n+         *     the buffer contained in that {@link DelayedTermination}.</li>\n+         *     <li>{@link #TERMINATED} if the target subscriber has been terminated.</li>\n+         *     <li>A {@link Collector} representing the current buffer.</li>\n+         * </ul>\n+         */\n+        @SuppressWarnings({\"FieldCanBeLocal\", \"FieldMayBeFinal\"})\n+        private volatile Object maybeCollector;\n+\n+        BufferSubscriber(final Publisher<Collector<T, B>> boundaries, final Subscriber<? super B> target,\n+                         final Collector<T, B> firstCollector, final int bufferSizeHint) {\n+            this.boundaries = boundaries;\n+            tSubscription = new DelayedSubscription();\n+            this.boundariesSubscriber = new BoundariesSubscriber(target, tSubscription);\n+            this.bufferSizeHint = bufferSizeHint;\n+            maybeCollector = requireNonNull(firstCollector);\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription subscription) {\n+            tSubscription.delayedSubscription(subscription);\n+            toSource(boundaries).subscribe(boundariesSubscriber);\n+            requestMore();\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            long pending = pendingItemsUpdater.decrementAndGet(this);\n+            for (;;) {\n+                final Object cMaybeCollector = maybeCollector;\n+                assert cMaybeCollector != ADDING;\n+                if (cMaybeCollector == TERMINATED || cMaybeCollector instanceof DelayedTermination) {\n+                    return;\n+                }\n+                assert cMaybeCollector instanceof Collector;\n+                if (maybeCollectorUpdater.compareAndSet(this, cMaybeCollector, ADDING)) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    final Collector<T, B> collector = (Collector<T, B>) cMaybeCollector;\n+                    collector.add(t);\n+                    for (;;) {\n+                        final Object ccMaybeCollector = maybeCollector;\n+                        if (ccMaybeCollector == ADDING &&\n+                                maybeCollectorUpdater.compareAndSet(this, ADDING, collector)) {\n+                            break;\n+                        }\n+                        if (ccMaybeCollector == TERMINATED) {\n+                            return;\n+                        }\n+                        if (ccMaybeCollector instanceof DelayedTermination) {\n+                            DelayedTermination cDelayedTerm = (DelayedTermination) ccMaybeCollector;\n+                            assert cDelayedTerm.isMaybeCollectorAdding();\n+                            // Termination was scheduled while we were adding; so discard the ADDING collector inside\n+                            // the cDelayedTerm and use the collector that we added the item in.\n+                            DelayedTermination nextTerm = cDelayedTerm.copyUsing(collector);\n+                            if (maybeCollectorUpdater.compareAndSet(this, ccMaybeCollector, nextTerm)) {\n+                                boundariesSubscriber.tryTerminate(nextTerm);\n+                                return;\n+                            }\n+                        }\n+                    }\n+                    break;\n+                }\n+            }\n+\n+            if (pending == 0) {\n+                requestMore();\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            boundariesSubscriber.terminateFromItemsSource(TerminalNotification.error(t));\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            boundariesSubscriber.terminateFromItemsSource(TerminalNotification.complete());\n+        }\n+\n+        private void requestMore() {\n+            pendingItemsUpdater.accumulateAndGet(this, bufferSizeHint, FlowControlUtils::addWithOverflowProtection);\n+            tSubscription.request(bufferSizeHint);\n+        }\n+\n+        private final class BoundariesSubscriber extends DelayedCancellable\n+                implements Subscriber<Collector<T, B>> {\n+            private final Subscriber<? super B> target;\n+            private final Cancellable tCancellable;\n+\n+            BoundariesSubscriber(final Subscriber<? super B> target, final Cancellable tCancellable) {\n+                this.target = target;\n+                this.tCancellable = tCancellable;\n+            }\n+\n+            @Override\n+            public void onSubscribe(final Subscription subscription) {\n+                ConcurrentSubscription bs = ConcurrentSubscription.wrap(new Subscription() {\n+                    @Override\n+                    public void request(final long n) {\n+                        if (!isRequestNValid(n)) {\n+                            // This code is deliberately not intending to avoid potentially concurrent calls to the\n+                            // subscriber as the specification is already violated. This avoids complicating this\n+                            // state machine for unexpected specification violations.\n+                            Object oldUpdater = maybeCollectorUpdater.getAndSet(BufferSubscriber.this, TERMINATED);\n+                            if (oldUpdater != TERMINATED) {\n+                                subscription.cancel();\n+                                safeOnError(target, newExceptionForInvalidRequestN(n));\n+                            }\n+                            return;\n+                        }\n+                        if (pendingBuffersUpdater.getAndAccumulate(BufferSubscriber.this, n,\n+                                FlowControlUtils::addWithOverflowProtection) == 0) {\n+                            Object cMaybeCollector = maybeCollector;\n+                            if (cMaybeCollector instanceof DelayedTermination) {", "originalCommit": "58ed3709d478a988f43f6607b808763f8a556dc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQwNTI5Nw==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r413405297", "bodyText": "Good catch! lemme fix this", "author": "NiteshKant", "createdAt": "2020-04-22T23:39:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc4MDYwOA=="}], "type": "inlineReview"}, {"oid": "1b86ecb3118e73a596362a78228c7be889277ca9", "url": "https://github.com/apple/servicetalk/commit/1b86ecb3118e73a596362a78228c7be889277ca9", "message": "Add `Publisher#buffer` operator\n\n__Motivation__\n\n[`buffer`](http://reactivex.io/documentation/operators/buffer.html) operator is useful for batching.\n\n__Modification__\n\nAdd `buffer()` operator for `Publisher` to buffer based on arbitrary buffer boundaries or based on size + time duration.\n\n__Result__\n\nUsers can buffer events from a `Publisher`.", "committedDate": "2020-04-28T17:28:36Z", "type": "forcePushed"}, {"oid": "c0c27efac7883d2436b1ca0b33875f63f64df6cd", "url": "https://github.com/apple/servicetalk/commit/c0c27efac7883d2436b1ca0b33875f63f64df6cd", "message": "Add `Publisher#buffer` operator\n\n__Motivation__\n\n[`buffer`](http://reactivex.io/documentation/operators/buffer.html) operator is useful for batching.\n\n__Modification__\n\nAdd `buffer()` operator for `Publisher` to buffer based on arbitrary buffer boundaries or based on size + time duration.\n\n__Result__\n\nUsers can buffer events from a `Publisher`.", "committedDate": "2020-04-29T00:32:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc4MDMyOA==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r418780328", "bodyText": "it isn't immediately obvious from an API perspective that BufferStrategy#boundaries() is used like a Supplier on each subscribe, but the BufferStrategy#bufferSizeHint() is used once when applying the operator.", "author": "Scottmitch", "createdAt": "2020-05-01T23:40:00Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherBuffer.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.ConcurrentSubscription.wrap;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.error;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n+\n+final class PublisherBuffer<T, B> extends AbstractAsynchronousPublisherOperator<T, B> {\n+    private final int bufferSizeHint;\n+    private final BufferStrategy<T, ?, B> bufferStrategy;\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final BufferStrategy<T, ?, B> bufferStrategy) {\n+        super(original, executor);\n+        bufferSizeHint = bufferStrategy.bufferSizeHint();\n+        if (bufferSizeHint <= 0) {\n+            throw new IllegalArgumentException(\"bufferSizeHint: \" + bufferSizeHint + \" (expected > 0)\");\n+        }\n+        this.bufferStrategy = bufferStrategy;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super B> subscriber) {\n+        return new BufferSubscriber<>(bufferStrategy.boundaries(), subscriber, bufferSizeHint);", "originalCommit": "c0c27efac7883d2436b1ca0b33875f63f64df6cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc1ODY4NA==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r419758684", "bodyText": "Good point, lemme get bufferSizeHint() for each subscribe.", "author": "NiteshKant", "createdAt": "2020-05-04T22:09:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc4MDMyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc4NDY4MQ==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r418784681", "bodyText": "can you clarify why this class needs to extend DelayedCancellable? I see that delayedCancellable is used, but this class isn't used as a Cancellable that I can see.", "author": "Scottmitch", "createdAt": "2020-05-02T00:03:39Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherBuffer.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.ConcurrentSubscription.wrap;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.error;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n+\n+final class PublisherBuffer<T, B> extends AbstractAsynchronousPublisherOperator<T, B> {\n+    private final int bufferSizeHint;\n+    private final BufferStrategy<T, ?, B> bufferStrategy;\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final BufferStrategy<T, ?, B> bufferStrategy) {\n+        super(original, executor);\n+        bufferSizeHint = bufferStrategy.bufferSizeHint();\n+        if (bufferSizeHint <= 0) {\n+            throw new IllegalArgumentException(\"bufferSizeHint: \" + bufferSizeHint + \" (expected > 0)\");\n+        }\n+        this.bufferStrategy = bufferStrategy;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super B> subscriber) {\n+        return new BufferSubscriber<>(bufferStrategy.boundaries(), subscriber, bufferSizeHint);\n+    }\n+\n+    private static final class BufferSubscriber<T, B> implements Subscriber<T> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BufferSubscriber> pendingUpdater =\n+                newUpdater(BufferSubscriber.class, \"pending\");\n+\n+        private final State state;\n+        private final DelayedCancellable tCancellable;\n+\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+        private volatile long pending;\n+\n+        BufferSubscriber(final Publisher<? extends Accumulator<T, B>> boundaries,\n+                         final Subscriber<? super B> target,\n+                         final int bufferSizeHint) {\n+            state = new State(bufferSizeHint);\n+            tCancellable = new DelayedCancellable();\n+            toSource(boundaries).subscribe(new BoundariesSubscriber<>(state, target, tCancellable));\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription subscription) {\n+            this.subscription = wrap(subscription);\n+            tCancellable.delayedCancellable(this.subscription);\n+            requestMoreItems(this.subscription);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final long pending = pendingUpdater.decrementAndGet(this);\n+            state.accumulate(t);\n+            if (pending == 0) {\n+                assert subscription != null;\n+                requestMoreItems(subscription);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            state.enqueueTermination(error(t));\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            state.enqueueTermination(complete());\n+        }\n+\n+        private void requestMoreItems(final Subscription subscription) {\n+            pendingUpdater.accumulateAndGet(this, state.bufferSizeHint,\n+                    FlowControlUtils::addWithOverflowProtection);\n+            subscription.request(state.bufferSizeHint);\n+        }\n+    }\n+\n+    private static final class BoundariesSubscriber<T, B> extends DelayedCancellable\n+            implements Subscriber<Accumulator<T, B>> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BoundariesSubscriber> pendingUpdater =\n+                newUpdater(BoundariesSubscriber.class, \"pending\");\n+        private final State state;\n+        private final Subscriber<? super B> target;\n+        private final Cancellable tCancellable;\n+\n+        private volatile long pending;\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+\n+        BoundariesSubscriber(final State state, final Subscriber<? super B> target, final Cancellable tCancellable) {\n+            this.state = state;\n+            this.target = target;\n+            this.tCancellable = tCancellable;\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription bSubscription) {\n+            subscription = wrap(new Subscription() {\n+                @Override\n+                public void request(final long n) {\n+                    if (isRequestNValid(n)) {\n+                        pendingUpdater.accumulateAndGet(BoundariesSubscriber.this, n,\n+                                FlowControlUtils::addWithOverflowProtection);\n+                    }\n+                    bSubscription.request(n);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    try {\n+                        bSubscription.cancel();\n+                    } finally {\n+                        tCancellable.cancel();\n+                    }\n+                }\n+            });\n+            delayedCancellable(subscription);", "originalCommit": "c0c27efac7883d2436b1ca0b33875f63f64df6cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc2OTMwMA==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r419769300", "bodyText": "This is actually a bug; the intent is to cancel it when original source terminates but that is missed here.", "author": "NiteshKant", "createdAt": "2020-05-04T22:36:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc4NDY4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc4ODEzOA==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r418788138", "bodyText": "should this go before the if (accumulator == null) check?", "author": "Scottmitch", "createdAt": "2020-05-02T00:24:56Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherBuffer.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.ConcurrentSubscription.wrap;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.error;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n+\n+final class PublisherBuffer<T, B> extends AbstractAsynchronousPublisherOperator<T, B> {\n+    private final int bufferSizeHint;\n+    private final BufferStrategy<T, ?, B> bufferStrategy;\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final BufferStrategy<T, ?, B> bufferStrategy) {\n+        super(original, executor);\n+        bufferSizeHint = bufferStrategy.bufferSizeHint();\n+        if (bufferSizeHint <= 0) {\n+            throw new IllegalArgumentException(\"bufferSizeHint: \" + bufferSizeHint + \" (expected > 0)\");\n+        }\n+        this.bufferStrategy = bufferStrategy;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super B> subscriber) {\n+        return new BufferSubscriber<>(bufferStrategy.boundaries(), subscriber, bufferSizeHint);\n+    }\n+\n+    private static final class BufferSubscriber<T, B> implements Subscriber<T> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BufferSubscriber> pendingUpdater =\n+                newUpdater(BufferSubscriber.class, \"pending\");\n+\n+        private final State state;\n+        private final DelayedCancellable tCancellable;\n+\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+        private volatile long pending;\n+\n+        BufferSubscriber(final Publisher<? extends Accumulator<T, B>> boundaries,\n+                         final Subscriber<? super B> target,\n+                         final int bufferSizeHint) {\n+            state = new State(bufferSizeHint);\n+            tCancellable = new DelayedCancellable();\n+            toSource(boundaries).subscribe(new BoundariesSubscriber<>(state, target, tCancellable));\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription subscription) {\n+            this.subscription = wrap(subscription);\n+            tCancellable.delayedCancellable(this.subscription);\n+            requestMoreItems(this.subscription);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final long pending = pendingUpdater.decrementAndGet(this);\n+            state.accumulate(t);\n+            if (pending == 0) {\n+                assert subscription != null;\n+                requestMoreItems(subscription);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            state.enqueueTermination(error(t));\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            state.enqueueTermination(complete());\n+        }\n+\n+        private void requestMoreItems(final Subscription subscription) {\n+            pendingUpdater.accumulateAndGet(this, state.bufferSizeHint,\n+                    FlowControlUtils::addWithOverflowProtection);\n+            subscription.request(state.bufferSizeHint);\n+        }\n+    }\n+\n+    private static final class BoundariesSubscriber<T, B> extends DelayedCancellable\n+            implements Subscriber<Accumulator<T, B>> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BoundariesSubscriber> pendingUpdater =\n+                newUpdater(BoundariesSubscriber.class, \"pending\");\n+        private final State state;\n+        private final Subscriber<? super B> target;\n+        private final Cancellable tCancellable;\n+\n+        private volatile long pending;\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+\n+        BoundariesSubscriber(final State state, final Subscriber<? super B> target, final Cancellable tCancellable) {\n+            this.state = state;\n+            this.target = target;\n+            this.tCancellable = tCancellable;\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription bSubscription) {\n+            subscription = wrap(new Subscription() {\n+                @Override\n+                public void request(final long n) {\n+                    if (isRequestNValid(n)) {\n+                        pendingUpdater.accumulateAndGet(BoundariesSubscriber.this, n,\n+                                FlowControlUtils::addWithOverflowProtection);\n+                    }\n+                    bSubscription.request(n);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    try {\n+                        bSubscription.cancel();\n+                    } finally {\n+                        tCancellable.cancel();\n+                    }\n+                }\n+            });\n+            delayedCancellable(subscription);\n+            target.onSubscribe(subscription);\n+        }\n+\n+        @Override\n+        public void onNext(final Accumulator<T, B> accumulator) {\n+            if (accumulator == null) {\n+                return;\n+            }\n+            pendingUpdater.decrementAndGet(this);", "originalCommit": "c0c27efac7883d2436b1ca0b33875f63f64df6cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc3MDExMw==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r419770113", "bodyText": "hmm, lemme replace accumulator == null check with requireNonNull(accumulator)", "author": "NiteshKant", "createdAt": "2020-05-04T22:38:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc4ODEzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc5MTg5OA==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r418791898", "bodyText": "nit: consider using break for consistency with other escape hatches in this loop.", "author": "Scottmitch", "createdAt": "2020-05-02T00:34:44Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherBuffer.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.ConcurrentSubscription.wrap;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.error;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n+\n+final class PublisherBuffer<T, B> extends AbstractAsynchronousPublisherOperator<T, B> {\n+    private final int bufferSizeHint;\n+    private final BufferStrategy<T, ?, B> bufferStrategy;\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final BufferStrategy<T, ?, B> bufferStrategy) {\n+        super(original, executor);\n+        bufferSizeHint = bufferStrategy.bufferSizeHint();\n+        if (bufferSizeHint <= 0) {\n+            throw new IllegalArgumentException(\"bufferSizeHint: \" + bufferSizeHint + \" (expected > 0)\");\n+        }\n+        this.bufferStrategy = bufferStrategy;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super B> subscriber) {\n+        return new BufferSubscriber<>(bufferStrategy.boundaries(), subscriber, bufferSizeHint);\n+    }\n+\n+    private static final class BufferSubscriber<T, B> implements Subscriber<T> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BufferSubscriber> pendingUpdater =\n+                newUpdater(BufferSubscriber.class, \"pending\");\n+\n+        private final State state;\n+        private final DelayedCancellable tCancellable;\n+\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+        private volatile long pending;\n+\n+        BufferSubscriber(final Publisher<? extends Accumulator<T, B>> boundaries,\n+                         final Subscriber<? super B> target,\n+                         final int bufferSizeHint) {\n+            state = new State(bufferSizeHint);\n+            tCancellable = new DelayedCancellable();\n+            toSource(boundaries).subscribe(new BoundariesSubscriber<>(state, target, tCancellable));\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription subscription) {\n+            this.subscription = wrap(subscription);\n+            tCancellable.delayedCancellable(this.subscription);\n+            requestMoreItems(this.subscription);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final long pending = pendingUpdater.decrementAndGet(this);\n+            state.accumulate(t);\n+            if (pending == 0) {\n+                assert subscription != null;\n+                requestMoreItems(subscription);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            state.enqueueTermination(error(t));\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            state.enqueueTermination(complete());\n+        }\n+\n+        private void requestMoreItems(final Subscription subscription) {\n+            pendingUpdater.accumulateAndGet(this, state.bufferSizeHint,\n+                    FlowControlUtils::addWithOverflowProtection);\n+            subscription.request(state.bufferSizeHint);\n+        }\n+    }\n+\n+    private static final class BoundariesSubscriber<T, B> extends DelayedCancellable\n+            implements Subscriber<Accumulator<T, B>> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BoundariesSubscriber> pendingUpdater =\n+                newUpdater(BoundariesSubscriber.class, \"pending\");\n+        private final State state;\n+        private final Subscriber<? super B> target;\n+        private final Cancellable tCancellable;\n+\n+        private volatile long pending;\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+\n+        BoundariesSubscriber(final State state, final Subscriber<? super B> target, final Cancellable tCancellable) {\n+            this.state = state;\n+            this.target = target;\n+            this.tCancellable = tCancellable;\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription bSubscription) {\n+            subscription = wrap(new Subscription() {\n+                @Override\n+                public void request(final long n) {\n+                    if (isRequestNValid(n)) {\n+                        pendingUpdater.accumulateAndGet(BoundariesSubscriber.this, n,\n+                                FlowControlUtils::addWithOverflowProtection);\n+                    }\n+                    bSubscription.request(n);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    try {\n+                        bSubscription.cancel();\n+                    } finally {\n+                        tCancellable.cancel();\n+                    }\n+                }\n+            });\n+            delayedCancellable(subscription);\n+            target.onSubscribe(subscription);\n+        }\n+\n+        @Override\n+        public void onNext(final Accumulator<T, B> accumulator) {\n+            if (accumulator == null) {\n+                return;\n+            }\n+            pendingUpdater.decrementAndGet(this);\n+            if (!state.nextAccumulator(accumulator, target)) {\n+                assert subscription != null;\n+                pendingUpdater.incrementAndGet(this);\n+                subscription.request(1);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            try {\n+                state.boundariesTerminated(t, target);\n+            } finally {\n+                tCancellable.cancel();\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            try {\n+                state.boundariesTerminated(new IllegalStateException(\"Boundaries source completed unexpectedly.\"),\n+                        target);\n+            } finally {\n+                tCancellable.cancel();\n+            }\n+        }\n+    }\n+\n+    private static final class State {\n+        private static final Object ADDING = new Object();\n+        private static final Object DRAINING_TMP_ACCUMULATOR = new Object();\n+        private static final Object TERMINATED = new Object();\n+        private static final AtomicReferenceFieldUpdater<State, Object> maybeAccumulatorUpdater =\n+                AtomicReferenceFieldUpdater.newUpdater(State.class, Object.class, \"maybeAccumulator\");\n+\n+        private final int bufferSizeHint;\n+        /**\n+         * Following values are assigned to this variable:\n+         * <ul>\n+         *     <li>Instance of {@link TmpAccumulator} if a real {@link Accumulator} can not be set.</li>\n+         *     <li>{@link #DRAINING_TMP_ACCUMULATOR} if a {@link TmpAccumulator} instance is currently being drained\n+         *     into an actual {@link Accumulator}.</li>\n+         *     <li>{@link #ADDING} if an item is being added to the currently active {@link Accumulator}</li>\n+         *     <li>{@link ItemsTerminated} if the items source terminated but the target is not yet terminated.</li>\n+         *     <li>{@link #TERMINATED} if the target subscriber has been terminated (or cancelled).</li>\n+         *     <li>{@link Accumulator} (not {@link TmpAccumulator} which is emitted by the boundaries source.</li>\n+         * </ul>\n+         */\n+        private volatile Object maybeAccumulator;\n+\n+        State(final int bufferSizeHint) {\n+            this.bufferSizeHint = bufferSizeHint;\n+            maybeAccumulator = new TmpAccumulator<>(bufferSizeHint);\n+        }\n+\n+        <T> void accumulate(@Nullable final T item) {\n+            for (;;) {\n+                final Object cMaybeAccumulator = maybeAccumulator;\n+                if (cMaybeAccumulator == TERMINATED || cMaybeAccumulator instanceof ItemsTerminated) {\n+                    return;", "originalCommit": "c0c27efac7883d2436b1ca0b33875f63f64df6cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc3MDcxNQ==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r419770715", "bodyText": "We have moved back-and-forth on this in general. I think what we have been doing is that if it is terminal then we use return indicating nothing else (after for(;;)) should be done and use break when any other action after for(;;) is OK to do. I think this distinction makes sense so I will stick to it.", "author": "NiteshKant", "createdAt": "2020-05-04T22:40:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc5MTg5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE5OTQwMA==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r422199400", "bodyText": "fine as is but just to clarify the thought process ... it think the general pattern is \"use return to avoid executing code after the loop\" which requires code after the loop to judge. this case it is ambiguous (and fine as is) bcz there is no code after the loop, but the  \"use return if a terminal event\" strategy may not be appropriate in all scenarios (e.g. cleanup code after the loop, additional unrelated logic to the Subscriber, etc...) and is not consistently followed in our code base (even in this PR).", "author": "Scottmitch", "createdAt": "2020-05-08T15:10:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc5MTg5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODgxMDA3NA==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r418810074", "bodyText": "nit: move this cast inside the conditional where it is used.", "author": "Scottmitch", "createdAt": "2020-05-02T01:15:54Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherBuffer.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.ConcurrentSubscription.wrap;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.error;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n+\n+final class PublisherBuffer<T, B> extends AbstractAsynchronousPublisherOperator<T, B> {\n+    private final int bufferSizeHint;\n+    private final BufferStrategy<T, ?, B> bufferStrategy;\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final BufferStrategy<T, ?, B> bufferStrategy) {\n+        super(original, executor);\n+        bufferSizeHint = bufferStrategy.bufferSizeHint();\n+        if (bufferSizeHint <= 0) {\n+            throw new IllegalArgumentException(\"bufferSizeHint: \" + bufferSizeHint + \" (expected > 0)\");\n+        }\n+        this.bufferStrategy = bufferStrategy;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super B> subscriber) {\n+        return new BufferSubscriber<>(bufferStrategy.boundaries(), subscriber, bufferSizeHint);\n+    }\n+\n+    private static final class BufferSubscriber<T, B> implements Subscriber<T> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BufferSubscriber> pendingUpdater =\n+                newUpdater(BufferSubscriber.class, \"pending\");\n+\n+        private final State state;\n+        private final DelayedCancellable tCancellable;\n+\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+        private volatile long pending;\n+\n+        BufferSubscriber(final Publisher<? extends Accumulator<T, B>> boundaries,\n+                         final Subscriber<? super B> target,\n+                         final int bufferSizeHint) {\n+            state = new State(bufferSizeHint);\n+            tCancellable = new DelayedCancellable();\n+            toSource(boundaries).subscribe(new BoundariesSubscriber<>(state, target, tCancellable));\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription subscription) {\n+            this.subscription = wrap(subscription);\n+            tCancellable.delayedCancellable(this.subscription);\n+            requestMoreItems(this.subscription);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final long pending = pendingUpdater.decrementAndGet(this);\n+            state.accumulate(t);\n+            if (pending == 0) {\n+                assert subscription != null;\n+                requestMoreItems(subscription);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            state.enqueueTermination(error(t));\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            state.enqueueTermination(complete());\n+        }\n+\n+        private void requestMoreItems(final Subscription subscription) {\n+            pendingUpdater.accumulateAndGet(this, state.bufferSizeHint,\n+                    FlowControlUtils::addWithOverflowProtection);\n+            subscription.request(state.bufferSizeHint);\n+        }\n+    }\n+\n+    private static final class BoundariesSubscriber<T, B> extends DelayedCancellable\n+            implements Subscriber<Accumulator<T, B>> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BoundariesSubscriber> pendingUpdater =\n+                newUpdater(BoundariesSubscriber.class, \"pending\");\n+        private final State state;\n+        private final Subscriber<? super B> target;\n+        private final Cancellable tCancellable;\n+\n+        private volatile long pending;\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+\n+        BoundariesSubscriber(final State state, final Subscriber<? super B> target, final Cancellable tCancellable) {\n+            this.state = state;\n+            this.target = target;\n+            this.tCancellable = tCancellable;\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription bSubscription) {\n+            subscription = wrap(new Subscription() {\n+                @Override\n+                public void request(final long n) {\n+                    if (isRequestNValid(n)) {\n+                        pendingUpdater.accumulateAndGet(BoundariesSubscriber.this, n,\n+                                FlowControlUtils::addWithOverflowProtection);\n+                    }\n+                    bSubscription.request(n);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    try {\n+                        bSubscription.cancel();\n+                    } finally {\n+                        tCancellable.cancel();\n+                    }\n+                }\n+            });\n+            delayedCancellable(subscription);\n+            target.onSubscribe(subscription);\n+        }\n+\n+        @Override\n+        public void onNext(final Accumulator<T, B> accumulator) {\n+            if (accumulator == null) {\n+                return;\n+            }\n+            pendingUpdater.decrementAndGet(this);\n+            if (!state.nextAccumulator(accumulator, target)) {\n+                assert subscription != null;\n+                pendingUpdater.incrementAndGet(this);\n+                subscription.request(1);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            try {\n+                state.boundariesTerminated(t, target);\n+            } finally {\n+                tCancellable.cancel();\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            try {\n+                state.boundariesTerminated(new IllegalStateException(\"Boundaries source completed unexpectedly.\"),\n+                        target);\n+            } finally {\n+                tCancellable.cancel();\n+            }\n+        }\n+    }\n+\n+    private static final class State {\n+        private static final Object ADDING = new Object();\n+        private static final Object DRAINING_TMP_ACCUMULATOR = new Object();\n+        private static final Object TERMINATED = new Object();\n+        private static final AtomicReferenceFieldUpdater<State, Object> maybeAccumulatorUpdater =\n+                AtomicReferenceFieldUpdater.newUpdater(State.class, Object.class, \"maybeAccumulator\");\n+\n+        private final int bufferSizeHint;\n+        /**\n+         * Following values are assigned to this variable:\n+         * <ul>\n+         *     <li>Instance of {@link TmpAccumulator} if a real {@link Accumulator} can not be set.</li>\n+         *     <li>{@link #DRAINING_TMP_ACCUMULATOR} if a {@link TmpAccumulator} instance is currently being drained\n+         *     into an actual {@link Accumulator}.</li>\n+         *     <li>{@link #ADDING} if an item is being added to the currently active {@link Accumulator}</li>\n+         *     <li>{@link ItemsTerminated} if the items source terminated but the target is not yet terminated.</li>\n+         *     <li>{@link #TERMINATED} if the target subscriber has been terminated (or cancelled).</li>\n+         *     <li>{@link Accumulator} (not {@link TmpAccumulator} which is emitted by the boundaries source.</li>\n+         * </ul>\n+         */\n+        private volatile Object maybeAccumulator;\n+\n+        State(final int bufferSizeHint) {\n+            this.bufferSizeHint = bufferSizeHint;\n+            maybeAccumulator = new TmpAccumulator<>(bufferSizeHint);\n+        }\n+\n+        <T> void accumulate(@Nullable final T item) {\n+            for (;;) {\n+                final Object cMaybeAccumulator = maybeAccumulator;\n+                if (cMaybeAccumulator == TERMINATED || cMaybeAccumulator instanceof ItemsTerminated) {\n+                    return;\n+                }\n+                assert cMaybeAccumulator != ADDING;\n+                if (cMaybeAccumulator == DRAINING_TMP_ACCUMULATOR) {\n+                    TmpAccumulator<T> tmpAccumulator = new TmpAccumulator<>(bufferSizeHint);\n+                    tmpAccumulator.accumulate(item);\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, DRAINING_TMP_ACCUMULATOR, tmpAccumulator)) {\n+                        break;\n+                    }\n+                } else if (maybeAccumulatorUpdater.compareAndSet(this, cMaybeAccumulator, ADDING)) {\n+                    assert cMaybeAccumulator instanceof Accumulator;\n+                    @SuppressWarnings(\"unchecked\")\n+                    final Accumulator<T, ?> accumulator = (Accumulator<T, ?>) cMaybeAccumulator;\n+                    accumulator.accumulate(item);\n+\n+                    maybeAccumulatorUpdater.getAndAccumulate(this, accumulator,\n+                            (prev, next) -> prev == TERMINATED ? TERMINATED : next);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        <T, B> boolean nextAccumulator(final Accumulator<T, B> nextAccumulator, final Subscriber<? super B> target) {\n+            requireNonNull(nextAccumulator);\n+            for (;;) {\n+                final Object cMaybeAccumulator = maybeAccumulator;\n+                if (cMaybeAccumulator == TERMINATED) {\n+                    return true;\n+                }\n+                if (cMaybeAccumulator == ADDING) {\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, ADDING, nextAccumulator)) {\n+                        return false;\n+                    }\n+                } else if (cMaybeAccumulator instanceof ItemsTerminated) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    ItemsTerminated<T, B> itemsTerminated = (ItemsTerminated<T, B>) cMaybeAccumulator;", "originalCommit": "c0c27efac7883d2436b1ca0b33875f63f64df6cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODgxMDM1Ng==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r418810356", "bodyText": "nit: move this cast inside the conditional where it is used.", "author": "Scottmitch", "createdAt": "2020-05-02T01:16:30Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherBuffer.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.ConcurrentSubscription.wrap;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.error;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n+\n+final class PublisherBuffer<T, B> extends AbstractAsynchronousPublisherOperator<T, B> {\n+    private final int bufferSizeHint;\n+    private final BufferStrategy<T, ?, B> bufferStrategy;\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final BufferStrategy<T, ?, B> bufferStrategy) {\n+        super(original, executor);\n+        bufferSizeHint = bufferStrategy.bufferSizeHint();\n+        if (bufferSizeHint <= 0) {\n+            throw new IllegalArgumentException(\"bufferSizeHint: \" + bufferSizeHint + \" (expected > 0)\");\n+        }\n+        this.bufferStrategy = bufferStrategy;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super B> subscriber) {\n+        return new BufferSubscriber<>(bufferStrategy.boundaries(), subscriber, bufferSizeHint);\n+    }\n+\n+    private static final class BufferSubscriber<T, B> implements Subscriber<T> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BufferSubscriber> pendingUpdater =\n+                newUpdater(BufferSubscriber.class, \"pending\");\n+\n+        private final State state;\n+        private final DelayedCancellable tCancellable;\n+\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+        private volatile long pending;\n+\n+        BufferSubscriber(final Publisher<? extends Accumulator<T, B>> boundaries,\n+                         final Subscriber<? super B> target,\n+                         final int bufferSizeHint) {\n+            state = new State(bufferSizeHint);\n+            tCancellable = new DelayedCancellable();\n+            toSource(boundaries).subscribe(new BoundariesSubscriber<>(state, target, tCancellable));\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription subscription) {\n+            this.subscription = wrap(subscription);\n+            tCancellable.delayedCancellable(this.subscription);\n+            requestMoreItems(this.subscription);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final long pending = pendingUpdater.decrementAndGet(this);\n+            state.accumulate(t);\n+            if (pending == 0) {\n+                assert subscription != null;\n+                requestMoreItems(subscription);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            state.enqueueTermination(error(t));\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            state.enqueueTermination(complete());\n+        }\n+\n+        private void requestMoreItems(final Subscription subscription) {\n+            pendingUpdater.accumulateAndGet(this, state.bufferSizeHint,\n+                    FlowControlUtils::addWithOverflowProtection);\n+            subscription.request(state.bufferSizeHint);\n+        }\n+    }\n+\n+    private static final class BoundariesSubscriber<T, B> extends DelayedCancellable\n+            implements Subscriber<Accumulator<T, B>> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BoundariesSubscriber> pendingUpdater =\n+                newUpdater(BoundariesSubscriber.class, \"pending\");\n+        private final State state;\n+        private final Subscriber<? super B> target;\n+        private final Cancellable tCancellable;\n+\n+        private volatile long pending;\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+\n+        BoundariesSubscriber(final State state, final Subscriber<? super B> target, final Cancellable tCancellable) {\n+            this.state = state;\n+            this.target = target;\n+            this.tCancellable = tCancellable;\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription bSubscription) {\n+            subscription = wrap(new Subscription() {\n+                @Override\n+                public void request(final long n) {\n+                    if (isRequestNValid(n)) {\n+                        pendingUpdater.accumulateAndGet(BoundariesSubscriber.this, n,\n+                                FlowControlUtils::addWithOverflowProtection);\n+                    }\n+                    bSubscription.request(n);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    try {\n+                        bSubscription.cancel();\n+                    } finally {\n+                        tCancellable.cancel();\n+                    }\n+                }\n+            });\n+            delayedCancellable(subscription);\n+            target.onSubscribe(subscription);\n+        }\n+\n+        @Override\n+        public void onNext(final Accumulator<T, B> accumulator) {\n+            if (accumulator == null) {\n+                return;\n+            }\n+            pendingUpdater.decrementAndGet(this);\n+            if (!state.nextAccumulator(accumulator, target)) {\n+                assert subscription != null;\n+                pendingUpdater.incrementAndGet(this);\n+                subscription.request(1);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            try {\n+                state.boundariesTerminated(t, target);\n+            } finally {\n+                tCancellable.cancel();\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            try {\n+                state.boundariesTerminated(new IllegalStateException(\"Boundaries source completed unexpectedly.\"),\n+                        target);\n+            } finally {\n+                tCancellable.cancel();\n+            }\n+        }\n+    }\n+\n+    private static final class State {\n+        private static final Object ADDING = new Object();\n+        private static final Object DRAINING_TMP_ACCUMULATOR = new Object();\n+        private static final Object TERMINATED = new Object();\n+        private static final AtomicReferenceFieldUpdater<State, Object> maybeAccumulatorUpdater =\n+                AtomicReferenceFieldUpdater.newUpdater(State.class, Object.class, \"maybeAccumulator\");\n+\n+        private final int bufferSizeHint;\n+        /**\n+         * Following values are assigned to this variable:\n+         * <ul>\n+         *     <li>Instance of {@link TmpAccumulator} if a real {@link Accumulator} can not be set.</li>\n+         *     <li>{@link #DRAINING_TMP_ACCUMULATOR} if a {@link TmpAccumulator} instance is currently being drained\n+         *     into an actual {@link Accumulator}.</li>\n+         *     <li>{@link #ADDING} if an item is being added to the currently active {@link Accumulator}</li>\n+         *     <li>{@link ItemsTerminated} if the items source terminated but the target is not yet terminated.</li>\n+         *     <li>{@link #TERMINATED} if the target subscriber has been terminated (or cancelled).</li>\n+         *     <li>{@link Accumulator} (not {@link TmpAccumulator} which is emitted by the boundaries source.</li>\n+         * </ul>\n+         */\n+        private volatile Object maybeAccumulator;\n+\n+        State(final int bufferSizeHint) {\n+            this.bufferSizeHint = bufferSizeHint;\n+            maybeAccumulator = new TmpAccumulator<>(bufferSizeHint);\n+        }\n+\n+        <T> void accumulate(@Nullable final T item) {\n+            for (;;) {\n+                final Object cMaybeAccumulator = maybeAccumulator;\n+                if (cMaybeAccumulator == TERMINATED || cMaybeAccumulator instanceof ItemsTerminated) {\n+                    return;\n+                }\n+                assert cMaybeAccumulator != ADDING;\n+                if (cMaybeAccumulator == DRAINING_TMP_ACCUMULATOR) {\n+                    TmpAccumulator<T> tmpAccumulator = new TmpAccumulator<>(bufferSizeHint);\n+                    tmpAccumulator.accumulate(item);\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, DRAINING_TMP_ACCUMULATOR, tmpAccumulator)) {\n+                        break;\n+                    }\n+                } else if (maybeAccumulatorUpdater.compareAndSet(this, cMaybeAccumulator, ADDING)) {\n+                    assert cMaybeAccumulator instanceof Accumulator;\n+                    @SuppressWarnings(\"unchecked\")\n+                    final Accumulator<T, ?> accumulator = (Accumulator<T, ?>) cMaybeAccumulator;\n+                    accumulator.accumulate(item);\n+\n+                    maybeAccumulatorUpdater.getAndAccumulate(this, accumulator,\n+                            (prev, next) -> prev == TERMINATED ? TERMINATED : next);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        <T, B> boolean nextAccumulator(final Accumulator<T, B> nextAccumulator, final Subscriber<? super B> target) {\n+            requireNonNull(nextAccumulator);\n+            for (;;) {\n+                final Object cMaybeAccumulator = maybeAccumulator;\n+                if (cMaybeAccumulator == TERMINATED) {\n+                    return true;\n+                }\n+                if (cMaybeAccumulator == ADDING) {\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, ADDING, nextAccumulator)) {\n+                        return false;\n+                    }\n+                } else if (cMaybeAccumulator instanceof ItemsTerminated) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    ItemsTerminated<T, B> itemsTerminated = (ItemsTerminated<T, B>) cMaybeAccumulator;\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, cMaybeAccumulator, TERMINATED)) {\n+                        itemsTerminated.terminate(nextAccumulator, target);\n+                        return true;\n+                    }\n+                } else if (cMaybeAccumulator instanceof TmpAccumulator) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    TmpAccumulator<T> tmpAccumulator = (TmpAccumulator<T>) cMaybeAccumulator;", "originalCommit": "c0c27efac7883d2436b1ca0b33875f63f64df6cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODgxMTUzMQ==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r418811531", "bodyText": "if this throws we won't propagate the error because maybeAccumulatorUpdater has been set to TERMINATED. Consider adding a try/catch to deliver the error locally.", "author": "Scottmitch", "createdAt": "2020-05-02T01:19:24Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherBuffer.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.ConcurrentSubscription.wrap;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.error;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n+\n+final class PublisherBuffer<T, B> extends AbstractAsynchronousPublisherOperator<T, B> {\n+    private final int bufferSizeHint;\n+    private final BufferStrategy<T, ?, B> bufferStrategy;\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final BufferStrategy<T, ?, B> bufferStrategy) {\n+        super(original, executor);\n+        bufferSizeHint = bufferStrategy.bufferSizeHint();\n+        if (bufferSizeHint <= 0) {\n+            throw new IllegalArgumentException(\"bufferSizeHint: \" + bufferSizeHint + \" (expected > 0)\");\n+        }\n+        this.bufferStrategy = bufferStrategy;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super B> subscriber) {\n+        return new BufferSubscriber<>(bufferStrategy.boundaries(), subscriber, bufferSizeHint);\n+    }\n+\n+    private static final class BufferSubscriber<T, B> implements Subscriber<T> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BufferSubscriber> pendingUpdater =\n+                newUpdater(BufferSubscriber.class, \"pending\");\n+\n+        private final State state;\n+        private final DelayedCancellable tCancellable;\n+\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+        private volatile long pending;\n+\n+        BufferSubscriber(final Publisher<? extends Accumulator<T, B>> boundaries,\n+                         final Subscriber<? super B> target,\n+                         final int bufferSizeHint) {\n+            state = new State(bufferSizeHint);\n+            tCancellable = new DelayedCancellable();\n+            toSource(boundaries).subscribe(new BoundariesSubscriber<>(state, target, tCancellable));\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription subscription) {\n+            this.subscription = wrap(subscription);\n+            tCancellable.delayedCancellable(this.subscription);\n+            requestMoreItems(this.subscription);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final long pending = pendingUpdater.decrementAndGet(this);\n+            state.accumulate(t);\n+            if (pending == 0) {\n+                assert subscription != null;\n+                requestMoreItems(subscription);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            state.enqueueTermination(error(t));\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            state.enqueueTermination(complete());\n+        }\n+\n+        private void requestMoreItems(final Subscription subscription) {\n+            pendingUpdater.accumulateAndGet(this, state.bufferSizeHint,\n+                    FlowControlUtils::addWithOverflowProtection);\n+            subscription.request(state.bufferSizeHint);\n+        }\n+    }\n+\n+    private static final class BoundariesSubscriber<T, B> extends DelayedCancellable\n+            implements Subscriber<Accumulator<T, B>> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BoundariesSubscriber> pendingUpdater =\n+                newUpdater(BoundariesSubscriber.class, \"pending\");\n+        private final State state;\n+        private final Subscriber<? super B> target;\n+        private final Cancellable tCancellable;\n+\n+        private volatile long pending;\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+\n+        BoundariesSubscriber(final State state, final Subscriber<? super B> target, final Cancellable tCancellable) {\n+            this.state = state;\n+            this.target = target;\n+            this.tCancellable = tCancellable;\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription bSubscription) {\n+            subscription = wrap(new Subscription() {\n+                @Override\n+                public void request(final long n) {\n+                    if (isRequestNValid(n)) {\n+                        pendingUpdater.accumulateAndGet(BoundariesSubscriber.this, n,\n+                                FlowControlUtils::addWithOverflowProtection);\n+                    }\n+                    bSubscription.request(n);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    try {\n+                        bSubscription.cancel();\n+                    } finally {\n+                        tCancellable.cancel();\n+                    }\n+                }\n+            });\n+            delayedCancellable(subscription);\n+            target.onSubscribe(subscription);\n+        }\n+\n+        @Override\n+        public void onNext(final Accumulator<T, B> accumulator) {\n+            if (accumulator == null) {\n+                return;\n+            }\n+            pendingUpdater.decrementAndGet(this);\n+            if (!state.nextAccumulator(accumulator, target)) {\n+                assert subscription != null;\n+                pendingUpdater.incrementAndGet(this);\n+                subscription.request(1);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            try {\n+                state.boundariesTerminated(t, target);\n+            } finally {\n+                tCancellable.cancel();\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            try {\n+                state.boundariesTerminated(new IllegalStateException(\"Boundaries source completed unexpectedly.\"),\n+                        target);\n+            } finally {\n+                tCancellable.cancel();\n+            }\n+        }\n+    }\n+\n+    private static final class State {\n+        private static final Object ADDING = new Object();\n+        private static final Object DRAINING_TMP_ACCUMULATOR = new Object();\n+        private static final Object TERMINATED = new Object();\n+        private static final AtomicReferenceFieldUpdater<State, Object> maybeAccumulatorUpdater =\n+                AtomicReferenceFieldUpdater.newUpdater(State.class, Object.class, \"maybeAccumulator\");\n+\n+        private final int bufferSizeHint;\n+        /**\n+         * Following values are assigned to this variable:\n+         * <ul>\n+         *     <li>Instance of {@link TmpAccumulator} if a real {@link Accumulator} can not be set.</li>\n+         *     <li>{@link #DRAINING_TMP_ACCUMULATOR} if a {@link TmpAccumulator} instance is currently being drained\n+         *     into an actual {@link Accumulator}.</li>\n+         *     <li>{@link #ADDING} if an item is being added to the currently active {@link Accumulator}</li>\n+         *     <li>{@link ItemsTerminated} if the items source terminated but the target is not yet terminated.</li>\n+         *     <li>{@link #TERMINATED} if the target subscriber has been terminated (or cancelled).</li>\n+         *     <li>{@link Accumulator} (not {@link TmpAccumulator} which is emitted by the boundaries source.</li>\n+         * </ul>\n+         */\n+        private volatile Object maybeAccumulator;\n+\n+        State(final int bufferSizeHint) {\n+            this.bufferSizeHint = bufferSizeHint;\n+            maybeAccumulator = new TmpAccumulator<>(bufferSizeHint);\n+        }\n+\n+        <T> void accumulate(@Nullable final T item) {\n+            for (;;) {\n+                final Object cMaybeAccumulator = maybeAccumulator;\n+                if (cMaybeAccumulator == TERMINATED || cMaybeAccumulator instanceof ItemsTerminated) {\n+                    return;\n+                }\n+                assert cMaybeAccumulator != ADDING;\n+                if (cMaybeAccumulator == DRAINING_TMP_ACCUMULATOR) {\n+                    TmpAccumulator<T> tmpAccumulator = new TmpAccumulator<>(bufferSizeHint);\n+                    tmpAccumulator.accumulate(item);\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, DRAINING_TMP_ACCUMULATOR, tmpAccumulator)) {\n+                        break;\n+                    }\n+                } else if (maybeAccumulatorUpdater.compareAndSet(this, cMaybeAccumulator, ADDING)) {\n+                    assert cMaybeAccumulator instanceof Accumulator;\n+                    @SuppressWarnings(\"unchecked\")\n+                    final Accumulator<T, ?> accumulator = (Accumulator<T, ?>) cMaybeAccumulator;\n+                    accumulator.accumulate(item);\n+\n+                    maybeAccumulatorUpdater.getAndAccumulate(this, accumulator,\n+                            (prev, next) -> prev == TERMINATED ? TERMINATED : next);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        <T, B> boolean nextAccumulator(final Accumulator<T, B> nextAccumulator, final Subscriber<? super B> target) {\n+            requireNonNull(nextAccumulator);\n+            for (;;) {\n+                final Object cMaybeAccumulator = maybeAccumulator;\n+                if (cMaybeAccumulator == TERMINATED) {\n+                    return true;\n+                }\n+                if (cMaybeAccumulator == ADDING) {\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, ADDING, nextAccumulator)) {\n+                        return false;\n+                    }\n+                } else if (cMaybeAccumulator instanceof ItemsTerminated) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    ItemsTerminated<T, B> itemsTerminated = (ItemsTerminated<T, B>) cMaybeAccumulator;\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, cMaybeAccumulator, TERMINATED)) {\n+                        itemsTerminated.terminate(nextAccumulator, target);\n+                        return true;\n+                    }\n+                } else if (cMaybeAccumulator instanceof TmpAccumulator) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    TmpAccumulator<T> tmpAccumulator = (TmpAccumulator<T>) cMaybeAccumulator;\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, cMaybeAccumulator, DRAINING_TMP_ACCUMULATOR)) {\n+                        tmpAccumulator.transferToActual(nextAccumulator);\n+                        // We can only emit one result per boundary closure. So, we move out of\n+                        // DRAINING_TMP_ACCUMULATOR state and process the state change in the next boundary closure.\n+                        if (maybeAccumulatorUpdater.compareAndSet(this, DRAINING_TMP_ACCUMULATOR, nextAccumulator)) {\n+                            return false;\n+                        } else {\n+                            target.onNext(nextAccumulator.finish());\n+                            return true;\n+                        }\n+                    }\n+                } else {\n+                    assert cMaybeAccumulator instanceof Accumulator;\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, cMaybeAccumulator, nextAccumulator)) {\n+                        @SuppressWarnings(\"unchecked\")\n+                        Accumulator<T, B> oldAccumulator = (Accumulator<T, B>) cMaybeAccumulator;\n+                        target.onNext(oldAccumulator.finish());\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+\n+        void enqueueTermination(final TerminalNotification terminalNotification) {\n+            maybeAccumulatorUpdater.accumulateAndGet(this, terminalNotification, (prev, next) -> {\n+                if (prev == TERMINATED) {\n+                    return TERMINATED;\n+                }\n+                assert !(prev instanceof ItemsTerminated);\n+                return new ItemsTerminated<>(prev, (TerminalNotification) next);\n+            });\n+        }\n+\n+        void boundariesTerminated(final Throwable cause, final Subscriber<?> target) {\n+            if (maybeAccumulatorUpdater.getAndSet(this, TERMINATED) != TERMINATED) {\n+                target.onError(cause);\n+            }\n+        }\n+    }\n+\n+    private static final class TmpAccumulator<T> implements Accumulator<T, List<T>> {\n+        private final List<T> items;\n+\n+        TmpAccumulator(final int bufferSizeHint) {\n+            items = new ArrayList<>(bufferSizeHint);\n+        }\n+\n+        @Override\n+        public void accumulate(@Nullable final T item) {\n+            items.add(item);\n+        }\n+\n+        @Override\n+        public List<T> finish() {\n+            return items;\n+        }\n+\n+        void transferToActual(final Accumulator<T, ?> accumulator) {\n+            for (T item : finish()) {\n+                accumulator.accumulate(item);\n+            }\n+        }\n+    }\n+\n+    private static final class ItemsTerminated<T, B> {\n+        @Nullable\n+        private final Function<Accumulator<T, B>, B> bufferProvider;\n+        private final TerminalNotification terminalNotification;\n+\n+        ItemsTerminated(final Object maybeAccumulator, final TerminalNotification terminalNotification) {\n+            if (maybeAccumulator instanceof TmpAccumulator) {\n+                @SuppressWarnings(\"unchecked\")\n+                TmpAccumulator<T> tmpAccumulator = (TmpAccumulator<T>) maybeAccumulator;\n+                bufferProvider = nextAccumulator -> {\n+                    tmpAccumulator.transferToActual(nextAccumulator);\n+                    return nextAccumulator.finish();\n+                };\n+            } else if (maybeAccumulator instanceof Accumulator) {\n+                @SuppressWarnings(\"unchecked\")\n+                Accumulator<T, B> accumulator = (Accumulator<T, B>) maybeAccumulator;\n+                this.bufferProvider = __ -> accumulator.finish();\n+            } else {\n+                bufferProvider = null;\n+            }\n+            this.terminalNotification = terminalNotification;\n+        }\n+\n+        void terminate(final Accumulator<T, B> nextAccumulator, final Subscriber<? super B> target) {\n+            if (bufferProvider != null) {\n+                target.onNext(bufferProvider.apply(nextAccumulator));", "originalCommit": "c0c27efac7883d2436b1ca0b33875f63f64df6cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc3NTY4MQ==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r419775681", "bodyText": "Good point, lemme just remove the conditional in boundariesTerminated() as we are always calling that method when boundaries source is terminated which should happen only once.", "author": "NiteshKant", "createdAt": "2020-05-04T22:54:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODgxMTUzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODgyMTg4Nw==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r418821887", "bodyText": "This comment is somewhat confusing, consider clarifying...\nIIUC we could emit nextAccumulator now (e.g. wouldn't violate requestN) but need to do CAS(DRAINING_TMP_ACCUMULATOR, nextAccumulator) to make a \"real\" Accumulator available to accumulate thread? For example we could create another empty TmpAccumulator here to use for the CAS, append to it in the accumulate, and transfer back later ... however then any constraints on the \"real\" Accumulator which may trigger new boundaries will be missed.", "author": "Scottmitch", "createdAt": "2020-05-02T01:45:09Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherBuffer.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.ConcurrentSubscription.wrap;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.error;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n+\n+final class PublisherBuffer<T, B> extends AbstractAsynchronousPublisherOperator<T, B> {\n+    private final int bufferSizeHint;\n+    private final BufferStrategy<T, ?, B> bufferStrategy;\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final BufferStrategy<T, ?, B> bufferStrategy) {\n+        super(original, executor);\n+        bufferSizeHint = bufferStrategy.bufferSizeHint();\n+        if (bufferSizeHint <= 0) {\n+            throw new IllegalArgumentException(\"bufferSizeHint: \" + bufferSizeHint + \" (expected > 0)\");\n+        }\n+        this.bufferStrategy = bufferStrategy;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super B> subscriber) {\n+        return new BufferSubscriber<>(bufferStrategy.boundaries(), subscriber, bufferSizeHint);\n+    }\n+\n+    private static final class BufferSubscriber<T, B> implements Subscriber<T> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BufferSubscriber> pendingUpdater =\n+                newUpdater(BufferSubscriber.class, \"pending\");\n+\n+        private final State state;\n+        private final DelayedCancellable tCancellable;\n+\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+        private volatile long pending;\n+\n+        BufferSubscriber(final Publisher<? extends Accumulator<T, B>> boundaries,\n+                         final Subscriber<? super B> target,\n+                         final int bufferSizeHint) {\n+            state = new State(bufferSizeHint);\n+            tCancellable = new DelayedCancellable();\n+            toSource(boundaries).subscribe(new BoundariesSubscriber<>(state, target, tCancellable));\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription subscription) {\n+            this.subscription = wrap(subscription);\n+            tCancellable.delayedCancellable(this.subscription);\n+            requestMoreItems(this.subscription);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final long pending = pendingUpdater.decrementAndGet(this);\n+            state.accumulate(t);\n+            if (pending == 0) {\n+                assert subscription != null;\n+                requestMoreItems(subscription);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            state.enqueueTermination(error(t));\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            state.enqueueTermination(complete());\n+        }\n+\n+        private void requestMoreItems(final Subscription subscription) {\n+            pendingUpdater.accumulateAndGet(this, state.bufferSizeHint,\n+                    FlowControlUtils::addWithOverflowProtection);\n+            subscription.request(state.bufferSizeHint);\n+        }\n+    }\n+\n+    private static final class BoundariesSubscriber<T, B> extends DelayedCancellable\n+            implements Subscriber<Accumulator<T, B>> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BoundariesSubscriber> pendingUpdater =\n+                newUpdater(BoundariesSubscriber.class, \"pending\");\n+        private final State state;\n+        private final Subscriber<? super B> target;\n+        private final Cancellable tCancellable;\n+\n+        private volatile long pending;\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+\n+        BoundariesSubscriber(final State state, final Subscriber<? super B> target, final Cancellable tCancellable) {\n+            this.state = state;\n+            this.target = target;\n+            this.tCancellable = tCancellable;\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription bSubscription) {\n+            subscription = wrap(new Subscription() {\n+                @Override\n+                public void request(final long n) {\n+                    if (isRequestNValid(n)) {\n+                        pendingUpdater.accumulateAndGet(BoundariesSubscriber.this, n,\n+                                FlowControlUtils::addWithOverflowProtection);\n+                    }\n+                    bSubscription.request(n);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    try {\n+                        bSubscription.cancel();\n+                    } finally {\n+                        tCancellable.cancel();\n+                    }\n+                }\n+            });\n+            delayedCancellable(subscription);\n+            target.onSubscribe(subscription);\n+        }\n+\n+        @Override\n+        public void onNext(final Accumulator<T, B> accumulator) {\n+            if (accumulator == null) {\n+                return;\n+            }\n+            pendingUpdater.decrementAndGet(this);\n+            if (!state.nextAccumulator(accumulator, target)) {\n+                assert subscription != null;\n+                pendingUpdater.incrementAndGet(this);\n+                subscription.request(1);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            try {\n+                state.boundariesTerminated(t, target);\n+            } finally {\n+                tCancellable.cancel();\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            try {\n+                state.boundariesTerminated(new IllegalStateException(\"Boundaries source completed unexpectedly.\"),\n+                        target);\n+            } finally {\n+                tCancellable.cancel();\n+            }\n+        }\n+    }\n+\n+    private static final class State {\n+        private static final Object ADDING = new Object();\n+        private static final Object DRAINING_TMP_ACCUMULATOR = new Object();\n+        private static final Object TERMINATED = new Object();\n+        private static final AtomicReferenceFieldUpdater<State, Object> maybeAccumulatorUpdater =\n+                AtomicReferenceFieldUpdater.newUpdater(State.class, Object.class, \"maybeAccumulator\");\n+\n+        private final int bufferSizeHint;\n+        /**\n+         * Following values are assigned to this variable:\n+         * <ul>\n+         *     <li>Instance of {@link TmpAccumulator} if a real {@link Accumulator} can not be set.</li>\n+         *     <li>{@link #DRAINING_TMP_ACCUMULATOR} if a {@link TmpAccumulator} instance is currently being drained\n+         *     into an actual {@link Accumulator}.</li>\n+         *     <li>{@link #ADDING} if an item is being added to the currently active {@link Accumulator}</li>\n+         *     <li>{@link ItemsTerminated} if the items source terminated but the target is not yet terminated.</li>\n+         *     <li>{@link #TERMINATED} if the target subscriber has been terminated (or cancelled).</li>\n+         *     <li>{@link Accumulator} (not {@link TmpAccumulator} which is emitted by the boundaries source.</li>\n+         * </ul>\n+         */\n+        private volatile Object maybeAccumulator;\n+\n+        State(final int bufferSizeHint) {\n+            this.bufferSizeHint = bufferSizeHint;\n+            maybeAccumulator = new TmpAccumulator<>(bufferSizeHint);\n+        }\n+\n+        <T> void accumulate(@Nullable final T item) {\n+            for (;;) {\n+                final Object cMaybeAccumulator = maybeAccumulator;\n+                if (cMaybeAccumulator == TERMINATED || cMaybeAccumulator instanceof ItemsTerminated) {\n+                    return;\n+                }\n+                assert cMaybeAccumulator != ADDING;\n+                if (cMaybeAccumulator == DRAINING_TMP_ACCUMULATOR) {\n+                    TmpAccumulator<T> tmpAccumulator = new TmpAccumulator<>(bufferSizeHint);\n+                    tmpAccumulator.accumulate(item);\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, DRAINING_TMP_ACCUMULATOR, tmpAccumulator)) {\n+                        break;\n+                    }\n+                } else if (maybeAccumulatorUpdater.compareAndSet(this, cMaybeAccumulator, ADDING)) {\n+                    assert cMaybeAccumulator instanceof Accumulator;\n+                    @SuppressWarnings(\"unchecked\")\n+                    final Accumulator<T, ?> accumulator = (Accumulator<T, ?>) cMaybeAccumulator;\n+                    accumulator.accumulate(item);\n+\n+                    maybeAccumulatorUpdater.getAndAccumulate(this, accumulator,\n+                            (prev, next) -> prev == TERMINATED ? TERMINATED : next);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        <T, B> boolean nextAccumulator(final Accumulator<T, B> nextAccumulator, final Subscriber<? super B> target) {\n+            requireNonNull(nextAccumulator);\n+            for (;;) {\n+                final Object cMaybeAccumulator = maybeAccumulator;\n+                if (cMaybeAccumulator == TERMINATED) {\n+                    return true;\n+                }\n+                if (cMaybeAccumulator == ADDING) {\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, ADDING, nextAccumulator)) {\n+                        return false;\n+                    }\n+                } else if (cMaybeAccumulator instanceof ItemsTerminated) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    ItemsTerminated<T, B> itemsTerminated = (ItemsTerminated<T, B>) cMaybeAccumulator;\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, cMaybeAccumulator, TERMINATED)) {\n+                        itemsTerminated.terminate(nextAccumulator, target);\n+                        return true;\n+                    }\n+                } else if (cMaybeAccumulator instanceof TmpAccumulator) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    TmpAccumulator<T> tmpAccumulator = (TmpAccumulator<T>) cMaybeAccumulator;\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, cMaybeAccumulator, DRAINING_TMP_ACCUMULATOR)) {\n+                        tmpAccumulator.transferToActual(nextAccumulator);\n+                        // We can only emit one result per boundary closure. So, we move out of", "originalCommit": "c0c27efac7883d2436b1ca0b33875f63f64df6cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc3NDQwNA==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r419774404", "bodyText": "Lemme clarify the comment; the intent here is to emit one accumulator per call to onNext(Accumulator) and simplify the drain logic.", "author": "NiteshKant", "createdAt": "2020-05-04T22:50:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODgyMTg4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODgyODgyMQ==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r418828821", "bodyText": "We could reduce the public API surface area if we flatten BufferStrategies into individual operators. This is a consistent approach with other operators that we have, and won't conflict if we want to add other buffer operators outside the scope of what BufferStrategy  is today. IIUC this could reduce the public API surface area to Accumulator (+ the actual operators).", "author": "Scottmitch", "createdAt": "2020-05-02T02:03:09Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Publisher.java", "diffHunk": "@@ -1394,6 +1395,37 @@ public final Completable flatMapCompletableDelayError(Function<? super T, ? exte\n         return new MulticastPublisher<>(this, expectedSubscribers, maxQueueSize, executor);\n     }\n \n+    /**\n+     * Create a {@link Publisher} that buffers items from this {@link Publisher} and emit those buffers instead of the\n+     * individual items.\n+     * <p>\n+     * In sequential programming this is similar to the following:\n+     * <pre>{@code\n+     *     List accumulators = strategy.boundaries();\n+     *     List buffers = ...;\n+     *     BC currentAccumulator;\n+     *     for (T t : resultOfThisPublisher()) {\n+     *         // This is an approximation; accumulators are emitted asynchronously.\n+     *         BC nextAccumulator = accumulators.remove(0).get();\n+     *         buffers.add(currentAccumulator.finish());\n+     *         currentAccumulator = nextAccumulator;\n+     *         currentAccumulator.add(t);\n+     *     }\n+     *     return buffers;\n+     * }</pre>\n+     *\n+     * @param strategy A {@link BufferStrategy} to use for buffering items from this {@link Publisher}.\n+     * @param <BC> Type of the {@link Accumulator} to buffer items from this {@link Publisher}.\n+     * @param <B> Type of the buffer emitted from the returned {@link Publisher}.\n+     * @return a {@link Publisher} that buffers items from this {@link Publisher} and emit those buffers instead of the\n+     * individual items.\n+     *\n+     * @see <a href=\"http://reactivex.io/documentation/operators/buffer.html\">ReactiveX buffer operator.</a>\n+     */\n+    public final <BC extends Accumulator<T, B>, B> Publisher<B> buffer(final BufferStrategy<T, BC, B> strategy) {", "originalCommit": "c0c27efac7883d2436b1ca0b33875f63f64df6cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc2NjcxMg==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r419766712", "bodyText": "Although I agree that it will reduce the API surface area and be consistent with other operators, but I do not think it is a convenient user facing API when you consider variants of buffering and down the line windowing. There are few aspects to consider:\n\nvariance in buffering types; Set (for de-dup over a window), List, etc\noverlapping buffers (sliding windows)\nassociation with bufferSizeHint => buffer by count == n translates to bufferSizeHint = n\n\nIf we were to break down the API; it will roughly translate to:\nbuffer(Publisher<Accumulator> boundaries, int bufferSizeHint)\nCreating the Publisher is non-trivial for the cases we have today, so we would have to either provide some utilities or have different (but similar) operators for each. Apart from collect() there aren't other examples like this where we have so much variance over the same operator semantics. So, I think it is useful at this point to experiment how we can approach this better.\nIf you are hesitant about this now, we can hide the BufferStrategy operator variant all together and replace it with two specific operators; bufferBySize() and bufferBySizeOrTime().", "author": "NiteshKant", "createdAt": "2020-05-04T22:29:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODgyODgyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODgyOTgxOQ==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r418829819", "bodyText": "consider adding a similar caveat as above \"The emitted buffers may have more less or more items than the {@code count}.\"", "author": "Scottmitch", "createdAt": "2020-05-02T02:05:46Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/BufferStrategies.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.CompletableSource.Subscriber;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.Cancellable.IGNORE_CANCEL;\n+import static io.servicetalk.concurrent.api.ImmediateExecutor.IMMEDIATE_EXECUTOR;\n+import static io.servicetalk.concurrent.api.Publisher.defer;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * A static factory of {@link BufferStrategy} instances.\n+ */\n+public final class BufferStrategies {\n+    private BufferStrategies() {\n+        // no instances\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.", "originalCommit": "c0c27efac7883d2436b1ca0b33875f63f64df6cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODgzMDYwMw==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r418830603", "bodyText": "consider putting in try/catch and delivering handleExceptionFromOnSubscribe to avoid duplicate onSubscribe calls if caught at a higher level.", "author": "Scottmitch", "createdAt": "2020-05-02T02:07:45Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/BufferStrategies.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.CompletableSource.Subscriber;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.Cancellable.IGNORE_CANCEL;\n+import static io.servicetalk.concurrent.api.ImmediateExecutor.IMMEDIATE_EXECUTOR;\n+import static io.servicetalk.concurrent.api.Publisher.defer;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * A static factory of {@link BufferStrategy} instances.\n+ */\n+public final class BufferStrategies {\n+    private BufferStrategies() {\n+        // no instances\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param <T> Type of items added to the buffer.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T> BufferStrategy<T, Accumulator<T, Iterable<T>>, Iterable<T>> forCountOrTime(\n+            final int count, final Duration duration) {\n+        return forCountOrTime(count, duration, IMMEDIATE_EXECUTOR);\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param executor {@link Executor} to use for recording the passed {@code duration}.\n+     * @param <T> Type of items added to the buffer.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T> BufferStrategy<T, Accumulator<T, Iterable<T>>, Iterable<T>> forCountOrTime(\n+            final int count, final Duration duration, final Executor executor) {\n+        return forCountOrTime(count, duration, () -> new Accumulator<T, Iterable<T>>() {\n+            private final List<T> accumulate = new ArrayList<>();\n+\n+            @Override\n+            public void accumulate(final T t) {\n+                accumulate.add(t);\n+            }\n+\n+            @Override\n+            public Iterable<T> finish() {\n+                return accumulate;\n+            }\n+        }, executor);\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param accumulatorSupplier A {@link Supplier} of {@link Accumulator} every time a buffer boundary is closed.\n+     * Methods on the {@link Accumulator} returned from this {@link Supplier} may or may not be called.\n+     * @param <T> Type of items added to the buffer.\n+     * @param <BC> Type of {@link Accumulator} used to accumulate items in a buffer.\n+     * @param <B> Type of object created after an {@link Accumulator} is {@link Accumulator#finish() finished}.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T, BC extends Accumulator<T, B>, B> BufferStrategy<T, Accumulator<T, B>, B> forCountOrTime(\n+            final int count, final Duration duration, Supplier<BC> accumulatorSupplier) {\n+        return forCountOrTime(count, duration, accumulatorSupplier, IMMEDIATE_EXECUTOR);\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param accumulatorSupplier A {@link Supplier} of {@link Accumulator} every time a buffer boundary is closed.\n+     * Methods on the {@link Accumulator} returned from this {@link Supplier} may or may not be called.\n+     * @param executor {@link Executor} to use for recording the passed {@code duration}.\n+     * @param <T> Type of items added to the buffer.\n+     * @param <BC> Type of {@link Accumulator} used to accumulate items in a buffer.\n+     * @param <B> Type of object created after an {@link Accumulator} is {@link Accumulator#finish() finished}.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T, BC extends Accumulator<T, B>, B> BufferStrategy<T, Accumulator<T, B>, B> forCountOrTime(\n+            final int count, final Duration duration, Supplier<BC> accumulatorSupplier,\n+            final Executor executor) {\n+        return new BufferStrategy<T, Accumulator<T, B>, B>() {\n+            @Override\n+            public Publisher<Accumulator<T, B>> boundaries() {\n+                return defer(() -> {\n+                    State<T, B> state = new State<>();\n+                    return new Completable() {\n+                        @Override\n+                        protected void handleSubscribe(final Subscriber subscriber) {\n+                            // We ignore cancel and expect ambWith to ignore if we delay emit\n+                            subscriber.onSubscribe(IGNORE_CANCEL);", "originalCommit": "c0c27efac7883d2436b1ca0b33875f63f64df6cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODgzNjU1NQ==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r418836555", "bodyText": "I think we should consider handing off the \u201ctarget\u201d Subscriber from BoundariesSubscriber to BufferSubscriber for the following reasons:\n\nTermination from BufferSubscriber means we have to wait until BoundariesSubscriber delivers an item.\nConcurrency between BoundariesSubscriber and BufferSubscriber will result in skipping delivery of an item.\n\nThis may also lead to exceeding constraints of the Accumulator (e.g. max items). Strictly avoiding this maybe painful (e.g. busy/spin loop) and continuing to be liberal on the API definition will give us flexibility, but skipping an Accumulator exacerbates the problem (e.g. instead of overflow proportional to concurrency time, there would be at least an additional period of items).\n\n\n\nThe boundary delivery frequency is unknown may be very long and result in unexpected/unnecessary delays in signal emission. Additional delay may introduce additional latency when used in a networking capacity. A strictly \u201ccount based\u201d buffer operator would reveal the pathological case for termination (currently not offered in the API directly, but can be simulated with \u201cinfinite\u201d duration), and if signal delivery (and thread scheduling) overlaps this would reveal the pathological case for concurrency not delivery items.", "author": "Scottmitch", "createdAt": "2020-05-02T02:23:58Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherBuffer.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.ConcurrentSubscription.wrap;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.error;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n+\n+final class PublisherBuffer<T, B> extends AbstractAsynchronousPublisherOperator<T, B> {\n+    private final int bufferSizeHint;\n+    private final BufferStrategy<T, ?, B> bufferStrategy;\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final BufferStrategy<T, ?, B> bufferStrategy) {\n+        super(original, executor);\n+        bufferSizeHint = bufferStrategy.bufferSizeHint();\n+        if (bufferSizeHint <= 0) {\n+            throw new IllegalArgumentException(\"bufferSizeHint: \" + bufferSizeHint + \" (expected > 0)\");\n+        }\n+        this.bufferStrategy = bufferStrategy;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super B> subscriber) {\n+        return new BufferSubscriber<>(bufferStrategy.boundaries(), subscriber, bufferSizeHint);\n+    }\n+\n+    private static final class BufferSubscriber<T, B> implements Subscriber<T> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BufferSubscriber> pendingUpdater =\n+                newUpdater(BufferSubscriber.class, \"pending\");\n+\n+        private final State state;\n+        private final DelayedCancellable tCancellable;\n+\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+        private volatile long pending;\n+\n+        BufferSubscriber(final Publisher<? extends Accumulator<T, B>> boundaries,\n+                         final Subscriber<? super B> target,\n+                         final int bufferSizeHint) {\n+            state = new State(bufferSizeHint);\n+            tCancellable = new DelayedCancellable();\n+            toSource(boundaries).subscribe(new BoundariesSubscriber<>(state, target, tCancellable));\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription subscription) {\n+            this.subscription = wrap(subscription);\n+            tCancellable.delayedCancellable(this.subscription);\n+            requestMoreItems(this.subscription);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final long pending = pendingUpdater.decrementAndGet(this);\n+            state.accumulate(t);\n+            if (pending == 0) {\n+                assert subscription != null;\n+                requestMoreItems(subscription);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            state.enqueueTermination(error(t));\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            state.enqueueTermination(complete());\n+        }\n+\n+        private void requestMoreItems(final Subscription subscription) {\n+            pendingUpdater.accumulateAndGet(this, state.bufferSizeHint,\n+                    FlowControlUtils::addWithOverflowProtection);\n+            subscription.request(state.bufferSizeHint);\n+        }\n+    }\n+\n+    private static final class BoundariesSubscriber<T, B> extends DelayedCancellable\n+            implements Subscriber<Accumulator<T, B>> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BoundariesSubscriber> pendingUpdater =\n+                newUpdater(BoundariesSubscriber.class, \"pending\");\n+        private final State state;\n+        private final Subscriber<? super B> target;\n+        private final Cancellable tCancellable;\n+\n+        private volatile long pending;\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+\n+        BoundariesSubscriber(final State state, final Subscriber<? super B> target, final Cancellable tCancellable) {\n+            this.state = state;\n+            this.target = target;\n+            this.tCancellable = tCancellable;\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription bSubscription) {\n+            subscription = wrap(new Subscription() {\n+                @Override\n+                public void request(final long n) {\n+                    if (isRequestNValid(n)) {\n+                        pendingUpdater.accumulateAndGet(BoundariesSubscriber.this, n,\n+                                FlowControlUtils::addWithOverflowProtection);\n+                    }\n+                    bSubscription.request(n);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    try {\n+                        bSubscription.cancel();\n+                    } finally {\n+                        tCancellable.cancel();\n+                    }\n+                }\n+            });\n+            delayedCancellable(subscription);\n+            target.onSubscribe(subscription);\n+        }\n+\n+        @Override\n+        public void onNext(final Accumulator<T, B> accumulator) {\n+            if (accumulator == null) {\n+                return;\n+            }\n+            pendingUpdater.decrementAndGet(this);\n+            if (!state.nextAccumulator(accumulator, target)) {\n+                assert subscription != null;\n+                pendingUpdater.incrementAndGet(this);\n+                subscription.request(1);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            try {\n+                state.boundariesTerminated(t, target);\n+            } finally {\n+                tCancellable.cancel();\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            try {\n+                state.boundariesTerminated(new IllegalStateException(\"Boundaries source completed unexpectedly.\"),\n+                        target);\n+            } finally {\n+                tCancellable.cancel();\n+            }\n+        }\n+    }\n+\n+    private static final class State {\n+        private static final Object ADDING = new Object();\n+        private static final Object DRAINING_TMP_ACCUMULATOR = new Object();\n+        private static final Object TERMINATED = new Object();\n+        private static final AtomicReferenceFieldUpdater<State, Object> maybeAccumulatorUpdater =\n+                AtomicReferenceFieldUpdater.newUpdater(State.class, Object.class, \"maybeAccumulator\");\n+\n+        private final int bufferSizeHint;\n+        /**\n+         * Following values are assigned to this variable:\n+         * <ul>\n+         *     <li>Instance of {@link TmpAccumulator} if a real {@link Accumulator} can not be set.</li>\n+         *     <li>{@link #DRAINING_TMP_ACCUMULATOR} if a {@link TmpAccumulator} instance is currently being drained\n+         *     into an actual {@link Accumulator}.</li>\n+         *     <li>{@link #ADDING} if an item is being added to the currently active {@link Accumulator}</li>\n+         *     <li>{@link ItemsTerminated} if the items source terminated but the target is not yet terminated.</li>\n+         *     <li>{@link #TERMINATED} if the target subscriber has been terminated (or cancelled).</li>\n+         *     <li>{@link Accumulator} (not {@link TmpAccumulator} which is emitted by the boundaries source.</li>\n+         * </ul>\n+         */\n+        private volatile Object maybeAccumulator;\n+\n+        State(final int bufferSizeHint) {\n+            this.bufferSizeHint = bufferSizeHint;\n+            maybeAccumulator = new TmpAccumulator<>(bufferSizeHint);\n+        }\n+\n+        <T> void accumulate(@Nullable final T item) {\n+            for (;;) {\n+                final Object cMaybeAccumulator = maybeAccumulator;\n+                if (cMaybeAccumulator == TERMINATED || cMaybeAccumulator instanceof ItemsTerminated) {\n+                    return;\n+                }\n+                assert cMaybeAccumulator != ADDING;\n+                if (cMaybeAccumulator == DRAINING_TMP_ACCUMULATOR) {\n+                    TmpAccumulator<T> tmpAccumulator = new TmpAccumulator<>(bufferSizeHint);\n+                    tmpAccumulator.accumulate(item);\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, DRAINING_TMP_ACCUMULATOR, tmpAccumulator)) {\n+                        break;\n+                    }\n+                } else if (maybeAccumulatorUpdater.compareAndSet(this, cMaybeAccumulator, ADDING)) {\n+                    assert cMaybeAccumulator instanceof Accumulator;\n+                    @SuppressWarnings(\"unchecked\")\n+                    final Accumulator<T, ?> accumulator = (Accumulator<T, ?>) cMaybeAccumulator;\n+                    accumulator.accumulate(item);\n+\n+                    maybeAccumulatorUpdater.getAndAccumulate(this, accumulator,\n+                            (prev, next) -> prev == TERMINATED ? TERMINATED : next);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        <T, B> boolean nextAccumulator(final Accumulator<T, B> nextAccumulator, final Subscriber<? super B> target) {\n+            requireNonNull(nextAccumulator);\n+            for (;;) {\n+                final Object cMaybeAccumulator = maybeAccumulator;\n+                if (cMaybeAccumulator == TERMINATED) {\n+                    return true;\n+                }\n+                if (cMaybeAccumulator == ADDING) {\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, ADDING, nextAccumulator)) {", "originalCommit": "c0c27efac7883d2436b1ca0b33875f63f64df6cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAxNjU4OQ==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r421016589", "bodyText": "I have modified the code to do this hand-off now, thanks!", "author": "NiteshKant", "createdAt": "2020-05-06T18:50:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODgzNjU1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2MjUyNg==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r419562526", "bodyText": "does this need to be a GAS or can it be a volatile write? please add a comment if GAS is necessary.", "author": "Scottmitch", "createdAt": "2020-05-04T16:25:51Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/BufferStrategies.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.CompletableSource.Subscriber;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.Cancellable.IGNORE_CANCEL;\n+import static io.servicetalk.concurrent.api.ImmediateExecutor.IMMEDIATE_EXECUTOR;\n+import static io.servicetalk.concurrent.api.Publisher.defer;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * A static factory of {@link BufferStrategy} instances.\n+ */\n+public final class BufferStrategies {\n+    private BufferStrategies() {\n+        // no instances\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param <T> Type of items added to the buffer.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T> BufferStrategy<T, Accumulator<T, Iterable<T>>, Iterable<T>> forCountOrTime(\n+            final int count, final Duration duration) {\n+        return forCountOrTime(count, duration, IMMEDIATE_EXECUTOR);\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param executor {@link Executor} to use for recording the passed {@code duration}.\n+     * @param <T> Type of items added to the buffer.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T> BufferStrategy<T, Accumulator<T, Iterable<T>>, Iterable<T>> forCountOrTime(\n+            final int count, final Duration duration, final Executor executor) {\n+        return forCountOrTime(count, duration, () -> new Accumulator<T, Iterable<T>>() {\n+            private final List<T> accumulate = new ArrayList<>();\n+\n+            @Override\n+            public void accumulate(final T t) {\n+                accumulate.add(t);\n+            }\n+\n+            @Override\n+            public Iterable<T> finish() {\n+                return accumulate;\n+            }\n+        }, executor);\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param accumulatorSupplier A {@link Supplier} of {@link Accumulator} every time a buffer boundary is closed.\n+     * Methods on the {@link Accumulator} returned from this {@link Supplier} may or may not be called.\n+     * @param <T> Type of items added to the buffer.\n+     * @param <BC> Type of {@link Accumulator} used to accumulate items in a buffer.\n+     * @param <B> Type of object created after an {@link Accumulator} is {@link Accumulator#finish() finished}.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T, BC extends Accumulator<T, B>, B> BufferStrategy<T, Accumulator<T, B>, B> forCountOrTime(\n+            final int count, final Duration duration, Supplier<BC> accumulatorSupplier) {\n+        return forCountOrTime(count, duration, accumulatorSupplier, IMMEDIATE_EXECUTOR);\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param accumulatorSupplier A {@link Supplier} of {@link Accumulator} every time a buffer boundary is closed.\n+     * Methods on the {@link Accumulator} returned from this {@link Supplier} may or may not be called.\n+     * @param executor {@link Executor} to use for recording the passed {@code duration}.\n+     * @param <T> Type of items added to the buffer.\n+     * @param <BC> Type of {@link Accumulator} used to accumulate items in a buffer.\n+     * @param <B> Type of object created after an {@link Accumulator} is {@link Accumulator#finish() finished}.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T, BC extends Accumulator<T, B>, B> BufferStrategy<T, Accumulator<T, B>, B> forCountOrTime(\n+            final int count, final Duration duration, Supplier<BC> accumulatorSupplier,\n+            final Executor executor) {\n+        return new BufferStrategy<T, Accumulator<T, B>, B>() {\n+            @Override\n+            public Publisher<Accumulator<T, B>> boundaries() {\n+                return defer(() -> {\n+                    State<T, B> state = new State<>();\n+                    return new Completable() {\n+                        @Override\n+                        protected void handleSubscribe(final Subscriber subscriber) {\n+                            // We ignore cancel and expect ambWith to ignore if we delay emit\n+                            subscriber.onSubscribe(IGNORE_CANCEL);\n+                            state.countCompletableSubscribed(subscriber);\n+                        }\n+                    }\n+                    .ambWith(executor.timer(duration))\n+                    .toSingle()\n+                    .map(__ -> {\n+                        CountingAccumulator<T, B> accum =\n+                                new CountingAccumulator<>(state, accumulatorSupplier.get(), count);\n+                        state.beforeNewAccumulatorEmitted(accum);\n+                        return accum;\n+                    })\n+                    .repeat(__ -> true);\n+                });\n+            }\n+\n+            @Override\n+            public int bufferSizeHint() {\n+                return count;\n+            }\n+        };\n+    }\n+\n+    private static final class State<T, B> {\n+        private static final Object THRESHOLD_BREACHED_BEFORE_SUBSCRIBE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<State, Object> stateUpdater =\n+                newUpdater(State.class, Object.class, \"state\");\n+\n+        /**\n+         * The following values can be set to this state:\n+         * <ul>\n+         *     <li>{@code null} if neither an active accumulator is present nor a subscriber.</li>\n+         *     <li>An {@link Accumulator} which is expected to accumulating items for the current boundary.</li>\n+         *     <li>{@link AccumulatorAndSubscriber} instance when an active accumulator and {@link Subscriber} both are\n+         *     active.</li>\n+         *     <li>{@link Subscriber} if the size threshold {@link Completable} is subscribed and there is no\n+         *     accumulator present.</li>\n+         * </ul>\n+         */\n+        @Nullable\n+        private volatile Object state;\n+\n+        void countThresholdBreached(final Accumulator<T, B> breachedAccumulator) {\n+            for (;;) {\n+                final Object cState = state;\n+                if (cState == THRESHOLD_BREACHED_BEFORE_SUBSCRIBE || cState == null) {\n+                    // multiple breaches\n+                    return;\n+                }\n+                if (cState instanceof Accumulator && (cState != breachedAccumulator ||\n+                        stateUpdater.compareAndSet(this, cState, THRESHOLD_BREACHED_BEFORE_SUBSCRIBE))) {\n+                    // Either the threshold was breached for a stale accumulator or threshold was breached before\n+                    // before the accumulator could be set.\n+                    return;\n+                }\n+                if (cState instanceof Subscriber && stateUpdater.compareAndSet(this, cState, null)) {\n+                    Subscriber subscriber = (Subscriber) cState;\n+                    subscriber.onComplete();\n+                    return;\n+                }\n+                if (cState instanceof AccumulatorAndSubscriber) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    final AccumulatorAndSubscriber<T, B> accumulatorAndSubscriber =\n+                            (AccumulatorAndSubscriber<T, B>) cState;\n+                    if (accumulatorAndSubscriber.accumulator != breachedAccumulator ||\n+                            stateUpdater.compareAndSet(this, cState, null)) {\n+                        return;\n+                    }\n+                }\n+            }\n+        }\n+\n+        void countCompletableSubscribed(final Subscriber countSubscriber) {\n+            for (;;) {\n+                final Object cState = state;\n+                if (cState == THRESHOLD_BREACHED_BEFORE_SUBSCRIBE) {\n+                    if (stateUpdater.compareAndSet(this, cState, null)) {\n+                        countSubscriber.onComplete();\n+                        return;\n+                    }\n+                } else if (cState instanceof Accumulator) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    final Accumulator<T, B> accumulator = (Accumulator<T, B>) cState;\n+                    if (stateUpdater.compareAndSet(\n+                            this, cState, new AccumulatorAndSubscriber<>(accumulator, countSubscriber))) {\n+                        return;\n+                    }\n+                } else if (stateUpdater.compareAndSet(this, cState, countSubscriber)) {\n+                    return;\n+                }\n+            }\n+        }\n+\n+        void beforeNewAccumulatorEmitted(final Accumulator<T, B> newAccumulator) {\n+            // Apart from the first Accumulator, we always expect Accumulator followed by the Subscriber.\n+            // For the first time, we will never terminate based on size as the items are buffered outside the\n+            // accumulator till the first accumulator is emitted. So, we blindly overwrite whenever a new accumulator\n+            // is emitted.\n+            stateUpdater.getAndSet(this, newAccumulator);", "originalCommit": "c0c27efac7883d2436b1ca0b33875f63f64df6cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc5MDk1MQ==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r419790951", "bodyText": "Doesn't have to be a GAS", "author": "NiteshKant", "createdAt": "2020-05-04T23:41:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2MjUyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY3MTE1Ng==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r419671156", "bodyText": "IIUC the first emission depends only upon the timeout firing and does not take into account the \"counting\"? This may lead to unexpected buffering/delays of emission if the count is expected to be the primary driver. Have you considered starting with an unconditional emission first, and then going into the repeat (to avoid timer coupling/dependency for first emission)?", "author": "Scottmitch", "createdAt": "2020-05-04T19:22:36Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/BufferStrategies.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.CompletableSource.Subscriber;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.Cancellable.IGNORE_CANCEL;\n+import static io.servicetalk.concurrent.api.ImmediateExecutor.IMMEDIATE_EXECUTOR;\n+import static io.servicetalk.concurrent.api.Publisher.defer;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * A static factory of {@link BufferStrategy} instances.\n+ */\n+public final class BufferStrategies {\n+    private BufferStrategies() {\n+        // no instances\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param <T> Type of items added to the buffer.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T> BufferStrategy<T, Accumulator<T, Iterable<T>>, Iterable<T>> forCountOrTime(\n+            final int count, final Duration duration) {\n+        return forCountOrTime(count, duration, IMMEDIATE_EXECUTOR);\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param executor {@link Executor} to use for recording the passed {@code duration}.\n+     * @param <T> Type of items added to the buffer.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T> BufferStrategy<T, Accumulator<T, Iterable<T>>, Iterable<T>> forCountOrTime(\n+            final int count, final Duration duration, final Executor executor) {\n+        return forCountOrTime(count, duration, () -> new Accumulator<T, Iterable<T>>() {\n+            private final List<T> accumulate = new ArrayList<>();\n+\n+            @Override\n+            public void accumulate(final T t) {\n+                accumulate.add(t);\n+            }\n+\n+            @Override\n+            public Iterable<T> finish() {\n+                return accumulate;\n+            }\n+        }, executor);\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param accumulatorSupplier A {@link Supplier} of {@link Accumulator} every time a buffer boundary is closed.\n+     * Methods on the {@link Accumulator} returned from this {@link Supplier} may or may not be called.\n+     * @param <T> Type of items added to the buffer.\n+     * @param <BC> Type of {@link Accumulator} used to accumulate items in a buffer.\n+     * @param <B> Type of object created after an {@link Accumulator} is {@link Accumulator#finish() finished}.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T, BC extends Accumulator<T, B>, B> BufferStrategy<T, Accumulator<T, B>, B> forCountOrTime(\n+            final int count, final Duration duration, Supplier<BC> accumulatorSupplier) {\n+        return forCountOrTime(count, duration, accumulatorSupplier, IMMEDIATE_EXECUTOR);\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param accumulatorSupplier A {@link Supplier} of {@link Accumulator} every time a buffer boundary is closed.\n+     * Methods on the {@link Accumulator} returned from this {@link Supplier} may or may not be called.\n+     * @param executor {@link Executor} to use for recording the passed {@code duration}.\n+     * @param <T> Type of items added to the buffer.\n+     * @param <BC> Type of {@link Accumulator} used to accumulate items in a buffer.\n+     * @param <B> Type of object created after an {@link Accumulator} is {@link Accumulator#finish() finished}.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T, BC extends Accumulator<T, B>, B> BufferStrategy<T, Accumulator<T, B>, B> forCountOrTime(\n+            final int count, final Duration duration, Supplier<BC> accumulatorSupplier,\n+            final Executor executor) {\n+        return new BufferStrategy<T, Accumulator<T, B>, B>() {\n+            @Override\n+            public Publisher<Accumulator<T, B>> boundaries() {\n+                return defer(() -> {\n+                    State<T, B> state = new State<>();\n+                    return new Completable() {\n+                        @Override\n+                        protected void handleSubscribe(final Subscriber subscriber) {\n+                            // We ignore cancel and expect ambWith to ignore if we delay emit\n+                            subscriber.onSubscribe(IGNORE_CANCEL);\n+                            state.countCompletableSubscribed(subscriber);\n+                        }\n+                    }\n+                    .ambWith(executor.timer(duration))", "originalCommit": "c0c27efac7883d2436b1ca0b33875f63f64df6cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk5OTE0OQ==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r420999149", "bodyText": "The contract in BufferStrategy has changed now to always start with an accumulator and then use the count/time criterion to close boundaries.", "author": "NiteshKant", "createdAt": "2020-05-06T18:22:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY3MTE1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY3NzU0NQ==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r419677545", "bodyText": "should this be size == sizeThreshold or do we need to keep re-triggering the event when the size is exceeded (which may happen)?", "author": "Scottmitch", "createdAt": "2020-05-04T19:33:43Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/BufferStrategies.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.CompletableSource.Subscriber;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.Cancellable.IGNORE_CANCEL;\n+import static io.servicetalk.concurrent.api.ImmediateExecutor.IMMEDIATE_EXECUTOR;\n+import static io.servicetalk.concurrent.api.Publisher.defer;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * A static factory of {@link BufferStrategy} instances.\n+ */\n+public final class BufferStrategies {\n+    private BufferStrategies() {\n+        // no instances\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param <T> Type of items added to the buffer.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T> BufferStrategy<T, Accumulator<T, Iterable<T>>, Iterable<T>> forCountOrTime(\n+            final int count, final Duration duration) {\n+        return forCountOrTime(count, duration, IMMEDIATE_EXECUTOR);\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param executor {@link Executor} to use for recording the passed {@code duration}.\n+     * @param <T> Type of items added to the buffer.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T> BufferStrategy<T, Accumulator<T, Iterable<T>>, Iterable<T>> forCountOrTime(\n+            final int count, final Duration duration, final Executor executor) {\n+        return forCountOrTime(count, duration, () -> new Accumulator<T, Iterable<T>>() {\n+            private final List<T> accumulate = new ArrayList<>();\n+\n+            @Override\n+            public void accumulate(final T t) {\n+                accumulate.add(t);\n+            }\n+\n+            @Override\n+            public Iterable<T> finish() {\n+                return accumulate;\n+            }\n+        }, executor);\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param accumulatorSupplier A {@link Supplier} of {@link Accumulator} every time a buffer boundary is closed.\n+     * Methods on the {@link Accumulator} returned from this {@link Supplier} may or may not be called.\n+     * @param <T> Type of items added to the buffer.\n+     * @param <BC> Type of {@link Accumulator} used to accumulate items in a buffer.\n+     * @param <B> Type of object created after an {@link Accumulator} is {@link Accumulator#finish() finished}.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T, BC extends Accumulator<T, B>, B> BufferStrategy<T, Accumulator<T, B>, B> forCountOrTime(\n+            final int count, final Duration duration, Supplier<BC> accumulatorSupplier) {\n+        return forCountOrTime(count, duration, accumulatorSupplier, IMMEDIATE_EXECUTOR);\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param accumulatorSupplier A {@link Supplier} of {@link Accumulator} every time a buffer boundary is closed.\n+     * Methods on the {@link Accumulator} returned from this {@link Supplier} may or may not be called.\n+     * @param executor {@link Executor} to use for recording the passed {@code duration}.\n+     * @param <T> Type of items added to the buffer.\n+     * @param <BC> Type of {@link Accumulator} used to accumulate items in a buffer.\n+     * @param <B> Type of object created after an {@link Accumulator} is {@link Accumulator#finish() finished}.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T, BC extends Accumulator<T, B>, B> BufferStrategy<T, Accumulator<T, B>, B> forCountOrTime(\n+            final int count, final Duration duration, Supplier<BC> accumulatorSupplier,\n+            final Executor executor) {\n+        return new BufferStrategy<T, Accumulator<T, B>, B>() {\n+            @Override\n+            public Publisher<Accumulator<T, B>> boundaries() {\n+                return defer(() -> {\n+                    State<T, B> state = new State<>();\n+                    return new Completable() {\n+                        @Override\n+                        protected void handleSubscribe(final Subscriber subscriber) {\n+                            // We ignore cancel and expect ambWith to ignore if we delay emit\n+                            subscriber.onSubscribe(IGNORE_CANCEL);\n+                            state.countCompletableSubscribed(subscriber);\n+                        }\n+                    }\n+                    .ambWith(executor.timer(duration))\n+                    .toSingle()\n+                    .map(__ -> {\n+                        CountingAccumulator<T, B> accum =\n+                                new CountingAccumulator<>(state, accumulatorSupplier.get(), count);\n+                        state.beforeNewAccumulatorEmitted(accum);\n+                        return accum;\n+                    })\n+                    .repeat(__ -> true);\n+                });\n+            }\n+\n+            @Override\n+            public int bufferSizeHint() {\n+                return count;\n+            }\n+        };\n+    }\n+\n+    private static final class State<T, B> {\n+        private static final Object THRESHOLD_BREACHED_BEFORE_SUBSCRIBE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<State, Object> stateUpdater =\n+                newUpdater(State.class, Object.class, \"state\");\n+\n+        /**\n+         * The following values can be set to this state:\n+         * <ul>\n+         *     <li>{@code null} if neither an active accumulator is present nor a subscriber.</li>\n+         *     <li>An {@link Accumulator} which is expected to accumulating items for the current boundary.</li>\n+         *     <li>{@link AccumulatorAndSubscriber} instance when an active accumulator and {@link Subscriber} both are\n+         *     active.</li>\n+         *     <li>{@link Subscriber} if the size threshold {@link Completable} is subscribed and there is no\n+         *     accumulator present.</li>\n+         * </ul>\n+         */\n+        @Nullable\n+        private volatile Object state;\n+\n+        void countThresholdBreached(final Accumulator<T, B> breachedAccumulator) {\n+            for (;;) {\n+                final Object cState = state;\n+                if (cState == THRESHOLD_BREACHED_BEFORE_SUBSCRIBE || cState == null) {\n+                    // multiple breaches\n+                    return;\n+                }\n+                if (cState instanceof Accumulator && (cState != breachedAccumulator ||\n+                        stateUpdater.compareAndSet(this, cState, THRESHOLD_BREACHED_BEFORE_SUBSCRIBE))) {\n+                    // Either the threshold was breached for a stale accumulator or threshold was breached before\n+                    // before the accumulator could be set.\n+                    return;\n+                }\n+                if (cState instanceof Subscriber && stateUpdater.compareAndSet(this, cState, null)) {\n+                    Subscriber subscriber = (Subscriber) cState;\n+                    subscriber.onComplete();\n+                    return;\n+                }\n+                if (cState instanceof AccumulatorAndSubscriber) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    final AccumulatorAndSubscriber<T, B> accumulatorAndSubscriber =\n+                            (AccumulatorAndSubscriber<T, B>) cState;\n+                    if (accumulatorAndSubscriber.accumulator != breachedAccumulator ||\n+                            stateUpdater.compareAndSet(this, cState, null)) {\n+                        return;\n+                    }\n+                }\n+            }\n+        }\n+\n+        void countCompletableSubscribed(final Subscriber countSubscriber) {\n+            for (;;) {\n+                final Object cState = state;\n+                if (cState == THRESHOLD_BREACHED_BEFORE_SUBSCRIBE) {\n+                    if (stateUpdater.compareAndSet(this, cState, null)) {\n+                        countSubscriber.onComplete();\n+                        return;\n+                    }\n+                } else if (cState instanceof Accumulator) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    final Accumulator<T, B> accumulator = (Accumulator<T, B>) cState;\n+                    if (stateUpdater.compareAndSet(\n+                            this, cState, new AccumulatorAndSubscriber<>(accumulator, countSubscriber))) {\n+                        return;\n+                    }\n+                } else if (stateUpdater.compareAndSet(this, cState, countSubscriber)) {\n+                    return;\n+                }\n+            }\n+        }\n+\n+        void beforeNewAccumulatorEmitted(final Accumulator<T, B> newAccumulator) {\n+            // Apart from the first Accumulator, we always expect Accumulator followed by the Subscriber.\n+            // For the first time, we will never terminate based on size as the items are buffered outside the\n+            // accumulator till the first accumulator is emitted. So, we blindly overwrite whenever a new accumulator\n+            // is emitted.\n+            stateUpdater.getAndSet(this, newAccumulator);\n+        }\n+    }\n+\n+    private static final class CountingAccumulator<T, B> implements Accumulator<T, B> {\n+        private final State<T, B> state;\n+        private final Accumulator<T, B> delegate;\n+        private final int sizeThreshold;\n+        private int size;\n+\n+        CountingAccumulator(final State<T, B> state, final Accumulator<T, B> delegate, final int sizeThreshold) {\n+            this.state = state;\n+            this.delegate = delegate;\n+            this.sizeThreshold = sizeThreshold;\n+        }\n+\n+        @Override\n+        public void accumulate(@Nullable final T item) {\n+            size++;\n+            delegate.accumulate(item);\n+            if (size >= sizeThreshold) {", "originalCommit": "c0c27efac7883d2436b1ca0b33875f63f64df6cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY3ODg0Mg==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r419678842", "bodyText": "assert preconditions (e.g. count > 0, duration != null, ..)?", "author": "Scottmitch", "createdAt": "2020-05-04T19:35:56Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/BufferStrategies.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.CompletableSource.Subscriber;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.Cancellable.IGNORE_CANCEL;\n+import static io.servicetalk.concurrent.api.ImmediateExecutor.IMMEDIATE_EXECUTOR;\n+import static io.servicetalk.concurrent.api.Publisher.defer;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * A static factory of {@link BufferStrategy} instances.\n+ */\n+public final class BufferStrategies {\n+    private BufferStrategies() {\n+        // no instances\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param <T> Type of items added to the buffer.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T> BufferStrategy<T, Accumulator<T, Iterable<T>>, Iterable<T>> forCountOrTime(\n+            final int count, final Duration duration) {\n+        return forCountOrTime(count, duration, IMMEDIATE_EXECUTOR);\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param executor {@link Executor} to use for recording the passed {@code duration}.\n+     * @param <T> Type of items added to the buffer.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T> BufferStrategy<T, Accumulator<T, Iterable<T>>, Iterable<T>> forCountOrTime(\n+            final int count, final Duration duration, final Executor executor) {\n+        return forCountOrTime(count, duration, () -> new Accumulator<T, Iterable<T>>() {\n+            private final List<T> accumulate = new ArrayList<>();\n+\n+            @Override\n+            public void accumulate(final T t) {\n+                accumulate.add(t);\n+            }\n+\n+            @Override\n+            public Iterable<T> finish() {\n+                return accumulate;\n+            }\n+        }, executor);\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param accumulatorSupplier A {@link Supplier} of {@link Accumulator} every time a buffer boundary is closed.\n+     * Methods on the {@link Accumulator} returned from this {@link Supplier} may or may not be called.\n+     * @param <T> Type of items added to the buffer.\n+     * @param <BC> Type of {@link Accumulator} used to accumulate items in a buffer.\n+     * @param <B> Type of object created after an {@link Accumulator} is {@link Accumulator#finish() finished}.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T, BC extends Accumulator<T, B>, B> BufferStrategy<T, Accumulator<T, B>, B> forCountOrTime(\n+            final int count, final Duration duration, Supplier<BC> accumulatorSupplier) {\n+        return forCountOrTime(count, duration, accumulatorSupplier, IMMEDIATE_EXECUTOR);\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param accumulatorSupplier A {@link Supplier} of {@link Accumulator} every time a buffer boundary is closed.\n+     * Methods on the {@link Accumulator} returned from this {@link Supplier} may or may not be called.\n+     * @param executor {@link Executor} to use for recording the passed {@code duration}.\n+     * @param <T> Type of items added to the buffer.\n+     * @param <BC> Type of {@link Accumulator} used to accumulate items in a buffer.\n+     * @param <B> Type of object created after an {@link Accumulator} is {@link Accumulator#finish() finished}.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T, BC extends Accumulator<T, B>, B> BufferStrategy<T, Accumulator<T, B>, B> forCountOrTime(\n+            final int count, final Duration duration, Supplier<BC> accumulatorSupplier,\n+            final Executor executor) {\n+        return new BufferStrategy<T, Accumulator<T, B>, B>() {", "originalCommit": "c0c27efac7883d2436b1ca0b33875f63f64df6cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY4NzIxMg==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r419687212", "bodyText": "nit: we don't want to evaluate all the subsequent conditional statements if the clause after the instanceof check fails, consider breaking up the conditionals.\nif (cState instanceof Accumulator) {\n  if (cState != breachedAccumulator || CAS()) {\n    return;\n  }\n} else if (cState instanceof Subscriber) {\n  if (CAS) {\n    return;\n  }\n}", "author": "Scottmitch", "createdAt": "2020-05-04T19:50:35Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/BufferStrategies.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.CompletableSource.Subscriber;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.Cancellable.IGNORE_CANCEL;\n+import static io.servicetalk.concurrent.api.ImmediateExecutor.IMMEDIATE_EXECUTOR;\n+import static io.servicetalk.concurrent.api.Publisher.defer;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * A static factory of {@link BufferStrategy} instances.\n+ */\n+public final class BufferStrategies {\n+    private BufferStrategies() {\n+        // no instances\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param <T> Type of items added to the buffer.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T> BufferStrategy<T, Accumulator<T, Iterable<T>>, Iterable<T>> forCountOrTime(\n+            final int count, final Duration duration) {\n+        return forCountOrTime(count, duration, IMMEDIATE_EXECUTOR);\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param executor {@link Executor} to use for recording the passed {@code duration}.\n+     * @param <T> Type of items added to the buffer.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T> BufferStrategy<T, Accumulator<T, Iterable<T>>, Iterable<T>> forCountOrTime(\n+            final int count, final Duration duration, final Executor executor) {\n+        return forCountOrTime(count, duration, () -> new Accumulator<T, Iterable<T>>() {\n+            private final List<T> accumulate = new ArrayList<>();\n+\n+            @Override\n+            public void accumulate(final T t) {\n+                accumulate.add(t);\n+            }\n+\n+            @Override\n+            public Iterable<T> finish() {\n+                return accumulate;\n+            }\n+        }, executor);\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param accumulatorSupplier A {@link Supplier} of {@link Accumulator} every time a buffer boundary is closed.\n+     * Methods on the {@link Accumulator} returned from this {@link Supplier} may or may not be called.\n+     * @param <T> Type of items added to the buffer.\n+     * @param <BC> Type of {@link Accumulator} used to accumulate items in a buffer.\n+     * @param <B> Type of object created after an {@link Accumulator} is {@link Accumulator#finish() finished}.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T, BC extends Accumulator<T, B>, B> BufferStrategy<T, Accumulator<T, B>, B> forCountOrTime(\n+            final int count, final Duration duration, Supplier<BC> accumulatorSupplier) {\n+        return forCountOrTime(count, duration, accumulatorSupplier, IMMEDIATE_EXECUTOR);\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param accumulatorSupplier A {@link Supplier} of {@link Accumulator} every time a buffer boundary is closed.\n+     * Methods on the {@link Accumulator} returned from this {@link Supplier} may or may not be called.\n+     * @param executor {@link Executor} to use for recording the passed {@code duration}.\n+     * @param <T> Type of items added to the buffer.\n+     * @param <BC> Type of {@link Accumulator} used to accumulate items in a buffer.\n+     * @param <B> Type of object created after an {@link Accumulator} is {@link Accumulator#finish() finished}.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T, BC extends Accumulator<T, B>, B> BufferStrategy<T, Accumulator<T, B>, B> forCountOrTime(\n+            final int count, final Duration duration, Supplier<BC> accumulatorSupplier,\n+            final Executor executor) {\n+        return new BufferStrategy<T, Accumulator<T, B>, B>() {\n+            @Override\n+            public Publisher<Accumulator<T, B>> boundaries() {\n+                return defer(() -> {\n+                    State<T, B> state = new State<>();\n+                    return new Completable() {\n+                        @Override\n+                        protected void handleSubscribe(final Subscriber subscriber) {\n+                            // We ignore cancel and expect ambWith to ignore if we delay emit\n+                            subscriber.onSubscribe(IGNORE_CANCEL);\n+                            state.countCompletableSubscribed(subscriber);\n+                        }\n+                    }\n+                    .ambWith(executor.timer(duration))\n+                    .toSingle()\n+                    .map(__ -> {\n+                        CountingAccumulator<T, B> accum =\n+                                new CountingAccumulator<>(state, accumulatorSupplier.get(), count);\n+                        state.beforeNewAccumulatorEmitted(accum);\n+                        return accum;\n+                    })\n+                    .repeat(__ -> true);\n+                });\n+            }\n+\n+            @Override\n+            public int bufferSizeHint() {\n+                return count;\n+            }\n+        };\n+    }\n+\n+    private static final class State<T, B> {\n+        private static final Object THRESHOLD_BREACHED_BEFORE_SUBSCRIBE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<State, Object> stateUpdater =\n+                newUpdater(State.class, Object.class, \"state\");\n+\n+        /**\n+         * The following values can be set to this state:\n+         * <ul>\n+         *     <li>{@code null} if neither an active accumulator is present nor a subscriber.</li>\n+         *     <li>An {@link Accumulator} which is expected to accumulating items for the current boundary.</li>\n+         *     <li>{@link AccumulatorAndSubscriber} instance when an active accumulator and {@link Subscriber} both are\n+         *     active.</li>\n+         *     <li>{@link Subscriber} if the size threshold {@link Completable} is subscribed and there is no\n+         *     accumulator present.</li>\n+         * </ul>\n+         */\n+        @Nullable\n+        private volatile Object state;\n+\n+        void countThresholdBreached(final Accumulator<T, B> breachedAccumulator) {\n+            for (;;) {\n+                final Object cState = state;\n+                if (cState == THRESHOLD_BREACHED_BEFORE_SUBSCRIBE || cState == null) {\n+                    // multiple breaches\n+                    return;\n+                }\n+                if (cState instanceof Accumulator && (cState != breachedAccumulator ||", "originalCommit": "c0c27efac7883d2436b1ca0b33875f63f64df6cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY4ODE0MA==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r419688140", "bodyText": "was breached before before -> remove duplicate before", "author": "Scottmitch", "createdAt": "2020-05-04T19:52:20Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/BufferStrategies.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.CompletableSource.Subscriber;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.Cancellable.IGNORE_CANCEL;\n+import static io.servicetalk.concurrent.api.ImmediateExecutor.IMMEDIATE_EXECUTOR;\n+import static io.servicetalk.concurrent.api.Publisher.defer;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * A static factory of {@link BufferStrategy} instances.\n+ */\n+public final class BufferStrategies {\n+    private BufferStrategies() {\n+        // no instances\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param <T> Type of items added to the buffer.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T> BufferStrategy<T, Accumulator<T, Iterable<T>>, Iterable<T>> forCountOrTime(\n+            final int count, final Duration duration) {\n+        return forCountOrTime(count, duration, IMMEDIATE_EXECUTOR);\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param executor {@link Executor} to use for recording the passed {@code duration}.\n+     * @param <T> Type of items added to the buffer.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T> BufferStrategy<T, Accumulator<T, Iterable<T>>, Iterable<T>> forCountOrTime(\n+            final int count, final Duration duration, final Executor executor) {\n+        return forCountOrTime(count, duration, () -> new Accumulator<T, Iterable<T>>() {\n+            private final List<T> accumulate = new ArrayList<>();\n+\n+            @Override\n+            public void accumulate(final T t) {\n+                accumulate.add(t);\n+            }\n+\n+            @Override\n+            public Iterable<T> finish() {\n+                return accumulate;\n+            }\n+        }, executor);\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param accumulatorSupplier A {@link Supplier} of {@link Accumulator} every time a buffer boundary is closed.\n+     * Methods on the {@link Accumulator} returned from this {@link Supplier} may or may not be called.\n+     * @param <T> Type of items added to the buffer.\n+     * @param <BC> Type of {@link Accumulator} used to accumulate items in a buffer.\n+     * @param <B> Type of object created after an {@link Accumulator} is {@link Accumulator#finish() finished}.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T, BC extends Accumulator<T, B>, B> BufferStrategy<T, Accumulator<T, B>, B> forCountOrTime(\n+            final int count, final Duration duration, Supplier<BC> accumulatorSupplier) {\n+        return forCountOrTime(count, duration, accumulatorSupplier, IMMEDIATE_EXECUTOR);\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param accumulatorSupplier A {@link Supplier} of {@link Accumulator} every time a buffer boundary is closed.\n+     * Methods on the {@link Accumulator} returned from this {@link Supplier} may or may not be called.\n+     * @param executor {@link Executor} to use for recording the passed {@code duration}.\n+     * @param <T> Type of items added to the buffer.\n+     * @param <BC> Type of {@link Accumulator} used to accumulate items in a buffer.\n+     * @param <B> Type of object created after an {@link Accumulator} is {@link Accumulator#finish() finished}.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T, BC extends Accumulator<T, B>, B> BufferStrategy<T, Accumulator<T, B>, B> forCountOrTime(\n+            final int count, final Duration duration, Supplier<BC> accumulatorSupplier,\n+            final Executor executor) {\n+        return new BufferStrategy<T, Accumulator<T, B>, B>() {\n+            @Override\n+            public Publisher<Accumulator<T, B>> boundaries() {\n+                return defer(() -> {\n+                    State<T, B> state = new State<>();\n+                    return new Completable() {\n+                        @Override\n+                        protected void handleSubscribe(final Subscriber subscriber) {\n+                            // We ignore cancel and expect ambWith to ignore if we delay emit\n+                            subscriber.onSubscribe(IGNORE_CANCEL);\n+                            state.countCompletableSubscribed(subscriber);\n+                        }\n+                    }\n+                    .ambWith(executor.timer(duration))\n+                    .toSingle()\n+                    .map(__ -> {\n+                        CountingAccumulator<T, B> accum =\n+                                new CountingAccumulator<>(state, accumulatorSupplier.get(), count);\n+                        state.beforeNewAccumulatorEmitted(accum);\n+                        return accum;\n+                    })\n+                    .repeat(__ -> true);\n+                });\n+            }\n+\n+            @Override\n+            public int bufferSizeHint() {\n+                return count;\n+            }\n+        };\n+    }\n+\n+    private static final class State<T, B> {\n+        private static final Object THRESHOLD_BREACHED_BEFORE_SUBSCRIBE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<State, Object> stateUpdater =\n+                newUpdater(State.class, Object.class, \"state\");\n+\n+        /**\n+         * The following values can be set to this state:\n+         * <ul>\n+         *     <li>{@code null} if neither an active accumulator is present nor a subscriber.</li>\n+         *     <li>An {@link Accumulator} which is expected to accumulating items for the current boundary.</li>\n+         *     <li>{@link AccumulatorAndSubscriber} instance when an active accumulator and {@link Subscriber} both are\n+         *     active.</li>\n+         *     <li>{@link Subscriber} if the size threshold {@link Completable} is subscribed and there is no\n+         *     accumulator present.</li>\n+         * </ul>\n+         */\n+        @Nullable\n+        private volatile Object state;\n+\n+        void countThresholdBreached(final Accumulator<T, B> breachedAccumulator) {\n+            for (;;) {\n+                final Object cState = state;\n+                if (cState == THRESHOLD_BREACHED_BEFORE_SUBSCRIBE || cState == null) {\n+                    // multiple breaches\n+                    return;\n+                }\n+                if (cState instanceof Accumulator && (cState != breachedAccumulator ||\n+                        stateUpdater.compareAndSet(this, cState, THRESHOLD_BREACHED_BEFORE_SUBSCRIBE))) {\n+                    // Either the threshold was breached for a stale accumulator or threshold was breached before\n+                    // before the accumulator could be set.", "originalCommit": "c0c27efac7883d2436b1ca0b33875f63f64df6cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY5MTY1Mw==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r419691653", "bodyText": "IIUC the subscribes are guaranteed to never be offloaded and events will happen in sequence such that if the previously accumulator breached, the next subscribe will necessarily correlate to that accumulator? consider adding a comment to clarify.", "author": "Scottmitch", "createdAt": "2020-05-04T19:58:50Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/BufferStrategies.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.CompletableSource.Subscriber;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.Cancellable.IGNORE_CANCEL;\n+import static io.servicetalk.concurrent.api.ImmediateExecutor.IMMEDIATE_EXECUTOR;\n+import static io.servicetalk.concurrent.api.Publisher.defer;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * A static factory of {@link BufferStrategy} instances.\n+ */\n+public final class BufferStrategies {\n+    private BufferStrategies() {\n+        // no instances\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param <T> Type of items added to the buffer.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T> BufferStrategy<T, Accumulator<T, Iterable<T>>, Iterable<T>> forCountOrTime(\n+            final int count, final Duration duration) {\n+        return forCountOrTime(count, duration, IMMEDIATE_EXECUTOR);\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param executor {@link Executor} to use for recording the passed {@code duration}.\n+     * @param <T> Type of items added to the buffer.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T> BufferStrategy<T, Accumulator<T, Iterable<T>>, Iterable<T>> forCountOrTime(\n+            final int count, final Duration duration, final Executor executor) {\n+        return forCountOrTime(count, duration, () -> new Accumulator<T, Iterable<T>>() {\n+            private final List<T> accumulate = new ArrayList<>();\n+\n+            @Override\n+            public void accumulate(final T t) {\n+                accumulate.add(t);\n+            }\n+\n+            @Override\n+            public Iterable<T> finish() {\n+                return accumulate;\n+            }\n+        }, executor);\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param accumulatorSupplier A {@link Supplier} of {@link Accumulator} every time a buffer boundary is closed.\n+     * Methods on the {@link Accumulator} returned from this {@link Supplier} may or may not be called.\n+     * @param <T> Type of items added to the buffer.\n+     * @param <BC> Type of {@link Accumulator} used to accumulate items in a buffer.\n+     * @param <B> Type of object created after an {@link Accumulator} is {@link Accumulator#finish() finished}.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T, BC extends Accumulator<T, B>, B> BufferStrategy<T, Accumulator<T, B>, B> forCountOrTime(\n+            final int count, final Duration duration, Supplier<BC> accumulatorSupplier) {\n+        return forCountOrTime(count, duration, accumulatorSupplier, IMMEDIATE_EXECUTOR);\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param accumulatorSupplier A {@link Supplier} of {@link Accumulator} every time a buffer boundary is closed.\n+     * Methods on the {@link Accumulator} returned from this {@link Supplier} may or may not be called.\n+     * @param executor {@link Executor} to use for recording the passed {@code duration}.\n+     * @param <T> Type of items added to the buffer.\n+     * @param <BC> Type of {@link Accumulator} used to accumulate items in a buffer.\n+     * @param <B> Type of object created after an {@link Accumulator} is {@link Accumulator#finish() finished}.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T, BC extends Accumulator<T, B>, B> BufferStrategy<T, Accumulator<T, B>, B> forCountOrTime(\n+            final int count, final Duration duration, Supplier<BC> accumulatorSupplier,\n+            final Executor executor) {\n+        return new BufferStrategy<T, Accumulator<T, B>, B>() {\n+            @Override\n+            public Publisher<Accumulator<T, B>> boundaries() {\n+                return defer(() -> {\n+                    State<T, B> state = new State<>();\n+                    return new Completable() {\n+                        @Override\n+                        protected void handleSubscribe(final Subscriber subscriber) {\n+                            // We ignore cancel and expect ambWith to ignore if we delay emit\n+                            subscriber.onSubscribe(IGNORE_CANCEL);\n+                            state.countCompletableSubscribed(subscriber);\n+                        }\n+                    }\n+                    .ambWith(executor.timer(duration))\n+                    .toSingle()\n+                    .map(__ -> {\n+                        CountingAccumulator<T, B> accum =\n+                                new CountingAccumulator<>(state, accumulatorSupplier.get(), count);\n+                        state.beforeNewAccumulatorEmitted(accum);\n+                        return accum;\n+                    })\n+                    .repeat(__ -> true);\n+                });\n+            }\n+\n+            @Override\n+            public int bufferSizeHint() {\n+                return count;\n+            }\n+        };\n+    }\n+\n+    private static final class State<T, B> {\n+        private static final Object THRESHOLD_BREACHED_BEFORE_SUBSCRIBE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<State, Object> stateUpdater =\n+                newUpdater(State.class, Object.class, \"state\");\n+\n+        /**\n+         * The following values can be set to this state:\n+         * <ul>\n+         *     <li>{@code null} if neither an active accumulator is present nor a subscriber.</li>\n+         *     <li>An {@link Accumulator} which is expected to accumulating items for the current boundary.</li>\n+         *     <li>{@link AccumulatorAndSubscriber} instance when an active accumulator and {@link Subscriber} both are\n+         *     active.</li>\n+         *     <li>{@link Subscriber} if the size threshold {@link Completable} is subscribed and there is no\n+         *     accumulator present.</li>\n+         * </ul>\n+         */\n+        @Nullable\n+        private volatile Object state;\n+\n+        void countThresholdBreached(final Accumulator<T, B> breachedAccumulator) {\n+            for (;;) {\n+                final Object cState = state;\n+                if (cState == THRESHOLD_BREACHED_BEFORE_SUBSCRIBE || cState == null) {\n+                    // multiple breaches\n+                    return;\n+                }\n+                if (cState instanceof Accumulator && (cState != breachedAccumulator ||\n+                        stateUpdater.compareAndSet(this, cState, THRESHOLD_BREACHED_BEFORE_SUBSCRIBE))) {\n+                    // Either the threshold was breached for a stale accumulator or threshold was breached before\n+                    // before the accumulator could be set.\n+                    return;\n+                }\n+                if (cState instanceof Subscriber && stateUpdater.compareAndSet(this, cState, null)) {\n+                    Subscriber subscriber = (Subscriber) cState;\n+                    subscriber.onComplete();\n+                    return;\n+                }\n+                if (cState instanceof AccumulatorAndSubscriber) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    final AccumulatorAndSubscriber<T, B> accumulatorAndSubscriber =\n+                            (AccumulatorAndSubscriber<T, B>) cState;\n+                    if (accumulatorAndSubscriber.accumulator != breachedAccumulator ||\n+                            stateUpdater.compareAndSet(this, cState, null)) {\n+                        return;\n+                    }\n+                }\n+            }\n+        }\n+\n+        void countCompletableSubscribed(final Subscriber countSubscriber) {\n+            for (;;) {\n+                final Object cState = state;\n+                if (cState == THRESHOLD_BREACHED_BEFORE_SUBSCRIBE) {", "originalCommit": "c0c27efac7883d2436b1ca0b33875f63f64df6cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "01ed2b2f74f93c153da5d802c2d5b2b6f569336c", "url": "https://github.com/apple/servicetalk/commit/01ed2b2f74f93c153da5d802c2d5b2b6f569336c", "message": "Change `BufferStrategy#boundaries()` contract to always start with the first boundary.\nNow `buffer()` emits from both items and boundaries source.", "committedDate": "2020-05-06T19:01:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE4NDgxNQ==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r422184815", "bodyText": "State is already given bufferSizeHint, and also interacts with one of the subscribers. consider just putting pendingUpdater inside state and passing the subscription into accumulator to consolidate duplicate state.", "author": "Scottmitch", "createdAt": "2020-05-08T14:45:10Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherBuffer.java", "diffHunk": "@@ -0,0 +1,373 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.ConcurrentSubscription.wrap;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.deliverErrorFromSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.error;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n+\n+final class PublisherBuffer<T, B> extends AbstractAsynchronousPublisherOperator<T, B> {\n+    private final BufferStrategy<T, ?, B> bufferStrategy;\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final BufferStrategy<T, ?, B> bufferStrategy) {\n+        super(original, executor);\n+        this.bufferStrategy = requireNonNull(bufferStrategy);\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super B> subscriber) {\n+        final int bufferSizeHint = bufferStrategy.bufferSizeHint();\n+        if (bufferSizeHint <= 0) {\n+            deliverErrorFromSource(subscriber,\n+                    new IllegalArgumentException(\"bufferSizeHint: \" + bufferSizeHint + \" (expected > 0)\"));\n+        }\n+        return new ItemsSubscriber<>(bufferStrategy.boundaries(), subscriber, bufferSizeHint);\n+    }\n+\n+    private static final class ItemsSubscriber<T, B> implements Subscriber<T> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<ItemsSubscriber> pendingUpdater =\n+                newUpdater(ItemsSubscriber.class, \"pending\");\n+\n+        private final Subscriber<? super B> target;\n+        private final State state;\n+        private final DelayedSubscription tSubscription;\n+        private final int bufferSizeHint;\n+        private final DelayedCancellable bCancellable;\n+\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+        private volatile long pending;\n+\n+        ItemsSubscriber(final Publisher<? extends Accumulator<T, B>> boundaries,\n+                        final Subscriber<? super B> target, final int bufferSizeHint) {\n+            this.target = target;\n+            state = new State(bufferSizeHint);\n+            tSubscription = new DelayedSubscription();\n+            this.bufferSizeHint = bufferSizeHint;\n+            // Request-n is delayed till we receive the first boundary but we will request bufferSizeHint.\n+            // This is done here to localize state management (pending count) in this subscriber but still drive the", "originalCommit": "01ed2b2f74f93c153da5d802c2d5b2b6f569336c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwMDI5NA==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r422400294", "bodyText": "Actually after your other comment, I realize we do not need an atomic count here.", "author": "NiteshKant", "createdAt": "2020-05-08T22:15:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE4NDgxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE4Nzc3NQ==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r422187775", "bodyText": "it doesn't look like pendingUpdater or pending is used to change control flow, can you clarify why we still need this?", "author": "Scottmitch", "createdAt": "2020-05-08T14:50:15Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherBuffer.java", "diffHunk": "@@ -0,0 +1,373 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.ConcurrentSubscription.wrap;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.deliverErrorFromSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.error;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n+\n+final class PublisherBuffer<T, B> extends AbstractAsynchronousPublisherOperator<T, B> {\n+    private final BufferStrategy<T, ?, B> bufferStrategy;\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final BufferStrategy<T, ?, B> bufferStrategy) {\n+        super(original, executor);\n+        this.bufferStrategy = requireNonNull(bufferStrategy);\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super B> subscriber) {\n+        final int bufferSizeHint = bufferStrategy.bufferSizeHint();\n+        if (bufferSizeHint <= 0) {\n+            deliverErrorFromSource(subscriber,\n+                    new IllegalArgumentException(\"bufferSizeHint: \" + bufferSizeHint + \" (expected > 0)\"));\n+        }\n+        return new ItemsSubscriber<>(bufferStrategy.boundaries(), subscriber, bufferSizeHint);\n+    }\n+\n+    private static final class ItemsSubscriber<T, B> implements Subscriber<T> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<ItemsSubscriber> pendingUpdater =\n+                newUpdater(ItemsSubscriber.class, \"pending\");\n+\n+        private final Subscriber<? super B> target;\n+        private final State state;\n+        private final DelayedSubscription tSubscription;\n+        private final int bufferSizeHint;\n+        private final DelayedCancellable bCancellable;\n+\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+        private volatile long pending;\n+\n+        ItemsSubscriber(final Publisher<? extends Accumulator<T, B>> boundaries,\n+                        final Subscriber<? super B> target, final int bufferSizeHint) {\n+            this.target = target;\n+            state = new State(bufferSizeHint);\n+            tSubscription = new DelayedSubscription();\n+            this.bufferSizeHint = bufferSizeHint;\n+            // Request-n is delayed till we receive the first boundary but we will request bufferSizeHint.\n+            // This is done here to localize state management (pending count) in this subscriber but still drive the\n+            // first request-n from inside State.\n+            pending = bufferSizeHint;\n+            final BoundariesSubscriber<T, B> bSubscriber = new BoundariesSubscriber<>(state, target, tSubscription);\n+            bCancellable = bSubscriber;\n+            toSource(boundaries).subscribe(bSubscriber);\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription subscription) {\n+            this.subscription = wrap(subscription);\n+            tSubscription.delayedSubscription(this.subscription);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final long pending = pendingUpdater.decrementAndGet(this);\n+            state.accumulate(t, target);\n+            if (pending == 0) {\n+                assert subscription != null;\n+                requestMoreItems(subscription);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            state.itemsTerminated(error(t), target, bCancellable);\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            state.itemsTerminated(complete(), target, bCancellable);\n+        }\n+\n+        private void requestMoreItems(final Subscription subscription) {\n+            pendingUpdater.accumulateAndGet(this, bufferSizeHint, FlowControlUtils::addWithOverflowProtection);\n+            subscription.request(bufferSizeHint);\n+        }\n+    }\n+\n+    private static final class BoundariesSubscriber<T, B> extends DelayedCancellable\n+            implements Subscriber<Accumulator<T, B>> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BoundariesSubscriber> pendingUpdater =\n+                newUpdater(BoundariesSubscriber.class, \"pending\");\n+        private final State state;\n+        private final Subscriber<? super B> target;\n+        private final Subscription tSubscription;\n+\n+        private volatile long pending;\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+\n+        BoundariesSubscriber(final State state, final Subscriber<? super B> target, final Subscription tSubscription) {\n+            this.state = state;\n+            this.target = target;\n+            this.tSubscription = tSubscription;\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription bSubscription) {\n+            subscription = wrap(new Subscription() {\n+                @Override\n+                public void request(final long n) {\n+                    if (isRequestNValid(n)) {\n+                        pendingUpdater.accumulateAndGet(BoundariesSubscriber.this, n,", "originalCommit": "01ed2b2f74f93c153da5d802c2d5b2b6f569336c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwMTg3NQ==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r422401875", "bodyText": "LOL .. good call, actually we do not need this \ud83d\ude04", "author": "NiteshKant", "createdAt": "2020-05-08T22:20:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE4Nzc3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE5MDY0Mw==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r422190643", "bodyText": "subscription is already passed into nextAccumulator, can this logic be encapsulated in that method instead of splitting interaction on the subscription inside/outside the scope of the method?", "author": "Scottmitch", "createdAt": "2020-05-08T14:55:02Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherBuffer.java", "diffHunk": "@@ -0,0 +1,373 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.ConcurrentSubscription.wrap;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.deliverErrorFromSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.error;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n+\n+final class PublisherBuffer<T, B> extends AbstractAsynchronousPublisherOperator<T, B> {\n+    private final BufferStrategy<T, ?, B> bufferStrategy;\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final BufferStrategy<T, ?, B> bufferStrategy) {\n+        super(original, executor);\n+        this.bufferStrategy = requireNonNull(bufferStrategy);\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super B> subscriber) {\n+        final int bufferSizeHint = bufferStrategy.bufferSizeHint();\n+        if (bufferSizeHint <= 0) {\n+            deliverErrorFromSource(subscriber,\n+                    new IllegalArgumentException(\"bufferSizeHint: \" + bufferSizeHint + \" (expected > 0)\"));\n+        }\n+        return new ItemsSubscriber<>(bufferStrategy.boundaries(), subscriber, bufferSizeHint);\n+    }\n+\n+    private static final class ItemsSubscriber<T, B> implements Subscriber<T> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<ItemsSubscriber> pendingUpdater =\n+                newUpdater(ItemsSubscriber.class, \"pending\");\n+\n+        private final Subscriber<? super B> target;\n+        private final State state;\n+        private final DelayedSubscription tSubscription;\n+        private final int bufferSizeHint;\n+        private final DelayedCancellable bCancellable;\n+\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+        private volatile long pending;\n+\n+        ItemsSubscriber(final Publisher<? extends Accumulator<T, B>> boundaries,\n+                        final Subscriber<? super B> target, final int bufferSizeHint) {\n+            this.target = target;\n+            state = new State(bufferSizeHint);\n+            tSubscription = new DelayedSubscription();\n+            this.bufferSizeHint = bufferSizeHint;\n+            // Request-n is delayed till we receive the first boundary but we will request bufferSizeHint.\n+            // This is done here to localize state management (pending count) in this subscriber but still drive the\n+            // first request-n from inside State.\n+            pending = bufferSizeHint;\n+            final BoundariesSubscriber<T, B> bSubscriber = new BoundariesSubscriber<>(state, target, tSubscription);\n+            bCancellable = bSubscriber;\n+            toSource(boundaries).subscribe(bSubscriber);\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription subscription) {\n+            this.subscription = wrap(subscription);\n+            tSubscription.delayedSubscription(this.subscription);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final long pending = pendingUpdater.decrementAndGet(this);\n+            state.accumulate(t, target);\n+            if (pending == 0) {\n+                assert subscription != null;\n+                requestMoreItems(subscription);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            state.itemsTerminated(error(t), target, bCancellable);\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            state.itemsTerminated(complete(), target, bCancellable);\n+        }\n+\n+        private void requestMoreItems(final Subscription subscription) {\n+            pendingUpdater.accumulateAndGet(this, bufferSizeHint, FlowControlUtils::addWithOverflowProtection);\n+            subscription.request(bufferSizeHint);\n+        }\n+    }\n+\n+    private static final class BoundariesSubscriber<T, B> extends DelayedCancellable\n+            implements Subscriber<Accumulator<T, B>> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BoundariesSubscriber> pendingUpdater =\n+                newUpdater(BoundariesSubscriber.class, \"pending\");\n+        private final State state;\n+        private final Subscriber<? super B> target;\n+        private final Subscription tSubscription;\n+\n+        private volatile long pending;\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+\n+        BoundariesSubscriber(final State state, final Subscriber<? super B> target, final Subscription tSubscription) {\n+            this.state = state;\n+            this.target = target;\n+            this.tSubscription = tSubscription;\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription bSubscription) {\n+            subscription = wrap(new Subscription() {\n+                @Override\n+                public void request(final long n) {\n+                    if (isRequestNValid(n)) {\n+                        pendingUpdater.accumulateAndGet(BoundariesSubscriber.this, n,\n+                                FlowControlUtils::addWithOverflowProtection);\n+                    }\n+                    bSubscription.request(n);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    try {\n+                        bSubscription.cancel();\n+                    } finally {\n+                        tSubscription.cancel();\n+                    }\n+                }\n+            });\n+            delayedCancellable(subscription);\n+            target.onSubscribe(subscription);\n+        }\n+\n+        @Override\n+        public void onNext(@Nonnull final Accumulator<T, B> accumulator) {\n+            requireNonNull(accumulator);\n+            pendingUpdater.decrementAndGet(this);\n+            assert subscription != null;\n+            if (!state.nextAccumulator(accumulator, target, subscription, tSubscription)) {\n+                pendingUpdater.incrementAndGet(this);\n+                subscription.request(1);", "originalCommit": "01ed2b2f74f93c153da5d802c2d5b2b6f569336c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE5Mjk3OA==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r422192978", "bodyText": "this is also done outside the scope of this method in onNext ... consider just keeping 1 of these.", "author": "Scottmitch", "createdAt": "2020-05-08T14:58:51Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherBuffer.java", "diffHunk": "@@ -0,0 +1,373 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.ConcurrentSubscription.wrap;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.deliverErrorFromSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.error;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n+\n+final class PublisherBuffer<T, B> extends AbstractAsynchronousPublisherOperator<T, B> {\n+    private final BufferStrategy<T, ?, B> bufferStrategy;\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final BufferStrategy<T, ?, B> bufferStrategy) {\n+        super(original, executor);\n+        this.bufferStrategy = requireNonNull(bufferStrategy);\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super B> subscriber) {\n+        final int bufferSizeHint = bufferStrategy.bufferSizeHint();\n+        if (bufferSizeHint <= 0) {\n+            deliverErrorFromSource(subscriber,\n+                    new IllegalArgumentException(\"bufferSizeHint: \" + bufferSizeHint + \" (expected > 0)\"));\n+        }\n+        return new ItemsSubscriber<>(bufferStrategy.boundaries(), subscriber, bufferSizeHint);\n+    }\n+\n+    private static final class ItemsSubscriber<T, B> implements Subscriber<T> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<ItemsSubscriber> pendingUpdater =\n+                newUpdater(ItemsSubscriber.class, \"pending\");\n+\n+        private final Subscriber<? super B> target;\n+        private final State state;\n+        private final DelayedSubscription tSubscription;\n+        private final int bufferSizeHint;\n+        private final DelayedCancellable bCancellable;\n+\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+        private volatile long pending;\n+\n+        ItemsSubscriber(final Publisher<? extends Accumulator<T, B>> boundaries,\n+                        final Subscriber<? super B> target, final int bufferSizeHint) {\n+            this.target = target;\n+            state = new State(bufferSizeHint);\n+            tSubscription = new DelayedSubscription();\n+            this.bufferSizeHint = bufferSizeHint;\n+            // Request-n is delayed till we receive the first boundary but we will request bufferSizeHint.\n+            // This is done here to localize state management (pending count) in this subscriber but still drive the\n+            // first request-n from inside State.\n+            pending = bufferSizeHint;\n+            final BoundariesSubscriber<T, B> bSubscriber = new BoundariesSubscriber<>(state, target, tSubscription);\n+            bCancellable = bSubscriber;\n+            toSource(boundaries).subscribe(bSubscriber);\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription subscription) {\n+            this.subscription = wrap(subscription);\n+            tSubscription.delayedSubscription(this.subscription);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final long pending = pendingUpdater.decrementAndGet(this);\n+            state.accumulate(t, target);\n+            if (pending == 0) {\n+                assert subscription != null;\n+                requestMoreItems(subscription);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            state.itemsTerminated(error(t), target, bCancellable);\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            state.itemsTerminated(complete(), target, bCancellable);\n+        }\n+\n+        private void requestMoreItems(final Subscription subscription) {\n+            pendingUpdater.accumulateAndGet(this, bufferSizeHint, FlowControlUtils::addWithOverflowProtection);\n+            subscription.request(bufferSizeHint);\n+        }\n+    }\n+\n+    private static final class BoundariesSubscriber<T, B> extends DelayedCancellable\n+            implements Subscriber<Accumulator<T, B>> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BoundariesSubscriber> pendingUpdater =\n+                newUpdater(BoundariesSubscriber.class, \"pending\");\n+        private final State state;\n+        private final Subscriber<? super B> target;\n+        private final Subscription tSubscription;\n+\n+        private volatile long pending;\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+\n+        BoundariesSubscriber(final State state, final Subscriber<? super B> target, final Subscription tSubscription) {\n+            this.state = state;\n+            this.target = target;\n+            this.tSubscription = tSubscription;\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription bSubscription) {\n+            subscription = wrap(new Subscription() {\n+                @Override\n+                public void request(final long n) {\n+                    if (isRequestNValid(n)) {\n+                        pendingUpdater.accumulateAndGet(BoundariesSubscriber.this, n,\n+                                FlowControlUtils::addWithOverflowProtection);\n+                    }\n+                    bSubscription.request(n);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    try {\n+                        bSubscription.cancel();\n+                    } finally {\n+                        tSubscription.cancel();\n+                    }\n+                }\n+            });\n+            delayedCancellable(subscription);\n+            target.onSubscribe(subscription);\n+        }\n+\n+        @Override\n+        public void onNext(@Nonnull final Accumulator<T, B> accumulator) {\n+            requireNonNull(accumulator);\n+            pendingUpdater.decrementAndGet(this);\n+            assert subscription != null;\n+            if (!state.nextAccumulator(accumulator, target, subscription, tSubscription)) {\n+                pendingUpdater.incrementAndGet(this);\n+                subscription.request(1);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            try {\n+                state.boundariesTerminated(t, target);\n+            } finally {\n+                tSubscription.cancel();\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            try {\n+                state.boundariesTerminated(new IllegalStateException(\"Boundaries source completed unexpectedly.\"),\n+                        target);\n+            } finally {\n+                tSubscription.cancel();\n+            }\n+        }\n+    }\n+\n+    private static final class State {\n+        private static final Object ADDING = new Object();\n+        private static final Object TERMINATED = new Object();\n+        private static final AtomicReferenceFieldUpdater<State, Object> maybeAccumulatorUpdater =\n+                AtomicReferenceFieldUpdater.newUpdater(State.class, Object.class, \"maybeAccumulator\");\n+\n+        private final int firstItemsRequestN;\n+        /**\n+         * Following values are assigned to this variable:\n+         * <ul>\n+         *     <li>{@code null} till the first accumulator arrives.</li>\n+         *     <li>{@link #ADDING} if an item is being added to the currently active {@link Accumulator}</li>\n+         *     <li>{@link ItemsTerminated} if the items source terminated but the target is not yet terminated.</li>\n+         *     <li>{@link #TERMINATED} if the target subscriber has been terminated (or cancelled).</li>\n+         *     <li>{@link Accumulator} which is emitted by the boundaries source.</li>\n+         * </ul>\n+         */\n+        @Nullable\n+        private volatile Object maybeAccumulator;\n+\n+        State(final int firstItemsRequestN) {\n+            this.firstItemsRequestN = firstItemsRequestN;\n+        }\n+\n+        <T, B> void accumulate(@Nullable final T item, final Subscriber<? super B> target) {\n+            Accumulator<T, B> missedAccumulator = null;\n+            for (;;) {\n+                final Object cMaybeAccumulator = maybeAccumulator;\n+                assert cMaybeAccumulator != null;\n+\n+                // This method is called when a new item is received.\n+                // The subscription for items source is local to this operator and could never be interacted from an\n+                // external entity. This means we neither re-enter this method nor the items source can terminate\n+                // when we are inside this method (onNext and onError/onComplete can not be concurrent).\n+                if (cMaybeAccumulator == TERMINATED || cMaybeAccumulator instanceof ItemsTerminated) {\n+                    return;\n+                }\n+                assert cMaybeAccumulator != ADDING;\n+                // If we are ADDING and maybeAccumulatorUpdater has changed then either it should have terminated or\n+                // a new accumulator has been received. If a new accumulator is received, we could have never added to\n+                // that accumulator (as we were adding to an old accumulator), so we discard that accumulator.\n+                if (maybeAccumulatorUpdater.compareAndSet(this, cMaybeAccumulator, ADDING)) {\n+                    assert cMaybeAccumulator instanceof Accumulator;\n+                    @SuppressWarnings(\"unchecked\")\n+                    final Accumulator<T, B> accumulator = (Accumulator<T, B>) cMaybeAccumulator;\n+                    if (missedAccumulator != null) {\n+                        target.onNext(missedAccumulator.finish());\n+                    } else {\n+                        accumulator.accumulate(item);\n+                    }\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, ADDING, accumulator)) {\n+                        return;\n+                    } else if (missedAccumulator == null) {\n+                        missedAccumulator = accumulator;\n+                    } else {\n+                        // we have added an item to the accumulator and emitted the missedAccumulator. The accumulator\n+                        // in maybeAccumulator is now the current to which subsequent items must be added.\n+                        return;\n+                    }\n+                }\n+            }\n+        }\n+\n+        <T, B> boolean nextAccumulator(final Accumulator<T, B> nextAccumulator, final Subscriber<? super B> target,\n+                                       final Cancellable boundariesCancellable, final Subscription itemsSubscription) {\n+            requireNonNull(nextAccumulator);", "originalCommit": "01ed2b2f74f93c153da5d802c2d5b2b6f569336c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE5NjYwMQ==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r422196601", "bodyText": "nit:  remove this assert because you cast immediately after this line which would throw a runtime exception if this assertion doesn't hold.", "author": "Scottmitch", "createdAt": "2020-05-08T15:05:19Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherBuffer.java", "diffHunk": "@@ -0,0 +1,373 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.ConcurrentSubscription.wrap;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.deliverErrorFromSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.error;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n+\n+final class PublisherBuffer<T, B> extends AbstractAsynchronousPublisherOperator<T, B> {\n+    private final BufferStrategy<T, ?, B> bufferStrategy;\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final BufferStrategy<T, ?, B> bufferStrategy) {\n+        super(original, executor);\n+        this.bufferStrategy = requireNonNull(bufferStrategy);\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super B> subscriber) {\n+        final int bufferSizeHint = bufferStrategy.bufferSizeHint();\n+        if (bufferSizeHint <= 0) {\n+            deliverErrorFromSource(subscriber,\n+                    new IllegalArgumentException(\"bufferSizeHint: \" + bufferSizeHint + \" (expected > 0)\"));\n+        }\n+        return new ItemsSubscriber<>(bufferStrategy.boundaries(), subscriber, bufferSizeHint);\n+    }\n+\n+    private static final class ItemsSubscriber<T, B> implements Subscriber<T> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<ItemsSubscriber> pendingUpdater =\n+                newUpdater(ItemsSubscriber.class, \"pending\");\n+\n+        private final Subscriber<? super B> target;\n+        private final State state;\n+        private final DelayedSubscription tSubscription;\n+        private final int bufferSizeHint;\n+        private final DelayedCancellable bCancellable;\n+\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+        private volatile long pending;\n+\n+        ItemsSubscriber(final Publisher<? extends Accumulator<T, B>> boundaries,\n+                        final Subscriber<? super B> target, final int bufferSizeHint) {\n+            this.target = target;\n+            state = new State(bufferSizeHint);\n+            tSubscription = new DelayedSubscription();\n+            this.bufferSizeHint = bufferSizeHint;\n+            // Request-n is delayed till we receive the first boundary but we will request bufferSizeHint.\n+            // This is done here to localize state management (pending count) in this subscriber but still drive the\n+            // first request-n from inside State.\n+            pending = bufferSizeHint;\n+            final BoundariesSubscriber<T, B> bSubscriber = new BoundariesSubscriber<>(state, target, tSubscription);\n+            bCancellable = bSubscriber;\n+            toSource(boundaries).subscribe(bSubscriber);\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription subscription) {\n+            this.subscription = wrap(subscription);\n+            tSubscription.delayedSubscription(this.subscription);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final long pending = pendingUpdater.decrementAndGet(this);\n+            state.accumulate(t, target);\n+            if (pending == 0) {\n+                assert subscription != null;\n+                requestMoreItems(subscription);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            state.itemsTerminated(error(t), target, bCancellable);\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            state.itemsTerminated(complete(), target, bCancellable);\n+        }\n+\n+        private void requestMoreItems(final Subscription subscription) {\n+            pendingUpdater.accumulateAndGet(this, bufferSizeHint, FlowControlUtils::addWithOverflowProtection);\n+            subscription.request(bufferSizeHint);\n+        }\n+    }\n+\n+    private static final class BoundariesSubscriber<T, B> extends DelayedCancellable\n+            implements Subscriber<Accumulator<T, B>> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BoundariesSubscriber> pendingUpdater =\n+                newUpdater(BoundariesSubscriber.class, \"pending\");\n+        private final State state;\n+        private final Subscriber<? super B> target;\n+        private final Subscription tSubscription;\n+\n+        private volatile long pending;\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+\n+        BoundariesSubscriber(final State state, final Subscriber<? super B> target, final Subscription tSubscription) {\n+            this.state = state;\n+            this.target = target;\n+            this.tSubscription = tSubscription;\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription bSubscription) {\n+            subscription = wrap(new Subscription() {\n+                @Override\n+                public void request(final long n) {\n+                    if (isRequestNValid(n)) {\n+                        pendingUpdater.accumulateAndGet(BoundariesSubscriber.this, n,\n+                                FlowControlUtils::addWithOverflowProtection);\n+                    }\n+                    bSubscription.request(n);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    try {\n+                        bSubscription.cancel();\n+                    } finally {\n+                        tSubscription.cancel();\n+                    }\n+                }\n+            });\n+            delayedCancellable(subscription);\n+            target.onSubscribe(subscription);\n+        }\n+\n+        @Override\n+        public void onNext(@Nonnull final Accumulator<T, B> accumulator) {\n+            requireNonNull(accumulator);\n+            pendingUpdater.decrementAndGet(this);\n+            assert subscription != null;\n+            if (!state.nextAccumulator(accumulator, target, subscription, tSubscription)) {\n+                pendingUpdater.incrementAndGet(this);\n+                subscription.request(1);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            try {\n+                state.boundariesTerminated(t, target);\n+            } finally {\n+                tSubscription.cancel();\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            try {\n+                state.boundariesTerminated(new IllegalStateException(\"Boundaries source completed unexpectedly.\"),\n+                        target);\n+            } finally {\n+                tSubscription.cancel();\n+            }\n+        }\n+    }\n+\n+    private static final class State {\n+        private static final Object ADDING = new Object();\n+        private static final Object TERMINATED = new Object();\n+        private static final AtomicReferenceFieldUpdater<State, Object> maybeAccumulatorUpdater =\n+                AtomicReferenceFieldUpdater.newUpdater(State.class, Object.class, \"maybeAccumulator\");\n+\n+        private final int firstItemsRequestN;\n+        /**\n+         * Following values are assigned to this variable:\n+         * <ul>\n+         *     <li>{@code null} till the first accumulator arrives.</li>\n+         *     <li>{@link #ADDING} if an item is being added to the currently active {@link Accumulator}</li>\n+         *     <li>{@link ItemsTerminated} if the items source terminated but the target is not yet terminated.</li>\n+         *     <li>{@link #TERMINATED} if the target subscriber has been terminated (or cancelled).</li>\n+         *     <li>{@link Accumulator} which is emitted by the boundaries source.</li>\n+         * </ul>\n+         */\n+        @Nullable\n+        private volatile Object maybeAccumulator;\n+\n+        State(final int firstItemsRequestN) {\n+            this.firstItemsRequestN = firstItemsRequestN;\n+        }\n+\n+        <T, B> void accumulate(@Nullable final T item, final Subscriber<? super B> target) {\n+            Accumulator<T, B> missedAccumulator = null;\n+            for (;;) {\n+                final Object cMaybeAccumulator = maybeAccumulator;\n+                assert cMaybeAccumulator != null;\n+\n+                // This method is called when a new item is received.\n+                // The subscription for items source is local to this operator and could never be interacted from an\n+                // external entity. This means we neither re-enter this method nor the items source can terminate\n+                // when we are inside this method (onNext and onError/onComplete can not be concurrent).\n+                if (cMaybeAccumulator == TERMINATED || cMaybeAccumulator instanceof ItemsTerminated) {\n+                    return;\n+                }\n+                assert cMaybeAccumulator != ADDING;\n+                // If we are ADDING and maybeAccumulatorUpdater has changed then either it should have terminated or\n+                // a new accumulator has been received. If a new accumulator is received, we could have never added to\n+                // that accumulator (as we were adding to an old accumulator), so we discard that accumulator.\n+                if (maybeAccumulatorUpdater.compareAndSet(this, cMaybeAccumulator, ADDING)) {\n+                    assert cMaybeAccumulator instanceof Accumulator;", "originalCommit": "01ed2b2f74f93c153da5d802c2d5b2b6f569336c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIwODM5MQ==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r422208391", "bodyText": "nit: consider simplifying this conditional:\n                    if (maybeAccumulatorUpdater.compareAndSet(this, ADDING, accumulator) || missedAccumulator != null) {\n                        return;\n                    }\n                    missedAccumulator = accumulator;", "author": "Scottmitch", "createdAt": "2020-05-08T15:26:56Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherBuffer.java", "diffHunk": "@@ -0,0 +1,373 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.ConcurrentSubscription.wrap;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.deliverErrorFromSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.error;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n+\n+final class PublisherBuffer<T, B> extends AbstractAsynchronousPublisherOperator<T, B> {\n+    private final BufferStrategy<T, ?, B> bufferStrategy;\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final BufferStrategy<T, ?, B> bufferStrategy) {\n+        super(original, executor);\n+        this.bufferStrategy = requireNonNull(bufferStrategy);\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super B> subscriber) {\n+        final int bufferSizeHint = bufferStrategy.bufferSizeHint();\n+        if (bufferSizeHint <= 0) {\n+            deliverErrorFromSource(subscriber,\n+                    new IllegalArgumentException(\"bufferSizeHint: \" + bufferSizeHint + \" (expected > 0)\"));\n+        }\n+        return new ItemsSubscriber<>(bufferStrategy.boundaries(), subscriber, bufferSizeHint);\n+    }\n+\n+    private static final class ItemsSubscriber<T, B> implements Subscriber<T> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<ItemsSubscriber> pendingUpdater =\n+                newUpdater(ItemsSubscriber.class, \"pending\");\n+\n+        private final Subscriber<? super B> target;\n+        private final State state;\n+        private final DelayedSubscription tSubscription;\n+        private final int bufferSizeHint;\n+        private final DelayedCancellable bCancellable;\n+\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+        private volatile long pending;\n+\n+        ItemsSubscriber(final Publisher<? extends Accumulator<T, B>> boundaries,\n+                        final Subscriber<? super B> target, final int bufferSizeHint) {\n+            this.target = target;\n+            state = new State(bufferSizeHint);\n+            tSubscription = new DelayedSubscription();\n+            this.bufferSizeHint = bufferSizeHint;\n+            // Request-n is delayed till we receive the first boundary but we will request bufferSizeHint.\n+            // This is done here to localize state management (pending count) in this subscriber but still drive the\n+            // first request-n from inside State.\n+            pending = bufferSizeHint;\n+            final BoundariesSubscriber<T, B> bSubscriber = new BoundariesSubscriber<>(state, target, tSubscription);\n+            bCancellable = bSubscriber;\n+            toSource(boundaries).subscribe(bSubscriber);\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription subscription) {\n+            this.subscription = wrap(subscription);\n+            tSubscription.delayedSubscription(this.subscription);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final long pending = pendingUpdater.decrementAndGet(this);\n+            state.accumulate(t, target);\n+            if (pending == 0) {\n+                assert subscription != null;\n+                requestMoreItems(subscription);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            state.itemsTerminated(error(t), target, bCancellable);\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            state.itemsTerminated(complete(), target, bCancellable);\n+        }\n+\n+        private void requestMoreItems(final Subscription subscription) {\n+            pendingUpdater.accumulateAndGet(this, bufferSizeHint, FlowControlUtils::addWithOverflowProtection);\n+            subscription.request(bufferSizeHint);\n+        }\n+    }\n+\n+    private static final class BoundariesSubscriber<T, B> extends DelayedCancellable\n+            implements Subscriber<Accumulator<T, B>> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BoundariesSubscriber> pendingUpdater =\n+                newUpdater(BoundariesSubscriber.class, \"pending\");\n+        private final State state;\n+        private final Subscriber<? super B> target;\n+        private final Subscription tSubscription;\n+\n+        private volatile long pending;\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+\n+        BoundariesSubscriber(final State state, final Subscriber<? super B> target, final Subscription tSubscription) {\n+            this.state = state;\n+            this.target = target;\n+            this.tSubscription = tSubscription;\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription bSubscription) {\n+            subscription = wrap(new Subscription() {\n+                @Override\n+                public void request(final long n) {\n+                    if (isRequestNValid(n)) {\n+                        pendingUpdater.accumulateAndGet(BoundariesSubscriber.this, n,\n+                                FlowControlUtils::addWithOverflowProtection);\n+                    }\n+                    bSubscription.request(n);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    try {\n+                        bSubscription.cancel();\n+                    } finally {\n+                        tSubscription.cancel();\n+                    }\n+                }\n+            });\n+            delayedCancellable(subscription);\n+            target.onSubscribe(subscription);\n+        }\n+\n+        @Override\n+        public void onNext(@Nonnull final Accumulator<T, B> accumulator) {\n+            requireNonNull(accumulator);\n+            pendingUpdater.decrementAndGet(this);\n+            assert subscription != null;\n+            if (!state.nextAccumulator(accumulator, target, subscription, tSubscription)) {\n+                pendingUpdater.incrementAndGet(this);\n+                subscription.request(1);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            try {\n+                state.boundariesTerminated(t, target);\n+            } finally {\n+                tSubscription.cancel();\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            try {\n+                state.boundariesTerminated(new IllegalStateException(\"Boundaries source completed unexpectedly.\"),\n+                        target);\n+            } finally {\n+                tSubscription.cancel();\n+            }\n+        }\n+    }\n+\n+    private static final class State {\n+        private static final Object ADDING = new Object();\n+        private static final Object TERMINATED = new Object();\n+        private static final AtomicReferenceFieldUpdater<State, Object> maybeAccumulatorUpdater =\n+                AtomicReferenceFieldUpdater.newUpdater(State.class, Object.class, \"maybeAccumulator\");\n+\n+        private final int firstItemsRequestN;\n+        /**\n+         * Following values are assigned to this variable:\n+         * <ul>\n+         *     <li>{@code null} till the first accumulator arrives.</li>\n+         *     <li>{@link #ADDING} if an item is being added to the currently active {@link Accumulator}</li>\n+         *     <li>{@link ItemsTerminated} if the items source terminated but the target is not yet terminated.</li>\n+         *     <li>{@link #TERMINATED} if the target subscriber has been terminated (or cancelled).</li>\n+         *     <li>{@link Accumulator} which is emitted by the boundaries source.</li>\n+         * </ul>\n+         */\n+        @Nullable\n+        private volatile Object maybeAccumulator;\n+\n+        State(final int firstItemsRequestN) {\n+            this.firstItemsRequestN = firstItemsRequestN;\n+        }\n+\n+        <T, B> void accumulate(@Nullable final T item, final Subscriber<? super B> target) {\n+            Accumulator<T, B> missedAccumulator = null;\n+            for (;;) {\n+                final Object cMaybeAccumulator = maybeAccumulator;\n+                assert cMaybeAccumulator != null;\n+\n+                // This method is called when a new item is received.\n+                // The subscription for items source is local to this operator and could never be interacted from an\n+                // external entity. This means we neither re-enter this method nor the items source can terminate\n+                // when we are inside this method (onNext and onError/onComplete can not be concurrent).\n+                if (cMaybeAccumulator == TERMINATED || cMaybeAccumulator instanceof ItemsTerminated) {\n+                    return;\n+                }\n+                assert cMaybeAccumulator != ADDING;\n+                // If we are ADDING and maybeAccumulatorUpdater has changed then either it should have terminated or\n+                // a new accumulator has been received. If a new accumulator is received, we could have never added to\n+                // that accumulator (as we were adding to an old accumulator), so we discard that accumulator.\n+                if (maybeAccumulatorUpdater.compareAndSet(this, cMaybeAccumulator, ADDING)) {\n+                    assert cMaybeAccumulator instanceof Accumulator;\n+                    @SuppressWarnings(\"unchecked\")\n+                    final Accumulator<T, B> accumulator = (Accumulator<T, B>) cMaybeAccumulator;\n+                    if (missedAccumulator != null) {\n+                        target.onNext(missedAccumulator.finish());\n+                    } else {\n+                        accumulator.accumulate(item);\n+                    }\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, ADDING, accumulator)) {", "originalCommit": "01ed2b2f74f93c153da5d802c2d5b2b6f569336c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIxMzE1Ng==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r422213156", "bodyText": "consider clarifying this statement, because it isn't true if there are 2 (or more) consecutive hand-offs between accumulate and nextAccumulator...\nT1:\naccumulate(item)\nCAS(accumulator, ADDING) -> true\n\nT2:\nnextAccumulator(newAccumulator)\nCAS(ADDING, newAccumulator) -> true\n\nT1:\naccumulator.accumulate(item)\nCAS(ADDING, accumulator) -> false\nCAS(newAccumulator, ADDING) -> true\n\nT2:\nnextAccumulator(newAccumulator2)\nCAS(ADDING, newAccumulator2) -> true\n\nT1:\ntarget.onNext(accumulator.finish()) // note that newAccumulator2 isn't emitted\nCAS(ADDING, newAccumulator2) -> true // this would have quit even if the CAS failed bcz item emitted\n\nsomething like ... \"either ADDING thread will emit nextAccumulator or the previously pending accumulator, but either way we don't need to request more accumulators because the ADDING thread will not loop indefinitely if new accumulators are delivered concurrently with ADDING \"", "author": "Scottmitch", "createdAt": "2020-05-08T15:35:56Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherBuffer.java", "diffHunk": "@@ -0,0 +1,373 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.ConcurrentSubscription.wrap;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.deliverErrorFromSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.error;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n+\n+final class PublisherBuffer<T, B> extends AbstractAsynchronousPublisherOperator<T, B> {\n+    private final BufferStrategy<T, ?, B> bufferStrategy;\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final BufferStrategy<T, ?, B> bufferStrategy) {\n+        super(original, executor);\n+        this.bufferStrategy = requireNonNull(bufferStrategy);\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super B> subscriber) {\n+        final int bufferSizeHint = bufferStrategy.bufferSizeHint();\n+        if (bufferSizeHint <= 0) {\n+            deliverErrorFromSource(subscriber,\n+                    new IllegalArgumentException(\"bufferSizeHint: \" + bufferSizeHint + \" (expected > 0)\"));\n+        }\n+        return new ItemsSubscriber<>(bufferStrategy.boundaries(), subscriber, bufferSizeHint);\n+    }\n+\n+    private static final class ItemsSubscriber<T, B> implements Subscriber<T> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<ItemsSubscriber> pendingUpdater =\n+                newUpdater(ItemsSubscriber.class, \"pending\");\n+\n+        private final Subscriber<? super B> target;\n+        private final State state;\n+        private final DelayedSubscription tSubscription;\n+        private final int bufferSizeHint;\n+        private final DelayedCancellable bCancellable;\n+\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+        private volatile long pending;\n+\n+        ItemsSubscriber(final Publisher<? extends Accumulator<T, B>> boundaries,\n+                        final Subscriber<? super B> target, final int bufferSizeHint) {\n+            this.target = target;\n+            state = new State(bufferSizeHint);\n+            tSubscription = new DelayedSubscription();\n+            this.bufferSizeHint = bufferSizeHint;\n+            // Request-n is delayed till we receive the first boundary but we will request bufferSizeHint.\n+            // This is done here to localize state management (pending count) in this subscriber but still drive the\n+            // first request-n from inside State.\n+            pending = bufferSizeHint;\n+            final BoundariesSubscriber<T, B> bSubscriber = new BoundariesSubscriber<>(state, target, tSubscription);\n+            bCancellable = bSubscriber;\n+            toSource(boundaries).subscribe(bSubscriber);\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription subscription) {\n+            this.subscription = wrap(subscription);\n+            tSubscription.delayedSubscription(this.subscription);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final long pending = pendingUpdater.decrementAndGet(this);\n+            state.accumulate(t, target);\n+            if (pending == 0) {\n+                assert subscription != null;\n+                requestMoreItems(subscription);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            state.itemsTerminated(error(t), target, bCancellable);\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            state.itemsTerminated(complete(), target, bCancellable);\n+        }\n+\n+        private void requestMoreItems(final Subscription subscription) {\n+            pendingUpdater.accumulateAndGet(this, bufferSizeHint, FlowControlUtils::addWithOverflowProtection);\n+            subscription.request(bufferSizeHint);\n+        }\n+    }\n+\n+    private static final class BoundariesSubscriber<T, B> extends DelayedCancellable\n+            implements Subscriber<Accumulator<T, B>> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BoundariesSubscriber> pendingUpdater =\n+                newUpdater(BoundariesSubscriber.class, \"pending\");\n+        private final State state;\n+        private final Subscriber<? super B> target;\n+        private final Subscription tSubscription;\n+\n+        private volatile long pending;\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+\n+        BoundariesSubscriber(final State state, final Subscriber<? super B> target, final Subscription tSubscription) {\n+            this.state = state;\n+            this.target = target;\n+            this.tSubscription = tSubscription;\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription bSubscription) {\n+            subscription = wrap(new Subscription() {\n+                @Override\n+                public void request(final long n) {\n+                    if (isRequestNValid(n)) {\n+                        pendingUpdater.accumulateAndGet(BoundariesSubscriber.this, n,\n+                                FlowControlUtils::addWithOverflowProtection);\n+                    }\n+                    bSubscription.request(n);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    try {\n+                        bSubscription.cancel();\n+                    } finally {\n+                        tSubscription.cancel();\n+                    }\n+                }\n+            });\n+            delayedCancellable(subscription);\n+            target.onSubscribe(subscription);\n+        }\n+\n+        @Override\n+        public void onNext(@Nonnull final Accumulator<T, B> accumulator) {\n+            requireNonNull(accumulator);\n+            pendingUpdater.decrementAndGet(this);\n+            assert subscription != null;\n+            if (!state.nextAccumulator(accumulator, target, subscription, tSubscription)) {\n+                pendingUpdater.incrementAndGet(this);\n+                subscription.request(1);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            try {\n+                state.boundariesTerminated(t, target);\n+            } finally {\n+                tSubscription.cancel();\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            try {\n+                state.boundariesTerminated(new IllegalStateException(\"Boundaries source completed unexpectedly.\"),\n+                        target);\n+            } finally {\n+                tSubscription.cancel();\n+            }\n+        }\n+    }\n+\n+    private static final class State {\n+        private static final Object ADDING = new Object();\n+        private static final Object TERMINATED = new Object();\n+        private static final AtomicReferenceFieldUpdater<State, Object> maybeAccumulatorUpdater =\n+                AtomicReferenceFieldUpdater.newUpdater(State.class, Object.class, \"maybeAccumulator\");\n+\n+        private final int firstItemsRequestN;\n+        /**\n+         * Following values are assigned to this variable:\n+         * <ul>\n+         *     <li>{@code null} till the first accumulator arrives.</li>\n+         *     <li>{@link #ADDING} if an item is being added to the currently active {@link Accumulator}</li>\n+         *     <li>{@link ItemsTerminated} if the items source terminated but the target is not yet terminated.</li>\n+         *     <li>{@link #TERMINATED} if the target subscriber has been terminated (or cancelled).</li>\n+         *     <li>{@link Accumulator} which is emitted by the boundaries source.</li>\n+         * </ul>\n+         */\n+        @Nullable\n+        private volatile Object maybeAccumulator;\n+\n+        State(final int firstItemsRequestN) {\n+            this.firstItemsRequestN = firstItemsRequestN;\n+        }\n+\n+        <T, B> void accumulate(@Nullable final T item, final Subscriber<? super B> target) {\n+            Accumulator<T, B> missedAccumulator = null;\n+            for (;;) {\n+                final Object cMaybeAccumulator = maybeAccumulator;\n+                assert cMaybeAccumulator != null;\n+\n+                // This method is called when a new item is received.\n+                // The subscription for items source is local to this operator and could never be interacted from an\n+                // external entity. This means we neither re-enter this method nor the items source can terminate\n+                // when we are inside this method (onNext and onError/onComplete can not be concurrent).\n+                if (cMaybeAccumulator == TERMINATED || cMaybeAccumulator instanceof ItemsTerminated) {\n+                    return;\n+                }\n+                assert cMaybeAccumulator != ADDING;\n+                // If we are ADDING and maybeAccumulatorUpdater has changed then either it should have terminated or\n+                // a new accumulator has been received. If a new accumulator is received, we could have never added to\n+                // that accumulator (as we were adding to an old accumulator), so we discard that accumulator.\n+                if (maybeAccumulatorUpdater.compareAndSet(this, cMaybeAccumulator, ADDING)) {\n+                    assert cMaybeAccumulator instanceof Accumulator;\n+                    @SuppressWarnings(\"unchecked\")\n+                    final Accumulator<T, B> accumulator = (Accumulator<T, B>) cMaybeAccumulator;\n+                    if (missedAccumulator != null) {\n+                        target.onNext(missedAccumulator.finish());\n+                    } else {\n+                        accumulator.accumulate(item);\n+                    }\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, ADDING, accumulator)) {\n+                        return;\n+                    } else if (missedAccumulator == null) {\n+                        missedAccumulator = accumulator;\n+                    } else {\n+                        // we have added an item to the accumulator and emitted the missedAccumulator. The accumulator\n+                        // in maybeAccumulator is now the current to which subsequent items must be added.\n+                        return;\n+                    }\n+                }\n+            }\n+        }\n+\n+        <T, B> boolean nextAccumulator(final Accumulator<T, B> nextAccumulator, final Subscriber<? super B> target,\n+                                       final Cancellable boundariesCancellable, final Subscription itemsSubscription) {\n+            requireNonNull(nextAccumulator);\n+            for (;;) {\n+                final Object cMaybeAccumulator = maybeAccumulator;\n+                if (cMaybeAccumulator == TERMINATED) {\n+                    return true;\n+                }\n+                if (cMaybeAccumulator == null) {\n+                    // This is the first received accumulator (first boundary start); so we just store the accumulator\n+                    // to accumulate and request items from itemsSubscription.\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, null, nextAccumulator)) {\n+                        itemsSubscription.request(firstItemsRequestN);\n+                        return false;\n+                    }\n+                } else if (cMaybeAccumulator == ADDING) {\n+                    // Hand-off emission of nextAccumulator to the thread that is ADDING\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, ADDING, nextAccumulator)) {\n+                        // ADDING thread will emit nextAccumulator.", "originalCommit": "01ed2b2f74f93c153da5d802c2d5b2b6f569336c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNTg0Mw==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r422405843", "bodyText": "After inlining bSubscription.request(1) in this method and removing boolean return type, this comment isn't needed anymore. I will just remove.", "author": "NiteshKant", "createdAt": "2020-05-08T22:34:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIxMzE1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIxNzgwMg==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r422217802", "bodyText": "nit: consider removing this because the cast inside the if will throw if this isn't true.", "author": "Scottmitch", "createdAt": "2020-05-08T15:44:35Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherBuffer.java", "diffHunk": "@@ -0,0 +1,373 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.ConcurrentSubscription.wrap;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.deliverErrorFromSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.error;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n+\n+final class PublisherBuffer<T, B> extends AbstractAsynchronousPublisherOperator<T, B> {\n+    private final BufferStrategy<T, ?, B> bufferStrategy;\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final BufferStrategy<T, ?, B> bufferStrategy) {\n+        super(original, executor);\n+        this.bufferStrategy = requireNonNull(bufferStrategy);\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super B> subscriber) {\n+        final int bufferSizeHint = bufferStrategy.bufferSizeHint();\n+        if (bufferSizeHint <= 0) {\n+            deliverErrorFromSource(subscriber,\n+                    new IllegalArgumentException(\"bufferSizeHint: \" + bufferSizeHint + \" (expected > 0)\"));\n+        }\n+        return new ItemsSubscriber<>(bufferStrategy.boundaries(), subscriber, bufferSizeHint);\n+    }\n+\n+    private static final class ItemsSubscriber<T, B> implements Subscriber<T> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<ItemsSubscriber> pendingUpdater =\n+                newUpdater(ItemsSubscriber.class, \"pending\");\n+\n+        private final Subscriber<? super B> target;\n+        private final State state;\n+        private final DelayedSubscription tSubscription;\n+        private final int bufferSizeHint;\n+        private final DelayedCancellable bCancellable;\n+\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+        private volatile long pending;\n+\n+        ItemsSubscriber(final Publisher<? extends Accumulator<T, B>> boundaries,\n+                        final Subscriber<? super B> target, final int bufferSizeHint) {\n+            this.target = target;\n+            state = new State(bufferSizeHint);\n+            tSubscription = new DelayedSubscription();\n+            this.bufferSizeHint = bufferSizeHint;\n+            // Request-n is delayed till we receive the first boundary but we will request bufferSizeHint.\n+            // This is done here to localize state management (pending count) in this subscriber but still drive the\n+            // first request-n from inside State.\n+            pending = bufferSizeHint;\n+            final BoundariesSubscriber<T, B> bSubscriber = new BoundariesSubscriber<>(state, target, tSubscription);\n+            bCancellable = bSubscriber;\n+            toSource(boundaries).subscribe(bSubscriber);\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription subscription) {\n+            this.subscription = wrap(subscription);\n+            tSubscription.delayedSubscription(this.subscription);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final long pending = pendingUpdater.decrementAndGet(this);\n+            state.accumulate(t, target);\n+            if (pending == 0) {\n+                assert subscription != null;\n+                requestMoreItems(subscription);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            state.itemsTerminated(error(t), target, bCancellable);\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            state.itemsTerminated(complete(), target, bCancellable);\n+        }\n+\n+        private void requestMoreItems(final Subscription subscription) {\n+            pendingUpdater.accumulateAndGet(this, bufferSizeHint, FlowControlUtils::addWithOverflowProtection);\n+            subscription.request(bufferSizeHint);\n+        }\n+    }\n+\n+    private static final class BoundariesSubscriber<T, B> extends DelayedCancellable\n+            implements Subscriber<Accumulator<T, B>> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BoundariesSubscriber> pendingUpdater =\n+                newUpdater(BoundariesSubscriber.class, \"pending\");\n+        private final State state;\n+        private final Subscriber<? super B> target;\n+        private final Subscription tSubscription;\n+\n+        private volatile long pending;\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+\n+        BoundariesSubscriber(final State state, final Subscriber<? super B> target, final Subscription tSubscription) {\n+            this.state = state;\n+            this.target = target;\n+            this.tSubscription = tSubscription;\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription bSubscription) {\n+            subscription = wrap(new Subscription() {\n+                @Override\n+                public void request(final long n) {\n+                    if (isRequestNValid(n)) {\n+                        pendingUpdater.accumulateAndGet(BoundariesSubscriber.this, n,\n+                                FlowControlUtils::addWithOverflowProtection);\n+                    }\n+                    bSubscription.request(n);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    try {\n+                        bSubscription.cancel();\n+                    } finally {\n+                        tSubscription.cancel();\n+                    }\n+                }\n+            });\n+            delayedCancellable(subscription);\n+            target.onSubscribe(subscription);\n+        }\n+\n+        @Override\n+        public void onNext(@Nonnull final Accumulator<T, B> accumulator) {\n+            requireNonNull(accumulator);\n+            pendingUpdater.decrementAndGet(this);\n+            assert subscription != null;\n+            if (!state.nextAccumulator(accumulator, target, subscription, tSubscription)) {\n+                pendingUpdater.incrementAndGet(this);\n+                subscription.request(1);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            try {\n+                state.boundariesTerminated(t, target);\n+            } finally {\n+                tSubscription.cancel();\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            try {\n+                state.boundariesTerminated(new IllegalStateException(\"Boundaries source completed unexpectedly.\"),\n+                        target);\n+            } finally {\n+                tSubscription.cancel();\n+            }\n+        }\n+    }\n+\n+    private static final class State {\n+        private static final Object ADDING = new Object();\n+        private static final Object TERMINATED = new Object();\n+        private static final AtomicReferenceFieldUpdater<State, Object> maybeAccumulatorUpdater =\n+                AtomicReferenceFieldUpdater.newUpdater(State.class, Object.class, \"maybeAccumulator\");\n+\n+        private final int firstItemsRequestN;\n+        /**\n+         * Following values are assigned to this variable:\n+         * <ul>\n+         *     <li>{@code null} till the first accumulator arrives.</li>\n+         *     <li>{@link #ADDING} if an item is being added to the currently active {@link Accumulator}</li>\n+         *     <li>{@link ItemsTerminated} if the items source terminated but the target is not yet terminated.</li>\n+         *     <li>{@link #TERMINATED} if the target subscriber has been terminated (or cancelled).</li>\n+         *     <li>{@link Accumulator} which is emitted by the boundaries source.</li>\n+         * </ul>\n+         */\n+        @Nullable\n+        private volatile Object maybeAccumulator;\n+\n+        State(final int firstItemsRequestN) {\n+            this.firstItemsRequestN = firstItemsRequestN;\n+        }\n+\n+        <T, B> void accumulate(@Nullable final T item, final Subscriber<? super B> target) {\n+            Accumulator<T, B> missedAccumulator = null;\n+            for (;;) {\n+                final Object cMaybeAccumulator = maybeAccumulator;\n+                assert cMaybeAccumulator != null;\n+\n+                // This method is called when a new item is received.\n+                // The subscription for items source is local to this operator and could never be interacted from an\n+                // external entity. This means we neither re-enter this method nor the items source can terminate\n+                // when we are inside this method (onNext and onError/onComplete can not be concurrent).\n+                if (cMaybeAccumulator == TERMINATED || cMaybeAccumulator instanceof ItemsTerminated) {\n+                    return;\n+                }\n+                assert cMaybeAccumulator != ADDING;\n+                // If we are ADDING and maybeAccumulatorUpdater has changed then either it should have terminated or\n+                // a new accumulator has been received. If a new accumulator is received, we could have never added to\n+                // that accumulator (as we were adding to an old accumulator), so we discard that accumulator.\n+                if (maybeAccumulatorUpdater.compareAndSet(this, cMaybeAccumulator, ADDING)) {\n+                    assert cMaybeAccumulator instanceof Accumulator;\n+                    @SuppressWarnings(\"unchecked\")\n+                    final Accumulator<T, B> accumulator = (Accumulator<T, B>) cMaybeAccumulator;\n+                    if (missedAccumulator != null) {\n+                        target.onNext(missedAccumulator.finish());\n+                    } else {\n+                        accumulator.accumulate(item);\n+                    }\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, ADDING, accumulator)) {\n+                        return;\n+                    } else if (missedAccumulator == null) {\n+                        missedAccumulator = accumulator;\n+                    } else {\n+                        // we have added an item to the accumulator and emitted the missedAccumulator. The accumulator\n+                        // in maybeAccumulator is now the current to which subsequent items must be added.\n+                        return;\n+                    }\n+                }\n+            }\n+        }\n+\n+        <T, B> boolean nextAccumulator(final Accumulator<T, B> nextAccumulator, final Subscriber<? super B> target,\n+                                       final Cancellable boundariesCancellable, final Subscription itemsSubscription) {\n+            requireNonNull(nextAccumulator);\n+            for (;;) {\n+                final Object cMaybeAccumulator = maybeAccumulator;\n+                if (cMaybeAccumulator == TERMINATED) {\n+                    return true;\n+                }\n+                if (cMaybeAccumulator == null) {\n+                    // This is the first received accumulator (first boundary start); so we just store the accumulator\n+                    // to accumulate and request items from itemsSubscription.\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, null, nextAccumulator)) {\n+                        itemsSubscription.request(firstItemsRequestN);\n+                        return false;\n+                    }\n+                } else if (cMaybeAccumulator == ADDING) {\n+                    // Hand-off emission of nextAccumulator to the thread that is ADDING\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, ADDING, nextAccumulator)) {\n+                        // ADDING thread will emit nextAccumulator.\n+                        return true;\n+                    }\n+                } else if (cMaybeAccumulator instanceof ItemsTerminated) {\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, cMaybeAccumulator, TERMINATED)) {\n+                        @SuppressWarnings(\"unchecked\")\n+                        ItemsTerminated<T, B> itemsTerminated = (ItemsTerminated<T, B>) cMaybeAccumulator;\n+                        terminateTarget(itemsTerminated.accumulator, target, itemsTerminated.terminalNotification,\n+                                boundariesCancellable);\n+                        return true;\n+                    }\n+                } else {\n+                    assert cMaybeAccumulator instanceof Accumulator;", "originalCommit": "01ed2b2f74f93c153da5d802c2d5b2b6f569336c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNjE3OA==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r422406178", "bodyText": "I have it before updating state to make sure we are not polluting the state which will happen if the class-cast throws.", "author": "NiteshKant", "createdAt": "2020-05-08T22:35:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIxNzgwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIxOTIwNA==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r422219204", "bodyText": "cMaybeAccumulator instanceof Accumulator && -> can this be removed? IIUC all other cases are handled above.", "author": "Scottmitch", "createdAt": "2020-05-08T15:47:21Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherBuffer.java", "diffHunk": "@@ -0,0 +1,373 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.ConcurrentSubscription.wrap;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.deliverErrorFromSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.error;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n+\n+final class PublisherBuffer<T, B> extends AbstractAsynchronousPublisherOperator<T, B> {\n+    private final BufferStrategy<T, ?, B> bufferStrategy;\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final BufferStrategy<T, ?, B> bufferStrategy) {\n+        super(original, executor);\n+        this.bufferStrategy = requireNonNull(bufferStrategy);\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super B> subscriber) {\n+        final int bufferSizeHint = bufferStrategy.bufferSizeHint();\n+        if (bufferSizeHint <= 0) {\n+            deliverErrorFromSource(subscriber,\n+                    new IllegalArgumentException(\"bufferSizeHint: \" + bufferSizeHint + \" (expected > 0)\"));\n+        }\n+        return new ItemsSubscriber<>(bufferStrategy.boundaries(), subscriber, bufferSizeHint);\n+    }\n+\n+    private static final class ItemsSubscriber<T, B> implements Subscriber<T> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<ItemsSubscriber> pendingUpdater =\n+                newUpdater(ItemsSubscriber.class, \"pending\");\n+\n+        private final Subscriber<? super B> target;\n+        private final State state;\n+        private final DelayedSubscription tSubscription;\n+        private final int bufferSizeHint;\n+        private final DelayedCancellable bCancellable;\n+\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+        private volatile long pending;\n+\n+        ItemsSubscriber(final Publisher<? extends Accumulator<T, B>> boundaries,\n+                        final Subscriber<? super B> target, final int bufferSizeHint) {\n+            this.target = target;\n+            state = new State(bufferSizeHint);\n+            tSubscription = new DelayedSubscription();\n+            this.bufferSizeHint = bufferSizeHint;\n+            // Request-n is delayed till we receive the first boundary but we will request bufferSizeHint.\n+            // This is done here to localize state management (pending count) in this subscriber but still drive the\n+            // first request-n from inside State.\n+            pending = bufferSizeHint;\n+            final BoundariesSubscriber<T, B> bSubscriber = new BoundariesSubscriber<>(state, target, tSubscription);\n+            bCancellable = bSubscriber;\n+            toSource(boundaries).subscribe(bSubscriber);\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription subscription) {\n+            this.subscription = wrap(subscription);\n+            tSubscription.delayedSubscription(this.subscription);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final long pending = pendingUpdater.decrementAndGet(this);\n+            state.accumulate(t, target);\n+            if (pending == 0) {\n+                assert subscription != null;\n+                requestMoreItems(subscription);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            state.itemsTerminated(error(t), target, bCancellable);\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            state.itemsTerminated(complete(), target, bCancellable);\n+        }\n+\n+        private void requestMoreItems(final Subscription subscription) {\n+            pendingUpdater.accumulateAndGet(this, bufferSizeHint, FlowControlUtils::addWithOverflowProtection);\n+            subscription.request(bufferSizeHint);\n+        }\n+    }\n+\n+    private static final class BoundariesSubscriber<T, B> extends DelayedCancellable\n+            implements Subscriber<Accumulator<T, B>> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BoundariesSubscriber> pendingUpdater =\n+                newUpdater(BoundariesSubscriber.class, \"pending\");\n+        private final State state;\n+        private final Subscriber<? super B> target;\n+        private final Subscription tSubscription;\n+\n+        private volatile long pending;\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+\n+        BoundariesSubscriber(final State state, final Subscriber<? super B> target, final Subscription tSubscription) {\n+            this.state = state;\n+            this.target = target;\n+            this.tSubscription = tSubscription;\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription bSubscription) {\n+            subscription = wrap(new Subscription() {\n+                @Override\n+                public void request(final long n) {\n+                    if (isRequestNValid(n)) {\n+                        pendingUpdater.accumulateAndGet(BoundariesSubscriber.this, n,\n+                                FlowControlUtils::addWithOverflowProtection);\n+                    }\n+                    bSubscription.request(n);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    try {\n+                        bSubscription.cancel();\n+                    } finally {\n+                        tSubscription.cancel();\n+                    }\n+                }\n+            });\n+            delayedCancellable(subscription);\n+            target.onSubscribe(subscription);\n+        }\n+\n+        @Override\n+        public void onNext(@Nonnull final Accumulator<T, B> accumulator) {\n+            requireNonNull(accumulator);\n+            pendingUpdater.decrementAndGet(this);\n+            assert subscription != null;\n+            if (!state.nextAccumulator(accumulator, target, subscription, tSubscription)) {\n+                pendingUpdater.incrementAndGet(this);\n+                subscription.request(1);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            try {\n+                state.boundariesTerminated(t, target);\n+            } finally {\n+                tSubscription.cancel();\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            try {\n+                state.boundariesTerminated(new IllegalStateException(\"Boundaries source completed unexpectedly.\"),\n+                        target);\n+            } finally {\n+                tSubscription.cancel();\n+            }\n+        }\n+    }\n+\n+    private static final class State {\n+        private static final Object ADDING = new Object();\n+        private static final Object TERMINATED = new Object();\n+        private static final AtomicReferenceFieldUpdater<State, Object> maybeAccumulatorUpdater =\n+                AtomicReferenceFieldUpdater.newUpdater(State.class, Object.class, \"maybeAccumulator\");\n+\n+        private final int firstItemsRequestN;\n+        /**\n+         * Following values are assigned to this variable:\n+         * <ul>\n+         *     <li>{@code null} till the first accumulator arrives.</li>\n+         *     <li>{@link #ADDING} if an item is being added to the currently active {@link Accumulator}</li>\n+         *     <li>{@link ItemsTerminated} if the items source terminated but the target is not yet terminated.</li>\n+         *     <li>{@link #TERMINATED} if the target subscriber has been terminated (or cancelled).</li>\n+         *     <li>{@link Accumulator} which is emitted by the boundaries source.</li>\n+         * </ul>\n+         */\n+        @Nullable\n+        private volatile Object maybeAccumulator;\n+\n+        State(final int firstItemsRequestN) {\n+            this.firstItemsRequestN = firstItemsRequestN;\n+        }\n+\n+        <T, B> void accumulate(@Nullable final T item, final Subscriber<? super B> target) {\n+            Accumulator<T, B> missedAccumulator = null;\n+            for (;;) {\n+                final Object cMaybeAccumulator = maybeAccumulator;\n+                assert cMaybeAccumulator != null;\n+\n+                // This method is called when a new item is received.\n+                // The subscription for items source is local to this operator and could never be interacted from an\n+                // external entity. This means we neither re-enter this method nor the items source can terminate\n+                // when we are inside this method (onNext and onError/onComplete can not be concurrent).\n+                if (cMaybeAccumulator == TERMINATED || cMaybeAccumulator instanceof ItemsTerminated) {\n+                    return;\n+                }\n+                assert cMaybeAccumulator != ADDING;\n+                // If we are ADDING and maybeAccumulatorUpdater has changed then either it should have terminated or\n+                // a new accumulator has been received. If a new accumulator is received, we could have never added to\n+                // that accumulator (as we were adding to an old accumulator), so we discard that accumulator.\n+                if (maybeAccumulatorUpdater.compareAndSet(this, cMaybeAccumulator, ADDING)) {\n+                    assert cMaybeAccumulator instanceof Accumulator;\n+                    @SuppressWarnings(\"unchecked\")\n+                    final Accumulator<T, B> accumulator = (Accumulator<T, B>) cMaybeAccumulator;\n+                    if (missedAccumulator != null) {\n+                        target.onNext(missedAccumulator.finish());\n+                    } else {\n+                        accumulator.accumulate(item);\n+                    }\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, ADDING, accumulator)) {\n+                        return;\n+                    } else if (missedAccumulator == null) {\n+                        missedAccumulator = accumulator;\n+                    } else {\n+                        // we have added an item to the accumulator and emitted the missedAccumulator. The accumulator\n+                        // in maybeAccumulator is now the current to which subsequent items must be added.\n+                        return;\n+                    }\n+                }\n+            }\n+        }\n+\n+        <T, B> boolean nextAccumulator(final Accumulator<T, B> nextAccumulator, final Subscriber<? super B> target,\n+                                       final Cancellable boundariesCancellable, final Subscription itemsSubscription) {\n+            requireNonNull(nextAccumulator);\n+            for (;;) {\n+                final Object cMaybeAccumulator = maybeAccumulator;\n+                if (cMaybeAccumulator == TERMINATED) {\n+                    return true;\n+                }\n+                if (cMaybeAccumulator == null) {\n+                    // This is the first received accumulator (first boundary start); so we just store the accumulator\n+                    // to accumulate and request items from itemsSubscription.\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, null, nextAccumulator)) {\n+                        itemsSubscription.request(firstItemsRequestN);\n+                        return false;\n+                    }\n+                } else if (cMaybeAccumulator == ADDING) {\n+                    // Hand-off emission of nextAccumulator to the thread that is ADDING\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, ADDING, nextAccumulator)) {\n+                        // ADDING thread will emit nextAccumulator.\n+                        return true;\n+                    }\n+                } else if (cMaybeAccumulator instanceof ItemsTerminated) {\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, cMaybeAccumulator, TERMINATED)) {\n+                        @SuppressWarnings(\"unchecked\")\n+                        ItemsTerminated<T, B> itemsTerminated = (ItemsTerminated<T, B>) cMaybeAccumulator;\n+                        terminateTarget(itemsTerminated.accumulator, target, itemsTerminated.terminalNotification,\n+                                boundariesCancellable);\n+                        return true;\n+                    }\n+                } else {\n+                    assert cMaybeAccumulator instanceof Accumulator;\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, cMaybeAccumulator, nextAccumulator)) {\n+                        @SuppressWarnings(\"unchecked\")\n+                        Accumulator<T, B> oldAccumulator = (Accumulator<T, B>) cMaybeAccumulator;\n+                        target.onNext(oldAccumulator.finish());\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+\n+        <B> void itemsTerminated(final TerminalNotification terminalNotification, final Subscriber<? super B> target,\n+                                 final Cancellable bCancellable) {\n+            for (;;) {\n+                final Object cMaybeAccumulator = maybeAccumulator;\n+                if (cMaybeAccumulator == TERMINATED) {\n+                    return;\n+                }\n+                assert !(cMaybeAccumulator instanceof ItemsTerminated);\n+\n+                if (cMaybeAccumulator == ADDING || cMaybeAccumulator == null) {\n+                    // we threw from onNext or items source completed before request-n\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, cMaybeAccumulator, TERMINATED)) {\n+                        terminalNotification.terminate(target);\n+                        return;\n+                    }\n+                } else if (cMaybeAccumulator instanceof Accumulator &&", "originalCommit": "01ed2b2f74f93c153da5d802c2d5b2b6f569336c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNjM1NA==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r422406354", "bodyText": "Yes lemme convert this to an assert.", "author": "NiteshKant", "createdAt": "2020-05-08T22:36:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIxOTIwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIyMTkyOA==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r422221928", "bodyText": "this constructor is never called. do we still need this object to handoff between the tSubscriber and bSubscriber, or can we just loop in itemsTerminated until CAS is successful and directly terminate? if so, we can kill this class.", "author": "Scottmitch", "createdAt": "2020-05-08T15:52:30Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherBuffer.java", "diffHunk": "@@ -0,0 +1,373 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.ConcurrentSubscription.wrap;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.deliverErrorFromSource;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnComplete;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.safeOnError;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.error;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n+\n+final class PublisherBuffer<T, B> extends AbstractAsynchronousPublisherOperator<T, B> {\n+    private final BufferStrategy<T, ?, B> bufferStrategy;\n+\n+    PublisherBuffer(final Publisher<T> original, final Executor executor,\n+                    final BufferStrategy<T, ?, B> bufferStrategy) {\n+        super(original, executor);\n+        this.bufferStrategy = requireNonNull(bufferStrategy);\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super B> subscriber) {\n+        final int bufferSizeHint = bufferStrategy.bufferSizeHint();\n+        if (bufferSizeHint <= 0) {\n+            deliverErrorFromSource(subscriber,\n+                    new IllegalArgumentException(\"bufferSizeHint: \" + bufferSizeHint + \" (expected > 0)\"));\n+        }\n+        return new ItemsSubscriber<>(bufferStrategy.boundaries(), subscriber, bufferSizeHint);\n+    }\n+\n+    private static final class ItemsSubscriber<T, B> implements Subscriber<T> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<ItemsSubscriber> pendingUpdater =\n+                newUpdater(ItemsSubscriber.class, \"pending\");\n+\n+        private final Subscriber<? super B> target;\n+        private final State state;\n+        private final DelayedSubscription tSubscription;\n+        private final int bufferSizeHint;\n+        private final DelayedCancellable bCancellable;\n+\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+        private volatile long pending;\n+\n+        ItemsSubscriber(final Publisher<? extends Accumulator<T, B>> boundaries,\n+                        final Subscriber<? super B> target, final int bufferSizeHint) {\n+            this.target = target;\n+            state = new State(bufferSizeHint);\n+            tSubscription = new DelayedSubscription();\n+            this.bufferSizeHint = bufferSizeHint;\n+            // Request-n is delayed till we receive the first boundary but we will request bufferSizeHint.\n+            // This is done here to localize state management (pending count) in this subscriber but still drive the\n+            // first request-n from inside State.\n+            pending = bufferSizeHint;\n+            final BoundariesSubscriber<T, B> bSubscriber = new BoundariesSubscriber<>(state, target, tSubscription);\n+            bCancellable = bSubscriber;\n+            toSource(boundaries).subscribe(bSubscriber);\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription subscription) {\n+            this.subscription = wrap(subscription);\n+            tSubscription.delayedSubscription(this.subscription);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final long pending = pendingUpdater.decrementAndGet(this);\n+            state.accumulate(t, target);\n+            if (pending == 0) {\n+                assert subscription != null;\n+                requestMoreItems(subscription);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            state.itemsTerminated(error(t), target, bCancellable);\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            state.itemsTerminated(complete(), target, bCancellable);\n+        }\n+\n+        private void requestMoreItems(final Subscription subscription) {\n+            pendingUpdater.accumulateAndGet(this, bufferSizeHint, FlowControlUtils::addWithOverflowProtection);\n+            subscription.request(bufferSizeHint);\n+        }\n+    }\n+\n+    private static final class BoundariesSubscriber<T, B> extends DelayedCancellable\n+            implements Subscriber<Accumulator<T, B>> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<BoundariesSubscriber> pendingUpdater =\n+                newUpdater(BoundariesSubscriber.class, \"pending\");\n+        private final State state;\n+        private final Subscriber<? super B> target;\n+        private final Subscription tSubscription;\n+\n+        private volatile long pending;\n+        @Nullable\n+        private ConcurrentSubscription subscription;\n+\n+        BoundariesSubscriber(final State state, final Subscriber<? super B> target, final Subscription tSubscription) {\n+            this.state = state;\n+            this.target = target;\n+            this.tSubscription = tSubscription;\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription bSubscription) {\n+            subscription = wrap(new Subscription() {\n+                @Override\n+                public void request(final long n) {\n+                    if (isRequestNValid(n)) {\n+                        pendingUpdater.accumulateAndGet(BoundariesSubscriber.this, n,\n+                                FlowControlUtils::addWithOverflowProtection);\n+                    }\n+                    bSubscription.request(n);\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    try {\n+                        bSubscription.cancel();\n+                    } finally {\n+                        tSubscription.cancel();\n+                    }\n+                }\n+            });\n+            delayedCancellable(subscription);\n+            target.onSubscribe(subscription);\n+        }\n+\n+        @Override\n+        public void onNext(@Nonnull final Accumulator<T, B> accumulator) {\n+            requireNonNull(accumulator);\n+            pendingUpdater.decrementAndGet(this);\n+            assert subscription != null;\n+            if (!state.nextAccumulator(accumulator, target, subscription, tSubscription)) {\n+                pendingUpdater.incrementAndGet(this);\n+                subscription.request(1);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            try {\n+                state.boundariesTerminated(t, target);\n+            } finally {\n+                tSubscription.cancel();\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            try {\n+                state.boundariesTerminated(new IllegalStateException(\"Boundaries source completed unexpectedly.\"),\n+                        target);\n+            } finally {\n+                tSubscription.cancel();\n+            }\n+        }\n+    }\n+\n+    private static final class State {\n+        private static final Object ADDING = new Object();\n+        private static final Object TERMINATED = new Object();\n+        private static final AtomicReferenceFieldUpdater<State, Object> maybeAccumulatorUpdater =\n+                AtomicReferenceFieldUpdater.newUpdater(State.class, Object.class, \"maybeAccumulator\");\n+\n+        private final int firstItemsRequestN;\n+        /**\n+         * Following values are assigned to this variable:\n+         * <ul>\n+         *     <li>{@code null} till the first accumulator arrives.</li>\n+         *     <li>{@link #ADDING} if an item is being added to the currently active {@link Accumulator}</li>\n+         *     <li>{@link ItemsTerminated} if the items source terminated but the target is not yet terminated.</li>\n+         *     <li>{@link #TERMINATED} if the target subscriber has been terminated (or cancelled).</li>\n+         *     <li>{@link Accumulator} which is emitted by the boundaries source.</li>\n+         * </ul>\n+         */\n+        @Nullable\n+        private volatile Object maybeAccumulator;\n+\n+        State(final int firstItemsRequestN) {\n+            this.firstItemsRequestN = firstItemsRequestN;\n+        }\n+\n+        <T, B> void accumulate(@Nullable final T item, final Subscriber<? super B> target) {\n+            Accumulator<T, B> missedAccumulator = null;\n+            for (;;) {\n+                final Object cMaybeAccumulator = maybeAccumulator;\n+                assert cMaybeAccumulator != null;\n+\n+                // This method is called when a new item is received.\n+                // The subscription for items source is local to this operator and could never be interacted from an\n+                // external entity. This means we neither re-enter this method nor the items source can terminate\n+                // when we are inside this method (onNext and onError/onComplete can not be concurrent).\n+                if (cMaybeAccumulator == TERMINATED || cMaybeAccumulator instanceof ItemsTerminated) {\n+                    return;\n+                }\n+                assert cMaybeAccumulator != ADDING;\n+                // If we are ADDING and maybeAccumulatorUpdater has changed then either it should have terminated or\n+                // a new accumulator has been received. If a new accumulator is received, we could have never added to\n+                // that accumulator (as we were adding to an old accumulator), so we discard that accumulator.\n+                if (maybeAccumulatorUpdater.compareAndSet(this, cMaybeAccumulator, ADDING)) {\n+                    assert cMaybeAccumulator instanceof Accumulator;\n+                    @SuppressWarnings(\"unchecked\")\n+                    final Accumulator<T, B> accumulator = (Accumulator<T, B>) cMaybeAccumulator;\n+                    if (missedAccumulator != null) {\n+                        target.onNext(missedAccumulator.finish());\n+                    } else {\n+                        accumulator.accumulate(item);\n+                    }\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, ADDING, accumulator)) {\n+                        return;\n+                    } else if (missedAccumulator == null) {\n+                        missedAccumulator = accumulator;\n+                    } else {\n+                        // we have added an item to the accumulator and emitted the missedAccumulator. The accumulator\n+                        // in maybeAccumulator is now the current to which subsequent items must be added.\n+                        return;\n+                    }\n+                }\n+            }\n+        }\n+\n+        <T, B> boolean nextAccumulator(final Accumulator<T, B> nextAccumulator, final Subscriber<? super B> target,\n+                                       final Cancellable boundariesCancellable, final Subscription itemsSubscription) {\n+            requireNonNull(nextAccumulator);\n+            for (;;) {\n+                final Object cMaybeAccumulator = maybeAccumulator;\n+                if (cMaybeAccumulator == TERMINATED) {\n+                    return true;\n+                }\n+                if (cMaybeAccumulator == null) {\n+                    // This is the first received accumulator (first boundary start); so we just store the accumulator\n+                    // to accumulate and request items from itemsSubscription.\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, null, nextAccumulator)) {\n+                        itemsSubscription.request(firstItemsRequestN);\n+                        return false;\n+                    }\n+                } else if (cMaybeAccumulator == ADDING) {\n+                    // Hand-off emission of nextAccumulator to the thread that is ADDING\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, ADDING, nextAccumulator)) {\n+                        // ADDING thread will emit nextAccumulator.\n+                        return true;\n+                    }\n+                } else if (cMaybeAccumulator instanceof ItemsTerminated) {\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, cMaybeAccumulator, TERMINATED)) {\n+                        @SuppressWarnings(\"unchecked\")\n+                        ItemsTerminated<T, B> itemsTerminated = (ItemsTerminated<T, B>) cMaybeAccumulator;\n+                        terminateTarget(itemsTerminated.accumulator, target, itemsTerminated.terminalNotification,\n+                                boundariesCancellable);\n+                        return true;\n+                    }\n+                } else {\n+                    assert cMaybeAccumulator instanceof Accumulator;\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, cMaybeAccumulator, nextAccumulator)) {\n+                        @SuppressWarnings(\"unchecked\")\n+                        Accumulator<T, B> oldAccumulator = (Accumulator<T, B>) cMaybeAccumulator;\n+                        target.onNext(oldAccumulator.finish());\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+\n+        <B> void itemsTerminated(final TerminalNotification terminalNotification, final Subscriber<? super B> target,\n+                                 final Cancellable bCancellable) {\n+            for (;;) {\n+                final Object cMaybeAccumulator = maybeAccumulator;\n+                if (cMaybeAccumulator == TERMINATED) {\n+                    return;\n+                }\n+                assert !(cMaybeAccumulator instanceof ItemsTerminated);\n+\n+                if (cMaybeAccumulator == ADDING || cMaybeAccumulator == null) {\n+                    // we threw from onNext or items source completed before request-n\n+                    if (maybeAccumulatorUpdater.compareAndSet(this, cMaybeAccumulator, TERMINATED)) {\n+                        terminalNotification.terminate(target);\n+                        return;\n+                    }\n+                } else if (cMaybeAccumulator instanceof Accumulator &&\n+                        maybeAccumulatorUpdater.compareAndSet(this, cMaybeAccumulator, TERMINATED)) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    Accumulator<?, B> accumulator = (Accumulator<?, B>) cMaybeAccumulator;\n+                    terminateTarget(accumulator, target, terminalNotification, bCancellable);\n+                    return;\n+                }\n+            }\n+        }\n+\n+        void boundariesTerminated(final Throwable cause, final Subscriber<?> target) {\n+            maybeAccumulator = TERMINATED;\n+            target.onError(cause);\n+        }\n+\n+        private static <T, B> void terminateTarget(@Nullable final Accumulator<T, B> accumulator,\n+                                                   final Subscriber<? super B> target,\n+                                                   final TerminalNotification terminalNotification,\n+                                                   final Cancellable bCancellable) {\n+            try {\n+                if (accumulator != null) {\n+                    try {\n+                        target.onNext(accumulator.finish());\n+                    } catch (Throwable t) {\n+                        target.onError(t);\n+                        return;\n+                    }\n+                }\n+                Throwable cause = terminalNotification.cause();\n+                if (cause == null) {\n+                    safeOnComplete(target);\n+                } else {\n+                    safeOnError(target, cause);\n+                }\n+            } finally {\n+                bCancellable.cancel();\n+            }\n+        }\n+    }\n+\n+    private static final class ItemsTerminated<T, B> {\n+        @Nullable\n+        final Accumulator<T, B> accumulator;\n+        final TerminalNotification terminalNotification;\n+\n+        ItemsTerminated(final Object maybeAccumulator, final TerminalNotification terminalNotification) {", "originalCommit": "01ed2b2f74f93c153da5d802c2d5b2b6f569336c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI5MjkwMA==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r423292900", "bodyText": "So not directly related to this but the handoff has a bug that could concurrently invoke the Subscriber:\nstate = accumulator1\nT1: accumulate() state -> ADDING\nsuspend\nT2: nextAccumulator() -> ADDING => accumulator2; return\nT2: nextAccumulator() -> accumulator2 -> accumulator3 -> target.onNext()\nT1: ADDING -> accumulator1 -> fail\nstate -> accumulator3 -> ADDING\ntarget.onNext(accumulator1.finish() <- we are invoking target concurrently.\n\nI am reverting the hand-off code for now and will create an issue for it for us to track", "author": "NiteshKant", "createdAt": "2020-05-11T20:15:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIyMTkyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI4MjgxOA==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r422282818", "bodyText": "if this throws we will duplicate terminate the countSubscriber via Completable#handleSubscribe catching/terminating -> consider using the safeOnComplete here.", "author": "Scottmitch", "createdAt": "2020-05-08T17:53:02Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/BufferStrategies.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.CompletableSource.Subscriber;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.Cancellable.IGNORE_CANCEL;\n+import static io.servicetalk.concurrent.api.ImmediateExecutor.IMMEDIATE_EXECUTOR;\n+import static io.servicetalk.concurrent.api.Publisher.defer;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.handleExceptionFromOnSubscribe;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * A static factory of {@link BufferStrategy} instances.\n+ */\n+public final class BufferStrategies {\n+    private BufferStrategies() {\n+        // no instances\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed. The\n+     * emitted buffers may have less or more items than this {@code count}.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param <T> Type of items added to the buffer.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T> BufferStrategy<T, Accumulator<T, Iterable<T>>, Iterable<T>> forCountOrTime(\n+            final int count, final Duration duration) {\n+        return forCountOrTime(count, duration, IMMEDIATE_EXECUTOR);\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param executor {@link Executor} to use for recording the passed {@code duration}.\n+     * @param <T> Type of items added to the buffer.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T> BufferStrategy<T, Accumulator<T, Iterable<T>>, Iterable<T>> forCountOrTime(\n+            final int count, final Duration duration, final Executor executor) {\n+        return forCountOrTime(count, duration, () -> new Accumulator<T, Iterable<T>>() {\n+            private final List<T> accumulate = new ArrayList<>();\n+\n+            @Override\n+            public void accumulate(final T t) {\n+                accumulate.add(t);\n+            }\n+\n+            @Override\n+            public Iterable<T> finish() {\n+                return accumulate;\n+            }\n+        }, executor);\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param accumulatorSupplier A {@link Supplier} of {@link Accumulator} every time a buffer boundary is closed.\n+     * Methods on the {@link Accumulator} returned from this {@link Supplier} may or may not be called.\n+     * @param <T> Type of items added to the buffer.\n+     * @param <BC> Type of {@link Accumulator} used to accumulate items in a buffer.\n+     * @param <B> Type of object created after an {@link Accumulator} is {@link Accumulator#finish() finished}.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T, BC extends Accumulator<T, B>, B> BufferStrategy<T, Accumulator<T, B>, B> forCountOrTime(\n+            final int count, final Duration duration, Supplier<BC> accumulatorSupplier) {\n+        return forCountOrTime(count, duration, accumulatorSupplier, IMMEDIATE_EXECUTOR);\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param accumulatorSupplier A {@link Supplier} of {@link Accumulator} every time a buffer boundary is closed.\n+     * Methods on the {@link Accumulator} returned from this {@link Supplier} may or may not be called.\n+     * @param executor {@link Executor} to use for recording the passed {@code duration}.\n+     * @param <T> Type of items added to the buffer.\n+     * @param <BC> Type of {@link Accumulator} used to accumulate items in a buffer.\n+     * @param <B> Type of object created after an {@link Accumulator} is {@link Accumulator#finish() finished}.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T, BC extends Accumulator<T, B>, B> BufferStrategy<T, Accumulator<T, B>, B> forCountOrTime(\n+            final int count, final Duration duration, Supplier<BC> accumulatorSupplier,\n+            final Executor executor) {\n+        if (count <= 0) {\n+            throw new IllegalArgumentException(\"count: \" + count + \" (expected > 0)\");\n+        }\n+        requireNonNull(duration);\n+        requireNonNull(accumulatorSupplier);\n+        requireNonNull(executor);\n+        return new BufferStrategy<T, Accumulator<T, B>, B>() {\n+            @Override\n+            public Publisher<Accumulator<T, B>> boundaries() {\n+                return defer(() -> {\n+                    State<T, B> state = new State<>();\n+                    CountingAccumulator<T, B> firstAccum =\n+                            new CountingAccumulator<>(state, accumulatorSupplier.get(), count);\n+                    state.beforeNewAccumulatorEmitted(firstAccum);\n+                    return Single.succeeded(firstAccum).concat(new Completable() {\n+                        @Override\n+                        protected void handleSubscribe(final Subscriber subscriber) {\n+                            // We ignore cancel and expect ambWith to ignore if we delay emit\n+                            try {\n+                                subscriber.onSubscribe(IGNORE_CANCEL);\n+                            } catch (Throwable t) {\n+                                handleExceptionFromOnSubscribe(subscriber, t);\n+                                return;\n+                            }\n+                            state.countCompletableSubscribed(subscriber);\n+                        }\n+                    }\n+                    .ambWith(executor.timer(duration))\n+                    .toSingle()\n+                    .map(__ -> {\n+                        CountingAccumulator<T, B> accum =\n+                                new CountingAccumulator<>(state, accumulatorSupplier.get(), count);\n+                        state.beforeNewAccumulatorEmitted(accum);\n+                        return accum;\n+                    })\n+                    .repeat(__ -> true));\n+                });\n+            }\n+\n+            @Override\n+            public int bufferSizeHint() {\n+                return count;\n+            }\n+        };\n+    }\n+\n+    private static final class State<T, B> {\n+        private static final Object THRESHOLD_BREACHED_BEFORE_SUBSCRIBE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<State, Object> stateUpdater =\n+                newUpdater(State.class, Object.class, \"state\");\n+\n+        /**\n+         * The following values can be set to this state:\n+         * <ul>\n+         *     <li>{@code null} if neither an active accumulator is present nor a subscriber.</li>\n+         *     <li>An {@link Accumulator} which is expected to accumulating items for the current boundary.</li>\n+         *     <li>{@link AccumulatorAndSubscriber} instance when an active accumulator and {@link Subscriber} both are\n+         *     active.</li>\n+         *     <li>{@link Subscriber} if the size threshold {@link Completable} is subscribed and there is no\n+         *     accumulator present.</li>\n+         * </ul>\n+         */\n+        @Nullable\n+        private volatile Object state;\n+\n+        void countThresholdBreached(final Accumulator<T, B> breachedAccumulator) {\n+            for (;;) {\n+                final Object cState = state;\n+                if (cState == THRESHOLD_BREACHED_BEFORE_SUBSCRIBE || cState == null) {\n+                    // multiple breaches\n+                    return;\n+                }\n+                if (cState instanceof Accumulator) {\n+                    if (cState != breachedAccumulator ||\n+                            stateUpdater.compareAndSet(this, cState, THRESHOLD_BREACHED_BEFORE_SUBSCRIBE)) {\n+                        // Either the threshold was breached for a stale accumulator or threshold was breached before\n+                        // the accumulator could be set.\n+                        return;\n+                    }\n+                } else if (cState instanceof Subscriber) {\n+                    if (stateUpdater.compareAndSet(this, cState, null)) {\n+                        Subscriber subscriber = (Subscriber) cState;\n+                        subscriber.onComplete();\n+                        return;\n+                    }\n+                } else if (cState instanceof AccumulatorAndSubscriber) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    final AccumulatorAndSubscriber<T, B> accumulatorAndSubscriber =\n+                            (AccumulatorAndSubscriber<T, B>) cState;\n+                    if (accumulatorAndSubscriber.accumulator != breachedAccumulator ||\n+                            stateUpdater.compareAndSet(this, cState, null)) {\n+                        return;\n+                    }\n+                }\n+            }\n+        }\n+\n+        void countCompletableSubscribed(final Subscriber countSubscriber) {\n+            for (;;) {\n+                final Object cState = state;\n+                // Ordering of subscriber and accumulator is provided by repeat() operator such that a new accumulator\n+                // is emitted and then the original source is subscribed again (repeat). As neither the accumulator nor\n+                // the subscribers are skipped, an accumulator that breaches threshold, always indicates completion\n+                // of the associated Subscriber.\n+                if (cState == THRESHOLD_BREACHED_BEFORE_SUBSCRIBE) {\n+                    if (stateUpdater.compareAndSet(this, cState, null)) {\n+                        countSubscriber.onComplete();", "originalCommit": "01ed2b2f74f93c153da5d802c2d5b2b6f569336c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwNjM5Nw==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r422306397", "bodyText": "if we did stateUpdater.compareAndSet(this, cState, null) ... shouldn't we also do subscriber.onComplete()?", "author": "Scottmitch", "createdAt": "2020-05-08T18:40:07Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/BufferStrategies.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.CompletableSource.Subscriber;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.Cancellable.IGNORE_CANCEL;\n+import static io.servicetalk.concurrent.api.ImmediateExecutor.IMMEDIATE_EXECUTOR;\n+import static io.servicetalk.concurrent.api.Publisher.defer;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.handleExceptionFromOnSubscribe;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * A static factory of {@link BufferStrategy} instances.\n+ */\n+public final class BufferStrategies {\n+    private BufferStrategies() {\n+        // no instances\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed. The\n+     * emitted buffers may have less or more items than this {@code count}.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param <T> Type of items added to the buffer.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T> BufferStrategy<T, Accumulator<T, Iterable<T>>, Iterable<T>> forCountOrTime(\n+            final int count, final Duration duration) {\n+        return forCountOrTime(count, duration, IMMEDIATE_EXECUTOR);\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param executor {@link Executor} to use for recording the passed {@code duration}.\n+     * @param <T> Type of items added to the buffer.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T> BufferStrategy<T, Accumulator<T, Iterable<T>>, Iterable<T>> forCountOrTime(\n+            final int count, final Duration duration, final Executor executor) {\n+        return forCountOrTime(count, duration, () -> new Accumulator<T, Iterable<T>>() {\n+            private final List<T> accumulate = new ArrayList<>();\n+\n+            @Override\n+            public void accumulate(final T t) {\n+                accumulate.add(t);\n+            }\n+\n+            @Override\n+            public Iterable<T> finish() {\n+                return accumulate;\n+            }\n+        }, executor);\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param accumulatorSupplier A {@link Supplier} of {@link Accumulator} every time a buffer boundary is closed.\n+     * Methods on the {@link Accumulator} returned from this {@link Supplier} may or may not be called.\n+     * @param <T> Type of items added to the buffer.\n+     * @param <BC> Type of {@link Accumulator} used to accumulate items in a buffer.\n+     * @param <B> Type of object created after an {@link Accumulator} is {@link Accumulator#finish() finished}.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T, BC extends Accumulator<T, B>, B> BufferStrategy<T, Accumulator<T, B>, B> forCountOrTime(\n+            final int count, final Duration duration, Supplier<BC> accumulatorSupplier) {\n+        return forCountOrTime(count, duration, accumulatorSupplier, IMMEDIATE_EXECUTOR);\n+    }\n+\n+    /**\n+     * Returns a {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started. This does not guarantee that the emitted buffers after applying the\n+     * returned {@link BufferStrategy} will have exactly {@code count} number of items. The emitted buffers may have\n+     * less or more items than the {@code count}.\n+     *\n+     * @param count Number of items to add before closing the current buffer boundary, if not already closed.\n+     * @param duration {@link Duration} after which the current buffer boundary is closed, if not already closed.\n+     * @param accumulatorSupplier A {@link Supplier} of {@link Accumulator} every time a buffer boundary is closed.\n+     * Methods on the {@link Accumulator} returned from this {@link Supplier} may or may not be called.\n+     * @param executor {@link Executor} to use for recording the passed {@code duration}.\n+     * @param <T> Type of items added to the buffer.\n+     * @param <BC> Type of {@link Accumulator} used to accumulate items in a buffer.\n+     * @param <B> Type of object created after an {@link Accumulator} is {@link Accumulator#finish() finished}.\n+     * @return {@link BufferStrategy} that creates buffer boundaries based on number of items buffered or time elapsed\n+     * since the current buffer boundary started.\n+     */\n+    public static <T, BC extends Accumulator<T, B>, B> BufferStrategy<T, Accumulator<T, B>, B> forCountOrTime(\n+            final int count, final Duration duration, Supplier<BC> accumulatorSupplier,\n+            final Executor executor) {\n+        if (count <= 0) {\n+            throw new IllegalArgumentException(\"count: \" + count + \" (expected > 0)\");\n+        }\n+        requireNonNull(duration);\n+        requireNonNull(accumulatorSupplier);\n+        requireNonNull(executor);\n+        return new BufferStrategy<T, Accumulator<T, B>, B>() {\n+            @Override\n+            public Publisher<Accumulator<T, B>> boundaries() {\n+                return defer(() -> {\n+                    State<T, B> state = new State<>();\n+                    CountingAccumulator<T, B> firstAccum =\n+                            new CountingAccumulator<>(state, accumulatorSupplier.get(), count);\n+                    state.beforeNewAccumulatorEmitted(firstAccum);\n+                    return Single.succeeded(firstAccum).concat(new Completable() {\n+                        @Override\n+                        protected void handleSubscribe(final Subscriber subscriber) {\n+                            // We ignore cancel and expect ambWith to ignore if we delay emit\n+                            try {\n+                                subscriber.onSubscribe(IGNORE_CANCEL);\n+                            } catch (Throwable t) {\n+                                handleExceptionFromOnSubscribe(subscriber, t);\n+                                return;\n+                            }\n+                            state.countCompletableSubscribed(subscriber);\n+                        }\n+                    }\n+                    .ambWith(executor.timer(duration))\n+                    .toSingle()\n+                    .map(__ -> {\n+                        CountingAccumulator<T, B> accum =\n+                                new CountingAccumulator<>(state, accumulatorSupplier.get(), count);\n+                        state.beforeNewAccumulatorEmitted(accum);\n+                        return accum;\n+                    })\n+                    .repeat(__ -> true));\n+                });\n+            }\n+\n+            @Override\n+            public int bufferSizeHint() {\n+                return count;\n+            }\n+        };\n+    }\n+\n+    private static final class State<T, B> {\n+        private static final Object THRESHOLD_BREACHED_BEFORE_SUBSCRIBE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<State, Object> stateUpdater =\n+                newUpdater(State.class, Object.class, \"state\");\n+\n+        /**\n+         * The following values can be set to this state:\n+         * <ul>\n+         *     <li>{@code null} if neither an active accumulator is present nor a subscriber.</li>\n+         *     <li>An {@link Accumulator} which is expected to accumulating items for the current boundary.</li>\n+         *     <li>{@link AccumulatorAndSubscriber} instance when an active accumulator and {@link Subscriber} both are\n+         *     active.</li>\n+         *     <li>{@link Subscriber} if the size threshold {@link Completable} is subscribed and there is no\n+         *     accumulator present.</li>\n+         * </ul>\n+         */\n+        @Nullable\n+        private volatile Object state;\n+\n+        void countThresholdBreached(final Accumulator<T, B> breachedAccumulator) {\n+            for (;;) {\n+                final Object cState = state;\n+                if (cState == THRESHOLD_BREACHED_BEFORE_SUBSCRIBE || cState == null) {\n+                    // multiple breaches\n+                    return;\n+                }\n+                if (cState instanceof Accumulator) {\n+                    if (cState != breachedAccumulator ||\n+                            stateUpdater.compareAndSet(this, cState, THRESHOLD_BREACHED_BEFORE_SUBSCRIBE)) {\n+                        // Either the threshold was breached for a stale accumulator or threshold was breached before\n+                        // the accumulator could be set.\n+                        return;\n+                    }\n+                } else if (cState instanceof Subscriber) {\n+                    if (stateUpdater.compareAndSet(this, cState, null)) {\n+                        Subscriber subscriber = (Subscriber) cState;\n+                        subscriber.onComplete();\n+                        return;\n+                    }\n+                } else if (cState instanceof AccumulatorAndSubscriber) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    final AccumulatorAndSubscriber<T, B> accumulatorAndSubscriber =\n+                            (AccumulatorAndSubscriber<T, B>) cState;\n+                    if (accumulatorAndSubscriber.accumulator != breachedAccumulator ||\n+                            stateUpdater.compareAndSet(this, cState, null)) {\n+                        return;", "originalCommit": "01ed2b2f74f93c153da5d802c2d5b2b6f569336c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMxNTY0NA==", "url": "https://github.com/apple/servicetalk/pull/1027#discussion_r423315644", "bodyText": "good catch, yes", "author": "NiteshKant", "createdAt": "2020-05-11T20:58:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwNjM5Nw=="}], "type": "inlineReview"}, {"oid": "ee06ff92aed0ef888384f9dc549048601e42c8eb", "url": "https://github.com/apple/servicetalk/commit/ee06ff92aed0ef888384f9dc549048601e42c8eb", "message": "Add `Publisher#buffer` operator\n\n__Motivation__\n\n[`buffer`](http://reactivex.io/documentation/operators/buffer.html) operator is useful for batching.\n\n__Modification__\n\nAdd `buffer()` operator for `Publisher` to buffer based on arbitrary buffer boundaries or based on size + time duration.\n\n__Result__\n\nUsers can buffer events from a `Publisher`.", "committedDate": "2020-05-08T20:45:09Z", "type": "commit"}, {"oid": "ee06ff92aed0ef888384f9dc549048601e42c8eb", "url": "https://github.com/apple/servicetalk/commit/ee06ff92aed0ef888384f9dc549048601e42c8eb", "message": "Add `Publisher#buffer` operator\n\n__Motivation__\n\n[`buffer`](http://reactivex.io/documentation/operators/buffer.html) operator is useful for batching.\n\n__Modification__\n\nAdd `buffer()` operator for `Publisher` to buffer based on arbitrary buffer boundaries or based on size + time duration.\n\n__Result__\n\nUsers can buffer events from a `Publisher`.", "committedDate": "2020-05-08T20:45:09Z", "type": "forcePushed"}, {"oid": "bc600dcb7a8eb43ea222fd4948fee7429f1ae240", "url": "https://github.com/apple/servicetalk/commit/bc600dcb7a8eb43ea222fd4948fee7429f1ae240", "message": "Review comments", "committedDate": "2020-05-08T23:52:13Z", "type": "commit"}, {"oid": "6859c3648c50784a7e781f9f57bb909d54d5554c", "url": "https://github.com/apple/servicetalk/commit/6859c3648c50784a7e781f9f57bb909d54d5554c", "message": "Remove hand-off b/w subscribers", "committedDate": "2020-05-11T22:47:36Z", "type": "commit"}, {"oid": "5ba1534baefe35c382ea91ad07647358abd5b4e7", "url": "https://github.com/apple/servicetalk/commit/5ba1534baefe35c382ea91ad07647358abd5b4e7", "message": "self-review", "committedDate": "2020-05-12T00:25:19Z", "type": "commit"}]}