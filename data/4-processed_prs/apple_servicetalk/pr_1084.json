{"pr_number": 1084, "pr_title": "ServiceTalkThreadContextMap to support null values", "pr_createdAt": "2020-06-10T03:40:37Z", "pr_url": "https://github.com/apple/servicetalk/pull/1084", "timeline": [{"oid": "649ab59fdbd27a41e3f4aa5e086b40e8e765695b", "url": "https://github.com/apple/servicetalk/commit/649ab59fdbd27a41e3f4aa5e086b40e8e765695b", "message": "ServiceTalkThreadContextMap to support null values\n\nMotivation:\nThe MDC API permits for not supporting null [1] but the log4j2\nThreadContextMap API [2] doesn't specify the behavior for null keys. It\nis possible direct usage of ThreadContextMap API may assume null values\nare permitted as the default implemetnations support null values.\n\n[1] https://www.javadoc.io/doc/org.slf4j/slf4j-api/1.7.30/org/slf4j/MDC.html#put-java.lang.String-java.lang.String-\n[2] https://logging.apache.org/log4j/2.x/log4j-api/apidocs/org/apache/logging/log4j/spi/ThreadContextMap.html#put-java.lang.String-java.lang.String-\n\nModifications:\n- Modify ServiceTalkThreadContextMap and\nServiceTalkTracingThreadContextMap to support null values\n\nResult:\nServiceTalkThreadContextMap permits null values", "committedDate": "2020-06-10T03:39:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0MzIzNg==", "url": "https://github.com/apple/servicetalk/pull/1084#discussion_r437843236", "bodyText": "@NiteshKant - note this is an API breaking change. The previous APIs leaked the underlying Map to avoid copy operations as an optimization. Now that the Map contains \"token\" elements that need to be unwrapped it leaks more knowledge and would require exposing the wrap/unwrap of null. I don't expect folks will be extending/calling these APIs so the risk is low, and it reduces our API footprint, at the cost of some breakage and less optimal implementation.", "author": "Scottmitch", "createdAt": "2020-06-10T03:45:26Z", "path": "servicetalk-opentracing-log4j2/src/main/java/io/servicetalk/opentracing/log4j2/ServiceTalkTracingThreadContextMap.java", "diffHunk": "@@ -132,116 +114,34 @@ public boolean isEmpty() {\n     }\n \n     @Override\n-    protected StringMap getReadOnlyContextData(Map<String, String> storage) {\n-        return new StringMap() {\n-            private static final long serialVersionUID = 6255838338202729246L;\n-\n-            @Override\n-            public void clear() {\n-                throw new UnsupportedOperationException();\n-            }\n-\n-            @Override\n-            public void freeze() {\n-            }\n-\n-            @Override\n-            public boolean isFrozen() {\n-                return true;\n-            }\n-\n-            @Override\n-            public void putAll(ReadOnlyStringMap source) {\n-                throw new UnsupportedOperationException();\n-            }\n-\n-            @Override\n-            public void putValue(String key, Object value) {\n-                throw new UnsupportedOperationException();\n-            }\n-\n-            @Override\n-            public void remove(String key) {\n-                throw new UnsupportedOperationException();\n-            }\n-\n-            @Override\n-            public Map<String, String> toMap() {\n-                return getCopy(storage, SCOPE_MANAGER.active());\n-            }\n-\n-            @Override\n-            public boolean containsKey(String key) {\n-                return containsTracingKey(key) || storage.containsKey(key);\n-            }\n-\n-            @SuppressWarnings(\"unchecked\")\n-            @Override\n-            public <V> void forEach(BiConsumer<String, ? super V> action) {\n-                InMemoryScope scope = SCOPE_MANAGER.active();\n-                if (scope != null) {\n-                    InMemorySpan span = scope.span();\n-                    action.accept(TRACE_ID_KEY, (V) span.traceIdHex());\n-                    action.accept(SPAN_ID_KEY, (V) span.spanIdHex());\n-                    action.accept(PARENT_SPAN_ID_KEY, (V) span.nonnullParentSpanIdHex());\n-                }\n-                storage.forEach((key, value) -> action.accept(key, (V) value));\n-            }\n-\n-            @SuppressWarnings(\"unchecked\")\n-            @Override\n-            public <V, S> void forEach(TriConsumer<String, ? super V, S> action, S state) {\n-                InMemoryScope scope = SCOPE_MANAGER.active();\n-                if (scope != null) {\n-                    InMemorySpan span = scope.span();\n-                    action.accept(TRACE_ID_KEY, (V) span.traceIdHex(), state);\n-                    action.accept(SPAN_ID_KEY, (V) span.spanIdHex(), state);\n-                    action.accept(PARENT_SPAN_ID_KEY, (V) span.nonnullParentSpanIdHex(), state);\n-                }\n-                storage.forEach((key, value) -> action.accept(key, (V) value, state));\n-            }\n-\n-            @SuppressWarnings(\"unchecked\")\n-            @Override\n-            public <V> V getValue(String key) {\n-                switch (key) {\n-                    case TRACE_ID_KEY: {\n-                        InMemoryScope scope = SCOPE_MANAGER.active();\n-                        if (scope != null) {\n-                            return (V) scope.span().traceIdHex();\n-                        }\n-                        break;\n-                    }\n-                    case SPAN_ID_KEY: {\n-                        InMemoryScope scope = SCOPE_MANAGER.active();\n-                        if (scope != null) {\n-                            return (V) scope.span().spanIdHex();\n-                        }\n-                        break;\n-                    }\n-                    case PARENT_SPAN_ID_KEY: {\n-                        InMemoryScope scope = SCOPE_MANAGER.active();\n-                        if (scope != null) {\n-                            return (V) scope.span().nonnullParentSpanIdHex();\n-                        }\n-                        break;\n-                    }\n-                    default:\n-                        break;\n-                }\n-                return (V) storage.get(key);\n-            }\n+    public StringMap getReadOnlyContextData() {\n+        StringMap map = new JdkMapAdapterStringMap(getCopy());", "originalCommit": "649ab59fdbd27a41e3f4aa5e086b40e8e765695b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2MjI4OA==", "url": "https://github.com/apple/servicetalk/pull/1084#discussion_r437862288", "bodyText": "Since MDC doesn't have a contains operator, why not just call remove(key) here? Is the concern that getCopyOfContextMap wouldn't show the null valued key?", "author": "colestanfield", "createdAt": "2020-06-10T05:06:06Z", "path": "servicetalk-log4j2-mdc-utils/src/main/java/io/servicetalk/log4j2/mdc/utils/ServiceTalkThreadContextMap.java", "diffHunk": "@@ -40,16 +39,18 @@\n  */\n public class ServiceTalkThreadContextMap implements ReadOnlyThreadContextMap, CleanableThreadContextMap {\n     private static final Key<Map<String, String>> key = Key.newKey(\"log4j2Mdc\");\n+    @SuppressWarnings(\"RedundantStringConstructorCall\")\n+    private static final String NULL_STRING = new String(\"\");\n \n     @Override\n     public final void put(String key, String value) {\n-        getStorage().put(key, value);\n+        getStorage().put(key, wrapNull(value));", "originalCommit": "649ab59fdbd27a41e3f4aa5e086b40e8e765695b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODIwMzc4Mw==", "url": "https://github.com/apple/servicetalk/pull/1084#discussion_r438203783", "bodyText": "I'm not sure I understand your suggestion, can you clarify?\nIn general if we don't put(..) (which will overrwrite the existing value associated with key) then the ThreadContextMap/MDC map-like API contracts won't be honored. Here are some methods that would be problematic:\n\ncontainsKey(key) wouldn't know if there was an entry or not\nisEmpty()\ngetCopy(), getImmutableMapOrNull(), getReadOnlyContextData() as you indicated may not return accurate Map contents", "author": "Scottmitch", "createdAt": "2020-06-10T15:16:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2MjI4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODIyMTczOA==", "url": "https://github.com/apple/servicetalk/pull/1084#discussion_r438221738", "bodyText": "I think @colestanfield is suggesting that consider put(\"foo\", null) as remove(\"foo\"). I think it is better to not make such inferences in the API as that will cause incompatibility b/w different implementations and is hard to reason about.", "author": "NiteshKant", "createdAt": "2020-06-10T15:39:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2MjI4OA=="}], "type": "inlineReview"}, {"oid": "2f2dc8211b5419c7e56758d305002bd214a8891d", "url": "https://github.com/apple/servicetalk/commit/2f2dc8211b5419c7e56758d305002bd214a8891d", "message": "Add suppressions.", "committedDate": "2020-06-10T17:15:07Z", "type": "commit"}]}