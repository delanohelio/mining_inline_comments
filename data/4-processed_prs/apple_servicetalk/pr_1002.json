{"pr_number": 1002, "pr_title": "`ProxyConnectConnectionFactoryFilter` leaks connection in case of errors", "pr_createdAt": "2020-04-04T00:34:52Z", "pr_url": "https://github.com/apple/servicetalk/pull/1002", "timeline": [{"oid": "8a9cf373192be94190236800d625369cc6a23f5d", "url": "https://github.com/apple/servicetalk/commit/8a9cf373192be94190236800d625369cc6a23f5d", "message": "`ProxyConnectConnectionFactoryFilter` leaks connection in case of errors\n\nMotivation:\n\nIn case of any error or cancellation, `ProxyConnectConnectionFactoryFilter`\ndoes not close the connection to the proxy.\n\nModifications:\n\n- Add tests to verify different failure scenarios for\n`ProxyConnectConnectionFactoryFilter`;\n- Close connection when `CONNECT` request or SSL handshake failures or\nif a `Single` is cancelled;\n\nResult:\n\n`ProxyConnectConnectionFactoryFilter` does not leak connections.", "committedDate": "2020-04-04T00:33:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY1NzQ5OQ==", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r403657499", "bodyText": "nit: looks like formatting is off...", "author": "normanmaurer", "createdAt": "2020-04-05T06:43:56Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/ProxyConnectConnectionFactoryFilter.java", "diffHunk": "@@ -100,28 +103,43 @@ public void userEventTriggered(final ChannelHandlerContext ctx, final Object evt\n                         }\n                     });\n \n-                    DeferSslHandler deferSslHandler = channel.pipeline().get(DeferSslHandler.class);\n+                    final DeferSslHandler deferSslHandler = channel.pipeline().get(DeferSslHandler.class);\n                     if (deferSslHandler == null) {\n-                        return response.payloadBodyAndTrailers().ignoreElements().concat(failed(\n-                                new IllegalStateException(\"Failed to find a handler of type \" +\n-                                        DeferSslHandler.class + \" in channel pipeline.\")));\n+                        return failed(new IllegalStateException(\"Failed to find a handler of type \" +\n+                                DeferSslHandler.class + \" in channel pipeline.\"));\n                     }\n-\n                     deferSslHandler.ready();\n \n-                    // There is no need to apply offloading explicitly (despite completing `processor` on the\n-                    // EventLoop) because `payloadBody()` will be offloaded according to the strategy for the\n-                    // request.\n-                    return response.payloadBodyAndTrailers().ignoreElements().concat(fromSource(processor));\n-                } else {\n-                    return response.payloadBodyAndTrailers().ignoreElements().concat(\n-                            failed(new ProxyResponseException(\"Bad response from proxy CONNECT \" + connectAddress,\n-                                    response.status())));\n-                }\n-            }));\n+                    return fromSource(processor);\n+                    // Close recently created connection in case of any error or cancellation while it connects to proxy\n+                 }).whenFinally(new TerminalSignalConsumer<C>() {\n+                    @Override\n+                    public void onSuccess(@Nullable final C result) {\n+                        // noop\n+                    }\n+\n+                    @Override\n+                    public void onError(final Throwable ignore) {\n+                        closeConnection(c);\n+                    }\n+\n+                    @Override\n+                    public void cancel() {\n+                        closeConnection(c);\n+                    }\n+                 });\n+            } catch (Exception e) {\n+                closeConnection(c);\n+                return failed(e);\n+            }\n+            });", "originalCommit": "8a9cf373192be94190236800d625369cc6a23f5d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg0MDM3NQ==", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r403840375", "bodyText": "Dangling subscribes are usually a bad idea. As this code is not composing the subscribe, if the returned Single from newConnection is cancelled, we will still keep consuming the response. Worse if the response does not complete, we will keep this subscribe around forever (and so the resources associated with the subscribe).\nWhat we were doing before, i.e. composing the response draining with the Single returned from this flatMap is the correct thing to do.", "author": "NiteshKant", "createdAt": "2020-04-06T05:39:59Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/ProxyConnectConnectionFactoryFilter.java", "diffHunk": "@@ -74,14 +70,21 @@ private ProxyFilter(final ConnectionFactory<ResolvedAddress, C> delegate) {\n \n         @Override\n         public Single<C> newConnection(final ResolvedAddress resolvedAddress) {\n-            return delegate().newConnection(resolvedAddress).flatMap(c ->\n+            return delegate().newConnection(resolvedAddress).flatMap(c -> {\n+            try {\n                 // We currently only have access to a StreamingHttpRequester, which means we are forced to provide an\n                 // HttpExecutionStrategy. Because we can't be sure if there is any blocking code in the connection\n                 // filters we use the default strategy which should offload everything to be safe.\n-                c.request(defaultStrategy(),\n-                            reqRespFactory.connect(connectAddress).addHeader(CONTENT_LENGTH, ZERO))\n+                return c.request(defaultStrategy(), c.connect(connectAddress).addHeader(CONTENT_LENGTH, ZERO))\n                  .flatMap(response -> {\n-                if (SUCCESSFUL_2XX.contains(response.status())) {\n+                    // Drain response payload body asynchronously as we are not interested in it:\n+                    response.payloadBodyAndTrailers().ignoreElements().subscribe();", "originalCommit": "8a9cf373192be94190236800d625369cc6a23f5d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg0MTI3NQ==", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r403841275", "bodyText": "Same as above, we should not be doing dangling subscribes, instead compose connection closure with error response.\nCancel path will be an exception to this rule as cancels are not composable.", "author": "NiteshKant", "createdAt": "2020-04-06T05:43:19Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/ProxyConnectConnectionFactoryFilter.java", "diffHunk": "@@ -100,28 +103,43 @@ public void userEventTriggered(final ChannelHandlerContext ctx, final Object evt\n                         }\n                     });\n \n-                    DeferSslHandler deferSslHandler = channel.pipeline().get(DeferSslHandler.class);\n+                    final DeferSslHandler deferSslHandler = channel.pipeline().get(DeferSslHandler.class);\n                     if (deferSslHandler == null) {\n-                        return response.payloadBodyAndTrailers().ignoreElements().concat(failed(\n-                                new IllegalStateException(\"Failed to find a handler of type \" +\n-                                        DeferSslHandler.class + \" in channel pipeline.\")));\n+                        return failed(new IllegalStateException(\"Failed to find a handler of type \" +\n+                                DeferSslHandler.class + \" in channel pipeline.\"));\n                     }\n-\n                     deferSslHandler.ready();\n \n-                    // There is no need to apply offloading explicitly (despite completing `processor` on the\n-                    // EventLoop) because `payloadBody()` will be offloaded according to the strategy for the\n-                    // request.\n-                    return response.payloadBodyAndTrailers().ignoreElements().concat(fromSource(processor));\n-                } else {\n-                    return response.payloadBodyAndTrailers().ignoreElements().concat(\n-                            failed(new ProxyResponseException(\"Bad response from proxy CONNECT \" + connectAddress,\n-                                    response.status())));\n-                }\n-            }));\n+                    return fromSource(processor);\n+                    // Close recently created connection in case of any error or cancellation while it connects to proxy\n+                 }).whenFinally(new TerminalSignalConsumer<C>() {\n+                    @Override\n+                    public void onSuccess(@Nullable final C result) {\n+                        // noop\n+                    }\n+\n+                    @Override\n+                    public void onError(final Throwable ignore) {\n+                        closeConnection(c);\n+                    }\n+\n+                    @Override\n+                    public void cancel() {\n+                        closeConnection(c);\n+                    }\n+                 });\n+            } catch (Exception e) {\n+                closeConnection(c);\n+                return failed(e);\n+            }\n+            });\n         }\n     }\n \n+    private static <C extends FilterableStreamingHttpConnection> void closeConnection(C connection) {\n+        connection.closeAsync().subscribe();", "originalCommit": "8a9cf373192be94190236800d625369cc6a23f5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ1NjE4OQ==", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r404456189", "bodyText": "Good catch! Two questions:\n\nIf we concat with failed Single, there is a chance that connection.closeAsync() may also fail. Should we worry about handling that case and adding the original exception as a suppressed one for the failed closure?\nShould we make the same change for RRLB as a follow-up? Currently, we just subscribe to closeAsync and return an exception. For example: \n  \n    \n      servicetalk/servicetalk-loadbalancer/src/main/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancer.java\n    \n    \n        Lines 279 to 285\n      in\n      52532d4\n    \n    \n    \n    \n\n        \n          \n           if (!selector.test(newCnx)) { \n        \n\n        \n          \n               newCnx.closeAsync().subscribe(); \n        \n\n        \n          \n               // Failure in selection could be temporary, hence add it to the queue and be consistent with the \n        \n\n        \n          \n               // fact that select failure does not close a connection. \n        \n\n        \n          \n               return failed(new ConnectionRejectedException(\"Newly created connection \" + newCnx + \n        \n\n        \n          \n                       \" rejected by the selection filter.\")); \n        \n\n        \n          \n           }", "author": "idelpivnitskiy", "createdAt": "2020-04-06T23:52:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg0MTI3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ3NjQ5OQ==", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r404476499", "bodyText": "A1: As closeAsync() is idempotent and not expected to fail I will avoid handling that case and make the control flow complex here.\nA2: Good catch, yes please do a follow-up", "author": "NiteshKant", "createdAt": "2020-04-07T01:01:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg0MTI3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUzNzYwOQ==", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r404537609", "bodyText": "Follow-up for RRLB: #1006", "author": "idelpivnitskiy", "createdAt": "2020-04-07T05:06:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg0MTI3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg0MjE3Mg==", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r403842172", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } catch (Exception e) {\n          \n          \n            \n                        } catch (Throwable t) {", "author": "NiteshKant", "createdAt": "2020-04-06T05:46:47Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/ProxyConnectConnectionFactoryFilter.java", "diffHunk": "@@ -100,28 +103,43 @@ public void userEventTriggered(final ChannelHandlerContext ctx, final Object evt\n                         }\n                     });\n \n-                    DeferSslHandler deferSslHandler = channel.pipeline().get(DeferSslHandler.class);\n+                    final DeferSslHandler deferSslHandler = channel.pipeline().get(DeferSslHandler.class);\n                     if (deferSslHandler == null) {\n-                        return response.payloadBodyAndTrailers().ignoreElements().concat(failed(\n-                                new IllegalStateException(\"Failed to find a handler of type \" +\n-                                        DeferSslHandler.class + \" in channel pipeline.\")));\n+                        return failed(new IllegalStateException(\"Failed to find a handler of type \" +\n+                                DeferSslHandler.class + \" in channel pipeline.\"));\n                     }\n-\n                     deferSslHandler.ready();\n \n-                    // There is no need to apply offloading explicitly (despite completing `processor` on the\n-                    // EventLoop) because `payloadBody()` will be offloaded according to the strategy for the\n-                    // request.\n-                    return response.payloadBodyAndTrailers().ignoreElements().concat(fromSource(processor));\n-                } else {\n-                    return response.payloadBodyAndTrailers().ignoreElements().concat(\n-                            failed(new ProxyResponseException(\"Bad response from proxy CONNECT \" + connectAddress,\n-                                    response.status())));\n-                }\n-            }));\n+                    return fromSource(processor);\n+                    // Close recently created connection in case of any error or cancellation while it connects to proxy\n+                 }).whenFinally(new TerminalSignalConsumer<C>() {\n+                    @Override\n+                    public void onSuccess(@Nullable final C result) {\n+                        // noop\n+                    }\n+\n+                    @Override\n+                    public void onError(final Throwable ignore) {\n+                        closeConnection(c);\n+                    }\n+\n+                    @Override\n+                    public void cancel() {\n+                        closeConnection(c);\n+                    }\n+                 });\n+            } catch (Exception e) {", "originalCommit": "8a9cf373192be94190236800d625369cc6a23f5d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg0NDgwMA==", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r403844800", "bodyText": "It seems cancel path may leak connection in general if the connection got emitted from here but the source got cancelled afterwards. eg: any operator added after this proxy filter may not send the connection further if it sees a cancel().", "author": "NiteshKant", "createdAt": "2020-04-06T05:56:09Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/ProxyConnectConnectionFactoryFilter.java", "diffHunk": "@@ -100,28 +103,43 @@ public void userEventTriggered(final ChannelHandlerContext ctx, final Object evt\n                         }\n                     });\n \n-                    DeferSslHandler deferSslHandler = channel.pipeline().get(DeferSslHandler.class);\n+                    final DeferSslHandler deferSslHandler = channel.pipeline().get(DeferSslHandler.class);\n                     if (deferSslHandler == null) {\n-                        return response.payloadBodyAndTrailers().ignoreElements().concat(failed(\n-                                new IllegalStateException(\"Failed to find a handler of type \" +\n-                                        DeferSslHandler.class + \" in channel pipeline.\")));\n+                        return failed(new IllegalStateException(\"Failed to find a handler of type \" +\n+                                DeferSslHandler.class + \" in channel pipeline.\"));\n                     }\n-\n                     deferSslHandler.ready();\n \n-                    // There is no need to apply offloading explicitly (despite completing `processor` on the\n-                    // EventLoop) because `payloadBody()` will be offloaded according to the strategy for the\n-                    // request.\n-                    return response.payloadBodyAndTrailers().ignoreElements().concat(fromSource(processor));\n-                } else {\n-                    return response.payloadBodyAndTrailers().ignoreElements().concat(\n-                            failed(new ProxyResponseException(\"Bad response from proxy CONNECT \" + connectAddress,\n-                                    response.status())));\n-                }\n-            }));\n+                    return fromSource(processor);\n+                    // Close recently created connection in case of any error or cancellation while it connects to proxy\n+                 }).whenFinally(new TerminalSignalConsumer<C>() {\n+                    @Override\n+                    public void onSuccess(@Nullable final C result) {\n+                        // noop\n+                    }\n+\n+                    @Override\n+                    public void onError(final Throwable ignore) {\n+                        closeConnection(c);\n+                    }\n+\n+                    @Override\n+                    public void cancel() {\n+                        closeConnection(c);", "originalCommit": "8a9cf373192be94190236800d625369cc6a23f5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ1MDkwNw==", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r404450907", "bodyText": "Interesting observation. I was focused only on cancel handling before onSuccess. For example, before the handshake completes: https://github.com/apple/servicetalk/pull/1002/files#diff-09ab1790ede42935bdec34cd0d96560cR234-R251\nWill you suggest to use whenCancel operator and always close the connection on cancellation? Because close is idempotent it should not matter if this connection is already closed by someone else. Is there any use-case when the connection is still useful after cancel?", "author": "idelpivnitskiy", "createdAt": "2020-04-06T23:36:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg0NDgwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ3NDkzOQ==", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r404474939", "bodyText": "This is a more broader problem and it can not be handled specifically in this class. As cancel()s can come after a success, we really do not know if the cancel has come due to the operation was cancelled by the user or due to some operators sending a cancel for the previous source when they move on to the next source (eg: concat()).\nI commented here to highlight the problem but this PR does not have to be blocked for this change. What you have here is sufficient in isolation for this class.", "author": "NiteshKant", "createdAt": "2020-04-07T00:55:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg0NDgwMA=="}], "type": "inlineReview"}, {"oid": "a0cd7b8ff1c1f6c96fa18b9c2f2dd3098409b9cf", "url": "https://github.com/apple/servicetalk/commit/a0cd7b8ff1c1f6c96fa18b9c2f2dd3098409b9cf", "message": "Address comments", "committedDate": "2020-04-07T04:40:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUzODU0NA==", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r404538544", "bodyText": "we really do not know if the cancel has come due to the operation was canceled by the user or due to some operators sending a cancel for the previous source when they move on to the next source (eg: concat()).\n\nCan any operator cancel after success? IIUC they cancel the previous source only for non-success/non-complete cases.\nLMK if I need to revert whenFinally here to prevent closure on cancel after success.", "author": "idelpivnitskiy", "createdAt": "2020-04-07T05:10:19Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/ProxyConnectConnectionFactoryFilter.java", "diffHunk": "@@ -74,51 +68,63 @@ private ProxyFilter(final ConnectionFactory<ResolvedAddress, C> delegate) {\n \n         @Override\n         public Single<C> newConnection(final ResolvedAddress resolvedAddress) {\n-            return delegate().newConnection(resolvedAddress).flatMap(c ->\n-                // We currently only have access to a StreamingHttpRequester, which means we are forced to provide an\n-                // HttpExecutionStrategy. Because we can't be sure if there is any blocking code in the connection\n-                // filters we use the default strategy which should offload everything to be safe.\n-                c.request(defaultStrategy(),\n-                            reqRespFactory.connect(connectAddress).addHeader(CONTENT_LENGTH, ZERO))\n-                 .flatMap(response -> {\n-                if (SUCCESSFUL_2XX.contains(response.status())) {\n-                    final Channel channel = ((NettyConnectionContext) c.connectionContext()).nettyChannel();\n-                    final SingleSource.Processor<C, C> processor = newSingleProcessor();\n+            return delegate().newConnection(resolvedAddress).flatMap(c -> {\n+                try {\n+                    // We currently only have access to a StreamingHttpRequester, which means we are forced to provide\n+                    // an HttpExecutionStrategy. Because we can't be sure if there is any blocking code in the\n+                    // connection filters we use the default strategy which should offload everything to be safe.\n+                    return c.request(defaultStrategy(), c.connect(connectAddress).addHeader(CONTENT_LENGTH, ZERO))\n+                            .flatMap(response -> handleConnectResponse(c, response))\n+                            // Close recently created connection in case of any error while it connects to the proxy\n+                            // or cancellation:\n+                            .recoverWith(t -> c.closeAsync().concat(failed(t)))\n+                            .whenCancel(() -> c.closeAsync().subscribe());", "originalCommit": "a0cd7b8ff1c1f6c96fa18b9c2f2dd3098409b9cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkzMTU3OA==", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r404931578", "bodyText": "Can any operator cancel after success?\n\nYes they do, consider this connFactory.newConnection().concat(executor.timer(1, MILLISECONDS) (eg: to add a delay to respond to connect)\nconcat() uses SequentialCancellable which cancels the old Cancellable when the new Cancellable is received, which in this case will be after the successful completion of connFactory.newConnection().\nMore generally, we should not assume anywhere that cancel is only received before success() as Cancellable and Subscriber code paths are concurrent.", "author": "NiteshKant", "createdAt": "2020-04-07T16:08:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUzODU0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTAwNTAzNA==", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r405005034", "bodyText": "Looking at SequentialCancellable and TBH don't see where it cancels the old Cancellable. When the new Cancellable is received it may close the new one immediately if the oldVal was already canceled via SequentialCancellable#cancel().\n\nMore generally, we should not assume anywhere that cancel is only received before success() as Cancellable and Subscriber code paths are concurrent.\n\nAgreed. I just thought that it doesn't matter when proxy filter sees cancel: before or after onSuccess we should close the connection if we saw that someone is not interested in the result anymore.\nBtw, after #1005, should it be afterCancel or afterFinally?", "author": "idelpivnitskiy", "createdAt": "2020-04-07T17:58:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUzODU0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE2NDQxNw==", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r405164417", "bodyText": "whenCancel will unconditionally execute the callback when cancel is called regardless if the connection has been delivered downstream. If we have already delivered the connection we shouldn't later close it (regardless if someone cancels or not). In addition to this being the expected control flow, the RS spec has some rules which discuss cancel being a no-op after a terminal signal is delivered [1][2].\nafterFinally(SingleTerminalSignalConsumer<T> doFinally) happens to enforce \"only a single callback will be executed\" but may still result in invoking the onCancel() call back and also calling the downstream Subscriber#onSuccess(...) for the following reasons:\n\nSubscription can be invoked on a different thread\nData/terminal signals may still be delivered after cancel [3]\n\nSo afterFinally is an improvement over afterCancel, but still isn't ideal because we may deliver a closed object (and/or invoke closeAsync() concurrently).\n[1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#1.6\n\nIf a Publisher signals either onError or onComplete on a Subscriber, that Subscriber\u2019s Subscription MUST be considered cancelled.\n\n[2] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#3.7\n\nAfter the Subscription is cancelled, additional Subscription.cancel() MUST be NOPs.\n\n[3] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#2.8\n\nA Subscriber MUST be prepared to receive one or more onNext signals after having called Subscription.cancel() if there are still requested elements pending [see 3.12]. Subscription.cancel() does not guarantee to perform the underlying cleaning operations immediately.", "author": "Scottmitch", "createdAt": "2020-04-07T23:05:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUzODU0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE4MzU2Mg==", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r405183562", "bodyText": "TBH don't see where it cancels the old Cancellable.\n\n\nAah, you are correct. I misread under an older assumption that we cancel() the previous Cancellable.\nAnyways, for other reasons me and Scott mention, unconditional close() upon cancel() isn't correct.", "author": "NiteshKant", "createdAt": "2020-04-08T00:04:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUzODU0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE4MzkzMA==", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r405183930", "bodyText": "Updated to use whenFinally d2bf22f afterFinally cfd0117", "author": "idelpivnitskiy", "createdAt": "2020-04-08T00:06:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUzODU0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0MzUzMQ==", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r405643531", "bodyText": "So afterFinally is an improvement over afterCancel, but still isn't ideal because we may deliver a closed object (and/or invoke closeAsync() concurrently).\n\nOk ya this seems to be a problem. Can we remove the close-on-cancel part for now?\nConnection lifetime is anyways a problem in such situation out of the context of this filter as mentioned in #1002 (comment).\nLets fix the obvious issue of leaking connection for non-200 responses and then handle lifecycle on cancel/early termination later.", "author": "NiteshKant", "createdAt": "2020-04-08T16:11:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUzODU0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTgwNTc5MA==", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r405805790", "bodyText": "Removed in 57e470b and created #1010.", "author": "idelpivnitskiy", "createdAt": "2020-04-08T20:49:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUzODU0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUzOTExMA==", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r404539110", "bodyText": "Moved this logic to the different method because nested try blocks make code indentation awful.", "author": "idelpivnitskiy", "createdAt": "2020-04-07T05:12:33Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/ProxyConnectConnectionFactoryFilter.java", "diffHunk": "@@ -74,51 +68,63 @@ private ProxyFilter(final ConnectionFactory<ResolvedAddress, C> delegate) {\n \n         @Override\n         public Single<C> newConnection(final ResolvedAddress resolvedAddress) {\n-            return delegate().newConnection(resolvedAddress).flatMap(c ->\n-                // We currently only have access to a StreamingHttpRequester, which means we are forced to provide an\n-                // HttpExecutionStrategy. Because we can't be sure if there is any blocking code in the connection\n-                // filters we use the default strategy which should offload everything to be safe.\n-                c.request(defaultStrategy(),\n-                            reqRespFactory.connect(connectAddress).addHeader(CONTENT_LENGTH, ZERO))\n-                 .flatMap(response -> {\n-                if (SUCCESSFUL_2XX.contains(response.status())) {\n-                    final Channel channel = ((NettyConnectionContext) c.connectionContext()).nettyChannel();\n-                    final SingleSource.Processor<C, C> processor = newSingleProcessor();\n+            return delegate().newConnection(resolvedAddress).flatMap(c -> {\n+                try {\n+                    // We currently only have access to a StreamingHttpRequester, which means we are forced to provide\n+                    // an HttpExecutionStrategy. Because we can't be sure if there is any blocking code in the\n+                    // connection filters we use the default strategy which should offload everything to be safe.\n+                    return c.request(defaultStrategy(), c.connect(connectAddress).addHeader(CONTENT_LENGTH, ZERO))\n+                            .flatMap(response -> handleConnectResponse(c, response))\n+                            // Close recently created connection in case of any error while it connects to the proxy\n+                            // or cancellation:\n+                            .recoverWith(t -> c.closeAsync().concat(failed(t)))\n+                            .whenCancel(() -> c.closeAsync().subscribe());\n+                } catch (Throwable t) {\n+                    return c.closeAsync().concat(failed(t));\n+                }\n+            });\n+        }\n+    }\n \n-                    channel.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n-                        @Override\n-                        public void userEventTriggered(final ChannelHandlerContext ctx, final Object evt) {\n-                            if (evt instanceof SslHandshakeCompletionEvent) {\n-                                SslHandshakeCompletionEvent event = (SslHandshakeCompletionEvent) evt;\n-                                if (event.isSuccess()) {\n-                                    processor.onSuccess(c);\n-                                } else {\n-                                    processor.onError(event.cause());\n-                                }\n-                            }\n-                            ctx.fireUserEventTriggered(evt);\n-                        }\n-                    });\n+    private Single<C> handleConnectResponse(final C connection, final StreamingHttpResponse response) {\n+        try {", "originalCommit": "a0cd7b8ff1c1f6c96fa18b9c2f2dd3098409b9cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE2NzA3MQ==", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r405167071", "bodyText": "this could lead to unnecessary resource (CPU, memory, network, etc...) consumption if we continuously read data that we don't care about (potential DOS vector). Can you clarify why this is necessary when we are hard-closing the connection?", "author": "Scottmitch", "createdAt": "2020-04-07T23:12:57Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/ProxyConnectConnectionFactoryFilter.java", "diffHunk": "@@ -74,51 +68,63 @@ private ProxyFilter(final ConnectionFactory<ResolvedAddress, C> delegate) {\n \n         @Override\n         public Single<C> newConnection(final ResolvedAddress resolvedAddress) {\n-            return delegate().newConnection(resolvedAddress).flatMap(c ->\n-                // We currently only have access to a StreamingHttpRequester, which means we are forced to provide an\n-                // HttpExecutionStrategy. Because we can't be sure if there is any blocking code in the connection\n-                // filters we use the default strategy which should offload everything to be safe.\n-                c.request(defaultStrategy(),\n-                            reqRespFactory.connect(connectAddress).addHeader(CONTENT_LENGTH, ZERO))\n-                 .flatMap(response -> {\n-                if (SUCCESSFUL_2XX.contains(response.status())) {\n-                    final Channel channel = ((NettyConnectionContext) c.connectionContext()).nettyChannel();\n-                    final SingleSource.Processor<C, C> processor = newSingleProcessor();\n+            return delegate().newConnection(resolvedAddress).flatMap(c -> {\n+                try {\n+                    // We currently only have access to a StreamingHttpRequester, which means we are forced to provide\n+                    // an HttpExecutionStrategy. Because we can't be sure if there is any blocking code in the\n+                    // connection filters we use the default strategy which should offload everything to be safe.\n+                    return c.request(defaultStrategy(), c.connect(connectAddress).addHeader(CONTENT_LENGTH, ZERO))\n+                            .flatMap(response -> handleConnectResponse(c, response))\n+                            // Close recently created connection in case of any error while it connects to the proxy\n+                            // or cancellation:\n+                            .recoverWith(t -> c.closeAsync().concat(failed(t)))\n+                            .whenCancel(() -> c.closeAsync().subscribe());\n+                } catch (Throwable t) {\n+                    return c.closeAsync().concat(failed(t));\n+                }\n+            });\n+        }\n+    }\n \n-                    channel.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n-                        @Override\n-                        public void userEventTriggered(final ChannelHandlerContext ctx, final Object evt) {\n-                            if (evt instanceof SslHandshakeCompletionEvent) {\n-                                SslHandshakeCompletionEvent event = (SslHandshakeCompletionEvent) evt;\n-                                if (event.isSuccess()) {\n-                                    processor.onSuccess(c);\n-                                } else {\n-                                    processor.onError(event.cause());\n-                                }\n-                            }\n-                            ctx.fireUserEventTriggered(evt);\n-                        }\n-                    });\n+    private Single<C> handleConnectResponse(final C connection, final StreamingHttpResponse response) {\n+        try {\n+            if (response.status().statusClass() != SUCCESSFUL_2XX) {\n+                return response.payloadBodyAndTrailers().ignoreElements().concat(failed(", "originalCommit": "a0cd7b8ff1c1f6c96fa18b9c2f2dd3098409b9cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE4MzAwNg==", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r405183006", "bodyText": "Good catch!\nI thought about this while was working on this PR. But because it was deferred until after #990 is merged I forgot to ask about it. Fixed.", "author": "idelpivnitskiy", "createdAt": "2020-04-08T00:02:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE2NzA3MQ=="}], "type": "inlineReview"}, {"oid": "685900e9234a7a2848425896b62e9ce90565f30a", "url": "https://github.com/apple/servicetalk/commit/685900e9234a7a2848425896b62e9ce90565f30a", "message": "Merge remote-tracking branch 'upstream/master' into proxy-close-connection", "committedDate": "2020-04-07T23:37:17Z", "type": "commit"}, {"oid": "d2bf22f6b3dd9d9f8a82a7193fd159b4ca069d50", "url": "https://github.com/apple/servicetalk/commit/d2bf22f6b3dd9d9f8a82a7193fd159b4ca069d50", "message": "Use whenFinally to prevent handling cancel event after termination", "committedDate": "2020-04-07T23:50:13Z", "type": "commit"}, {"oid": "083347de4ffd0e52bef4a5c573008827a67cc07e", "url": "https://github.com/apple/servicetalk/commit/083347de4ffd0e52bef4a5c573008827a67cc07e", "message": "Do not drain payload body in case of error", "committedDate": "2020-04-07T23:50:37Z", "type": "commit"}, {"oid": "cfd01174f02340fc92b0adb892e2d98e0e7d778f", "url": "https://github.com/apple/servicetalk/commit/cfd01174f02340fc92b0adb892e2d98e0e7d778f", "message": "Change whenFinally to afterFinally", "committedDate": "2020-04-08T00:07:53Z", "type": "commit"}, {"oid": "57e470b5307862d543c41e8274b3fc5ee634cfa7", "url": "https://github.com/apple/servicetalk/commit/57e470b5307862d543c41e8274b3fc5ee634cfa7", "message": "Remove close-on-cancel", "committedDate": "2020-04-08T20:48:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg2MDY5MA==", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r405860690", "bodyText": "This try-catch isn't required as it is called from the flatMap which has a recoverWith, so if anything does throw from here, flatMap will correctly terminate the control flow with the same error which will then be intercepted by recoverWith() closing the connection.", "author": "NiteshKant", "createdAt": "2020-04-08T22:54:36Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/ProxyConnectConnectionFactoryFilter.java", "diffHunk": "@@ -74,51 +68,59 @@ private ProxyFilter(final ConnectionFactory<ResolvedAddress, C> delegate) {\n \n         @Override\n         public Single<C> newConnection(final ResolvedAddress resolvedAddress) {\n-            return delegate().newConnection(resolvedAddress).flatMap(c ->\n-                // We currently only have access to a StreamingHttpRequester, which means we are forced to provide an\n-                // HttpExecutionStrategy. Because we can't be sure if there is any blocking code in the connection\n-                // filters we use the default strategy which should offload everything to be safe.\n-                c.request(defaultStrategy(),\n-                            reqRespFactory.connect(connectAddress).addHeader(CONTENT_LENGTH, ZERO))\n-                 .flatMap(response -> {\n-                if (SUCCESSFUL_2XX.contains(response.status())) {\n-                    final Channel channel = ((NettyConnectionContext) c.connectionContext()).nettyChannel();\n-                    final SingleSource.Processor<C, C> processor = newSingleProcessor();\n+            return delegate().newConnection(resolvedAddress).flatMap(c -> {\n+                try {\n+                    // We currently only have access to a StreamingHttpRequester, which means we are forced to provide\n+                    // an HttpExecutionStrategy. Because we can't be sure if there is any blocking code in the\n+                    // connection filters we use the default strategy which should offload everything to be safe.\n+                    return c.request(defaultStrategy(), c.connect(connectAddress).addHeader(CONTENT_LENGTH, ZERO))\n+                            .flatMap(response -> handleConnectResponse(c, response))\n+                            // Close recently created connection in case of any error while it connects to the proxy:\n+                            .recoverWith(t -> c.closeAsync().concat(failed(t)));\n+                } catch (Throwable t) {\n+                    return c.closeAsync().concat(failed(t));\n+                }\n+            });\n+        }\n+    }\n \n-                    channel.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n-                        @Override\n-                        public void userEventTriggered(final ChannelHandlerContext ctx, final Object evt) {\n-                            if (evt instanceof SslHandshakeCompletionEvent) {\n-                                SslHandshakeCompletionEvent event = (SslHandshakeCompletionEvent) evt;\n-                                if (event.isSuccess()) {\n-                                    processor.onSuccess(c);\n-                                } else {\n-                                    processor.onError(event.cause());\n-                                }\n-                            }\n-                            ctx.fireUserEventTriggered(evt);\n-                        }\n-                    });\n+    private Single<C> handleConnectResponse(final C connection, final StreamingHttpResponse response) {\n+        try {\n+            if (response.status().statusClass() != SUCCESSFUL_2XX) {\n+                return failed(new ProxyResponseException(\"Non-successful response from proxy CONNECT \" +\n+                        connectAddress, response.status()));\n+            }\n \n-                    DeferSslHandler deferSslHandler = channel.pipeline().get(DeferSslHandler.class);\n-                    if (deferSslHandler == null) {\n-                        return response.payloadBodyAndTrailers().ignoreElements().concat(failed(\n-                                new IllegalStateException(\"Failed to find a handler of type \" +\n-                                        DeferSslHandler.class + \" in channel pipeline.\")));\n+            final Channel channel = ((NettyConnectionContext) connection.connectionContext()).nettyChannel();\n+            final SingleSource.Processor<C, C> processor = newSingleProcessor();\n+            channel.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n+                @Override\n+                public void userEventTriggered(final ChannelHandlerContext ctx, final Object evt) {\n+                    if (evt instanceof SslHandshakeCompletionEvent) {\n+                        SslHandshakeCompletionEvent event = (SslHandshakeCompletionEvent) evt;\n+                        if (event.isSuccess()) {\n+                            processor.onSuccess(connection);\n+                        } else {\n+                            processor.onError(event.cause());\n+                        }\n                     }\n+                    ctx.fireUserEventTriggered(evt);\n+                }\n+            });\n \n-                    deferSslHandler.ready();\n+            final DeferSslHandler deferSslHandler = channel.pipeline().get(DeferSslHandler.class);\n+            if (deferSslHandler == null) {\n+                return failed(new IllegalStateException(\"Failed to find a handler of type \" +\n+                        DeferSslHandler.class + \" in channel pipeline.\"));\n+            }\n+            deferSslHandler.ready();\n \n-                    // There is no need to apply offloading explicitly (despite completing `processor` on the\n-                    // EventLoop) because `payloadBody()` will be offloaded according to the strategy for the\n-                    // request.\n-                    return response.payloadBodyAndTrailers().ignoreElements().concat(fromSource(processor));\n-                } else {\n-                    return response.payloadBodyAndTrailers().ignoreElements().concat(\n-                            failed(new ProxyResponseException(\"Bad response from proxy CONNECT \" + connectAddress,\n-                                    response.status())));\n-                }\n-            }));\n+            // There is no need to apply offloading explicitly (despite completing `processor` on the\n+            // EventLoop) because `payloadBody()` will be offloaded according to the strategy for the\n+            // request.\n+            return response.payloadBodyAndTrailers().ignoreElements().concat(fromSource(processor));\n+        } catch (Throwable t) {", "originalCommit": "57e470b5307862d543c41e8274b3fc5ee634cfa7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg2MTYyNg==", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r405861626", "bodyText": "I think we are being overly paranoid here about the calls to c.request() or c.connect() throwing. Any method returning an asynchronous source is not expected to throw. Having said that it is not a big deal so its ok as it is, I will leave it to you to take a call on this.", "author": "NiteshKant", "createdAt": "2020-04-08T22:57:14Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/ProxyConnectConnectionFactoryFilter.java", "diffHunk": "@@ -74,51 +68,59 @@ private ProxyFilter(final ConnectionFactory<ResolvedAddress, C> delegate) {\n \n         @Override\n         public Single<C> newConnection(final ResolvedAddress resolvedAddress) {\n-            return delegate().newConnection(resolvedAddress).flatMap(c ->\n-                // We currently only have access to a StreamingHttpRequester, which means we are forced to provide an\n-                // HttpExecutionStrategy. Because we can't be sure if there is any blocking code in the connection\n-                // filters we use the default strategy which should offload everything to be safe.\n-                c.request(defaultStrategy(),\n-                            reqRespFactory.connect(connectAddress).addHeader(CONTENT_LENGTH, ZERO))\n-                 .flatMap(response -> {\n-                if (SUCCESSFUL_2XX.contains(response.status())) {\n-                    final Channel channel = ((NettyConnectionContext) c.connectionContext()).nettyChannel();\n-                    final SingleSource.Processor<C, C> processor = newSingleProcessor();\n+            return delegate().newConnection(resolvedAddress).flatMap(c -> {\n+                try {\n+                    // We currently only have access to a StreamingHttpRequester, which means we are forced to provide\n+                    // an HttpExecutionStrategy. Because we can't be sure if there is any blocking code in the\n+                    // connection filters we use the default strategy which should offload everything to be safe.\n+                    return c.request(defaultStrategy(), c.connect(connectAddress).addHeader(CONTENT_LENGTH, ZERO))\n+                            .flatMap(response -> handleConnectResponse(c, response))\n+                            // Close recently created connection in case of any error while it connects to the proxy:\n+                            .recoverWith(t -> c.closeAsync().concat(failed(t)));\n+                } catch (Throwable t) {", "originalCommit": "57e470b5307862d543c41e8274b3fc5ee634cfa7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0144018d9bed65c5d358f725665005545255893e", "url": "https://github.com/apple/servicetalk/commit/0144018d9bed65c5d358f725665005545255893e", "message": "Remove unnecessary try-catch", "committedDate": "2020-04-08T23:09:05Z", "type": "commit"}, {"oid": "12cbd4c2998bc5590fff03591c919454e4ac3905", "url": "https://github.com/apple/servicetalk/commit/12cbd4c2998bc5590fff03591c919454e4ac3905", "message": "Move handleConnectResponse inside ProxyFilter", "committedDate": "2020-04-08T23:14:45Z", "type": "commit"}]}