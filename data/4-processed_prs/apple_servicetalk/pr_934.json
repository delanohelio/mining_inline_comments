{"pr_number": 934, "pr_title": "gRPC-client should fail responses without grpc-status code", "pr_createdAt": "2020-02-07T01:53:58Z", "pr_url": "https://github.com/apple/servicetalk/pull/934", "timeline": [{"oid": "1f25afb8e4b007c694cc1bbdc66b3f508134df67", "url": "https://github.com/apple/servicetalk/commit/1f25afb8e4b007c694cc1bbdc66b3f508134df67", "message": "gRPC-client should fail responses without grpc-status code\n\nMotivation:\n\ngRPC protocol requires server to send grpc-status code as part\nof the response. It may come in headers (when there is no\npayload body) or in trailers. Current implementation considers\nresponses without `grpc-status` as legit responses.\n\nModifications:\n\n- Ensure that the response object contains `grpc-status` code;\n- Tests to verify that client throws an exception when server\ndoes not send `grpc-status`;\n\nResult:\n\ngRPC-client throws an exception when server does not send\n`grpc-status`.", "committedDate": "2020-02-07T01:52:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE3OTg5Mg==", "url": "https://github.com/apple/servicetalk/pull/934#discussion_r376179892", "bodyText": "This helps to catch the case when server does not send trailers at all.\nIn this case payloadBodyAndTrailers() returns only Buffers. transformRaw helps to create empty trailers and catch that there is no grpc-status.\nI did not add a comment here, because the test will fail if this changes, but I can add it if it will be useful.", "author": "idelpivnitskiy", "createdAt": "2020-02-07T01:58:47Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcUtils.java", "diffHunk": "@@ -138,50 +150,56 @@ static void setStatus(final HttpHeaders trailers, final Throwable cause, final B\n \n     static <Resp> Publisher<Resp> validateResponseAndGetPayload(final StreamingHttpResponse response,\n                                                                 final HttpDeserializer<Resp> deserializer) {\n-        // In case of server error, gRPC may return only one HEADER frame with endStream=true. Our\n-        // HTTP1-based implementation translates them into response headers so we need to look for\n-        // the status in both headers and trailers. Since this is streaming response and we have the headers now, we\n-        // check for error here first. If we see trailers later in payloadBodyAndTrailers(), we will check for error\n-        // there.\n-        final HttpHeaders respHeaders = response.headers();\n-        GrpcStatusException grpcStatusException = extractGrpcExceptionFromHeaders(respHeaders);\n-        if (grpcStatusException != null) {\n-            return Publisher.failed(grpcStatusException);\n+        // In case of an empty response, gRPC-server may return only one HEADER frame with endStream=true. Our\n+        // HTTP1-based implementation translates them into response headers so we need to look for a grpc-status in both\n+        // headers and trailers. Since this is streaming response and we have the headers now, we check for the\n+        // grpc-status here first. If there is no grpc-status in headers, we look for it in trailers later.\n+        final HttpHeaders headers = response.headers();\n+        final GrpcStatusCode grpcStatusCode = extractGrpcStatusCodeFromHeaders(headers);\n+        if (grpcStatusCode != null) {\n+            final GrpcStatusException grpcStatusException = convertToGrpcStatusException(grpcStatusCode, headers);\n+            return response.payloadBodyAndTrailers().ignoreElements()\n+                    .concat(grpcStatusException != null ? failed(grpcStatusException) : empty());\n         }\n-        return deserializer.deserialize(respHeaders, response.payloadBodyAndTrailers().map(o -> {\n-            if (o instanceof HttpHeaders) {\n-                // We have already checked for error in headers above, now we just check in trailers.\n-                GrpcStatusException ex = extractGrpcExceptionFromHeaders((HttpHeaders) o);\n-                if (ex != null) {\n-                    throw ex;\n-                }\n-            } else if (!(o instanceof Buffer)) {\n-                throw new IllegalArgumentException(\"Unexpected payload type: \" + o.getClass());\n-            }\n-            return o;\n-        }).filter(o -> !(o instanceof HttpHeaders)).map(o -> (Buffer) o));\n+\n+        response.transformRaw(ENSURE_GRPC_STATUS_RECEIVED);\n+        return deserializer.deserialize(headers, response.payloadBodyAndTrailers()", "originalCommit": "1f25afb8e4b007c694cc1bbdc66b3f508134df67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQwMjI4MQ==", "url": "https://github.com/apple/servicetalk/pull/934#discussion_r377402281", "bodyText": "This makes sense. If you wish to avoid calling transformRaw() (and create trailers); you can use a liftSync() to intercept onComplete() (you would still have to use filter() like before).", "author": "NiteshKant", "createdAt": "2020-02-11T00:51:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE3OTg5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk0OTk0OQ==", "url": "https://github.com/apple/servicetalk/pull/934#discussion_r377949949", "bodyText": "Good idea, I will keep it with transformRaw for now and we can optimize if it show ups as a problem later.", "author": "idelpivnitskiy", "createdAt": "2020-02-11T22:57:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE3OTg5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ1MjczNA==", "url": "https://github.com/apple/servicetalk/pull/934#discussion_r377452734", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new GrpcStatus(INTERNAL, null, \"Response does not contain grpc-status code\")\n          \n          \n            \n                        throw new GrpcStatus(INTERNAL, null, \"Response does not contain \" + GRPC_STATUS_CODE_TRAILER + \" header or trailer.\")", "author": "NiteshKant", "createdAt": "2020-02-11T05:39:03Z", "path": "servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcUtils.java", "diffHunk": "@@ -138,50 +150,56 @@ static void setStatus(final HttpHeaders trailers, final Throwable cause, final B\n \n     static <Resp> Publisher<Resp> validateResponseAndGetPayload(final StreamingHttpResponse response,\n                                                                 final HttpDeserializer<Resp> deserializer) {\n-        // In case of server error, gRPC may return only one HEADER frame with endStream=true. Our\n-        // HTTP1-based implementation translates them into response headers so we need to look for\n-        // the status in both headers and trailers. Since this is streaming response and we have the headers now, we\n-        // check for error here first. If we see trailers later in payloadBodyAndTrailers(), we will check for error\n-        // there.\n-        final HttpHeaders respHeaders = response.headers();\n-        GrpcStatusException grpcStatusException = extractGrpcExceptionFromHeaders(respHeaders);\n-        if (grpcStatusException != null) {\n-            return Publisher.failed(grpcStatusException);\n+        // In case of an empty response, gRPC-server may return only one HEADER frame with endStream=true. Our\n+        // HTTP1-based implementation translates them into response headers so we need to look for a grpc-status in both\n+        // headers and trailers. Since this is streaming response and we have the headers now, we check for the\n+        // grpc-status here first. If there is no grpc-status in headers, we look for it in trailers later.\n+        final HttpHeaders headers = response.headers();\n+        final GrpcStatusCode grpcStatusCode = extractGrpcStatusCodeFromHeaders(headers);\n+        if (grpcStatusCode != null) {\n+            final GrpcStatusException grpcStatusException = convertToGrpcStatusException(grpcStatusCode, headers);\n+            return response.payloadBodyAndTrailers().ignoreElements()\n+                    .concat(grpcStatusException != null ? failed(grpcStatusException) : empty());\n         }\n-        return deserializer.deserialize(respHeaders, response.payloadBodyAndTrailers().map(o -> {\n-            if (o instanceof HttpHeaders) {\n-                // We have already checked for error in headers above, now we just check in trailers.\n-                GrpcStatusException ex = extractGrpcExceptionFromHeaders((HttpHeaders) o);\n-                if (ex != null) {\n-                    throw ex;\n-                }\n-            } else if (!(o instanceof Buffer)) {\n-                throw new IllegalArgumentException(\"Unexpected payload type: \" + o.getClass());\n-            }\n-            return o;\n-        }).filter(o -> !(o instanceof HttpHeaders)).map(o -> (Buffer) o));\n+\n+        response.transformRaw(ENSURE_GRPC_STATUS_RECEIVED);\n+        return deserializer.deserialize(headers, response.payloadBodyAndTrailers()\n+                .filter(o -> !(o instanceof HttpHeaders)).map(o -> (Buffer) o));\n     }\n \n     static <Resp> Resp validateResponseAndGetPayload(final HttpResponse response,\n                                                      final HttpDeserializer<Resp> deserializer) {\n-        final HttpHeaders trailers = response.trailers();\n-        final HttpHeaders headers = response.headers();\n-        // In case of server error, gRPC may return only one HEADER frame with endStream=true. Our\n-        // HTTP1-based implementation translates them into response headers so we need to look for\n-        // the status in both headers and trailers.\n+        // In case of an empty response, gRPC-server may return only one HEADER frame with endStream=true. Our\n+        // HTTP1-based implementation translates them into response headers so we need to look for a grpc-status in both\n+        // headers and trailers.\n \n-        // We will try the trailers first as this is the most likely place to find the GRPC related headers.\n-        GrpcStatusException grpcStatusException = extractGrpcExceptionFromHeaders(trailers);\n-        if (grpcStatusException != null) {\n-            throw grpcStatusException;\n+        // We will try the trailers first as this is the most likely place to find the gRPC-related headers.\n+        final HttpHeaders trailers = response.trailers();\n+        GrpcStatusCode grpcStatusCode = extractGrpcStatusCodeFromHeaders(trailers);\n+        if (grpcStatusCode != null) {\n+            final GrpcStatusException grpcStatusException = convertToGrpcStatusException(grpcStatusCode, trailers);\n+            if (grpcStatusException != null) {\n+                throw grpcStatusException;\n+            }\n+            return response.payloadBody(deserializer);\n         }\n \n-        // There was no grpc-status in the trailers, so error may be in the headers.\n-        grpcStatusException = extractGrpcExceptionFromHeaders(headers);\n+        // There was no grpc-status in the trailers, so it must be in headers.\n+        ensureGrpcStatusReceived(response.headers());\n+        return response.payloadBody(deserializer);\n+    }\n+\n+    private static void ensureGrpcStatusReceived(final HttpHeaders headers) {\n+        final GrpcStatusCode statusCode = extractGrpcStatusCodeFromHeaders(headers);\n+        if (statusCode == null) {\n+            // This is a protocol violation as we expect to receive grpc-status.\n+            throw new GrpcStatus(INTERNAL, null, \"Response does not contain grpc-status code\")", "originalCommit": "1f25afb8e4b007c694cc1bbdc66b3f508134df67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ff84226513c38c862868030e58f061369cb7b80f", "url": "https://github.com/apple/servicetalk/commit/ff84226513c38c862868030e58f061369cb7b80f", "message": "Update servicetalk-grpc-api/src/main/java/io/servicetalk/grpc/api/GrpcUtils.java\r\n\r\nAddress comments\n\nCo-Authored-By: Nitesh Kant <nitesh_kant@apple.com>", "committedDate": "2020-02-11T22:58:27Z", "type": "commit"}, {"oid": "5b4e33cf086ead2d819562fd66eadea1b8748dd0", "url": "https://github.com/apple/servicetalk/commit/5b4e33cf086ead2d819562fd66eadea1b8748dd0", "message": "Fix tests", "committedDate": "2020-02-11T23:24:06Z", "type": "commit"}, {"oid": "b28505228733da60a534b2ec9572400d2262bbfb", "url": "https://github.com/apple/servicetalk/commit/b28505228733da60a534b2ec9572400d2262bbfb", "message": "Merge remote-tracking branch 'upstream/master' into grpc-require-trailers", "committedDate": "2020-02-11T23:24:22Z", "type": "commit"}, {"oid": "9f2d6397e47d0116160fc20de6d8c913b1d1acc1", "url": "https://github.com/apple/servicetalk/commit/9f2d6397e47d0116160fc20de6d8c913b1d1acc1", "message": "Update copyright years", "committedDate": "2020-02-11T23:34:07Z", "type": "commit"}]}