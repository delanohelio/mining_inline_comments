{"pr_number": 1166, "pr_title": "Add an `EmbeddedChannel` that supports `DuplexChannel` interface", "pr_createdAt": "2020-10-03T01:09:28Z", "pr_url": "https://github.com/apple/servicetalk/pull/1166", "timeline": [{"oid": "1e5e96be7e29cb019a9ce2727c567cd8f254fdaa", "url": "https://github.com/apple/servicetalk/commit/1e5e96be7e29cb019a9ce2727c567cd8f254fdaa", "message": "Add an `EmbeddedChannel` that supports `DuplexChannel` interface\n\nMotivation:\n\n`RequestResponseCloseHandler` requires a `Channel` to implement `DuplexChannel`\ninterface. To reliably reproduce some racy behavior on the network we use\n`EmbeddedChannel` to control all the network events manually, but it does\nnot implement `DuplexChannel`. Therefore, we can not use it to verify\nbehavior of `RequestResponseCloseHandler`.\n\nModifications:\n\n- Implement `EmbeddedDuplexChannel` test fixture that extends\n`EmbeddedChannel` and implements `DuplexChannel` interface;\n- Use a new variant in all tests that require an `EmbeddedChannel` with\n`RequestResponseCloseHandler`;\n- Update `RequestResponseCloseHandler` to support any `DuplexChannel`\nimplementations that has `ALLOW_HALF_CLOSURE` socket option enabled;\n\nResult:\n\nBetter test coverage for `RequestResponseCloseHandler`, no unexpected\n`ClassCastException`(s) on the pipeline.", "committedDate": "2020-10-03T01:08:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwMTg4NQ==", "url": "https://github.com/apple/servicetalk/pull/1166#discussion_r499101885", "bodyText": "@normanmaurer is it something you will be interested to see in netty? Implementation can be a bit simplified if we implement DuplexChannel for the existing EmbeddedChannel, or provide EmbeddedDuplexChannel in the same package.", "author": "idelpivnitskiy", "createdAt": "2020-10-03T01:11:30Z", "path": "servicetalk-transport-netty-internal/src/testFixtures/java/io/servicetalk/transport/netty/internal/EmbeddedDuplexChannel.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.netty.internal;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelConfig;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.ChannelOutboundBuffer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.DefaultChannelConfig;\n+import io.netty.channel.EventLoop;\n+import io.netty.channel.RecvByteBufAllocator;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.channel.socket.ChannelInputShutdownEvent;\n+import io.netty.channel.socket.ChannelInputShutdownReadComplete;\n+import io.netty.channel.socket.DuplexChannel;\n+import io.netty.channel.socket.SocketChannelConfig;\n+\n+import java.net.SocketAddress;\n+import java.nio.channels.ClosedChannelException;\n+import java.util.ArrayDeque;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.ALLOW_HALF_CLOSURE;\n+\n+/**\n+ * {@link EmbeddedChannel} that implements {@link DuplexChannel}.\n+ */\n+public final class EmbeddedDuplexChannel extends EmbeddedChannel implements DuplexChannel {", "originalCommit": "1e5e96be7e29cb019a9ce2727c567cd8f254fdaa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIyMzQ0MQ==", "url": "https://github.com/apple/servicetalk/pull/1166#discussion_r501223441", "bodyText": "Agreed this belongs in Netty. we should likely also have EmbeddedChannel#config() return something that supports half closure. Currently this method is only present on SocketChannelConfig but perhaps we should  also have a DuplexChannelConfig which extracts out these methods in 5.0.", "author": "Scottmitch", "createdAt": "2020-10-07T18:26:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwMTg4NQ=="}], "type": "inlineReview"}, {"oid": "5ea2664c59b1349132ffccc555429ee62344c586", "url": "https://github.com/apple/servicetalk/commit/5ea2664c59b1349132ffccc555429ee62344c586", "message": "Add missed gradle dependency", "committedDate": "2020-10-03T15:42:11Z", "type": "commit"}, {"oid": "fda8951f6d5833ae3f3e0260e64a00557c6e0e05", "url": "https://github.com/apple/servicetalk/commit/fda8951f6d5833ae3f3e0260e64a00557c6e0e05", "message": "Discard new inbound and complete awaitOutputShutdown on CLOSE event", "committedDate": "2020-10-03T17:54:59Z", "type": "commit"}, {"oid": "1b28f1836d087bfdbfcd6d214637aed441a6ca14", "url": "https://github.com/apple/servicetalk/commit/1b28f1836d087bfdbfcd6d214637aed441a6ca14", "message": "Release new ref-counted objects after shutdownInput", "committedDate": "2020-10-05T16:33:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIxNTI1MA==", "url": "https://github.com/apple/servicetalk/pull/1166#discussion_r501215250", "bodyText": "are there tests that intentionally leave requests open that necessitates this change?", "author": "Scottmitch", "createdAt": "2020-10-07T18:15:32Z", "path": "servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/FlushStrategyOnServerTest.java", "diffHunk": "@@ -129,7 +129,7 @@ public FlushStrategyOnServerTest(final Param param) throws Exception {\n     @After\n     public void tearDown() throws Exception {\n         try {\n-            serverConnection.closeAsyncGracefully().toFuture().get();\n+            serverConnection.closeAsync().toFuture().get();", "originalCommit": "1b28f1836d087bfdbfcd6d214637aed441a6ca14", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM3MTc4OA==", "url": "https://github.com/apple/servicetalk/pull/1166#discussion_r501371788", "bodyText": "I was thinking that in tearDown() it's not expected that something is still in process and we should just close. But then I realized that graceful closure will show us if there is some unexpected outstanding data on the pipeline that do not allow us to close. Let me revert it.", "author": "idelpivnitskiy", "createdAt": "2020-10-07T23:45:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIxNTI1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIzMDkxMw==", "url": "https://github.com/apple/servicetalk/pull/1166#discussion_r501230913", "bodyText": "the state is split between EmbeddedChannel and this class. in EmbeddedChannel it is not atomic (perhaps it should be bcz inEventLoop() is always true) and here it is atomic. Ideally this could be consolidated in Netty and use a similar strategy to Socket.java.\nThis doesn't need to block this PR but when/if this goes into Netty we should resolve this.", "author": "Scottmitch", "createdAt": "2020-10-07T18:39:08Z", "path": "servicetalk-transport-netty-internal/src/testFixtures/java/io/servicetalk/transport/netty/internal/EmbeddedDuplexChannel.java", "diffHunk": "@@ -0,0 +1,476 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.netty.internal;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelConfig;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.ChannelOutboundBuffer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.DefaultChannelConfig;\n+import io.netty.channel.EventLoop;\n+import io.netty.channel.RecvByteBufAllocator;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.channel.socket.ChannelInputShutdownEvent;\n+import io.netty.channel.socket.ChannelInputShutdownReadComplete;\n+import io.netty.channel.socket.DuplexChannel;\n+import io.netty.channel.socket.SocketChannelConfig;\n+import io.netty.util.ReferenceCountUtil;\n+\n+import java.net.SocketAddress;\n+import java.nio.channels.ClosedChannelException;\n+import java.util.ArrayDeque;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.ALLOW_HALF_CLOSURE;\n+\n+/**\n+ * {@link EmbeddedChannel} that implements {@link DuplexChannel}.\n+ */\n+public final class EmbeddedDuplexChannel extends EmbeddedChannel implements DuplexChannel {\n+\n+    // Use atomics because shutdown may be requested from offloaded thread,\n+    // while EmbeddedEventLoop#inEventLoop() always returns `true`.\n+    private final AtomicBoolean isInputShutdown = new AtomicBoolean();\n+    private final AtomicBoolean isOutputShutdown = new AtomicBoolean();\n+\n+    private final CountDownLatch inputShutdownLatch = new CountDownLatch(1);\n+    private final CountDownLatch outputShutdownLatch = new CountDownLatch(1);\n+\n+    @Nullable\n+    private EmbeddedDuplexChannelConfig config;\n+    @Nullable\n+    private EmbeddedUnsafe unsafe;\n+\n+    /**\n+     * Create a new instance with the pipeline initialized with the specified handlers.\n+     *\n+     * @param handlers the {@link ChannelHandler}s which will be add in the {@link ChannelPipeline}\n+     */\n+    public EmbeddedDuplexChannel(ChannelHandler... handlers) {\n+        super(handlers);\n+    }\n+\n+    @Override\n+    protected void doClose() throws Exception {\n+        super.doClose();\n+        isInputShutdown.set(true);\n+        doShutdownOutput();\n+    }\n+\n+    @Override\n+    public boolean isInputShutdown() {\n+        return isInputShutdown.get();\n+    }\n+\n+    /**\n+     * Awaits completion of {@link #shutdownInput()}.\n+     *\n+     * @throws InterruptedException if the current thread was interrupted\n+     */\n+    public void awaitInputShutdown() throws InterruptedException {\n+        inputShutdownLatch.await();\n+    }\n+\n+    @Override\n+    public ChannelFuture shutdownInput() {\n+        return shutdownInput(newPromise());\n+    }\n+\n+    @Override\n+    public ChannelFuture shutdownInput(final ChannelPromise promise) {\n+        if (!isOpen()) {", "originalCommit": "1b28f1836d087bfdbfcd6d214637aed441a6ca14", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM3MjQxOQ==", "url": "https://github.com/apple/servicetalk/pull/1166#discussion_r501372419", "bodyText": "EmbeddedChannel is not expected to be used from different threads. But this is what we do to verify offloading. If we port code in netty, it should not have atomics. Instead, we should enhance EmbeddedEventLoop in netty to account for the thread and use a concurrent queue for tasks.", "author": "idelpivnitskiy", "createdAt": "2020-10-07T23:47:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIzMDkxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIzMjIzOA==", "url": "https://github.com/apple/servicetalk/pull/1166#discussion_r501232238", "bodyText": "maybe worth adding a comment these are independent atomic variables and this maybe racy. Not sure it matters for this class usage in tests but consider using approach similar to Socket#isShutdown().", "author": "Scottmitch", "createdAt": "2020-10-07T18:41:28Z", "path": "servicetalk-transport-netty-internal/src/testFixtures/java/io/servicetalk/transport/netty/internal/EmbeddedDuplexChannel.java", "diffHunk": "@@ -0,0 +1,476 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.netty.internal;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelConfig;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.ChannelOutboundBuffer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.DefaultChannelConfig;\n+import io.netty.channel.EventLoop;\n+import io.netty.channel.RecvByteBufAllocator;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.channel.socket.ChannelInputShutdownEvent;\n+import io.netty.channel.socket.ChannelInputShutdownReadComplete;\n+import io.netty.channel.socket.DuplexChannel;\n+import io.netty.channel.socket.SocketChannelConfig;\n+import io.netty.util.ReferenceCountUtil;\n+\n+import java.net.SocketAddress;\n+import java.nio.channels.ClosedChannelException;\n+import java.util.ArrayDeque;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.ALLOW_HALF_CLOSURE;\n+\n+/**\n+ * {@link EmbeddedChannel} that implements {@link DuplexChannel}.\n+ */\n+public final class EmbeddedDuplexChannel extends EmbeddedChannel implements DuplexChannel {\n+\n+    // Use atomics because shutdown may be requested from offloaded thread,\n+    // while EmbeddedEventLoop#inEventLoop() always returns `true`.\n+    private final AtomicBoolean isInputShutdown = new AtomicBoolean();\n+    private final AtomicBoolean isOutputShutdown = new AtomicBoolean();\n+\n+    private final CountDownLatch inputShutdownLatch = new CountDownLatch(1);\n+    private final CountDownLatch outputShutdownLatch = new CountDownLatch(1);\n+\n+    @Nullable\n+    private EmbeddedDuplexChannelConfig config;\n+    @Nullable\n+    private EmbeddedUnsafe unsafe;\n+\n+    /**\n+     * Create a new instance with the pipeline initialized with the specified handlers.\n+     *\n+     * @param handlers the {@link ChannelHandler}s which will be add in the {@link ChannelPipeline}\n+     */\n+    public EmbeddedDuplexChannel(ChannelHandler... handlers) {\n+        super(handlers);\n+    }\n+\n+    @Override\n+    protected void doClose() throws Exception {\n+        super.doClose();\n+        isInputShutdown.set(true);\n+        doShutdownOutput();\n+    }\n+\n+    @Override\n+    public boolean isInputShutdown() {\n+        return isInputShutdown.get();\n+    }\n+\n+    /**\n+     * Awaits completion of {@link #shutdownInput()}.\n+     *\n+     * @throws InterruptedException if the current thread was interrupted\n+     */\n+    public void awaitInputShutdown() throws InterruptedException {\n+        inputShutdownLatch.await();\n+    }\n+\n+    @Override\n+    public ChannelFuture shutdownInput() {\n+        return shutdownInput(newPromise());\n+    }\n+\n+    @Override\n+    public ChannelFuture shutdownInput(final ChannelPromise promise) {\n+        if (!isOpen()) {\n+            promise.setFailure(new ClosedChannelException());\n+            return promise;\n+        }\n+\n+        assert config != null;\n+        if (!config.isAllowHalfClosure()) {\n+            return close(promise);\n+        }\n+\n+        if (isInputShutdown.compareAndSet(false, true)) {\n+            pipeline().fireUserEventTriggered(ChannelInputShutdownEvent.INSTANCE);\n+            super.flushInbound();\n+            pipeline().fireUserEventTriggered(ChannelInputShutdownReadComplete.INSTANCE);\n+            inputShutdownLatch.countDown();\n+        }\n+        promise.setSuccess();\n+        return promise;\n+    }\n+\n+    @Override\n+    public boolean isOutputShutdown() {\n+        return isOutputShutdown.get();\n+    }\n+\n+    /**\n+     * Awaits completion of {@link #shutdownOutput()}.\n+     *\n+     * @throws InterruptedException if the current thread was interrupted\n+     */\n+    public void awaitOutputShutdown() throws InterruptedException {\n+        outputShutdownLatch.await();\n+    }\n+\n+    @Override\n+    public ChannelFuture shutdownOutput() {\n+        return shutdownOutput(newPromise());\n+    }\n+\n+    @Override\n+    public ChannelFuture shutdownOutput(final ChannelPromise promise) {\n+        if (!isOpen()) {\n+            promise.setFailure(new ClosedChannelException());\n+            return promise;\n+        }\n+\n+        assert config != null;\n+        if (!config.isAllowHalfClosure()) {\n+            return close(promise);\n+        }\n+\n+        assert unsafe != null;\n+        unsafe.shutdownOutput(promise);\n+        return promise;\n+    }\n+\n+    @Override\n+    protected void doShutdownOutput() {\n+        isOutputShutdown.set(true);\n+        outputShutdownLatch.countDown();\n+    }\n+\n+    @Override\n+    public boolean isShutdown() {\n+        return isInputShutdown() && isOutputShutdown();", "originalCommit": "1b28f1836d087bfdbfcd6d214637aed441a6ca14", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2MzQ1Mw==", "url": "https://github.com/apple/servicetalk/pull/1166#discussion_r501263453", "bodyText": "if the input is shutdown real transports will stop producing data (eventually), did you consider force clear/release when shutdown inbound happens to emulate this behavior?", "author": "Scottmitch", "createdAt": "2020-10-07T19:39:03Z", "path": "servicetalk-transport-netty-internal/src/testFixtures/java/io/servicetalk/transport/netty/internal/EmbeddedDuplexChannel.java", "diffHunk": "@@ -0,0 +1,476 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.netty.internal;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelConfig;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.ChannelOutboundBuffer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.DefaultChannelConfig;\n+import io.netty.channel.EventLoop;\n+import io.netty.channel.RecvByteBufAllocator;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.channel.socket.ChannelInputShutdownEvent;\n+import io.netty.channel.socket.ChannelInputShutdownReadComplete;\n+import io.netty.channel.socket.DuplexChannel;\n+import io.netty.channel.socket.SocketChannelConfig;\n+import io.netty.util.ReferenceCountUtil;\n+\n+import java.net.SocketAddress;\n+import java.nio.channels.ClosedChannelException;\n+import java.util.ArrayDeque;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.ALLOW_HALF_CLOSURE;\n+\n+/**\n+ * {@link EmbeddedChannel} that implements {@link DuplexChannel}.\n+ */\n+public final class EmbeddedDuplexChannel extends EmbeddedChannel implements DuplexChannel {\n+\n+    // Use atomics because shutdown may be requested from offloaded thread,\n+    // while EmbeddedEventLoop#inEventLoop() always returns `true`.\n+    private final AtomicBoolean isInputShutdown = new AtomicBoolean();\n+    private final AtomicBoolean isOutputShutdown = new AtomicBoolean();\n+\n+    private final CountDownLatch inputShutdownLatch = new CountDownLatch(1);\n+    private final CountDownLatch outputShutdownLatch = new CountDownLatch(1);\n+\n+    @Nullable\n+    private EmbeddedDuplexChannelConfig config;\n+    @Nullable\n+    private EmbeddedUnsafe unsafe;\n+\n+    /**\n+     * Create a new instance with the pipeline initialized with the specified handlers.\n+     *\n+     * @param handlers the {@link ChannelHandler}s which will be add in the {@link ChannelPipeline}\n+     */\n+    public EmbeddedDuplexChannel(ChannelHandler... handlers) {\n+        super(handlers);\n+    }\n+\n+    @Override\n+    protected void doClose() throws Exception {\n+        super.doClose();\n+        isInputShutdown.set(true);\n+        doShutdownOutput();\n+    }\n+\n+    @Override\n+    public boolean isInputShutdown() {\n+        return isInputShutdown.get();\n+    }\n+\n+    /**\n+     * Awaits completion of {@link #shutdownInput()}.\n+     *\n+     * @throws InterruptedException if the current thread was interrupted\n+     */\n+    public void awaitInputShutdown() throws InterruptedException {\n+        inputShutdownLatch.await();\n+    }\n+\n+    @Override\n+    public ChannelFuture shutdownInput() {\n+        return shutdownInput(newPromise());\n+    }\n+\n+    @Override\n+    public ChannelFuture shutdownInput(final ChannelPromise promise) {\n+        if (!isOpen()) {\n+            promise.setFailure(new ClosedChannelException());\n+            return promise;\n+        }\n+\n+        assert config != null;\n+        if (!config.isAllowHalfClosure()) {\n+            return close(promise);\n+        }\n+\n+        if (isInputShutdown.compareAndSet(false, true)) {\n+            pipeline().fireUserEventTriggered(ChannelInputShutdownEvent.INSTANCE);\n+            super.flushInbound();\n+            pipeline().fireUserEventTriggered(ChannelInputShutdownReadComplete.INSTANCE);\n+            inputShutdownLatch.countDown();\n+        }\n+        promise.setSuccess();\n+        return promise;\n+    }\n+\n+    @Override\n+    public boolean isOutputShutdown() {\n+        return isOutputShutdown.get();\n+    }\n+\n+    /**\n+     * Awaits completion of {@link #shutdownOutput()}.\n+     *\n+     * @throws InterruptedException if the current thread was interrupted\n+     */\n+    public void awaitOutputShutdown() throws InterruptedException {\n+        outputShutdownLatch.await();\n+    }\n+\n+    @Override\n+    public ChannelFuture shutdownOutput() {\n+        return shutdownOutput(newPromise());\n+    }\n+\n+    @Override\n+    public ChannelFuture shutdownOutput(final ChannelPromise promise) {\n+        if (!isOpen()) {\n+            promise.setFailure(new ClosedChannelException());\n+            return promise;\n+        }\n+\n+        assert config != null;\n+        if (!config.isAllowHalfClosure()) {\n+            return close(promise);\n+        }\n+\n+        assert unsafe != null;\n+        unsafe.shutdownOutput(promise);\n+        return promise;\n+    }\n+\n+    @Override\n+    protected void doShutdownOutput() {\n+        isOutputShutdown.set(true);\n+        outputShutdownLatch.countDown();\n+    }\n+\n+    @Override\n+    public boolean isShutdown() {\n+        return isInputShutdown() && isOutputShutdown();\n+    }\n+\n+    @Override\n+    public ChannelFuture shutdown() {\n+        return shutdown(newPromise());\n+    }\n+\n+    @Override\n+    public ChannelFuture shutdown(final ChannelPromise promise) {\n+        ChannelFuture shutdownOutputFuture = shutdownOutput();\n+        if (shutdownOutputFuture.isDone()) {\n+            shutdownOutputDone(shutdownOutputFuture, promise);\n+        } else {\n+            shutdownOutputFuture.addListener((ChannelFutureListener) sof -> shutdownOutputDone(sof, promise));\n+        }\n+        return promise;\n+    }\n+\n+    private void shutdownOutputDone(final ChannelFuture shutdownOutputFuture, final ChannelPromise promise) {\n+        ChannelFuture shutdownInputFuture = shutdownInput();\n+        if (shutdownInputFuture.isDone()) {\n+            shutdownDone(shutdownOutputFuture, shutdownInputFuture, promise);\n+        } else {\n+            shutdownInputFuture.addListener((ChannelFutureListener) sif ->\n+                    shutdownDone(shutdownOutputFuture, sif, promise));\n+        }\n+    }\n+\n+    private static void shutdownDone(ChannelFuture shutdownOutputFuture,\n+                                     ChannelFuture shutdownInputFuture,\n+                                     ChannelPromise promise) {\n+        Throwable shutdownOutputCause = shutdownOutputFuture.cause();\n+        Throwable shutdownInputCause = shutdownInputFuture.cause();\n+        if (shutdownOutputCause != null) {\n+            if (shutdownInputCause != null) {\n+                shutdownOutputCause.addSuppressed(shutdownInputCause);\n+            }\n+            promise.setFailure(shutdownOutputCause);\n+        } else if (shutdownInputCause != null) {\n+            promise.setFailure(shutdownInputCause);\n+        } else {\n+            promise.setSuccess();\n+        }\n+    }\n+\n+    @Override\n+    public Queue<Object> inboundMessages() {\n+        if (isInputShutdown.get()) {", "originalCommit": "1b28f1836d087bfdbfcd6d214637aed441a6ca14", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM3NTQxNA==", "url": "https://github.com/apple/servicetalk/pull/1166#discussion_r501375414", "bodyText": "It will stop producing new messages, but it should read all pending messages. This is what I emulate using:\npipeline().fireUserEventTriggered(ChannelInputShutdownEvent.INSTANCE);\nsuper.flushInbound();\npipeline().fireUserEventTriggered(ChannelInputShutdownReadComplete.INSTANCE);\nAfter that, I make sure that it can not produce more messages discarding any following attempts to write inbound.", "author": "idelpivnitskiy", "createdAt": "2020-10-07T23:57:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2MzQ1Mw=="}], "type": "inlineReview"}, {"oid": "a0d21586a0950308cf9ad16e0039f5687656c094", "url": "https://github.com/apple/servicetalk/commit/a0d21586a0950308cf9ad16e0039f5687656c094", "message": "Address comments", "committedDate": "2020-10-08T19:18:26Z", "type": "commit"}]}