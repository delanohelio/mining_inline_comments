{"pr_number": 1059, "pr_title": "`WriteStreamSubscriber` retains listeners for the lifetime of the source", "pr_createdAt": "2020-05-19T21:01:28Z", "pr_url": "https://github.com/apple/servicetalk/pull/1059", "timeline": [{"oid": "84517e5c0193fc159116ca4134faf42f1fdbba9a", "url": "https://github.com/apple/servicetalk/commit/84517e5c0193fc159116ca4134faf42f1fdbba9a", "message": "`WriteStreamSubscriber` retains listeners for the lifetime of the source\n\n__Motivation__\n\n`WriteStreamSubscriber` uses a single `Promise` for all writes done through it. As we add listeners to each write, the listeners get accumulated in the promise till the `WriteStreamSubscriber` terminates. For servers since we do a single write for the connection, these listeners are retained for the connection lifetime.\n\n__Modification__\n\n- Manage listeners in `AllWritesPromise` as opposed to delegating them to `DefaultWritePromise`.\n- Listeners are managed over the specific write boundaries.\n- Each time a write is complete, listeners added since last write are terminated and removed from the list.\n\n__Result__\n\nListeners are retained by `WriteStreamSubscriber` for the duration of each write.", "committedDate": "2020-05-19T23:16:07Z", "type": "commit"}, {"oid": "84517e5c0193fc159116ca4134faf42f1fdbba9a", "url": "https://github.com/apple/servicetalk/commit/84517e5c0193fc159116ca4134faf42f1fdbba9a", "message": "`WriteStreamSubscriber` retains listeners for the lifetime of the source\n\n__Motivation__\n\n`WriteStreamSubscriber` uses a single `Promise` for all writes done through it. As we add listeners to each write, the listeners get accumulated in the promise till the `WriteStreamSubscriber` terminates. For servers since we do a single write for the connection, these listeners are retained for the connection lifetime.\n\n__Modification__\n\n- Manage listeners in `AllWritesPromise` as opposed to delegating them to `DefaultWritePromise`.\n- Listeners are managed over the specific write boundaries.\n- Each time a write is complete, listeners added since last write are terminated and removed from the list.\n\n__Result__\n\nListeners are retained by `WriteStreamSubscriber` for the duration of each write.", "committedDate": "2020-05-19T23:16:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYzOTUxMg==", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r427639512", "bodyText": "nit: isEmpty() and removeFirst() can be combined into a single call:\n            Object maybeListener;\n            while ((maybeListener = listenersOnWriteBoundaries.pollFirst()) != null) {\n                if (maybeListener != WRITE_BOUNDARY) {\n                    notifyListener(future, maybeListener);\n                }\n            }", "author": "Scottmitch", "createdAt": "2020-05-19T22:37:05Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -420,6 +482,38 @@ private void terminateSubscriber(@Nullable Throwable cause) {\n             }\n         }\n \n+        private void notifyAllListeners(@Nullable Throwable cause) {\n+            final ChannelFuture future = cause == null ? channel.newSucceededFuture() : channel.newFailedFuture(cause);\n+            while (!listenersOnWriteBoundaries.isEmpty()) {", "originalCommit": "ad102cb68c3a23fe4c6fb9c93d272d5bc1eab215", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0MDA2OQ==", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r427640069", "bodyText": "did you consider random insertion or removal to be common (I'm assuming removeListener isn't frequently used)? if not consider ArrayDeque which has a lower constant memory overhead (LinkedList = 24 bytes per Node, ArrayDeque = backed by array).", "author": "Scottmitch", "createdAt": "2020-05-19T22:38:42Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -259,11 +265,61 @@ private void requestMoreIfRequired(@Nullable Subscription subscription) {\n         private byte state;\n         @Nullable\n         private Throwable failureCause;\n+        /**\n+         * This deque contains all added listeners within {@link #WRITE_BOUNDARY write boundaries}.\n+         * <pre>\n+         *     {@link #WRITE_BOUNDARY}, listener1, listener2, {@link #WRITE_BOUNDARY}, listener3 ...\n+         * </pre>\n+         * We assume that no listener for a write is added after that write is completed (a.k.a late listeners).\n+         */\n+        private final Deque<Object> listenersOnWriteBoundaries = new LinkedList<>();", "originalCommit": "ad102cb68c3a23fe4c6fb9c93d272d5bc1eab215", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY4MDQ1MQ==", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r427680451", "bodyText": "ArrayDeque SGTM", "author": "NiteshKant", "createdAt": "2020-05-20T00:48:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0MDA2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0MjU4MA==", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r427642580", "bodyText": "is it necessary to leave WRITE_BOUNDARY at the head of the queue?  if not we could simplify draining to just stop when null or we hit a WRITE_BOUNDARY\n            final ChannelFuture future = cause == null ? channel.newSucceededFuture() : channel.newFailedFuture(cause);\n            Object maybeListener = listenersOnWriteBoundaries.poll();\n            while (maybeListener != null && maybeListener != WRITE_BOUNDARY) {\n                notifyListener(future, maybeListener);\n                maybeListener = listenersOnWriteBoundaries.poll();\n            }\nthe order of the WRITE_BOUNDRY addition relative to channel#write would have to change, not sure if that is a problem? It maybe safer to delineate the boundaries on the leading edge if there are any async listeners added before completion, but given the restrictions on the boundaries I'm not sure if that would be reliable from a sequencing perspective?\n            channel.write(msg, this);\n            if (listenersOnWriteBoundaries.peekLast() != WRITE_BOUNDARY) {\n                listenersOnWriteBoundaries.addLast(WRITE_BOUNDARY);\n            }", "author": "Scottmitch", "createdAt": "2020-05-19T22:45:58Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -420,6 +482,38 @@ private void terminateSubscriber(@Nullable Throwable cause) {\n             }\n         }\n \n+        private void notifyAllListeners(@Nullable Throwable cause) {\n+            final ChannelFuture future = cause == null ? channel.newSucceededFuture() : channel.newFailedFuture(cause);\n+            while (!listenersOnWriteBoundaries.isEmpty()) {\n+                Object mayBeListener = listenersOnWriteBoundaries.removeFirst();\n+                if (mayBeListener != WRITE_BOUNDARY) {\n+                    notifyListener(future, mayBeListener);\n+                }\n+            }\n+        }\n+\n+        private void notifyListenersTillNextWrite(@Nullable Throwable cause) {\n+            Object shdBeWriteBoundary = listenersOnWriteBoundaries.removeFirst();", "originalCommit": "ad102cb68c3a23fe4c6fb9c93d272d5bc1eab215", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY4MTU3MQ==", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r427681571", "bodyText": "Let me try this out, thanks", "author": "NiteshKant", "createdAt": "2020-05-20T00:52:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0MjU4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIwNzExMA==", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r428207110", "bodyText": "Ok doing this will have problems if the write completes synchronously with channel.write() call.\nlistenersOnWriteBoundaries <- empty\nchannel.write()\n   - addListener(listener1) => listenersOnWriteBoundaries (listener1)\n   - writeAndFlush() (internally in the pipeline) => drain  listenersOnWriteBoundaries <- empty\nadd WRITE_BOUNDARY to listenersOnWriteBoundaries\nchannel.write()\n    - addListener(listener2) => listenersOnWriteBoundaries (WRITE_BOUNDARY, listener2)\nflush()\nnotifyListenersTillNextWrite() <- removes WRITE_BOUNDARY and exits", "author": "NiteshKant", "createdAt": "2020-05-20T18:04:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0MjU4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIwODA4Ng==", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r428208086", "bodyText": "I have replaced the early-return with an assert", "author": "NiteshKant", "createdAt": "2020-05-20T18:06:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0MjU4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM3ODA0MA==", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r428378040", "bodyText": "good call on the re-entry! Here is a unit test for WriteStreamSubscriberFutureListenersTest to verify correctness here:\n    @Test\n    public void synchronousCompleteWrite() throws Exception {\n        Channel mockChannel = mock(Channel.class);\n        EventLoop mockEventLoop = mock(EventLoop.class);\n        when(mockEventLoop.inEventLoop()).thenReturn(true);\n        when(mockChannel.eventLoop()).thenReturn(mockEventLoop);\n        when(mockChannel.newSucceededFuture()).thenReturn(channel.newSucceededFuture());\n        doAnswer((Answer<Void>) invocation -> {\n            ReferenceCountUtil.release(invocation.getArgument(0));\n            ChannelFutureListener listener = mock(ChannelFutureListener.class);\n            listeners.add(listener);\n            ChannelPromise promise = invocation.getArgument(1);\n            promise.addListener(listener);\n            promise.setSuccess();\n            return null;\n        }).when(mockChannel).write(any(), any());\n        WriteDemandEstimator estimator = WriteDemandEstimators.newDefaultEstimator();\n        TestCompletableSubscriber completableSubscriber = new TestCompletableSubscriber();\n        WriteStreamSubscriber subscriber = new WriteStreamSubscriber(mockChannel, estimator, completableSubscriber,\n                UNSUPPORTED_PROTOCOL_CLOSE_HANDLER);\n        subscriber.onNext(1);\n        verifyListenerInvokedWithSuccess(listeners.take());\n        subscriber.onNext(2);\n        verifyListenerInvokedWithSuccess(listeners.take());\n    }", "author": "Scottmitch", "createdAt": "2020-05-21T00:16:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0MjU4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0MzcxMw==", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r427643713", "bodyText": "I see the we assume no late listener comment above but I'm wondering what the negative/costs would be of notifying listeners if they are late. Otherwise if this does happen we may not complete async control flow in some cases. We maybe able to delegate to super to manage notification, however not sure if this will bring up any notification ordering if folks add a listener in a re-entry fashion.", "author": "Scottmitch", "createdAt": "2020-05-19T22:49:30Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -259,11 +265,61 @@ private void requestMoreIfRequired(@Nullable Subscription subscription) {\n         private byte state;\n         @Nullable\n         private Throwable failureCause;\n+        /**\n+         * This deque contains all added listeners within {@link #WRITE_BOUNDARY write boundaries}.\n+         * <pre>\n+         *     {@link #WRITE_BOUNDARY}, listener1, listener2, {@link #WRITE_BOUNDARY}, listener3 ...\n+         * </pre>\n+         * We assume that no listener for a write is added after that write is completed (a.k.a late listeners).\n+         */\n+        private final Deque<Object> listenersOnWriteBoundaries = new LinkedList<>();\n \n         AllWritesPromise(final Channel channel) {\n             super(channel);\n         }\n \n+        @Override\n+        public ChannelPromise addListener(final GenericFutureListener<? extends Future<? super Void>> listener) {\n+            assert channel.eventLoop().inEventLoop();\n+            if (hasFlag(SUBSCRIBER_TERMINATED)) {", "originalCommit": "ad102cb68c3a23fe4c6fb9c93d272d5bc1eab215", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY2NDc4MQ==", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r427664781", "bodyText": "nit: consider simplifying code block to:\n            if (!hasFlag(SUBSCRIBER_TERMINATED)) {\n                listenersOnWriteBoundaries.addLast(listener);\n            }\n            return this;", "author": "Scottmitch", "createdAt": "2020-05-19T23:53:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0MzcxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY4MDM1OQ==", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r427680359", "bodyText": "Re: late listeners\nWhat I was struggling with was that how do we distinguish between a late listener and a listener for the next write.", "author": "NiteshKant", "createdAt": "2020-05-20T00:47:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0MzcxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM4MDAzNw==", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r428380037", "bodyText": "how do we distinguish between a late listener and a listener for the next write.\n\nThis is a good point, I guess we really can't. Now that we are tracking listeners for individual write operations I wonder if AllWritesPromise still makes sense? An alternative would be to allocate new promises and have a shared listener that counts success/failures and manages the state ... wdyt?", "author": "Scottmitch", "createdAt": "2020-05-21T00:23:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0MzcxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM4MTE0Ng==", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r428381146", "bodyText": "Ya creating new promises is what I thought initially but since it has perf implications, I decided to not make such a drastic change.", "author": "NiteshKant", "createdAt": "2020-05-21T00:27:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0MzcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY2NDAzNA==", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r427664034", "bodyText": "nit: consider making this method static", "author": "Scottmitch", "createdAt": "2020-05-19T23:51:29Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -420,6 +480,39 @@ private void terminateSubscriber(@Nullable Throwable cause) {\n             }\n         }\n \n+        private void notifyAllListeners(@Nullable Throwable cause) {\n+            final ChannelFuture future = cause == null ? channel.newSucceededFuture() : channel.newFailedFuture(cause);\n+            while (!listenersOnWriteBoundaries.isEmpty()) {\n+                Object mayBeListener = listenersOnWriteBoundaries.removeFirst();\n+                if (mayBeListener != WRITE_BOUNDARY) {\n+                    notifyListener(future, mayBeListener);\n+                }\n+            }\n+        }\n+\n+        private void notifyListenersTillNextWrite(@Nullable Throwable cause) {\n+            assert !listenersOnWriteBoundaries.isEmpty();\n+            Object shdBeWriteBoundary = listenersOnWriteBoundaries.removeFirst();\n+            if (shdBeWriteBoundary != WRITE_BOUNDARY) {\n+                return;\n+            }\n+            final ChannelFuture future = cause == null ? channel.newSucceededFuture() : channel.newFailedFuture(cause);\n+            while (!listenersOnWriteBoundaries.isEmpty() && listenersOnWriteBoundaries.peekFirst() != WRITE_BOUNDARY) {\n+                Object shdBeListener = listenersOnWriteBoundaries.removeFirst();\n+                notifyListener(future, shdBeListener);\n+            }\n+        }\n+\n+        @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+        private void notifyListener(final ChannelFuture future, final Object shdBeListener) {", "originalCommit": "84517e5c0193fc159116ca4134faf42f1fdbba9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIxODU3Mg==", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r428218572", "bodyText": "Actually, this made me notice that I can use DefaultPromise.notifyListener()  which provides stack overflow protection \ud83c\udf89", "author": "NiteshKant", "createdAt": "2020-05-20T18:25:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY2NDAzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczNjE0NQ==", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r427736145", "bodyText": "Consider making this a GenericFutureListener. This was can tighten up the generics for the queue.", "author": "normanmaurer", "createdAt": "2020-05-20T04:35:54Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -67,6 +72,7 @@\n  */\n final class WriteStreamSubscriber implements PublisherSource.Subscriber<Object>, ChannelOutboundListener, Cancellable {\n     private static final Logger LOGGER = LoggerFactory.getLogger(WriteStreamSubscriber.class);\n+    private static final Object WRITE_BOUNDARY = new Object();", "originalCommit": "84517e5c0193fc159116ca4134faf42f1fdbba9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIzNTEzNA==", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r428235134", "bodyText": "good call", "author": "NiteshKant", "createdAt": "2020-05-20T18:48:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczNjE0NQ=="}], "type": "inlineReview"}, {"oid": "2982c09dacb563b2562511a3eae9b90022e6db64", "url": "https://github.com/apple/servicetalk/commit/2982c09dacb563b2562511a3eae9b90022e6db64", "message": "Review comments", "committedDate": "2020-05-20T18:33:34Z", "type": "commit"}, {"oid": "6cea4eb2599b9e55326573bfb559d71c0d75e7e5", "url": "https://github.com/apple/servicetalk/commit/6cea4eb2599b9e55326573bfb559d71c0d75e7e5", "message": "Moar review comments", "committedDate": "2020-05-20T18:47:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM2ODE1NA==", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r428368154", "bodyText": "removeFirst() -> pollFirst() (you have already verified there is an item in the queue, you can avoid the null check/exception from remove* method)", "author": "Scottmitch", "createdAt": "2020-05-20T23:41:49Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -420,6 +481,26 @@ private void terminateSubscriber(@Nullable Throwable cause) {\n             }\n         }\n \n+        private void notifyAllListeners(@Nullable Throwable cause) {\n+            final ChannelFuture future = cause == null ? channel.newSucceededFuture() : channel.newFailedFuture(cause);\n+            GenericFutureListener<?> mayBeListener;\n+            while ((mayBeListener = listenersOnWriteBoundaries.pollFirst()) != null) {\n+                if (mayBeListener != WRITE_BOUNDARY) {\n+                    notifyListener(eventLoop, future, mayBeListener);\n+                }\n+            }\n+        }\n+\n+        private void notifyListenersTillNextWrite(@Nullable Throwable cause) {\n+            Object shdBeWriteBoundary = listenersOnWriteBoundaries.pollFirst();\n+            assert shdBeWriteBoundary == WRITE_BOUNDARY;\n+\n+            final ChannelFuture future = cause == null ? channel.newSucceededFuture() : channel.newFailedFuture(cause);\n+            while (!listenersOnWriteBoundaries.isEmpty() && listenersOnWriteBoundaries.peekFirst() != WRITE_BOUNDARY) {\n+                notifyListener(eventLoop, future, listenersOnWriteBoundaries.removeFirst());", "originalCommit": "6cea4eb2599b9e55326573bfb559d71c0d75e7e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1b98e6117db8f9f4b79578b6cedd68811a811280", "url": "https://github.com/apple/servicetalk/commit/1b98e6117db8f9f4b79578b6cedd68811a811280", "message": "Review comments", "committedDate": "2020-05-21T00:33:06Z", "type": "commit"}]}