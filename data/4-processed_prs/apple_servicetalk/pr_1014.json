{"pr_number": 1014, "pr_title": "Publisher#flatMapMergeSingle potential queue drain visibility issue", "pr_createdAt": "2020-04-14T20:19:04Z", "pr_url": "https://github.com/apple/servicetalk/pull/1014", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNDE3OQ==", "url": "https://github.com/apple/servicetalk/pull/1014#discussion_r408414179", "bodyText": "shouldn't we release in a finally block ?", "author": "normanmaurer", "createdAt": "2020-04-14T20:27:12Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapSingle.java", "diffHunk": "@@ -222,23 +223,31 @@ private void enqueueAndDrain(Object item) {\n             assert s != null;\n \n             if (!pending.offer(item)) {\n-                QueueFullException exception = new QueueFullException(\"pending\");\n-                if (item instanceof TerminalNotification) {\n-                    LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n-                    throw exception;\n-                } else {\n-                    onError0(exception, true, true);\n-                }\n+                enqueueAndDrainFail(item);\n             }\n             drainPending(s);\n         }\n \n         private void drainPending(Subscription subscription) {\n-            long drainedCount = drainSingleConsumerQueue(pending, this::sendToTarget, emittingUpdater, this);\n-            if (drainedCount != 0) {\n+            long drainCount = 0;\n+            for (;;) {\n+                if (!acquirePendingLock(emittingUpdater, this)) {\n+                    break;\n+                }\n+                Object t;\n+                while ((t = pending.poll()) != null) {\n+                    ++drainCount;\n+                    sendToTarget(t);\n+                }\n+                if (releasePendingLock(emittingUpdater, this)) {", "originalCommit": "e9dfa3d2b655dc4d7d1201fda62526237960d5c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQzNDYxNA==", "url": "https://github.com/apple/servicetalk/pull/1014#discussion_r408434614", "bodyText": "good point ... let me make this more robust.", "author": "Scottmitch", "createdAt": "2020-04-14T21:04:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNDE3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcxNzQ0MA==", "url": "https://github.com/apple/servicetalk/pull/1014#discussion_r408717440", "bodyText": "nit: should we use addSuppressed(...) when delayedCause != null", "author": "normanmaurer", "createdAt": "2020-04-15T09:48:02Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapSingle.java", "diffHunk": "@@ -222,29 +224,58 @@ private void enqueueAndDrain(Object item) {\n             assert s != null;\n \n             if (!pending.offer(item)) {\n-                QueueFullException exception = new QueueFullException(\"pending\");\n-                if (item instanceof TerminalNotification) {\n-                    LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n-                    throw exception;\n-                } else {\n-                    onError0(exception, true, true);\n-                }\n+                enqueueAndDrainFail(item);\n             }\n             drainPending(s);\n         }\n \n         private void drainPending(Subscription subscription) {\n-            long drainedCount = drainSingleConsumerQueue(pending, this::sendToTarget, emittingUpdater, this);\n-            if (drainedCount != 0) {\n+            long drainCount = 0;\n+            Throwable delayedCause = null;\n+            while (acquirePendingLock(emittingUpdater, this)) {\n+                try {\n+                    Object t;\n+                    while ((t = pending.poll()) != null) {\n+                        ++drainCount;\n+                        try {\n+                            sendToTarget(t);\n+                        } catch (Throwable cause) {\n+                            if (delayedCause == null) {\n+                                delayedCause = cause;", "originalCommit": "8a525a8eae60877e0a37fa66f020c67588e0fbe7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE3ODk4Ng==", "url": "https://github.com/apple/servicetalk/pull/1014#discussion_r409178986", "bodyText": "lets discuss on #1011 (comment)", "author": "Scottmitch", "createdAt": "2020-04-15T22:48:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcxNzQ0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE1NzQ2NQ==", "url": "https://github.com/apple/servicetalk/pull/1014#discussion_r410157465", "bodyText": "Just wondering why the others need to be public and this can be private ...", "author": "normanmaurer", "createdAt": "2020-04-17T11:17:22Z", "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentUtils.java", "diffHunk": "@@ -31,47 +31,44 @@\n \n     public static final int CONCURRENT_IDLE = 0;\n     public static final int CONCURRENT_EMITTING = 1;\n+    private static final int CONCURRENT_PENDING = 2;", "originalCommit": "da043d3580ecb4737eef739b272693358f074539", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MDcyMQ==", "url": "https://github.com/apple/servicetalk/pull/1014#discussion_r410350721", "bodyText": "its a good question. I would like to investigate making them all private and instead expose lock methods, but didn't want to expand the scope of this PR: #1023", "author": "Scottmitch", "createdAt": "2020-04-17T16:57:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE1NzQ2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjExNzE2MQ==", "url": "https://github.com/apple/servicetalk/pull/1014#discussion_r412117161", "bodyText": "sounds good...", "author": "normanmaurer", "createdAt": "2020-04-21T11:52:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE1NzQ2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE1Nzg2OQ==", "url": "https://github.com/apple/servicetalk/pull/1014#discussion_r410157869", "bodyText": "nit: ...DrainFailed ?", "author": "normanmaurer", "createdAt": "2020-04-17T11:18:19Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapSingle.java", "diffHunk": "@@ -222,29 +231,62 @@ private void enqueueAndDrain(Object item) {\n             assert s != null;\n \n             if (!pending.offer(item)) {\n-                QueueFullException exception = new QueueFullException(\"pending\");\n-                if (item instanceof TerminalNotification) {\n-                    LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n-                    throw exception;\n-                } else {\n-                    onError0(exception, true, true);\n-                }\n+                enqueueAndDrainFail(item);\n             }\n             drainPending(s);\n         }\n \n+        @SuppressWarnings(\"ContinueOrBreakFromFinallyBlock\")\n         private void drainPending(Subscription subscription) {\n-            long drainedCount = drainSingleConsumerQueue(pending, this::sendToTarget, emittingUpdater, this);\n-            if (drainedCount != 0) {\n+            long drainCount = 0;\n+            Throwable delayedCause = null;\n+            while (acquirePendingLock(emittingUpdater, this)) {\n+                try {\n+                    Object t;\n+                    while ((t = pending.poll()) != null) {\n+                        ++drainCount;\n+                        try {\n+                            sendToTarget(t);\n+                        } catch (Throwable cause) {\n+                            if (delayedCause == null) {\n+                                delayedCause = cause;\n+                            }\n+                        }\n+                    }\n+                } finally {\n+                    if (releasePendingLock(emittingUpdater, this)) {\n+                        // break in finally isn't ideal but we catch Throwable above so we won't modify exception\n+                        // control flow. Also if we didn't catch Throwable and attempt to req-acquire the lock would be\n+                        // poisoned as the owner needs to re-acquire as long as release fails.\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            if (drainCount != 0) {\n                 // We ignore overflow here because once we get to this extreme, we won't be able to account for more\n                 // data anyways.\n-                sourceEmittedUpdater.addAndGet(this, drainedCount);\n+                sourceEmittedUpdater.addAndGet(this, drainCount);\n                 int actualSourceRequestN = calculateSourceRequested(requestedUpdater, sourceRequestedUpdater,\n                         sourceEmittedUpdater, source.maxConcurrency, this);\n                 if (actualSourceRequestN != 0) {\n                     subscription.request(actualSourceRequestN);\n                 }\n             }\n+\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void enqueueAndDrainFail(Object item) {", "originalCommit": "da043d3580ecb4737eef739b272693358f074539", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b65d07d1426d1378179889947ab2d439ceb6d8b9", "url": "https://github.com/apple/servicetalk/commit/b65d07d1426d1378179889947ab2d439ceb6d8b9", "message": "Publisher#flatMapMergeSingle potential queue drain visibility issue\n\nMotivation:\nPublisher#flatMapMergeSingle uses the\nConcurrentUtils#drainSingleConsumerQueue to drain the pending signal\nqueue. However this method relies upon the queue's isEmpty() method\nproviding visibility as to if an item has been inserted into the queue\nsince the last poll information. We should avoid leveraging the queue's\nvisibility guarantees (which may not hold) and instead leverage the\nconcurrency avoidance for single consumer drain to provide visibility.\n\nModifications:\n- Remove ConcurrentUtils#drainSingleConsumerQueue\n- Introduce ConcurrentUtils#acquirePendingLock and releasePendingLock\nmethods that allow for notification if another thread attempted to\nacquire the lock while it was being held. If all threads that publish\nand event (e.g. insert into a queue) use this lock it can ensure no\nconcurrency and visibility.\n\nResult:\nNo dependency on queue visibility semantics for draining the signal\nqueue in Publisher#flatMapMergeSingle.", "committedDate": "2020-04-27T22:59:07Z", "type": "forcePushed"}, {"oid": "3b79e1bfe466f985ba3a373126af2a413df0f66c", "url": "https://github.com/apple/servicetalk/commit/3b79e1bfe466f985ba3a373126af2a413df0f66c", "message": "Publisher#flatMapMergeSingle potential queue drain visibility issue\n\nMotivation:\nPublisher#flatMapMergeSingle uses the\nConcurrentUtils#drainSingleConsumerQueue to drain the pending signal\nqueue. However this method relies upon the queue's isEmpty() method\nproviding visibility as to if an item has been inserted into the queue\nsince the last poll information. We should avoid leveraging the queue's\nvisibility guarantees (which may not hold) and instead leverage the\nconcurrency avoidance for single consumer drain to provide visibility.\n\nModifications:\n- Remove ConcurrentUtils#drainSingleConsumerQueue\n- Introduce ConcurrentUtils#acquirePendingLock and releasePendingLock\nmethods that allow for notification if another thread attempted to\nacquire the lock while it was being held. If all threads that publish\nand event (e.g. insert into a queue) use this lock it can ensure no\nconcurrency and visibility.\n\nResult:\nNo dependency on queue visibility semantics for draining the signal\nqueue in Publisher#flatMapMergeSingle.", "committedDate": "2020-04-28T04:01:28Z", "type": "forcePushed"}, {"oid": "cc5dd371da29fd90fd333d6604bd9a4bcd7bc0ff", "url": "https://github.com/apple/servicetalk/commit/cc5dd371da29fd90fd333d6604bd9a4bcd7bc0ff", "message": "Publisher#flatMapMergeSingle potential queue drain visibility issue\n\nMotivation:\nPublisher#flatMapMergeSingle uses the\nConcurrentUtils#drainSingleConsumerQueue to drain the pending signal\nqueue. However this method relies upon the queue's isEmpty() method\nproviding visibility as to if an item has been inserted into the queue\nsince the last poll information. We should avoid leveraging the queue's\nvisibility guarantees (which may not hold) and instead leverage the\nconcurrency avoidance for single consumer drain to provide visibility.\n\nModifications:\n- Remove ConcurrentUtils#drainSingleConsumerQueue\n- Introduce ConcurrentUtils#acquirePendingLock and releasePendingLock\nmethods that allow for notification if another thread attempted to\nacquire the lock while it was being held. If all threads that publish\nand event (e.g. insert into a queue) use this lock it can ensure no\nconcurrency and visibility.\n\nResult:\nNo dependency on queue visibility semantics for draining the signal\nqueue in Publisher#flatMapMergeSingle.", "committedDate": "2020-04-28T04:02:23Z", "type": "forcePushed"}, {"oid": "550413afb290968388de8599cd729a248024a68b", "url": "https://github.com/apple/servicetalk/commit/550413afb290968388de8599cd729a248024a68b", "message": "Publisher#flatMapMergeSingle potential queue drain visibility issue\n\nMotivation:\nPublisher#flatMapMergeSingle uses the\nConcurrentUtils#drainSingleConsumerQueue to drain the pending signal\nqueue. However this method relies upon the queue's isEmpty() method\nproviding visibility as to if an item has been inserted into the queue\nsince the last poll information. We should avoid leveraging the queue's\nvisibility guarantees (which may not hold) and instead leverage the\nconcurrency avoidance for single consumer drain to provide visibility.\n\nModifications:\n- Remove ConcurrentUtils#drainSingleConsumerQueue\n- Introduce ConcurrentUtils#acquirePendingLock and releasePendingLock\nmethods that allow for notification if another thread attempted to\nacquire the lock while it was being held. If all threads that publish\nand event (e.g. insert into a queue) use this lock it can ensure no\nconcurrency and visibility.\n\nResult:\nNo dependency on queue visibility semantics for draining the signal\nqueue in Publisher#flatMapMergeSingle.", "committedDate": "2020-05-01T01:16:52Z", "type": "commit"}, {"oid": "550413afb290968388de8599cd729a248024a68b", "url": "https://github.com/apple/servicetalk/commit/550413afb290968388de8599cd729a248024a68b", "message": "Publisher#flatMapMergeSingle potential queue drain visibility issue\n\nMotivation:\nPublisher#flatMapMergeSingle uses the\nConcurrentUtils#drainSingleConsumerQueue to drain the pending signal\nqueue. However this method relies upon the queue's isEmpty() method\nproviding visibility as to if an item has been inserted into the queue\nsince the last poll information. We should avoid leveraging the queue's\nvisibility guarantees (which may not hold) and instead leverage the\nconcurrency avoidance for single consumer drain to provide visibility.\n\nModifications:\n- Remove ConcurrentUtils#drainSingleConsumerQueue\n- Introduce ConcurrentUtils#acquirePendingLock and releasePendingLock\nmethods that allow for notification if another thread attempted to\nacquire the lock while it was being held. If all threads that publish\nand event (e.g. insert into a queue) use this lock it can ensure no\nconcurrency and visibility.\n\nResult:\nNo dependency on queue visibility semantics for draining the signal\nqueue in Publisher#flatMapMergeSingle.", "committedDate": "2020-05-01T01:16:52Z", "type": "forcePushed"}]}