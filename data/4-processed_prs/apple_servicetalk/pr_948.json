{"pr_number": 948, "pr_title": "Reduce probability of LB selecting an unusable connection", "pr_createdAt": "2020-02-25T06:04:03Z", "pr_url": "https://github.com/apple/servicetalk/pull/948", "timeline": [{"oid": "5d989b1e5e547946b9161fcc457520bf3c6d68ee", "url": "https://github.com/apple/servicetalk/commit/5d989b1e5e547946b9161fcc457520bf3c6d68ee", "message": "Reduce probability of LB selecting an unusable connection\n\n__Motivation__\n\n`NettyChannelPublisher` closes the connection if it sees a `cancel()` before all data for the current `Subscriber` is read. However, the client layer makes the connection eligible for selection by load balancer if it sees a `cancel()` being unaware that the connection MAY be eventually closed by the transport. This creates a race condition where load balancer may select a connection which is going to be closed.\n\n__Modification__\n\nPessimistically assume that if we see a `cancel()` for a request, transport will close the connection so force close the connection. This is pessimistic because it may so happen that completion of read is racing with the cancel and transport may see read completion before cancel and hence not close the connection. At the client layer (where we control LB selection eligibility), it is impossible to discern whether transport will close the connection or not so the safest option is to assume closure. This reduces the possibility of selecting an unusable connection hence the pains associated with debugging those situations at the cost of closing the connection.\nFor H2, this will be a stream, which is cheap to close but for H1 this will close the actual connection.\n\n__Result__\n\nReduce possibility of selecting an unusable connection. As `cancel()` is not the only reason for closure, we still have the case where a connection can be selected only to be closed later but we reduce that probability with this change.", "committedDate": "2020-02-25T06:03:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY3NDMyOA==", "url": "https://github.com/apple/servicetalk/pull/948#discussion_r383674328", "bodyText": "This was dead code.", "author": "NiteshKant", "createdAt": "2020-02-25T06:04:27Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/ConcurrentRequestsHttpConnectionFilter.java", "diffHunk": "@@ -1,149 +0,0 @@\n-/*\n- * Copyright \u00a9 2018-2019 Apple Inc. and the ServiceTalk project authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package io.servicetalk.http.netty;\n-\n-import io.servicetalk.client.api.ConnectionClosedException;\n-import io.servicetalk.client.api.internal.MaxRequestLimitExceededRejectedSubscribeException;\n-import io.servicetalk.client.api.internal.RequestConcurrencyController;\n-import io.servicetalk.concurrent.api.Completable;\n-import io.servicetalk.concurrent.api.Publisher;\n-import io.servicetalk.concurrent.api.Single;\n-import io.servicetalk.concurrent.api.internal.SubscribableSingle;\n-import io.servicetalk.concurrent.internal.LatestValueSubscriber;\n-import io.servicetalk.http.api.FilterableStreamingHttpConnection;\n-import io.servicetalk.http.api.HttpEventKey;\n-import io.servicetalk.http.api.HttpExecutionContext;\n-import io.servicetalk.http.api.HttpExecutionStrategy;\n-import io.servicetalk.http.api.HttpRequestMethod;\n-import io.servicetalk.http.api.StreamingHttpRequest;\n-import io.servicetalk.http.api.StreamingHttpResponse;\n-import io.servicetalk.http.api.StreamingHttpResponseFactory;\n-import io.servicetalk.http.utils.BeforeFinallyOnHttpResponseOperator;\n-import io.servicetalk.transport.api.ConnectionContext;\n-\n-import static io.servicetalk.client.api.internal.RequestConcurrencyControllers.newController;\n-import static io.servicetalk.client.api.internal.RequestConcurrencyControllers.newSingleController;\n-import static io.servicetalk.concurrent.Cancellable.IGNORE_CANCEL;\n-import static io.servicetalk.concurrent.api.Executors.immediate;\n-import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n-import static io.servicetalk.http.api.HttpEventKey.MAX_CONCURRENCY;\n-\n-final class ConcurrentRequestsHttpConnectionFilter implements FilterableStreamingHttpConnection {", "originalCommit": "5d989b1e5e547946b9161fcc457520bf3c6d68ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}