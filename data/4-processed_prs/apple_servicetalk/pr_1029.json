{"pr_number": 1029, "pr_title": "Introduce HTTP/2 keep alive", "pr_createdAt": "2020-04-22T05:10:00Z", "pr_url": "https://github.com/apple/servicetalk/pull/1029", "timeline": [{"oid": "e7ea8b7ff48bd46e37cfc158417da51a3cb7ae0d", "url": "https://github.com/apple/servicetalk/commit/e7ea8b7ff48bd46e37cfc158417da51a3cb7ae0d", "message": "Introduce HTTP/2 keep alive\n\n__Motivation__\n\nHTTP/2 PING frames are useful to keep a connection alive relatively cheaply in presence of long running streams. ServiceTalk should support adding this functionality for both clients and servers.\n\n__Modification__\n\n- Add `KeepAlivePolicy` to `H2ProtocolConfig` that can be configured to enable keep-alive behavior on either clients or servers. Following features are provided:\n    -- Specify an idleness threshold, after which a PING frame will be sent on the connection to detect liveness.\n    -- Specify an ack timeout, within which we expect an ack for the sent PING. If no ack is received, the connection is closed.\n    -- Specify whether PING frames should be sent even when there are no active streams. This defaults to `false`.\n\n__Result__\n\nKeep alive behavior can be enabled for either client or server.", "committedDate": "2020-04-22T05:03:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzAzNzMyMQ==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413037321", "bodyText": "nit: final", "author": "normanmaurer", "createdAt": "2020-04-22T14:34:33Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/DefaultKeepAlivePolicy.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.http.netty.H2ProtocolConfig.KeepAlivePolicy;\n+\n+import java.time.Duration;\n+\n+import static java.time.Duration.ofSeconds;\n+\n+class DefaultKeepAlivePolicy implements KeepAlivePolicy {", "originalCommit": "e7ea8b7ff48bd46e37cfc158417da51a3cb7ae0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzAzNzcxNA==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413037714", "bodyText": "nit: requireNonNull(...) for both Durations.", "author": "normanmaurer", "createdAt": "2020-04-22T14:35:04Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/DefaultKeepAlivePolicy.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.http.netty.H2ProtocolConfig.KeepAlivePolicy;\n+\n+import java.time.Duration;\n+\n+import static java.time.Duration.ofSeconds;\n+\n+class DefaultKeepAlivePolicy implements KeepAlivePolicy {\n+    static final Duration DEFAULT_IDLE_DURATION = ofSeconds(30);\n+    static final Duration DEFAULT_ACK_TIMEOUT = ofSeconds(30);\n+    static final boolean DEFAULT_WITHOUT_ACTIVE_STREAMS = false;\n+    private final Duration idleDuration;\n+    private final Duration ackTimeout;\n+    private final boolean withoutActiveStreams;\n+\n+    DefaultKeepAlivePolicy() {\n+        this(DEFAULT_IDLE_DURATION, DEFAULT_ACK_TIMEOUT, false);\n+    }\n+\n+    DefaultKeepAlivePolicy(final Duration idleDuration, final Duration ackTimeout, final boolean withoutActiveStreams) {\n+        this.idleDuration = idleDuration;\n+        this.ackTimeout = ackTimeout;", "originalCommit": "e7ea8b7ff48bd46e37cfc158417da51a3cb7ae0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzAzOTQwNw==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413039407", "bodyText": "nit: s/which//", "author": "normanmaurer", "createdAt": "2020-04-22T14:36:58Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H2ProtocolConfig.java", "diffHunk": "@@ -53,4 +54,46 @@ default String alpnId() {\n      */\n     @Nullable\n     String frameLoggerName();\n+\n+    /**\n+     * Configured {@link KeepAlivePolicy}.\n+     *\n+     * @return configured {@link KeepAlivePolicy} or {@code null} if none is configured.\n+     */\n+    @Nullable\n+    KeepAlivePolicy keepAlivePolicy();\n+\n+    /**\n+     * A policy for sending <a href=\"https://tools.ietf.org/html/rfc7540#page-42\">PING frames</a> to the peer.\n+     */\n+    interface KeepAlivePolicy {\n+        /**\n+         * {@link Duration} of time the connection has to be idle before which a", "originalCommit": "e7ea8b7ff48bd46e37cfc158417da51a3cb7ae0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA0MjM3NA==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413042374", "bodyText": "if java would just have better enums like Swift... This makes me sad :/", "author": "normanmaurer", "createdAt": "2020-04-22T14:40:33Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/KeepAliveManager.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.http.netty.H2ProtocolConfig.KeepAlivePolicy;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.DefaultHttp2GoAwayFrame;\n+import io.netty.handler.codec.http2.DefaultHttp2PingFrame;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.concurrent.Future;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.http2.Http2Error.NO_ERROR;\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_ACK_TIMEOUT;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+/**\n+ * An implementation of {@link KeepAlivePolicy} per {@link Channel}.\n+ */\n+final class KeepAliveManager {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KeepAliveManager.class);\n+    private static final AtomicIntegerFieldUpdater<KeepAliveManager> activeChildChannelsUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(KeepAliveManager.class, \"activeChildChannels\");\n+    private static final long GRACEFUL_CLOSE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final long KEEP_ALIVE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final Object CLOSED = new Object();\n+    private static final Object GRACEFUL_CLOSE_START = new Object();\n+    private static final Object GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT = new Object();\n+    private static final Object KEEP_ALIVE_ACK_PENDING = new Object();\n+    private static final Object KEEP_ALIVE_ACK_TIMEDOUT = new Object();\n+\n+    private volatile int activeChildChannels;\n+\n+    private final Channel channel;\n+    private final long pingAckTimeoutMillis;\n+    @Nullable\n+    private final boolean disallowKeepAliveWithoutActiveStreams;\n+    private final Scheduler scheduler;\n+\n+    // below state should only be accessed from eventloop\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if graceful close has not started.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_START} if graceful close process has been initiated.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent to measure RTT.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT} if we have sent the second go away frame.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object gracefulCloseState;", "originalCommit": "e7ea8b7ff48bd46e37cfc158417da51a3cb7ae0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA0NTQ4NA==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413045484", "bodyText": "I would just catch RejectExecutionException and let the rest bubble up.", "author": "normanmaurer", "createdAt": "2020-04-22T14:44:01Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/KeepAliveManager.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.http.netty.H2ProtocolConfig.KeepAlivePolicy;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.DefaultHttp2GoAwayFrame;\n+import io.netty.handler.codec.http2.DefaultHttp2PingFrame;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.concurrent.Future;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.http2.Http2Error.NO_ERROR;\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_ACK_TIMEOUT;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+/**\n+ * An implementation of {@link KeepAlivePolicy} per {@link Channel}.\n+ */\n+final class KeepAliveManager {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KeepAliveManager.class);\n+    private static final AtomicIntegerFieldUpdater<KeepAliveManager> activeChildChannelsUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(KeepAliveManager.class, \"activeChildChannels\");\n+    private static final long GRACEFUL_CLOSE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final long KEEP_ALIVE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final Object CLOSED = new Object();\n+    private static final Object GRACEFUL_CLOSE_START = new Object();\n+    private static final Object GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT = new Object();\n+    private static final Object KEEP_ALIVE_ACK_PENDING = new Object();\n+    private static final Object KEEP_ALIVE_ACK_TIMEDOUT = new Object();\n+\n+    private volatile int activeChildChannels;\n+\n+    private final Channel channel;\n+    private final long pingAckTimeoutMillis;\n+    @Nullable\n+    private final boolean disallowKeepAliveWithoutActiveStreams;\n+    private final Scheduler scheduler;\n+\n+    // below state should only be accessed from eventloop\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if graceful close has not started.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_START} if graceful close process has been initiated.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent to measure RTT.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT} if we have sent the second go away frame.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object gracefulCloseState;\n+\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if keep-alive PING process is not started.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_PENDING} if a keep-alive PING has been sent but ack is not received.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_TIMEDOUT} if we fail to receive a PING ack for the configured timeout.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object keepAliveState;\n+\n+    KeepAliveManager(final Channel channel, @Nullable final KeepAlivePolicy keepAlivePolicy) {\n+        this(channel, keepAlivePolicy, (task, delayInMillis) ->\n+                channel.eventLoop().schedule(task, delayInMillis, MILLISECONDS),\n+                (ch, idlenessThresholdMillis, onIdle) -> ch.pipeline().addLast(\n+                        new IdleStateHandler(idlenessThresholdMillis, idlenessThresholdMillis, 0) {\n+                            @Override\n+                            protected void channelIdle(final ChannelHandlerContext ctx, final IdleStateEvent evt) {\n+                                onIdle.run();\n+                            }\n+                        }));\n+    }\n+\n+    KeepAliveManager(final Channel channel, @Nullable final KeepAlivePolicy keepAlivePolicy,\n+                     final Scheduler scheduler, final IdlenessDetector idlenessDetector) {\n+        this.channel = channel;\n+        this.scheduler = scheduler;\n+        if (keepAlivePolicy != null) {\n+            disallowKeepAliveWithoutActiveStreams = !keepAlivePolicy.withoutActiveStreams();\n+            pingAckTimeoutMillis = keepAlivePolicy.ackTimeout().toMillis();\n+            int idleInSeconds = (int) keepAlivePolicy.idleDuration().getSeconds();\n+            idlenessDetector.configure(channel, idleInSeconds, this::channelIdle);\n+        } else {\n+            disallowKeepAliveWithoutActiveStreams = false;\n+            pingAckTimeoutMillis = DEFAULT_ACK_TIMEOUT.toMillis();\n+        }\n+    }\n+\n+    void pingReceived(final Http2PingFrame pingFrame) {\n+        assert channel.eventLoop().inEventLoop();\n+\n+        if (pingFrame.ack()) {\n+            long pingAckContent = pingFrame.content();\n+            if (pingAckContent == GRACEFUL_CLOSE_PING_CONTENT) {\n+                LOGGER.debug(\"channel={}, graceful close ping ack received.\", channel);\n+                cancelIfStateIsAFuture(gracefulCloseState);\n+                gracefulCloseWriteSecondGoAway();\n+            } else if (pingAckContent == KEEP_ALIVE_PING_CONTENT) {\n+                cancelIfStateIsAFuture(keepAliveState);\n+                keepAliveState = null;\n+            }\n+        } else {\n+            // Send an ack for the received ping\n+            channel.writeAndFlush(new DefaultHttp2PingFrame(pingFrame.content(), true));\n+        }\n+    }\n+\n+    void trackActiveStream(final Channel streamChannel) {\n+        activeChildChannelsUpdater.incrementAndGet(this);\n+        streamChannel.closeFuture().addListener(f -> {\n+            activeChildChannelsUpdater.decrementAndGet(this);\n+            if (activeChildChannels == 0 && gracefulCloseState == GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT) {\n+                close0();\n+            }\n+        });\n+    }\n+\n+    void channelClosed() {\n+        assert channel.eventLoop().inEventLoop();\n+\n+        cancelIfStateIsAFuture(gracefulCloseState);\n+        cancelIfStateIsAFuture(keepAliveState);\n+        gracefulCloseState = CLOSED;\n+        keepAliveState = CLOSED;\n+    }\n+\n+    void initiateGracefulClose(final Runnable whenInitiated) {\n+        EventLoop eventLoop = channel.eventLoop();\n+        if (eventLoop.inEventLoop()) {\n+            doCloseAsyncGracefully0(whenInitiated);\n+        } else {\n+            try {\n+                eventLoop.execute(() -> doCloseAsyncGracefully0(whenInitiated));\n+            } catch (Throwable cause) {", "originalCommit": "e7ea8b7ff48bd46e37cfc158417da51a3cb7ae0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA0NTg2OQ==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413045869", "bodyText": "nit: you could merge the if blocks", "author": "normanmaurer", "createdAt": "2020-04-22T14:44:27Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/KeepAliveManager.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.http.netty.H2ProtocolConfig.KeepAlivePolicy;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.DefaultHttp2GoAwayFrame;\n+import io.netty.handler.codec.http2.DefaultHttp2PingFrame;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.concurrent.Future;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.http2.Http2Error.NO_ERROR;\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_ACK_TIMEOUT;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+/**\n+ * An implementation of {@link KeepAlivePolicy} per {@link Channel}.\n+ */\n+final class KeepAliveManager {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KeepAliveManager.class);\n+    private static final AtomicIntegerFieldUpdater<KeepAliveManager> activeChildChannelsUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(KeepAliveManager.class, \"activeChildChannels\");\n+    private static final long GRACEFUL_CLOSE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final long KEEP_ALIVE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final Object CLOSED = new Object();\n+    private static final Object GRACEFUL_CLOSE_START = new Object();\n+    private static final Object GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT = new Object();\n+    private static final Object KEEP_ALIVE_ACK_PENDING = new Object();\n+    private static final Object KEEP_ALIVE_ACK_TIMEDOUT = new Object();\n+\n+    private volatile int activeChildChannels;\n+\n+    private final Channel channel;\n+    private final long pingAckTimeoutMillis;\n+    @Nullable\n+    private final boolean disallowKeepAliveWithoutActiveStreams;\n+    private final Scheduler scheduler;\n+\n+    // below state should only be accessed from eventloop\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if graceful close has not started.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_START} if graceful close process has been initiated.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent to measure RTT.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT} if we have sent the second go away frame.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object gracefulCloseState;\n+\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if keep-alive PING process is not started.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_PENDING} if a keep-alive PING has been sent but ack is not received.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_TIMEDOUT} if we fail to receive a PING ack for the configured timeout.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object keepAliveState;\n+\n+    KeepAliveManager(final Channel channel, @Nullable final KeepAlivePolicy keepAlivePolicy) {\n+        this(channel, keepAlivePolicy, (task, delayInMillis) ->\n+                channel.eventLoop().schedule(task, delayInMillis, MILLISECONDS),\n+                (ch, idlenessThresholdMillis, onIdle) -> ch.pipeline().addLast(\n+                        new IdleStateHandler(idlenessThresholdMillis, idlenessThresholdMillis, 0) {\n+                            @Override\n+                            protected void channelIdle(final ChannelHandlerContext ctx, final IdleStateEvent evt) {\n+                                onIdle.run();\n+                            }\n+                        }));\n+    }\n+\n+    KeepAliveManager(final Channel channel, @Nullable final KeepAlivePolicy keepAlivePolicy,\n+                     final Scheduler scheduler, final IdlenessDetector idlenessDetector) {\n+        this.channel = channel;\n+        this.scheduler = scheduler;\n+        if (keepAlivePolicy != null) {\n+            disallowKeepAliveWithoutActiveStreams = !keepAlivePolicy.withoutActiveStreams();\n+            pingAckTimeoutMillis = keepAlivePolicy.ackTimeout().toMillis();\n+            int idleInSeconds = (int) keepAlivePolicy.idleDuration().getSeconds();\n+            idlenessDetector.configure(channel, idleInSeconds, this::channelIdle);\n+        } else {\n+            disallowKeepAliveWithoutActiveStreams = false;\n+            pingAckTimeoutMillis = DEFAULT_ACK_TIMEOUT.toMillis();\n+        }\n+    }\n+\n+    void pingReceived(final Http2PingFrame pingFrame) {\n+        assert channel.eventLoop().inEventLoop();\n+\n+        if (pingFrame.ack()) {\n+            long pingAckContent = pingFrame.content();\n+            if (pingAckContent == GRACEFUL_CLOSE_PING_CONTENT) {\n+                LOGGER.debug(\"channel={}, graceful close ping ack received.\", channel);\n+                cancelIfStateIsAFuture(gracefulCloseState);\n+                gracefulCloseWriteSecondGoAway();\n+            } else if (pingAckContent == KEEP_ALIVE_PING_CONTENT) {\n+                cancelIfStateIsAFuture(keepAliveState);\n+                keepAliveState = null;\n+            }\n+        } else {\n+            // Send an ack for the received ping\n+            channel.writeAndFlush(new DefaultHttp2PingFrame(pingFrame.content(), true));\n+        }\n+    }\n+\n+    void trackActiveStream(final Channel streamChannel) {\n+        activeChildChannelsUpdater.incrementAndGet(this);\n+        streamChannel.closeFuture().addListener(f -> {\n+            activeChildChannelsUpdater.decrementAndGet(this);\n+            if (activeChildChannels == 0 && gracefulCloseState == GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT) {\n+                close0();\n+            }\n+        });\n+    }\n+\n+    void channelClosed() {\n+        assert channel.eventLoop().inEventLoop();\n+\n+        cancelIfStateIsAFuture(gracefulCloseState);\n+        cancelIfStateIsAFuture(keepAliveState);\n+        gracefulCloseState = CLOSED;\n+        keepAliveState = CLOSED;\n+    }\n+\n+    void initiateGracefulClose(final Runnable whenInitiated) {\n+        EventLoop eventLoop = channel.eventLoop();\n+        if (eventLoop.inEventLoop()) {\n+            doCloseAsyncGracefully0(whenInitiated);\n+        } else {\n+            try {\n+                eventLoop.execute(() -> doCloseAsyncGracefully0(whenInitiated));\n+            } catch (Throwable cause) {\n+                close0();\n+                LOGGER.warn(\"channel={} EventLoop rejected a task for graceful shutdown, force closing connection\",\n+                        channel, cause);\n+            }\n+        }\n+    }\n+\n+    void channelIdle() {\n+        assert channel.eventLoop().inEventLoop();\n+\n+        if (keepAliveState == CLOSED) {\n+            return;\n+        }\n+        if (activeChildChannels == 0 && disallowKeepAliveWithoutActiveStreams) {", "originalCommit": "e7ea8b7ff48bd46e37cfc158417da51a3cb7ae0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA0NjYxMQ==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413046611", "bodyText": "consider caching the ChannelFutureListener to reduce GC pressure if you need to write the next ping again", "author": "normanmaurer", "createdAt": "2020-04-22T14:45:20Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/KeepAliveManager.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.http.netty.H2ProtocolConfig.KeepAlivePolicy;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.DefaultHttp2GoAwayFrame;\n+import io.netty.handler.codec.http2.DefaultHttp2PingFrame;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.concurrent.Future;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.http2.Http2Error.NO_ERROR;\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_ACK_TIMEOUT;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+/**\n+ * An implementation of {@link KeepAlivePolicy} per {@link Channel}.\n+ */\n+final class KeepAliveManager {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KeepAliveManager.class);\n+    private static final AtomicIntegerFieldUpdater<KeepAliveManager> activeChildChannelsUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(KeepAliveManager.class, \"activeChildChannels\");\n+    private static final long GRACEFUL_CLOSE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final long KEEP_ALIVE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final Object CLOSED = new Object();\n+    private static final Object GRACEFUL_CLOSE_START = new Object();\n+    private static final Object GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT = new Object();\n+    private static final Object KEEP_ALIVE_ACK_PENDING = new Object();\n+    private static final Object KEEP_ALIVE_ACK_TIMEDOUT = new Object();\n+\n+    private volatile int activeChildChannels;\n+\n+    private final Channel channel;\n+    private final long pingAckTimeoutMillis;\n+    @Nullable\n+    private final boolean disallowKeepAliveWithoutActiveStreams;\n+    private final Scheduler scheduler;\n+\n+    // below state should only be accessed from eventloop\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if graceful close has not started.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_START} if graceful close process has been initiated.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent to measure RTT.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT} if we have sent the second go away frame.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object gracefulCloseState;\n+\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if keep-alive PING process is not started.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_PENDING} if a keep-alive PING has been sent but ack is not received.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_TIMEDOUT} if we fail to receive a PING ack for the configured timeout.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object keepAliveState;\n+\n+    KeepAliveManager(final Channel channel, @Nullable final KeepAlivePolicy keepAlivePolicy) {\n+        this(channel, keepAlivePolicy, (task, delayInMillis) ->\n+                channel.eventLoop().schedule(task, delayInMillis, MILLISECONDS),\n+                (ch, idlenessThresholdMillis, onIdle) -> ch.pipeline().addLast(\n+                        new IdleStateHandler(idlenessThresholdMillis, idlenessThresholdMillis, 0) {\n+                            @Override\n+                            protected void channelIdle(final ChannelHandlerContext ctx, final IdleStateEvent evt) {\n+                                onIdle.run();\n+                            }\n+                        }));\n+    }\n+\n+    KeepAliveManager(final Channel channel, @Nullable final KeepAlivePolicy keepAlivePolicy,\n+                     final Scheduler scheduler, final IdlenessDetector idlenessDetector) {\n+        this.channel = channel;\n+        this.scheduler = scheduler;\n+        if (keepAlivePolicy != null) {\n+            disallowKeepAliveWithoutActiveStreams = !keepAlivePolicy.withoutActiveStreams();\n+            pingAckTimeoutMillis = keepAlivePolicy.ackTimeout().toMillis();\n+            int idleInSeconds = (int) keepAlivePolicy.idleDuration().getSeconds();\n+            idlenessDetector.configure(channel, idleInSeconds, this::channelIdle);\n+        } else {\n+            disallowKeepAliveWithoutActiveStreams = false;\n+            pingAckTimeoutMillis = DEFAULT_ACK_TIMEOUT.toMillis();\n+        }\n+    }\n+\n+    void pingReceived(final Http2PingFrame pingFrame) {\n+        assert channel.eventLoop().inEventLoop();\n+\n+        if (pingFrame.ack()) {\n+            long pingAckContent = pingFrame.content();\n+            if (pingAckContent == GRACEFUL_CLOSE_PING_CONTENT) {\n+                LOGGER.debug(\"channel={}, graceful close ping ack received.\", channel);\n+                cancelIfStateIsAFuture(gracefulCloseState);\n+                gracefulCloseWriteSecondGoAway();\n+            } else if (pingAckContent == KEEP_ALIVE_PING_CONTENT) {\n+                cancelIfStateIsAFuture(keepAliveState);\n+                keepAliveState = null;\n+            }\n+        } else {\n+            // Send an ack for the received ping\n+            channel.writeAndFlush(new DefaultHttp2PingFrame(pingFrame.content(), true));\n+        }\n+    }\n+\n+    void trackActiveStream(final Channel streamChannel) {\n+        activeChildChannelsUpdater.incrementAndGet(this);\n+        streamChannel.closeFuture().addListener(f -> {\n+            activeChildChannelsUpdater.decrementAndGet(this);\n+            if (activeChildChannels == 0 && gracefulCloseState == GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT) {\n+                close0();\n+            }\n+        });\n+    }\n+\n+    void channelClosed() {\n+        assert channel.eventLoop().inEventLoop();\n+\n+        cancelIfStateIsAFuture(gracefulCloseState);\n+        cancelIfStateIsAFuture(keepAliveState);\n+        gracefulCloseState = CLOSED;\n+        keepAliveState = CLOSED;\n+    }\n+\n+    void initiateGracefulClose(final Runnable whenInitiated) {\n+        EventLoop eventLoop = channel.eventLoop();\n+        if (eventLoop.inEventLoop()) {\n+            doCloseAsyncGracefully0(whenInitiated);\n+        } else {\n+            try {\n+                eventLoop.execute(() -> doCloseAsyncGracefully0(whenInitiated));\n+            } catch (Throwable cause) {\n+                close0();\n+                LOGGER.warn(\"channel={} EventLoop rejected a task for graceful shutdown, force closing connection\",\n+                        channel, cause);\n+            }\n+        }\n+    }\n+\n+    void channelIdle() {\n+        assert channel.eventLoop().inEventLoop();\n+\n+        if (keepAliveState == CLOSED) {\n+            return;\n+        }\n+        if (activeChildChannels == 0 && disallowKeepAliveWithoutActiveStreams) {\n+            return;\n+        }\n+        // idleness detected for the first time, send a ping to detect closure, if any.\n+        keepAliveState = KEEP_ALIVE_ACK_PENDING;\n+        channel.writeAndFlush(new DefaultHttp2PingFrame(KEEP_ALIVE_PING_CONTENT, false))\n+                .addListener(future -> {", "originalCommit": "e7ea8b7ff48bd46e37cfc158417da51a3cb7ae0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA0NzM2OQ==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413047369", "bodyText": "consider rethrow if Error.", "author": "normanmaurer", "createdAt": "2020-04-22T14:46:11Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/KeepAliveManager.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.http.netty.H2ProtocolConfig.KeepAlivePolicy;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.DefaultHttp2GoAwayFrame;\n+import io.netty.handler.codec.http2.DefaultHttp2PingFrame;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.concurrent.Future;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.http2.Http2Error.NO_ERROR;\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_ACK_TIMEOUT;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+/**\n+ * An implementation of {@link KeepAlivePolicy} per {@link Channel}.\n+ */\n+final class KeepAliveManager {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KeepAliveManager.class);\n+    private static final AtomicIntegerFieldUpdater<KeepAliveManager> activeChildChannelsUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(KeepAliveManager.class, \"activeChildChannels\");\n+    private static final long GRACEFUL_CLOSE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final long KEEP_ALIVE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final Object CLOSED = new Object();\n+    private static final Object GRACEFUL_CLOSE_START = new Object();\n+    private static final Object GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT = new Object();\n+    private static final Object KEEP_ALIVE_ACK_PENDING = new Object();\n+    private static final Object KEEP_ALIVE_ACK_TIMEDOUT = new Object();\n+\n+    private volatile int activeChildChannels;\n+\n+    private final Channel channel;\n+    private final long pingAckTimeoutMillis;\n+    @Nullable\n+    private final boolean disallowKeepAliveWithoutActiveStreams;\n+    private final Scheduler scheduler;\n+\n+    // below state should only be accessed from eventloop\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if graceful close has not started.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_START} if graceful close process has been initiated.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent to measure RTT.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT} if we have sent the second go away frame.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object gracefulCloseState;\n+\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if keep-alive PING process is not started.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_PENDING} if a keep-alive PING has been sent but ack is not received.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_TIMEDOUT} if we fail to receive a PING ack for the configured timeout.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object keepAliveState;\n+\n+    KeepAliveManager(final Channel channel, @Nullable final KeepAlivePolicy keepAlivePolicy) {\n+        this(channel, keepAlivePolicy, (task, delayInMillis) ->\n+                channel.eventLoop().schedule(task, delayInMillis, MILLISECONDS),\n+                (ch, idlenessThresholdMillis, onIdle) -> ch.pipeline().addLast(\n+                        new IdleStateHandler(idlenessThresholdMillis, idlenessThresholdMillis, 0) {\n+                            @Override\n+                            protected void channelIdle(final ChannelHandlerContext ctx, final IdleStateEvent evt) {\n+                                onIdle.run();\n+                            }\n+                        }));\n+    }\n+\n+    KeepAliveManager(final Channel channel, @Nullable final KeepAlivePolicy keepAlivePolicy,\n+                     final Scheduler scheduler, final IdlenessDetector idlenessDetector) {\n+        this.channel = channel;\n+        this.scheduler = scheduler;\n+        if (keepAlivePolicy != null) {\n+            disallowKeepAliveWithoutActiveStreams = !keepAlivePolicy.withoutActiveStreams();\n+            pingAckTimeoutMillis = keepAlivePolicy.ackTimeout().toMillis();\n+            int idleInSeconds = (int) keepAlivePolicy.idleDuration().getSeconds();\n+            idlenessDetector.configure(channel, idleInSeconds, this::channelIdle);\n+        } else {\n+            disallowKeepAliveWithoutActiveStreams = false;\n+            pingAckTimeoutMillis = DEFAULT_ACK_TIMEOUT.toMillis();\n+        }\n+    }\n+\n+    void pingReceived(final Http2PingFrame pingFrame) {\n+        assert channel.eventLoop().inEventLoop();\n+\n+        if (pingFrame.ack()) {\n+            long pingAckContent = pingFrame.content();\n+            if (pingAckContent == GRACEFUL_CLOSE_PING_CONTENT) {\n+                LOGGER.debug(\"channel={}, graceful close ping ack received.\", channel);\n+                cancelIfStateIsAFuture(gracefulCloseState);\n+                gracefulCloseWriteSecondGoAway();\n+            } else if (pingAckContent == KEEP_ALIVE_PING_CONTENT) {\n+                cancelIfStateIsAFuture(keepAliveState);\n+                keepAliveState = null;\n+            }\n+        } else {\n+            // Send an ack for the received ping\n+            channel.writeAndFlush(new DefaultHttp2PingFrame(pingFrame.content(), true));\n+        }\n+    }\n+\n+    void trackActiveStream(final Channel streamChannel) {\n+        activeChildChannelsUpdater.incrementAndGet(this);\n+        streamChannel.closeFuture().addListener(f -> {\n+            activeChildChannelsUpdater.decrementAndGet(this);\n+            if (activeChildChannels == 0 && gracefulCloseState == GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT) {\n+                close0();\n+            }\n+        });\n+    }\n+\n+    void channelClosed() {\n+        assert channel.eventLoop().inEventLoop();\n+\n+        cancelIfStateIsAFuture(gracefulCloseState);\n+        cancelIfStateIsAFuture(keepAliveState);\n+        gracefulCloseState = CLOSED;\n+        keepAliveState = CLOSED;\n+    }\n+\n+    void initiateGracefulClose(final Runnable whenInitiated) {\n+        EventLoop eventLoop = channel.eventLoop();\n+        if (eventLoop.inEventLoop()) {\n+            doCloseAsyncGracefully0(whenInitiated);\n+        } else {\n+            try {\n+                eventLoop.execute(() -> doCloseAsyncGracefully0(whenInitiated));\n+            } catch (Throwable cause) {\n+                close0();\n+                LOGGER.warn(\"channel={} EventLoop rejected a task for graceful shutdown, force closing connection\",\n+                        channel, cause);\n+            }\n+        }\n+    }\n+\n+    void channelIdle() {\n+        assert channel.eventLoop().inEventLoop();\n+\n+        if (keepAliveState == CLOSED) {\n+            return;\n+        }\n+        if (activeChildChannels == 0 && disallowKeepAliveWithoutActiveStreams) {\n+            return;\n+        }\n+        // idleness detected for the first time, send a ping to detect closure, if any.\n+        keepAliveState = KEEP_ALIVE_ACK_PENDING;\n+        channel.writeAndFlush(new DefaultHttp2PingFrame(KEEP_ALIVE_PING_CONTENT, false))\n+                .addListener(future -> {\n+                    if (future.isSuccess() && keepAliveState == KEEP_ALIVE_ACK_PENDING) {\n+                        // Schedule a task to verify ping ack within the pingAckTimeoutMillis\n+                        keepAliveState = scheduler.afterMillis(() -> {\n+                            if (keepAliveState != null) {\n+                                keepAliveState = KEEP_ALIVE_ACK_TIMEDOUT;\n+                                LOGGER.debug(\n+                                        \"channel={}, timeout {}ms waiting for keep-alive PING(ACK), writing go_away.\",\n+                                        channel, pingAckTimeoutMillis);\n+                                channel.writeAndFlush(new DefaultHttp2GoAwayFrame(NO_ERROR))\n+                                        .addListener(f -> {\n+                                            if (f.isSuccess()) {\n+                                                LOGGER.debug(\"Closing channel={}, after keep-alive timeout.\", channel);\n+                                                close0();\n+                                            }\n+                                        });\n+                            }\n+                        }, pingAckTimeoutMillis);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Scheduler of {@link Runnable}s.\n+     */\n+    @FunctionalInterface\n+    interface Scheduler {\n+\n+        /**\n+         * Run the passed {@link Runnable} after {@code delayInMillis} milliseconds.\n+         *\n+         * @param task {@link Runnable} to run.\n+         * @param delayInMillis Milliseconds after which the task is to be run.\n+         * @return {@link Future} for the scheduled task.\n+         */\n+        Future<?> afterMillis(Runnable task, long delayInMillis);\n+    }\n+\n+    /**\n+     * Scheduler of {@link Runnable}s.\n+     */\n+    @FunctionalInterface\n+    interface IdlenessDetector {\n+        /**\n+         * Configure idleness detection for the passed {@code channel}.\n+         *\n+         * @param channel {@link Channel} for which idleness detection is to be configured.\n+         * @param idlenessThresholdMillis Millis of idleness after which {@link Runnable#run()} should be called on the\n+         * passed {@code onIdle}.\n+         * @param onIdle {@link Runnable} to call when the channel is idle more than {@code idlenessThresholdMillis}.\n+         */\n+        void configure(Channel channel, int idlenessThresholdMillis, Runnable onIdle);\n+    }\n+\n+    private void doCloseAsyncGracefully0(final Runnable whenInitiated) {\n+        assert channel.eventLoop().inEventLoop();\n+\n+        if (gracefulCloseState != null) {\n+            // either we are already closed or have already initiated graceful closure.\n+            return;\n+        }\n+        // Set the pingState before doing the write, because we will reference the state\n+        // when we receive the PING(ACK) to determine if action is necessary, and it is conceivable that the\n+        // write future may not be executed which sets the timer.\n+        gracefulCloseState = GRACEFUL_CLOSE_START;\n+\n+        try {\n+            whenInitiated.run();\n+        } catch (Throwable t) {\n+            LOGGER.error(\"Failed to invoke callback for graceful closure initiation, ignoring.\", t);", "originalCommit": "e7ea8b7ff48bd46e37cfc158417da51a3cb7ae0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "894a68342eb7351020d4fa5cc7e47c8d97493e85", "url": "https://github.com/apple/servicetalk/commit/894a68342eb7351020d4fa5cc7e47c8d97493e85", "message": "Review comments", "committedDate": "2020-04-22T21:31:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM2OTQ4MA==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413369480", "bodyText": "Here and on other places, consider linking to the specific section instead of the page to be consistent with all other links: <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">PING</a> frames", "author": "idelpivnitskiy", "createdAt": "2020-04-22T22:15:28Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H2ProtocolConfig.java", "diffHunk": "@@ -53,4 +54,46 @@ default String alpnId() {\n      */\n     @Nullable\n     String frameLoggerName();\n+\n+    /**\n+     * Configured {@link KeepAlivePolicy}.\n+     *\n+     * @return configured {@link KeepAlivePolicy} or {@code null} if none is configured.\n+     */\n+    @Nullable\n+    KeepAlivePolicy keepAlivePolicy();\n+\n+    /**\n+     * A policy for sending <a href=\"https://tools.ietf.org/html/rfc7540#page-42\">PING frames</a> to the peer.", "originalCommit": "894a68342eb7351020d4fa5cc7e47c8d97493e85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM3MzI2Ng==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413373266", "bodyText": "Looks like a leftover from intermediate work, boolean should not be annotated.", "author": "idelpivnitskiy", "createdAt": "2020-04-22T22:22:57Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/KeepAliveManager.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.http.netty.H2ProtocolConfig.KeepAlivePolicy;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.DefaultHttp2GoAwayFrame;\n+import io.netty.handler.codec.http2.DefaultHttp2PingFrame;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.GenericFutureListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.http2.Http2Error.NO_ERROR;\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_ACK_TIMEOUT;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+/**\n+ * An implementation of {@link KeepAlivePolicy} per {@link Channel}.\n+ */\n+final class KeepAliveManager {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KeepAliveManager.class);\n+    private static final AtomicIntegerFieldUpdater<KeepAliveManager> activeChildChannelsUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(KeepAliveManager.class, \"activeChildChannels\");\n+    private static final long GRACEFUL_CLOSE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final long KEEP_ALIVE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final Object CLOSED = new Object();\n+    private static final Object GRACEFUL_CLOSE_START = new Object();\n+    private static final Object GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT = new Object();\n+    private static final Object KEEP_ALIVE_ACK_PENDING = new Object();\n+    private static final Object KEEP_ALIVE_ACK_TIMEDOUT = new Object();\n+\n+    private volatile int activeChildChannels;\n+\n+    private final Channel channel;\n+    private final long pingAckTimeoutMillis;\n+    @Nullable", "originalCommit": "894a68342eb7351020d4fa5cc7e47c8d97493e85", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM3NDY3Mg==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413374672", "bodyText": "Consider swapping it in this way to protect from unnecessary volatile read: disallowKeepAliveWithoutActiveStreams && activeChildChannels == 0", "author": "idelpivnitskiy", "createdAt": "2020-04-22T22:26:07Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/KeepAliveManager.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.http.netty.H2ProtocolConfig.KeepAlivePolicy;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.DefaultHttp2GoAwayFrame;\n+import io.netty.handler.codec.http2.DefaultHttp2PingFrame;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.GenericFutureListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.http2.Http2Error.NO_ERROR;\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_ACK_TIMEOUT;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+/**\n+ * An implementation of {@link KeepAlivePolicy} per {@link Channel}.\n+ */\n+final class KeepAliveManager {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KeepAliveManager.class);\n+    private static final AtomicIntegerFieldUpdater<KeepAliveManager> activeChildChannelsUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(KeepAliveManager.class, \"activeChildChannels\");\n+    private static final long GRACEFUL_CLOSE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final long KEEP_ALIVE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final Object CLOSED = new Object();\n+    private static final Object GRACEFUL_CLOSE_START = new Object();\n+    private static final Object GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT = new Object();\n+    private static final Object KEEP_ALIVE_ACK_PENDING = new Object();\n+    private static final Object KEEP_ALIVE_ACK_TIMEDOUT = new Object();\n+\n+    private volatile int activeChildChannels;\n+\n+    private final Channel channel;\n+    private final long pingAckTimeoutMillis;\n+    @Nullable\n+    private final boolean disallowKeepAliveWithoutActiveStreams;\n+    private final Scheduler scheduler;\n+\n+    // below state should only be accessed from eventloop\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if graceful close has not started.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_START} if graceful close process has been initiated.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent to measure RTT.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT} if we have sent the second go away frame.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object gracefulCloseState;\n+\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if keep-alive PING process is not started.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_PENDING} if a keep-alive PING has been sent but ack is not received.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_TIMEDOUT} if we fail to receive a PING ack for the configured timeout.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object keepAliveState;\n+    @Nullable\n+    private final GenericFutureListener<Future<? super Void>> pingWriteCompletionListener;\n+\n+    KeepAliveManager(final Channel channel, @Nullable final KeepAlivePolicy keepAlivePolicy) {\n+        this(channel, keepAlivePolicy, (task, delayInMillis) ->\n+                channel.eventLoop().schedule(task, delayInMillis, MILLISECONDS),\n+                (ch, idlenessThresholdMillis, onIdle) -> ch.pipeline().addLast(\n+                        new IdleStateHandler(idlenessThresholdMillis, idlenessThresholdMillis, 0) {\n+                            @Override\n+                            protected void channelIdle(final ChannelHandlerContext ctx, final IdleStateEvent evt) {\n+                                onIdle.run();\n+                            }\n+                        }));\n+    }\n+\n+    KeepAliveManager(final Channel channel, @Nullable final KeepAlivePolicy keepAlivePolicy,\n+                     final Scheduler scheduler, final IdlenessDetector idlenessDetector) {\n+        this.channel = channel;\n+        this.scheduler = scheduler;\n+        if (keepAlivePolicy != null) {\n+            disallowKeepAliveWithoutActiveStreams = !keepAlivePolicy.withoutActiveStreams();\n+            pingAckTimeoutMillis = keepAlivePolicy.ackTimeout().toMillis();\n+            final GenericFutureListener<Future<? super Void>> goAwayListener = f -> {\n+                if (f.isSuccess()) {\n+                    LOGGER.debug(\"Closing channel={}, after keep-alive timeout.\", this.channel);\n+                    KeepAliveManager.this.close0();\n+                }\n+            };\n+            pingWriteCompletionListener = future -> {\n+                if (future.isSuccess() && keepAliveState == KEEP_ALIVE_ACK_PENDING) {\n+                    // Schedule a task to verify ping ack within the pingAckTimeoutMillis\n+                    keepAliveState = scheduler.afterMillis(() -> {\n+                        if (keepAliveState != null) {\n+                            keepAliveState = KEEP_ALIVE_ACK_TIMEDOUT;\n+                            LOGGER.debug(\n+                                    \"channel={}, timeout {}ms waiting for keep-alive PING(ACK), writing go_away.\",\n+                                    this.channel, pingAckTimeoutMillis);\n+                            channel.writeAndFlush(new DefaultHttp2GoAwayFrame(NO_ERROR))\n+                                    .addListener(goAwayListener);\n+                        }\n+                    }, pingAckTimeoutMillis);\n+                }\n+            };\n+            int idleInSeconds = (int) keepAlivePolicy.idleDuration().getSeconds();\n+            idlenessDetector.configure(channel, idleInSeconds, this::channelIdle);\n+        } else {\n+            disallowKeepAliveWithoutActiveStreams = false;\n+            pingAckTimeoutMillis = DEFAULT_ACK_TIMEOUT.toMillis();\n+            pingWriteCompletionListener = null;\n+        }\n+    }\n+\n+    void pingReceived(final Http2PingFrame pingFrame) {\n+        assert channel.eventLoop().inEventLoop();\n+\n+        if (pingFrame.ack()) {\n+            long pingAckContent = pingFrame.content();\n+            if (pingAckContent == GRACEFUL_CLOSE_PING_CONTENT) {\n+                LOGGER.debug(\"channel={}, graceful close ping ack received.\", channel);\n+                cancelIfStateIsAFuture(gracefulCloseState);\n+                gracefulCloseWriteSecondGoAway();\n+            } else if (pingAckContent == KEEP_ALIVE_PING_CONTENT) {\n+                cancelIfStateIsAFuture(keepAliveState);\n+                keepAliveState = null;\n+            }\n+        } else {\n+            // Send an ack for the received ping\n+            channel.writeAndFlush(new DefaultHttp2PingFrame(pingFrame.content(), true));\n+        }\n+    }\n+\n+    void trackActiveStream(final Channel streamChannel) {\n+        activeChildChannelsUpdater.incrementAndGet(this);\n+        streamChannel.closeFuture().addListener(f -> {\n+            activeChildChannelsUpdater.decrementAndGet(this);\n+            if (activeChildChannels == 0 && gracefulCloseState == GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT) {\n+                close0();\n+            }\n+        });\n+    }\n+\n+    void channelClosed() {\n+        assert channel.eventLoop().inEventLoop();\n+\n+        cancelIfStateIsAFuture(gracefulCloseState);\n+        cancelIfStateIsAFuture(keepAliveState);\n+        gracefulCloseState = CLOSED;\n+        keepAliveState = CLOSED;\n+    }\n+\n+    void initiateGracefulClose(final Runnable whenInitiated) {\n+        EventLoop eventLoop = channel.eventLoop();\n+        if (eventLoop.inEventLoop()) {\n+            doCloseAsyncGracefully0(whenInitiated);\n+        } else {\n+            try {\n+                eventLoop.execute(() -> doCloseAsyncGracefully0(whenInitiated));\n+            } catch (RejectedExecutionException ree) {\n+                close0();\n+                LOGGER.warn(\"channel={} EventLoop rejected a task for graceful shutdown, force closing connection\",\n+                        channel, ree);\n+            }\n+        }\n+    }\n+\n+    void channelIdle() {\n+        assert channel.eventLoop().inEventLoop();\n+        assert pingWriteCompletionListener != null;\n+\n+        if (keepAliveState == CLOSED || activeChildChannels == 0 && disallowKeepAliveWithoutActiveStreams) {", "originalCommit": "894a68342eb7351020d4fa5cc7e47c8d97493e85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM3ODIyOQ==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413378229", "bodyText": "Actually, I thought it should work in the opposite way: provide a config to disable ping frames when there are activeChildChannels > 0. Because if there is a working stream there is less need to check if the connection is still alive. When there are no active streams, and users want to check the connection and keep it alive, ping frames are useful.\nWhat is the use-case for holding PING frames when activeChildChannels == 0?", "author": "idelpivnitskiy", "createdAt": "2020-04-22T22:34:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM3NDY3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQyMDcwMQ==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413420701", "bodyText": "Good question.\nKeeping a connection alive when there are no requests has limited usage for connection warm up anticipating a traffic spike. This change is predominantly enabling checking connection liveness in presence of long-lived streams where activity is sparse.", "author": "NiteshKant", "createdAt": "2020-04-23T00:21:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM3NDY3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM4NjQ0Nw==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413386447", "bodyText": "While this approach gives users nice fluent DSL for configuration, they really do not read docs and forget to invoke commit() at the end. Frequent pattern:\nH2ProtocolConfigBuilder h2ConfigBuilder = h2();\n// ...\nif (needKeepAlive) {\n    h2ConfigBuilder.keepAlive();\n}\nH2ProtocolConfig config = h2ConfigBuilder.build();\nSince there is only a single commit() method on KeepAliveConfigurator, can we just have a method on the builder that takes KeepAlivePolicy?\npublic H2ProtocolConfigBuilder keepAlivePolicy(final KeepAlivePolicy keepAlivePolicy) {\n    this.keepAlivePolicy = requireNonNull(keepAlivePolicy);\n    return this;\n}\nThis will make it consistent with HttpHeadersFactory.\nWe can make DefaultKeepAlivePolicy public (similar to DefaultHttpHeadersFactory) or provide a separate builder for KeepAlivePolicy if you expect the number of configuration options may grow later.", "author": "idelpivnitskiy", "createdAt": "2020-04-22T22:52:52Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H2ProtocolConfigBuilder.java", "diffHunk": "@@ -81,13 +88,124 @@ public H2ProtocolConfigBuilder enableFrameLogging(final String loggerName) {\n         return this;\n     }\n \n+    /**\n+     * Configure keep alive behavior using <a href=\"https://tools.ietf.org/html/rfc7540#page-42\">PING frames</a>.\n+     *\n+     * @return A {@link KeepAliveConfigurator} which adds keep-alive configuration to this {@link H2ProtocolConfig} when\n+     * {@link KeepAliveConfigurator#commit() committed}.", "originalCommit": "894a68342eb7351020d4fa5cc7e47c8d97493e85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ0NzM0OQ==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413447349", "bodyText": "\ud83d\udc4d I have changed the approach, PTAL", "author": "NiteshKant", "createdAt": "2020-04-23T01:41:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM4NjQ0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM5MTA5OA==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413391098", "bodyText": "Consider removing an option to disable if users can just skip #keepAlive() configurator.", "author": "idelpivnitskiy", "createdAt": "2020-04-22T23:03:45Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H2ProtocolConfigBuilder.java", "diffHunk": "@@ -81,13 +88,124 @@ public H2ProtocolConfigBuilder enableFrameLogging(final String loggerName) {\n         return this;\n     }\n \n+    /**\n+     * Configure keep alive behavior using <a href=\"https://tools.ietf.org/html/rfc7540#page-42\">PING frames</a>.\n+     *\n+     * @return A {@link KeepAliveConfigurator} which adds keep-alive configuration to this {@link H2ProtocolConfig} when\n+     * {@link KeepAliveConfigurator#commit() committed}.\n+     */\n+    public KeepAliveConfigurator keepAlive() {\n+        return new KeepAliveConfigurator() {\n+            private Duration idleDuration = DEFAULT_IDLE_DURATION;\n+            private Duration ackTimeout = DEFAULT_ACK_TIMEOUT;\n+            private boolean withoutActiveStreams = DEFAULT_WITHOUT_ACTIVE_STREAMS;\n+            private boolean disable;\n+\n+            @Override\n+            public KeepAliveConfigurator idleDuration(final Duration idleDuration) {\n+                if (idleDuration.getSeconds() < 10) {\n+                    throw new IllegalArgumentException(\"idleDuration: \" + idleDuration + \" (expected >= 10 seconds\");\n+                }\n+                this.idleDuration = requireNonNull(idleDuration);\n+                return this;\n+            }\n+\n+            @Override\n+            public KeepAliveConfigurator ackTimeout(final Duration ackTimeout) {\n+                this.ackTimeout = requireNonNull(ackTimeout);\n+                return this;\n+            }\n+\n+            @Override\n+            public KeepAliveConfigurator withoutActiveStreams(final boolean withoutActiveStreams) {\n+                this.withoutActiveStreams = withoutActiveStreams;\n+                return this;\n+            }\n+\n+            @Override\n+            public KeepAliveConfigurator disable() {", "originalCommit": "894a68342eb7351020d4fa5cc7e47c8d97493e85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQyMTg0Mg==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413421842", "bodyText": "skipping keep-alive != disable keep-alive if we enable keep-alive by default which I think we should in the long term. I will be changing to a separate KeepAlivePolicyBuilder as per your other suggestion so this disable() method may just become a constant, but we would still want a way to explicitly disable keep-alives.", "author": "NiteshKant", "createdAt": "2020-04-23T00:24:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM5MTA5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM5MjQ3MQ==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413392471", "bodyText": "Consider adding <p> tag to move the note at second javadoc line.", "author": "idelpivnitskiy", "createdAt": "2020-04-22T23:07:17Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H2ProtocolConfigBuilder.java", "diffHunk": "@@ -81,13 +88,124 @@ public H2ProtocolConfigBuilder enableFrameLogging(final String loggerName) {\n         return this;\n     }\n \n+    /**\n+     * Configure keep alive behavior using <a href=\"https://tools.ietf.org/html/rfc7540#page-42\">PING frames</a>.\n+     *\n+     * @return A {@link KeepAliveConfigurator} which adds keep-alive configuration to this {@link H2ProtocolConfig} when\n+     * {@link KeepAliveConfigurator#commit() committed}.\n+     */\n+    public KeepAliveConfigurator keepAlive() {\n+        return new KeepAliveConfigurator() {\n+            private Duration idleDuration = DEFAULT_IDLE_DURATION;\n+            private Duration ackTimeout = DEFAULT_ACK_TIMEOUT;\n+            private boolean withoutActiveStreams = DEFAULT_WITHOUT_ACTIVE_STREAMS;\n+            private boolean disable;\n+\n+            @Override\n+            public KeepAliveConfigurator idleDuration(final Duration idleDuration) {\n+                if (idleDuration.getSeconds() < 10) {\n+                    throw new IllegalArgumentException(\"idleDuration: \" + idleDuration + \" (expected >= 10 seconds\");\n+                }\n+                this.idleDuration = requireNonNull(idleDuration);\n+                return this;\n+            }\n+\n+            @Override\n+            public KeepAliveConfigurator ackTimeout(final Duration ackTimeout) {\n+                this.ackTimeout = requireNonNull(ackTimeout);\n+                return this;\n+            }\n+\n+            @Override\n+            public KeepAliveConfigurator withoutActiveStreams(final boolean withoutActiveStreams) {\n+                this.withoutActiveStreams = withoutActiveStreams;\n+                return this;\n+            }\n+\n+            @Override\n+            public KeepAliveConfigurator disable() {\n+                this.disable = true;\n+                return this;\n+            }\n+\n+            @Override\n+            public H2ProtocolConfigBuilder commit() {\n+                H2ProtocolConfigBuilder parent = H2ProtocolConfigBuilder.this;\n+                if (disable) {\n+                    parent.keepAlivePolicy = null;\n+                } else {\n+                    parent.keepAlivePolicy = new DefaultKeepAlivePolicy(idleDuration, ackTimeout, withoutActiveStreams);\n+                }\n+                return parent;\n+            }\n+        };\n+    }\n+\n     /**\n      * Builds {@link H2ProtocolConfig}.\n      *\n      * @return {@link H2ProtocolConfig}\n      */\n     public H2ProtocolConfig build() {\n-        return new DefaultH2ProtocolConfig(headersFactory, headersSensitivityDetector, frameLoggerName);\n+        return new DefaultH2ProtocolConfig(headersFactory, headersSensitivityDetector, frameLoggerName,\n+                keepAlivePolicy);\n+    }\n+\n+    /**\n+     * A configurator for {@link KeepAlivePolicy}.\n+     */\n+    public interface KeepAliveConfigurator {\n+\n+        /**\n+         * Set the {@link Duration} of idleness on a connection after which a\n+         * <a href=\"https://tools.ietf.org/html/rfc7540#page-42\">ping</a> is sent.\n+         * <strong>Too short ping durations may cause high network traffic, so implementations may enforce a minimum", "originalCommit": "894a68342eb7351020d4fa5cc7e47c8d97493e85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM5MzMwNQ==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413393305", "bodyText": "so -> some? or just without anything: ... traffic, implementations may ...", "author": "idelpivnitskiy", "createdAt": "2020-04-22T23:09:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM5MjQ3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM5NTM3NQ==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413395375", "bodyText": "When these two default values are equal there is a possible race between \"idle duration\" and \"ack timeout\". Should we make \"ack timeout\" lower to avoid sending a second ping frame when connection awaits for an ack for the first ping?", "author": "idelpivnitskiy", "createdAt": "2020-04-22T23:14:24Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/DefaultKeepAlivePolicy.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.http.netty.H2ProtocolConfig.KeepAlivePolicy;\n+\n+import java.time.Duration;\n+\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+\n+final class DefaultKeepAlivePolicy implements KeepAlivePolicy {\n+    static final Duration DEFAULT_IDLE_DURATION = ofSeconds(30);\n+    static final Duration DEFAULT_ACK_TIMEOUT = ofSeconds(30);", "originalCommit": "894a68342eb7351020d4fa5cc7e47c8d97493e85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQyNDY5NA==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413424694", "bodyText": "Hmm .. actually we should not send another ping if the ack is pending; that is a bug, I will fix.", "author": "NiteshKant", "createdAt": "2020-04-23T00:33:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM5NTM3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQwNDgwNw==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413404807", "bodyText": "netty's IdleStateHandler default ctor expects time in seconds (and I see you pass the correct value in seconds in line 134: https://github.com/apple/servicetalk/pull/1029/files#diff-8444eb430112783058af7e8cd6f2c006R134). The name of the parameter here should be idlenessThresholdSeconds. Alternatively, you can use IdleStateHandler ctor that also takes TimeUnit and pass the value in millis here.\nIf we use only seconds, we should clarify that in javadoc of  KeepAliveConfigurator#idleDuration or force it in the API. Otherwise, users may provide Duration.ofMillis(999) that will result in disabled IdleStateEvents as it returns 0 seconds.", "author": "idelpivnitskiy", "createdAt": "2020-04-22T23:38:17Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/KeepAliveManager.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.http.netty.H2ProtocolConfig.KeepAlivePolicy;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.DefaultHttp2GoAwayFrame;\n+import io.netty.handler.codec.http2.DefaultHttp2PingFrame;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.GenericFutureListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.http2.Http2Error.NO_ERROR;\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_ACK_TIMEOUT;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+/**\n+ * An implementation of {@link KeepAlivePolicy} per {@link Channel}.\n+ */\n+final class KeepAliveManager {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KeepAliveManager.class);\n+    private static final AtomicIntegerFieldUpdater<KeepAliveManager> activeChildChannelsUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(KeepAliveManager.class, \"activeChildChannels\");\n+    private static final long GRACEFUL_CLOSE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final long KEEP_ALIVE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final Object CLOSED = new Object();\n+    private static final Object GRACEFUL_CLOSE_START = new Object();\n+    private static final Object GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT = new Object();\n+    private static final Object KEEP_ALIVE_ACK_PENDING = new Object();\n+    private static final Object KEEP_ALIVE_ACK_TIMEDOUT = new Object();\n+\n+    private volatile int activeChildChannels;\n+\n+    private final Channel channel;\n+    private final long pingAckTimeoutMillis;\n+    @Nullable\n+    private final boolean disallowKeepAliveWithoutActiveStreams;\n+    private final Scheduler scheduler;\n+\n+    // below state should only be accessed from eventloop\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if graceful close has not started.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_START} if graceful close process has been initiated.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent to measure RTT.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT} if we have sent the second go away frame.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object gracefulCloseState;\n+\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if keep-alive PING process is not started.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_PENDING} if a keep-alive PING has been sent but ack is not received.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_TIMEDOUT} if we fail to receive a PING ack for the configured timeout.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object keepAliveState;\n+    @Nullable\n+    private final GenericFutureListener<Future<? super Void>> pingWriteCompletionListener;\n+\n+    KeepAliveManager(final Channel channel, @Nullable final KeepAlivePolicy keepAlivePolicy) {\n+        this(channel, keepAlivePolicy, (task, delayInMillis) ->\n+                channel.eventLoop().schedule(task, delayInMillis, MILLISECONDS),\n+                (ch, idlenessThresholdMillis, onIdle) -> ch.pipeline().addLast(\n+                        new IdleStateHandler(idlenessThresholdMillis, idlenessThresholdMillis, 0) {", "originalCommit": "894a68342eb7351020d4fa5cc7e47c8d97493e85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQyNzIyMA==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413427220", "bodyText": "I will rename the parameter in IdlenessDetector to reflect seconds.\nKeepAliveConfigurator#idleDuration()  forces the duration to be >= 10 seconds", "author": "NiteshKant", "createdAt": "2020-04-23T00:40:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQwNDgwNw=="}], "type": "inlineReview"}, {"oid": "7de08e1e8f8615b4b427af6e92a10506945321a9", "url": "https://github.com/apple/servicetalk/commit/7de08e1e8f8615b4b427af6e92a10506945321a9", "message": "Review comments", "committedDate": "2020-04-23T01:41:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUwOTM5OQ==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413509399", "bodyText": "Consider swapping it in this way to protect from unnecessary volatile read: disallowKeepAliveWithoutActiveStreams && activeChildChannels == 0", "author": "idelpivnitskiy", "createdAt": "2020-04-23T04:59:02Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/KeepAliveManager.java", "diffHunk": "@@ -197,7 +196,7 @@ void channelIdle() {\n         assert channel.eventLoop().inEventLoop();\n         assert pingWriteCompletionListener != null;\n \n-        if (keepAliveState == CLOSED || activeChildChannels == 0 && disallowKeepAliveWithoutActiveStreams) {\n+        if (keepAliveState != null || activeChildChannels == 0 && disallowKeepAliveWithoutActiveStreams) {", "originalCommit": "7de08e1e8f8615b4b427af6e92a10506945321a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUxMTgyOA==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413511828", "bodyText": "Incorrect comment for @return tag.", "author": "idelpivnitskiy", "createdAt": "2020-04-23T05:06:27Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/KeepAlivePolicies.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.http.netty.H2ProtocolConfig.KeepAlivePolicy;\n+\n+import java.time.Duration;\n+\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_ACK_TIMEOUT;\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_IDLE_DURATION;\n+import static java.time.Duration.ofDays;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A factory to create {@link KeepAlivePolicy} instances.\n+ */\n+public final class KeepAlivePolicies {\n+    static final KeepAlivePolicy DISABLE_KEEP_ALIVE =\n+            new DefaultKeepAlivePolicy(ofDays(365), ofDays(365), false);\n+\n+    private KeepAlivePolicies() {\n+        // no instances.\n+    }\n+\n+    /**\n+     * Returns a {@link KeepAlivePolicy} that disables all keep alive behaviors.\n+     *\n+     * @return A {@link KeepAlivePolicy} that disables all keep alive behaviors.\n+     */\n+    public static KeepAlivePolicy disabled() {\n+        return DISABLE_KEEP_ALIVE;\n+    }\n+\n+    /**\n+     * Returns a {@link KeepAlivePolicy} that sends a <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">\n+     * ping</a> if the channel is idle for the passed {@code idleDuration}. Default values are used for other parameters\n+     * of the returned {@link KeepAlivePolicy}.\n+     *\n+     * @param idleDuration {@link Duration} of idleness on a connection after which a\n+     * <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a> is sent.\n+     * @return A {@link KeepAlivePolicy} that disables all keep alive behaviors.", "originalCommit": "7de08e1e8f8615b4b427af6e92a10506945321a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUxMTg4Nw==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413511887", "bodyText": "Incorrect comment for @return tag.", "author": "idelpivnitskiy", "createdAt": "2020-04-23T05:06:34Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/KeepAlivePolicies.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.http.netty.H2ProtocolConfig.KeepAlivePolicy;\n+\n+import java.time.Duration;\n+\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_ACK_TIMEOUT;\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_IDLE_DURATION;\n+import static java.time.Duration.ofDays;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A factory to create {@link KeepAlivePolicy} instances.\n+ */\n+public final class KeepAlivePolicies {\n+    static final KeepAlivePolicy DISABLE_KEEP_ALIVE =\n+            new DefaultKeepAlivePolicy(ofDays(365), ofDays(365), false);\n+\n+    private KeepAlivePolicies() {\n+        // no instances.\n+    }\n+\n+    /**\n+     * Returns a {@link KeepAlivePolicy} that disables all keep alive behaviors.\n+     *\n+     * @return A {@link KeepAlivePolicy} that disables all keep alive behaviors.\n+     */\n+    public static KeepAlivePolicy disabled() {\n+        return DISABLE_KEEP_ALIVE;\n+    }\n+\n+    /**\n+     * Returns a {@link KeepAlivePolicy} that sends a <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">\n+     * ping</a> if the channel is idle for the passed {@code idleDuration}. Default values are used for other parameters\n+     * of the returned {@link KeepAlivePolicy}.\n+     *\n+     * @param idleDuration {@link Duration} of idleness on a connection after which a\n+     * <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a> is sent.\n+     * @return A {@link KeepAlivePolicy} that disables all keep alive behaviors.\n+     */\n+    public static KeepAlivePolicy whenIdleFor(final Duration idleDuration) {\n+        return new KeepAlivePolicyBuilder().idleDuration(idleDuration).build();\n+    }\n+\n+    /**\n+     * Returns a {@link KeepAlivePolicy} that sends a <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">\n+     * ping</a> if the channel is idle for the passed {@code idleDuration} and waits for {@code ackTimeout} for an ack\n+     * for that <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a>. Default values are used for other\n+     * parameters of the returned {@link KeepAlivePolicy}.\n+     *\n+     * @param idleDuration {@link Duration} of idleness on a connection after which a\n+     * <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a> is sent.\n+     * @param ackTimeout {@link Duration} to wait for an acknowledgment of a previously sent\n+     * <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a>.\n+     * @return A {@link KeepAlivePolicy} that disables all keep alive behaviors.", "originalCommit": "7de08e1e8f8615b4b427af6e92a10506945321a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUxMzk5Nw==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413513997", "bodyText": "Since this is a final class now instead of an interface, \"implementation_s_ may enforce\" is not correct anymore. Consider something like:\n\nToo short ping durations may cause high network traffic. Too small duration is not allowed.\n\nOr be specific about 10 seconds.", "author": "idelpivnitskiy", "createdAt": "2020-04-23T05:13:04Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/KeepAlivePolicies.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.http.netty.H2ProtocolConfig.KeepAlivePolicy;\n+\n+import java.time.Duration;\n+\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_ACK_TIMEOUT;\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_IDLE_DURATION;\n+import static java.time.Duration.ofDays;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A factory to create {@link KeepAlivePolicy} instances.\n+ */\n+public final class KeepAlivePolicies {\n+    static final KeepAlivePolicy DISABLE_KEEP_ALIVE =\n+            new DefaultKeepAlivePolicy(ofDays(365), ofDays(365), false);\n+\n+    private KeepAlivePolicies() {\n+        // no instances.\n+    }\n+\n+    /**\n+     * Returns a {@link KeepAlivePolicy} that disables all keep alive behaviors.\n+     *\n+     * @return A {@link KeepAlivePolicy} that disables all keep alive behaviors.\n+     */\n+    public static KeepAlivePolicy disabled() {\n+        return DISABLE_KEEP_ALIVE;\n+    }\n+\n+    /**\n+     * Returns a {@link KeepAlivePolicy} that sends a <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">\n+     * ping</a> if the channel is idle for the passed {@code idleDuration}. Default values are used for other parameters\n+     * of the returned {@link KeepAlivePolicy}.\n+     *\n+     * @param idleDuration {@link Duration} of idleness on a connection after which a\n+     * <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a> is sent.\n+     * @return A {@link KeepAlivePolicy} that disables all keep alive behaviors.\n+     */\n+    public static KeepAlivePolicy whenIdleFor(final Duration idleDuration) {\n+        return new KeepAlivePolicyBuilder().idleDuration(idleDuration).build();\n+    }\n+\n+    /**\n+     * Returns a {@link KeepAlivePolicy} that sends a <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">\n+     * ping</a> if the channel is idle for the passed {@code idleDuration} and waits for {@code ackTimeout} for an ack\n+     * for that <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a>. Default values are used for other\n+     * parameters of the returned {@link KeepAlivePolicy}.\n+     *\n+     * @param idleDuration {@link Duration} of idleness on a connection after which a\n+     * <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a> is sent.\n+     * @param ackTimeout {@link Duration} to wait for an acknowledgment of a previously sent\n+     * <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a>.\n+     * @return A {@link KeepAlivePolicy} that disables all keep alive behaviors.\n+     */\n+    public static KeepAlivePolicy whenIdleFor(final Duration idleDuration, final Duration ackTimeout) {\n+        return new KeepAlivePolicyBuilder().idleDuration(idleDuration).ackTimeout(ackTimeout).build();\n+    }\n+\n+    /**\n+     * A builder of {@link KeepAlivePolicy}.\n+     */\n+    public static final class KeepAlivePolicyBuilder {\n+        private Duration idleDuration = DEFAULT_IDLE_DURATION;\n+        private Duration ackTimeout = DEFAULT_ACK_TIMEOUT;\n+        private boolean withoutActiveStreams;\n+\n+        /**\n+         * Set the {@link Duration} of idleness on a connection after which a\n+         * <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a> is sent.\n+         * <p>\n+         * <strong>Too short ping durations may cause high network traffic, implementations may enforce a minimum", "originalCommit": "7de08e1e8f8615b4b427af6e92a10506945321a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAzODk2NQ==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r414038965", "bodyText": "Good point. I will avoid mentioning a value in the doc though.", "author": "NiteshKant", "createdAt": "2020-04-23T18:46:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUxMzk5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUxNTkxOQ==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413515919", "bodyText": "\"disallow receiving\" currently is not true. KeepAliveManager#pingReceived always acks received ping frames.", "author": "idelpivnitskiy", "createdAt": "2020-04-23T05:18:36Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/KeepAlivePolicies.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.http.netty.H2ProtocolConfig.KeepAlivePolicy;\n+\n+import java.time.Duration;\n+\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_ACK_TIMEOUT;\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_IDLE_DURATION;\n+import static java.time.Duration.ofDays;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A factory to create {@link KeepAlivePolicy} instances.\n+ */\n+public final class KeepAlivePolicies {\n+    static final KeepAlivePolicy DISABLE_KEEP_ALIVE =\n+            new DefaultKeepAlivePolicy(ofDays(365), ofDays(365), false);\n+\n+    private KeepAlivePolicies() {\n+        // no instances.\n+    }\n+\n+    /**\n+     * Returns a {@link KeepAlivePolicy} that disables all keep alive behaviors.\n+     *\n+     * @return A {@link KeepAlivePolicy} that disables all keep alive behaviors.\n+     */\n+    public static KeepAlivePolicy disabled() {\n+        return DISABLE_KEEP_ALIVE;\n+    }\n+\n+    /**\n+     * Returns a {@link KeepAlivePolicy} that sends a <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">\n+     * ping</a> if the channel is idle for the passed {@code idleDuration}. Default values are used for other parameters\n+     * of the returned {@link KeepAlivePolicy}.\n+     *\n+     * @param idleDuration {@link Duration} of idleness on a connection after which a\n+     * <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a> is sent.\n+     * @return A {@link KeepAlivePolicy} that disables all keep alive behaviors.\n+     */\n+    public static KeepAlivePolicy whenIdleFor(final Duration idleDuration) {\n+        return new KeepAlivePolicyBuilder().idleDuration(idleDuration).build();\n+    }\n+\n+    /**\n+     * Returns a {@link KeepAlivePolicy} that sends a <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">\n+     * ping</a> if the channel is idle for the passed {@code idleDuration} and waits for {@code ackTimeout} for an ack\n+     * for that <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a>. Default values are used for other\n+     * parameters of the returned {@link KeepAlivePolicy}.\n+     *\n+     * @param idleDuration {@link Duration} of idleness on a connection after which a\n+     * <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a> is sent.\n+     * @param ackTimeout {@link Duration} to wait for an acknowledgment of a previously sent\n+     * <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a>.\n+     * @return A {@link KeepAlivePolicy} that disables all keep alive behaviors.\n+     */\n+    public static KeepAlivePolicy whenIdleFor(final Duration idleDuration, final Duration ackTimeout) {\n+        return new KeepAlivePolicyBuilder().idleDuration(idleDuration).ackTimeout(ackTimeout).build();\n+    }\n+\n+    /**\n+     * A builder of {@link KeepAlivePolicy}.\n+     */\n+    public static final class KeepAlivePolicyBuilder {\n+        private Duration idleDuration = DEFAULT_IDLE_DURATION;\n+        private Duration ackTimeout = DEFAULT_ACK_TIMEOUT;\n+        private boolean withoutActiveStreams;\n+\n+        /**\n+         * Set the {@link Duration} of idleness on a connection after which a\n+         * <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a> is sent.\n+         * <p>\n+         * <strong>Too short ping durations may cause high network traffic, implementations may enforce a minimum\n+         * duration.</strong>\n+         *\n+         * @param idleDuration {@link Duration} of idleness on a connection after which a\n+         * <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a> is sent.\n+         * @return {@code this}.\n+         * @see KeepAlivePolicy#idleDuration()\n+         */\n+        public KeepAlivePolicyBuilder idleDuration(final Duration idleDuration) {\n+            if (idleDuration.getSeconds() < 10) {\n+                throw new IllegalArgumentException(\"idleDuration: \" + idleDuration + \" (expected >= 10 seconds\");\n+            }\n+            this.idleDuration = idleDuration;\n+            return this;\n+        }\n+\n+        /**\n+         * Set the maximum {@link Duration} to wait for an acknowledgment of a previously sent\n+         * <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a>. If no acknowledgment is received, the\n+         * connection will be closed.\n+         *\n+         * @param ackTimeout {@link Duration} to wait for an acknowledgment of a previously sent\n+         * <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a>.\n+         * @return {@code this}.\n+         * @see KeepAlivePolicy#ackTimeout()\n+         */\n+        public KeepAlivePolicyBuilder ackTimeout(final Duration ackTimeout) {\n+            this.ackTimeout = requireNonNull(ackTimeout);\n+            return this;\n+        }\n+\n+        /**\n+         * Allow/disallow sending or receiving <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">pings</a> even", "originalCommit": "7de08e1e8f8615b4b427af6e92a10506945321a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUxNjM5MQ==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413516391", "bodyText": "WDYT about whenNoActiveStreams name here and for KeepAlivePolicy? \"without\" does not match with the javadoc language.", "author": "idelpivnitskiy", "createdAt": "2020-04-23T05:20:01Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/KeepAlivePolicies.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.http.netty.H2ProtocolConfig.KeepAlivePolicy;\n+\n+import java.time.Duration;\n+\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_ACK_TIMEOUT;\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_IDLE_DURATION;\n+import static java.time.Duration.ofDays;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A factory to create {@link KeepAlivePolicy} instances.\n+ */\n+public final class KeepAlivePolicies {\n+    static final KeepAlivePolicy DISABLE_KEEP_ALIVE =\n+            new DefaultKeepAlivePolicy(ofDays(365), ofDays(365), false);\n+\n+    private KeepAlivePolicies() {\n+        // no instances.\n+    }\n+\n+    /**\n+     * Returns a {@link KeepAlivePolicy} that disables all keep alive behaviors.\n+     *\n+     * @return A {@link KeepAlivePolicy} that disables all keep alive behaviors.\n+     */\n+    public static KeepAlivePolicy disabled() {\n+        return DISABLE_KEEP_ALIVE;\n+    }\n+\n+    /**\n+     * Returns a {@link KeepAlivePolicy} that sends a <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">\n+     * ping</a> if the channel is idle for the passed {@code idleDuration}. Default values are used for other parameters\n+     * of the returned {@link KeepAlivePolicy}.\n+     *\n+     * @param idleDuration {@link Duration} of idleness on a connection after which a\n+     * <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a> is sent.\n+     * @return A {@link KeepAlivePolicy} that disables all keep alive behaviors.\n+     */\n+    public static KeepAlivePolicy whenIdleFor(final Duration idleDuration) {\n+        return new KeepAlivePolicyBuilder().idleDuration(idleDuration).build();\n+    }\n+\n+    /**\n+     * Returns a {@link KeepAlivePolicy} that sends a <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">\n+     * ping</a> if the channel is idle for the passed {@code idleDuration} and waits for {@code ackTimeout} for an ack\n+     * for that <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a>. Default values are used for other\n+     * parameters of the returned {@link KeepAlivePolicy}.\n+     *\n+     * @param idleDuration {@link Duration} of idleness on a connection after which a\n+     * <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a> is sent.\n+     * @param ackTimeout {@link Duration} to wait for an acknowledgment of a previously sent\n+     * <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a>.\n+     * @return A {@link KeepAlivePolicy} that disables all keep alive behaviors.\n+     */\n+    public static KeepAlivePolicy whenIdleFor(final Duration idleDuration, final Duration ackTimeout) {\n+        return new KeepAlivePolicyBuilder().idleDuration(idleDuration).ackTimeout(ackTimeout).build();\n+    }\n+\n+    /**\n+     * A builder of {@link KeepAlivePolicy}.\n+     */\n+    public static final class KeepAlivePolicyBuilder {\n+        private Duration idleDuration = DEFAULT_IDLE_DURATION;\n+        private Duration ackTimeout = DEFAULT_ACK_TIMEOUT;\n+        private boolean withoutActiveStreams;\n+\n+        /**\n+         * Set the {@link Duration} of idleness on a connection after which a\n+         * <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a> is sent.\n+         * <p>\n+         * <strong>Too short ping durations may cause high network traffic, implementations may enforce a minimum\n+         * duration.</strong>\n+         *\n+         * @param idleDuration {@link Duration} of idleness on a connection after which a\n+         * <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a> is sent.\n+         * @return {@code this}.\n+         * @see KeepAlivePolicy#idleDuration()\n+         */\n+        public KeepAlivePolicyBuilder idleDuration(final Duration idleDuration) {\n+            if (idleDuration.getSeconds() < 10) {\n+                throw new IllegalArgumentException(\"idleDuration: \" + idleDuration + \" (expected >= 10 seconds\");\n+            }\n+            this.idleDuration = idleDuration;\n+            return this;\n+        }\n+\n+        /**\n+         * Set the maximum {@link Duration} to wait for an acknowledgment of a previously sent\n+         * <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a>. If no acknowledgment is received, the\n+         * connection will be closed.\n+         *\n+         * @param ackTimeout {@link Duration} to wait for an acknowledgment of a previously sent\n+         * <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a>.\n+         * @return {@code this}.\n+         * @see KeepAlivePolicy#ackTimeout()\n+         */\n+        public KeepAlivePolicyBuilder ackTimeout(final Duration ackTimeout) {\n+            this.ackTimeout = requireNonNull(ackTimeout);\n+            return this;\n+        }\n+\n+        /**\n+         * Allow/disallow sending or receiving <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">pings</a> even\n+         * when no streams are <a href=\"https://tools.ietf.org/html/rfc7540#section-5.1\">active</a>.\n+         *\n+         * @param withoutActiveStreams {@code true} if\n+         * <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">pings</a> are expected when no streams are\n+         * <a href=\"https://tools.ietf.org/html/rfc7540#section-5.1\">active</a>.\n+         * @return {@code this}.\n+         * @see KeepAlivePolicy#withoutActiveStreams()\n+         */\n+        public KeepAlivePolicyBuilder withoutActiveStreams(final boolean withoutActiveStreams) {", "originalCommit": "7de08e1e8f8615b4b427af6e92a10506945321a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA0MTQ2Ng==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r414041466", "bodyText": "I guess they are equivalent:\nkeepAlive.withoutActiveStreams() or keepAlive.withNoActiveStreams()\nwithout is a single negative whereas withNo is a positive (with) and a negative (no), so I feel without is easier to understand.\nJavadocs language has more context than a name so I feel it is OK to be different.", "author": "NiteshKant", "createdAt": "2020-04-23T18:50:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUxNjM5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUxODI4MQ==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413518281", "bodyText": "This is an unused variable now.", "author": "idelpivnitskiy", "createdAt": "2020-04-23T05:25:20Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/DefaultKeepAlivePolicy.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.http.netty.H2ProtocolConfig.KeepAlivePolicy;\n+\n+import java.time.Duration;\n+\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+\n+final class DefaultKeepAlivePolicy implements KeepAlivePolicy {\n+    static final Duration DEFAULT_IDLE_DURATION = ofSeconds(30);\n+    static final Duration DEFAULT_ACK_TIMEOUT = ofSeconds(30);\n+    static final boolean DEFAULT_WITHOUT_ACTIVE_STREAMS = false;", "originalCommit": "7de08e1e8f8615b4b427af6e92a10506945321a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUxODQ3Ng==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413518476", "bodyText": "This ctor is unused now.", "author": "idelpivnitskiy", "createdAt": "2020-04-23T05:25:51Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/DefaultKeepAlivePolicy.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.http.netty.H2ProtocolConfig.KeepAlivePolicy;\n+\n+import java.time.Duration;\n+\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+\n+final class DefaultKeepAlivePolicy implements KeepAlivePolicy {\n+    static final Duration DEFAULT_IDLE_DURATION = ofSeconds(30);\n+    static final Duration DEFAULT_ACK_TIMEOUT = ofSeconds(30);\n+    static final boolean DEFAULT_WITHOUT_ACTIVE_STREAMS = false;\n+    private final Duration idleDuration;\n+    private final Duration ackTimeout;\n+    private final boolean withoutActiveStreams;\n+\n+    DefaultKeepAlivePolicy() {", "originalCommit": "7de08e1e8f8615b4b427af6e92a10506945321a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUxODg2NQ==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413518865", "bodyText": "If you will remove the default ctor, you can move these constants to KeepAlivePolicies.", "author": "idelpivnitskiy", "createdAt": "2020-04-23T05:26:47Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/DefaultKeepAlivePolicy.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.http.netty.H2ProtocolConfig.KeepAlivePolicy;\n+\n+import java.time.Duration;\n+\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+\n+final class DefaultKeepAlivePolicy implements KeepAlivePolicy {\n+    static final Duration DEFAULT_IDLE_DURATION = ofSeconds(30);\n+    static final Duration DEFAULT_ACK_TIMEOUT = ofSeconds(30);", "originalCommit": "7de08e1e8f8615b4b427af6e92a10506945321a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUyMTIyMw==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413521223", "bodyText": "Since now we have a special DISABLE_KEEP_ALIVE constant, consider making this field not-nullable. We may start with disabled() as a default value and change it later if necessary.", "author": "idelpivnitskiy", "createdAt": "2020-04-23T05:33:40Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H2ProtocolConfig.java", "diffHunk": "@@ -53,4 +54,46 @@ default String alpnId() {\n      */\n     @Nullable\n     String frameLoggerName();\n+\n+    /**\n+     * Configured {@link KeepAlivePolicy}.\n+     *\n+     * @return configured {@link KeepAlivePolicy} or {@code null} if none is configured.\n+     */\n+    @Nullable", "originalCommit": "7de08e1e8f8615b4b427af6e92a10506945321a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA0NDM1OA==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r414044358", "bodyText": "The constant equating to disable is just an implementation detail IMHO. This returning null better represents that there is no policy set.", "author": "NiteshKant", "createdAt": "2020-04-23T18:55:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUyMTIyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUyMzY2Ng==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413523666", "bodyText": "Should we check that this is at least 1 ms?", "author": "idelpivnitskiy", "createdAt": "2020-04-23T05:40:18Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/KeepAlivePolicies.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.http.netty.H2ProtocolConfig.KeepAlivePolicy;\n+\n+import java.time.Duration;\n+\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_ACK_TIMEOUT;\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_IDLE_DURATION;\n+import static java.time.Duration.ofDays;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A factory to create {@link KeepAlivePolicy} instances.\n+ */\n+public final class KeepAlivePolicies {\n+    static final KeepAlivePolicy DISABLE_KEEP_ALIVE =\n+            new DefaultKeepAlivePolicy(ofDays(365), ofDays(365), false);\n+\n+    private KeepAlivePolicies() {\n+        // no instances.\n+    }\n+\n+    /**\n+     * Returns a {@link KeepAlivePolicy} that disables all keep alive behaviors.\n+     *\n+     * @return A {@link KeepAlivePolicy} that disables all keep alive behaviors.\n+     */\n+    public static KeepAlivePolicy disabled() {\n+        return DISABLE_KEEP_ALIVE;\n+    }\n+\n+    /**\n+     * Returns a {@link KeepAlivePolicy} that sends a <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">\n+     * ping</a> if the channel is idle for the passed {@code idleDuration}. Default values are used for other parameters\n+     * of the returned {@link KeepAlivePolicy}.\n+     *\n+     * @param idleDuration {@link Duration} of idleness on a connection after which a\n+     * <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a> is sent.\n+     * @return A {@link KeepAlivePolicy} that disables all keep alive behaviors.\n+     */\n+    public static KeepAlivePolicy whenIdleFor(final Duration idleDuration) {\n+        return new KeepAlivePolicyBuilder().idleDuration(idleDuration).build();\n+    }\n+\n+    /**\n+     * Returns a {@link KeepAlivePolicy} that sends a <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">\n+     * ping</a> if the channel is idle for the passed {@code idleDuration} and waits for {@code ackTimeout} for an ack\n+     * for that <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a>. Default values are used for other\n+     * parameters of the returned {@link KeepAlivePolicy}.\n+     *\n+     * @param idleDuration {@link Duration} of idleness on a connection after which a\n+     * <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a> is sent.\n+     * @param ackTimeout {@link Duration} to wait for an acknowledgment of a previously sent\n+     * <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a>.\n+     * @return A {@link KeepAlivePolicy} that disables all keep alive behaviors.\n+     */\n+    public static KeepAlivePolicy whenIdleFor(final Duration idleDuration, final Duration ackTimeout) {\n+        return new KeepAlivePolicyBuilder().idleDuration(idleDuration).ackTimeout(ackTimeout).build();\n+    }\n+\n+    /**\n+     * A builder of {@link KeepAlivePolicy}.\n+     */\n+    public static final class KeepAlivePolicyBuilder {\n+        private Duration idleDuration = DEFAULT_IDLE_DURATION;\n+        private Duration ackTimeout = DEFAULT_ACK_TIMEOUT;\n+        private boolean withoutActiveStreams;\n+\n+        /**\n+         * Set the {@link Duration} of idleness on a connection after which a\n+         * <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a> is sent.\n+         * <p>\n+         * <strong>Too short ping durations may cause high network traffic, implementations may enforce a minimum\n+         * duration.</strong>\n+         *\n+         * @param idleDuration {@link Duration} of idleness on a connection after which a\n+         * <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a> is sent.\n+         * @return {@code this}.\n+         * @see KeepAlivePolicy#idleDuration()\n+         */\n+        public KeepAlivePolicyBuilder idleDuration(final Duration idleDuration) {\n+            if (idleDuration.getSeconds() < 10) {\n+                throw new IllegalArgumentException(\"idleDuration: \" + idleDuration + \" (expected >= 10 seconds\");\n+            }\n+            this.idleDuration = idleDuration;\n+            return this;\n+        }\n+\n+        /**\n+         * Set the maximum {@link Duration} to wait for an acknowledgment of a previously sent\n+         * <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a>. If no acknowledgment is received, the\n+         * connection will be closed.\n+         *\n+         * @param ackTimeout {@link Duration} to wait for an acknowledgment of a previously sent\n+         * <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a>.\n+         * @return {@code this}.\n+         * @see KeepAlivePolicy#ackTimeout()\n+         */\n+        public KeepAlivePolicyBuilder ackTimeout(final Duration ackTimeout) {\n+            this.ackTimeout = requireNonNull(ackTimeout);", "originalCommit": "7de08e1e8f8615b4b427af6e92a10506945321a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUzMDM0NQ==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413530345", "bodyText": "We can also check at the build time that the ackTimeout is less than idleDuration.", "author": "idelpivnitskiy", "createdAt": "2020-04-23T05:57:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUyMzY2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5MjUxNA==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r414092514", "bodyText": "I would like to avoid making assumptions here as this does not have a network traffic impact. Although a good point that smaller values will cause issues with the scheduler. Let me also pass the unit to the internal Scheduler interface.\n\nWe can also check at the build time that the ackTimeout is less than idleDuration.\n\nThere isn't really a relation b/w these two values.", "author": "NiteshKant", "createdAt": "2020-04-23T20:13:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUyMzY2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUyNDE4Mw==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413524183", "bodyText": "RFC says:\n\nReceivers of a PING frame that does not include an ACK flag MUST send a PING frame with the ACK flag set in response, with an identical payload.\n\nShould we error ack frames with payload we do not expect?", "author": "idelpivnitskiy", "createdAt": "2020-04-23T05:41:48Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/KeepAliveManager.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.http.netty.H2ProtocolConfig.KeepAlivePolicy;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.DefaultHttp2GoAwayFrame;\n+import io.netty.handler.codec.http2.DefaultHttp2PingFrame;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.GenericFutureListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.http2.Http2Error.NO_ERROR;\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_ACK_TIMEOUT;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+/**\n+ * An implementation of {@link KeepAlivePolicy} per {@link Channel}.\n+ */\n+final class KeepAliveManager {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KeepAliveManager.class);\n+    private static final AtomicIntegerFieldUpdater<KeepAliveManager> activeChildChannelsUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(KeepAliveManager.class, \"activeChildChannels\");\n+    private static final long GRACEFUL_CLOSE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final long KEEP_ALIVE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final Object CLOSED = new Object();\n+    private static final Object GRACEFUL_CLOSE_START = new Object();\n+    private static final Object GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT = new Object();\n+    private static final Object KEEP_ALIVE_ACK_PENDING = new Object();\n+    private static final Object KEEP_ALIVE_ACK_TIMEDOUT = new Object();\n+\n+    private volatile int activeChildChannels;\n+\n+    private final Channel channel;\n+    private final long pingAckTimeoutMillis;\n+    private final boolean disallowKeepAliveWithoutActiveStreams;\n+    private final Scheduler scheduler;\n+\n+    // below state should only be accessed from eventloop\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if graceful close has not started.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_START} if graceful close process has been initiated.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent to measure RTT.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT} if we have sent the second go away frame.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object gracefulCloseState;\n+\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if keep-alive PING process is not started.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_PENDING} if a keep-alive PING has been sent but ack is not received.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_TIMEDOUT} if we fail to receive a PING ack for the configured timeout.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object keepAliveState;\n+    @Nullable\n+    private final GenericFutureListener<Future<? super Void>> pingWriteCompletionListener;\n+\n+    KeepAliveManager(final Channel channel, @Nullable final KeepAlivePolicy keepAlivePolicy) {\n+        this(channel, keepAlivePolicy, (task, delayInMillis) ->\n+                channel.eventLoop().schedule(task, delayInMillis, MILLISECONDS),\n+                (ch, idlenessThresholdSeconds, onIdle) -> ch.pipeline().addLast(\n+                        new IdleStateHandler(idlenessThresholdSeconds, idlenessThresholdSeconds, 0) {\n+                            @Override\n+                            protected void channelIdle(final ChannelHandlerContext ctx, final IdleStateEvent evt) {\n+                                onIdle.run();\n+                            }\n+                        }));\n+    }\n+\n+    KeepAliveManager(final Channel channel, @Nullable final KeepAlivePolicy keepAlivePolicy,\n+                     final Scheduler scheduler, final IdlenessDetector idlenessDetector) {\n+        this.channel = channel;\n+        this.scheduler = scheduler;\n+        if (keepAlivePolicy != null) {\n+            disallowKeepAliveWithoutActiveStreams = !keepAlivePolicy.withoutActiveStreams();\n+            pingAckTimeoutMillis = keepAlivePolicy.ackTimeout().toMillis();\n+            final GenericFutureListener<Future<? super Void>> goAwayListener = f -> {\n+                if (f.isSuccess()) {\n+                    LOGGER.debug(\"Closing channel={}, after keep-alive timeout.\", this.channel);\n+                    KeepAliveManager.this.close0();\n+                }\n+            };\n+            pingWriteCompletionListener = future -> {\n+                if (future.isSuccess() && keepAliveState == KEEP_ALIVE_ACK_PENDING) {\n+                    // Schedule a task to verify ping ack within the pingAckTimeoutMillis\n+                    keepAliveState = scheduler.afterMillis(() -> {\n+                        if (keepAliveState != null) {\n+                            keepAliveState = KEEP_ALIVE_ACK_TIMEDOUT;\n+                            LOGGER.debug(\n+                                    \"channel={}, timeout {}ms waiting for keep-alive PING(ACK), writing go_away.\",\n+                                    this.channel, pingAckTimeoutMillis);\n+                            channel.writeAndFlush(new DefaultHttp2GoAwayFrame(NO_ERROR))\n+                                    .addListener(goAwayListener);\n+                        }\n+                    }, pingAckTimeoutMillis);\n+                }\n+            };\n+            int idleInSeconds = (int) keepAlivePolicy.idleDuration().getSeconds();\n+            idlenessDetector.configure(channel, idleInSeconds, this::channelIdle);\n+        } else {\n+            disallowKeepAliveWithoutActiveStreams = false;\n+            pingAckTimeoutMillis = DEFAULT_ACK_TIMEOUT.toMillis();\n+            pingWriteCompletionListener = null;\n+        }\n+    }\n+\n+    void pingReceived(final Http2PingFrame pingFrame) {\n+        assert channel.eventLoop().inEventLoop();\n+\n+        if (pingFrame.ack()) {\n+            long pingAckContent = pingFrame.content();\n+            if (pingAckContent == GRACEFUL_CLOSE_PING_CONTENT) {\n+                LOGGER.debug(\"channel={}, graceful close ping ack received.\", channel);\n+                cancelIfStateIsAFuture(gracefulCloseState);\n+                gracefulCloseWriteSecondGoAway();\n+            } else if (pingAckContent == KEEP_ALIVE_PING_CONTENT) {\n+                cancelIfStateIsAFuture(keepAliveState);\n+                keepAliveState = null;\n+            }", "originalCommit": "7de08e1e8f8615b4b427af6e92a10506945321a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY0MzQ3Mw==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413643473", "bodyText": "+1... I think this should be a connection error", "author": "normanmaurer", "createdAt": "2020-04-23T09:04:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUyNDE4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5NTQ4Nw==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r414095487", "bodyText": "hmm I would be hesitant to assume that we are the only entity sending PINGs when we do not have the visibility of which all frames are sent on the wire.\nIf at all we do feel this is necessary, I think this should be part of an enforcement policy as opposed to the keep-alive policy as it exists in this PR.", "author": "NiteshKant", "createdAt": "2020-04-23T20:18:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUyNDE4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUyNTI2Mg==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413525262", "bodyText": "If we change this code to always use addListener (doesn't look it's practical in real network application that promise will complete so fast):\n\n  \n    \n      servicetalk/servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H2ClientParentConnectionContext.java\n    \n    \n        Lines 229 to 234\n      in\n      b22e5ea\n    \n    \n    \n    \n\n        \n          \n           if (promise.isDone()) { \n        \n\n        \n          \n               childChannelActive(promise, subscriber, sequentialCancellable, strategy, request); \n        \n\n        \n          \n           } else { \n        \n\n        \n          \n               promise.addListener((FutureListener<Http2StreamChannel>) future -> \n        \n\n        \n          \n                       childChannelActive(future, subscriber, sequentialCancellable, strategy, request)); \n        \n\n        \n          \n           } \n        \n    \n  \n\n\nThen this method will always be on the event loop. closeFuture also invokes listeners on the event loop. We will be able to make this variable non-volatile then. WDYT? Can be a follow-up as it's not related to this PR.", "author": "idelpivnitskiy", "createdAt": "2020-04-23T05:44:52Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/KeepAliveManager.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.http.netty.H2ProtocolConfig.KeepAlivePolicy;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.DefaultHttp2GoAwayFrame;\n+import io.netty.handler.codec.http2.DefaultHttp2PingFrame;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.GenericFutureListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.http2.Http2Error.NO_ERROR;\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_ACK_TIMEOUT;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+/**\n+ * An implementation of {@link KeepAlivePolicy} per {@link Channel}.\n+ */\n+final class KeepAliveManager {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KeepAliveManager.class);\n+    private static final AtomicIntegerFieldUpdater<KeepAliveManager> activeChildChannelsUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(KeepAliveManager.class, \"activeChildChannels\");\n+    private static final long GRACEFUL_CLOSE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final long KEEP_ALIVE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final Object CLOSED = new Object();\n+    private static final Object GRACEFUL_CLOSE_START = new Object();\n+    private static final Object GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT = new Object();\n+    private static final Object KEEP_ALIVE_ACK_PENDING = new Object();\n+    private static final Object KEEP_ALIVE_ACK_TIMEDOUT = new Object();\n+\n+    private volatile int activeChildChannels;\n+\n+    private final Channel channel;\n+    private final long pingAckTimeoutMillis;\n+    private final boolean disallowKeepAliveWithoutActiveStreams;\n+    private final Scheduler scheduler;\n+\n+    // below state should only be accessed from eventloop\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if graceful close has not started.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_START} if graceful close process has been initiated.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent to measure RTT.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT} if we have sent the second go away frame.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object gracefulCloseState;\n+\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if keep-alive PING process is not started.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_PENDING} if a keep-alive PING has been sent but ack is not received.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_TIMEDOUT} if we fail to receive a PING ack for the configured timeout.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object keepAliveState;\n+    @Nullable\n+    private final GenericFutureListener<Future<? super Void>> pingWriteCompletionListener;\n+\n+    KeepAliveManager(final Channel channel, @Nullable final KeepAlivePolicy keepAlivePolicy) {\n+        this(channel, keepAlivePolicy, (task, delayInMillis) ->\n+                channel.eventLoop().schedule(task, delayInMillis, MILLISECONDS),\n+                (ch, idlenessThresholdSeconds, onIdle) -> ch.pipeline().addLast(\n+                        new IdleStateHandler(idlenessThresholdSeconds, idlenessThresholdSeconds, 0) {\n+                            @Override\n+                            protected void channelIdle(final ChannelHandlerContext ctx, final IdleStateEvent evt) {\n+                                onIdle.run();\n+                            }\n+                        }));\n+    }\n+\n+    KeepAliveManager(final Channel channel, @Nullable final KeepAlivePolicy keepAlivePolicy,\n+                     final Scheduler scheduler, final IdlenessDetector idlenessDetector) {\n+        this.channel = channel;\n+        this.scheduler = scheduler;\n+        if (keepAlivePolicy != null) {\n+            disallowKeepAliveWithoutActiveStreams = !keepAlivePolicy.withoutActiveStreams();\n+            pingAckTimeoutMillis = keepAlivePolicy.ackTimeout().toMillis();\n+            final GenericFutureListener<Future<? super Void>> goAwayListener = f -> {\n+                if (f.isSuccess()) {\n+                    LOGGER.debug(\"Closing channel={}, after keep-alive timeout.\", this.channel);\n+                    KeepAliveManager.this.close0();\n+                }\n+            };\n+            pingWriteCompletionListener = future -> {\n+                if (future.isSuccess() && keepAliveState == KEEP_ALIVE_ACK_PENDING) {\n+                    // Schedule a task to verify ping ack within the pingAckTimeoutMillis\n+                    keepAliveState = scheduler.afterMillis(() -> {\n+                        if (keepAliveState != null) {\n+                            keepAliveState = KEEP_ALIVE_ACK_TIMEDOUT;\n+                            LOGGER.debug(\n+                                    \"channel={}, timeout {}ms waiting for keep-alive PING(ACK), writing go_away.\",\n+                                    this.channel, pingAckTimeoutMillis);\n+                            channel.writeAndFlush(new DefaultHttp2GoAwayFrame(NO_ERROR))\n+                                    .addListener(goAwayListener);\n+                        }\n+                    }, pingAckTimeoutMillis);\n+                }\n+            };\n+            int idleInSeconds = (int) keepAlivePolicy.idleDuration().getSeconds();\n+            idlenessDetector.configure(channel, idleInSeconds, this::channelIdle);\n+        } else {\n+            disallowKeepAliveWithoutActiveStreams = false;\n+            pingAckTimeoutMillis = DEFAULT_ACK_TIMEOUT.toMillis();\n+            pingWriteCompletionListener = null;\n+        }\n+    }\n+\n+    void pingReceived(final Http2PingFrame pingFrame) {\n+        assert channel.eventLoop().inEventLoop();\n+\n+        if (pingFrame.ack()) {\n+            long pingAckContent = pingFrame.content();\n+            if (pingAckContent == GRACEFUL_CLOSE_PING_CONTENT) {\n+                LOGGER.debug(\"channel={}, graceful close ping ack received.\", channel);\n+                cancelIfStateIsAFuture(gracefulCloseState);\n+                gracefulCloseWriteSecondGoAway();\n+            } else if (pingAckContent == KEEP_ALIVE_PING_CONTENT) {\n+                cancelIfStateIsAFuture(keepAliveState);\n+                keepAliveState = null;\n+            }\n+        } else {\n+            // Send an ack for the received ping\n+            channel.writeAndFlush(new DefaultHttp2PingFrame(pingFrame.content(), true));\n+        }\n+    }\n+\n+    void trackActiveStream(final Channel streamChannel) {\n+        activeChildChannelsUpdater.incrementAndGet(this);", "originalCommit": "7de08e1e8f8615b4b427af6e92a10506945321a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5NzE2NQ==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r414097165", "bodyText": "I am not sure about the API inter-connects here and would like to defer.", "author": "NiteshKant", "createdAt": "2020-04-23T20:21:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUyNTI2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY0NDM1OQ==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413644359", "bodyText": "first log then call close0() just in case that close0 will throw", "author": "normanmaurer", "createdAt": "2020-04-23T09:05:41Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/KeepAliveManager.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.http.netty.H2ProtocolConfig.KeepAlivePolicy;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.DefaultHttp2GoAwayFrame;\n+import io.netty.handler.codec.http2.DefaultHttp2PingFrame;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.GenericFutureListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.http2.Http2Error.NO_ERROR;\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_ACK_TIMEOUT;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+/**\n+ * An implementation of {@link KeepAlivePolicy} per {@link Channel}.\n+ */\n+final class KeepAliveManager {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KeepAliveManager.class);\n+    private static final AtomicIntegerFieldUpdater<KeepAliveManager> activeChildChannelsUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(KeepAliveManager.class, \"activeChildChannels\");\n+    private static final long GRACEFUL_CLOSE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final long KEEP_ALIVE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final Object CLOSED = new Object();\n+    private static final Object GRACEFUL_CLOSE_START = new Object();\n+    private static final Object GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT = new Object();\n+    private static final Object KEEP_ALIVE_ACK_PENDING = new Object();\n+    private static final Object KEEP_ALIVE_ACK_TIMEDOUT = new Object();\n+\n+    private volatile int activeChildChannels;\n+\n+    private final Channel channel;\n+    private final long pingAckTimeoutMillis;\n+    private final boolean disallowKeepAliveWithoutActiveStreams;\n+    private final Scheduler scheduler;\n+\n+    // below state should only be accessed from eventloop\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if graceful close has not started.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_START} if graceful close process has been initiated.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent to measure RTT.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT} if we have sent the second go away frame.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object gracefulCloseState;\n+\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if keep-alive PING process is not started.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_PENDING} if a keep-alive PING has been sent but ack is not received.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_TIMEDOUT} if we fail to receive a PING ack for the configured timeout.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object keepAliveState;\n+    @Nullable\n+    private final GenericFutureListener<Future<? super Void>> pingWriteCompletionListener;\n+\n+    KeepAliveManager(final Channel channel, @Nullable final KeepAlivePolicy keepAlivePolicy) {\n+        this(channel, keepAlivePolicy, (task, delayInMillis) ->\n+                channel.eventLoop().schedule(task, delayInMillis, MILLISECONDS),\n+                (ch, idlenessThresholdSeconds, onIdle) -> ch.pipeline().addLast(\n+                        new IdleStateHandler(idlenessThresholdSeconds, idlenessThresholdSeconds, 0) {\n+                            @Override\n+                            protected void channelIdle(final ChannelHandlerContext ctx, final IdleStateEvent evt) {\n+                                onIdle.run();\n+                            }\n+                        }));\n+    }\n+\n+    KeepAliveManager(final Channel channel, @Nullable final KeepAlivePolicy keepAlivePolicy,\n+                     final Scheduler scheduler, final IdlenessDetector idlenessDetector) {\n+        this.channel = channel;\n+        this.scheduler = scheduler;\n+        if (keepAlivePolicy != null) {\n+            disallowKeepAliveWithoutActiveStreams = !keepAlivePolicy.withoutActiveStreams();\n+            pingAckTimeoutMillis = keepAlivePolicy.ackTimeout().toMillis();\n+            final GenericFutureListener<Future<? super Void>> goAwayListener = f -> {\n+                if (f.isSuccess()) {\n+                    LOGGER.debug(\"Closing channel={}, after keep-alive timeout.\", this.channel);\n+                    KeepAliveManager.this.close0();\n+                }\n+            };\n+            pingWriteCompletionListener = future -> {\n+                if (future.isSuccess() && keepAliveState == KEEP_ALIVE_ACK_PENDING) {\n+                    // Schedule a task to verify ping ack within the pingAckTimeoutMillis\n+                    keepAliveState = scheduler.afterMillis(() -> {\n+                        if (keepAliveState != null) {\n+                            keepAliveState = KEEP_ALIVE_ACK_TIMEDOUT;\n+                            LOGGER.debug(\n+                                    \"channel={}, timeout {}ms waiting for keep-alive PING(ACK), writing go_away.\",\n+                                    this.channel, pingAckTimeoutMillis);\n+                            channel.writeAndFlush(new DefaultHttp2GoAwayFrame(NO_ERROR))\n+                                    .addListener(goAwayListener);\n+                        }\n+                    }, pingAckTimeoutMillis);\n+                }\n+            };\n+            int idleInSeconds = (int) keepAlivePolicy.idleDuration().getSeconds();\n+            idlenessDetector.configure(channel, idleInSeconds, this::channelIdle);\n+        } else {\n+            disallowKeepAliveWithoutActiveStreams = false;\n+            pingAckTimeoutMillis = DEFAULT_ACK_TIMEOUT.toMillis();\n+            pingWriteCompletionListener = null;\n+        }\n+    }\n+\n+    void pingReceived(final Http2PingFrame pingFrame) {\n+        assert channel.eventLoop().inEventLoop();\n+\n+        if (pingFrame.ack()) {\n+            long pingAckContent = pingFrame.content();\n+            if (pingAckContent == GRACEFUL_CLOSE_PING_CONTENT) {\n+                LOGGER.debug(\"channel={}, graceful close ping ack received.\", channel);\n+                cancelIfStateIsAFuture(gracefulCloseState);\n+                gracefulCloseWriteSecondGoAway();\n+            } else if (pingAckContent == KEEP_ALIVE_PING_CONTENT) {\n+                cancelIfStateIsAFuture(keepAliveState);\n+                keepAliveState = null;\n+            }\n+        } else {\n+            // Send an ack for the received ping\n+            channel.writeAndFlush(new DefaultHttp2PingFrame(pingFrame.content(), true));\n+        }\n+    }\n+\n+    void trackActiveStream(final Channel streamChannel) {\n+        activeChildChannelsUpdater.incrementAndGet(this);\n+        streamChannel.closeFuture().addListener(f -> {\n+            activeChildChannelsUpdater.decrementAndGet(this);\n+            if (activeChildChannels == 0 && gracefulCloseState == GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT) {\n+                close0();\n+            }\n+        });\n+    }\n+\n+    void channelClosed() {\n+        assert channel.eventLoop().inEventLoop();\n+\n+        cancelIfStateIsAFuture(gracefulCloseState);\n+        cancelIfStateIsAFuture(keepAliveState);\n+        gracefulCloseState = CLOSED;\n+        keepAliveState = CLOSED;\n+    }\n+\n+    void initiateGracefulClose(final Runnable whenInitiated) {\n+        EventLoop eventLoop = channel.eventLoop();\n+        if (eventLoop.inEventLoop()) {\n+            doCloseAsyncGracefully0(whenInitiated);\n+        } else {\n+            try {\n+                eventLoop.execute(() -> doCloseAsyncGracefully0(whenInitiated));\n+            } catch (RejectedExecutionException ree) {\n+                close0();\n+                LOGGER.warn(\"channel={} EventLoop rejected a task for graceful shutdown, force closing connection\",", "originalCommit": "7de08e1e8f8615b4b427af6e92a10506945321a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY0NjQ0Mw==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413646443", "bodyText": "should the close be done once all previous written data is really written out on the network ? At the moment we may loose some data if the channel was not writable when flush() is called.", "author": "normanmaurer", "createdAt": "2020-04-23T09:08:34Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/KeepAliveManager.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.http.netty.H2ProtocolConfig.KeepAlivePolicy;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.DefaultHttp2GoAwayFrame;\n+import io.netty.handler.codec.http2.DefaultHttp2PingFrame;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.GenericFutureListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.http2.Http2Error.NO_ERROR;\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_ACK_TIMEOUT;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+/**\n+ * An implementation of {@link KeepAlivePolicy} per {@link Channel}.\n+ */\n+final class KeepAliveManager {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KeepAliveManager.class);\n+    private static final AtomicIntegerFieldUpdater<KeepAliveManager> activeChildChannelsUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(KeepAliveManager.class, \"activeChildChannels\");\n+    private static final long GRACEFUL_CLOSE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final long KEEP_ALIVE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final Object CLOSED = new Object();\n+    private static final Object GRACEFUL_CLOSE_START = new Object();\n+    private static final Object GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT = new Object();\n+    private static final Object KEEP_ALIVE_ACK_PENDING = new Object();\n+    private static final Object KEEP_ALIVE_ACK_TIMEDOUT = new Object();\n+\n+    private volatile int activeChildChannels;\n+\n+    private final Channel channel;\n+    private final long pingAckTimeoutMillis;\n+    private final boolean disallowKeepAliveWithoutActiveStreams;\n+    private final Scheduler scheduler;\n+\n+    // below state should only be accessed from eventloop\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if graceful close has not started.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_START} if graceful close process has been initiated.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent to measure RTT.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT} if we have sent the second go away frame.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object gracefulCloseState;\n+\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if keep-alive PING process is not started.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_PENDING} if a keep-alive PING has been sent but ack is not received.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_TIMEDOUT} if we fail to receive a PING ack for the configured timeout.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object keepAliveState;\n+    @Nullable\n+    private final GenericFutureListener<Future<? super Void>> pingWriteCompletionListener;\n+\n+    KeepAliveManager(final Channel channel, @Nullable final KeepAlivePolicy keepAlivePolicy) {\n+        this(channel, keepAlivePolicy, (task, delayInMillis) ->\n+                channel.eventLoop().schedule(task, delayInMillis, MILLISECONDS),\n+                (ch, idlenessThresholdSeconds, onIdle) -> ch.pipeline().addLast(\n+                        new IdleStateHandler(idlenessThresholdSeconds, idlenessThresholdSeconds, 0) {\n+                            @Override\n+                            protected void channelIdle(final ChannelHandlerContext ctx, final IdleStateEvent evt) {\n+                                onIdle.run();\n+                            }\n+                        }));\n+    }\n+\n+    KeepAliveManager(final Channel channel, @Nullable final KeepAlivePolicy keepAlivePolicy,\n+                     final Scheduler scheduler, final IdlenessDetector idlenessDetector) {\n+        this.channel = channel;\n+        this.scheduler = scheduler;\n+        if (keepAlivePolicy != null) {\n+            disallowKeepAliveWithoutActiveStreams = !keepAlivePolicy.withoutActiveStreams();\n+            pingAckTimeoutMillis = keepAlivePolicy.ackTimeout().toMillis();\n+            final GenericFutureListener<Future<? super Void>> goAwayListener = f -> {\n+                if (f.isSuccess()) {\n+                    LOGGER.debug(\"Closing channel={}, after keep-alive timeout.\", this.channel);\n+                    KeepAliveManager.this.close0();\n+                }\n+            };\n+            pingWriteCompletionListener = future -> {\n+                if (future.isSuccess() && keepAliveState == KEEP_ALIVE_ACK_PENDING) {\n+                    // Schedule a task to verify ping ack within the pingAckTimeoutMillis\n+                    keepAliveState = scheduler.afterMillis(() -> {\n+                        if (keepAliveState != null) {\n+                            keepAliveState = KEEP_ALIVE_ACK_TIMEDOUT;\n+                            LOGGER.debug(\n+                                    \"channel={}, timeout {}ms waiting for keep-alive PING(ACK), writing go_away.\",\n+                                    this.channel, pingAckTimeoutMillis);\n+                            channel.writeAndFlush(new DefaultHttp2GoAwayFrame(NO_ERROR))\n+                                    .addListener(goAwayListener);\n+                        }\n+                    }, pingAckTimeoutMillis);\n+                }\n+            };\n+            int idleInSeconds = (int) keepAlivePolicy.idleDuration().getSeconds();\n+            idlenessDetector.configure(channel, idleInSeconds, this::channelIdle);\n+        } else {\n+            disallowKeepAliveWithoutActiveStreams = false;\n+            pingAckTimeoutMillis = DEFAULT_ACK_TIMEOUT.toMillis();\n+            pingWriteCompletionListener = null;\n+        }\n+    }\n+\n+    void pingReceived(final Http2PingFrame pingFrame) {\n+        assert channel.eventLoop().inEventLoop();\n+\n+        if (pingFrame.ack()) {\n+            long pingAckContent = pingFrame.content();\n+            if (pingAckContent == GRACEFUL_CLOSE_PING_CONTENT) {\n+                LOGGER.debug(\"channel={}, graceful close ping ack received.\", channel);\n+                cancelIfStateIsAFuture(gracefulCloseState);\n+                gracefulCloseWriteSecondGoAway();\n+            } else if (pingAckContent == KEEP_ALIVE_PING_CONTENT) {\n+                cancelIfStateIsAFuture(keepAliveState);\n+                keepAliveState = null;\n+            }\n+        } else {\n+            // Send an ack for the received ping\n+            channel.writeAndFlush(new DefaultHttp2PingFrame(pingFrame.content(), true));\n+        }\n+    }\n+\n+    void trackActiveStream(final Channel streamChannel) {\n+        activeChildChannelsUpdater.incrementAndGet(this);\n+        streamChannel.closeFuture().addListener(f -> {\n+            activeChildChannelsUpdater.decrementAndGet(this);\n+            if (activeChildChannels == 0 && gracefulCloseState == GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT) {\n+                close0();\n+            }\n+        });\n+    }\n+\n+    void channelClosed() {\n+        assert channel.eventLoop().inEventLoop();\n+\n+        cancelIfStateIsAFuture(gracefulCloseState);\n+        cancelIfStateIsAFuture(keepAliveState);\n+        gracefulCloseState = CLOSED;\n+        keepAliveState = CLOSED;\n+    }\n+\n+    void initiateGracefulClose(final Runnable whenInitiated) {\n+        EventLoop eventLoop = channel.eventLoop();\n+        if (eventLoop.inEventLoop()) {\n+            doCloseAsyncGracefully0(whenInitiated);\n+        } else {\n+            try {\n+                eventLoop.execute(() -> doCloseAsyncGracefully0(whenInitiated));\n+            } catch (RejectedExecutionException ree) {\n+                close0();\n+                LOGGER.warn(\"channel={} EventLoop rejected a task for graceful shutdown, force closing connection\",\n+                        channel, ree);\n+            }\n+        }\n+    }\n+\n+    void channelIdle() {\n+        assert channel.eventLoop().inEventLoop();\n+        assert pingWriteCompletionListener != null;\n+\n+        if (keepAliveState != null || activeChildChannels == 0 && disallowKeepAliveWithoutActiveStreams) {\n+            return;\n+        }\n+        // idleness detected for the first time, send a ping to detect closure, if any.\n+        keepAliveState = KEEP_ALIVE_ACK_PENDING;\n+        channel.writeAndFlush(new DefaultHttp2PingFrame(KEEP_ALIVE_PING_CONTENT, false))\n+                .addListener(pingWriteCompletionListener);\n+    }\n+\n+    /**\n+     * Scheduler of {@link Runnable}s.\n+     */\n+    @FunctionalInterface\n+    interface Scheduler {\n+\n+        /**\n+         * Run the passed {@link Runnable} after {@code delayInMillis} milliseconds.\n+         *\n+         * @param task {@link Runnable} to run.\n+         * @param delayInMillis Milliseconds after which the task is to be run.\n+         * @return {@link Future} for the scheduled task.\n+         */\n+        Future<?> afterMillis(Runnable task, long delayInMillis);\n+    }\n+\n+    /**\n+     * Scheduler of {@link Runnable}s.\n+     */\n+    @FunctionalInterface\n+    interface IdlenessDetector {\n+        /**\n+         * Configure idleness detection for the passed {@code channel}.\n+         *\n+         * @param channel {@link Channel} for which idleness detection is to be configured.\n+         * @param idlenessThresholdSeconds Seconds of idleness after which {@link Runnable#run()} should be called on\n+         * the passed {@code onIdle}.\n+         * @param onIdle {@link Runnable} to call when the channel is idle more than {@code idlenessThresholdSeconds}.\n+         */\n+        void configure(Channel channel, int idlenessThresholdSeconds, Runnable onIdle);\n+    }\n+\n+    private void doCloseAsyncGracefully0(final Runnable whenInitiated) {\n+        assert channel.eventLoop().inEventLoop();\n+\n+        if (gracefulCloseState != null) {\n+            // either we are already closed or have already initiated graceful closure.\n+            return;\n+        }\n+\n+        whenInitiated.run();\n+\n+        // Set the pingState before doing the write, because we will reference the state\n+        // when we receive the PING(ACK) to determine if action is necessary, and it is conceivable that the\n+        // write future may not be executed which sets the timer.\n+        gracefulCloseState = GRACEFUL_CLOSE_START;\n+\n+        // The graceful close process is described in [1]. It involves sending 2 GOAWAY frames. The first\n+        // GOAWAY has last-stream-id=<maximum stream ID> to indicate no new streams can be created, wait for 2 RTT\n+        // time duration for inflight frames to land, and the second GOAWAY includes the maximum known stream ID.\n+        // To account for 2 RTTs we can send a PING and when the PING(ACK) comes back we can send the second GOAWAY.\n+        // [1] https://tools.ietf.org/html/rfc7540#section-6.8\n+        DefaultHttp2GoAwayFrame goAwayFrame = new DefaultHttp2GoAwayFrame(NO_ERROR);\n+        goAwayFrame.setExtraStreamIds(Integer.MAX_VALUE);\n+        channel.write(goAwayFrame);\n+        channel.writeAndFlush(new DefaultHttp2PingFrame(GRACEFUL_CLOSE_PING_CONTENT)).addListener(future -> {\n+            // If gracefulCloseState is not GRACEFUL_CLOSE_START that means we have already received the PING(ACK) and\n+            // there is no need to apply the timeout.\n+            if (future.isSuccess() && gracefulCloseState == GRACEFUL_CLOSE_START) {\n+                gracefulCloseState = scheduler.afterMillis(() -> {\n+                    // If the PING(ACK) times out we may have under estimated the 2RTT time so we\n+                    // optimistically keep the connection open and rely upon higher level timeouts to tear\n+                    // down the connection.\n+                    LOGGER.debug(\"channel={} timeout {}ms waiting for PING(ACK) during graceful close.\",\n+                            channel, pingAckTimeoutMillis);\n+                    gracefulCloseWriteSecondGoAway();\n+                }, pingAckTimeoutMillis);\n+            }\n+        });\n+    }\n+\n+    private void gracefulCloseWriteSecondGoAway() {\n+        assert channel.eventLoop().inEventLoop();\n+\n+        if (gracefulCloseState == GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT) {\n+            return;\n+        }\n+\n+        gracefulCloseState = GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT;\n+\n+        channel.writeAndFlush(new DefaultHttp2GoAwayFrame(NO_ERROR)).addListener(future -> {\n+            if (activeChildChannels == 0) {\n+                close0();\n+            }\n+        });\n+    }\n+\n+    private void close0() {\n+        assert channel.eventLoop().inEventLoop();\n+\n+        if (gracefulCloseState == CLOSED && keepAliveState == CLOSED) {\n+            return;\n+        }\n+        gracefulCloseState = CLOSED;\n+        keepAliveState = CLOSED;\n+\n+        // The way netty H2 stream state machine works, we may trigger stream closures during writes with flushes\n+        // pending behind the writes. In such cases, we may close too early ignoring the writes. Hence we flush before\n+        // closure, if there is no write pending then flush is a noop.\n+        channel.flush();\n+        channel.close();", "originalCommit": "7de08e1e8f8615b4b427af6e92a10506945321a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5OTk2NA==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r414099964", "bodyText": "(this code is pre-existing, just refactored).\nWe enter here when active streams == 0, there is a fatal error or missing keep-alive. In all these cases we do not expect further graceful closure.\nPractically, this would require we track all writes on the channel from here, ROI of which is arguable here.", "author": "NiteshKant", "createdAt": "2020-04-23T20:25:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY0NjQ0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY0Njg0MQ==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413646841", "bodyText": "cancel(...) should never throw. So I would also not catch it.", "author": "normanmaurer", "createdAt": "2020-04-23T09:09:09Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/KeepAliveManager.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.http.netty.H2ProtocolConfig.KeepAlivePolicy;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.DefaultHttp2GoAwayFrame;\n+import io.netty.handler.codec.http2.DefaultHttp2PingFrame;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.GenericFutureListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.http2.Http2Error.NO_ERROR;\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_ACK_TIMEOUT;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+/**\n+ * An implementation of {@link KeepAlivePolicy} per {@link Channel}.\n+ */\n+final class KeepAliveManager {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KeepAliveManager.class);\n+    private static final AtomicIntegerFieldUpdater<KeepAliveManager> activeChildChannelsUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(KeepAliveManager.class, \"activeChildChannels\");\n+    private static final long GRACEFUL_CLOSE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final long KEEP_ALIVE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final Object CLOSED = new Object();\n+    private static final Object GRACEFUL_CLOSE_START = new Object();\n+    private static final Object GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT = new Object();\n+    private static final Object KEEP_ALIVE_ACK_PENDING = new Object();\n+    private static final Object KEEP_ALIVE_ACK_TIMEDOUT = new Object();\n+\n+    private volatile int activeChildChannels;\n+\n+    private final Channel channel;\n+    private final long pingAckTimeoutMillis;\n+    private final boolean disallowKeepAliveWithoutActiveStreams;\n+    private final Scheduler scheduler;\n+\n+    // below state should only be accessed from eventloop\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if graceful close has not started.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_START} if graceful close process has been initiated.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent to measure RTT.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT} if we have sent the second go away frame.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object gracefulCloseState;\n+\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if keep-alive PING process is not started.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_PENDING} if a keep-alive PING has been sent but ack is not received.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_TIMEDOUT} if we fail to receive a PING ack for the configured timeout.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object keepAliveState;\n+    @Nullable\n+    private final GenericFutureListener<Future<? super Void>> pingWriteCompletionListener;\n+\n+    KeepAliveManager(final Channel channel, @Nullable final KeepAlivePolicy keepAlivePolicy) {\n+        this(channel, keepAlivePolicy, (task, delayInMillis) ->\n+                channel.eventLoop().schedule(task, delayInMillis, MILLISECONDS),\n+                (ch, idlenessThresholdSeconds, onIdle) -> ch.pipeline().addLast(\n+                        new IdleStateHandler(idlenessThresholdSeconds, idlenessThresholdSeconds, 0) {\n+                            @Override\n+                            protected void channelIdle(final ChannelHandlerContext ctx, final IdleStateEvent evt) {\n+                                onIdle.run();\n+                            }\n+                        }));\n+    }\n+\n+    KeepAliveManager(final Channel channel, @Nullable final KeepAlivePolicy keepAlivePolicy,\n+                     final Scheduler scheduler, final IdlenessDetector idlenessDetector) {\n+        this.channel = channel;\n+        this.scheduler = scheduler;\n+        if (keepAlivePolicy != null) {\n+            disallowKeepAliveWithoutActiveStreams = !keepAlivePolicy.withoutActiveStreams();\n+            pingAckTimeoutMillis = keepAlivePolicy.ackTimeout().toMillis();\n+            final GenericFutureListener<Future<? super Void>> goAwayListener = f -> {\n+                if (f.isSuccess()) {\n+                    LOGGER.debug(\"Closing channel={}, after keep-alive timeout.\", this.channel);\n+                    KeepAliveManager.this.close0();\n+                }\n+            };\n+            pingWriteCompletionListener = future -> {\n+                if (future.isSuccess() && keepAliveState == KEEP_ALIVE_ACK_PENDING) {\n+                    // Schedule a task to verify ping ack within the pingAckTimeoutMillis\n+                    keepAliveState = scheduler.afterMillis(() -> {\n+                        if (keepAliveState != null) {\n+                            keepAliveState = KEEP_ALIVE_ACK_TIMEDOUT;\n+                            LOGGER.debug(\n+                                    \"channel={}, timeout {}ms waiting for keep-alive PING(ACK), writing go_away.\",\n+                                    this.channel, pingAckTimeoutMillis);\n+                            channel.writeAndFlush(new DefaultHttp2GoAwayFrame(NO_ERROR))\n+                                    .addListener(goAwayListener);\n+                        }\n+                    }, pingAckTimeoutMillis);\n+                }\n+            };\n+            int idleInSeconds = (int) keepAlivePolicy.idleDuration().getSeconds();\n+            idlenessDetector.configure(channel, idleInSeconds, this::channelIdle);\n+        } else {\n+            disallowKeepAliveWithoutActiveStreams = false;\n+            pingAckTimeoutMillis = DEFAULT_ACK_TIMEOUT.toMillis();\n+            pingWriteCompletionListener = null;\n+        }\n+    }\n+\n+    void pingReceived(final Http2PingFrame pingFrame) {\n+        assert channel.eventLoop().inEventLoop();\n+\n+        if (pingFrame.ack()) {\n+            long pingAckContent = pingFrame.content();\n+            if (pingAckContent == GRACEFUL_CLOSE_PING_CONTENT) {\n+                LOGGER.debug(\"channel={}, graceful close ping ack received.\", channel);\n+                cancelIfStateIsAFuture(gracefulCloseState);\n+                gracefulCloseWriteSecondGoAway();\n+            } else if (pingAckContent == KEEP_ALIVE_PING_CONTENT) {\n+                cancelIfStateIsAFuture(keepAliveState);\n+                keepAliveState = null;\n+            }\n+        } else {\n+            // Send an ack for the received ping\n+            channel.writeAndFlush(new DefaultHttp2PingFrame(pingFrame.content(), true));\n+        }\n+    }\n+\n+    void trackActiveStream(final Channel streamChannel) {\n+        activeChildChannelsUpdater.incrementAndGet(this);\n+        streamChannel.closeFuture().addListener(f -> {\n+            activeChildChannelsUpdater.decrementAndGet(this);\n+            if (activeChildChannels == 0 && gracefulCloseState == GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT) {\n+                close0();\n+            }\n+        });\n+    }\n+\n+    void channelClosed() {\n+        assert channel.eventLoop().inEventLoop();\n+\n+        cancelIfStateIsAFuture(gracefulCloseState);\n+        cancelIfStateIsAFuture(keepAliveState);\n+        gracefulCloseState = CLOSED;\n+        keepAliveState = CLOSED;\n+    }\n+\n+    void initiateGracefulClose(final Runnable whenInitiated) {\n+        EventLoop eventLoop = channel.eventLoop();\n+        if (eventLoop.inEventLoop()) {\n+            doCloseAsyncGracefully0(whenInitiated);\n+        } else {\n+            try {\n+                eventLoop.execute(() -> doCloseAsyncGracefully0(whenInitiated));\n+            } catch (RejectedExecutionException ree) {\n+                close0();\n+                LOGGER.warn(\"channel={} EventLoop rejected a task for graceful shutdown, force closing connection\",\n+                        channel, ree);\n+            }\n+        }\n+    }\n+\n+    void channelIdle() {\n+        assert channel.eventLoop().inEventLoop();\n+        assert pingWriteCompletionListener != null;\n+\n+        if (keepAliveState != null || activeChildChannels == 0 && disallowKeepAliveWithoutActiveStreams) {\n+            return;\n+        }\n+        // idleness detected for the first time, send a ping to detect closure, if any.\n+        keepAliveState = KEEP_ALIVE_ACK_PENDING;\n+        channel.writeAndFlush(new DefaultHttp2PingFrame(KEEP_ALIVE_PING_CONTENT, false))\n+                .addListener(pingWriteCompletionListener);\n+    }\n+\n+    /**\n+     * Scheduler of {@link Runnable}s.\n+     */\n+    @FunctionalInterface\n+    interface Scheduler {\n+\n+        /**\n+         * Run the passed {@link Runnable} after {@code delayInMillis} milliseconds.\n+         *\n+         * @param task {@link Runnable} to run.\n+         * @param delayInMillis Milliseconds after which the task is to be run.\n+         * @return {@link Future} for the scheduled task.\n+         */\n+        Future<?> afterMillis(Runnable task, long delayInMillis);\n+    }\n+\n+    /**\n+     * Scheduler of {@link Runnable}s.\n+     */\n+    @FunctionalInterface\n+    interface IdlenessDetector {\n+        /**\n+         * Configure idleness detection for the passed {@code channel}.\n+         *\n+         * @param channel {@link Channel} for which idleness detection is to be configured.\n+         * @param idlenessThresholdSeconds Seconds of idleness after which {@link Runnable#run()} should be called on\n+         * the passed {@code onIdle}.\n+         * @param onIdle {@link Runnable} to call when the channel is idle more than {@code idlenessThresholdSeconds}.\n+         */\n+        void configure(Channel channel, int idlenessThresholdSeconds, Runnable onIdle);\n+    }\n+\n+    private void doCloseAsyncGracefully0(final Runnable whenInitiated) {\n+        assert channel.eventLoop().inEventLoop();\n+\n+        if (gracefulCloseState != null) {\n+            // either we are already closed or have already initiated graceful closure.\n+            return;\n+        }\n+\n+        whenInitiated.run();\n+\n+        // Set the pingState before doing the write, because we will reference the state\n+        // when we receive the PING(ACK) to determine if action is necessary, and it is conceivable that the\n+        // write future may not be executed which sets the timer.\n+        gracefulCloseState = GRACEFUL_CLOSE_START;\n+\n+        // The graceful close process is described in [1]. It involves sending 2 GOAWAY frames. The first\n+        // GOAWAY has last-stream-id=<maximum stream ID> to indicate no new streams can be created, wait for 2 RTT\n+        // time duration for inflight frames to land, and the second GOAWAY includes the maximum known stream ID.\n+        // To account for 2 RTTs we can send a PING and when the PING(ACK) comes back we can send the second GOAWAY.\n+        // [1] https://tools.ietf.org/html/rfc7540#section-6.8\n+        DefaultHttp2GoAwayFrame goAwayFrame = new DefaultHttp2GoAwayFrame(NO_ERROR);\n+        goAwayFrame.setExtraStreamIds(Integer.MAX_VALUE);\n+        channel.write(goAwayFrame);\n+        channel.writeAndFlush(new DefaultHttp2PingFrame(GRACEFUL_CLOSE_PING_CONTENT)).addListener(future -> {\n+            // If gracefulCloseState is not GRACEFUL_CLOSE_START that means we have already received the PING(ACK) and\n+            // there is no need to apply the timeout.\n+            if (future.isSuccess() && gracefulCloseState == GRACEFUL_CLOSE_START) {\n+                gracefulCloseState = scheduler.afterMillis(() -> {\n+                    // If the PING(ACK) times out we may have under estimated the 2RTT time so we\n+                    // optimistically keep the connection open and rely upon higher level timeouts to tear\n+                    // down the connection.\n+                    LOGGER.debug(\"channel={} timeout {}ms waiting for PING(ACK) during graceful close.\",\n+                            channel, pingAckTimeoutMillis);\n+                    gracefulCloseWriteSecondGoAway();\n+                }, pingAckTimeoutMillis);\n+            }\n+        });\n+    }\n+\n+    private void gracefulCloseWriteSecondGoAway() {\n+        assert channel.eventLoop().inEventLoop();\n+\n+        if (gracefulCloseState == GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT) {\n+            return;\n+        }\n+\n+        gracefulCloseState = GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT;\n+\n+        channel.writeAndFlush(new DefaultHttp2GoAwayFrame(NO_ERROR)).addListener(future -> {\n+            if (activeChildChannels == 0) {\n+                close0();\n+            }\n+        });\n+    }\n+\n+    private void close0() {\n+        assert channel.eventLoop().inEventLoop();\n+\n+        if (gracefulCloseState == CLOSED && keepAliveState == CLOSED) {\n+            return;\n+        }\n+        gracefulCloseState = CLOSED;\n+        keepAliveState = CLOSED;\n+\n+        // The way netty H2 stream state machine works, we may trigger stream closures during writes with flushes\n+        // pending behind the writes. In such cases, we may close too early ignoring the writes. Hence we flush before\n+        // closure, if there is no write pending then flush is a noop.\n+        channel.flush();\n+        channel.close();\n+    }\n+\n+    private void cancelIfStateIsAFuture(@Nullable final Object state) {\n+        if (state instanceof Future) {\n+            try {\n+                ((Future<?>) state).cancel(true);", "originalCommit": "7de08e1e8f8615b4b427af6e92a10506945321a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEwMDUzMQ==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r414100531", "bodyText": "Whenever there is a state cleanup required (here sending a second go away for example) we just are pedantic about unexpected exceptions. So, this is inline with other places.", "author": "NiteshKant", "createdAt": "2020-04-23T20:26:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY0Njg0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkzMTc1NA==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413931754", "bodyText": "nit: this is only used in a single place, consider just inlining it.", "author": "Scottmitch", "createdAt": "2020-04-23T16:12:28Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/KeepAliveManager.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.http.netty.H2ProtocolConfig.KeepAlivePolicy;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.DefaultHttp2GoAwayFrame;\n+import io.netty.handler.codec.http2.DefaultHttp2PingFrame;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.GenericFutureListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.http2.Http2Error.NO_ERROR;\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_ACK_TIMEOUT;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+/**\n+ * An implementation of {@link KeepAlivePolicy} per {@link Channel}.\n+ */\n+final class KeepAliveManager {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KeepAliveManager.class);\n+    private static final AtomicIntegerFieldUpdater<KeepAliveManager> activeChildChannelsUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(KeepAliveManager.class, \"activeChildChannels\");\n+    private static final long GRACEFUL_CLOSE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final long KEEP_ALIVE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final Object CLOSED = new Object();\n+    private static final Object GRACEFUL_CLOSE_START = new Object();\n+    private static final Object GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT = new Object();\n+    private static final Object KEEP_ALIVE_ACK_PENDING = new Object();\n+    private static final Object KEEP_ALIVE_ACK_TIMEDOUT = new Object();\n+\n+    private volatile int activeChildChannels;\n+\n+    private final Channel channel;\n+    private final long pingAckTimeoutMillis;\n+    private final boolean disallowKeepAliveWithoutActiveStreams;\n+    private final Scheduler scheduler;\n+\n+    // below state should only be accessed from eventloop\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if graceful close has not started.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_START} if graceful close process has been initiated.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent to measure RTT.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT} if we have sent the second go away frame.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object gracefulCloseState;\n+\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if keep-alive PING process is not started.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_PENDING} if a keep-alive PING has been sent but ack is not received.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_TIMEDOUT} if we fail to receive a PING ack for the configured timeout.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object keepAliveState;\n+    @Nullable\n+    private final GenericFutureListener<Future<? super Void>> pingWriteCompletionListener;\n+\n+    KeepAliveManager(final Channel channel, @Nullable final KeepAlivePolicy keepAlivePolicy) {\n+        this(channel, keepAlivePolicy, (task, delayInMillis) ->\n+                channel.eventLoop().schedule(task, delayInMillis, MILLISECONDS),\n+                (ch, idlenessThresholdSeconds, onIdle) -> ch.pipeline().addLast(\n+                        new IdleStateHandler(idlenessThresholdSeconds, idlenessThresholdSeconds, 0) {\n+                            @Override\n+                            protected void channelIdle(final ChannelHandlerContext ctx, final IdleStateEvent evt) {\n+                                onIdle.run();\n+                            }\n+                        }));\n+    }\n+\n+    KeepAliveManager(final Channel channel, @Nullable final KeepAlivePolicy keepAlivePolicy,\n+                     final Scheduler scheduler, final IdlenessDetector idlenessDetector) {\n+        this.channel = channel;\n+        this.scheduler = scheduler;\n+        if (keepAlivePolicy != null) {\n+            disallowKeepAliveWithoutActiveStreams = !keepAlivePolicy.withoutActiveStreams();\n+            pingAckTimeoutMillis = keepAlivePolicy.ackTimeout().toMillis();\n+            final GenericFutureListener<Future<? super Void>> goAwayListener = f -> {", "originalCommit": "7de08e1e8f8615b4b427af6e92a10506945321a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE2MDU5MA==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r414160590", "bodyText": "There was another comment that suggested not to inline but cache the value instead :)\n#1029 (comment)", "author": "idelpivnitskiy", "createdAt": "2020-04-23T22:16:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkzMTc1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE2Mzc1OA==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r414163758", "bodyText": "go_away is once (or twice) per connection on shutdown so I don't think GC would be the dominating factor here (vs readability).", "author": "Scottmitch", "createdAt": "2020-04-23T22:23:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkzMTc1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk0ODM2Ng==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413948366", "bodyText": "lets use the result of the atomic operation activeChildChannelsUpdater.decrementAndGet(this) == 0 instead of decrement and then re-read/check independently.\npending @idelpivnitskiy question/suggestion above maybe we can kill the atomics too and force everything on the event loop.", "author": "Scottmitch", "createdAt": "2020-04-23T16:33:58Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/KeepAliveManager.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.http.netty.H2ProtocolConfig.KeepAlivePolicy;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.DefaultHttp2GoAwayFrame;\n+import io.netty.handler.codec.http2.DefaultHttp2PingFrame;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.GenericFutureListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.http2.Http2Error.NO_ERROR;\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_ACK_TIMEOUT;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+/**\n+ * An implementation of {@link KeepAlivePolicy} per {@link Channel}.\n+ */\n+final class KeepAliveManager {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KeepAliveManager.class);\n+    private static final AtomicIntegerFieldUpdater<KeepAliveManager> activeChildChannelsUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(KeepAliveManager.class, \"activeChildChannels\");\n+    private static final long GRACEFUL_CLOSE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final long KEEP_ALIVE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final Object CLOSED = new Object();\n+    private static final Object GRACEFUL_CLOSE_START = new Object();\n+    private static final Object GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT = new Object();\n+    private static final Object KEEP_ALIVE_ACK_PENDING = new Object();\n+    private static final Object KEEP_ALIVE_ACK_TIMEDOUT = new Object();\n+\n+    private volatile int activeChildChannels;\n+\n+    private final Channel channel;\n+    private final long pingAckTimeoutMillis;\n+    private final boolean disallowKeepAliveWithoutActiveStreams;\n+    private final Scheduler scheduler;\n+\n+    // below state should only be accessed from eventloop\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if graceful close has not started.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_START} if graceful close process has been initiated.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent to measure RTT.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT} if we have sent the second go away frame.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object gracefulCloseState;\n+\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if keep-alive PING process is not started.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_PENDING} if a keep-alive PING has been sent but ack is not received.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_TIMEDOUT} if we fail to receive a PING ack for the configured timeout.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object keepAliveState;\n+    @Nullable\n+    private final GenericFutureListener<Future<? super Void>> pingWriteCompletionListener;\n+\n+    KeepAliveManager(final Channel channel, @Nullable final KeepAlivePolicy keepAlivePolicy) {\n+        this(channel, keepAlivePolicy, (task, delayInMillis) ->\n+                channel.eventLoop().schedule(task, delayInMillis, MILLISECONDS),\n+                (ch, idlenessThresholdSeconds, onIdle) -> ch.pipeline().addLast(\n+                        new IdleStateHandler(idlenessThresholdSeconds, idlenessThresholdSeconds, 0) {\n+                            @Override\n+                            protected void channelIdle(final ChannelHandlerContext ctx, final IdleStateEvent evt) {\n+                                onIdle.run();\n+                            }\n+                        }));\n+    }\n+\n+    KeepAliveManager(final Channel channel, @Nullable final KeepAlivePolicy keepAlivePolicy,\n+                     final Scheduler scheduler, final IdlenessDetector idlenessDetector) {\n+        this.channel = channel;\n+        this.scheduler = scheduler;\n+        if (keepAlivePolicy != null) {\n+            disallowKeepAliveWithoutActiveStreams = !keepAlivePolicy.withoutActiveStreams();\n+            pingAckTimeoutMillis = keepAlivePolicy.ackTimeout().toMillis();\n+            final GenericFutureListener<Future<? super Void>> goAwayListener = f -> {\n+                if (f.isSuccess()) {\n+                    LOGGER.debug(\"Closing channel={}, after keep-alive timeout.\", this.channel);\n+                    KeepAliveManager.this.close0();\n+                }\n+            };\n+            pingWriteCompletionListener = future -> {\n+                if (future.isSuccess() && keepAliveState == KEEP_ALIVE_ACK_PENDING) {\n+                    // Schedule a task to verify ping ack within the pingAckTimeoutMillis\n+                    keepAliveState = scheduler.afterMillis(() -> {\n+                        if (keepAliveState != null) {\n+                            keepAliveState = KEEP_ALIVE_ACK_TIMEDOUT;\n+                            LOGGER.debug(\n+                                    \"channel={}, timeout {}ms waiting for keep-alive PING(ACK), writing go_away.\",\n+                                    this.channel, pingAckTimeoutMillis);\n+                            channel.writeAndFlush(new DefaultHttp2GoAwayFrame(NO_ERROR))\n+                                    .addListener(goAwayListener);\n+                        }\n+                    }, pingAckTimeoutMillis);\n+                }\n+            };\n+            int idleInSeconds = (int) keepAlivePolicy.idleDuration().getSeconds();\n+            idlenessDetector.configure(channel, idleInSeconds, this::channelIdle);\n+        } else {\n+            disallowKeepAliveWithoutActiveStreams = false;\n+            pingAckTimeoutMillis = DEFAULT_ACK_TIMEOUT.toMillis();\n+            pingWriteCompletionListener = null;\n+        }\n+    }\n+\n+    void pingReceived(final Http2PingFrame pingFrame) {\n+        assert channel.eventLoop().inEventLoop();\n+\n+        if (pingFrame.ack()) {\n+            long pingAckContent = pingFrame.content();\n+            if (pingAckContent == GRACEFUL_CLOSE_PING_CONTENT) {\n+                LOGGER.debug(\"channel={}, graceful close ping ack received.\", channel);\n+                cancelIfStateIsAFuture(gracefulCloseState);\n+                gracefulCloseWriteSecondGoAway();\n+            } else if (pingAckContent == KEEP_ALIVE_PING_CONTENT) {\n+                cancelIfStateIsAFuture(keepAliveState);\n+                keepAliveState = null;\n+            }\n+        } else {\n+            // Send an ack for the received ping\n+            channel.writeAndFlush(new DefaultHttp2PingFrame(pingFrame.content(), true));\n+        }\n+    }\n+\n+    void trackActiveStream(final Channel streamChannel) {\n+        activeChildChannelsUpdater.incrementAndGet(this);\n+        streamChannel.closeFuture().addListener(f -> {\n+            activeChildChannelsUpdater.decrementAndGet(this);", "originalCommit": "7de08e1e8f8615b4b427af6e92a10506945321a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEwMjQ1Mg==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r414102452", "bodyText": "I will defer the inEventLoop assumption as this is pre-existing code.", "author": "NiteshKant", "createdAt": "2020-04-23T20:30:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk0ODM2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1MjQ5Ng==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413952496", "bodyText": "RejectedExecutionException -> Throwable? Do we want some exceptions to potentially escape and rely upon other layers for cleanup of async control flow and force a close, or should we just force a closure here?", "author": "Scottmitch", "createdAt": "2020-04-23T16:39:38Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/KeepAliveManager.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.http.netty.H2ProtocolConfig.KeepAlivePolicy;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.DefaultHttp2GoAwayFrame;\n+import io.netty.handler.codec.http2.DefaultHttp2PingFrame;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.GenericFutureListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.http2.Http2Error.NO_ERROR;\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_ACK_TIMEOUT;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+/**\n+ * An implementation of {@link KeepAlivePolicy} per {@link Channel}.\n+ */\n+final class KeepAliveManager {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KeepAliveManager.class);\n+    private static final AtomicIntegerFieldUpdater<KeepAliveManager> activeChildChannelsUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(KeepAliveManager.class, \"activeChildChannels\");\n+    private static final long GRACEFUL_CLOSE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final long KEEP_ALIVE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final Object CLOSED = new Object();\n+    private static final Object GRACEFUL_CLOSE_START = new Object();\n+    private static final Object GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT = new Object();\n+    private static final Object KEEP_ALIVE_ACK_PENDING = new Object();\n+    private static final Object KEEP_ALIVE_ACK_TIMEDOUT = new Object();\n+\n+    private volatile int activeChildChannels;\n+\n+    private final Channel channel;\n+    private final long pingAckTimeoutMillis;\n+    private final boolean disallowKeepAliveWithoutActiveStreams;\n+    private final Scheduler scheduler;\n+\n+    // below state should only be accessed from eventloop\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if graceful close has not started.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_START} if graceful close process has been initiated.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent to measure RTT.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT} if we have sent the second go away frame.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object gracefulCloseState;\n+\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if keep-alive PING process is not started.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_PENDING} if a keep-alive PING has been sent but ack is not received.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_TIMEDOUT} if we fail to receive a PING ack for the configured timeout.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object keepAliveState;\n+    @Nullable\n+    private final GenericFutureListener<Future<? super Void>> pingWriteCompletionListener;\n+\n+    KeepAliveManager(final Channel channel, @Nullable final KeepAlivePolicy keepAlivePolicy) {\n+        this(channel, keepAlivePolicy, (task, delayInMillis) ->\n+                channel.eventLoop().schedule(task, delayInMillis, MILLISECONDS),\n+                (ch, idlenessThresholdSeconds, onIdle) -> ch.pipeline().addLast(\n+                        new IdleStateHandler(idlenessThresholdSeconds, idlenessThresholdSeconds, 0) {\n+                            @Override\n+                            protected void channelIdle(final ChannelHandlerContext ctx, final IdleStateEvent evt) {\n+                                onIdle.run();\n+                            }\n+                        }));\n+    }\n+\n+    KeepAliveManager(final Channel channel, @Nullable final KeepAlivePolicy keepAlivePolicy,\n+                     final Scheduler scheduler, final IdlenessDetector idlenessDetector) {\n+        this.channel = channel;\n+        this.scheduler = scheduler;\n+        if (keepAlivePolicy != null) {\n+            disallowKeepAliveWithoutActiveStreams = !keepAlivePolicy.withoutActiveStreams();\n+            pingAckTimeoutMillis = keepAlivePolicy.ackTimeout().toMillis();\n+            final GenericFutureListener<Future<? super Void>> goAwayListener = f -> {\n+                if (f.isSuccess()) {\n+                    LOGGER.debug(\"Closing channel={}, after keep-alive timeout.\", this.channel);\n+                    KeepAliveManager.this.close0();\n+                }\n+            };\n+            pingWriteCompletionListener = future -> {\n+                if (future.isSuccess() && keepAliveState == KEEP_ALIVE_ACK_PENDING) {\n+                    // Schedule a task to verify ping ack within the pingAckTimeoutMillis\n+                    keepAliveState = scheduler.afterMillis(() -> {\n+                        if (keepAliveState != null) {\n+                            keepAliveState = KEEP_ALIVE_ACK_TIMEDOUT;\n+                            LOGGER.debug(\n+                                    \"channel={}, timeout {}ms waiting for keep-alive PING(ACK), writing go_away.\",\n+                                    this.channel, pingAckTimeoutMillis);\n+                            channel.writeAndFlush(new DefaultHttp2GoAwayFrame(NO_ERROR))\n+                                    .addListener(goAwayListener);\n+                        }\n+                    }, pingAckTimeoutMillis);\n+                }\n+            };\n+            int idleInSeconds = (int) keepAlivePolicy.idleDuration().getSeconds();\n+            idlenessDetector.configure(channel, idleInSeconds, this::channelIdle);\n+        } else {\n+            disallowKeepAliveWithoutActiveStreams = false;\n+            pingAckTimeoutMillis = DEFAULT_ACK_TIMEOUT.toMillis();\n+            pingWriteCompletionListener = null;\n+        }\n+    }\n+\n+    void pingReceived(final Http2PingFrame pingFrame) {\n+        assert channel.eventLoop().inEventLoop();\n+\n+        if (pingFrame.ack()) {\n+            long pingAckContent = pingFrame.content();\n+            if (pingAckContent == GRACEFUL_CLOSE_PING_CONTENT) {\n+                LOGGER.debug(\"channel={}, graceful close ping ack received.\", channel);\n+                cancelIfStateIsAFuture(gracefulCloseState);\n+                gracefulCloseWriteSecondGoAway();\n+            } else if (pingAckContent == KEEP_ALIVE_PING_CONTENT) {\n+                cancelIfStateIsAFuture(keepAliveState);\n+                keepAliveState = null;\n+            }\n+        } else {\n+            // Send an ack for the received ping\n+            channel.writeAndFlush(new DefaultHttp2PingFrame(pingFrame.content(), true));\n+        }\n+    }\n+\n+    void trackActiveStream(final Channel streamChannel) {\n+        activeChildChannelsUpdater.incrementAndGet(this);\n+        streamChannel.closeFuture().addListener(f -> {\n+            activeChildChannelsUpdater.decrementAndGet(this);\n+            if (activeChildChannels == 0 && gracefulCloseState == GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT) {\n+                close0();\n+            }\n+        });\n+    }\n+\n+    void channelClosed() {\n+        assert channel.eventLoop().inEventLoop();\n+\n+        cancelIfStateIsAFuture(gracefulCloseState);\n+        cancelIfStateIsAFuture(keepAliveState);\n+        gracefulCloseState = CLOSED;\n+        keepAliveState = CLOSED;\n+    }\n+\n+    void initiateGracefulClose(final Runnable whenInitiated) {\n+        EventLoop eventLoop = channel.eventLoop();\n+        if (eventLoop.inEventLoop()) {\n+            doCloseAsyncGracefully0(whenInitiated);\n+        } else {\n+            try {\n+                eventLoop.execute(() -> doCloseAsyncGracefully0(whenInitiated));\n+            } catch (RejectedExecutionException ree) {", "originalCommit": "7de08e1e8f8615b4b427af6e92a10506945321a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEwNDQxNQ==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r414104415", "bodyText": "Lemme just remove the error handling here as this has been changed twice based on comments. All callers handle errors from here and have more context how to handle exceptions.", "author": "NiteshKant", "createdAt": "2020-04-23T20:33:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1MjQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1MzE2NQ==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413953165", "bodyText": "this method reads/modifies state that is only expected to be touched in the event loop, consider just hard-closing (e.g. flush/close).", "author": "Scottmitch", "createdAt": "2020-04-23T16:40:36Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/KeepAliveManager.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.http.netty.H2ProtocolConfig.KeepAlivePolicy;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.DefaultHttp2GoAwayFrame;\n+import io.netty.handler.codec.http2.DefaultHttp2PingFrame;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.GenericFutureListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.http2.Http2Error.NO_ERROR;\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_ACK_TIMEOUT;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+/**\n+ * An implementation of {@link KeepAlivePolicy} per {@link Channel}.\n+ */\n+final class KeepAliveManager {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KeepAliveManager.class);\n+    private static final AtomicIntegerFieldUpdater<KeepAliveManager> activeChildChannelsUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(KeepAliveManager.class, \"activeChildChannels\");\n+    private static final long GRACEFUL_CLOSE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final long KEEP_ALIVE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final Object CLOSED = new Object();\n+    private static final Object GRACEFUL_CLOSE_START = new Object();\n+    private static final Object GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT = new Object();\n+    private static final Object KEEP_ALIVE_ACK_PENDING = new Object();\n+    private static final Object KEEP_ALIVE_ACK_TIMEDOUT = new Object();\n+\n+    private volatile int activeChildChannels;\n+\n+    private final Channel channel;\n+    private final long pingAckTimeoutMillis;\n+    private final boolean disallowKeepAliveWithoutActiveStreams;\n+    private final Scheduler scheduler;\n+\n+    // below state should only be accessed from eventloop\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if graceful close has not started.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_START} if graceful close process has been initiated.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent to measure RTT.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT} if we have sent the second go away frame.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object gracefulCloseState;\n+\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if keep-alive PING process is not started.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_PENDING} if a keep-alive PING has been sent but ack is not received.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_TIMEDOUT} if we fail to receive a PING ack for the configured timeout.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object keepAliveState;\n+    @Nullable\n+    private final GenericFutureListener<Future<? super Void>> pingWriteCompletionListener;\n+\n+    KeepAliveManager(final Channel channel, @Nullable final KeepAlivePolicy keepAlivePolicy) {\n+        this(channel, keepAlivePolicy, (task, delayInMillis) ->\n+                channel.eventLoop().schedule(task, delayInMillis, MILLISECONDS),\n+                (ch, idlenessThresholdSeconds, onIdle) -> ch.pipeline().addLast(\n+                        new IdleStateHandler(idlenessThresholdSeconds, idlenessThresholdSeconds, 0) {\n+                            @Override\n+                            protected void channelIdle(final ChannelHandlerContext ctx, final IdleStateEvent evt) {\n+                                onIdle.run();\n+                            }\n+                        }));\n+    }\n+\n+    KeepAliveManager(final Channel channel, @Nullable final KeepAlivePolicy keepAlivePolicy,\n+                     final Scheduler scheduler, final IdlenessDetector idlenessDetector) {\n+        this.channel = channel;\n+        this.scheduler = scheduler;\n+        if (keepAlivePolicy != null) {\n+            disallowKeepAliveWithoutActiveStreams = !keepAlivePolicy.withoutActiveStreams();\n+            pingAckTimeoutMillis = keepAlivePolicy.ackTimeout().toMillis();\n+            final GenericFutureListener<Future<? super Void>> goAwayListener = f -> {\n+                if (f.isSuccess()) {\n+                    LOGGER.debug(\"Closing channel={}, after keep-alive timeout.\", this.channel);\n+                    KeepAliveManager.this.close0();\n+                }\n+            };\n+            pingWriteCompletionListener = future -> {\n+                if (future.isSuccess() && keepAliveState == KEEP_ALIVE_ACK_PENDING) {\n+                    // Schedule a task to verify ping ack within the pingAckTimeoutMillis\n+                    keepAliveState = scheduler.afterMillis(() -> {\n+                        if (keepAliveState != null) {\n+                            keepAliveState = KEEP_ALIVE_ACK_TIMEDOUT;\n+                            LOGGER.debug(\n+                                    \"channel={}, timeout {}ms waiting for keep-alive PING(ACK), writing go_away.\",\n+                                    this.channel, pingAckTimeoutMillis);\n+                            channel.writeAndFlush(new DefaultHttp2GoAwayFrame(NO_ERROR))\n+                                    .addListener(goAwayListener);\n+                        }\n+                    }, pingAckTimeoutMillis);\n+                }\n+            };\n+            int idleInSeconds = (int) keepAlivePolicy.idleDuration().getSeconds();\n+            idlenessDetector.configure(channel, idleInSeconds, this::channelIdle);\n+        } else {\n+            disallowKeepAliveWithoutActiveStreams = false;\n+            pingAckTimeoutMillis = DEFAULT_ACK_TIMEOUT.toMillis();\n+            pingWriteCompletionListener = null;\n+        }\n+    }\n+\n+    void pingReceived(final Http2PingFrame pingFrame) {\n+        assert channel.eventLoop().inEventLoop();\n+\n+        if (pingFrame.ack()) {\n+            long pingAckContent = pingFrame.content();\n+            if (pingAckContent == GRACEFUL_CLOSE_PING_CONTENT) {\n+                LOGGER.debug(\"channel={}, graceful close ping ack received.\", channel);\n+                cancelIfStateIsAFuture(gracefulCloseState);\n+                gracefulCloseWriteSecondGoAway();\n+            } else if (pingAckContent == KEEP_ALIVE_PING_CONTENT) {\n+                cancelIfStateIsAFuture(keepAliveState);\n+                keepAliveState = null;\n+            }\n+        } else {\n+            // Send an ack for the received ping\n+            channel.writeAndFlush(new DefaultHttp2PingFrame(pingFrame.content(), true));\n+        }\n+    }\n+\n+    void trackActiveStream(final Channel streamChannel) {\n+        activeChildChannelsUpdater.incrementAndGet(this);\n+        streamChannel.closeFuture().addListener(f -> {\n+            activeChildChannelsUpdater.decrementAndGet(this);\n+            if (activeChildChannels == 0 && gracefulCloseState == GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT) {\n+                close0();\n+            }\n+        });\n+    }\n+\n+    void channelClosed() {\n+        assert channel.eventLoop().inEventLoop();\n+\n+        cancelIfStateIsAFuture(gracefulCloseState);\n+        cancelIfStateIsAFuture(keepAliveState);\n+        gracefulCloseState = CLOSED;\n+        keepAliveState = CLOSED;\n+    }\n+\n+    void initiateGracefulClose(final Runnable whenInitiated) {\n+        EventLoop eventLoop = channel.eventLoop();\n+        if (eventLoop.inEventLoop()) {\n+            doCloseAsyncGracefully0(whenInitiated);\n+        } else {\n+            try {\n+                eventLoop.execute(() -> doCloseAsyncGracefully0(whenInitiated));\n+            } catch (RejectedExecutionException ree) {\n+                close0();", "originalCommit": "7de08e1e8f8615b4b427af6e92a10506945321a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE3ODIwMQ==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r414178201", "bodyText": "I removed the error handling here.", "author": "NiteshKant", "createdAt": "2020-04-23T22:57:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1MzE2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk2MDg3NQ==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413960875", "bodyText": "this will overflow to a negative number if getSeconds() > Integer.MAX_VALUE", "author": "Scottmitch", "createdAt": "2020-04-23T16:51:32Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/KeepAliveManager.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.http.netty.H2ProtocolConfig.KeepAlivePolicy;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.DefaultHttp2GoAwayFrame;\n+import io.netty.handler.codec.http2.DefaultHttp2PingFrame;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.GenericFutureListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.http2.Http2Error.NO_ERROR;\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_ACK_TIMEOUT;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+/**\n+ * An implementation of {@link KeepAlivePolicy} per {@link Channel}.\n+ */\n+final class KeepAliveManager {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KeepAliveManager.class);\n+    private static final AtomicIntegerFieldUpdater<KeepAliveManager> activeChildChannelsUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(KeepAliveManager.class, \"activeChildChannels\");\n+    private static final long GRACEFUL_CLOSE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final long KEEP_ALIVE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final Object CLOSED = new Object();\n+    private static final Object GRACEFUL_CLOSE_START = new Object();\n+    private static final Object GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT = new Object();\n+    private static final Object KEEP_ALIVE_ACK_PENDING = new Object();\n+    private static final Object KEEP_ALIVE_ACK_TIMEDOUT = new Object();\n+\n+    private volatile int activeChildChannels;\n+\n+    private final Channel channel;\n+    private final long pingAckTimeoutMillis;\n+    private final boolean disallowKeepAliveWithoutActiveStreams;\n+    private final Scheduler scheduler;\n+\n+    // below state should only be accessed from eventloop\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if graceful close has not started.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_START} if graceful close process has been initiated.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent to measure RTT.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT} if we have sent the second go away frame.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object gracefulCloseState;\n+\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if keep-alive PING process is not started.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_PENDING} if a keep-alive PING has been sent but ack is not received.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_TIMEDOUT} if we fail to receive a PING ack for the configured timeout.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object keepAliveState;\n+    @Nullable\n+    private final GenericFutureListener<Future<? super Void>> pingWriteCompletionListener;\n+\n+    KeepAliveManager(final Channel channel, @Nullable final KeepAlivePolicy keepAlivePolicy) {\n+        this(channel, keepAlivePolicy, (task, delayInMillis) ->\n+                channel.eventLoop().schedule(task, delayInMillis, MILLISECONDS),\n+                (ch, idlenessThresholdSeconds, onIdle) -> ch.pipeline().addLast(\n+                        new IdleStateHandler(idlenessThresholdSeconds, idlenessThresholdSeconds, 0) {\n+                            @Override\n+                            protected void channelIdle(final ChannelHandlerContext ctx, final IdleStateEvent evt) {\n+                                onIdle.run();\n+                            }\n+                        }));\n+    }\n+\n+    KeepAliveManager(final Channel channel, @Nullable final KeepAlivePolicy keepAlivePolicy,\n+                     final Scheduler scheduler, final IdlenessDetector idlenessDetector) {\n+        this.channel = channel;\n+        this.scheduler = scheduler;\n+        if (keepAlivePolicy != null) {\n+            disallowKeepAliveWithoutActiveStreams = !keepAlivePolicy.withoutActiveStreams();\n+            pingAckTimeoutMillis = keepAlivePolicy.ackTimeout().toMillis();\n+            final GenericFutureListener<Future<? super Void>> goAwayListener = f -> {\n+                if (f.isSuccess()) {\n+                    LOGGER.debug(\"Closing channel={}, after keep-alive timeout.\", this.channel);\n+                    KeepAliveManager.this.close0();\n+                }\n+            };\n+            pingWriteCompletionListener = future -> {\n+                if (future.isSuccess() && keepAliveState == KEEP_ALIVE_ACK_PENDING) {\n+                    // Schedule a task to verify ping ack within the pingAckTimeoutMillis\n+                    keepAliveState = scheduler.afterMillis(() -> {\n+                        if (keepAliveState != null) {\n+                            keepAliveState = KEEP_ALIVE_ACK_TIMEDOUT;\n+                            LOGGER.debug(\n+                                    \"channel={}, timeout {}ms waiting for keep-alive PING(ACK), writing go_away.\",\n+                                    this.channel, pingAckTimeoutMillis);\n+                            channel.writeAndFlush(new DefaultHttp2GoAwayFrame(NO_ERROR))\n+                                    .addListener(goAwayListener);\n+                        }\n+                    }, pingAckTimeoutMillis);\n+                }\n+            };\n+            int idleInSeconds = (int) keepAlivePolicy.idleDuration().getSeconds();", "originalCommit": "7de08e1e8f8615b4b427af6e92a10506945321a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE0MTQzNQ==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r414141435", "bodyText": "Good point, lemme put an upper bound that resembles infinity for the time here.", "author": "NiteshKant", "createdAt": "2020-04-23T21:37:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk2MDg3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk2OTE0OA==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413969148", "bodyText": "This utility class is in the http namespace but is specific to h2 functionality.\nWe should consider the following options:\n\nmove KeepAlivePolicy outside the scope of h2 specific scope (e.g. H2ProtocolConfig) and make it less h2 specific. I don't think the API would have to change in a material way (e.g. methods all can stay, comments may need to be adjusted). If/when we were to use it in h1 we would need some additional input from the user on sending the \"ping\" request, but I think that can be done independently of the KeepAlivePolicy API.\nOR\nclarify that this is h2 specific (e.g. add H2 in the name).", "author": "Scottmitch", "createdAt": "2020-04-23T17:03:10Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/KeepAlivePolicies.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.http.netty.H2ProtocolConfig.KeepAlivePolicy;\n+\n+import java.time.Duration;\n+\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_ACK_TIMEOUT;\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_IDLE_DURATION;\n+import static java.time.Duration.ofDays;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A factory to create {@link KeepAlivePolicy} instances.\n+ */\n+public final class KeepAlivePolicies {", "originalCommit": "7de08e1e8f8615b4b427af6e92a10506945321a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1NjA4NQ==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r414156085", "bodyText": "Good point, lemme add the H2 prefix as this is creating a H2ProtocolConfig.KeepAlivePolicy", "author": "NiteshKant", "createdAt": "2020-04-23T22:07:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk2OTE0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk3MTU3Ng==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r413971576", "bodyText": "do we need both static factories and a builder?", "author": "Scottmitch", "createdAt": "2020-04-23T17:06:34Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/KeepAlivePolicies.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.http.netty.H2ProtocolConfig.KeepAlivePolicy;\n+\n+import java.time.Duration;\n+\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_ACK_TIMEOUT;\n+import static io.servicetalk.http.netty.DefaultKeepAlivePolicy.DEFAULT_IDLE_DURATION;\n+import static java.time.Duration.ofDays;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A factory to create {@link KeepAlivePolicy} instances.\n+ */\n+public final class KeepAlivePolicies {\n+    static final KeepAlivePolicy DISABLE_KEEP_ALIVE =\n+            new DefaultKeepAlivePolicy(ofDays(365), ofDays(365), false);\n+\n+    private KeepAlivePolicies() {\n+        // no instances.\n+    }\n+\n+    /**\n+     * Returns a {@link KeepAlivePolicy} that disables all keep alive behaviors.\n+     *\n+     * @return A {@link KeepAlivePolicy} that disables all keep alive behaviors.\n+     */\n+    public static KeepAlivePolicy disabled() {\n+        return DISABLE_KEEP_ALIVE;\n+    }\n+\n+    /**\n+     * Returns a {@link KeepAlivePolicy} that sends a <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">\n+     * ping</a> if the channel is idle for the passed {@code idleDuration}. Default values are used for other parameters\n+     * of the returned {@link KeepAlivePolicy}.\n+     *\n+     * @param idleDuration {@link Duration} of idleness on a connection after which a\n+     * <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a> is sent.\n+     * @return A {@link KeepAlivePolicy} that disables all keep alive behaviors.\n+     */\n+    public static KeepAlivePolicy whenIdleFor(final Duration idleDuration) {\n+        return new KeepAlivePolicyBuilder().idleDuration(idleDuration).build();\n+    }\n+\n+    /**\n+     * Returns a {@link KeepAlivePolicy} that sends a <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">\n+     * ping</a> if the channel is idle for the passed {@code idleDuration} and waits for {@code ackTimeout} for an ack\n+     * for that <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a>. Default values are used for other\n+     * parameters of the returned {@link KeepAlivePolicy}.\n+     *\n+     * @param idleDuration {@link Duration} of idleness on a connection after which a\n+     * <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a> is sent.\n+     * @param ackTimeout {@link Duration} to wait for an acknowledgment of a previously sent\n+     * <a href=\"https://tools.ietf.org/html/rfc7540#section-6.7\">ping</a>.\n+     * @return A {@link KeepAlivePolicy} that disables all keep alive behaviors.\n+     */\n+    public static KeepAlivePolicy whenIdleFor(final Duration idleDuration, final Duration ackTimeout) {\n+        return new KeepAlivePolicyBuilder().idleDuration(idleDuration).ackTimeout(ackTimeout).build();\n+    }\n+\n+    /**\n+     * A builder of {@link KeepAlivePolicy}.\n+     */\n+    public static final class KeepAlivePolicyBuilder {", "originalCommit": "7de08e1e8f8615b4b427af6e92a10506945321a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1ODk5Ng==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r414158996", "bodyText": "We don't need it but the static methods are convenient to express common cases, eg: disabled(), whenIdleFor() as opposed to new KeepAlivePolicyBuilder().idleDuration().ackTimeout().build()", "author": "NiteshKant", "createdAt": "2020-04-23T22:13:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk3MTU3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE2OTY3MQ==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r414169671", "bodyText": "fair enough. \ud83d\udea2", "author": "Scottmitch", "createdAt": "2020-04-23T22:37:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk3MTU3Ng=="}], "type": "inlineReview"}, {"oid": "e398ed81bf8ece9724378a4899bf76b4f60ba4e9", "url": "https://github.com/apple/servicetalk/commit/e398ed81bf8ece9724378a4899bf76b4f60ba4e9", "message": "Review comments", "committedDate": "2020-04-23T22:31:23Z", "type": "commit"}, {"oid": "0348c705c7ec7d5af79c283e27dd5e4345c8743f", "url": "https://github.com/apple/servicetalk/commit/0348c705c7ec7d5af79c283e27dd5e4345c8743f", "message": "Some moar fixes", "committedDate": "2020-04-23T22:54:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE5MTc2Mw==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r414191763", "bodyText": "KeepAlivePolicyBuilder applies a limit when setting the Idle duration, although I think it is safer to avoid overflow here and then we don't have to worry about applying a limit upfront or missing applying the limit if someone implement their own KeepAlivePolicy etc..", "author": "Scottmitch", "createdAt": "2020-04-23T23:32:32Z", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/KeepAliveManager.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.http.netty.H2ProtocolConfig.KeepAlivePolicy;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.EventLoop;\n+import io.netty.handler.codec.http2.DefaultHttp2GoAwayFrame;\n+import io.netty.handler.codec.http2.DefaultHttp2PingFrame;\n+import io.netty.handler.codec.http2.Http2PingFrame;\n+import io.netty.handler.timeout.IdleStateEvent;\n+import io.netty.handler.timeout.IdleStateHandler;\n+import io.netty.util.concurrent.Future;\n+import io.netty.util.concurrent.GenericFutureListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.handler.codec.http2.Http2Error.NO_ERROR;\n+import static io.servicetalk.http.netty.H2KeepAlivePolicies.DEFAULT_ACK_TIMEOUT;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+/**\n+ * An implementation of {@link KeepAlivePolicy} per {@link Channel}.\n+ */\n+final class KeepAliveManager {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KeepAliveManager.class);\n+    private static final AtomicIntegerFieldUpdater<KeepAliveManager> activeChildChannelsUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(KeepAliveManager.class, \"activeChildChannels\");\n+    private static final long GRACEFUL_CLOSE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final long KEEP_ALIVE_PING_CONTENT = ThreadLocalRandom.current().nextLong();\n+    private static final Object CLOSED = new Object();\n+    private static final Object GRACEFUL_CLOSE_START = new Object();\n+    private static final Object GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT = new Object();\n+    private static final Object KEEP_ALIVE_ACK_PENDING = new Object();\n+    private static final Object KEEP_ALIVE_ACK_TIMEDOUT = new Object();\n+\n+    private volatile int activeChildChannels;\n+\n+    private final Channel channel;\n+    private final long pingAckTimeoutNanos;\n+    private final boolean disallowKeepAliveWithoutActiveStreams;\n+    private final Scheduler scheduler;\n+\n+    // below state should only be accessed from eventloop\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if graceful close has not started.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_START} if graceful close process has been initiated.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent to measure RTT.</li>\n+     *     <li>{@link #GRACEFUL_CLOSE_SECOND_GO_AWAY_SENT} if we have sent the second go away frame.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object gracefulCloseState;\n+\n+    /**\n+     * This stores the following possible values:\n+     * <ul>\n+     *     <li>{@code null} if keep-alive PING process is not started.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_PENDING} if a keep-alive PING has been sent but ack is not received.</li>\n+     *     <li>{@link Future} instance to timeout ack of PING sent.</li>\n+     *     <li>{@link #KEEP_ALIVE_ACK_TIMEDOUT} if we fail to receive a PING ack for the configured timeout.</li>\n+     *     <li>{@link #CLOSED} if the channel is closed.</li>\n+     * </ul>\n+     */\n+    @Nullable\n+    private Object keepAliveState;\n+    @Nullable\n+    private final GenericFutureListener<Future<? super Void>> pingWriteCompletionListener;\n+\n+    KeepAliveManager(final Channel channel, @Nullable final KeepAlivePolicy keepAlivePolicy) {\n+        this(channel, keepAlivePolicy, (task, delay, unit) ->\n+                channel.eventLoop().schedule(task, delay, unit),\n+                (ch, idlenessThresholdSeconds, onIdle) -> ch.pipeline().addLast(\n+                        new IdleStateHandler(idlenessThresholdSeconds, idlenessThresholdSeconds, 0) {\n+                            @Override\n+                            protected void channelIdle(final ChannelHandlerContext ctx, final IdleStateEvent evt) {\n+                                onIdle.run();\n+                            }\n+                        }));\n+    }\n+\n+    KeepAliveManager(final Channel channel, @Nullable final KeepAlivePolicy keepAlivePolicy,\n+                     final Scheduler scheduler, final IdlenessDetector idlenessDetector) {\n+        this.channel = channel;\n+        this.scheduler = scheduler;\n+        if (keepAlivePolicy != null) {\n+            disallowKeepAliveWithoutActiveStreams = !keepAlivePolicy.withoutActiveStreams();\n+            pingAckTimeoutNanos = keepAlivePolicy.ackTimeout().toNanos();\n+            pingWriteCompletionListener = future -> {\n+                if (future.isSuccess() && keepAliveState == KEEP_ALIVE_ACK_PENDING) {\n+                    // Schedule a task to verify ping ack within the pingAckTimeoutMillis\n+                    keepAliveState = scheduler.afterDuration(() -> {\n+                        if (keepAliveState != null) {\n+                            keepAliveState = KEEP_ALIVE_ACK_TIMEDOUT;\n+                            LOGGER.debug(\n+                                    \"channel={}, timeout {}ns waiting for keep-alive PING(ACK), writing go_away.\",\n+                                    this.channel, pingAckTimeoutNanos);\n+                            channel.writeAndFlush(new DefaultHttp2GoAwayFrame(NO_ERROR))\n+                                    .addListener(f -> {\n+                                        if (f.isSuccess()) {\n+                                            LOGGER.debug(\"Closing channel={}, after keep-alive timeout.\", this.channel);\n+                                            KeepAliveManager.this.close0();\n+                                        }\n+                                    });\n+                        }\n+                    }, pingAckTimeoutNanos, NANOSECONDS);\n+                }\n+            };\n+            int idleInSeconds = (int) keepAlivePolicy.idleDuration().getSeconds();", "originalCommit": "0348c705c7ec7d5af79c283e27dd5e4345c8743f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE5MjkxMA==", "url": "https://github.com/apple/servicetalk/pull/1029#discussion_r414192910", "bodyText": "use SubscriberUtils#deliverTerminalFromSource instead?", "author": "Scottmitch", "createdAt": "2020-04-23T23:35:31Z", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/NettyChannelListenableAsyncCloseable.java", "diffHunk": "@@ -82,7 +82,13 @@ public final Completable closeAsyncGracefully() {\n             @Override\n             protected void handleSubscribe(final Subscriber subscriber) {\n                 if (stateUpdater.compareAndSet(NettyChannelListenableAsyncCloseable.this, OPEN, GRACEFULLY_CLOSING)) {\n-                    doCloseAsyncGracefully();\n+                    try {\n+                        doCloseAsyncGracefully();\n+                    } catch (Throwable t) {\n+                        subscriber.onSubscribe(IGNORE_CANCEL);", "originalCommit": "0348c705c7ec7d5af79c283e27dd5e4345c8743f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0b42191c4f33ab5a9895d3eea0adbadd2a54372d", "url": "https://github.com/apple/servicetalk/commit/0b42191c4f33ab5a9895d3eea0adbadd2a54372d", "message": "Review comments", "committedDate": "2020-04-24T16:27:03Z", "type": "commit"}]}