{"pr_number": 1291, "pr_title": "Completable#merge concurrency fix, new Completable#merge single arg o\u2026", "pr_createdAt": "2020-12-18T12:49:27Z", "pr_url": "https://github.com/apple/servicetalk/pull/1291", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3NDQxNg==", "url": "https://github.com/apple/servicetalk/pull/1291#discussion_r546174416", "bodyText": "I thought about cases like this. Currently, we allow Completable.completed().merge() which doesn't make any sense. I think we should change all API that use varargs but require at least one element to merge(Completable first, Completable... others).  Then merge(Completable) will be not necessary or may be used to avoid extra allocation because merging with one is the most common case.", "author": "idelpivnitskiy", "createdAt": "2020-12-19T01:57:35Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Completable.java", "diffHunk": "@@ -437,7 +461,7 @@ public final Completable concat(Completable next) {\n      * complete or terminates with an error when any one terminates with an error.\n      */\n     public final Completable merge(Completable... other) {", "originalCommit": "315029c1f6020692be9558025fadb10394f5b211", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE5MTcxOQ==", "url": "https://github.com/apple/servicetalk/pull/1291#discussion_r546191719", "bodyText": "I think it makes sense for merge(Completable) to exist either way as you said to avoid allocations when not necessary.", "author": "Scottmitch", "createdAt": "2020-12-19T04:53:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3NDQxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3NTc3Ng==", "url": "https://github.com/apple/servicetalk/pull/1291#discussion_r546175776", "bodyText": "If other is empty we can return this here and in mergeDelayError.", "author": "idelpivnitskiy", "createdAt": "2020-12-19T02:09:08Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Completable.java", "diffHunk": "@@ -437,7 +461,7 @@ public final Completable concat(Completable next) {\n      * complete or terminates with an error when any one terminates with an error.\n      */\n     public final Completable merge(Completable... other) {\n-        return new MergeCompletable(false, this, executor, other);\n+        return MergeCompletable.newInstance(false, this, executor, other);", "originalCommit": "315029c1f6020692be9558025fadb10394f5b211", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3NjU1NA==", "url": "https://github.com/apple/servicetalk/pull/1291#discussion_r546176554", "bodyText": "Consider reverting this check until we fix API as described above.", "author": "idelpivnitskiy", "createdAt": "2020-12-19T02:16:15Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/MergeCompletable.java", "diffHunk": "@@ -15,77 +15,54 @@\n  */\n package io.servicetalk.concurrent.api;\n \n-import javax.annotation.Nullable;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n \n import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n \n-/**\n- * A {@link Completable} implementation for merging {@link Completable}s.\n- */\n final class MergeCompletable extends AbstractMergeCompletableOperator {\n-\n-    @Nullable\n     private final Completable[] others;\n-    @Nullable\n-    private final Completable onlyOther;\n     private final boolean delayError;\n \n-    /**\n-     * New instance.\n-     * @param delayError {@code true} to wait until all {@code others} complete before propagating an error.\n-     *                   {@code false} to fail fast and propagate an error on the first\n-     *                   {@link Subscriber#onError(Throwable)} observed.\n-     * @param original {@link Completable} to merge with {@code others}.\n-     * @param others {@link Completable}s to merge with {@code original}.\n-     */\n-    MergeCompletable(boolean delayError, Completable original, Executor executor, Completable... others) {\n+    private MergeCompletable(boolean delayError, Completable original, Executor executor, Completable... others) {\n         super(original, executor);\n         this.delayError = delayError;\n-        switch (others.length) {\n-            case 0:\n-                throw new IllegalArgumentException(\"At least one Completable required to merge\");", "originalCommit": "315029c1f6020692be9558025fadb10394f5b211", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE5MjE0MA==", "url": "https://github.com/apple/servicetalk/pull/1291#discussion_r546192140", "bodyText": "I don't think we need to prevent the empty use case you described. There is nothing incorrect about passing an empty array or empty iterator, and I think we would want consistency between the two. If folks are passing empty collections they will just incur some overhead. If we have an API which prevents it that is fine, but until then lets just allow it consistently.", "author": "Scottmitch", "createdAt": "2020-12-19T04:57:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3NjU1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3NzA0Mw==", "url": "https://github.com/apple/servicetalk/pull/1291#discussion_r546177043", "bodyText": "It's actually not a counter of remaining items, it's a counter of terminated items. Consider renaming to something like terminatedCount or doneCount.\nAlternatively, you can initialize remainingCount = expectedCount and decrement until 0. This way we will save a few bytes in this object by removing expectedCount.", "author": "idelpivnitskiy", "createdAt": "2020-12-19T02:20:44Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/MergeCompletable.java", "diffHunk": "@@ -15,77 +15,54 @@\n  */\n package io.servicetalk.concurrent.api;\n \n-import javax.annotation.Nullable;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n \n import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n \n-/**\n- * A {@link Completable} implementation for merging {@link Completable}s.\n- */\n final class MergeCompletable extends AbstractMergeCompletableOperator {\n-\n-    @Nullable\n     private final Completable[] others;\n-    @Nullable\n-    private final Completable onlyOther;\n     private final boolean delayError;\n \n-    /**\n-     * New instance.\n-     * @param delayError {@code true} to wait until all {@code others} complete before propagating an error.\n-     *                   {@code false} to fail fast and propagate an error on the first\n-     *                   {@link Subscriber#onError(Throwable)} observed.\n-     * @param original {@link Completable} to merge with {@code others}.\n-     * @param others {@link Completable}s to merge with {@code original}.\n-     */\n-    MergeCompletable(boolean delayError, Completable original, Executor executor, Completable... others) {\n+    private MergeCompletable(boolean delayError, Completable original, Executor executor, Completable... others) {\n         super(original, executor);\n         this.delayError = delayError;\n-        switch (others.length) {\n-            case 0:\n-                throw new IllegalArgumentException(\"At least one Completable required to merge\");\n-            case 1:\n-                onlyOther = requireNonNull(others[0]);\n-                this.others = null;\n-                break;\n-            default:\n-                this.others = others;\n-                onlyOther = null;\n-        }\n+        this.others = requireNonNull(others);\n+    }\n+\n+    static AbstractMergeCompletableOperator newInstance(boolean delayError, Completable original, Executor executor,\n+                                                        Completable... others) {\n+        return others.length == 1 ?\n+                new MergeOneCompletable(delayError, original, executor, others[0]) :\n+                new MergeCompletable(delayError, original, executor, others);\n     }\n \n     @Override\n     public MergeSubscriber apply(final Subscriber subscriber) {\n-        assert onlyOther != null || others != null;\n-        return new FixedCountMergeSubscriber(subscriber, 1 + (onlyOther == null ? others.length : 1),\n-                delayError);\n+        return new FixedCountMergeSubscriber(subscriber, 1 + others.length, delayError);\n     }\n \n     @Override\n     void doMerge(final MergeSubscriber subscriber) {\n-        if (onlyOther == null) {\n-            assert others != null;\n-            for (Completable itr : others) {\n-                itr.subscribeInternal(subscriber);\n-            }\n-        } else {\n-            onlyOther.subscribeInternal(subscriber);\n+        for (Completable itr : others) {\n+            itr.subscribeInternal(subscriber);\n         }\n     }\n \n     static final class FixedCountMergeSubscriber extends MergeSubscriber {\n-        FixedCountMergeSubscriber(Subscriber subscriber, int completedCount, boolean delayError) {\n-            super(subscriber, completedCount, delayError);\n-        }\n+        private static final AtomicIntegerFieldUpdater<FixedCountMergeSubscriber> remainingCountUpdater =\n+                newUpdater(FixedCountMergeSubscriber.class, \"remainingCount\");\n+        private final int expectedCount;\n+        private volatile int remainingCount;\n \n-        @Override\n-        boolean onTerminate() {\n-            return completedCountUpdater.decrementAndGet(this) == 0;\n+        FixedCountMergeSubscriber(Subscriber subscriber, int expectedCount, boolean delayError) {\n+            super(subscriber, delayError);\n+            this.expectedCount = expectedCount;\n         }\n \n         @Override\n-        boolean isDone() {\n-            return completedCount == 0;\n+        boolean onTerminate() {\n+            return remainingCountUpdater.incrementAndGet(this) == expectedCount;", "originalCommit": "315029c1f6020692be9558025fadb10394f5b211", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3ODMyMA==", "url": "https://github.com/apple/servicetalk/pull/1291#discussion_r546178320", "bodyText": "Why not to keep pre-existing check for Collection?", "author": "idelpivnitskiy", "createdAt": "2020-12-19T02:32:25Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/IterableMergeCompletable.java", "diffHunk": "@@ -37,49 +35,37 @@\n \n     @Override\n     public MergeSubscriber apply(final Subscriber subscriber) {\n-        if (others instanceof Collection) {\n-            return new FixedCountMergeSubscriber(subscriber, 1 + ((Collection) others).size(), delayError);\n-        } else {\n-            return new DynamicCountSubscriber(subscriber, delayError);\n-        }\n+        return new DynamicCountSubscriber(subscriber, delayError);", "originalCommit": "315029c1f6020692be9558025fadb10394f5b211", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE5MjMzMg==", "url": "https://github.com/apple/servicetalk/pull/1291#discussion_r546192332", "bodyText": "there is no longer a meaningful different between the two implementations, and some collections size() is costly and requires iteration.", "author": "Scottmitch", "createdAt": "2020-12-19T04:59:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3ODMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE5NzEzNQ==", "url": "https://github.com/apple/servicetalk/pull/1291#discussion_r546197135", "bodyText": "Agreed, difference is negligible. Saying that, do we need 2 impls or can we always use dynamic one?", "author": "idelpivnitskiy", "createdAt": "2020-12-19T05:56:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3ODMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE5NzIxOQ==", "url": "https://github.com/apple/servicetalk/pull/1291#discussion_r546197219", "bodyText": "Sorry for back and forth. Existing code lgtm as well.", "author": "idelpivnitskiy", "createdAt": "2020-12-19T05:57:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3ODMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTk3NzY2Mw==", "url": "https://github.com/apple/servicetalk/pull/1291#discussion_r555977663", "bodyText": "np. thanks for review!", "author": "Scottmitch", "createdAt": "2021-01-12T18:15:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3ODMyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3ODQ1OQ==", "url": "https://github.com/apple/servicetalk/pull/1291#discussion_r546178459", "bodyText": "If you prefer to keep only DynamicCountSubscriber, consider adding a generic type for AbstractMergeCompletableOperator to avoid cast here.", "author": "idelpivnitskiy", "createdAt": "2020-12-19T02:33:46Z", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/IterableMergeCompletable.java", "diffHunk": "@@ -37,49 +35,37 @@\n \n     @Override\n     public MergeSubscriber apply(final Subscriber subscriber) {\n-        if (others instanceof Collection) {\n-            return new FixedCountMergeSubscriber(subscriber, 1 + ((Collection) others).size(), delayError);\n-        } else {\n-            return new DynamicCountSubscriber(subscriber, delayError);\n-        }\n+        return new DynamicCountSubscriber(subscriber, delayError);\n     }\n \n     @Override\n     void doMerge(final MergeSubscriber subscriber) {\n-        if (subscriber instanceof DynamicCountSubscriber) {\n-            int count = 1;\n-            for (Completable itr : others) {\n-                ++count;\n-                itr.subscribeInternal(subscriber);\n-            }\n-            ((DynamicCountSubscriber) subscriber).setExpectedCount(count);\n-        } else {\n-            for (Completable itr : others) {\n-                itr.subscribeInternal(subscriber);\n-            }\n+        long count = 1;\n+        for (Completable itr : others) {\n+            ++count;\n+            itr.subscribeInternal(subscriber);\n         }\n+        ((DynamicCountSubscriber) subscriber).setExpectedCount(count);", "originalCommit": "315029c1f6020692be9558025fadb10394f5b211", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE5Mjk4OA==", "url": "https://github.com/apple/servicetalk/pull/1291#discussion_r546192988", "bodyText": "I experimented with this but you can't have a generic sub-type with an inner class. I'll move the inner classes so I can avoid the cast.", "author": "Scottmitch", "createdAt": "2020-12-19T05:06:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3ODQ1OQ=="}], "type": "inlineReview"}, {"oid": "46da2f4f848438da9b6032a60c8d469d16c25932", "url": "https://github.com/apple/servicetalk/commit/46da2f4f848438da9b6032a60c8d469d16c25932", "message": "Completable#merge concurrency fix, new Completable#merge single arg override\n\nMotivation:\nCompletable#merge(Iterable) must iterate before it knows how many\nCompletables to wait for. The implementation uses two independent\nvolatile variables for the expected value and current count, which may\nresult in visibility issues.\n\nModifications:\n- Completable#merge(Iterable) should use the same volatile variable to\nmanage the count, and avoid data races/visibility issues.\n- Add Compleable#merge(Completable) and\nCompletable#mergeDelayError(Completable) overrides to avoid array\nallocation.\n- Clean up Compleable#merge implementations to remove unused methods,\nand create the optimized implementation depending upon array\ncardinality.\n\nResult:\nLess data races in Completable#merge(Iterable) and operator overload for\nsingle Completable merge operations.", "committedDate": "2020-12-19T05:10:04Z", "type": "commit"}, {"oid": "d20cc86061aea631f6b825ba11b2933661bb070a", "url": "https://github.com/apple/servicetalk/commit/d20cc86061aea631f6b825ba11b2933661bb070a", "message": "use final variable to simplify concurrency, rely less on RS correctness", "committedDate": "2020-12-19T05:10:06Z", "type": "commit"}, {"oid": "d535d428ca9d555816da2a8a03160194b5de1a84", "url": "https://github.com/apple/servicetalk/commit/d535d428ca9d555816da2a8a03160194b5de1a84", "message": "review comments", "committedDate": "2020-12-19T05:12:46Z", "type": "commit"}, {"oid": "d535d428ca9d555816da2a8a03160194b5de1a84", "url": "https://github.com/apple/servicetalk/commit/d535d428ca9d555816da2a8a03160194b5de1a84", "message": "review comments", "committedDate": "2020-12-19T05:12:46Z", "type": "forcePushed"}]}