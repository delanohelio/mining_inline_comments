{"pr_number": 1052, "pr_title": "RoundRobinLoadBalancer to allow duplicate addresses", "pr_createdAt": "2020-05-13T23:46:49Z", "pr_url": "https://github.com/apple/servicetalk/pull/1052", "timeline": [{"oid": "0060468acd5bf55e8f65e268b102d564d5b513c9", "url": "https://github.com/apple/servicetalk/commit/0060468acd5bf55e8f65e268b102d564d5b513c9", "message": "RoundRobinLoadBalancer to allow duplicate addresses\n\nMotivation:\nRoundRobinLoadBalancer currently prevents duplicates from being\ninserted. However the ServiceDiscoverer is responsible for filtering\nduplicates in the typical use case. Allowing duplicates at the LB layer\nallows to give more weight to specific addresses if desired.\n\nModifications:\n- RoundRobinLoadBalancer simplify addition/removal to forgo duplicate\ndetection\n\nResult:\nRoundRobinLoadBalancer code simplified to ignore duplicate detection,\naddition doesn't require linear search.", "committedDate": "2020-05-13T23:34:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc5NDU0MA==", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r424794540", "bodyText": "Consider using emptyList() to allow currentAddresses to be GCed.", "author": "idelpivnitskiy", "createdAt": "2020-05-13T23:50:52Z", "path": "servicetalk-loadbalancer/src/main/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancer.java", "diffHunk": "@@ -150,29 +150,26 @@ public void onNext(final ServiceDiscovererEvent<ResolvedAddress> event) {\n                         event);\n                 final List<Host<ResolvedAddress, C>> activeAddresses =\n                         activeHostsUpdater.updateAndGet(RoundRobinLoadBalancer.this, currentAddresses -> {\n-                            final List<Host<ResolvedAddress, C>> refreshedAddresses =\n-                                    new ArrayList<Host<ResolvedAddress, C>>(currentAddresses);\n                             final ResolvedAddress addr = requireNonNull(event.address());\n-                            for (int i = 0; i < refreshedAddresses.size(); i++) {\n-                                Host<ResolvedAddress, C> host = refreshedAddresses.get(i);\n-                                if (host.address.equals(addr)) {\n-                                    if (event.isAvailable()) {\n-                                        LOGGER.debug(\"Address {} added but it already exists.\", addr);\n-                                        return currentAddresses;\n-                                    } else {\n-                                        refreshedAddresses.remove(i);\n-                                        host.markInactive();\n-                                        return refreshedAddresses;\n-                                    }\n-                                }\n-                            }\n+                            final List<Host<ResolvedAddress, C>> refreshedAddresses;\n                             if (event.isAvailable()) {\n+                                refreshedAddresses = new ArrayList<>(currentAddresses.size() + 1);\n+                                refreshedAddresses.addAll(currentAddresses);\n                                 refreshedAddresses.add(new Host<>(addr));\n-                                return refreshedAddresses;\n+                            } else if (currentAddresses.isEmpty()) {\n+                                refreshedAddresses = currentAddresses;", "originalCommit": "0060468acd5bf55e8f65e268b102d564d5b513c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc5NTEwMg==", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r424795102", "bodyText": "ArrayList.addAll(anotherArrayList) implementation does copying two times internally:\n\nto convert anotherArrayList to array\nto copy that new array into its elementData\n\nAmount of allocated memory and copied elements remains the same.\nAlso, I won't expect this to be a perf issue, as usually new addresses does not appear frequently.", "author": "idelpivnitskiy", "createdAt": "2020-05-13T23:52:42Z", "path": "servicetalk-loadbalancer/src/main/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancer.java", "diffHunk": "@@ -150,29 +150,26 @@ public void onNext(final ServiceDiscovererEvent<ResolvedAddress> event) {\n                         event);\n                 final List<Host<ResolvedAddress, C>> activeAddresses =\n                         activeHostsUpdater.updateAndGet(RoundRobinLoadBalancer.this, currentAddresses -> {\n-                            final List<Host<ResolvedAddress, C>> refreshedAddresses =\n-                                    new ArrayList<Host<ResolvedAddress, C>>(currentAddresses);\n                             final ResolvedAddress addr = requireNonNull(event.address());\n-                            for (int i = 0; i < refreshedAddresses.size(); i++) {\n-                                Host<ResolvedAddress, C> host = refreshedAddresses.get(i);\n-                                if (host.address.equals(addr)) {\n-                                    if (event.isAvailable()) {\n-                                        LOGGER.debug(\"Address {} added but it already exists.\", addr);\n-                                        return currentAddresses;\n-                                    } else {\n-                                        refreshedAddresses.remove(i);\n-                                        host.markInactive();\n-                                        return refreshedAddresses;\n-                                    }\n-                                }\n-                            }\n+                            final List<Host<ResolvedAddress, C>> refreshedAddresses;\n                             if (event.isAvailable()) {\n+                                refreshedAddresses = new ArrayList<>(currentAddresses.size() + 1);\n+                                refreshedAddresses.addAll(currentAddresses);", "originalCommit": "0060468acd5bf55e8f65e268b102d564d5b513c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg0MDY0NA==", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r424840644", "bodyText": "Good observation that addAll does a toArray(). However this is an implementation detail of addAll which isn't strictly required. This approach avoids iteration for duplicate detection and an upfront copy and additional copy/shift for removal (at the expense of iterative additions instead of bulk copy operations). I'll add benchmarks for more insight: #1052 (comment)", "author": "Scottmitch", "createdAt": "2020-05-14T02:47:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc5NTEwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc5NTcyMw==", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r424795723", "bodyText": "As we discussed in #1051 (comment), SD may emit duplicated events and it should be expected.", "author": "idelpivnitskiy", "createdAt": "2020-05-13T23:54:49Z", "path": "servicetalk-loadbalancer/src/main/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancer.java", "diffHunk": "@@ -150,29 +150,26 @@ public void onNext(final ServiceDiscovererEvent<ResolvedAddress> event) {\n                         event);\n                 final List<Host<ResolvedAddress, C>> activeAddresses =\n                         activeHostsUpdater.updateAndGet(RoundRobinLoadBalancer.this, currentAddresses -> {\n-                            final List<Host<ResolvedAddress, C>> refreshedAddresses =\n-                                    new ArrayList<Host<ResolvedAddress, C>>(currentAddresses);\n                             final ResolvedAddress addr = requireNonNull(event.address());\n-                            for (int i = 0; i < refreshedAddresses.size(); i++) {\n-                                Host<ResolvedAddress, C> host = refreshedAddresses.get(i);\n-                                if (host.address.equals(addr)) {\n-                                    if (event.isAvailable()) {\n-                                        LOGGER.debug(\"Address {} added but it already exists.\", addr);\n-                                        return currentAddresses;\n-                                    } else {\n-                                        refreshedAddresses.remove(i);\n-                                        host.markInactive();\n-                                        return refreshedAddresses;\n-                                    }\n-                                }\n-                            }\n+                            final List<Host<ResolvedAddress, C>> refreshedAddresses;\n                             if (event.isAvailable()) {", "originalCommit": "0060468acd5bf55e8f65e268b102d564d5b513c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg0MzQwMQ==", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r424843401", "bodyText": "thx for pointing this out. I don't think we need todo duplicate detection in the LoadBalancer. the previous binarySearch approach was done for faster lookup and duplicate detection was a side effect.", "author": "Scottmitch", "createdAt": "2020-05-14T02:58:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc5NTcyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg1OTY5Mw==", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r424859693", "bodyText": "sgtm!", "author": "idelpivnitskiy", "createdAt": "2020-05-14T04:09:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc5NTcyMw=="}], "type": "inlineReview"}, {"oid": "931875bc904c645e45c912bd7ba7874b60f9855c", "url": "https://github.com/apple/servicetalk/commit/931875bc904c645e45c912bd7ba7874b60f9855c", "message": "review comments, benchmark", "committedDate": "2020-05-14T02:49:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg0MzM5NA==", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r424843394", "bodyText": "This test is still relevant, the assert can be changed.", "author": "NiteshKant", "createdAt": "2020-05-14T02:58:49Z", "path": "servicetalk-loadbalancer/src/test/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancerTest.java", "diffHunk": "@@ -242,15 +242,6 @@ public void unknownAddressIsRemoved() {\n         assertThat(lb.activeAddresses(), is(empty()));\n     }\n \n-    @Test\n-    public void addressIsAddedTwice() {", "originalCommit": "931875bc904c645e45c912bd7ba7874b60f9855c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg0NTE4Mw==", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r424845183", "bodyText": "sounds good", "author": "Scottmitch", "createdAt": "2020-05-14T03:06:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg0MzM5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg0NDAzOQ==", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r424844039", "bodyText": "An equivalent log may still be useful to detect descrepancies of events from SD or an issue with our matching.", "author": "NiteshKant", "createdAt": "2020-05-14T03:01:29Z", "path": "servicetalk-loadbalancer/src/main/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancer.java", "diffHunk": "@@ -150,29 +150,26 @@ public void onNext(final ServiceDiscovererEvent<ResolvedAddress> event) {\n                         event);\n                 final List<Host<ResolvedAddress, C>> activeAddresses =\n                         activeHostsUpdater.updateAndGet(RoundRobinLoadBalancer.this, currentAddresses -> {\n-                            final List<Host<ResolvedAddress, C>> refreshedAddresses =\n-                                    new ArrayList<Host<ResolvedAddress, C>>(currentAddresses);\n                             final ResolvedAddress addr = requireNonNull(event.address());\n-                            for (int i = 0; i < refreshedAddresses.size(); i++) {\n-                                Host<ResolvedAddress, C> host = refreshedAddresses.get(i);\n-                                if (host.address.equals(addr)) {\n-                                    if (event.isAvailable()) {\n-                                        LOGGER.debug(\"Address {} added but it already exists.\", addr);\n-                                        return currentAddresses;\n-                                    } else {\n-                                        refreshedAddresses.remove(i);\n-                                        host.markInactive();\n-                                        return refreshedAddresses;\n-                                    }\n-                                }\n-                            }\n+                            final List<Host<ResolvedAddress, C>> refreshedAddresses;\n                             if (event.isAvailable()) {\n+                                refreshedAddresses = new ArrayList<>(currentAddresses.size() + 1);\n+                                refreshedAddresses.addAll(currentAddresses);\n                                 refreshedAddresses.add(new Host<>(addr));\n-                                return refreshedAddresses;\n+                            } else if (currentAddresses.isEmpty()) {\n+                                refreshedAddresses = emptyList();\n                             } else {\n-                                LOGGER.debug(\"Address {} removed but it does not exist.\", addr);", "originalCommit": "931875bc904c645e45c912bd7ba7874b60f9855c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg1MTIzOA==", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r424851238", "bodyText": "I would prefer to avoid modifying control flow just for debug logs if possible (e.g. add boolean check it after loop). there is a debug statement before this operation for the event and after to prints all addresses which should be sufficient to detect the no-change scenario. I understand not having this log is dropping a targeted log statement for this condition, but this was the state for a while so trying to understand more context (e.g. too difficult to detect in practice, etc..).", "author": "Scottmitch", "createdAt": "2020-05-14T03:32:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg0NDAzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA5MzQ0Mg==", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r425093442", "bodyText": "I changed the control flow so that we now only remove the first match ... so the control flow change would be lesser to add this log statement back. however we would need need to add another log statement if the oldHosts.isEmpty() to cover both cases ... still not sure the additional log(s) are necessary. wdyt?", "author": "Scottmitch", "createdAt": "2020-05-14T12:21:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg0NDAzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTMxMjI5NQ==", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r425312295", "bodyText": "I didn't see that we already have logs at start and end of this method, so adding this log makes less sense. Disregard my comment here.", "author": "NiteshKant", "createdAt": "2020-05-14T17:31:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg0NDAzOQ=="}], "type": "inlineReview"}, {"oid": "ebeca0d822082ce444d4a54b3f88f7cdfb834c1c", "url": "https://github.com/apple/servicetalk/commit/ebeca0d822082ce444d4a54b3f88f7cdfb834c1c", "message": "add back test", "committedDate": "2020-05-14T03:32:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg1OTA5Mw==", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r424859093", "bodyText": "currentAddresses.size() - 1 may give a zero as the result. Consider rewriting in this way:\nif (event.isAvailable()) {\n    ...\n} else if (currentAddresses.size() <= 1) {\n    refreshedAddresses = emptyList();\n} else {\n    refreshedAddresses = new ArrayList<>(currentAddresses.size() - 1);\n    ...\n}", "author": "idelpivnitskiy", "createdAt": "2020-05-14T04:06:57Z", "path": "servicetalk-loadbalancer/src/main/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancer.java", "diffHunk": "@@ -150,29 +150,26 @@ public void onNext(final ServiceDiscovererEvent<ResolvedAddress> event) {\n                         event);\n                 final List<Host<ResolvedAddress, C>> activeAddresses =\n                         activeHostsUpdater.updateAndGet(RoundRobinLoadBalancer.this, currentAddresses -> {\n-                            final List<Host<ResolvedAddress, C>> refreshedAddresses =\n-                                    new ArrayList<Host<ResolvedAddress, C>>(currentAddresses);\n                             final ResolvedAddress addr = requireNonNull(event.address());\n-                            for (int i = 0; i < refreshedAddresses.size(); i++) {\n-                                Host<ResolvedAddress, C> host = refreshedAddresses.get(i);\n-                                if (host.address.equals(addr)) {\n-                                    if (event.isAvailable()) {\n-                                        LOGGER.debug(\"Address {} added but it already exists.\", addr);\n-                                        return currentAddresses;\n-                                    } else {\n-                                        refreshedAddresses.remove(i);\n-                                        host.markInactive();\n-                                        return refreshedAddresses;\n-                                    }\n-                                }\n-                            }\n+                            final List<Host<ResolvedAddress, C>> refreshedAddresses;\n                             if (event.isAvailable()) {\n+                                refreshedAddresses = new ArrayList<>(currentAddresses.size() + 1);\n+                                refreshedAddresses.addAll(currentAddresses);\n                                 refreshedAddresses.add(new Host<>(addr));\n-                                return refreshedAddresses;\n+                            } else if (currentAddresses.isEmpty()) {\n+                                refreshedAddresses = emptyList();\n                             } else {\n-                                LOGGER.debug(\"Address {} removed but it does not exist.\", addr);\n-                                return currentAddresses;\n+                                refreshedAddresses = new ArrayList<>(currentAddresses.size() - 1);", "originalCommit": "ebeca0d822082ce444d4a54b3f88f7cdfb834c1c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2MDA1Mg==", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r424860052", "bodyText": "hm, may be worth checking that addresses are equal when currentAddresses.size() == 1.", "author": "idelpivnitskiy", "createdAt": "2020-05-14T04:10:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg1OTA5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2NTYwOQ==", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r424865609", "bodyText": "Not sure if we need to be too paranoid, but here is the version \ud83d\ude04\nfinal ResolvedAddress addr = requireNonNull(event.address());\nif (event.isAvailable()) {\n    if (currentAddresses.isEmpty()) {\n        return singletonList(new Host<>(addr));\n    }\n    final List<Host<ResolvedAddress, C>> refreshedAddresses =\n            new ArrayList<>(currentAddresses.size() + 1);\n    refreshedAddresses.addAll(currentAddresses);\n    refreshedAddresses.add(new Host<>(addr));\n    return refreshedAddresses;\n} else {\n    Host<ResolvedAddress, C> host;\n    switch (currentAddresses.size()) {\n        case 0:\n            return emptyList();\n        case 1:\n            host = (Host<ResolvedAddress, C>) currentAddresses.get(0);\n            return addr.equals(host.address) ? emptyList() : singletonList(host);\n        case 2:\n            host = (Host<ResolvedAddress, C>) currentAddresses.get(0);\n            if (addr.equals(host.address)) {\n                return singletonList(currentAddresses.get(1));\n            }\n            host = (Host<ResolvedAddress, C>) currentAddresses.get(1);\n            if (addr.equals(host.address)) {\n                return singletonList(currentAddresses.get(0));\n            }\n            return currentAddresses;\n        default:\n            final List<Host<ResolvedAddress, C>> refreshedAddresses =\n                    new ArrayList<>(currentAddresses.size() - 1);\n            for (Host<ResolvedAddress, C> hostItem :\n                    (List<Host<ResolvedAddress, C>>) currentAddresses) {\n                if (hostItem.address.equals(addr)) {\n                    hostItem.markInactive();\n                } else {\n                    refreshedAddresses.add(hostItem);\n                }\n            }\n            return refreshedAddresses;\n    }\n}", "author": "idelpivnitskiy", "createdAt": "2020-05-14T04:34:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg1OTA5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg3MzEzOQ==", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r424873139", "bodyText": "this code would be a bit more complex in practice because we need to call markInactive when removing, and also for the removal of case 2 we need to check if both elements match bcz there maybe duplicates. I will take some of the suggestions (singleton list for adding when empty, return empty list if after removal the array is empty) but keep it simple as the list being empty isn't generally expected (e.g. we wouldn't be able to communicate with servers in that case).", "author": "Scottmitch", "createdAt": "2020-05-14T05:06:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg1OTA5Mw=="}], "type": "inlineReview"}, {"oid": "bc7175505060065417fa98b8f0a2e73c39e35bfe", "url": "https://github.com/apple/servicetalk/commit/bc7175505060065417fa98b8f0a2e73c39e35bfe", "message": "singleton list when adding to empty list, return empty list if removal results in empty list", "committedDate": "2020-05-14T05:08:12Z", "type": "commit"}, {"oid": "843a4c65e3ad5d0bd30355b82e9d7f53a03592d3", "url": "https://github.com/apple/servicetalk/commit/843a4c65e3ad5d0bd30355b82e9d7f53a03592d3", "message": "duplicate removal, only remove first match", "committedDate": "2020-05-14T12:19:29Z", "type": "commit"}, {"oid": "d6d613e07eae8797356f31155ccf40a0494b82ae", "url": "https://github.com/apple/servicetalk/commit/d6d613e07eae8797356f31155ccf40a0494b82ae", "message": "move unchecked supression to specific assignments.", "committedDate": "2020-05-14T12:25:52Z", "type": "commit"}, {"oid": "8d52ff2dba3b86c7fa733644089faafd40426ef0", "url": "https://github.com/apple/servicetalk/commit/8d52ff2dba3b86c7fa733644089faafd40426ef0", "message": "use typed list instead of untyped list", "committedDate": "2020-05-14T12:30:14Z", "type": "commit"}, {"oid": "b520ad49d5a8183867864a097b0b0953c4e13920", "url": "https://github.com/apple/servicetalk/commit/b520ad49d5a8183867864a097b0b0953c4e13920", "message": "move 2nd copy loop inside first loop", "committedDate": "2020-05-14T12:32:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIzODk1NA==", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r425238954", "bodyText": "We said that it's ok to have duplicated addresses from SD. Neither SD, nor RRLB removes duplicates. What is expected behavior when we receive inactive event for an address that appears multiple times in the list? Should we remove all entries or only the first one?", "author": "idelpivnitskiy", "createdAt": "2020-05-14T15:44:46Z", "path": "servicetalk-loadbalancer/src/main/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancer.java", "diffHunk": "@@ -143,37 +144,43 @@ public void onSubscribe(final Subscription s) {\n                 discoveryCancellable.nextCancellable(s);\n             }\n \n-            @SuppressWarnings(\"unchecked\")\n             @Override\n             public void onNext(final ServiceDiscovererEvent<ResolvedAddress> event) {\n                 LOGGER.debug(\"Load balancer {}, received new ServiceDiscoverer event {}.\", RoundRobinLoadBalancer.this,\n                         event);\n+                @SuppressWarnings(\"unchecked\")\n                 final List<Host<ResolvedAddress, C>> activeAddresses =\n-                        activeHostsUpdater.updateAndGet(RoundRobinLoadBalancer.this, currentAddresses -> {\n-                            final List<Host<ResolvedAddress, C>> refreshedAddresses =\n-                                    new ArrayList<Host<ResolvedAddress, C>>(currentAddresses);\n-                            final ResolvedAddress addr = requireNonNull(event.address());\n-                            for (int i = 0; i < refreshedAddresses.size(); i++) {\n-                                Host<ResolvedAddress, C> host = refreshedAddresses.get(i);\n+                    activeHostsUpdater.updateAndGet(RoundRobinLoadBalancer.this, oldHosts -> {\n+                        final ResolvedAddress addr = requireNonNull(event.address());\n+                        @SuppressWarnings(\"unchecked\")\n+                        final List<Host<ResolvedAddress, C>> oldHostsTyped = (List<Host<ResolvedAddress, C>>) oldHosts;\n+                        if (event.isAvailable()) {\n+                            if (oldHostsTyped.isEmpty()) {\n+                                return singletonList(new Host<>(addr));\n+                            }\n+                            final List<Host<ResolvedAddress, C>> newHosts = new ArrayList<>(oldHostsTyped.size() + 1);\n+                            newHosts.addAll(oldHostsTyped);\n+                            newHosts.add(new Host<>(addr));\n+                            return newHosts;\n+                        } else if (oldHostsTyped.isEmpty()) {\n+                            return emptyList();\n+                        } else {\n+                            final List<Host<ResolvedAddress, C>> newHosts = new ArrayList<>(oldHostsTyped.size() - 1);\n+                            for (int i = 0; i < oldHostsTyped.size(); ++i) {\n+                                final Host<ResolvedAddress, C> host = oldHostsTyped.get(i);\n                                 if (host.address.equals(addr)) {\n-                                    if (event.isAvailable()) {\n-                                        LOGGER.debug(\"Address {} added but it already exists.\", addr);\n-                                        return currentAddresses;\n-                                    } else {\n-                                        refreshedAddresses.remove(i);\n-                                        host.markInactive();\n-                                        return refreshedAddresses;\n+                                    host.markInactive();\n+                                    for (int x = i + 1; x < oldHostsTyped.size(); ++x) {", "originalCommit": "b520ad49d5a8183867864a097b0b0953c4e13920", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI2MDEyNQ==", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r425260125", "bodyText": "initially this PR was removing all items that matched, however I updated it last night to just the first match. for each available event there should be a corresponding unavailable event. if duplicates are used for weighting (e.g. duplicate entries make it more likely to select) then adjusting the weighting by removing an entry shouldn't remove all matching entries.", "author": "Scottmitch", "createdAt": "2020-05-14T16:14:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIzODk1NA=="}], "type": "inlineReview"}, {"oid": "fafe357cce76b07abf51a2e07542b374573c8aef", "url": "https://github.com/apple/servicetalk/commit/fafe357cce76b07abf51a2e07542b374573c8aef", "message": "move conditional to where removal happens", "committedDate": "2020-05-14T16:17:05Z", "type": "commit"}]}