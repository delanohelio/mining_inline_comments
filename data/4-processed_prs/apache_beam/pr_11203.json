{"pr_number": 11203, "pr_title": "[BEAM-9577] Define and implement dependency-aware artifact staging service.", "pr_createdAt": "2020-03-24T01:30:55Z", "pr_url": "https://github.com/apache/beam/pull/11203", "timeline": [{"oid": "8777862c2dc6d0caa1245bfefb9e83000058a498", "url": "https://github.com/apache/beam/commit/8777862c2dc6d0caa1245bfefb9e83000058a498", "message": "file moves", "committedDate": "2020-03-24T20:33:46Z", "type": "forcePushed"}, {"oid": "1595d15db986b02e656529e8f43969d0881b39f7", "url": "https://github.com/apache/beam/commit/1595d15db986b02e656529e8f43969d0881b39f7", "message": "[BEAM-9577] Implement the new Artifact{Staging,Retrieval}Services in Python.\n\nThis is not yet used.", "committedDate": "2020-03-24T20:58:11Z", "type": "forcePushed"}, {"oid": "643c2cbbdb03b9b719946b137775a52278c34550", "url": "https://github.com/apache/beam/commit/643c2cbbdb03b9b719946b137775a52278c34550", "message": "[BEAM-9577] Implement the new Artifact{Staging,Retrieval}Services in Python.\n\nThis is not yet used.", "committedDate": "2020-03-26T00:32:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ2Njk2Mw==", "url": "https://github.com/apache/beam/pull/11203#discussion_r399466963", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            // A client calls the service with an ArtifactResponseWrapper that has the\n          \n          \n            \n            //\n          \n          \n            \n            // A client calls the service with an ArtifactResponseWrapper that has the", "author": "lukecwik", "createdAt": "2020-03-27T18:37:35Z", "path": "model/job-management/src/main/proto/beam_artifact_api.proto", "diffHunk": "@@ -31,8 +31,77 @@ option java_outer_classname = \"ArtifactApi\";\n \n import \"beam_runner_api.proto\";\n \n-// A service to stage artifacts for use in a Job.\n+// A service to retrieve artifacts for use in a Job.\n+service ArtifactRetrievalService {\n+  // Resolves the given artifact reference into one or more simpler artifact\n+  // references (e.g. a Maven dependency into a (transitive) set of jars.\n+  // If no further simplification is possible, returns the original artifacts,\n+  // at which point, all artifacts must be gettable.\n+  rpc ResolveArtifact(ResolveArtifactRequest) returns (ResolveArtifactResponse);\n+\n+  // Retrieves the given artifact as a stream of bytes.\n+  rpc GetArtifact(GetArtifactRequest) returns (stream GetArtifactResponse);\n+}\n+\n+// A service that allows the client to act as an ArtifactRetrievalService,\n+// for a particular job with the server initiating requests and receiving\n+// responses.\n+// A client calls the service with an ArtifactResponseWrapper that has the", "originalCommit": "643c2cbbdb03b9b719946b137775a52278c34550", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ2NzUxNw==", "url": "https://github.com/apache/beam/pull/11203#discussion_r399467517", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              org.apache.beam.model.pipeline.v1.ArtifactInformation artifact = 2;\n          \n          \n            \n              org.apache.beam.model.pipeline.v1.ArtifactInformation artifact = 1;", "author": "lukecwik", "createdAt": "2020-03-27T18:38:36Z", "path": "model/job-management/src/main/proto/beam_artifact_api.proto", "diffHunk": "@@ -31,8 +31,77 @@ option java_outer_classname = \"ArtifactApi\";\n \n import \"beam_runner_api.proto\";\n \n-// A service to stage artifacts for use in a Job.\n+// A service to retrieve artifacts for use in a Job.\n+service ArtifactRetrievalService {\n+  // Resolves the given artifact reference into one or more simpler artifact\n+  // references (e.g. a Maven dependency into a (transitive) set of jars.\n+  // If no further simplification is possible, returns the original artifacts,\n+  // at which point, all artifacts must be gettable.\n+  rpc ResolveArtifact(ResolveArtifactRequest) returns (ResolveArtifactResponse);\n+\n+  // Retrieves the given artifact as a stream of bytes.\n+  rpc GetArtifact(GetArtifactRequest) returns (stream GetArtifactResponse);\n+}\n+\n+// A service that allows the client to act as an ArtifactRetrievalService,\n+// for a particular job with the server initiating requests and receiving\n+// responses.\n+// A client calls the service with an ArtifactResponseWrapper that has the\n+// staging token set, and thereafter responds to the server's requests.\n service ArtifactStagingService {\n+  rpc ReverseArtifactRetrievalService(stream ArtifactResponseWrapper)\n+      returns (stream ArtifactRequestWrapper);\n+}\n+\n+// A request for artifact resolution.\n+message ResolveArtifactRequest {\n+  repeated org.apache.beam.model.pipeline.v1.ArtifactInformation artifacts = 1;\n+}\n+\n+// A response for artifact resolution.\n+message ResolveArtifactResponse {\n+  repeated org.apache.beam.model.pipeline.v1.ArtifactInformation replacements = 1;\n+}\n+\n+// A request to get an artifact.\n+message GetArtifactRequest {\n+  org.apache.beam.model.pipeline.v1.ArtifactInformation artifact = 2;", "originalCommit": "643c2cbbdb03b9b719946b137775a52278c34550", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ2OTQ1Nw==", "url": "https://github.com/apache/beam/pull/11203#discussion_r399469457", "bodyText": "Some documentation questions:\nIs this meant to completely replace the artifacts supplied in replacements?\nWhat if a user doesn't pass in all the original artifacts?\nIf something can't be \"resolved\" to something simpler, does it still appear in the output?", "author": "lukecwik", "createdAt": "2020-03-27T18:42:13Z", "path": "model/job-management/src/main/proto/beam_artifact_api.proto", "diffHunk": "@@ -31,8 +31,77 @@ option java_outer_classname = \"ArtifactApi\";\n \n import \"beam_runner_api.proto\";\n \n-// A service to stage artifacts for use in a Job.\n+// A service to retrieve artifacts for use in a Job.\n+service ArtifactRetrievalService {\n+  // Resolves the given artifact reference into one or more simpler artifact\n+  // references (e.g. a Maven dependency into a (transitive) set of jars.\n+  // If no further simplification is possible, returns the original artifacts,\n+  // at which point, all artifacts must be gettable.\n+  rpc ResolveArtifact(ResolveArtifactRequest) returns (ResolveArtifactResponse);\n+\n+  // Retrieves the given artifact as a stream of bytes.\n+  rpc GetArtifact(GetArtifactRequest) returns (stream GetArtifactResponse);\n+}\n+\n+// A service that allows the client to act as an ArtifactRetrievalService,\n+// for a particular job with the server initiating requests and receiving\n+// responses.\n+// A client calls the service with an ArtifactResponseWrapper that has the\n+// staging token set, and thereafter responds to the server's requests.\n service ArtifactStagingService {\n+  rpc ReverseArtifactRetrievalService(stream ArtifactResponseWrapper)\n+      returns (stream ArtifactRequestWrapper);\n+}\n+\n+// A request for artifact resolution.\n+message ResolveArtifactRequest {\n+  repeated org.apache.beam.model.pipeline.v1.ArtifactInformation artifacts = 1;", "originalCommit": "643c2cbbdb03b9b719946b137775a52278c34550", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU4MDgwNA==", "url": "https://github.com/apache/beam/pull/11203#discussion_r399580804", "bodyText": "Yes, updated the documentation.", "author": "robertwb", "createdAt": "2020-03-27T23:24:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ2OTQ1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU4Mjg1Mw==", "url": "https://github.com/apache/beam/pull/11203#discussion_r399582853", "bodyText": "The documentation has been expanded.", "author": "robertwb", "createdAt": "2020-03-27T23:33:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ2OTQ1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ3NTM2Ng==", "url": "https://github.com/apache/beam/pull/11203#discussion_r399475366", "bodyText": "Why do you not want the resolving to happen as part of GetArtifact?", "author": "lukecwik", "createdAt": "2020-03-27T18:53:12Z", "path": "model/job-management/src/main/proto/beam_artifact_api.proto", "diffHunk": "@@ -31,8 +31,77 @@ option java_outer_classname = \"ArtifactApi\";\n \n import \"beam_runner_api.proto\";\n \n-// A service to stage artifacts for use in a Job.\n+// A service to retrieve artifacts for use in a Job.\n+service ArtifactRetrievalService {\n+  // Resolves the given artifact reference into one or more simpler artifact\n+  // references (e.g. a Maven dependency into a (transitive) set of jars.\n+  // If no further simplification is possible, returns the original artifacts,\n+  // at which point, all artifacts must be gettable.\n+  rpc ResolveArtifact(ResolveArtifactRequest) returns (ResolveArtifactResponse);\n+\n+  // Retrieves the given artifact as a stream of bytes.\n+  rpc GetArtifact(GetArtifactRequest) returns (stream GetArtifactResponse);", "originalCommit": "643c2cbbdb03b9b719946b137775a52278c34550", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2NjU2Mw==", "url": "https://github.com/apache/beam/pull/11203#discussion_r400566563", "bodyText": "Resolution may expand a dependency into multiple distinct blobs. Also, it may be possible (likely?) that artifacts can be resolved into form the client can recognize (or at least deduplicate) obviating the need for a fetch.", "author": "robertwb", "createdAt": "2020-03-31T00:06:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ3NTM2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ5OTE2NA==", "url": "https://github.com/apache/beam/pull/11203#discussion_r399499164", "bodyText": "The style of this stream won't allow for parallel requests to be send to the client since there is no id mechanism to diffentiate the responses since every request will have to have wait for the is_last to be set before the next request is sent out. If you want to support parallel requests, you also need to have a place to provide errors outside of the gRPC status that can be returned since you'll want to identify which request had a problem.\nAlso, if there are any errors for a single request, the whole RPC needs to be terminated since there is no way to say which request failed.\nSince Java has typically a lot of jars, it is likely that we'll want to be able to parallelize this.", "author": "lukecwik", "createdAt": "2020-03-27T19:39:45Z", "path": "model/job-management/src/main/proto/beam_artifact_api.proto", "diffHunk": "@@ -31,8 +31,77 @@ option java_outer_classname = \"ArtifactApi\";\n \n import \"beam_runner_api.proto\";\n \n-// A service to stage artifacts for use in a Job.\n+// A service to retrieve artifacts for use in a Job.\n+service ArtifactRetrievalService {\n+  // Resolves the given artifact reference into one or more simpler artifact\n+  // references (e.g. a Maven dependency into a (transitive) set of jars.\n+  // If no further simplification is possible, returns the original artifacts,\n+  // at which point, all artifacts must be gettable.\n+  rpc ResolveArtifact(ResolveArtifactRequest) returns (ResolveArtifactResponse);\n+\n+  // Retrieves the given artifact as a stream of bytes.\n+  rpc GetArtifact(GetArtifactRequest) returns (stream GetArtifactResponse);\n+}\n+\n+// A service that allows the client to act as an ArtifactRetrievalService,\n+// for a particular job with the server initiating requests and receiving\n+// responses.\n+// A client calls the service with an ArtifactResponseWrapper that has the\n+// staging token set, and thereafter responds to the server's requests.\n service ArtifactStagingService {\n+  rpc ReverseArtifactRetrievalService(stream ArtifactResponseWrapper)", "originalCommit": "643c2cbbdb03b9b719946b137775a52278c34550", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU4MTgxMw==", "url": "https://github.com/apache/beam/pull/11203#discussion_r399581813", "bodyText": "Good question. As discussed offline, multiple requests can be pushed before waiting for a response, so we should be able to fill the network buffer. Either the server or client can choose to parallelize on its backend store as needed.\nI added an error field to the resolve_artifacts field as a runner may attempt to opportunistically consolidate environments, and then fall back to doing each separately.", "author": "robertwb", "createdAt": "2020-03-27T23:28:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ5OTE2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUwMTI2MA==", "url": "https://github.com/apache/beam/pull/11203#discussion_r399501260", "bodyText": "I can see that your trying to set this up so that the staging service can make calls to the SDK so that this way it can get artifacts that are created by the expansion service.", "author": "lukecwik", "createdAt": "2020-03-27T19:44:14Z", "path": "model/job-management/src/main/proto/beam_artifact_api.proto", "diffHunk": "@@ -31,8 +31,77 @@ option java_outer_classname = \"ArtifactApi\";\n \n import \"beam_runner_api.proto\";\n \n-// A service to stage artifacts for use in a Job.\n+// A service to retrieve artifacts for use in a Job.\n+service ArtifactRetrievalService {\n+  // Resolves the given artifact reference into one or more simpler artifact\n+  // references (e.g. a Maven dependency into a (transitive) set of jars.\n+  // If no further simplification is possible, returns the original artifacts,\n+  // at which point, all artifacts must be gettable.\n+  rpc ResolveArtifact(ResolveArtifactRequest) returns (ResolveArtifactResponse);\n+\n+  // Retrieves the given artifact as a stream of bytes.\n+  rpc GetArtifact(GetArtifactRequest) returns (stream GetArtifactResponse);\n+}\n+\n+// A service that allows the client to act as an ArtifactRetrievalService,\n+// for a particular job with the server initiating requests and receiving\n+// responses.\n+// A client calls the service with an ArtifactResponseWrapper that has the\n+// staging token set, and thereafter responds to the server's requests.\n service ArtifactStagingService {", "originalCommit": "643c2cbbdb03b9b719946b137775a52278c34550", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUwMTgzMA==", "url": "https://github.com/apache/beam/pull/11203#discussion_r399501830", "bodyText": "What does simpler mean?, should the request contain a supported set of urns for types and roles?", "author": "lukecwik", "createdAt": "2020-03-27T19:45:26Z", "path": "model/job-management/src/main/proto/beam_artifact_api.proto", "diffHunk": "@@ -31,8 +31,77 @@ option java_outer_classname = \"ArtifactApi\";\n \n import \"beam_runner_api.proto\";\n \n-// A service to stage artifacts for use in a Job.\n+// A service to retrieve artifacts for use in a Job.\n+service ArtifactRetrievalService {\n+  // Resolves the given artifact reference into one or more simpler artifact\n+  // references (e.g. a Maven dependency into a (transitive) set of jars.\n+  // If no further simplification is possible, returns the original artifacts,", "originalCommit": "643c2cbbdb03b9b719946b137775a52278c34550", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU4MzI4MQ==", "url": "https://github.com/apache/beam/pull/11203#discussion_r399583281", "bodyText": "Clarified in the docs.", "author": "robertwb", "createdAt": "2020-03-27T23:35:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUwMTgzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ2NzA3Ng==", "url": "https://github.com/apache/beam/pull/11203#discussion_r400467076", "bodyText": "Is this an ordered list, things that appear first are more preferred then things that appear later?\nIf so, we should make that clear.", "author": "lukecwik", "createdAt": "2020-03-30T20:17:06Z", "path": "model/job-management/src/main/proto/beam_artifact_api.proto", "diffHunk": "@@ -31,8 +31,92 @@ option java_outer_classname = \"ArtifactApi\";\n \n import \"beam_runner_api.proto\";\n \n-// A service to stage artifacts for use in a Job.\n+// A service to retrieve artifacts for use in a Job.\n+service ArtifactRetrievalService {\n+  // Resolves the given artifact references into one or more replacement\n+  // artifact references (e.g. a Maven dependency into a (transitive) set\n+  // of jars.\n+  rpc ResolveArtifact(ResolveArtifactRequest) returns (ResolveArtifactResponse);\n+\n+  // Retrieves the given artifact as a stream of bytes.\n+  rpc GetArtifact(GetArtifactRequest) returns (stream GetArtifactResponse);\n+}\n+\n+// A service that allows the client to act as an ArtifactRetrievalService,\n+// for a particular job with the server initiating requests and receiving\n+// responses.\n+//\n+// A client calls the service with an ArtifactResponseWrapper that has the\n+// staging token set, and thereafter responds to the server's requests.\n service ArtifactStagingService {\n+  rpc ReverseArtifactRetrievalService(stream ArtifactResponseWrapper)\n+      returns (stream ArtifactRequestWrapper);\n+}\n+\n+// A request for artifact resolution.\n+message ResolveArtifactRequest {\n+  // A set of artifacts to (jointly) resolve.\n+  repeated org.apache.beam.model.pipeline.v1.ArtifactInformation artifacts = 1;\n+\n+  // A set of artifact type urns that are understood by the requester.\n+  // An attempt should be made to resolve the artifacts in terms of these URNs,\n+  // but other URNs may be used as well with the understanding that they must\n+  // be fetch-able as bytes via GetArtifact.\n+  repeated string preferred_urns = 2;", "originalCommit": "f10daf5ecc47d57a53e87e9a7bb8845a72f99b4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2NzQ4MQ==", "url": "https://github.com/apache/beam/pull/11203#discussion_r400567481", "bodyText": "I was not intending for this to be an ordered list; I think the choice of artifact will governed more by the existing placement of the artifact.", "author": "robertwb", "createdAt": "2020-03-31T00:09:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ2NzA3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYwNjkwOQ==", "url": "https://github.com/apache/beam/pull/11203#discussion_r400606909", "bodyText": "We don't have to answer this question as part of this PR as it involves a much smaller subset so if you address the other parts then LGTM.\nImagine we added the deferred artifact, would resolving be allowed to return the deferred artifact again?\nWhat would Get do for a deferred artifact?", "author": "lukecwik", "createdAt": "2020-03-31T02:33:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ2NzA3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ2Nzk2Ng==", "url": "https://github.com/apache/beam/pull/11203#discussion_r400467966", "bodyText": "It is important to point out that the artifact information / ordering is important in both the request and the response since in Java this would represent the classpath. So artifacts should be passed in the expected order of usage and returned in an expected order of usage.", "author": "lukecwik", "createdAt": "2020-03-30T20:18:40Z", "path": "model/job-management/src/main/proto/beam_artifact_api.proto", "diffHunk": "@@ -31,8 +31,92 @@ option java_outer_classname = \"ArtifactApi\";\n \n import \"beam_runner_api.proto\";\n \n-// A service to stage artifacts for use in a Job.\n+// A service to retrieve artifacts for use in a Job.\n+service ArtifactRetrievalService {\n+  // Resolves the given artifact references into one or more replacement\n+  // artifact references (e.g. a Maven dependency into a (transitive) set\n+  // of jars.\n+  rpc ResolveArtifact(ResolveArtifactRequest) returns (ResolveArtifactResponse);\n+\n+  // Retrieves the given artifact as a stream of bytes.\n+  rpc GetArtifact(GetArtifactRequest) returns (stream GetArtifactResponse);\n+}\n+\n+// A service that allows the client to act as an ArtifactRetrievalService,\n+// for a particular job with the server initiating requests and receiving\n+// responses.\n+//\n+// A client calls the service with an ArtifactResponseWrapper that has the\n+// staging token set, and thereafter responds to the server's requests.\n service ArtifactStagingService {\n+  rpc ReverseArtifactRetrievalService(stream ArtifactResponseWrapper)\n+      returns (stream ArtifactRequestWrapper);\n+}\n+\n+// A request for artifact resolution.\n+message ResolveArtifactRequest {\n+  // A set of artifacts to (jointly) resolve.\n+  repeated org.apache.beam.model.pipeline.v1.ArtifactInformation artifacts = 1;", "originalCommit": "f10daf5ecc47d57a53e87e9a7bb8845a72f99b4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2Njc2OA==", "url": "https://github.com/apache/beam/pull/11203#discussion_r400566768", "bodyText": "Done.", "author": "robertwb", "createdAt": "2020-03-31T00:06:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ2Nzk2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ2ODUxMg==", "url": "https://github.com/apache/beam/pull/11203#discussion_r400468512", "bodyText": "I don't believe this error message will be actionable.\nA runner makes a request to resolve A -> B. If it doesn't understand what A is then an error during resolution won't really be actionable to the runner and I don't believe will be significantly better then terminating the whole streaming RPC with the failure. Lets say the runner could also try A -> C, then it should have listed in the preferred URNs B and C and the resolver would choose a valid combination.", "author": "lukecwik", "createdAt": "2020-03-30T20:19:41Z", "path": "model/job-management/src/main/proto/beam_artifact_api.proto", "diffHunk": "@@ -31,8 +31,92 @@ option java_outer_classname = \"ArtifactApi\";\n \n import \"beam_runner_api.proto\";\n \n-// A service to stage artifacts for use in a Job.\n+// A service to retrieve artifacts for use in a Job.\n+service ArtifactRetrievalService {\n+  // Resolves the given artifact references into one or more replacement\n+  // artifact references (e.g. a Maven dependency into a (transitive) set\n+  // of jars.\n+  rpc ResolveArtifact(ResolveArtifactRequest) returns (ResolveArtifactResponse);\n+\n+  // Retrieves the given artifact as a stream of bytes.\n+  rpc GetArtifact(GetArtifactRequest) returns (stream GetArtifactResponse);\n+}\n+\n+// A service that allows the client to act as an ArtifactRetrievalService,\n+// for a particular job with the server initiating requests and receiving\n+// responses.\n+//\n+// A client calls the service with an ArtifactResponseWrapper that has the\n+// staging token set, and thereafter responds to the server's requests.\n service ArtifactStagingService {\n+  rpc ReverseArtifactRetrievalService(stream ArtifactResponseWrapper)\n+      returns (stream ArtifactRequestWrapper);\n+}\n+\n+// A request for artifact resolution.\n+message ResolveArtifactRequest {\n+  // A set of artifacts to (jointly) resolve.\n+  repeated org.apache.beam.model.pipeline.v1.ArtifactInformation artifacts = 1;\n+\n+  // A set of artifact type urns that are understood by the requester.\n+  // An attempt should be made to resolve the artifacts in terms of these URNs,\n+  // but other URNs may be used as well with the understanding that they must\n+  // be fetch-able as bytes via GetArtifact.\n+  repeated string preferred_urns = 2;\n+}\n+\n+// A response for artifact resolution.\n+message ResolveArtifactResponse {\n+  // A full set of replacements for the set of requested artifacts, preferably\n+  // in terms of the requested type URNs.  If there is no better resolution,\n+  // the original list is returned.\n+  repeated org.apache.beam.model.pipeline.v1.ArtifactInformation replacements = 1;\n+\n+  // (Optional) If set, used to indicate the artifacts are mutually inconsistent\n+  // (e.g. due to a diamond dependency problem) or could otherwise not be\n+  // resolved (e.g. due to invalid specifications).\n+  string error = 2;", "originalCommit": "f10daf5ecc47d57a53e87e9a7bb8845a72f99b4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3MDMxNg==", "url": "https://github.com/apache/beam/pull/11203#discussion_r400570316", "bodyText": "This was intended to be used for the merging of environments. Suppose one environment requires A and another requires B. It may be possible to provide a set of artifacts that satisfy both (e.g. if they were maven dependencies), or possibly not (if there was a diamond dependency problem, or they were opaque).\nI am now realizing that this probably needs to be a separate protocol, which can be introduced at a future date.", "author": "robertwb", "createdAt": "2020-03-31T00:18:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ2ODUxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ3MDk2Nw==", "url": "https://github.com/apache/beam/pull/11203#discussion_r400470967", "bodyText": "Should we have a resume_offset field?\nWhenever we need to stage a large amount of data, it seems as though the SDK would reconnect so a \"retry\" would be possible and should be able to pass in a point to resume from for a large stream.", "author": "lukecwik", "createdAt": "2020-03-30T20:24:12Z", "path": "model/job-management/src/main/proto/beam_artifact_api.proto", "diffHunk": "@@ -31,8 +31,92 @@ option java_outer_classname = \"ArtifactApi\";\n \n import \"beam_runner_api.proto\";\n \n-// A service to stage artifacts for use in a Job.\n+// A service to retrieve artifacts for use in a Job.\n+service ArtifactRetrievalService {\n+  // Resolves the given artifact references into one or more replacement\n+  // artifact references (e.g. a Maven dependency into a (transitive) set\n+  // of jars.\n+  rpc ResolveArtifact(ResolveArtifactRequest) returns (ResolveArtifactResponse);\n+\n+  // Retrieves the given artifact as a stream of bytes.\n+  rpc GetArtifact(GetArtifactRequest) returns (stream GetArtifactResponse);\n+}\n+\n+// A service that allows the client to act as an ArtifactRetrievalService,\n+// for a particular job with the server initiating requests and receiving\n+// responses.\n+//\n+// A client calls the service with an ArtifactResponseWrapper that has the\n+// staging token set, and thereafter responds to the server's requests.\n service ArtifactStagingService {\n+  rpc ReverseArtifactRetrievalService(stream ArtifactResponseWrapper)\n+      returns (stream ArtifactRequestWrapper);\n+}\n+\n+// A request for artifact resolution.\n+message ResolveArtifactRequest {\n+  // A set of artifacts to (jointly) resolve.\n+  repeated org.apache.beam.model.pipeline.v1.ArtifactInformation artifacts = 1;\n+\n+  // A set of artifact type urns that are understood by the requester.\n+  // An attempt should be made to resolve the artifacts in terms of these URNs,\n+  // but other URNs may be used as well with the understanding that they must\n+  // be fetch-able as bytes via GetArtifact.\n+  repeated string preferred_urns = 2;\n+}\n+\n+// A response for artifact resolution.\n+message ResolveArtifactResponse {\n+  // A full set of replacements for the set of requested artifacts, preferably\n+  // in terms of the requested type URNs.  If there is no better resolution,\n+  // the original list is returned.\n+  repeated org.apache.beam.model.pipeline.v1.ArtifactInformation replacements = 1;\n+\n+  // (Optional) If set, used to indicate the artifacts are mutually inconsistent\n+  // (e.g. due to a diamond dependency problem) or could otherwise not be\n+  // resolved (e.g. due to invalid specifications).\n+  string error = 2;\n+}\n+\n+// A request to get an artifact.\n+message GetArtifactRequest {\n+  org.apache.beam.model.pipeline.v1.ArtifactInformation artifact = 1;", "originalCommit": "f10daf5ecc47d57a53e87e9a7bb8845a72f99b4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3MTYxNw==", "url": "https://github.com/apache/beam/pull/11203#discussion_r400571617", "bodyText": "Let's not for now; this could be difficult to implement in practice (for non-seekable resources). We could add this capability in the future if needed.", "author": "robertwb", "createdAt": "2020-03-31T00:23:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ3MDk2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYwNjEzOQ==", "url": "https://github.com/apache/beam/pull/11203#discussion_r400606139", "bodyText": "I'm fine with adding it later, just pointing out that adding it later will require producing GetArtifactRequest V2 as adding the field would be backwards incompatible unless an actual resumed_offset was added to the response.", "author": "lukecwik", "createdAt": "2020-03-31T02:30:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ3MDk2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ3NjEyNw==", "url": "https://github.com/apache/beam/pull/11203#discussion_r400476127", "bodyText": "nit: FakeRetrievalService -> ForwardingRetrievalService\nor ProxyingRetrievalService", "author": "lukecwik", "createdAt": "2020-03-30T20:33:31Z", "path": "sdks/python/apache_beam/runners/portability/artifact_service.py", "diffHunk": "@@ -263,3 +279,205 @@ def _open(self, path, mode='r'):\n       return filesystems.FileSystems.create(path)\n     else:\n       return filesystems.FileSystems.open(path)\n+\n+\n+# The dependency-aware artifact staging and retrieval services.\n+\n+\n+def _queue_iter(queue, end_token):\n+  while True:\n+    item = queue.get()\n+    if item is end_token:\n+      break\n+    yield item\n+\n+\n+class ArtifactRetrievalService(\n+    beam_artifact_api_pb2_grpc.ArtifactRetrievalServiceServicer):\n+\n+  _DEFAULT_CHUNK_SIZE = 2 << 20\n+\n+  def __init__(\n+      self,\n+      file_reader,  # type: Callable[[str], BinaryIO],\n+      chunk_size=None,\n+  ):\n+    self._file_reader = file_reader\n+    self._chunk_size = chunk_size or self._DEFAULT_CHUNK_SIZE\n+\n+  def ResolveArtifact(self, request, context=None):\n+    return beam_artifact_api_pb2.ResolveArtifactResponse(\n+        replacements=request.artifacts)\n+\n+  def GetArtifact(self, request, context=None):\n+    if request.artifact.type_urn == common_urns.artifact_types.FILE.urn:\n+      payload = proto_utils.parse_Bytes(\n+          request.artifact.type_payload,\n+          beam_runner_api_pb2.ArtifactFilePayload)\n+      read_handle = self._file_reader(payload.path)\n+    elif request.artifact.type_urn == common_urns.artifact_types.URL.urn:\n+      payload = proto_utils.parse_Bytes(\n+          request.artifact.type_payload, beam_runner_api_pb2.ArtifactUrlPayload)\n+      # TODO(Py3): Remove the unneeded contextlib wrapper.\n+      read_handle = contextlib.closing(urlopen(payload.path))\n+    elif request.artifact.type_urn == common_urns.artifact_types.EMBEDDED.urn:\n+      payload = proto_utils.parse_Bytes(\n+          request.artifact.type_payload,\n+          beam_runner_api_pb2.EmbeddedFilePayload)\n+      read_handle = BytesIO(payload.data)\n+    else:\n+      raise NotImplementedError(request.artifact.type_urn)\n+\n+    with read_handle as fin:\n+      while True:\n+        chunk = fin.read(self._chunk_size)\n+        if not chunk:\n+          break\n+        yield beam_artifact_api_pb2.GetArtifactResponse(data=chunk)\n+\n+\n+class ArtifactStagingService(\n+    beam_artifact_api_pb2_grpc.ArtifactStagingServiceServicer):\n+  def __init__(\n+      self,\n+      file_writer,  # type: Callable[[str, Optional[str]], Tuple[BinaryIO, str]]\n+    ):\n+    self._lock = threading.Lock()\n+    self._jobs_to_stage = {}\n+    self._file_writer = file_writer\n+\n+  def register_job(self, staging_token, dependencies):\n+    self._jobs_to_stage[staging_token] = list(dependencies), threading.Event()\n+\n+  def resolved_deps(self, staging_token, timeout=None):\n+    dependencies_list, event = self._jobs_to_stage[staging_token]\n+    try:\n+      if not event.wait(timeout):\n+        raise concurrent.futures.TimeoutError()\n+      return dependencies_list\n+    finally:\n+      del self._jobs_to_stage[staging_token]\n+\n+  def ReverseArtifactRetrievalService(self, responses, context=None):\n+    staging_token = next(responses).staging_token\n+    dependencies, event = self._jobs_to_stage[staging_token]\n+\n+    requests = queue.Queue()\n+\n+    class FakeRetrievalService(object):", "originalCommit": "f10daf5ecc47d57a53e87e9a7bb8845a72f99b4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU4Mzg1Mw==", "url": "https://github.com/apache/beam/pull/11203#discussion_r400583853", "bodyText": "Done.", "author": "robertwb", "createdAt": "2020-03-31T01:07:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ3NjEyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ3ODM4MQ==", "url": "https://github.com/apache/beam/pull/11203#discussion_r400478381", "bodyText": "preferred_urns = FILE", "author": "lukecwik", "createdAt": "2020-03-30T20:37:37Z", "path": "sdks/python/apache_beam/runners/portability/artifact_service.py", "diffHunk": "@@ -263,3 +279,205 @@ def _open(self, path, mode='r'):\n       return filesystems.FileSystems.create(path)\n     else:\n       return filesystems.FileSystems.open(path)\n+\n+\n+# The dependency-aware artifact staging and retrieval services.\n+\n+\n+def _queue_iter(queue, end_token):\n+  while True:\n+    item = queue.get()\n+    if item is end_token:\n+      break\n+    yield item\n+\n+\n+class ArtifactRetrievalService(\n+    beam_artifact_api_pb2_grpc.ArtifactRetrievalServiceServicer):\n+\n+  _DEFAULT_CHUNK_SIZE = 2 << 20\n+\n+  def __init__(\n+      self,\n+      file_reader,  # type: Callable[[str], BinaryIO],\n+      chunk_size=None,\n+  ):\n+    self._file_reader = file_reader\n+    self._chunk_size = chunk_size or self._DEFAULT_CHUNK_SIZE\n+\n+  def ResolveArtifact(self, request, context=None):\n+    return beam_artifact_api_pb2.ResolveArtifactResponse(\n+        replacements=request.artifacts)\n+\n+  def GetArtifact(self, request, context=None):\n+    if request.artifact.type_urn == common_urns.artifact_types.FILE.urn:\n+      payload = proto_utils.parse_Bytes(\n+          request.artifact.type_payload,\n+          beam_runner_api_pb2.ArtifactFilePayload)\n+      read_handle = self._file_reader(payload.path)\n+    elif request.artifact.type_urn == common_urns.artifact_types.URL.urn:\n+      payload = proto_utils.parse_Bytes(\n+          request.artifact.type_payload, beam_runner_api_pb2.ArtifactUrlPayload)\n+      # TODO(Py3): Remove the unneeded contextlib wrapper.\n+      read_handle = contextlib.closing(urlopen(payload.path))\n+    elif request.artifact.type_urn == common_urns.artifact_types.EMBEDDED.urn:\n+      payload = proto_utils.parse_Bytes(\n+          request.artifact.type_payload,\n+          beam_runner_api_pb2.EmbeddedFilePayload)\n+      read_handle = BytesIO(payload.data)\n+    else:\n+      raise NotImplementedError(request.artifact.type_urn)\n+\n+    with read_handle as fin:\n+      while True:\n+        chunk = fin.read(self._chunk_size)\n+        if not chunk:\n+          break\n+        yield beam_artifact_api_pb2.GetArtifactResponse(data=chunk)\n+\n+\n+class ArtifactStagingService(\n+    beam_artifact_api_pb2_grpc.ArtifactStagingServiceServicer):\n+  def __init__(\n+      self,\n+      file_writer,  # type: Callable[[str, Optional[str]], Tuple[BinaryIO, str]]\n+    ):\n+    self._lock = threading.Lock()\n+    self._jobs_to_stage = {}\n+    self._file_writer = file_writer\n+\n+  def register_job(self, staging_token, dependencies):\n+    self._jobs_to_stage[staging_token] = list(dependencies), threading.Event()\n+\n+  def resolved_deps(self, staging_token, timeout=None):\n+    dependencies_list, event = self._jobs_to_stage[staging_token]\n+    try:\n+      if not event.wait(timeout):\n+        raise concurrent.futures.TimeoutError()\n+      return dependencies_list\n+    finally:\n+      del self._jobs_to_stage[staging_token]\n+\n+  def ReverseArtifactRetrievalService(self, responses, context=None):\n+    staging_token = next(responses).staging_token\n+    dependencies, event = self._jobs_to_stage[staging_token]\n+\n+    requests = queue.Queue()\n+\n+    class FakeRetrievalService(object):\n+      def ResolveArtifacts(self, request):\n+        requests.put(\n+            beam_artifact_api_pb2.ArtifactRequestWrapper(\n+                resolve_artifact=request))\n+        return next(responses).resolve_artifact_response\n+\n+      def GetArtifact(self, request):\n+        requests.put(\n+            beam_artifact_api_pb2.ArtifactRequestWrapper(get_artifact=request))\n+        while True:\n+          response = next(responses)\n+          yield response.get_artifact_response\n+          if response.is_last:\n+            break\n+\n+    def resolve():\n+      file_deps = resolve_as_files(\n+          FakeRetrievalService(),\n+          lambda name: self._file_writer(os.path.join(staging_token, name)),\n+          dependencies)\n+      dependencies[:] = file_deps\n+      requests.put(None)\n+      event.set()\n+\n+    t = threading.Thread(target=resolve)\n+    t.daemon = True\n+    t.start()\n+\n+    return _queue_iter(requests, None)\n+\n+\n+def resolve_as_files(retrieval_service, file_writer, dependencies):\n+  \"\"\"Translates a set of dependencies into file-based dependencies.\"\"\"\n+  # Resolve until nothing changes.  This ensures that they can be fetched.\n+  resolution = retrieval_service.ResolveArtifacts(\n+      beam_artifact_api_pb2.ResolveArtifactRequest(\n+          artifacts=dependencies,\n+          # Anything fetchable will do.\n+          # TODO(robertwb): Take advantage of shared filesystems, urls.\n+          preferred_urns=[],", "originalCommit": "f10daf5ecc47d57a53e87e9a7bb8845a72f99b4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU4NDI3Nw==", "url": "https://github.com/apache/beam/pull/11203#discussion_r400584277", "bodyText": "There is no preference here, it always fetches them.", "author": "robertwb", "createdAt": "2020-03-31T01:08:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ3ODM4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4MDk2Ng==", "url": "https://github.com/apache/beam/pull/11203#discussion_r400480966", "bodyText": "Any reason to not use the staging token to prevent collisions instead of relying on the sha256 of a proto which may not be unique (note that nobody populates the sha256 for the File type, I mentioned this on #11205)?", "author": "lukecwik", "createdAt": "2020-03-30T20:42:23Z", "path": "sdks/python/apache_beam/runners/portability/artifact_service.py", "diffHunk": "@@ -263,3 +279,205 @@ def _open(self, path, mode='r'):\n       return filesystems.FileSystems.create(path)\n     else:\n       return filesystems.FileSystems.open(path)\n+\n+\n+# The dependency-aware artifact staging and retrieval services.\n+\n+\n+def _queue_iter(queue, end_token):\n+  while True:\n+    item = queue.get()\n+    if item is end_token:\n+      break\n+    yield item\n+\n+\n+class ArtifactRetrievalService(\n+    beam_artifact_api_pb2_grpc.ArtifactRetrievalServiceServicer):\n+\n+  _DEFAULT_CHUNK_SIZE = 2 << 20\n+\n+  def __init__(\n+      self,\n+      file_reader,  # type: Callable[[str], BinaryIO],\n+      chunk_size=None,\n+  ):\n+    self._file_reader = file_reader\n+    self._chunk_size = chunk_size or self._DEFAULT_CHUNK_SIZE\n+\n+  def ResolveArtifact(self, request, context=None):\n+    return beam_artifact_api_pb2.ResolveArtifactResponse(\n+        replacements=request.artifacts)\n+\n+  def GetArtifact(self, request, context=None):\n+    if request.artifact.type_urn == common_urns.artifact_types.FILE.urn:\n+      payload = proto_utils.parse_Bytes(\n+          request.artifact.type_payload,\n+          beam_runner_api_pb2.ArtifactFilePayload)\n+      read_handle = self._file_reader(payload.path)\n+    elif request.artifact.type_urn == common_urns.artifact_types.URL.urn:\n+      payload = proto_utils.parse_Bytes(\n+          request.artifact.type_payload, beam_runner_api_pb2.ArtifactUrlPayload)\n+      # TODO(Py3): Remove the unneeded contextlib wrapper.\n+      read_handle = contextlib.closing(urlopen(payload.path))\n+    elif request.artifact.type_urn == common_urns.artifact_types.EMBEDDED.urn:\n+      payload = proto_utils.parse_Bytes(\n+          request.artifact.type_payload,\n+          beam_runner_api_pb2.EmbeddedFilePayload)\n+      read_handle = BytesIO(payload.data)\n+    else:\n+      raise NotImplementedError(request.artifact.type_urn)\n+\n+    with read_handle as fin:\n+      while True:\n+        chunk = fin.read(self._chunk_size)\n+        if not chunk:\n+          break\n+        yield beam_artifact_api_pb2.GetArtifactResponse(data=chunk)\n+\n+\n+class ArtifactStagingService(\n+    beam_artifact_api_pb2_grpc.ArtifactStagingServiceServicer):\n+  def __init__(\n+      self,\n+      file_writer,  # type: Callable[[str, Optional[str]], Tuple[BinaryIO, str]]\n+    ):\n+    self._lock = threading.Lock()\n+    self._jobs_to_stage = {}\n+    self._file_writer = file_writer\n+\n+  def register_job(self, staging_token, dependencies):\n+    self._jobs_to_stage[staging_token] = list(dependencies), threading.Event()\n+\n+  def resolved_deps(self, staging_token, timeout=None):\n+    dependencies_list, event = self._jobs_to_stage[staging_token]\n+    try:\n+      if not event.wait(timeout):\n+        raise concurrent.futures.TimeoutError()\n+      return dependencies_list\n+    finally:\n+      del self._jobs_to_stage[staging_token]\n+\n+  def ReverseArtifactRetrievalService(self, responses, context=None):\n+    staging_token = next(responses).staging_token\n+    dependencies, event = self._jobs_to_stage[staging_token]\n+\n+    requests = queue.Queue()\n+\n+    class FakeRetrievalService(object):\n+      def ResolveArtifacts(self, request):\n+        requests.put(\n+            beam_artifact_api_pb2.ArtifactRequestWrapper(\n+                resolve_artifact=request))\n+        return next(responses).resolve_artifact_response\n+\n+      def GetArtifact(self, request):\n+        requests.put(\n+            beam_artifact_api_pb2.ArtifactRequestWrapper(get_artifact=request))\n+        while True:\n+          response = next(responses)\n+          yield response.get_artifact_response\n+          if response.is_last:\n+            break\n+\n+    def resolve():\n+      file_deps = resolve_as_files(\n+          FakeRetrievalService(),\n+          lambda name: self._file_writer(os.path.join(staging_token, name)),\n+          dependencies)\n+      dependencies[:] = file_deps\n+      requests.put(None)\n+      event.set()\n+\n+    t = threading.Thread(target=resolve)\n+    t.daemon = True\n+    t.start()\n+\n+    return _queue_iter(requests, None)\n+\n+\n+def resolve_as_files(retrieval_service, file_writer, dependencies):\n+  \"\"\"Translates a set of dependencies into file-based dependencies.\"\"\"\n+  # Resolve until nothing changes.  This ensures that they can be fetched.\n+  resolution = retrieval_service.ResolveArtifacts(\n+      beam_artifact_api_pb2.ResolveArtifactRequest(\n+          artifacts=dependencies,\n+          # Anything fetchable will do.\n+          # TODO(robertwb): Take advantage of shared filesystems, urls.\n+          preferred_urns=[],\n+      ))\n+  if resolution.error:\n+    raise RuntimeError(resolution)\n+  dependencies = resolution.replacements\n+\n+  # Fetch each of the dependencies, using file_writer to store them as\n+  # file-based artifacts.\n+  # TODO(robertwb): Consider parallelizing the actual writes.\n+  for dep in dependencies:\n+    if dep.role_urn == common_urns.artifact_roles.STAGING_TO.urn:\n+      base_name = os.path.basename(\n+          proto_utils.parse_Bytes(\n+              dep.role_payload,\n+              beam_runner_api_pb2.ArtifactStagingToRolePayload).staged_name)\n+    else:\n+      base_name = None\n+    unique_name = '-'.join(\n+        filter(\n+            None,\n+            [hashlib.sha256(dep.SerializeToString()).hexdigest(), base_name]))", "originalCommit": "f10daf5ecc47d57a53e87e9a7bb8845a72f99b4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU4NTY3Ng==", "url": "https://github.com/apache/beam/pull/11203#discussion_r400585676", "bodyText": "The full file path will already be prefixed by the staging token (line ~413 where this is called). This does make me wonder whether every artifact should have a name (even non-file based ones). Especially if roles become more specific (like classpath or pip package rather than just stage_to).", "author": "robertwb", "createdAt": "2020-03-31T01:13:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4MDk2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYwMzU4Mg==", "url": "https://github.com/apache/beam/pull/11203#discussion_r400603582", "bodyText": "Its typically pretty easy to figure out the name of a path component so no need.", "author": "lukecwik", "createdAt": "2020-03-31T02:20:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4MDk2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4OTI4OA==", "url": "https://github.com/apache/beam/pull/11203#discussion_r400489288", "bodyText": "Its probably best to raise an error if the staging token is already in the dict.", "author": "lukecwik", "createdAt": "2020-03-30T20:57:46Z", "path": "sdks/python/apache_beam/runners/portability/artifact_service.py", "diffHunk": "@@ -263,3 +279,205 @@ def _open(self, path, mode='r'):\n       return filesystems.FileSystems.create(path)\n     else:\n       return filesystems.FileSystems.open(path)\n+\n+\n+# The dependency-aware artifact staging and retrieval services.\n+\n+\n+def _queue_iter(queue, end_token):\n+  while True:\n+    item = queue.get()\n+    if item is end_token:\n+      break\n+    yield item\n+\n+\n+class ArtifactRetrievalService(\n+    beam_artifact_api_pb2_grpc.ArtifactRetrievalServiceServicer):\n+\n+  _DEFAULT_CHUNK_SIZE = 2 << 20\n+\n+  def __init__(\n+      self,\n+      file_reader,  # type: Callable[[str], BinaryIO],\n+      chunk_size=None,\n+  ):\n+    self._file_reader = file_reader\n+    self._chunk_size = chunk_size or self._DEFAULT_CHUNK_SIZE\n+\n+  def ResolveArtifact(self, request, context=None):\n+    return beam_artifact_api_pb2.ResolveArtifactResponse(\n+        replacements=request.artifacts)\n+\n+  def GetArtifact(self, request, context=None):\n+    if request.artifact.type_urn == common_urns.artifact_types.FILE.urn:\n+      payload = proto_utils.parse_Bytes(\n+          request.artifact.type_payload,\n+          beam_runner_api_pb2.ArtifactFilePayload)\n+      read_handle = self._file_reader(payload.path)\n+    elif request.artifact.type_urn == common_urns.artifact_types.URL.urn:\n+      payload = proto_utils.parse_Bytes(\n+          request.artifact.type_payload, beam_runner_api_pb2.ArtifactUrlPayload)\n+      # TODO(Py3): Remove the unneeded contextlib wrapper.\n+      read_handle = contextlib.closing(urlopen(payload.path))\n+    elif request.artifact.type_urn == common_urns.artifact_types.EMBEDDED.urn:\n+      payload = proto_utils.parse_Bytes(\n+          request.artifact.type_payload,\n+          beam_runner_api_pb2.EmbeddedFilePayload)\n+      read_handle = BytesIO(payload.data)\n+    else:\n+      raise NotImplementedError(request.artifact.type_urn)\n+\n+    with read_handle as fin:\n+      while True:\n+        chunk = fin.read(self._chunk_size)\n+        if not chunk:\n+          break\n+        yield beam_artifact_api_pb2.GetArtifactResponse(data=chunk)\n+\n+\n+class ArtifactStagingService(\n+    beam_artifact_api_pb2_grpc.ArtifactStagingServiceServicer):\n+  def __init__(\n+      self,\n+      file_writer,  # type: Callable[[str, Optional[str]], Tuple[BinaryIO, str]]\n+    ):\n+    self._lock = threading.Lock()\n+    self._jobs_to_stage = {}\n+    self._file_writer = file_writer\n+\n+  def register_job(self, staging_token, dependencies):\n+    self._jobs_to_stage[staging_token] = list(dependencies), threading.Event()", "originalCommit": "f10daf5ecc47d57a53e87e9a7bb8845a72f99b4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU3MjMyMQ==", "url": "https://github.com/apache/beam/pull/11203#discussion_r400572321", "bodyText": "Yes, done.", "author": "robertwb", "createdAt": "2020-03-31T00:25:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4OTI4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYwNDgyMw==", "url": "https://github.com/apache/beam/pull/11203#discussion_r400604823", "bodyText": "I think we need to hold _lock everywhere for access/mutation of _jobs_to_stage", "author": "lukecwik", "createdAt": "2020-03-31T02:25:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4OTI4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ5MDU1MQ==", "url": "https://github.com/apache/beam/pull/11203#discussion_r400490551", "bodyText": "It doesn't look like we are passing any of the failures through the queue meaning the daemon thread below will get stuck forever, it would be great if we could pass through the status/error we got from the call we forwarded and stop.", "author": "lukecwik", "createdAt": "2020-03-30T21:00:08Z", "path": "sdks/python/apache_beam/runners/portability/artifact_service.py", "diffHunk": "@@ -263,3 +279,205 @@ def _open(self, path, mode='r'):\n       return filesystems.FileSystems.create(path)\n     else:\n       return filesystems.FileSystems.open(path)\n+\n+\n+# The dependency-aware artifact staging and retrieval services.\n+\n+\n+def _queue_iter(queue, end_token):\n+  while True:\n+    item = queue.get()\n+    if item is end_token:\n+      break\n+    yield item\n+\n+\n+class ArtifactRetrievalService(\n+    beam_artifact_api_pb2_grpc.ArtifactRetrievalServiceServicer):\n+\n+  _DEFAULT_CHUNK_SIZE = 2 << 20\n+\n+  def __init__(\n+      self,\n+      file_reader,  # type: Callable[[str], BinaryIO],\n+      chunk_size=None,\n+  ):\n+    self._file_reader = file_reader\n+    self._chunk_size = chunk_size or self._DEFAULT_CHUNK_SIZE\n+\n+  def ResolveArtifact(self, request, context=None):\n+    return beam_artifact_api_pb2.ResolveArtifactResponse(\n+        replacements=request.artifacts)\n+\n+  def GetArtifact(self, request, context=None):\n+    if request.artifact.type_urn == common_urns.artifact_types.FILE.urn:\n+      payload = proto_utils.parse_Bytes(\n+          request.artifact.type_payload,\n+          beam_runner_api_pb2.ArtifactFilePayload)\n+      read_handle = self._file_reader(payload.path)\n+    elif request.artifact.type_urn == common_urns.artifact_types.URL.urn:\n+      payload = proto_utils.parse_Bytes(\n+          request.artifact.type_payload, beam_runner_api_pb2.ArtifactUrlPayload)\n+      # TODO(Py3): Remove the unneeded contextlib wrapper.\n+      read_handle = contextlib.closing(urlopen(payload.path))\n+    elif request.artifact.type_urn == common_urns.artifact_types.EMBEDDED.urn:\n+      payload = proto_utils.parse_Bytes(\n+          request.artifact.type_payload,\n+          beam_runner_api_pb2.EmbeddedFilePayload)\n+      read_handle = BytesIO(payload.data)\n+    else:\n+      raise NotImplementedError(request.artifact.type_urn)\n+\n+    with read_handle as fin:\n+      while True:\n+        chunk = fin.read(self._chunk_size)\n+        if not chunk:\n+          break\n+        yield beam_artifact_api_pb2.GetArtifactResponse(data=chunk)\n+\n+\n+class ArtifactStagingService(\n+    beam_artifact_api_pb2_grpc.ArtifactStagingServiceServicer):\n+  def __init__(\n+      self,\n+      file_writer,  # type: Callable[[str, Optional[str]], Tuple[BinaryIO, str]]\n+    ):\n+    self._lock = threading.Lock()\n+    self._jobs_to_stage = {}\n+    self._file_writer = file_writer\n+\n+  def register_job(self, staging_token, dependencies):\n+    self._jobs_to_stage[staging_token] = list(dependencies), threading.Event()\n+\n+  def resolved_deps(self, staging_token, timeout=None):\n+    dependencies_list, event = self._jobs_to_stage[staging_token]\n+    try:\n+      if not event.wait(timeout):\n+        raise concurrent.futures.TimeoutError()\n+      return dependencies_list\n+    finally:\n+      del self._jobs_to_stage[staging_token]\n+\n+  def ReverseArtifactRetrievalService(self, responses, context=None):\n+    staging_token = next(responses).staging_token\n+    dependencies, event = self._jobs_to_stage[staging_token]\n+\n+    requests = queue.Queue()\n+\n+    class FakeRetrievalService(object):\n+      def ResolveArtifacts(self, request):\n+        requests.put(\n+            beam_artifact_api_pb2.ArtifactRequestWrapper(\n+                resolve_artifact=request))\n+        return next(responses).resolve_artifact_response", "originalCommit": "f10daf5ecc47d57a53e87e9a7bb8845a72f99b4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU4Mzk3Mg==", "url": "https://github.com/apache/beam/pull/11203#discussion_r400583972", "bodyText": "Good call. Done.", "author": "robertwb", "createdAt": "2020-03-31T01:07:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ5MDU1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYwNDAwOQ==", "url": "https://github.com/apache/beam/pull/11203#discussion_r400604009", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              // A full (ordered) set of replacements for the set of requested artifacts,\n          \n          \n            \n              // A fully (ordered) set of replacements for the set of requested artifacts,", "author": "lukecwik", "createdAt": "2020-03-31T02:21:45Z", "path": "model/job-management/src/main/proto/beam_artifact_api.proto", "diffHunk": "@@ -67,15 +70,10 @@ message ResolveArtifactRequest {\n \n // A response for artifact resolution.\n message ResolveArtifactResponse {\n-  // A full set of replacements for the set of requested artifacts, preferably\n-  // in terms of the requested type URNs.  If there is no better resolution,\n-  // the original list is returned.\n+  // A full (ordered) set of replacements for the set of requested artifacts,", "originalCommit": "7ee5b3c786ba6eac14bdbf72cf599962000bdb3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYwNDU0Ng==", "url": "https://github.com/apache/beam/pull/11203#discussion_r400604546", "bodyText": "so clever", "author": "lukecwik", "createdAt": "2020-03-31T02:24:02Z", "path": "sdks/python/apache_beam/runners/portability/artifact_service.py", "diffHunk": "@@ -284,12 +284,38 @@ def _open(self, path, mode='r'):\n # The dependency-aware artifact staging and retrieval services.\n \n \n-def _queue_iter(queue, end_token):\n-  while True:\n-    item = queue.get()\n-    if item is end_token:\n-      break\n-    yield item\n+class _QueueIter(object):\n+\n+  _END = object()\n+\n+  def __init__(self):\n+    self._queue = queue.Queue()\n+\n+  def put(self, item):\n+    self._queue.put(item)\n+\n+  def done(self):\n+    self._queue.put(self._END)\n+    self._queue.put(StopIteration)\n+\n+  def abort(self, exn=None):\n+    if exn is None:\n+      exn = sys.exc_info()[1]\n+    self._queue.put(self._END)\n+    self._queue.put(exn)\n+\n+  def __iter__(self):\n+    return self\n+\n+  def __next__(self):\n+    item = self._queue.get()", "originalCommit": "baba007204286dc35f84d44e4302b366e82355eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b6f2db53f834b50b2554dbde6bd627c417c9ac6e", "url": "https://github.com/apache/beam/commit/b6f2db53f834b50b2554dbde6bd627c417c9ac6e", "message": "[BEAM-9577] Rename the Artifact{Staging,Retrieval}Service.\n\nThis is to allow for the new dependency-aware one to be put into place.\n\nArtifactRetrievalService -> LegacyArtifactRetrievalService\nArtifactStagingService -> LegacyArtifactStagingService\nGetArtifactRequest -> LegacyGetArtifactRequest", "committedDate": "2020-03-31T06:06:51Z", "type": "commit"}, {"oid": "4c25de620fdafb2e1e0040e8693890cdc51886da", "url": "https://github.com/apache/beam/commit/4c25de620fdafb2e1e0040e8693890cdc51886da", "message": "[BEAM-9577] Define the new Artifact{Staging,Retrieval}Service.\n\nImplemented as a new service for cleanliness.  It can be served off the same port.", "committedDate": "2020-03-31T06:06:52Z", "type": "commit"}, {"oid": "f2a58b4ee905fcff37632b9417c229cbf40e9639", "url": "https://github.com/apache/beam/commit/f2a58b4ee905fcff37632b9417c229cbf40e9639", "message": "[BEAM-9577] Regenerate protos.", "committedDate": "2020-03-31T06:06:52Z", "type": "commit"}, {"oid": "9eef9b5fe1d794953c740fa571d33b7df178f600", "url": "https://github.com/apache/beam/commit/9eef9b5fe1d794953c740fa571d33b7df178f600", "message": "[BEAM-9577] Implement the new Artifact{Staging,Retrieval}Services in Python.\n\nThis is not yet used.", "committedDate": "2020-03-31T06:06:53Z", "type": "forcePushed"}, {"oid": "b2ad0f93ad2e70a35fa529ffe41094b9c6cf29f6", "url": "https://github.com/apache/beam/commit/b2ad0f93ad2e70a35fa529ffe41094b9c6cf29f6", "message": "[BEAM-9577] Implement the new Artifact{Staging,Retrieval}Services in Python.\n\nThis is not yet used.", "committedDate": "2020-03-31T16:48:23Z", "type": "commit"}, {"oid": "b2ad0f93ad2e70a35fa529ffe41094b9c6cf29f6", "url": "https://github.com/apache/beam/commit/b2ad0f93ad2e70a35fa529ffe41094b9c6cf29f6", "message": "[BEAM-9577] Implement the new Artifact{Staging,Retrieval}Services in Python.\n\nThis is not yet used.", "committedDate": "2020-03-31T16:48:23Z", "type": "forcePushed"}]}