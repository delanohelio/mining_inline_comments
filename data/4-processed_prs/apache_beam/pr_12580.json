{"pr_number": 12580, "pr_title": "[BEAM-2855] nexmark python suite implement implement query 3, 4, 5, 6, 7, 8, 11", "pr_createdAt": "2020-08-14T01:25:07Z", "pr_url": "https://github.com/apache/beam/pull/12580", "timeline": [{"oid": "3085e4a1eb6b6ebcd59a5250bcde3280bfb2a24d", "url": "https://github.com/apache/beam/commit/3085e4a1eb6b6ebcd59a5250bcde3280bfb2a24d", "message": "implement query 3, 4, 5, 6, 7, 8, 11", "committedDate": "2020-08-14T01:19:20Z", "type": "commit"}, {"oid": "4a67c7bbaf85add9d52c5f0416ea7fae536b588d", "url": "https://github.com/apache/beam/commit/4a67c7bbaf85add9d52c5f0416ea7fae536b588d", "message": "forgot to run pylint2_3", "committedDate": "2020-08-14T02:08:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM4NzA2OA==", "url": "https://github.com/apache/beam/pull/12580#discussion_r470387068", "bodyText": "The module document should be more explanatory.", "author": "y1chi", "createdAt": "2020-08-14T03:18:43Z", "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/models/auction_count.py", "diffHunk": "@@ -0,0 +1,56 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Result of Query5.\"\"\"", "originalCommit": "4a67c7bbaf85add9d52c5f0416ea7fae536b588d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM4NzI2Mw==", "url": "https://github.com/apache/beam/pull/12580#discussion_r470387263", "bodyText": "ditto", "author": "y1chi", "createdAt": "2020-08-14T03:19:27Z", "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/models/bids_per_session.py", "diffHunk": "@@ -0,0 +1,56 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Result of Query11 and 12.\"\"\"", "originalCommit": "4a67c7bbaf85add9d52c5f0416ea7fae536b588d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM4ODE5MQ==", "url": "https://github.com/apache/beam/pull/12580#discussion_r470388191", "bodyText": "Does every result class need a coder? What are the coder used for?", "author": "y1chi", "createdAt": "2020-08-14T03:23:12Z", "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/models/bids_per_session.py", "diffHunk": "@@ -0,0 +1,56 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Result of Query11 and 12.\"\"\"\n+from __future__ import absolute_import\n+\n+from apache_beam.coders import coder_impl\n+from apache_beam.coders.coders import FastCoder\n+from apache_beam.testing.benchmarks.nexmark import nexmark_util\n+\n+\n+class BidsPerSessionCoder(FastCoder):", "originalCommit": "4a67c7bbaf85add9d52c5f0416ea7fae536b588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQzMTQ1Nw==", "url": "https://github.com/apache/beam/pull/12580#discussion_r470431457", "bodyText": "I'm actually not sure, we need coder for the 3 models. As for the results, IIRC according to the documentation, beam will try to infer coders if no coder is registered. I am not sure how exactly that works and if the inferred coder works well on all runners.\nSo far I forgot to register coders for some of the result models and there seems to be no problem on the direct runner. not sure on others though.", "author": "leiyiz", "createdAt": "2020-08-14T06:19:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM4ODE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDcxMDM4Mw==", "url": "https://github.com/apache/beam/pull/12580#discussion_r470710383", "bodyText": "if there is no need to serialize/deserialize the object to bytes and send it over a network channel then the coder is typically not needed. The result classes seem only used to print result and there seem no additional transforms that require further processing of these objects.\nI think we could avoid having these result classes along with their coders, I don't think they add too much value to the pipeline.", "author": "y1chi", "createdAt": "2020-08-14T15:53:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM4ODE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDc1ODIwMw==", "url": "https://github.com/apache/beam/pull/12580#discussion_r470758203", "bodyText": "I think there will be further transforms, at least there is going to be metrics transform after the query is done to collect data and re-stamping the elements for streaming purposes i suppose", "author": "leiyiz", "createdAt": "2020-08-14T17:27:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM4ODE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDc2NzIwNg==", "url": "https://github.com/apache/beam/pull/12580#discussion_r470767206", "bodyText": "can't we use tuple or dict instead? that way the we can infer the coders instead of defining additional ones.", "author": "y1chi", "createdAt": "2020-08-14T17:46:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM4ODE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg1MjY5NA==", "url": "https://github.com/apache/beam/pull/12580#discussion_r470852694", "bodyText": "I think the most reason to use a wrapper is to have a clearer idea of what each field is, and it would provide a less error-prone way to construct than using dict. I think by using dict we would need to define literal name of the fields into variables anyway to prevent making typo errors.", "author": "leiyiz", "createdAt": "2020-08-14T20:33:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM4ODE5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg2ODYxMw==", "url": "https://github.com/apache/beam/pull/12580#discussion_r470868613", "bodyText": "The pipeline is largely static, any typo issue should be resolved after the pipeline is validated once.", "author": "y1chi", "createdAt": "2020-08-14T21:15:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM4ODE5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5MDEyMg==", "url": "https://github.com/apache/beam/pull/12580#discussion_r470390122", "bodyText": "are all the result objects necessary? if it is for validation purpose we should be able to just use a dict and rely on additional script to compare.", "author": "y1chi", "createdAt": "2020-08-14T03:30:56Z", "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/models/auction_count.py", "diffHunk": "@@ -0,0 +1,56 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Result of Query5.\"\"\"\n+from __future__ import absolute_import\n+\n+from apache_beam.coders import coder_impl\n+from apache_beam.coders.coders import FastCoder\n+from apache_beam.testing.benchmarks.nexmark import nexmark_util\n+\n+\n+class AuctionCountCoder(FastCoder):\n+  def _create_impl(self):\n+    return AuctionCountCoderImpl()\n+\n+  def is_deterministic(self):\n+    # type: () -> bool\n+    return True\n+\n+\n+class AuctionCount(object):", "originalCommit": "4a67c7bbaf85add9d52c5f0416ea7fae536b588d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5MTQ2Nw==", "url": "https://github.com/apache/beam/pull/12580#discussion_r470391467", "bodyText": "by default it should be 0 so this is not necessary.", "author": "y1chi", "createdAt": "2020-08-14T03:36:22Z", "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/queries/query3.py", "diffHunk": "@@ -0,0 +1,164 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Query 3, 'Local Item Suggestion'. Who is selling in OR, ID or CA in category\n+10, and for what auction ids? In CQL syntax::\n+\n+  SELECT Istream(P.name, P.city, P.state, A.id)\n+  FROM Auction A [ROWS UNBOUNDED], Person P [ROWS UNBOUNDED]\n+  WHERE A.seller = P.id\n+    AND (P.state = `OR' OR P.state = `ID' OR P.state = `CA')\n+    AND A.category = 10;\n+\n+We'll implement this query to allow 'new auction' events to come before the\n+'new person' events for the auction seller. Those auctions will be stored until\n+the matching person is seen. Then all subsequent auctions for a person will use\n+the stored person record.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import logging\n+\n+import apache_beam as beam\n+from apache_beam.coders import coders\n+from apache_beam.testing.benchmarks.nexmark.models import name_city_state_id\n+from apache_beam.testing.benchmarks.nexmark.models import nexmark_model\n+from apache_beam.testing.benchmarks.nexmark.queries import nexmark_query_util\n+from apache_beam.transforms import trigger\n+from apache_beam.transforms import userstate\n+from apache_beam.transforms import window\n+from apache_beam.transforms.userstate import on_timer\n+from apache_beam.utils.timestamp import Duration\n+\n+\n+def load(events, metadata=None):\n+  num_events_in_pane = 30\n+  windowed_events = (\n+      events\n+      | beam.WindowInto(\n+          window.GlobalWindows(),\n+          trigger=trigger.Repeatedly(trigger.AfterCount(num_events_in_pane)),\n+          accumulation_mode=trigger.AccumulationMode.DISCARDING,\n+          allowed_lateness=Duration.of(0)))", "originalCommit": "4a67c7bbaf85add9d52c5f0416ea7fae536b588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQ1MzE0OQ==", "url": "https://github.com/apache/beam/pull/12580#discussion_r470453149", "bodyText": "Done.", "author": "leiyiz", "createdAt": "2020-08-14T07:19:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5MTQ2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5Mjc2Nw==", "url": "https://github.com/apache/beam/pull/12580#discussion_r470392767", "bodyText": "Should this be a BagUserState instead, generally it's better to use BagUserState for iterables.", "author": "y1chi", "createdAt": "2020-08-14T03:42:16Z", "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/queries/query3.py", "diffHunk": "@@ -0,0 +1,164 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Query 3, 'Local Item Suggestion'. Who is selling in OR, ID or CA in category\n+10, and for what auction ids? In CQL syntax::\n+\n+  SELECT Istream(P.name, P.city, P.state, A.id)\n+  FROM Auction A [ROWS UNBOUNDED], Person P [ROWS UNBOUNDED]\n+  WHERE A.seller = P.id\n+    AND (P.state = `OR' OR P.state = `ID' OR P.state = `CA')\n+    AND A.category = 10;\n+\n+We'll implement this query to allow 'new auction' events to come before the\n+'new person' events for the auction seller. Those auctions will be stored until\n+the matching person is seen. Then all subsequent auctions for a person will use\n+the stored person record.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import logging\n+\n+import apache_beam as beam\n+from apache_beam.coders import coders\n+from apache_beam.testing.benchmarks.nexmark.models import name_city_state_id\n+from apache_beam.testing.benchmarks.nexmark.models import nexmark_model\n+from apache_beam.testing.benchmarks.nexmark.queries import nexmark_query_util\n+from apache_beam.transforms import trigger\n+from apache_beam.transforms import userstate\n+from apache_beam.transforms import window\n+from apache_beam.transforms.userstate import on_timer\n+from apache_beam.utils.timestamp import Duration\n+\n+\n+def load(events, metadata=None):\n+  num_events_in_pane = 30\n+  windowed_events = (\n+      events\n+      | beam.WindowInto(\n+          window.GlobalWindows(),\n+          trigger=trigger.Repeatedly(trigger.AfterCount(num_events_in_pane)),\n+          accumulation_mode=trigger.AccumulationMode.DISCARDING,\n+          allowed_lateness=Duration.of(0)))\n+  auction_by_seller_id = (\n+      windowed_events\n+      | nexmark_query_util.JustAuctions()\n+      | 'query3_filter_category' >> beam.Filter(lambda auc: auc.category == 10)\n+      | 'query3_key_by_seller' >> beam.ParDo(\n+          nexmark_query_util.AuctionBySellerFn()))\n+  person_by_id = (\n+      windowed_events\n+      | nexmark_query_util.JustPerson()\n+      | 'query3_filter_region' >> beam.Filter(\n+          lambda person: person.state == 'OR' or person.state == 'ID' or person.\n+          state == 'CA')\n+      | 'query3_key_by_person_id' >> beam.ParDo(\n+          nexmark_query_util.PersonByIdFn()))\n+  return ({\n+      nexmark_query_util.AUCTION_TAG: auction_by_seller_id,\n+      nexmark_query_util.PERSON_TAG: person_by_id,\n+  }\n+          | beam.CoGroupByKey()\n+          | 'query3_join' >> beam.ParDo(\n+              JoinFn(metadata.get('max_auction_waiting_time')))\n+          | 'query3_output' >> beam.Map(\n+              lambda t: name_city_state_id.NameCiyStateId(\n+                  t[1].name, t[1].city, t[1].state, t[0].id)))\n+\n+\n+class JoinFn(beam.DoFn):\n+  \"\"\"\n+  Join auctions and person by person id and emit their product one pair at\n+  a time.\n+\n+  We know a person may submit any number of auctions. Thus new person event\n+  must have the person record stored in persistent state in order to match\n+  future auctions by that person.\n+\n+  However we know that each auction is associated with at most one person, so\n+  only need to store auction records in persistent state until we have seen the\n+  corresponding person record. And of course may have already seen that record.\n+  \"\"\"\n+\n+  AUCTIONS = 'auctions_state'\n+  PERSON = 'person_state'\n+  PERSON_EXPIRING = 'person_state_expiring'\n+\n+  auction_spec = userstate.ReadModifyWriteStateSpec(", "originalCommit": "4a67c7bbaf85add9d52c5f0416ea7fae536b588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQ1Mzc2MA==", "url": "https://github.com/apache/beam/pull/12580#discussion_r470453760", "bodyText": "wouldn't I need to have a for loop to use the add() to add a list of stuff and then would it be slower in that realm", "author": "leiyiz", "createdAt": "2020-08-14T07:21:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5Mjc2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDcxNjU3Mg==", "url": "https://github.com/apache/beam/pull/12580#discussion_r470716572", "bodyText": "not necessarily, ReadModifyWriteState uses BagUserState of size 1 underneath, if you use ReadModifyWriteState the whole list gets serialized/deserialized each time as a single item you make a change, BagUserState allows you to just add the new items.", "author": "y1chi", "createdAt": "2020-08-14T16:05:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5Mjc2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDc3MTQ2Nw==", "url": "https://github.com/apache/beam/pull/12580#discussion_r470771467", "bodyText": "Cool, will do that", "author": "leiyiz", "createdAt": "2020-08-14T17:55:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5Mjc2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5NDQ4Ng==", "url": "https://github.com/apache/beam/pull/12580#discussion_r470394486", "bodyText": "remove this?", "author": "y1chi", "createdAt": "2020-08-14T03:49:28Z", "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/queries/query6.py", "diffHunk": "@@ -0,0 +1,93 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Query 6, 'Average Selling Price by Seller'. Select the average selling price\n+over the last 10 closed auctions by the same seller. In CQL syntax::\n+\n+  SELECT Istream(AVG(Q.final), Q.seller)\n+  FROM (SELECT Rstream(MAX(B.price) AS final, A.seller)\n+    FROM Auction A [ROWS UNBOUNDED], Bid B [ROWS UNBOUNDED]\n+    WHERE A.id=B.auction\n+      AND B.datetime < A.expires AND A.expires < CURRENT_TIME\n+    GROUP BY A.id, A.seller) [PARTITION BY A.seller ROWS 10] Q\n+  GROUP BY Q.seller;\n+\"\"\"\n+\n+from __future__ import absolute_import\n+from __future__ import division\n+\n+import apache_beam as beam\n+from apache_beam.testing.benchmarks.nexmark.models import seller_price\n+from apache_beam.testing.benchmarks.nexmark.queries import nexmark_query_util\n+from apache_beam.testing.benchmarks.nexmark.queries import winning_bids\n+from apache_beam.transforms import trigger\n+from apache_beam.transforms import window\n+\n+\n+def load(events, metadata=None):\n+  # find winning bids for each closed auction\n+  return (\n+      events\n+      # find winning bids\n+      | beam.Filter(nexmark_query_util.auction_or_bid)\n+      | winning_bids.WinningBids()\n+      # (auction_bids -> (aution.seller, bid)\n+      | beam.Map(lambda auc_bid: (auc_bid.auction.seller, auc_bid.bid))\n+      # calculate and output mean as data arrives\n+      | beam.WindowInto(\n+          window.GlobalWindows(),\n+          trigger=trigger.Repeatedly(trigger.AfterCount(1)),\n+          accumulation_mode=trigger.AccumulationMode.ACCUMULATING,\n+          allowed_lateness=0)\n+      # | beam.combiners.Count.Globally())", "originalCommit": "4a67c7bbaf85add9d52c5f0416ea7fae536b588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQ1MzE5MA==", "url": "https://github.com/apache/beam/pull/12580#discussion_r470453190", "bodyText": "Done", "author": "leiyiz", "createdAt": "2020-08-14T07:19:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5NDQ4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5NDkyMw==", "url": "https://github.com/apache/beam/pull/12580#discussion_r470394923", "bodyText": "should this be a while loop?", "author": "y1chi", "createdAt": "2020-08-14T03:51:13Z", "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/queries/query6.py", "diffHunk": "@@ -0,0 +1,93 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Query 6, 'Average Selling Price by Seller'. Select the average selling price\n+over the last 10 closed auctions by the same seller. In CQL syntax::\n+\n+  SELECT Istream(AVG(Q.final), Q.seller)\n+  FROM (SELECT Rstream(MAX(B.price) AS final, A.seller)\n+    FROM Auction A [ROWS UNBOUNDED], Bid B [ROWS UNBOUNDED]\n+    WHERE A.id=B.auction\n+      AND B.datetime < A.expires AND A.expires < CURRENT_TIME\n+    GROUP BY A.id, A.seller) [PARTITION BY A.seller ROWS 10] Q\n+  GROUP BY Q.seller;\n+\"\"\"\n+\n+from __future__ import absolute_import\n+from __future__ import division\n+\n+import apache_beam as beam\n+from apache_beam.testing.benchmarks.nexmark.models import seller_price\n+from apache_beam.testing.benchmarks.nexmark.queries import nexmark_query_util\n+from apache_beam.testing.benchmarks.nexmark.queries import winning_bids\n+from apache_beam.transforms import trigger\n+from apache_beam.transforms import window\n+\n+\n+def load(events, metadata=None):\n+  # find winning bids for each closed auction\n+  return (\n+      events\n+      # find winning bids\n+      | beam.Filter(nexmark_query_util.auction_or_bid)\n+      | winning_bids.WinningBids()\n+      # (auction_bids -> (aution.seller, bid)\n+      | beam.Map(lambda auc_bid: (auc_bid.auction.seller, auc_bid.bid))\n+      # calculate and output mean as data arrives\n+      | beam.WindowInto(\n+          window.GlobalWindows(),\n+          trigger=trigger.Repeatedly(trigger.AfterCount(1)),\n+          accumulation_mode=trigger.AccumulationMode.ACCUMULATING,\n+          allowed_lateness=0)\n+      # | beam.combiners.Count.Globally())\n+      | beam.CombinePerKey(MovingMeanSellingPriceFn(10))\n+      | beam.Map(lambda t: seller_price.SellerPrice(t[0], t[1])))\n+\n+\n+class MovingMeanSellingPriceFn(beam.CombineFn):\n+  \"\"\"\n+  Combiner to keep track of up to max_num_bids of the most recent wining\n+  bids and calculate their average selling price.\n+  \"\"\"\n+  def __init__(self, max_num_bids):\n+    self.max_num_bids = max_num_bids\n+\n+  def create_accumulator(self):\n+    return []\n+\n+  def add_input(self, accumulator, element):\n+    accumulator.append(element)\n+    new_accu = sorted(accumulator, key=lambda bid: (bid.date_time, bid.price))\n+    if len(new_accu) > self.max_num_bids:", "originalCommit": "4a67c7bbaf85add9d52c5f0416ea7fae536b588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQzNDgxMw==", "url": "https://github.com/apache/beam/pull/12580#discussion_r470434813", "bodyText": "the length of the new_accu should never be larger than max_num_bids by more than 1 because each time 1 input is added, this if statement is checked and oldest element will be dropped starting from the first time it went over, so if would be ok to have if instead of while.\nBut logically it would be while if input is not always size 1.", "author": "leiyiz", "createdAt": "2020-08-14T06:29:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5NDkyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5NTI5NQ==", "url": "https://github.com/apache/beam/pull/12580#discussion_r470395295", "bodyText": "call sum() directly?", "author": "y1chi", "createdAt": "2020-08-14T03:52:52Z", "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/queries/query6.py", "diffHunk": "@@ -0,0 +1,93 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Query 6, 'Average Selling Price by Seller'. Select the average selling price\n+over the last 10 closed auctions by the same seller. In CQL syntax::\n+\n+  SELECT Istream(AVG(Q.final), Q.seller)\n+  FROM (SELECT Rstream(MAX(B.price) AS final, A.seller)\n+    FROM Auction A [ROWS UNBOUNDED], Bid B [ROWS UNBOUNDED]\n+    WHERE A.id=B.auction\n+      AND B.datetime < A.expires AND A.expires < CURRENT_TIME\n+    GROUP BY A.id, A.seller) [PARTITION BY A.seller ROWS 10] Q\n+  GROUP BY Q.seller;\n+\"\"\"\n+\n+from __future__ import absolute_import\n+from __future__ import division\n+\n+import apache_beam as beam\n+from apache_beam.testing.benchmarks.nexmark.models import seller_price\n+from apache_beam.testing.benchmarks.nexmark.queries import nexmark_query_util\n+from apache_beam.testing.benchmarks.nexmark.queries import winning_bids\n+from apache_beam.transforms import trigger\n+from apache_beam.transforms import window\n+\n+\n+def load(events, metadata=None):\n+  # find winning bids for each closed auction\n+  return (\n+      events\n+      # find winning bids\n+      | beam.Filter(nexmark_query_util.auction_or_bid)\n+      | winning_bids.WinningBids()\n+      # (auction_bids -> (aution.seller, bid)\n+      | beam.Map(lambda auc_bid: (auc_bid.auction.seller, auc_bid.bid))\n+      # calculate and output mean as data arrives\n+      | beam.WindowInto(\n+          window.GlobalWindows(),\n+          trigger=trigger.Repeatedly(trigger.AfterCount(1)),\n+          accumulation_mode=trigger.AccumulationMode.ACCUMULATING,\n+          allowed_lateness=0)\n+      # | beam.combiners.Count.Globally())\n+      | beam.CombinePerKey(MovingMeanSellingPriceFn(10))\n+      | beam.Map(lambda t: seller_price.SellerPrice(t[0], t[1])))\n+\n+\n+class MovingMeanSellingPriceFn(beam.CombineFn):\n+  \"\"\"\n+  Combiner to keep track of up to max_num_bids of the most recent wining\n+  bids and calculate their average selling price.\n+  \"\"\"\n+  def __init__(self, max_num_bids):\n+    self.max_num_bids = max_num_bids\n+\n+  def create_accumulator(self):\n+    return []\n+\n+  def add_input(self, accumulator, element):\n+    accumulator.append(element)\n+    new_accu = sorted(accumulator, key=lambda bid: (bid.date_time, bid.price))\n+    if len(new_accu) > self.max_num_bids:\n+      del new_accu[0]\n+    return new_accu\n+\n+  def merge_accumulators(self, accumulators):\n+    new_accu = []\n+    for accumulator in accumulators:\n+      new_accu += accumulator\n+    new_accu.sort(key=lambda bid: (bid.date_time, bid.price))\n+    return new_accu[-10:]\n+\n+  def extract_output(self, accumulator):\n+    if len(accumulator) == 0:\n+      return 0\n+    sum_price = 0\n+    for bid in accumulator:", "originalCommit": "4a67c7bbaf85add9d52c5f0416ea7fae536b588d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQzNjAxNA==", "url": "https://github.com/apache/beam/pull/12580#discussion_r470436014", "bodyText": "do you mean like\nsum(b.price for b in accumulator)", "author": "leiyiz", "createdAt": "2020-08-14T06:33:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5NTI5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDcxNzc2MQ==", "url": "https://github.com/apache/beam/pull/12580#discussion_r470717761", "bodyText": "yeah.", "author": "y1chi", "createdAt": "2020-08-14T16:07:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5NTI5NQ=="}], "type": "inlineReview"}, {"oid": "9aa549faf09689672663feddd91b365f231ec683", "url": "https://github.com/apache/beam/commit/9aa549faf09689672663feddd91b365f231ec683", "message": "using dict instead of object for results of query", "committedDate": "2020-08-17T22:41:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg5Mzc0NA==", "url": "https://github.com/apache/beam/pull/12580#discussion_r471893744", "bodyText": "this can be put in nexmark_query_utils", "author": "y1chi", "createdAt": "2020-08-18T03:34:16Z", "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/models/result_name.py", "diffHunk": "@@ -0,0 +1,35 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\" field names for the final results of queries\n+\"\"\"\n+\n+\n+class ResultNames:", "originalCommit": "9aa549faf09689672663feddd91b365f231ec683", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg5NDk4NA==", "url": "https://github.com/apache/beam/pull/12580#discussion_r471894984", "bodyText": "nit: person.state in ['OR', 'ID', 'CA']", "author": "y1chi", "createdAt": "2020-08-18T03:39:30Z", "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/queries/query3.py", "diffHunk": "@@ -0,0 +1,160 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Query 3, 'Local Item Suggestion'. Who is selling in OR, ID or CA in category\n+10, and for what auction ids? In CQL syntax::\n+\n+  SELECT Istream(P.name, P.city, P.state, A.id)\n+  FROM Auction A [ROWS UNBOUNDED], Person P [ROWS UNBOUNDED]\n+  WHERE A.seller = P.id\n+    AND (P.state = `OR' OR P.state = `ID' OR P.state = `CA')\n+    AND A.category = 10;\n+\n+We'll implement this query to allow 'new auction' events to come before the\n+'new person' events for the auction seller. Those auctions will be stored until\n+the matching person is seen. Then all subsequent auctions for a person will use\n+the stored person record.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import logging\n+\n+import apache_beam as beam\n+from apache_beam.testing.benchmarks.nexmark.models import nexmark_model\n+from apache_beam.testing.benchmarks.nexmark.models.result_name import ResultNames\n+from apache_beam.testing.benchmarks.nexmark.queries import nexmark_query_util\n+from apache_beam.transforms import trigger\n+from apache_beam.transforms import userstate\n+from apache_beam.transforms import window\n+from apache_beam.transforms.userstate import on_timer\n+\n+\n+def load(events, metadata=None):\n+  num_events_in_pane = 30\n+  windowed_events = (\n+      events\n+      | beam.WindowInto(\n+          window.GlobalWindows(),\n+          trigger=trigger.Repeatedly(trigger.AfterCount(num_events_in_pane)),\n+          accumulation_mode=trigger.AccumulationMode.DISCARDING))\n+  auction_by_seller_id = (\n+      windowed_events\n+      | nexmark_query_util.JustAuctions()\n+      | 'query3_filter_category' >> beam.Filter(lambda auc: auc.category == 10)\n+      | 'query3_key_by_seller' >> beam.ParDo(\n+          nexmark_query_util.AuctionBySellerFn()))\n+  person_by_id = (\n+      windowed_events\n+      | nexmark_query_util.JustPerson()\n+      | 'query3_filter_region' >> beam.Filter(\n+          lambda person: person.state == 'OR' or person.state == 'ID' or person.", "originalCommit": "9aa549faf09689672663feddd91b365f231ec683", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg5NTkwNw==", "url": "https://github.com/apache/beam/pull/12580#discussion_r471895907", "bodyText": "fanout has bug -> fanout with sliding window produces duplicated results.", "author": "y1chi", "createdAt": "2020-08-18T03:43:40Z", "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/queries/query4.py", "diffHunk": "@@ -0,0 +1,80 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Query 4, 'Average Price for a Category'. Select the average of the wining bid\n+prices for all closed auctions in each category. In CQL syntax::\n+\n+  SELECT Istream(AVG(Q.final))\n+  FROM Category C, (SELECT Rstream(MAX(B.price) AS final, A.category)\n+    FROM Auction A [ROWS UNBOUNDED], Bid B [ROWS UNBOUNDED]\n+    WHERE A.id=B.auction\n+      AND B.datetime < A.expires AND A.expires < CURRENT_TIME\n+    GROUP BY A.id, A.category) Q\n+  WHERE Q.category = C.id\n+  GROUP BY C.id;\n+\n+For extra spiciness our implementation differs slightly from the above:\n+\n+* We select both the average winning price and the category.\n+* We don't bother joining with a static category table, since it's\n+  contents are never used.\n+* We only consider bids which are above the auction's reserve price.\n+* We accept the highest-price, earliest valid bid as the winner.\n+* We calculate the averages oven a sliding window of size\n+  window_size_sec and period window_period_sec.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import apache_beam as beam\n+from apache_beam.testing.benchmarks.nexmark.models.result_name import ResultNames\n+from apache_beam.testing.benchmarks.nexmark.queries import nexmark_query_util\n+from apache_beam.testing.benchmarks.nexmark.queries import winning_bids\n+from apache_beam.transforms import window\n+\n+\n+def load(events, metadata=None):\n+  # find winning bids for each closed auction\n+  all_winning_bids = (\n+      events\n+      | beam.Filter(nexmark_query_util.auction_or_bid)\n+      | winning_bids.WinningBids())\n+  return (\n+      all_winning_bids\n+      # key winning bids by auction category\n+      | beam.Map(lambda auc_bid: (auc_bid.auction.category, auc_bid.bid.price))\n+      # re-window for sliding average\n+      | beam.WindowInto(\n+          window.SlidingWindows(\n+              metadata.get('window_size_sec'),\n+              metadata.get('window_period_sec')))\n+      # average for each category\n+      | beam.CombinePerKey(beam.combiners.MeanCombineFn())\n+      # TODO(leiyiz): fanout has bug, uncomment after it is fixed [BEAM-10617]", "originalCommit": "9aa549faf09689672663feddd91b365f231ec683", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg5NzczMQ==", "url": "https://github.com/apache/beam/pull/12580#discussion_r471897731", "bodyText": "'repr' seems redundant", "author": "y1chi", "createdAt": "2020-08-18T03:51:04Z", "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/queries/query3.py", "diffHunk": "@@ -0,0 +1,160 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Query 3, 'Local Item Suggestion'. Who is selling in OR, ID or CA in category\n+10, and for what auction ids? In CQL syntax::\n+\n+  SELECT Istream(P.name, P.city, P.state, A.id)\n+  FROM Auction A [ROWS UNBOUNDED], Person P [ROWS UNBOUNDED]\n+  WHERE A.seller = P.id\n+    AND (P.state = `OR' OR P.state = `ID' OR P.state = `CA')\n+    AND A.category = 10;\n+\n+We'll implement this query to allow 'new auction' events to come before the\n+'new person' events for the auction seller. Those auctions will be stored until\n+the matching person is seen. Then all subsequent auctions for a person will use\n+the stored person record.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import logging\n+\n+import apache_beam as beam\n+from apache_beam.testing.benchmarks.nexmark.models import nexmark_model\n+from apache_beam.testing.benchmarks.nexmark.models.result_name import ResultNames\n+from apache_beam.testing.benchmarks.nexmark.queries import nexmark_query_util\n+from apache_beam.transforms import trigger\n+from apache_beam.transforms import userstate\n+from apache_beam.transforms import window\n+from apache_beam.transforms.userstate import on_timer\n+\n+\n+def load(events, metadata=None):\n+  num_events_in_pane = 30\n+  windowed_events = (\n+      events\n+      | beam.WindowInto(\n+          window.GlobalWindows(),\n+          trigger=trigger.Repeatedly(trigger.AfterCount(num_events_in_pane)),\n+          accumulation_mode=trigger.AccumulationMode.DISCARDING))\n+  auction_by_seller_id = (\n+      windowed_events\n+      | nexmark_query_util.JustAuctions()\n+      | 'query3_filter_category' >> beam.Filter(lambda auc: auc.category == 10)\n+      | 'query3_key_by_seller' >> beam.ParDo(\n+          nexmark_query_util.AuctionBySellerFn()))\n+  person_by_id = (\n+      windowed_events\n+      | nexmark_query_util.JustPerson()\n+      | 'query3_filter_region' >> beam.Filter(\n+          lambda person: person.state == 'OR' or person.state == 'ID' or person.\n+          state == 'CA')\n+      | 'query3_key_by_person_id' >> beam.ParDo(\n+          nexmark_query_util.PersonByIdFn()))\n+  return ({\n+      nexmark_query_util.AUCTION_TAG: auction_by_seller_id,\n+      nexmark_query_util.PERSON_TAG: person_by_id,\n+  }\n+          | beam.CoGroupByKey()\n+          | 'query3_join' >> beam.ParDo(\n+              JoinFn(metadata.get('max_auction_waiting_time')))\n+          | 'query3_output' >> beam.Map(\n+              lambda t: {\n+                  ResultNames.NAME: t[1].name,\n+                  ResultNames.CITY: t[1].city,\n+                  ResultNames.STATE: t[1].state,\n+                  ResultNames.AUCTION_ID: t[0].id\n+              }))\n+\n+\n+class JoinFn(beam.DoFn):\n+  \"\"\"\n+  Join auctions and person by person id and emit their product one pair at\n+  a time.\n+\n+  We know a person may submit any number of auctions. Thus new person event\n+  must have the person record stored in persistent state in order to match\n+  future auctions by that person.\n+\n+  However we know that each auction is associated with at most one person, so\n+  only need to store auction records in persistent state until we have seen the\n+  corresponding person record. And of course may have already seen that record.\n+  \"\"\"\n+\n+  AUCTIONS = 'auctions_state'\n+  PERSON = 'person_state'\n+  PERSON_EXPIRING = 'person_state_expiring'\n+\n+  auction_spec = userstate.BagStateSpec(AUCTIONS, nexmark_model.Auction.CODER)\n+  person_spec = userstate.ReadModifyWriteStateSpec(\n+      PERSON, nexmark_model.Person.CODER)\n+  person_timer_spec = userstate.TimerSpec(\n+      PERSON_EXPIRING, userstate.TimeDomain.WATERMARK)\n+\n+  def __init__(self, max_auction_wait_time):\n+    self.max_auction_wait_time = max_auction_wait_time\n+\n+  def process(\n+      self,\n+      element,\n+      auction_state=beam.DoFn.StateParam(auction_spec),\n+      person_state=beam.DoFn.StateParam(person_spec),\n+      person_timer=beam.DoFn.TimerParam(person_timer_spec)):\n+    # extract group with tags from element tuple\n+    _, group = element\n+\n+    existing_person = person_state.read()\n+    if existing_person:\n+      # the person exists in person_state for this person id\n+      for auction in group[nexmark_query_util.AUCTION_TAG]:\n+        yield auction, existing_person\n+      return\n+\n+    new_person = None\n+    for person in group[nexmark_query_util.PERSON_TAG]:\n+      if not new_person:\n+        new_person = person\n+      else:\n+        logging.error(\n+            'two new person wtih same key: %s and %s' %\n+            (repr(person), repr(new_person)))", "originalCommit": "9aa549faf09689672663feddd91b365f231ec683", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM1ODc0NA==", "url": "https://github.com/apache/beam/pull/12580#discussion_r472358744", "bodyText": "the person and new person here are actual person objects so I think we need to call repr to convert them to string", "author": "leiyiz", "createdAt": "2020-08-18T17:20:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg5NzczMQ=="}], "type": "inlineReview"}, {"oid": "f972b520c825d95e750801d8e3985834d17eef70", "url": "https://github.com/apache/beam/commit/f972b520c825d95e750801d8e3985834d17eef70", "message": "added to_type_hint for coders, fixed issues brought up in code review", "committedDate": "2020-08-20T00:03:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQxMTE5OA==", "url": "https://github.com/apache/beam/pull/12580#discussion_r474411198", "bodyText": "maybe remove this TODO", "author": "pabloem", "createdAt": "2020-08-21T05:07:56Z", "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/nexmark_launcher.py", "diffHunk": "@@ -242,12 +249,28 @@ def run(self):\n     queries = {\n         0: query0,\n         1: query1,\n-        2: query2,  # TODO(mariagh): Add more queries.\n-        9: query9\n+        2: query2,\n+        3: query3,\n+        4: query4,\n+        5: query5,\n+        6: query6,\n+        7: query7,\n+        8: query8,\n+        9: query9,\n+        11: query11\n     }\n \n     # TODO(mariagh): Move to a config file.", "originalCommit": "f972b520c825d95e750801d8e3985834d17eef70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg2NzEyNQ==", "url": "https://github.com/apache/beam/pull/12580#discussion_r474867125", "bodyText": "I think this TODO is still valid because I think eventually we do want to move to a more configurable future?", "author": "leiyiz", "createdAt": "2020-08-21T18:46:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQxMTE5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQxMTQxNw==", "url": "https://github.com/apache/beam/pull/12580#discussion_r474411417", "bodyText": "how come we don't have per-query query-args anymore?", "author": "pabloem", "createdAt": "2020-08-21T05:08:55Z", "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/nexmark_launcher.py", "diffHunk": "@@ -262,13 +285,13 @@ def run(self):\n       query_duration = self.pipeline_options.view_as(TestOptions).wait_until_finish_duration  # pylint: disable=line-too-long\n       if launch_from_direct_runner:\n         command = Command(\n-            self.run_query, args=[queries[i], query_args.get(i), query_errors])\n+            self.run_query, args=[queries[i], query_args, query_errors])\n         command.run(timeout=query_duration // 1000)\n       else:\n         try:\n-          self.run_query(queries[i], query_args.get(i), query_errors=None)\n+          self.run_query(queries[i], query_args, query_errors=query_errors)", "originalCommit": "f972b520c825d95e750801d8e3985834d17eef70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg1MzQ0MQ==", "url": "https://github.com/apache/beam/pull/12580#discussion_r474853441", "bodyText": "because a lot of queries actually want the same arg options and because we are doing dict lookup inside the queries anyway due to more than 1 query args, I just removed the per-query args", "author": "leiyiz", "createdAt": "2020-08-21T18:15:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQxMTQxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAxODA4Ng==", "url": "https://github.com/apache/beam/pull/12580#discussion_r475018086", "bodyText": "SGTM!", "author": "pabloem", "createdAt": "2020-08-22T00:11:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQxMTQxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQxOTkwOQ==", "url": "https://github.com/apache/beam/pull/12580#discussion_r474419909", "bodyText": "Is this how this is implemented in Java? I am wondering if we should make bids comparable. If they were comparable, then you would be able to just return max_prices\ne.g.:\n@functools.total_ordering\nclass ComparableBidByPrice(object):\n  def __init__(self, bid):\n    self.bid = bid\n  def __eq__(self, other):\n    return self.bid == other.bid\n  def __lt__(self, other):\n    return self.bid.price < other.bid.price\n\nAnd then you'd do:\n  max_bids = (\n      sliding_bids\n      | beam.Map(ComparableBidByPrice)\n      | beam.CombineGlobally(max).without_defaults())\n\nthoughts? The main thing here is having one fewer stage, thus higher performance - but I think the best option is to do whatever Java does.", "author": "pabloem", "createdAt": "2020-08-21T05:41:58Z", "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/queries/query7.py", "diffHunk": "@@ -0,0 +1,59 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Query 7, 'Highest Bid'. Select the bids with the highest bid price in the\n+last minute. In CQL syntax::\n+\n+  SELECT Rstream(B.auction, B.price, B.bidder)\n+  FROM Bid [RANGE 1 MINUTE SLIDE 1 MINUTE] B\n+  WHERE B.price = (SELECT MAX(B1.price)\n+                   FROM BID [RANGE 1 MINUTE SLIDE 1 MINUTE] B1);\n+\n+We will use a shorter window to help make testing easier. We'll also\n+implement this using a side-input in order to exercise that functionality.\n+(A combiner, as used in Query 5, is a more efficient approach.).\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import apache_beam as beam\n+from apache_beam.testing.benchmarks.nexmark.queries import nexmark_query_util\n+from apache_beam.transforms import window\n+\n+\n+def load(events, metadata=None):\n+  # window bids into fixed window\n+  sliding_bids = (\n+      events\n+      | nexmark_query_util.JustBids()\n+      | beam.WindowInto(window.FixedWindows(metadata.get('window_size_sec'))))\n+  # find the largest price in all bids per window\n+  max_prices = (\n+      sliding_bids\n+      | beam.Map(lambda bid: bid.price)\n+      | beam.CombineGlobally(max).without_defaults())\n+  return (\n+      sliding_bids\n+      | 'select_bids' >> beam.ParDo(\n+          SelectMaxBidFn(), beam.pvalue.AsSingleton(max_prices)))", "originalCommit": "f972b520c825d95e750801d8e3985834d17eef70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgyNTAzNw==", "url": "https://github.com/apache/beam/pull/12580#discussion_r474825037", "bodyText": "I think one of the purpose would be to benchmark the performance of side inputs, thus some pipelines are choosing certain beam semantics that may not be the best way.", "author": "y1chi", "createdAt": "2020-08-21T17:14:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQxOTkwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg0MjM4Mw==", "url": "https://github.com/apache/beam/pull/12580#discussion_r474842383", "bodyText": "that's reasonable. Than can you just add a comment @leiyiz ?", "author": "pabloem", "createdAt": "2020-08-21T17:51:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQxOTkwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg1Mzk0NA==", "url": "https://github.com/apache/beam/pull/12580#discussion_r474853944", "bodyText": "Yeah, I read the code and the reason to not use combiner, which is more efficient, is to utilize the side-input functionality", "author": "leiyiz", "createdAt": "2020-08-21T18:16:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQxOTkwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAxODY1Nw==", "url": "https://github.com/apache/beam/pull/12580#discussion_r475018657", "bodyText": "can you add a comment on the file in a follow up PR please?", "author": "pabloem", "createdAt": "2020-08-22T00:14:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQxOTkwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQyMjc0Mg==", "url": "https://github.com/apache/beam/pull/12580#discussion_r474422742", "bodyText": "Deleting from the begining of a Python list is very slow (as all elements have to be shifted). Should the sorting be opposite and wwe just drop from the end?", "author": "pabloem", "createdAt": "2020-08-21T05:52:02Z", "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/queries/query6.py", "diffHunk": "@@ -0,0 +1,92 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Query 6, 'Average Selling Price by Seller'. Select the average selling price\n+over the last 10 closed auctions by the same seller. In CQL syntax::\n+\n+  SELECT Istream(AVG(Q.final), Q.seller)\n+  FROM (SELECT Rstream(MAX(B.price) AS final, A.seller)\n+    FROM Auction A [ROWS UNBOUNDED], Bid B [ROWS UNBOUNDED]\n+    WHERE A.id=B.auction\n+      AND B.datetime < A.expires AND A.expires < CURRENT_TIME\n+    GROUP BY A.id, A.seller) [PARTITION BY A.seller ROWS 10] Q\n+  GROUP BY Q.seller;\n+\"\"\"\n+\n+from __future__ import absolute_import\n+from __future__ import division\n+\n+import apache_beam as beam\n+from apache_beam.testing.benchmarks.nexmark.queries import nexmark_query_util\n+from apache_beam.testing.benchmarks.nexmark.queries import winning_bids\n+from apache_beam.testing.benchmarks.nexmark.queries.nexmark_query_util import ResultNames\n+from apache_beam.transforms import trigger\n+from apache_beam.transforms import window\n+\n+\n+def load(events, metadata=None):\n+  # find winning bids for each closed auction\n+  return (\n+      events\n+      # find winning bids\n+      | beam.Filter(nexmark_query_util.auction_or_bid)\n+      | winning_bids.WinningBids()\n+      # (auction_bids -> (aution.seller, bid)\n+      | beam.Map(lambda auc_bid: (auc_bid.auction.seller, auc_bid.bid))\n+      # calculate and output mean as data arrives\n+      | beam.WindowInto(\n+          window.GlobalWindows(),\n+          trigger=trigger.Repeatedly(trigger.AfterCount(1)),\n+          accumulation_mode=trigger.AccumulationMode.ACCUMULATING,\n+          allowed_lateness=0)\n+      | beam.CombinePerKey(MovingMeanSellingPriceFn(10))\n+      | beam.Map(lambda t: {\n+          ResultNames.SELLER: t[0], ResultNames.PRICE: t[1]\n+      }))\n+\n+\n+class MovingMeanSellingPriceFn(beam.CombineFn):\n+  \"\"\"\n+  Combiner to keep track of up to max_num_bids of the most recent wining\n+  bids and calculate their average selling price.\n+  \"\"\"\n+  def __init__(self, max_num_bids):\n+    self.max_num_bids = max_num_bids\n+\n+  def create_accumulator(self):\n+    return []\n+\n+  def add_input(self, accumulator, element):\n+    accumulator.append(element)\n+    new_accu = sorted(accumulator, key=lambda bid: (bid.date_time, bid.price))\n+    if len(new_accu) > self.max_num_bids:\n+      del new_accu[0]", "originalCommit": "f972b520c825d95e750801d8e3985834d17eef70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg2NzI4NA==", "url": "https://github.com/apache/beam/pull/12580#discussion_r474867284", "bodyText": "Sure, consider it done", "author": "leiyiz", "createdAt": "2020-08-21T18:46:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQyMjc0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQyMzMzMw==", "url": "https://github.com/apache/beam/pull/12580#discussion_r474423333", "bodyText": "This trigger is a little hard to wrap my head around : ) can you help me understand it? So I guess we simply accumulate fired panes and fire everything every time? (let's say that the stream contains a new element every second. Would we fire 1000 elements after 1000 seconds?)", "author": "pabloem", "createdAt": "2020-08-21T05:54:14Z", "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/queries/query6.py", "diffHunk": "@@ -0,0 +1,92 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Query 6, 'Average Selling Price by Seller'. Select the average selling price\n+over the last 10 closed auctions by the same seller. In CQL syntax::\n+\n+  SELECT Istream(AVG(Q.final), Q.seller)\n+  FROM (SELECT Rstream(MAX(B.price) AS final, A.seller)\n+    FROM Auction A [ROWS UNBOUNDED], Bid B [ROWS UNBOUNDED]\n+    WHERE A.id=B.auction\n+      AND B.datetime < A.expires AND A.expires < CURRENT_TIME\n+    GROUP BY A.id, A.seller) [PARTITION BY A.seller ROWS 10] Q\n+  GROUP BY Q.seller;\n+\"\"\"\n+\n+from __future__ import absolute_import\n+from __future__ import division\n+\n+import apache_beam as beam\n+from apache_beam.testing.benchmarks.nexmark.queries import nexmark_query_util\n+from apache_beam.testing.benchmarks.nexmark.queries import winning_bids\n+from apache_beam.testing.benchmarks.nexmark.queries.nexmark_query_util import ResultNames\n+from apache_beam.transforms import trigger\n+from apache_beam.transforms import window\n+\n+\n+def load(events, metadata=None):\n+  # find winning bids for each closed auction\n+  return (\n+      events\n+      # find winning bids\n+      | beam.Filter(nexmark_query_util.auction_or_bid)\n+      | winning_bids.WinningBids()\n+      # (auction_bids -> (aution.seller, bid)\n+      | beam.Map(lambda auc_bid: (auc_bid.auction.seller, auc_bid.bid))\n+      # calculate and output mean as data arrives\n+      | beam.WindowInto(\n+          window.GlobalWindows(),\n+          trigger=trigger.Repeatedly(trigger.AfterCount(1)),\n+          accumulation_mode=trigger.AccumulationMode.ACCUMULATING,\n+          allowed_lateness=0)", "originalCommit": "f972b520c825d95e750801d8e3985834d17eef70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg1Njk0Mg==", "url": "https://github.com/apache/beam/pull/12580#discussion_r474856942", "bodyText": "yes, so every time an event arrives, it should fire and calculate", "author": "leiyiz", "createdAt": "2020-08-21T18:22:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQyMzMzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg1NzMwNA==", "url": "https://github.com/apache/beam/pull/12580#discussion_r474857304", "bodyText": "because it is calculating the mean, every time something arrives it calculates the mean 1 more time", "author": "leiyiz", "createdAt": "2020-08-21T18:23:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQyMzMzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQyMzkzNQ==", "url": "https://github.com/apache/beam/pull/12580#discussion_r474423935", "bodyText": "why do we also return whether this is the last pane in a window?", "author": "pabloem", "createdAt": "2020-08-21T05:56:23Z", "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/queries/query4.py", "diffHunk": "@@ -0,0 +1,81 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Query 4, 'Average Price for a Category'. Select the average of the wining bid\n+prices for all closed auctions in each category. In CQL syntax::\n+\n+  SELECT Istream(AVG(Q.final))\n+  FROM Category C, (SELECT Rstream(MAX(B.price) AS final, A.category)\n+    FROM Auction A [ROWS UNBOUNDED], Bid B [ROWS UNBOUNDED]\n+    WHERE A.id=B.auction\n+      AND B.datetime < A.expires AND A.expires < CURRENT_TIME\n+    GROUP BY A.id, A.category) Q\n+  WHERE Q.category = C.id\n+  GROUP BY C.id;\n+\n+For extra spiciness our implementation differs slightly from the above:\n+\n+* We select both the average winning price and the category.\n+* We don't bother joining with a static category table, since it's\n+  contents are never used.\n+* We only consider bids which are above the auction's reserve price.\n+* We accept the highest-price, earliest valid bid as the winner.\n+* We calculate the averages oven a sliding window of size\n+  window_size_sec and period window_period_sec.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import apache_beam as beam\n+from apache_beam.testing.benchmarks.nexmark.queries import nexmark_query_util\n+from apache_beam.testing.benchmarks.nexmark.queries import winning_bids\n+from apache_beam.testing.benchmarks.nexmark.queries.nexmark_query_util import ResultNames\n+from apache_beam.transforms import window\n+\n+\n+def load(events, metadata=None):\n+  # find winning bids for each closed auction\n+  all_winning_bids = (\n+      events\n+      | beam.Filter(nexmark_query_util.auction_or_bid)\n+      | winning_bids.WinningBids())\n+  return (\n+      all_winning_bids\n+      # key winning bids by auction category\n+      | beam.Map(lambda auc_bid: (auc_bid.auction.category, auc_bid.bid.price))\n+      # re-window for sliding average\n+      | beam.WindowInto(\n+          window.SlidingWindows(\n+              metadata.get('window_size_sec'),\n+              metadata.get('window_period_sec')))\n+      # average for each category\n+      | beam.CombinePerKey(beam.combiners.MeanCombineFn())\n+      # TODO(leiyiz): fanout with sliding window produces duplicated results,\n+      #   uncomment after it is fixed [BEAM-10617]\n+      # .with_hot_key_fanout(metadata.get('fanout'))\n+      # produce output\n+      | beam.ParDo(ProjectToCategoryPriceFn()))\n+\n+\n+class ProjectToCategoryPriceFn(beam.DoFn):\n+  def process(self, element, pane_info=beam.DoFn.PaneInfoParam):\n+    yield {\n+        ResultNames.CATEGORY: element[0],\n+        ResultNames.PRICE: element[1],\n+        ResultNames.IS_LAST: pane_info.is_last", "originalCommit": "f972b520c825d95e750801d8e3985834d17eef70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg0MjY0NQ==", "url": "https://github.com/apache/beam/pull/12580#discussion_r474842645", "bodyText": "(not a big deal. I'm just curious.)", "author": "pabloem", "createdAt": "2020-08-21T17:51:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQyMzkzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg1OTE2Mg==", "url": "https://github.com/apache/beam/pull/12580#discussion_r474859162", "bodyText": "I had the question also, the is_last is not in the nexmark spec but put in there by java nexmark. I just think it is also used to utilize the pane is_last function.", "author": "leiyiz", "createdAt": "2020-08-21T18:28:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQyMzkzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAxODM1OA==", "url": "https://github.com/apache/beam/pull/12580#discussion_r475018358", "bodyText": "SGTM", "author": "pabloem", "createdAt": "2020-08-22T00:12:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQyMzkzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQyNTk0OA==", "url": "https://github.com/apache/beam/pull/12580#discussion_r474425948", "bodyText": "Can it happen that the same person creates new auctions after > max_auction_waiting_time ? Will there be a new person event? If we get new auctions after the person is expired, then we'll just keep adding them to auction_state forevetr, no?", "author": "pabloem", "createdAt": "2020-08-21T06:03:23Z", "path": "sdks/python/apache_beam/testing/benchmarks/nexmark/queries/query3.py", "diffHunk": "@@ -0,0 +1,158 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Query 3, 'Local Item Suggestion'. Who is selling in OR, ID or CA in category\n+10, and for what auction ids? In CQL syntax::\n+\n+  SELECT Istream(P.name, P.city, P.state, A.id)\n+  FROM Auction A [ROWS UNBOUNDED], Person P [ROWS UNBOUNDED]\n+  WHERE A.seller = P.id\n+    AND (P.state = `OR' OR P.state = `ID' OR P.state = `CA')\n+    AND A.category = 10;\n+\n+We'll implement this query to allow 'new auction' events to come before the\n+'new person' events for the auction seller. Those auctions will be stored until\n+the matching person is seen. Then all subsequent auctions for a person will use\n+the stored person record.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import logging\n+\n+import apache_beam as beam\n+from apache_beam.testing.benchmarks.nexmark.models import nexmark_model\n+from apache_beam.testing.benchmarks.nexmark.queries import nexmark_query_util\n+from apache_beam.testing.benchmarks.nexmark.queries.nexmark_query_util import ResultNames\n+from apache_beam.transforms import trigger\n+from apache_beam.transforms import userstate\n+from apache_beam.transforms import window\n+from apache_beam.transforms.userstate import on_timer\n+\n+\n+def load(events, metadata=None):\n+  num_events_in_pane = 30\n+  windowed_events = (\n+      events\n+      | beam.WindowInto(\n+          window.GlobalWindows(),\n+          trigger=trigger.Repeatedly(trigger.AfterCount(num_events_in_pane)),\n+          accumulation_mode=trigger.AccumulationMode.DISCARDING))\n+  auction_by_seller_id = (\n+      windowed_events\n+      | nexmark_query_util.JustAuctions()\n+      | 'query3_filter_category' >> beam.Filter(lambda auc: auc.category == 10)\n+      | 'query3_key_by_seller' >> beam.ParDo(\n+          nexmark_query_util.AuctionBySellerFn()))\n+  person_by_id = (\n+      windowed_events\n+      | nexmark_query_util.JustPerson()\n+      | 'query3_filter_region' >>\n+      beam.Filter(lambda person: person.state in ['OR', 'ID', 'CA'])\n+      | 'query3_key_by_person_id' >> beam.ParDo(\n+          nexmark_query_util.PersonByIdFn()))\n+  return ({\n+      nexmark_query_util.AUCTION_TAG: auction_by_seller_id,\n+      nexmark_query_util.PERSON_TAG: person_by_id,\n+  }\n+          | beam.CoGroupByKey()\n+          | 'query3_join' >> beam.ParDo(\n+              JoinFn(metadata.get('max_auction_waiting_time')))\n+          | 'query3_output' >> beam.Map(\n+              lambda t: {\n+                  ResultNames.NAME: t[1].name,\n+                  ResultNames.CITY: t[1].city,\n+                  ResultNames.STATE: t[1].state,\n+                  ResultNames.AUCTION_ID: t[0].id\n+              }))\n+\n+\n+class JoinFn(beam.DoFn):\n+  \"\"\"\n+  Join auctions and person by person id and emit their product one pair at\n+  a time.\n+\n+  We know a person may submit any number of auctions. Thus new person event\n+  must have the person record stored in persistent state in order to match\n+  future auctions by that person.\n+\n+  However we know that each auction is associated with at most one person, so\n+  only need to store auction records in persistent state until we have seen the\n+  corresponding person record. And of course may have already seen that record.\n+  \"\"\"\n+\n+  AUCTIONS = 'auctions_state'\n+  PERSON = 'person_state'\n+  PERSON_EXPIRING = 'person_state_expiring'\n+\n+  auction_spec = userstate.BagStateSpec(AUCTIONS, nexmark_model.Auction.CODER)\n+  person_spec = userstate.ReadModifyWriteStateSpec(\n+      PERSON, nexmark_model.Person.CODER)\n+  person_timer_spec = userstate.TimerSpec(\n+      PERSON_EXPIRING, userstate.TimeDomain.WATERMARK)\n+\n+  def __init__(self, max_auction_wait_time):\n+    self.max_auction_wait_time = max_auction_wait_time\n+\n+  def process(\n+      self,\n+      element,\n+      auction_state=beam.DoFn.StateParam(auction_spec),\n+      person_state=beam.DoFn.StateParam(person_spec),\n+      person_timer=beam.DoFn.TimerParam(person_timer_spec)):\n+    # extract group with tags from element tuple\n+    _, group = element\n+\n+    existing_person = person_state.read()\n+    if existing_person:\n+      # the person exists in person_state for this person id\n+      for auction in group[nexmark_query_util.AUCTION_TAG]:\n+        yield auction, existing_person\n+      return\n+\n+    new_person = None\n+    for person in group[nexmark_query_util.PERSON_TAG]:\n+      if not new_person:\n+        new_person = person\n+      else:\n+        logging.error(\n+            'two new person wtih same key: %s and %s' % (person, new_person))\n+        continue\n+      # read all pending auctions for this person id, output and flush it\n+      pending_auctions = auction_state.read()\n+      if pending_auctions:\n+        for pending_auction in pending_auctions:\n+          yield pending_auction, new_person\n+        auction_state.clear()\n+      # output new auction for this person id\n+      for auction in group[nexmark_query_util.AUCTION_TAG]:\n+        yield auction, new_person\n+      # remember person for max_auction_wait_time seconds for future auctions\n+      person_state.write(new_person)\n+      person_timer.set(new_person.date_time + self.max_auction_wait_time)\n+    # we are done if we have seen a new person\n+    if new_person:\n+      return\n+\n+    # remember auction until we see person\n+    for auction in group[nexmark_query_util.AUCTION_TAG]:\n+      auction_state.add(auction)\n+\n+  @on_timer(person_timer_spec)\n+  def expiry(self, person_state=beam.DoFn.StateParam(person_spec)):\n+    person_state.clear()", "originalCommit": "f972b520c825d95e750801d8e3985834d17eef70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg2MTE4MA==", "url": "https://github.com/apache/beam/pull/12580#discussion_r474861180", "bodyText": "I think it would, then the new auction for person is just added to the state and eventually dropped when the pipeline ends. but it is also specified in the nexmark spec as \"clear the state after TTL\" also the default timer is like 600 seconds long which is way longer than the test duration so I think it is less of a issue?", "author": "leiyiz", "createdAt": "2020-08-21T18:32:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQyNTk0OA=="}], "type": "inlineReview"}, {"oid": "553c0780038b9007796e8598395e825deb17aeed", "url": "https://github.com/apache/beam/commit/553c0780038b9007796e8598395e825deb17aeed", "message": "reversed the sorting to not remove from front of list", "committedDate": "2020-08-21T19:55:34Z", "type": "commit"}]}