{"pr_number": 10757, "pr_title": "[BEAM-9496] Starting implementation of dataframes for Beam", "pr_createdAt": "2020-02-03T23:13:19Z", "pr_url": "https://github.com/apache/beam/pull/10757", "timeline": [{"oid": "9c674e4686d096264696f8f2a9f8ba0f1e6e7858", "url": "https://github.com/apache/beam/commit/9c674e4686d096264696f8f2a9f8ba0f1e6e7858", "message": "Basic deferred data frame implementation.", "committedDate": "2020-02-03T23:15:56Z", "type": "forcePushed"}, {"oid": "c2945b6dcfb67d061be1a4f51639bb1298b0c4a3", "url": "https://github.com/apache/beam/commit/c2945b6dcfb67d061be1a4f51639bb1298b0c4a3", "message": "Supporting infrastructure for dataframes on beam.\n\nBasic expression classes.", "committedDate": "2020-02-10T18:10:51Z", "type": "commit"}, {"oid": "6de32d709717a9b6aa5843fbceed3864b3392a83", "url": "https://github.com/apache/beam/commit/6de32d709717a9b6aa5843fbceed3864b3392a83", "message": "Basic deferred data frame implementation.", "committedDate": "2020-02-10T18:10:51Z", "type": "commit"}, {"oid": "6de32d709717a9b6aa5843fbceed3864b3392a83", "url": "https://github.com/apache/beam/commit/6de32d709717a9b6aa5843fbceed3864b3392a83", "message": "Basic deferred data frame implementation.", "committedDate": "2020-02-10T18:10:51Z", "type": "forcePushed"}, {"oid": "94ed5f155af72b908abeafcf2d7c2d0ec736c4c2", "url": "https://github.com/apache/beam/commit/94ed5f155af72b908abeafcf2d7c2d0ec736c4c2", "message": "yapf, py2", "committedDate": "2020-02-10T20:09:53Z", "type": "commit"}, {"oid": "a0b9c69c5b71417a212c201a01bc7f0bf40ff211", "url": "https://github.com/apache/beam/commit/a0b9c69c5b71417a212c201a01bc7f0bf40ff211", "message": "typings and docs for expressions.py", "committedDate": "2020-02-24T16:29:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU1MzcwNA==", "url": "https://github.com/apache/beam/pull/10757#discussion_r383553704", "bodyText": "These lists could be constants like UNLIFTABLE_AGGREGATIONS and LIFTABLE_AGGREGATIONS (similar for series operations above), to make this more self-documenting.", "author": "TheNeuralBit", "createdAt": "2020-02-24T22:30:42Z", "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -0,0 +1,208 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import pandas as pd\n+\n+from apache_beam.dataframe import expressions\n+from apache_beam.dataframe import frame_base\n+\n+\n+@frame_base.DeferredFrame._register_for(pd.Series)\n+class DeferredSeries(frame_base.DeferredFrame):\n+  pass\n+\n+\n+for base in ['add', 'sub', 'mul', 'div', 'truediv', 'floordiv', 'mod', 'pow']:\n+  for p in ['%s', 'r%s', '__%s__', '__r%s__']:\n+    # TODO: non-trivial level?\n+    name = p % base\n+    setattr(\n+        DeferredSeries,\n+        name,\n+        frame_base._elementwise_method(name, restrictions={'level': None}))\n+  setattr(\n+      DeferredSeries,\n+      '__i%s__' % base,\n+      frame_base._elementwise_method('__i%s__' % base, inplace=True))\n+for name in ['__lt__', '__le__', '__gt__', '__ge__', '__eq__', '__ne__']:\n+  setattr(DeferredSeries, name, frame_base._elementwise_method(name))\n+for name in ['apply', 'map', 'transform']:\n+  setattr(DeferredSeries, name, frame_base._elementwise_method(name))\n+\n+\n+@frame_base.DeferredFrame._register_for(pd.DataFrame)\n+class DeferredDataFrame(frame_base.DeferredFrame):\n+  def groupby(self, cols):\n+    # TODO: what happens to the existing index?\n+    # We set the columns to index as we have a notion of being partitioned by\n+    # index, but not partitioned by an arbitrary subset of columns.\n+    return DeferredGroupBy(\n+        expressions.ComputedExpression(\n+            'groupbyindex',\n+            lambda df: df.groupby(level=list(range(df.index.nlevels))),\n+            [self.set_index(cols)._expr],\n+            requires_partition_by_index=True,\n+            preserves_partition_by_index=True))\n+\n+  def __getattr__(self, name):\n+    # Column attribute access.\n+    if name in self._expr.proxy().columns:\n+      return self[name]\n+    else:\n+      return super(DeferredDataFrame, self).__getattr__(name)\n+\n+  def __getitem__(self, key):\n+    if key in self._expr.proxy().columns:\n+      return self._elementwise(lambda df: df[key], 'get_column')\n+    else:\n+      raise NotImplementedError(key)\n+\n+  def __setitem__(self, key, value):\n+    if isinstance(key, str):\n+      # yapf: disable\n+      return self._elementwise(\n+          lambda df, key, value: df.__setitem__(key, value),\n+          'set_column',\n+          (key, value),\n+          inplace=True)\n+    else:\n+      raise NotImplementedError(key)\n+\n+  def set_index(self, keys, **kwargs):\n+    if isinstance(keys, str):\n+      keys = [keys]\n+    else:\n+      keys = keys\n+    if not set(keys).issubset(self._expr.proxy().columns):\n+      raise NotImplementedError(keys)\n+    return self._elementwise(\n+        lambda df: df.set_index(keys, **kwargs),\n+        'set_index',\n+        inplace=kwargs.get('inplace', False))\n+\n+  def at(self, *args, **kwargs):\n+    raise NotImplementedError()\n+\n+  @property\n+  def loc(self):\n+    return _DeferredLoc(self)\n+\n+\n+class DeferredGroupBy(frame_base.DeferredFrame):\n+  def agg(self, fn):\n+    if not callable(fn):\n+      raise NotImplementedError(fn)\n+    return DeferredDataFrame(\n+        expressions.ComputedExpression(\n+            'agg',\n+            lambda df: df.agg(fn), [self._expr],\n+            requires_partition_by_index=True,\n+            preserves_partition_by_index=True))\n+\n+\n+def _liftable_agg(meth):\n+  name, func = frame_base.name_and_func(meth)\n+\n+  def wrapper(self, *args, **kargs):\n+    assert isinstance(self, DeferredGroupBy)\n+    ungrouped = self._expr.args()[0]\n+    pre_agg = expressions.ComputedExpression(\n+        'pre_combine_' + name,\n+        lambda df: func(df.groupby(level=list(range(df.index.nlevels)))),\n+        [ungrouped],\n+        requires_partition_by_index=False,\n+        preserves_partition_by_index=True)\n+    post_agg = expressions.ComputedExpression(\n+        'post_combine_' + name,\n+        lambda df: func(df.groupby(level=list(range(df.index.nlevels)))),\n+        [pre_agg],\n+        requires_partition_by_index=True,\n+        preserves_partition_by_index=True)\n+    return frame_base.DeferredFrame.wrap(post_agg)\n+\n+  return wrapper\n+\n+\n+def _unliftable_agg(meth):\n+  name, func = frame_base.name_and_func(meth)\n+\n+  def wrapper(self, *args, **kargs):\n+    assert isinstance(self, DeferredGroupBy)\n+    ungrouped = self._expr.args()[0]\n+    post_agg = expressions.ComputedExpression(\n+        name,\n+        lambda df: func(df.groupby(level=list(range(df.index.nlevels)))),\n+        [ungrouped],\n+        requires_partition_by_index=True,\n+        preserves_partition_by_index=True)\n+    return frame_base.DeferredFrame.wrap(post_agg)\n+\n+  return wrapper\n+\n+\n+for meth in ['all', 'any', 'max', 'min', 'prod', 'size', 'sum']:\n+  setattr(DeferredGroupBy, meth, _liftable_agg(meth))\n+for meth in ['mean', 'median', 'std', 'var']:\n+  setattr(DeferredGroupBy, meth, _unliftable_agg(meth))", "originalCommit": "a0b9c69c5b71417a212c201a01bc7f0bf40ff211", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEzMjI5Mg==", "url": "https://github.com/apache/beam/pull/10757#discussion_r389132292", "bodyText": "Somewhat related: I wonder if there's some way to get a full accounting of pandas operations, so we can create functions that raise NotImplementedError for \"everything else\" and/or generate a to-do list for future work. Would it be reasonable to use dir(pd.core.groupby.generic.DataFrameGroupBy) minus internal functions?", "author": "TheNeuralBit", "createdAt": "2020-03-06T20:38:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU1MzcwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM0OTY2NA==", "url": "https://github.com/apache/beam/pull/10757#discussion_r392349664", "bodyText": "Pulled these out into constants.\nYes, I think doing dir(cls) to both fill in NotImplemented methods and track current progress would be good to do (and we already have the correspondence with DeferredFrame._register_for).", "author": "robertwb", "createdAt": "2020-03-13T16:50:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU1MzcwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyODY1Ng==", "url": "https://github.com/apache/beam/pull/10757#discussion_r389128656", "bodyText": "It doesn't look like this import is actually used in this file. Given how closely related frame and frame_base are, I wonder if they should just be combined?", "author": "TheNeuralBit", "createdAt": "2020-03-06T20:30:05Z", "path": "sdks/python/apache_beam/dataframe/frames_test.py", "diffHunk": "@@ -0,0 +1,79 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+import unittest\n+\n+import numpy as np\n+import pandas as pd\n+\n+from apache_beam.dataframe import expressions\n+from apache_beam.dataframe import frame_base\n+from apache_beam.dataframe import frames", "originalCommit": "a0b9c69c5b71417a212c201a01bc7f0bf40ff211", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1MDU0OA==", "url": "https://github.com/apache/beam/pull/10757#discussion_r392350548", "bodyText": "The idea here is that frame_base would contain the infrastructure, and frame would grow to include the concrete implementations of various operations (which would grow over time).", "author": "robertwb", "createdAt": "2020-03-13T16:51:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEyODY1Ng=="}], "type": "inlineReview"}, {"oid": "fa253966092d2d187e66c219fd5beeedb59e0837", "url": "https://github.com/apache/beam/commit/fa253966092d2d187e66c219fd5beeedb59e0837", "message": "Minor cleanup.", "committedDate": "2020-03-13T18:05:27Z", "type": "forcePushed"}, {"oid": "2dd615a5eed0eec551ca64a5a6f0341bcfe4a0a4", "url": "https://github.com/apache/beam/commit/2dd615a5eed0eec551ca64a5a6f0341bcfe4a0a4", "message": "Minor cleanup, lint.", "committedDate": "2020-03-13T18:50:08Z", "type": "commit"}, {"oid": "2dd615a5eed0eec551ca64a5a6f0341bcfe4a0a4", "url": "https://github.com/apache/beam/commit/2dd615a5eed0eec551ca64a5a6f0341bcfe4a0a4", "message": "Minor cleanup, lint.", "committedDate": "2020-03-13T18:50:08Z", "type": "forcePushed"}]}