{"pr_number": 10897, "pr_title": "[BEAM-2939] Java UnboundedSource SDF wrapper", "pr_createdAt": "2020-02-19T00:12:31Z", "pr_url": "https://github.com/apache/beam/pull/10897", "timeline": [{"oid": "3a0abcb4e1a17be8e91a8df71a54044e3771c502", "url": "https://github.com/apache/beam/commit/3a0abcb4e1a17be8e91a8df71a54044e3771c502", "message": "[BEAM-XXX] Implement UnboundedSource wrapper.", "committedDate": "2020-02-19T01:09:12Z", "type": "forcePushed"}, {"oid": "be048806002c21d086cf729cfbf225d4a1699fd3", "url": "https://github.com/apache/beam/commit/be048806002c21d086cf729cfbf225d4a1699fd3", "message": "[BEAM-XXX] Implement UnboundedSource wrapper.", "committedDate": "2020-02-19T20:00:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY0MzcyOQ==", "url": "https://github.com/apache/beam/pull/10897#discussion_r381643729", "bodyText": "Nice. So looks like we don't have to create new Java transforms to use existing sources ?", "author": "chamikaramj", "createdAt": "2020-02-20T01:23:29Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "diffHunk": "@@ -182,6 +198,37 @@ private Unbounded(@Nullable String name, UnboundedSource<T, ?> source) {\n     @Override\n     public final PCollection<T> expand(PBegin input) {\n       source.validate();\n+\n+      if (ExperimentalOptions.hasExperiment(input.getPipeline().getOptions(), \"beam_fn_api\")\n+          && !ExperimentalOptions.hasExperiment(\n+              input.getPipeline().getOptions(), \"beam_fn_api_use_deprecated_read\")) {\n+        // We don't use Create here since Create is defined as a BoundedSource and using it would\n+        // cause an infinite expansion loop. We can reconsider this if Create is implemented\n+        // directly as a SplittableDoFn.\n+        PCollection<ValueWithRecordId<T>> outputWithIds =\n+            input\n+                .getPipeline()\n+                .apply(Impulse.create())\n+                .apply(\n+                    MapElements.into(new TypeDescriptor<UnboundedSource<T, CheckpointMark>>() {})\n+                        .via(element -> (UnboundedSource<T, CheckpointMark>) source))\n+                .setCoder(\n+                    SerializableCoder.of(\n+                        new TypeDescriptor<UnboundedSource<T, CheckpointMark>>() {}))\n+                .apply(\n+                    ParDo.of(\n+                        new UnboundedSourceAsSDFWrapperFn<>(", "originalCommit": "be048806002c21d086cf729cfbf225d4a1699fd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY4MTgzNw==", "url": "https://github.com/apache/beam/pull/10897#discussion_r381681837", "bodyText": "Yes, the wrapper is going to convert existing UnboundedSource into SDF.", "author": "boyuanzz", "createdAt": "2020-02-20T02:31:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTY0MzcyOQ=="}], "type": "inlineReview"}, {"oid": "228e5844a5022439cc048b19f070e1561b8ec94f", "url": "https://github.com/apache/beam/commit/228e5844a5022439cc048b19f070e1561b8ec94f", "message": "[BEAM-2939] Implement UnboundedSource wrapper.", "committedDate": "2020-02-24T19:51:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc5MzU5Mw==", "url": "https://github.com/apache/beam/pull/10897#discussion_r384793593", "bodyText": "It seems the risk is higher setting this too low than too high--maybe 100 or more? (Is there a JIRA for letting the runner pass this in?)", "author": "robertwb", "createdAt": "2020-02-26T22:00:53Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "diffHunk": "@@ -375,4 +422,361 @@ public void checkDone() throws IllegalStateException {\n       }\n     }\n   }\n+\n+  /**\n+   * A splittable {@link DoFn} which executes an {@link UnboundedSource}.\n+   *\n+   * <p>We model the element as the original source and the restriction as a pair of the sub-source\n+   * and its {@link CheckpointMark}. This allows us to split the sub-source over and over as long as\n+   * the checkpoint mark is {@code null} or the {@link NoopCheckpointMark} since it does not\n+   * maintain any state.\n+   */\n+  // TODO: Support reporting the watermark, currently the watermark never advances.\n+  @UnboundedPerElement\n+  static class UnboundedSourceAsSDFWrapperFn<OutputT, CheckpointT extends CheckpointMark>\n+      extends DoFn<UnboundedSource<OutputT, CheckpointT>, ValueWithRecordId<OutputT>> {\n+\n+    private static final int DEFAULT_DESIRED_NUM_SPLITS = 20;", "originalCommit": "228e5844a5022439cc048b19f070e1561b8ec94f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2ODYzOA==", "url": "https://github.com/apache/beam/pull/10897#discussion_r384868638", "bodyText": "The default in Dataflow is 4 * first non-null of (maxNumWorkers, numWorkers, 5):\n\n  \n    \n      beam/runners/google-cloud-dataflow-java/src/main/java/org/apache/beam/runners/dataflow/internal/CustomSources.java\n    \n    \n         Line 51\n      in\n      860131b\n    \n    \n    \n    \n\n        \n          \n           private static int getDesiredNumUnboundedSourceSplits(DataflowPipelineOptions options) { \n        \n    \n  \n\n (I like the TODO in the method)\nWhich is why I went with 20 as the default.", "author": "lukecwik", "createdAt": "2020-02-27T01:39:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc5MzU5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgyMDM1NA==", "url": "https://github.com/apache/beam/pull/10897#discussion_r384820354", "bodyText": "Is \"named tuple\" also java terminology, or should this be a POJO?", "author": "robertwb", "createdAt": "2020-02-26T23:01:44Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "diffHunk": "@@ -375,4 +422,361 @@ public void checkDone() throws IllegalStateException {\n       }\n     }\n   }\n+\n+  /**\n+   * A splittable {@link DoFn} which executes an {@link UnboundedSource}.\n+   *\n+   * <p>We model the element as the original source and the restriction as a pair of the sub-source\n+   * and its {@link CheckpointMark}. This allows us to split the sub-source over and over as long as\n+   * the checkpoint mark is {@code null} or the {@link NoopCheckpointMark} since it does not\n+   * maintain any state.\n+   */\n+  // TODO: Support reporting the watermark, currently the watermark never advances.\n+  @UnboundedPerElement\n+  static class UnboundedSourceAsSDFWrapperFn<OutputT, CheckpointT extends CheckpointMark>\n+      extends DoFn<UnboundedSource<OutputT, CheckpointT>, ValueWithRecordId<OutputT>> {\n+\n+    private static final int DEFAULT_DESIRED_NUM_SPLITS = 20;\n+    private static final int DEFAULT_BUNDLE_FINALIZATION_LIMIT_MINS = 10;\n+    private final Coder<CheckpointT> restrictionCoder;\n+\n+    private UnboundedSourceAsSDFWrapperFn(Coder<CheckpointT> restrictionCoder) {\n+      this.restrictionCoder = restrictionCoder;\n+    }\n+\n+    @GetInitialRestriction\n+    public KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> initialRestriction(\n+        @Element UnboundedSource<OutputT, CheckpointT> element) {\n+      return KV.of(element, null);\n+    }\n+\n+    @GetSize\n+    public double getSize(\n+        @Restriction KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> restriction,\n+        PipelineOptions pipelineOptions)\n+        throws Exception {\n+      if (restriction.getKey() instanceof EmptyUnboundedSource) {\n+        return 1;\n+      }\n+\n+      UnboundedReader<OutputT> reader =\n+          restriction.getKey().createReader(pipelineOptions, restriction.getValue());\n+      long size = reader.getSplitBacklogBytes();\n+      if (size != UnboundedReader.BACKLOG_UNKNOWN) {\n+        return size;\n+      }\n+      // TODO: Support \"global\" backlog reporting\n+      // size = reader.getTotalBacklogBytes();\n+      // if (size != UnboundedReader.BACKLOG_UNKNOWN) {\n+      //   return size;\n+      // }\n+      return 1;\n+    }\n+\n+    @SplitRestriction\n+    public void splitRestriction(\n+        @Restriction KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> restriction,\n+        OutputReceiver<KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT>> receiver,\n+        PipelineOptions pipelineOptions)\n+        throws Exception {\n+      // The empty unbounded source is trivially done and hence we don't need to output any splits\n+      // for it.\n+      if (restriction.getKey() instanceof EmptyUnboundedSource) {\n+        return;\n+      }\n+\n+      // The UnboundedSource API does not support splitting after a meaningful checkpoint mark has\n+      // been created.\n+      if (restriction.getValue() != null\n+          && !(restriction.getValue()\n+              instanceof UnboundedSource.CheckpointMark.NoopCheckpointMark)) {\n+        receiver.output(restriction);\n+      }\n+\n+      try {\n+        for (UnboundedSource<OutputT, CheckpointT> split :\n+            restriction.getKey().split(DEFAULT_DESIRED_NUM_SPLITS, pipelineOptions)) {\n+          receiver.output(KV.of(split, null));\n+        }\n+      } catch (Exception e) {\n+        receiver.output(restriction);\n+      }\n+    }\n+\n+    @NewTracker\n+    public RestrictionTracker<\n+            KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT>, UnboundedSourceValue<OutputT>[]>\n+        restrictionTracker(\n+            @Restriction KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> restriction,\n+            PipelineOptions pipelineOptions) {\n+      return new UnboundedSourceAsSDFRestrictionTracker(restriction, pipelineOptions);\n+    }\n+\n+    @ProcessElement\n+    public ProcessContinuation processElement(\n+        RestrictionTracker<\n+                KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT>, UnboundedSourceValue[]>\n+            tracker,\n+        OutputReceiver<ValueWithRecordId<OutputT>> receiver,\n+        BundleFinalizer bundleFinalizer)\n+        throws IOException {\n+      UnboundedSourceValue<OutputT>[] out = new UnboundedSourceValue[1];\n+      while (tracker.tryClaim(out)) {\n+        receiver.outputWithTimestamp(\n+            new ValueWithRecordId<>(out[0].getValue(), out[0].getId()), out[0].getTimestamp());\n+      }\n+\n+      // Add the checkpoint mark to be finalized if the checkpoint mark isn't trivial.\n+      KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> currentRestriction =\n+          tracker.currentRestriction();\n+      if (currentRestriction.getValue() != null\n+          && !(tracker.currentRestriction().getValue() instanceof NoopCheckpointMark)) {\n+        bundleFinalizer.afterBundleCommit(\n+            Instant.now().plus(Duration.standardMinutes(DEFAULT_BUNDLE_FINALIZATION_LIMIT_MINS)),\n+            currentRestriction.getValue()::finalizeCheckpoint);\n+      }\n+\n+      // If we have been split/checkpoint by a runner, the tracker will have been updated to the\n+      // empty source and we will return stop. Otherwise the unbounded source has only temporarily\n+      // run out of work.\n+      if (tracker.currentRestriction().getKey() instanceof EmptyUnboundedSource) {\n+        return ProcessContinuation.stop();\n+      }\n+      return ProcessContinuation.resume();\n+    }\n+\n+    @GetRestrictionCoder\n+    public Coder<KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT>> restrictionCoder() {\n+      return KvCoder.of(\n+          SerializableCoder.of(new TypeDescriptor<UnboundedSource<OutputT, CheckpointT>>() {}),\n+          NullableCoder.of(restrictionCoder));\n+    }\n+\n+    /**\n+     * A named tuple representing all the values we need to pass between the {@link UnboundedReader}", "originalCommit": "228e5844a5022439cc048b19f070e1561b8ec94f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2ODczNg==", "url": "https://github.com/apache/beam/pull/10897#discussion_r384868736", "bodyText": "not really, borrowed it from python, will fix.", "author": "lukecwik", "createdAt": "2020-02-27T01:39:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgyMDM1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgyNjc0Ng==", "url": "https://github.com/apache/beam/pull/10897#discussion_r384826746", "bodyText": "JIRA for tracking? (Or would this be 10897?) Maybe update the PR/commit description to describe the current capabilities and limitations.", "author": "robertwb", "createdAt": "2020-02-26T23:19:44Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "diffHunk": "@@ -375,4 +422,361 @@ public void checkDone() throws IllegalStateException {\n       }\n     }\n   }\n+\n+  /**\n+   * A splittable {@link DoFn} which executes an {@link UnboundedSource}.\n+   *\n+   * <p>We model the element as the original source and the restriction as a pair of the sub-source\n+   * and its {@link CheckpointMark}. This allows us to split the sub-source over and over as long as\n+   * the checkpoint mark is {@code null} or the {@link NoopCheckpointMark} since it does not\n+   * maintain any state.\n+   */\n+  // TODO: Support reporting the watermark, currently the watermark never advances.", "originalCommit": "228e5844a5022439cc048b19f070e1561b8ec94f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2Nzc2MA==", "url": "https://github.com/apache/beam/pull/10897#discussion_r384867760", "bodyText": "Will file JIRA if I can't do all the watermark reporting passing and implementation in the SDK harness.", "author": "lukecwik", "createdAt": "2020-02-27T01:36:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgyNjc0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg0MDc2OA==", "url": "https://github.com/apache/beam/pull/10897#discussion_r384840768", "bodyText": "I'm curious what WindowingStrategy is going to apply here. If it's using GlobalWindow, will it work in streaming mode?", "author": "boyuanzz", "createdAt": "2020-02-27T00:03:00Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "diffHunk": "@@ -185,6 +200,37 @@ private Unbounded(@Nullable String name, UnboundedSource<T, ?> source) {\n     @Override\n     public final PCollection<T> expand(PBegin input) {\n       source.validate();\n+\n+      if (ExperimentalOptions.hasExperiment(input.getPipeline().getOptions(), \"beam_fn_api\")\n+          && !ExperimentalOptions.hasExperiment(\n+              input.getPipeline().getOptions(), \"beam_fn_api_use_deprecated_read\")) {\n+        // We don't use Create here since Create is defined as a BoundedSource and using it would\n+        // cause an infinite expansion loop. We can reconsider this if Create is implemented\n+        // directly as a SplittableDoFn.\n+        PCollection<ValueWithRecordId<T>> outputWithIds =\n+            input\n+                .getPipeline()\n+                .apply(Impulse.create())\n+                .apply(\n+                    MapElements.into(new TypeDescriptor<UnboundedSource<T, CheckpointMark>>() {})\n+                        .via(element -> (UnboundedSource<T, CheckpointMark>) source))\n+                .setCoder(\n+                    SerializableCoder.of(\n+                        new TypeDescriptor<UnboundedSource<T, CheckpointMark>>() {}))\n+                .apply(\n+                    ParDo.of(\n+                        new UnboundedSourceAsSDFWrapperFn<>(\n+                            (Coder<CheckpointMark>) source.getCheckpointMarkCoder())))\n+                .setCoder(ValueWithRecordIdCoder.of(source.getOutputCoder()));\n+        if (source.requiresDeduping()) {\n+          outputWithIds.apply(\n+              Distinct.<ValueWithRecordId<T>, byte[]>withRepresentativeValueFn(", "originalCommit": "228e5844a5022439cc048b19f070e1561b8ec94f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2NzA0Mg==", "url": "https://github.com/apache/beam/pull/10897#discussion_r384867042", "bodyText": "No it won't, this was for some testing of mine.", "author": "lukecwik", "createdAt": "2020-02-27T01:33:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg0MDc2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg0NjY5OQ==", "url": "https://github.com/apache/beam/pull/10897#discussion_r384846699", "bodyText": "Also curious why each output has its own watermark. Will the watermark be different from timestamp for one given record?", "author": "boyuanzz", "createdAt": "2020-02-27T00:22:34Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "diffHunk": "@@ -375,4 +422,361 @@ public void checkDone() throws IllegalStateException {\n       }\n     }\n   }\n+\n+  /**\n+   * A splittable {@link DoFn} which executes an {@link UnboundedSource}.\n+   *\n+   * <p>We model the element as the original source and the restriction as a pair of the sub-source\n+   * and its {@link CheckpointMark}. This allows us to split the sub-source over and over as long as\n+   * the checkpoint mark is {@code null} or the {@link NoopCheckpointMark} since it does not\n+   * maintain any state.\n+   */\n+  // TODO: Support reporting the watermark, currently the watermark never advances.\n+  @UnboundedPerElement\n+  static class UnboundedSourceAsSDFWrapperFn<OutputT, CheckpointT extends CheckpointMark>\n+      extends DoFn<UnboundedSource<OutputT, CheckpointT>, ValueWithRecordId<OutputT>> {\n+\n+    private static final int DEFAULT_DESIRED_NUM_SPLITS = 20;\n+    private static final int DEFAULT_BUNDLE_FINALIZATION_LIMIT_MINS = 10;\n+    private final Coder<CheckpointT> restrictionCoder;\n+\n+    private UnboundedSourceAsSDFWrapperFn(Coder<CheckpointT> restrictionCoder) {\n+      this.restrictionCoder = restrictionCoder;\n+    }\n+\n+    @GetInitialRestriction\n+    public KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> initialRestriction(\n+        @Element UnboundedSource<OutputT, CheckpointT> element) {\n+      return KV.of(element, null);\n+    }\n+\n+    @GetSize\n+    public double getSize(\n+        @Restriction KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> restriction,\n+        PipelineOptions pipelineOptions)\n+        throws Exception {\n+      if (restriction.getKey() instanceof EmptyUnboundedSource) {\n+        return 1;\n+      }\n+\n+      UnboundedReader<OutputT> reader =\n+          restriction.getKey().createReader(pipelineOptions, restriction.getValue());\n+      long size = reader.getSplitBacklogBytes();\n+      if (size != UnboundedReader.BACKLOG_UNKNOWN) {\n+        return size;\n+      }\n+      // TODO: Support \"global\" backlog reporting\n+      // size = reader.getTotalBacklogBytes();\n+      // if (size != UnboundedReader.BACKLOG_UNKNOWN) {\n+      //   return size;\n+      // }\n+      return 1;\n+    }\n+\n+    @SplitRestriction\n+    public void splitRestriction(\n+        @Restriction KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> restriction,\n+        OutputReceiver<KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT>> receiver,\n+        PipelineOptions pipelineOptions)\n+        throws Exception {\n+      // The empty unbounded source is trivially done and hence we don't need to output any splits\n+      // for it.\n+      if (restriction.getKey() instanceof EmptyUnboundedSource) {\n+        return;\n+      }\n+\n+      // The UnboundedSource API does not support splitting after a meaningful checkpoint mark has\n+      // been created.\n+      if (restriction.getValue() != null\n+          && !(restriction.getValue()\n+              instanceof UnboundedSource.CheckpointMark.NoopCheckpointMark)) {\n+        receiver.output(restriction);\n+      }\n+\n+      try {\n+        for (UnboundedSource<OutputT, CheckpointT> split :\n+            restriction.getKey().split(DEFAULT_DESIRED_NUM_SPLITS, pipelineOptions)) {\n+          receiver.output(KV.of(split, null));\n+        }\n+      } catch (Exception e) {\n+        receiver.output(restriction);\n+      }\n+    }\n+\n+    @NewTracker\n+    public RestrictionTracker<\n+            KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT>, UnboundedSourceValue<OutputT>[]>\n+        restrictionTracker(\n+            @Restriction KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> restriction,\n+            PipelineOptions pipelineOptions) {\n+      return new UnboundedSourceAsSDFRestrictionTracker(restriction, pipelineOptions);\n+    }\n+\n+    @ProcessElement\n+    public ProcessContinuation processElement(\n+        RestrictionTracker<\n+                KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT>, UnboundedSourceValue[]>\n+            tracker,\n+        OutputReceiver<ValueWithRecordId<OutputT>> receiver,\n+        BundleFinalizer bundleFinalizer)\n+        throws IOException {\n+      UnboundedSourceValue<OutputT>[] out = new UnboundedSourceValue[1];\n+      while (tracker.tryClaim(out)) {\n+        receiver.outputWithTimestamp(\n+            new ValueWithRecordId<>(out[0].getValue(), out[0].getId()), out[0].getTimestamp());\n+      }\n+\n+      // Add the checkpoint mark to be finalized if the checkpoint mark isn't trivial.\n+      KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> currentRestriction =\n+          tracker.currentRestriction();\n+      if (currentRestriction.getValue() != null\n+          && !(tracker.currentRestriction().getValue() instanceof NoopCheckpointMark)) {\n+        bundleFinalizer.afterBundleCommit(\n+            Instant.now().plus(Duration.standardMinutes(DEFAULT_BUNDLE_FINALIZATION_LIMIT_MINS)),\n+            currentRestriction.getValue()::finalizeCheckpoint);\n+      }\n+\n+      // If we have been split/checkpoint by a runner, the tracker will have been updated to the\n+      // empty source and we will return stop. Otherwise the unbounded source has only temporarily\n+      // run out of work.\n+      if (tracker.currentRestriction().getKey() instanceof EmptyUnboundedSource) {\n+        return ProcessContinuation.stop();\n+      }\n+      return ProcessContinuation.resume();\n+    }\n+\n+    @GetRestrictionCoder\n+    public Coder<KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT>> restrictionCoder() {\n+      return KvCoder.of(\n+          SerializableCoder.of(new TypeDescriptor<UnboundedSource<OutputT, CheckpointT>>() {}),\n+          NullableCoder.of(restrictionCoder));\n+    }\n+\n+    /**\n+     * A named tuple representing all the values we need to pass between the {@link UnboundedReader}\n+     * and the {@link org.apache.beam.sdk.transforms.DoFn.ProcessElement @ProcessElement} method of\n+     * the splittable DoFn.\n+     */\n+    @AutoValue\n+    abstract static class UnboundedSourceValue<T> {\n+      public static <T> UnboundedSourceValue<T> create(\n+          byte[] id, T value, Instant timestamp, Instant watermark) {\n+        return new AutoValue_Read_UnboundedSourceAsSDFWrapperFn_UnboundedSourceValue<T>(\n+            id, value, timestamp, watermark);\n+      }\n+\n+      @SuppressWarnings(\"mutable\")\n+      public abstract byte[] getId();\n+\n+      public abstract T getValue();\n+\n+      public abstract Instant getTimestamp();\n+\n+      public abstract Instant getWatermark();", "originalCommit": "228e5844a5022439cc048b19f070e1561b8ec94f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2NjEyNQ==", "url": "https://github.com/apache/beam/pull/10897#discussion_r384866125", "bodyText": "The UnboundedSource can report a watermark that is reported separately from the element timestamp.", "author": "lukecwik", "createdAt": "2020-02-27T01:29:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg0NjY5OQ=="}], "type": "inlineReview"}, {"oid": "bc827bd0ba108b5ee87502011e307e411281481f", "url": "https://github.com/apache/beam/commit/bc827bd0ba108b5ee87502011e307e411281481f", "message": "[BEAM-2939] Implement UnboundedSource wrapper.", "committedDate": "2020-03-02T23:35:51Z", "type": "commit"}, {"oid": "8eaf552be6e73a3f636425f7486b8764613fcc33", "url": "https://github.com/apache/beam/commit/8eaf552be6e73a3f636425f7486b8764613fcc33", "message": "fixup! Plumb watermark through the ProcessContext and report it on the BundleApplication.", "committedDate": "2020-03-03T00:27:56Z", "type": "forcePushed"}, {"oid": "033e8f52bd3b7636d23f6e81cb0cedf1ddc1df4e", "url": "https://github.com/apache/beam/commit/033e8f52bd3b7636d23f6e81cb0cedf1ddc1df4e", "message": "fixup! Plumb watermark through the ProcessContext and report it on the BundleApplication.", "committedDate": "2020-03-03T00:31:55Z", "type": "forcePushed"}, {"oid": "26aeea0657369ddf4ed5a917bd10df288087d2bf", "url": "https://github.com/apache/beam/commit/26aeea0657369ddf4ed5a917bd10df288087d2bf", "message": "fixup! Plumb watermark through the ProcessContext and report it on the BundleApplication.", "committedDate": "2020-03-03T00:36:58Z", "type": "forcePushed"}, {"oid": "01c12c08bc0c4a093533d93d20ecf8f8869e68c7", "url": "https://github.com/apache/beam/commit/01c12c08bc0c4a093533d93d20ecf8f8869e68c7", "message": "fixup! Plumb watermark through the ProcessContext and report it on the BundleApplication.", "committedDate": "2020-03-03T00:39:11Z", "type": "commit"}, {"oid": "01c12c08bc0c4a093533d93d20ecf8f8869e68c7", "url": "https://github.com/apache/beam/commit/01c12c08bc0c4a093533d93d20ecf8f8869e68c7", "message": "fixup! Plumb watermark through the ProcessContext and report it on the BundleApplication.", "committedDate": "2020-03-03T00:39:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMjEwNQ==", "url": "https://github.com/apache/beam/pull/10897#discussion_r411722105", "bodyText": "Do we assume that getSize here is always called for calculating backlog in streaming? It is not correct for calculating  primary size(though primary size doesn't matter for now).", "author": "boyuanzz", "createdAt": "2020-04-20T22:02:24Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/io/Read.java", "diffHunk": "@@ -375,4 +423,372 @@ public void checkDone() throws IllegalStateException {\n       }\n     }\n   }\n+\n+  /**\n+   * A splittable {@link DoFn} which executes an {@link UnboundedSource}.\n+   *\n+   * <p>We model the element as the original source and the restriction as a pair of the sub-source\n+   * and its {@link CheckpointMark}. This allows us to split the sub-source over and over as long as\n+   * the checkpoint mark is {@code null} or the {@link NoopCheckpointMark} since it does not\n+   * maintain any state.\n+   */\n+  @UnboundedPerElement\n+  static class UnboundedSourceAsSDFWrapperFn<OutputT, CheckpointT extends CheckpointMark>\n+      extends DoFn<UnboundedSource<OutputT, CheckpointT>, ValueWithRecordId<OutputT>> {\n+    private static final Logger LOG = LoggerFactory.getLogger(UnboundedSourceAsSDFWrapperFn.class);\n+    private static final int DEFAULT_DESIRED_NUM_SPLITS = 20;\n+    private static final int DEFAULT_BUNDLE_FINALIZATION_LIMIT_MINS = 10;\n+    private final Coder<CheckpointT> restrictionCoder;\n+\n+    private UnboundedSourceAsSDFWrapperFn(Coder<CheckpointT> restrictionCoder) {\n+      this.restrictionCoder = restrictionCoder;\n+    }\n+\n+    @GetInitialRestriction\n+    public KV<UnboundedSource<OutputT, CheckpointT>, CheckpointT> initialRestriction(\n+        @Element UnboundedSource<OutputT, CheckpointT> element) {\n+      return KV.of(element, null);\n+    }\n+\n+    @GetSize\n+    public double getSize(", "originalCommit": "01c12c08bc0c4a093533d93d20ecf8f8869e68c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0Njc5Nw==", "url": "https://github.com/apache/beam/pull/10897#discussion_r411746797", "bodyText": "getSize is used for the initial size and isn't used anywhere for progress/backlog reporting yet.\nWith #11472, this can be migrated to HasProgress on the restriction tracker.", "author": "lukecwik", "createdAt": "2020-04-20T22:57:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMjEwNQ=="}], "type": "inlineReview"}]}