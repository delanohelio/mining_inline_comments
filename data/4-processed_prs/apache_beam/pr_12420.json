{"pr_number": 12420, "pr_title": "Extending ApproximateQuantiles functionality to deal with non-uniform weights.", "pr_createdAt": "2020-07-30T03:02:59Z", "pr_url": "https://github.com/apache/beam/pull/12420", "timeline": [{"oid": "2ed365579d683a46a575c513d433584d59589f8a", "url": "https://github.com/apache/beam/commit/2ed365579d683a46a575c513d433584d59589f8a", "message": "Extending ApproximateQuantiles functionality to deal with non-uniform weights.", "committedDate": "2020-07-30T02:10:59Z", "type": "commit"}, {"oid": "2f907301a37b306b2f1c275e1d14ae07ab4d0ddb", "url": "https://github.com/apache/beam/commit/2f907301a37b306b2f1c275e1d14ae07ab4d0ddb", "message": "Merge pull request #1 from iindyk/weighted_quantiles\n\nExtending ApproximateQuantiles functionality to deal with non-uniform weights.", "committedDate": "2020-07-30T02:19:03Z", "type": "commit"}, {"oid": "5f0a736fd3c552c6fa61e5c20cbb129b1a90414e", "url": "https://github.com/apache/beam/commit/5f0a736fd3c552c6fa61e5c20cbb129b1a90414e", "message": "Extending ApproximateQuantiles functionality to deal with non-uniform weights.", "committedDate": "2020-07-30T02:34:53Z", "type": "commit"}, {"oid": "ad5a28a738622aad9049e05e192558c3a4873bd0", "url": "https://github.com/apache/beam/commit/ad5a28a738622aad9049e05e192558c3a4873bd0", "message": "Extending ApproximateQuantiles functionality to deal with non-uniform weights.", "committedDate": "2020-07-30T02:37:17Z", "type": "commit"}, {"oid": "5e7edfd19de07eb41ebde667140ab715ad0655e7", "url": "https://github.com/apache/beam/commit/5e7edfd19de07eb41ebde667140ab715ad0655e7", "message": "Extending ApproximateQuantiles functionality to deal with non-uniform weights.", "committedDate": "2020-07-30T13:52:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzMDM0Mw==", "url": "https://github.com/apache/beam/pull/12420#discussion_r463330343", "bodyText": "Can we add weighted as the last argument? So we'll have a change that's backwards compatible", "author": "pabloem", "createdAt": "2020-07-30T23:43:38Z", "path": "sdks/python/apache_beam/transforms/stats.py", "diffHunk": "@@ -263,30 +265,38 @@ class Globally(PTransform):\n \n     Args:\n       num_quantiles: number of elements in the resulting quantiles values list.\n+      weighted: (optional) if set to True, the transform returns weighted\n+        quantiles. The input PCollection is then expected to contain tuples of\n+        input values with the corresponding weight.\n       key: (optional) Key is  a mapping of elements to a comparable key, similar\n         to the key argument of Python's sorting methods.\n       reverse: (optional) whether to order things smallest to largest, rather\n         than largest to smallest\n     \"\"\"\n-    def __init__(self, num_quantiles, key=None, reverse=False):\n+    def __init__(self, num_quantiles, weighted=False, key=None, reverse=False):", "originalCommit": "5e7edfd19de07eb41ebde667140ab715ad0655e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkzNzczMg==", "url": "https://github.com/apache/beam/pull/12420#discussion_r468937732", "bodyText": "Ah, yes, of course.", "author": "iindyk", "createdAt": "2020-08-12T00:29:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzMDM0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzMTY2OA==", "url": "https://github.com/apache/beam/pull/12420#discussion_r463331668", "bodyText": "I don't know much math, so I wonder: How come the error bound for the approximation for weighted elements is not f(N)?", "author": "pabloem", "createdAt": "2020-07-30T23:48:09Z", "path": "sdks/python/apache_beam/transforms/stats.py", "diffHunk": "@@ -398,8 +424,8 @@ class ApproximateQuantilesCombineFn(CombineFn):\n   http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.6.6513&rep=rep1\n   &type=pdf\n \n-  The default error bound is (1 / N), though in practice the accuracy\n-  tends to be much better.\n+  The default error bound is (1 / N) for uniformly distributed data and 1e-2 for", "originalCommit": "5e7edfd19de07eb41ebde667140ab715ad0655e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkzNzc4OA==", "url": "https://github.com/apache/beam/pull/12420#discussion_r468937788", "bodyText": "I think N rarely exceeds 100 and most of the time is <10, so I changed to 1e-2 to increase accuracy for the weighted case. This was done to reflect the fact that, although we guarantee this error bound, the bound itself is on the weight concentrated between the returned value and the actual quantile. If the weights are uneven, then there may potentially be a lot of values between those.\nBut looking at it again, I think you're right and it would make more sense to set it to min(1e-2, 1/N).", "author": "iindyk", "createdAt": "2020-08-12T00:29:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzMTY2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA2MjU4Ng==", "url": "https://github.com/apache/beam/pull/12420#discussion_r468062586", "bodyText": "Perhaps show an example of this in a code snippet?", "author": "pabloem", "createdAt": "2020-08-10T17:26:30Z", "path": "sdks/python/apache_beam/transforms/stats.py", "diffHunk": "@@ -263,30 +265,38 @@ class Globally(PTransform):\n \n     Args:\n       num_quantiles: number of elements in the resulting quantiles values list.\n+      weighted: (optional) if set to True, the transform returns weighted\n+        quantiles. The input PCollection is then expected to contain tuples of\n+        input values with the corresponding weight.", "originalCommit": "5e7edfd19de07eb41ebde667140ab715ad0655e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA2MzAzNg==", "url": "https://github.com/apache/beam/pull/12420#discussion_r468063036", "bodyText": "Perhaps under the ApproximateQuantiles transform pydoc, rather than on these args (so it'll work for perKey and globally)? Up to you.", "author": "pabloem", "createdAt": "2020-08-10T17:27:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA2MjU4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkzNzg0Mg==", "url": "https://github.com/apache/beam/pull/12420#discussion_r468937842", "bodyText": "Done. Although I wasn't able to find a pattern for examples (like for DocTest). Let me know if I should change the format", "author": "iindyk", "createdAt": "2020-08-12T00:29:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA2MjU4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI0MTU2MQ==", "url": "https://github.com/apache/beam/pull/12420#discussion_r468241561", "bodyText": "I wonder if it's possible to do this without duplicating the code in both branches? I understand that separating branches may help performance, but it decreases on readability...  WDYT?", "author": "pabloem", "createdAt": "2020-08-10T23:32:11Z", "path": "sdks/python/apache_beam/transforms/stats.py", "diffHunk": "@@ -576,17 +633,34 @@ def _interpolate(self, i_buffers, count, step, offset):\n     weighted_element = next(sorted_elem)\n     current = weighted_element[1]\n     j = 0\n-    while j < count:\n-      target = j * step + offset\n-      j = j + 1\n-      try:\n-        while current <= target:\n-          weighted_element = next(sorted_elem)\n-          current = current + weighted_element[1]\n-      except StopIteration:\n-        pass\n-      new_elements.append(weighted_element[0])\n-    return new_elements\n+    if self._weighted:", "originalCommit": "5e7edfd19de07eb41ebde667140ab715ad0655e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkzNzkyNA==", "url": "https://github.com/apache/beam/pull/12420#discussion_r468937924", "bodyText": "I tried to avoid affecting the performance of the existing codepath, but after a closer look I think the overhead caused by the if in the loop is negligible compared to the time taken by the inner loop and append. Merged the branches.", "author": "iindyk", "createdAt": "2020-08-12T00:30:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI0MTU2MQ=="}], "type": "inlineReview"}, {"oid": "2441e0d5263d4dda4d2043da24d7ba4e5e50cf47", "url": "https://github.com/apache/beam/commit/2441e0d5263d4dda4d2043da24d7ba4e5e50cf47", "message": "Added example to ApproximateQuantiles docstring, made weighted argument the last and modified _interpolate for readability.", "committedDate": "2020-08-12T00:28:23Z", "type": "commit"}, {"oid": "170d0cb5a403b02129f9276dd26d9b8671d187a5", "url": "https://github.com/apache/beam/commit/170d0cb5a403b02129f9276dd26d9b8671d187a5", "message": "Added example to ApproximateQuantiles docstring, made weighted argument the last and modified _interpolate for readability.", "committedDate": "2020-08-12T00:51:28Z", "type": "commit"}, {"oid": "ff2db21c821137abcd7a4a961cc25e8644e33022", "url": "https://github.com/apache/beam/commit/ff2db21c821137abcd7a4a961cc25e8644e33022", "message": "Added example to ApproximateQuantiles docstring, made weighted argument the last and modified _interpolate for readability.", "committedDate": "2020-08-12T02:20:46Z", "type": "commit"}, {"oid": "b4f2a9b34ecd888ab8abd35cc8b65de190c561c6", "url": "https://github.com/apache/beam/commit/b4f2a9b34ecd888ab8abd35cc8b65de190c561c6", "message": "Added example to ApproximateQuantiles docstring, made weighted argument the last and modified _interpolate for readability.", "committedDate": "2020-08-12T15:54:02Z", "type": "commit"}, {"oid": "f826a0752fdd23aa42de870aae64cb415412d231", "url": "https://github.com/apache/beam/commit/f826a0752fdd23aa42de870aae64cb415412d231", "message": "Added example to ApproximateQuantiles docstring, made weighted argument the last and modified _interpolate for readability.", "committedDate": "2020-08-12T21:16:52Z", "type": "commit"}]}