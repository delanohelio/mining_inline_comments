{"pr_number": 12093, "pr_title": "[BEAM-10303] Add support for the non-window observing optimization to DoFn execution in portable Beam Java", "pr_createdAt": "2020-06-25T22:28:10Z", "pr_url": "https://github.com/apache/beam/pull/12093", "timeline": [{"oid": "9ede4ca7f82659ba43fd018a42a416b1c43f3b6d", "url": "https://github.com/apache/beam/commit/9ede4ca7f82659ba43fd018a42a416b1c43f3b6d", "message": "[BEAM-10303] Add support for the non-window observing optimization to DoFn execution.\n\nThis covers all but the splittable DoFn processElements call since I wanted to limit the size of the change.", "committedDate": "2020-06-25T22:27:42Z", "type": "commit"}, {"oid": "39292acb90443e9e643b656380e7fd62ed7a3020", "url": "https://github.com/apache/beam/commit/39292acb90443e9e643b656380e7fd62ed7a3020", "message": "fixup! Fix issues found during beamimport test_pr\n\n* Make sure that TimerFamilyParameter makes DoFns window observing\n* Handle the case where the split call isn't implemented and we get the default", "committedDate": "2020-06-25T23:11:35Z", "type": "commit"}, {"oid": "39292acb90443e9e643b656380e7fd62ed7a3020", "url": "https://github.com/apache/beam/commit/39292acb90443e9e643b656380e7fd62ed7a3020", "message": "fixup! Fix issues found during beamimport test_pr\n\n* Make sure that TimerFamilyParameter makes DoFns window observing\n* Handle the case where the split call isn't implemented and we get the default", "committedDate": "2020-06-25T23:11:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQxODM5OQ==", "url": "https://github.com/apache/beam/pull/12093#discussion_r446418399", "bodyText": "I noticed currentWindow isn't set to null here, where it was before. Same with processElementForWindowObservingPairWithRestriction. Why is that?", "author": "ibzib", "createdAt": "2020-06-26T21:29:23Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -637,6 +737,28 @@ private void processElementForParDo(WindowedValue<InputT> elem) {\n   }\n \n   private void processElementForPairWithRestriction(WindowedValue<InputT> elem) {\n+    currentElement = elem;\n+    try {\n+      currentRestriction = doFnInvoker.invokeGetInitialRestriction(processContext);\n+      outputTo(\n+          mainOutputConsumers,\n+          (WindowedValue)\n+              elem.withValue(\n+                  KV.of(\n+                      elem.getValue(),\n+                      KV.of(\n+                          currentRestriction,\n+                          doFnInvoker.invokeGetInitialWatermarkEstimatorState(processContext)))));\n+    } finally {\n+      currentElement = null;\n+      currentRestriction = null;", "originalCommit": "39292acb90443e9e643b656380e7fd62ed7a3020", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0Nzc4Mg==", "url": "https://github.com/apache/beam/pull/12093#discussion_r446447782", "bodyText": "It is never set/utilized in these methods and just remains null. All output is produced using the entire set of windows for the current element instead.\nThe window observing versions of these methods do set it and clear it.", "author": "lukecwik", "createdAt": "2020-06-26T23:13:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQxODM5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ3NTI2MA==", "url": "https://github.com/apache/beam/pull/12093#discussion_r446475260", "bodyText": "It seems like we should remove this duplicate part.", "author": "boyuanzz", "createdAt": "2020-06-27T02:51:06Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -488,60 +438,201 @@ public void accept(WindowedValue input) throws Exception {\n     this.doFnInvoker.invokeSetup();\n \n     this.startBundleArgumentProvider = new StartBundleArgumentProvider();\n+    // Register the appropriate handlers.\n+    switch (pTransform.getSpec().getUrn()) {\n+      case PTransformTranslation.PAR_DO_TRANSFORM_URN:\n+      case PTransformTranslation.SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN:\n+        startFunctionRegistry.register(pTransformId, this::startBundle);\n+        break;\n+      case PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN:\n+        // startBundle should not be invoked\n+      case PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN:\n+        // startBundle should not be invoked\n+      default:\n+        // no-op\n+    }\n+\n+    String mainInput;\n+    try {\n+      mainInput = ParDoTranslation.getMainInputName(pTransform);\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n+    final FnDataReceiver<WindowedValue> mainInputConsumer;\n+    switch (pTransform.getSpec().getUrn()) {\n+      case PTransformTranslation.PAR_DO_TRANSFORM_URN:\n+        if (doFnSignature.processElement().observesWindow() || !sideInputMapping.isEmpty()) {\n+          mainInputConsumer = this::processElementForWindowObservingParDo;\n+          this.processContext = new WindowObservingProcessBundleContext();\n+        } else {\n+          mainInputConsumer = this::processElementForParDo;\n+          this.processContext = new NonWindowObservingProcessBundleContext();\n+        }\n+        break;\n+      case PTransformTranslation.SPLITTABLE_PAIR_WITH_RESTRICTION_URN:\n+        if (doFnSignature.getInitialRestriction().observesWindow()\n+            || (doFnSignature.getInitialWatermarkEstimatorState() != null\n+                && doFnSignature.getInitialWatermarkEstimatorState().observesWindow())\n+            || !sideInputMapping.isEmpty()) {\n+          mainInputConsumer = this::processElementForWindowObservingPairWithRestriction;\n+          this.processContext = new WindowObservingProcessBundleContext();\n+        } else {\n+          mainInputConsumer = this::processElementForPairWithRestriction;\n+          this.processContext = new NonWindowObservingProcessBundleContext();\n+        }\n+        break;\n+      case PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN:\n+        if ((doFnSignature.splitRestriction() != null\n+                && doFnSignature.splitRestriction().observesWindow())\n+            || (doFnSignature.newTracker() != null && doFnSignature.newTracker().observesWindow())\n+            || (doFnSignature.getSize() != null && doFnSignature.getSize().observesWindow())\n+            || !sideInputMapping.isEmpty()) {\n+          mainInputConsumer = this::processElementForWindowObservingSplitRestriction;\n+          // OutputT == RestrictionT\n+          this.processContext =\n+              new WindowObservingProcessBundleContext() {\n+                @Override\n+                public void outputWithTimestamp(OutputT output, Instant timestamp) {\n+                  double size =\n+                      doFnInvoker.invokeGetSize(\n+                          new DelegatingArgumentProvider<InputT, OutputT>(\n+                              this,\n+                              PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN\n+                                  + \"/GetSize\") {\n+                            @Override\n+                            public Object restriction() {\n+                              return output;\n+                            }\n+\n+                            @Override\n+                            public Instant timestamp(DoFn<InputT, OutputT> doFn) {\n+                              return timestamp;\n+                            }\n+\n+                            @Override\n+                            public RestrictionTracker<?, ?> restrictionTracker() {\n+                              return doFnInvoker.invokeNewTracker(this);\n+                            }\n+                          });\n+\n+                  outputTo(\n+                      mainOutputConsumers,\n+                      (WindowedValue<OutputT>)\n+                          WindowedValue.of(\n+                              KV.of(\n+                                  KV.of(\n+                                      currentElement.getValue(),\n+                                      KV.of(output, currentWatermarkEstimatorState)),\n+                                  size),\n+                              timestamp,\n+                              currentWindow,\n+                              currentElement.getPane()));\n+                }\n+              };\n+        } else {\n+          mainInputConsumer = this::processElementForSplitRestriction;\n+          // OutputT == RestrictionT\n+          this.processContext =\n+              new NonWindowObservingProcessBundleContext() {\n+                @Override\n+                public void outputWithTimestamp(OutputT output, Instant timestamp) {\n+                  double size =\n+                      doFnInvoker.invokeGetSize(\n+                          new DelegatingArgumentProvider<InputT, OutputT>(\n+                              this,\n+                              PTransformTranslation.SPLITTABLE_SPLIT_AND_SIZE_RESTRICTIONS_URN\n+                                  + \"/GetSize\") {\n+                            @Override\n+                            public Object restriction() {\n+                              return output;\n+                            }\n+\n+                            @Override\n+                            public Instant timestamp(DoFn<InputT, OutputT> doFn) {\n+                              return timestamp;\n+                            }\n+\n+                            @Override\n+                            public RestrictionTracker<?, ?> restrictionTracker() {\n+                              return doFnInvoker.invokeNewTracker(this);\n+                            }\n+                          });\n+\n+                  outputTo(\n+                      mainOutputConsumers,\n+                      (WindowedValue<OutputT>)\n+                          WindowedValue.of(\n+                              KV.of(\n+                                  KV.of(\n+                                      currentElement.getValue(),\n+                                      KV.of(output, currentWatermarkEstimatorState)),\n+                                  size),\n+                              timestamp,\n+                              currentElement.getWindows(),\n+                              currentElement.getPane()));\n+                }\n+              };\n+        }\n+        break;\n+      case PTransformTranslation.SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN:\n+        if (doFnSignature.processElement().observesWindow()\n+            || (doFnSignature.newTracker() != null && doFnSignature.newTracker().observesWindow())\n+            || (doFnSignature.getSize() != null && doFnSignature.getSize().observesWindow())\n+            || (doFnSignature.newWatermarkEstimator() != null\n+                && doFnSignature.newWatermarkEstimator().observesWindow())\n+            || !sideInputMapping.isEmpty()) {\n+          mainInputConsumer =\n+              new SplittableFnDataReceiver() {\n+                @Override\n+                public void accept(WindowedValue input) throws Exception {\n+                  processElementForWindowObservingSizedElementAndRestriction(input);\n+                }\n+              };\n+          this.processContext = new WindowObservingProcessBundleContext();\n+        } else {\n+          mainInputConsumer =\n+              new SplittableFnDataReceiver() {\n+                @Override\n+                public void accept(WindowedValue input) throws Exception {\n+                  // TODO(BEAM-10303): Create a variant which is optimized to not observe the\n+                  // windows.\n+                  processElementForWindowObservingSizedElementAndRestriction(input);\n+                }\n+              };\n+          this.processContext = new WindowObservingProcessBundleContext();\n+        }\n+        break;\n+      default:\n+        throw new IllegalStateException(\"Unknown urn: \" + pTransform.getSpec().getUrn());\n+    }\n+    pCollectionConsumerRegistry.register(\n+        pTransform.getInputsOrThrow(mainInput), pTransformId, (FnDataReceiver) mainInputConsumer);\n+\n     switch (pTransform.getSpec().getUrn()) {", "originalCommit": "39292acb90443e9e643b656380e7fd62ed7a3020", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzExOTQ3Nw==", "url": "https://github.com/apache/beam/pull/12093#discussion_r447119477", "bodyText": "Thanks, I'll remove it in a follow-up.", "author": "lukecwik", "createdAt": "2020-06-29T17:00:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ3NTI2MA=="}], "type": "inlineReview"}]}