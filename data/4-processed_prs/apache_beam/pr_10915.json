{"pr_number": 10915, "pr_title": "[BEAM-8335] Add PCollection to DataFrame logic for InteractiveRunner.", "pr_createdAt": "2020-02-20T18:18:42Z", "pr_url": "https://github.com/apache/beam/pull/10915", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE4MTEwMA==", "url": "https://github.com/apache/beam/pull/10915#discussion_r382181100", "bodyText": "nit: remove extra space", "author": "KevinGG", "createdAt": "2020-02-20T18:32:20Z", "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,113 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.", "originalCommit": "302ce72f9bae5969bff837d209b62ca26a9fe5e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE4NTEzMQ==", "url": "https://github.com/apache/beam/pull/10915#discussion_r382185131", "bodyText": "Yapf puts that space there", "author": "rohdesamuel", "createdAt": "2020-02-20T18:40:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE4MTEwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc5NDI5MA==", "url": "https://github.com/apache/beam/pull/10915#discussion_r386794290", "bodyText": "Sorry, I missed this before merging. I think the extra space was \"in[space][space]Interactive\", not the whitespace that yapf inserted.", "author": "robertwb", "createdAt": "2020-03-03T04:32:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE4MTEwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE4MjAxNw==", "url": "https://github.com/apache/beam/pull/10915#discussion_r382182017", "bodyText": "nit: can this just be prefix?", "author": "KevinGG", "createdAt": "2020-02-20T18:34:03Z", "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,113 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import pandas as pd\n+\n+from apache_beam.typehints import typehints as th\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+COLUMN_PREFIX = 'el'\n+\n+\n+def parse_row_(el, element_type, depth):\n+  elements = []\n+  columns = []\n+\n+  # Recurse if there are a known length of columns to parse into.\n+  if isinstance(element_type, (th.TupleHint.TupleConstraint)):\n+    for index, t in enumerate(element_type._inner_types()):\n+      underlying_columns, underlying_elements = parse_row_(el[index], t,\n+                                                           depth + 1)\n+      column = '[{}]'.format(index)\n+      if underlying_columns:\n+        columns += [column + c for c in underlying_columns]\n+      else:\n+        columns += [column]\n+      elements += underlying_elements\n+\n+  # Don't make new columns for variable length types.\n+  elif isinstance(\n+      element_type,\n+      (th.ListHint.ListConstraint, th.TupleHint.TupleSequenceConstraint)):\n+    elements = [pd.array(el)]\n+\n+  # For any other types, try to parse as a namedtuple, otherwise pass element\n+  # through.\n+  else:\n+    fields = getattr(el, '_fields', None)\n+    if fields:\n+      columns = list(fields)\n+      if depth > 0:\n+        columns = ['[{}]'.format(f) for f in fields]\n+      elements = [el._asdict()[f] for f in fields]\n+    else:\n+      elements = [el]\n+  return columns, elements\n+\n+\n+def parse_row(el, element_type, include_window_info=True, prefix=COLUMN_PREFIX):\n+  # Reify the WindowedValue data to the Dataframe if asked.\n+  windowed = None\n+  if isinstance(el, WindowedValue):\n+    if include_window_info:\n+      windowed = el\n+    el = el.value\n+\n+  # Parse the elements with the given type.\n+  columns, elements = parse_row_(el, element_type, 0)\n+\n+  # If there are no columns returned, there is only a single column of a\n+  # primitive data type.\n+  if not columns:\n+    columns = ['']\n+\n+  # Add the prefix to the columns that have an index.\n+  for i in range(len(columns)):\n+    if columns[i] == '' or columns[i][0] == '[':\n+      columns[i] = prefix + columns[i]\n+\n+  # Reify the windowed columns and do a best-effort casting into Pandas DTypes.\n+  if windowed:\n+    columns += ['event_time', 'windows', 'pane_info']\n+    elements += [\n+        windowed.timestamp.micros, windowed.windows, windowed.pane_info\n+    ]\n+  return columns, elements\n+\n+\n+def pcoll_to_df(\n+    elements, element_type, include_window_info=False, prefix=COLUMN_PREFIX):\n+  \"\"\"Parses the given elements into a Dataframe.\n+\n+  Each column name will be prefixed with `prefix` concatenated with the nested\n+  index, e.g. for a Tuple[Tuple[int, str], int], the column names will be:\n+  [prefix[0][0], prefix[0][1], prefix[0]]. This is subject to change.\n+  \"\"\"\n+  rows = []\n+  columns = []\n+\n+  for e in elements:\n+    columns, row = parse_row(e, element_type, include_window_info,\n+                             prefix=prefix)", "originalCommit": "302ce72f9bae5969bff837d209b62ca26a9fe5e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE4NTIwOA==", "url": "https://github.com/apache/beam/pull/10915#discussion_r382185208", "bodyText": "Done", "author": "rohdesamuel", "createdAt": "2020-02-20T18:40:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE4MjAxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE4MjcwMA==", "url": "https://github.com/apache/beam/pull/10915#discussion_r382182700", "bodyText": "Can the tests be assigned meaningful names? Also test_parse_5 occurred twice.", "author": "KevinGG", "createdAt": "2020-02-20T18:35:25Z", "path": "sdks/python/apache_beam/runners/interactive/utils_test.py", "diffHunk": "@@ -0,0 +1,138 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from __future__ import absolute_import\n+\n+import unittest\n+\n+import pandas as pd\n+\n+from apache_beam.runners.interactive import utils\n+from apache_beam.typehints.typehints import Any\n+from apache_beam.typehints.typehints import Dict\n+from apache_beam.typehints.typehints import List\n+from apache_beam.typehints.typehints import Tuple\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+\n+class ParseToDataframeTest(unittest.TestCase):\n+  def test_parse_1(self):\n+    el = (1, 'a')\n+    element_type = Tuple[int, str]\n+\n+    columns, elements = utils.parse_row(el, element_type)\n+    self.assertEqual(columns, ['el[0]', 'el[1]'])\n+    self.assertEqual(elements, [1, 'a'])\n+\n+  def test_parse_2(self):\n+    el = ((1, 2.0, 'a'), 'b')\n+    element_type = Tuple[Tuple[int, float, str], str]\n+\n+    columns, elements = utils.parse_row(el, element_type)\n+    self.assertEqual(columns, ['el[0][0]', 'el[0][1]', 'el[0][2]', 'el[1]'])\n+    self.assertEqual(elements, [1, 2.0, 'a', 'b'])\n+\n+  def test_parse_3(self):\n+    el = [1, 2, 3]\n+    element_type = List[int]\n+\n+    columns, elements = utils.parse_row(el, element_type)\n+    self.assertEqual(columns, ['el'])\n+    self.assertEqual(elements, [[1, 2, 3]])\n+\n+  def test_parse_4(self):\n+    el = ('k', [1, 2, 3])\n+    element_type = Tuple[str, List[int]]\n+\n+    columns, elements = utils.parse_row(el, element_type)\n+    self.assertEqual(columns, ['el[0]', 'el[1]'])\n+    self.assertEqual(elements, ['k', [1, 2, 3]])\n+\n+  def test_parse_5(self):\n+    el = (([1, 2, 3], {'b': 1, 'c': 2}), 'a')\n+    element_type = Tuple[Tuple[List[int], Dict[str, int]], str]\n+\n+    columns, elements = utils.parse_row(el, element_type)\n+    self.assertEqual(columns, ['el[0][0]', 'el[0][1]', 'el[1]'])\n+    self.assertEqual(elements, [[1, 2, 3], {'b': 1, 'c': 2}, 'a'])\n+\n+  def test_parse_5(self):", "originalCommit": "302ce72f9bae5969bff837d209b62ca26a9fe5e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE4NTI2Mw==", "url": "https://github.com/apache/beam/pull/10915#discussion_r382185263", "bodyText": "Done", "author": "rohdesamuel", "createdAt": "2020-02-20T18:40:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE4MjcwMA=="}], "type": "inlineReview"}, {"oid": "083723a5b17fc3b24225d92d2b3e6cb9a9122606", "url": "https://github.com/apache/beam/commit/083723a5b17fc3b24225d92d2b3e6cb9a9122606", "message": "[BEAM-8335] Add PCollection to Dataframe logic for InteractiveRunner.\n\nChange-Id: I180c5da914da3e7d5830d3272b2bb6587fd338b2", "committedDate": "2020-02-20T18:38:17Z", "type": "commit"}, {"oid": "083723a5b17fc3b24225d92d2b3e6cb9a9122606", "url": "https://github.com/apache/beam/commit/083723a5b17fc3b24225d92d2b3e6cb9a9122606", "message": "[BEAM-8335] Add PCollection to Dataframe logic for InteractiveRunner.\n\nChange-Id: I180c5da914da3e7d5830d3272b2bb6587fd338b2", "committedDate": "2020-02-20T18:38:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA4NjI4MA==", "url": "https://github.com/apache/beam/pull/10915#discussion_r384086280", "bodyText": "The convention in Python is to put the underscore before for a private method. Also, I'd call this \"_parse_row_internal\" or similar to make it easier to read. And at least a one-line docstring explaining what the intent of this function is.", "author": "robertwb", "createdAt": "2020-02-25T19:45:16Z", "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,112 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import pandas as pd\n+\n+from apache_beam.typehints import typehints as th\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+COLUMN_PREFIX = 'el'\n+\n+\n+def parse_row_(el, element_type, depth):", "originalCommit": "083723a5b17fc3b24225d92d2b3e6cb9a9122606", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5MTkxOA==", "url": "https://github.com/apache/beam/pull/10915#discussion_r384891918", "bodyText": "Ack, I changed the name to just parse_row (because I use it in tests).", "author": "rohdesamuel", "createdAt": "2020-02-27T03:12:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA4NjI4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA4OTExOQ==", "url": "https://github.com/apache/beam/pull/10915#discussion_r384089119", "bodyText": "We typically use e or elt for abbreviating element. el evokes either the letter L (making it hard to read aloud/talk about) or the hebrew Deity. This goes for the variable names below as well.", "author": "robertwb", "createdAt": "2020-02-25T19:50:34Z", "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,112 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import pandas as pd\n+\n+from apache_beam.typehints import typehints as th\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+COLUMN_PREFIX = 'el'", "originalCommit": "083723a5b17fc3b24225d92d2b3e6cb9a9122606", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5MTk1Ng==", "url": "https://github.com/apache/beam/pull/10915#discussion_r384891956", "bodyText": "Ack, changed to elt", "author": "rohdesamuel", "createdAt": "2020-02-27T03:12:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA4OTExOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5MDg4OA==", "url": "https://github.com/apache/beam/pull/10915#discussion_r384090888", "bodyText": "https://engdoc.corp.google.com/eng/doc/devguide/py/totw/026.md?cl=head", "author": "robertwb", "createdAt": "2020-02-25T19:53:37Z", "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,112 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import pandas as pd\n+\n+from apache_beam.typehints import typehints as th\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+COLUMN_PREFIX = 'el'\n+\n+\n+def parse_row_(el, element_type, depth):\n+  elements = []\n+  columns = []\n+\n+  # Recurse if there are a known length of columns to parse into.\n+  if isinstance(element_type, (th.TupleHint.TupleConstraint)):\n+    for index, t in enumerate(element_type._inner_types()):\n+      underlying_columns, underlying_elements = parse_row_(el[index], t,\n+                                                           depth + 1)\n+      column = '[{}]'.format(index)\n+      if underlying_columns:\n+        columns += [column + c for c in underlying_columns]\n+      else:\n+        columns += [column]\n+      elements += underlying_elements\n+\n+  # Don't make new columns for variable length types.\n+  elif isinstance(\n+      element_type,\n+      (th.ListHint.ListConstraint, th.TupleHint.TupleSequenceConstraint)):\n+    elements = [pd.array(el)]\n+\n+  # For any other types, try to parse as a namedtuple, otherwise pass element\n+  # through.\n+  else:\n+    fields = getattr(el, '_fields', None)\n+    if fields:\n+      columns = list(fields)", "originalCommit": "083723a5b17fc3b24225d92d2b3e6cb9a9122606", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5MzU0Mw==", "url": "https://github.com/apache/beam/pull/10915#discussion_r384893543", "bodyText": "I still need to take a look in my code to see if anything violates this, I'll let you know.", "author": "rohdesamuel", "createdAt": "2020-02-27T03:19:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5MDg4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5MzQ3Mw==", "url": "https://github.com/apache/beam/pull/10915#discussion_r384093473", "bodyText": "Doing an isinstance check would be preferable to checking a private variable.", "author": "robertwb", "createdAt": "2020-02-25T19:58:24Z", "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,112 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import pandas as pd\n+\n+from apache_beam.typehints import typehints as th\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+COLUMN_PREFIX = 'el'\n+\n+\n+def parse_row_(el, element_type, depth):\n+  elements = []\n+  columns = []\n+\n+  # Recurse if there are a known length of columns to parse into.\n+  if isinstance(element_type, (th.TupleHint.TupleConstraint)):\n+    for index, t in enumerate(element_type._inner_types()):\n+      underlying_columns, underlying_elements = parse_row_(el[index], t,\n+                                                           depth + 1)\n+      column = '[{}]'.format(index)\n+      if underlying_columns:\n+        columns += [column + c for c in underlying_columns]\n+      else:\n+        columns += [column]\n+      elements += underlying_elements\n+\n+  # Don't make new columns for variable length types.\n+  elif isinstance(\n+      element_type,\n+      (th.ListHint.ListConstraint, th.TupleHint.TupleSequenceConstraint)):\n+    elements = [pd.array(el)]\n+\n+  # For any other types, try to parse as a namedtuple, otherwise pass element\n+  # through.\n+  else:\n+    fields = getattr(el, '_fields', None)", "originalCommit": "083723a5b17fc3b24225d92d2b3e6cb9a9122606", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5MjEwMg==", "url": "https://github.com/apache/beam/pull/10915#discussion_r384892102", "bodyText": "Unfortunately this is the way to check if it is a named tuple.", "author": "rohdesamuel", "createdAt": "2020-02-27T03:12:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5MzQ3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5MzY2OA==", "url": "https://github.com/apache/beam/pull/10915#discussion_r384093668", "bodyText": "getattr(el, f) would be more natural. Or just list(elt) as the fields should be in the proper order.", "author": "robertwb", "createdAt": "2020-02-25T19:58:47Z", "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,112 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import pandas as pd\n+\n+from apache_beam.typehints import typehints as th\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+COLUMN_PREFIX = 'el'\n+\n+\n+def parse_row_(el, element_type, depth):\n+  elements = []\n+  columns = []\n+\n+  # Recurse if there are a known length of columns to parse into.\n+  if isinstance(element_type, (th.TupleHint.TupleConstraint)):\n+    for index, t in enumerate(element_type._inner_types()):\n+      underlying_columns, underlying_elements = parse_row_(el[index], t,\n+                                                           depth + 1)\n+      column = '[{}]'.format(index)\n+      if underlying_columns:\n+        columns += [column + c for c in underlying_columns]\n+      else:\n+        columns += [column]\n+      elements += underlying_elements\n+\n+  # Don't make new columns for variable length types.\n+  elif isinstance(\n+      element_type,\n+      (th.ListHint.ListConstraint, th.TupleHint.TupleSequenceConstraint)):\n+    elements = [pd.array(el)]\n+\n+  # For any other types, try to parse as a namedtuple, otherwise pass element\n+  # through.\n+  else:\n+    fields = getattr(el, '_fields', None)\n+    if fields:\n+      columns = list(fields)\n+      if depth > 0:\n+        columns = ['[{}]'.format(f) for f in fields]\n+      elements = [el._asdict()[f] for f in fields]", "originalCommit": "083723a5b17fc3b24225d92d2b3e6cb9a9122606", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5MjI4OQ==", "url": "https://github.com/apache/beam/pull/10915#discussion_r384892289", "bodyText": "This code was removed in a recent commit, but ack on getattr being more natural", "author": "rohdesamuel", "createdAt": "2020-02-27T03:13:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5MzY2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5NjA5Mg==", "url": "https://github.com/apache/beam/pull/10915#discussion_r384096092", "bodyText": "I would suggest having a format column.field.0.1. I think this could simplify your code quite a bit (e.g. you could only have one parse_row that recursively calls itself with an increasingly longer prefix). (As a bonus, easier on the eyes.)", "author": "robertwb", "createdAt": "2020-02-25T20:03:41Z", "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,112 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import pandas as pd\n+\n+from apache_beam.typehints import typehints as th\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+COLUMN_PREFIX = 'el'\n+\n+\n+def parse_row_(el, element_type, depth):\n+  elements = []\n+  columns = []\n+\n+  # Recurse if there are a known length of columns to parse into.\n+  if isinstance(element_type, (th.TupleHint.TupleConstraint)):\n+    for index, t in enumerate(element_type._inner_types()):\n+      underlying_columns, underlying_elements = parse_row_(el[index], t,\n+                                                           depth + 1)\n+      column = '[{}]'.format(index)\n+      if underlying_columns:\n+        columns += [column + c for c in underlying_columns]\n+      else:\n+        columns += [column]\n+      elements += underlying_elements\n+\n+  # Don't make new columns for variable length types.\n+  elif isinstance(\n+      element_type,\n+      (th.ListHint.ListConstraint, th.TupleHint.TupleSequenceConstraint)):\n+    elements = [pd.array(el)]\n+\n+  # For any other types, try to parse as a namedtuple, otherwise pass element\n+  # through.\n+  else:\n+    fields = getattr(el, '_fields', None)\n+    if fields:\n+      columns = list(fields)\n+      if depth > 0:\n+        columns = ['[{}]'.format(f) for f in fields]\n+      elements = [el._asdict()[f] for f in fields]\n+    else:\n+      elements = [el]\n+  return columns, elements\n+\n+\n+def parse_row(el, element_type, include_window_info=True, prefix=COLUMN_PREFIX):\n+  # Reify the WindowedValue data to the Dataframe if asked.\n+  windowed = None\n+  if isinstance(el, WindowedValue):\n+    if include_window_info:\n+      windowed = el\n+    el = el.value\n+\n+  # Parse the elements with the given type.\n+  columns, elements = parse_row_(el, element_type, 0)\n+\n+  # If there are no columns returned, there is only a single column of a\n+  # primitive data type.\n+  if not columns:\n+    columns = ['']\n+\n+  # Add the prefix to the columns that have an index.\n+  for i in range(len(columns)):\n+    if columns[i] == '' or columns[i][0] == '[':\n+      columns[i] = prefix + columns[i]\n+\n+  # Reify the windowed columns and do a best-effort casting into Pandas DTypes.\n+  if windowed:\n+    columns += ['event_time', 'windows', 'pane_info']\n+    elements += [\n+        windowed.timestamp.micros, windowed.windows, windowed.pane_info\n+    ]\n+  return columns, elements\n+\n+\n+def pcoll_to_df(\n+    elements, element_type, include_window_info=False, prefix=COLUMN_PREFIX):\n+  \"\"\"Parses the given elements into a Dataframe.\n+\n+  Each column name will be prefixed with `prefix` concatenated with the nested\n+  index, e.g. for a Tuple[Tuple[int, str], int], the column names will be:\n+  [prefix[0][0], prefix[0][1], prefix[0]]. This is subject to change.", "originalCommit": "083723a5b17fc3b24225d92d2b3e6cb9a9122606", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5MjM0Mg==", "url": "https://github.com/apache/beam/pull/10915#discussion_r384892342", "bodyText": "ack, changed to dots (much simpler)", "author": "rohdesamuel", "createdAt": "2020-02-27T03:13:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5NjA5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5NzUzNg==", "url": "https://github.com/apache/beam/pull/10915#discussion_r384097536", "bodyText": "When can columns[i] be the empty string? Also, when would it not be []. There seems to be an off-by-one to have to handle the base case in both the caller and the callee.", "author": "robertwb", "createdAt": "2020-02-25T20:06:45Z", "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,112 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import pandas as pd\n+\n+from apache_beam.typehints import typehints as th\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+COLUMN_PREFIX = 'el'\n+\n+\n+def parse_row_(el, element_type, depth):\n+  elements = []\n+  columns = []\n+\n+  # Recurse if there are a known length of columns to parse into.\n+  if isinstance(element_type, (th.TupleHint.TupleConstraint)):\n+    for index, t in enumerate(element_type._inner_types()):\n+      underlying_columns, underlying_elements = parse_row_(el[index], t,\n+                                                           depth + 1)\n+      column = '[{}]'.format(index)\n+      if underlying_columns:\n+        columns += [column + c for c in underlying_columns]\n+      else:\n+        columns += [column]\n+      elements += underlying_elements\n+\n+  # Don't make new columns for variable length types.\n+  elif isinstance(\n+      element_type,\n+      (th.ListHint.ListConstraint, th.TupleHint.TupleSequenceConstraint)):\n+    elements = [pd.array(el)]\n+\n+  # For any other types, try to parse as a namedtuple, otherwise pass element\n+  # through.\n+  else:\n+    fields = getattr(el, '_fields', None)\n+    if fields:\n+      columns = list(fields)\n+      if depth > 0:\n+        columns = ['[{}]'.format(f) for f in fields]\n+      elements = [el._asdict()[f] for f in fields]\n+    else:\n+      elements = [el]\n+  return columns, elements\n+\n+\n+def parse_row(el, element_type, include_window_info=True, prefix=COLUMN_PREFIX):\n+  # Reify the WindowedValue data to the Dataframe if asked.\n+  windowed = None\n+  if isinstance(el, WindowedValue):\n+    if include_window_info:\n+      windowed = el\n+    el = el.value\n+\n+  # Parse the elements with the given type.\n+  columns, elements = parse_row_(el, element_type, 0)\n+\n+  # If there are no columns returned, there is only a single column of a\n+  # primitive data type.\n+  if not columns:\n+    columns = ['']\n+\n+  # Add the prefix to the columns that have an index.\n+  for i in range(len(columns)):\n+    if columns[i] == '' or columns[i][0] == '[':", "originalCommit": "083723a5b17fc3b24225d92d2b3e6cb9a9122606", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5MjM3Nw==", "url": "https://github.com/apache/beam/pull/10915#discussion_r384892377", "bodyText": "This code was removed in a recent commit.", "author": "rohdesamuel", "createdAt": "2020-02-27T03:14:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5NzUzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5Nzk2MA==", "url": "https://github.com/apache/beam/pull/10915#discussion_r384097960", "bodyText": "Would it be better to infer the schema once, then apply all rows, rather than re-parse it for every element? (Also, that way you could correctly detect/handle if the schema is not consistent, e.g. tuples of varying length.)", "author": "robertwb", "createdAt": "2020-02-25T20:07:39Z", "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,112 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import pandas as pd\n+\n+from apache_beam.typehints import typehints as th\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+COLUMN_PREFIX = 'el'\n+\n+\n+def parse_row_(el, element_type, depth):\n+  elements = []\n+  columns = []\n+\n+  # Recurse if there are a known length of columns to parse into.\n+  if isinstance(element_type, (th.TupleHint.TupleConstraint)):\n+    for index, t in enumerate(element_type._inner_types()):\n+      underlying_columns, underlying_elements = parse_row_(el[index], t,\n+                                                           depth + 1)\n+      column = '[{}]'.format(index)\n+      if underlying_columns:\n+        columns += [column + c for c in underlying_columns]\n+      else:\n+        columns += [column]\n+      elements += underlying_elements\n+\n+  # Don't make new columns for variable length types.\n+  elif isinstance(\n+      element_type,\n+      (th.ListHint.ListConstraint, th.TupleHint.TupleSequenceConstraint)):\n+    elements = [pd.array(el)]\n+\n+  # For any other types, try to parse as a namedtuple, otherwise pass element\n+  # through.\n+  else:\n+    fields = getattr(el, '_fields', None)\n+    if fields:\n+      columns = list(fields)\n+      if depth > 0:\n+        columns = ['[{}]'.format(f) for f in fields]\n+      elements = [el._asdict()[f] for f in fields]\n+    else:\n+      elements = [el]\n+  return columns, elements\n+\n+\n+def parse_row(el, element_type, include_window_info=True, prefix=COLUMN_PREFIX):\n+  # Reify the WindowedValue data to the Dataframe if asked.\n+  windowed = None\n+  if isinstance(el, WindowedValue):\n+    if include_window_info:\n+      windowed = el\n+    el = el.value\n+\n+  # Parse the elements with the given type.\n+  columns, elements = parse_row_(el, element_type, 0)\n+\n+  # If there are no columns returned, there is only a single column of a\n+  # primitive data type.\n+  if not columns:\n+    columns = ['']\n+\n+  # Add the prefix to the columns that have an index.\n+  for i in range(len(columns)):\n+    if columns[i] == '' or columns[i][0] == '[':\n+      columns[i] = prefix + columns[i]\n+\n+  # Reify the windowed columns and do a best-effort casting into Pandas DTypes.\n+  if windowed:\n+    columns += ['event_time', 'windows', 'pane_info']\n+    elements += [\n+        windowed.timestamp.micros, windowed.windows, windowed.pane_info\n+    ]\n+  return columns, elements\n+\n+\n+def pcoll_to_df(\n+    elements, element_type, include_window_info=False, prefix=COLUMN_PREFIX):\n+  \"\"\"Parses the given elements into a Dataframe.\n+\n+  Each column name will be prefixed with `prefix` concatenated with the nested\n+  index, e.g. for a Tuple[Tuple[int, str], int], the column names will be:\n+  [prefix[0][0], prefix[0][1], prefix[0]]. This is subject to change.\n+  \"\"\"\n+  rows = []\n+  columns = []\n+\n+  for e in elements:\n+    columns, row = parse_row(e, element_type, include_window_info, prefix)", "originalCommit": "083723a5b17fc3b24225d92d2b3e6cb9a9122606", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5MjQzNg==", "url": "https://github.com/apache/beam/pull/10915#discussion_r384892436", "bodyText": "Changed to inferring the schema once.", "author": "rohdesamuel", "createdAt": "2020-02-27T03:14:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5Nzk2MA=="}], "type": "inlineReview"}, {"oid": "10d1803d9349c23e9ec15c86b74c7600e7256851", "url": "https://github.com/apache/beam/commit/10d1803d9349c23e9ec15c86b74c7600e7256851", "message": "remove nested logic. Only create columns for tuples and named tuples that have known fixed lengths.\n\nChange-Id: I284ab4a2b4d097843fcdecddab432617d222837a", "committedDate": "2020-02-28T18:21:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU5MTgxOA==", "url": "https://github.com/apache/beam/pull/10915#discussion_r386591818", "bodyText": "Remove this case.", "author": "robertwb", "createdAt": "2020-03-02T19:10:20Z", "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,55 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import pandas as pd\n+\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+\n+def elements_to_df(elements, include_window_info=False):\n+  \"\"\"Parses the given elements into a Dataframe.\n+\n+  If the elements are a list of `WindowedValue`s, then it will break out the\n+  elements into their own DataFrame and return it. If include_window_info is\n+  True, then it will concatenate the windowing information onto the elements\n+  DataFrame.\n+  \"\"\"\n+\n+  rows = []\n+  windowed_values = []\n+  for e in elements:\n+    if isinstance(e, WindowedValue):\n+      rows.append(e.value)\n+    else:\n+      rows.append(e)", "originalCommit": "10d1803d9349c23e9ec15c86b74c7600e7256851", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY0NjY5MA==", "url": "https://github.com/apache/beam/pull/10915#discussion_r386646690", "bodyText": "Done", "author": "rohdesamuel", "createdAt": "2020-03-02T20:59:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU5MTgxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU5MjAwNQ==", "url": "https://github.com/apache/beam/pull/10915#discussion_r386592005", "bodyText": "windowing_info? (windowed_values sounds like it has the values themselves).", "author": "robertwb", "createdAt": "2020-03-02T19:10:43Z", "path": "sdks/python/apache_beam/runners/interactive/utils.py", "diffHunk": "@@ -0,0 +1,55 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Utilities to be used in  Interactive Beam.\n+\"\"\"\n+\n+from __future__ import absolute_import\n+\n+import pandas as pd\n+\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+\n+def elements_to_df(elements, include_window_info=False):\n+  \"\"\"Parses the given elements into a Dataframe.\n+\n+  If the elements are a list of `WindowedValue`s, then it will break out the\n+  elements into their own DataFrame and return it. If include_window_info is\n+  True, then it will concatenate the windowing information onto the elements\n+  DataFrame.\n+  \"\"\"\n+\n+  rows = []\n+  windowed_values = []", "originalCommit": "10d1803d9349c23e9ec15c86b74c7600e7256851", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY0Njc1Nw==", "url": "https://github.com/apache/beam/pull/10915#discussion_r386646757", "bodyText": "Changed to \"windowing_info\"", "author": "rohdesamuel", "createdAt": "2020-03-02T20:59:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU5MjAwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU5MjI2NA==", "url": "https://github.com/apache/beam/pull/10915#discussion_r386592264", "bodyText": "Remove tests that don't test our code.", "author": "robertwb", "createdAt": "2020-03-02T19:11:08Z", "path": "sdks/python/apache_beam/runners/interactive/utils_test.py", "diffHunk": "@@ -0,0 +1,182 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#  http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from __future__ import absolute_import\n+\n+import unittest\n+\n+import numpy as np\n+import pandas as pd\n+\n+from apache_beam.runners.interactive import utils\n+from apache_beam.utils.windowed_value import WindowedValue\n+\n+\n+class ParseToDataframeTest(unittest.TestCase):", "originalCommit": "10d1803d9349c23e9ec15c86b74c7600e7256851", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY0Njg5MA==", "url": "https://github.com/apache/beam/pull/10915#discussion_r386646890", "bodyText": "Ack, kept tests that test the WindowValue cases.", "author": "rohdesamuel", "createdAt": "2020-03-02T21:00:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU5MjI2NA=="}], "type": "inlineReview"}, {"oid": "124f6ecacba03d6aea775fc595e761b1d45e5919", "url": "https://github.com/apache/beam/commit/124f6ecacba03d6aea775fc595e761b1d45e5919", "message": "remove nested logic. Only create columns for tuples and named tuples that have known fixed lengths.\n\nChange-Id: I284ab4a2b4d097843fcdecddab432617d222837a", "committedDate": "2020-03-02T20:58:47Z", "type": "commit"}, {"oid": "124f6ecacba03d6aea775fc595e761b1d45e5919", "url": "https://github.com/apache/beam/commit/124f6ecacba03d6aea775fc595e761b1d45e5919", "message": "remove nested logic. Only create columns for tuples and named tuples that have known fixed lengths.\n\nChange-Id: I284ab4a2b4d097843fcdecddab432617d222837a", "committedDate": "2020-03-02T20:58:47Z", "type": "forcePushed"}]}