{"pr_number": 11205, "pr_title": "[BEAM-9578] Enumerating artifacts is too expensive in Java", "pr_createdAt": "2020-03-24T09:36:37Z", "pr_url": "https://github.com/apache/beam/pull/11205", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ1ODk0MA==", "url": "https://github.com/apache/beam/pull/11205#discussion_r400458940", "bodyText": "It doesn't seem like we are populating sha256 here.", "author": "lukecwik", "createdAt": "2020-03-30T20:02:18Z", "path": "model/pipeline/src/main/proto/beam_runner_api.proto", "diffHunk": "@@ -1146,33 +1146,41 @@ message StandardArtifacts {\n   enum Types {\n     // A URN for locally-accessible artifact files.\n     // payload: ArtifactFilePayload\n-    FILE     = 0 [(beam_urn) = \"beam:artifact:type:file:v1\"];\n+    FILE      = 0 [(beam_urn) = \"beam:artifact:type:file:v1\"];\n \n     // A URN for artifacts described by URLs.\n     // payload: ArtifactUrlPayload\n-    URL      = 1 [(beam_urn) = \"beam:artifact:type:url:v1\"];\n+    URL       = 1 [(beam_urn) = \"beam:artifact:type:url:v1\"];\n \n     // A URN for artifacts embedded in ArtifactInformation proto.\n     // payload: EmbeddedFilePayload.\n-    EMBEDDED = 2 [(beam_urn) = \"beam:artifact:type:embedded:v1\"];\n+    EMBEDDED  = 2 [(beam_urn) = \"beam:artifact:type:embedded:v1\"];\n \n     // A URN for Python artifacts hosted on PYPI.\n     // payload: PypiPayload\n-    PYPI     = 3 [(beam_urn) = \"beam:artifact:type:pypi:v1\"];\n+    PYPI      = 3 [(beam_urn) = \"beam:artifact:type:pypi:v1\"];\n \n     // A URN for Java artifacts hosted on a Maven repository.\n     // payload: MavenPayload\n-    MAVEN    = 4 [(beam_urn) = \"beam:artifact:type:maven:v1\"];\n+    MAVEN     = 4 [(beam_urn) = \"beam:artifact:type:maven:v1\"];\n+\n+    // A URN for locally-accessible artifact directory.\n+    // payload: ArtifactDirectoryPayload\n+    DIRECTORY = 5 [(beam_urn) = \"beam:artifact:type:directory:v1\"];\n   }\n   enum Roles {\n     // A URN for staging-to role.\n     // payload: ArtifactStagingToRolePayload\n     STAGING_TO  = 0 [(beam_urn) = \"beam:artifact:role:staging_to:v1\"];\n+\n+    // A URN for unzip-to role.\n+    // payload: ArtifactUnzipToRolePayload\n+    UNZIP_TO    = 1 [(beam_urn) = \"beam:artifact:role:unzip_to:v1\"];\n   }\n }\n \n message ArtifactFilePayload {\n-  // a string for an artifact path e.g. \"/tmp/foo.jar\"\n+  // a string for an artifact file path e.g. \"/tmp/foo.jar\"\n   string path = 1;\n \n   // The hex-encoded sha256 checksum of the artifact.", "originalCommit": "bd7452a6088b350c43a95175438cce704966cfd9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkzMDc4NA==", "url": "https://github.com/apache/beam/pull/11205#discussion_r401930784", "bodyText": "adding deferred artifacts and populating sha256.", "author": "ihji", "createdAt": "2020-04-01T21:49:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ1ODk0MA=="}], "type": "inlineReview"}, {"oid": "e62888a6aad537fecf47f1a9eb666adcf51d8aae", "url": "https://github.com/apache/beam/commit/e62888a6aad537fecf47f1a9eb666adcf51d8aae", "message": "deferred artifact and resolver sketch", "committedDate": "2020-04-01T10:05:16Z", "type": "forcePushed"}, {"oid": "ce2aa58c1bd13df476234b42365456242172e928", "url": "https://github.com/apache/beam/commit/ce2aa58c1bd13df476234b42365456242172e928", "message": "deferred artifact and resolver sketch", "committedDate": "2020-04-01T20:09:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ3NDYwOA==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402474608", "bodyText": "I was under the impression we were going to make this a bytes field so that any deferred information can get passed through and then back to the creator whether it be an id or a serialized blob of objects or ...\nAllowing for bytes enables for solutions beyond in memory maps.", "author": "lukecwik", "createdAt": "2020-04-02T17:11:44Z", "path": "model/pipeline/src/main/proto/beam_runner_api.proto", "diffHunk": "@@ -1206,6 +1210,11 @@ message MavenPayload {\n   string repository_url = 2;\n }\n \n+message DeferredArtifactPayload {\n+  // A id for deferred artifacts.\n+  string id = 1;", "originalCommit": "3e9af32625859bdfdb5da4bf18b5f4f4bf1d26bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ5MjA0NA==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402492044", "bodyText": "+1", "author": "robertwb", "createdAt": "2020-04-02T17:35:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ3NDYwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NTc3OA==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402685778", "bodyText": "Don't we need at least a key field (or urn or identifier) which can be used to check whether the payload is parsable by the creator? Otherwise, it would be pretty hard to know where the bytes payload originally came from.", "author": "ihji", "createdAt": "2020-04-03T01:23:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ3NDYwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY5ODc1Mg==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402698752", "bodyText": "Thats a good point about the key and in general this will become a problem for all artifacts since none of them have unique keys associated with them unless an intermediary resolves the artifact immediately and possibly \"renames\" the contents to make it unique.\nIf we ever want to support multiple layers of expansion for XLang we'll want to proxy any artifact resolution/retrieval calls through the layers and not require each layer to have a copy of the artifact.", "author": "lukecwik", "createdAt": "2020-04-03T02:15:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ3NDYwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQwMjk1OQ==", "url": "https://github.com/apache/beam/pull/11205#discussion_r403402959", "bodyText": "As discussed (but putting here for the record) having a proxy artifact type could solve this issue.", "author": "robertwb", "createdAt": "2020-04-04T01:12:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ3NDYwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ3NjUwMg==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402476502", "bodyText": "We won't need to rely on using Optional if we make registration take a URN and ResolutionFn and then the resolver can be found by URN.", "author": "lukecwik", "createdAt": "2020-04-02T17:14:47Z", "path": "runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/ArtifactResolver.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.core.construction;\n+\n+import java.util.Optional;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+\n+public interface ArtifactResolver {\n+  void register(ResolutionFn fn);", "originalCommit": "3e9af32625859bdfdb5da4bf18b5f4f4bf1d26bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ5NDc2OA==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402494768", "bodyText": "I agree. However, this might be more limited. E.g. one could have a more than one resolver per type, each of which can only resolve a subset, or alternatively one could want to resolve more than one type (or any type), e.g. a proxying resolver.", "author": "robertwb", "createdAt": "2020-04-02T17:39:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ3NjUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ3NzM4OQ==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402477389", "bodyText": "Please add comments to this class and methods.", "author": "lukecwik", "createdAt": "2020-04-02T17:16:19Z", "path": "runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/ArtifactResolver.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.core.construction;\n+\n+import java.util.Optional;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+\n+public interface ArtifactResolver {", "originalCommit": "3e9af32625859bdfdb5da4bf18b5f4f4bf1d26bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NDQwNQ==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402684405", "bodyText": "done.", "author": "ihji", "createdAt": "2020-04-03T01:18:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ3NzM4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ3OTg0OA==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402479848", "bodyText": "Class comment", "author": "lukecwik", "createdAt": "2020-04-02T17:20:03Z", "path": "runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/DefaultArtifactResolver.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.core.construction;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+\n+public class DefaultArtifactResolver implements ArtifactResolver {", "originalCommit": "3e9af32625859bdfdb5da4bf18b5f4f4bf1d26bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NDQzMA==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402684430", "bodyText": "done.", "author": "ihji", "createdAt": "2020-04-03T01:18:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ3OTg0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ4MjM2NQ==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402482365", "bodyText": "The level of nesting in this method is getting a little silly.\nUse local variables to logically describe what your doing and consider dropping using stream", "author": "lukecwik", "createdAt": "2020-04-02T17:23:40Z", "path": "runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/DefaultArtifactResolver.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.core.construction;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+\n+public class DefaultArtifactResolver implements ArtifactResolver {\n+  public static ArtifactResolver INSTANCE = new DefaultArtifactResolver();\n+\n+  private ResolutionFn resolver =\n+      (info) -> {\n+        if (BeamUrns.getUrn(RunnerApi.StandardArtifacts.Types.FILE).equals(info.getTypeUrn())) {\n+          return Optional.of(info);\n+        } else {\n+          return Optional.empty();\n+        }\n+      };\n+\n+  @Override\n+  public void register(ResolutionFn fn) {\n+    resolver =\n+        (info) -> {\n+          Optional<RunnerApi.ArtifactInformation> resolved = fn.resolve(info);\n+          if (resolved.isPresent()) {\n+            return resolved;\n+          } else {\n+            return resolver.resolve(info);\n+          }\n+        };\n+  }\n+\n+  @Override\n+  public RunnerApi.Pipeline resolveArtifacts(RunnerApi.Pipeline pipeline) {", "originalCommit": "3e9af32625859bdfdb5da4bf18b5f4f4bf1d26bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NDQ4NA==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402684484", "bodyText": "done \ud83d\ude04", "author": "ihji", "createdAt": "2020-04-03T01:18:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ4MjM2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ4MjkxOA==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402482918", "bodyText": "Note that you could put one ID into the map for the entire list of files if you allowed ResolutionFn to return a List/Collection of artifacts.", "author": "lukecwik", "createdAt": "2020-04-02T17:24:27Z", "path": "runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/Environments.java", "diffHunk": "@@ -215,22 +221,76 @@ public static Environment createProcessEnvironment(\n     }\n \n     ImmutableList.Builder<ArtifactInformation> filesToStage = ImmutableList.builder();\n+    ImmutableMap.Builder<String, Function<ArtifactInformation, ArtifactInformation>>\n+        lazyArtifactsBuilder = ImmutableMap.builder();\n     for (String path : pathsToStage) {\n       File file = new File(path);\n-      if (new File(path).exists()) {\n-        // Spurious items get added to the classpath. Filter by just those that exist.\n-        if (file.isDirectory()) {\n-          // Zip up directories so we can upload them to the artifact service.\n-          try {\n-            filesToStage.add(createArtifactInformation(zipDirectory(file)));\n-          } catch (IOException e) {\n-            throw new RuntimeException(e);\n-          }\n-        } else {\n-          filesToStage.add(createArtifactInformation(file));\n-        }\n+      // Spurious items get added to the classpath. Filter by just those that exist.\n+      if (file.exists()) {\n+        String id = UUID.randomUUID().toString();", "originalCommit": "3e9af32625859bdfdb5da4bf18b5f4f4bf1d26bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUwMTg5OA==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402501898", "bodyText": "Yes, I think the goal is to avoid even this enumeration until we actually need it.", "author": "robertwb", "createdAt": "2020-04-02T17:50:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ4MjkxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NDU1MA==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402684550", "bodyText": "done.", "author": "ihji", "createdAt": "2020-04-03T01:18:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ4MjkxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ5OTMzNQ==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402499335", "bodyText": "As with the resolution API, one may want to attempt to resolve multiple artifacts (e.g. maven dependencies) simultaneously. One may also need to return multiple artifacts as the resolution of a single artifact (e.g. the deferred \"ambient environment\" one).", "author": "robertwb", "createdAt": "2020-04-02T17:45:44Z", "path": "runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/ArtifactResolver.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.core.construction;\n+\n+import java.util.Optional;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+\n+public interface ArtifactResolver {\n+  void register(ResolutionFn fn);\n+\n+  RunnerApi.Pipeline resolveArtifacts(RunnerApi.Pipeline pipeline);\n+\n+  interface ResolutionFn {\n+    Optional<RunnerApi.ArtifactInformation> resolve(RunnerApi.ArtifactInformation info);", "originalCommit": "3e9af32625859bdfdb5da4bf18b5f4f4bf1d26bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4ODA1MA==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402688050", "bodyText": "changed to List.", "author": "ihji", "createdAt": "2020-04-03T01:31:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ5OTMzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUwMDY0OA==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402500648", "bodyText": "I wonder if having an explicit List would be easier to understand than the implicit chaining in these abstract classes.", "author": "robertwb", "createdAt": "2020-04-02T17:47:58Z", "path": "runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/DefaultArtifactResolver.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.core.construction;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+\n+public class DefaultArtifactResolver implements ArtifactResolver {\n+  public static ArtifactResolver INSTANCE = new DefaultArtifactResolver();\n+\n+  private ResolutionFn resolver =\n+      (info) -> {\n+        if (BeamUrns.getUrn(RunnerApi.StandardArtifacts.Types.FILE).equals(info.getTypeUrn())) {\n+          return Optional.of(info);\n+        } else {\n+          return Optional.empty();\n+        }\n+      };\n+\n+  @Override\n+  public void register(ResolutionFn fn) {\n+    resolver =", "originalCommit": "3e9af32625859bdfdb5da4bf18b5f4f4bf1d26bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM5MDQyMg==", "url": "https://github.com/apache/beam/pull/11205#discussion_r403390422", "bodyText": "done.", "author": "ihji", "createdAt": "2020-04-04T00:03:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUwMDY0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY5OTA5Ng==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402699096", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              // A data for deferred artifacts. Interpretation of bytes is delegated to the creator of this payload.\n          \n          \n            \n              // Data for deferred artifacts. Interpretation of bytes is delegated to the creator of this payload.", "author": "lukecwik", "createdAt": "2020-04-03T02:16:54Z", "path": "model/pipeline/src/main/proto/beam_runner_api.proto", "diffHunk": "@@ -1206,6 +1210,15 @@ message MavenPayload {\n   string repository_url = 2;\n }\n \n+message DeferredArtifactPayload {\n+  // A unique string identifier assigned by the creator of this payload. The creator may use this key to confirm\n+  // whether they can parse the data.\n+  string key = 1;\n+\n+  // A data for deferred artifacts. Interpretation of bytes is delegated to the creator of this payload.", "originalCommit": "0a0422e8b1de81ab21b715533de34a9e2e19ab5a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY5OTM5OA==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402699398", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                      String.format(\"cannot resolve artifact information: %s\", info));\n          \n          \n            \n                                      String.format(\"Cannot resolve artifact information: %s\", info));", "author": "lukecwik", "createdAt": "2020-04-03T02:18:12Z", "path": "runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/DefaultArtifactResolver.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.core.construction;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * A default artifact resolver. This resolver applies {@link ResolutionFn} first matched in the\n+ * order they registered.\n+ */\n+public class DefaultArtifactResolver implements ArtifactResolver {\n+  public static final ArtifactResolver INSTANCE = new DefaultArtifactResolver();\n+\n+  private ResolutionFn resolver =\n+      (info) -> {\n+        if (BeamUrns.getUrn(RunnerApi.StandardArtifacts.Types.FILE).equals(info.getTypeUrn())) {\n+          return ImmutableList.of(info);\n+        } else {\n+          return ImmutableList.of();\n+        }\n+      };\n+\n+  @Override\n+  public void register(ResolutionFn fn) {\n+    resolver =\n+        (info) -> {\n+          List<RunnerApi.ArtifactInformation> resolved = fn.resolve(info);\n+          if (!resolved.isEmpty()) {\n+            return resolved;\n+          } else {\n+            return resolver.resolve(info);\n+          }\n+        };\n+  }\n+\n+  @Override\n+  public RunnerApi.Pipeline resolveArtifacts(RunnerApi.Pipeline pipeline) {\n+    ImmutableMap.Builder<String, RunnerApi.Environment> environmentMapBuilder =\n+        ImmutableMap.builder();\n+    for (Map.Entry<String, RunnerApi.Environment> entry :\n+        pipeline.getComponents().getEnvironmentsMap().entrySet()) {\n+      List<RunnerApi.ArtifactInformation> resolvedDependencies =\n+          entry\n+              .getValue()\n+              .getDependenciesList()\n+              .parallelStream()\n+              .flatMap(\n+                  (info) -> {\n+                    List<RunnerApi.ArtifactInformation> resolved = resolver.resolve(info);\n+                    if (resolved.isEmpty()) {\n+                      throw new RuntimeException(\n+                          String.format(\"cannot resolve artifact information: %s\", info));", "originalCommit": "0a0422e8b1de81ab21b715533de34a9e2e19ab5a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcwMDYwMQ==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402700601", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                String id = UUID.randomUUID().toString();\n          \n          \n            \n                DefaultArtifactResolver.INSTANCE.register(\n          \n          \n            \n                    (info) -> {\n          \n          \n            \n                      if (BeamUrns.getUrn(StandardArtifacts.Types.DEFERRED).equals(info.getTypeUrn())) {\n          \n          \n            \n                        RunnerApi.DeferredArtifactPayload deferredArtifactPayload;\n          \n          \n            \n                        try {\n          \n          \n            \n                          deferredArtifactPayload =\n          \n          \n            \n                              RunnerApi.DeferredArtifactPayload.parseFrom(info.getTypePayload());\n          \n          \n            \n                        } catch (InvalidProtocolBufferException e) {\n          \n          \n            \n                          throw new RuntimeException(\"Error parsing deferred artifact payload.\", e);\n          \n          \n            \n                        }\n          \n          \n            \n                        if (id.equals(deferredArtifactPayload.getKey())) {\n          \n          \n            \n                          return lazyArtifacts.stream().map(Supplier::get).collect(Collectors.toList());\n          \n          \n            \n                        } else {\n          \n          \n            \n                          return ImmutableList.of();\n          \n          \n            \n                        }\n          \n          \n            \n                      } else {\n          \n          \n            \n                        return ImmutableList.of();\n          \n          \n            \n                      }\n          \n          \n            \n                    });\n          \n          \n            \n            \n          \n          \n            \n                return ImmutableList.of(\n          \n          \n            \n                    ArtifactInformation.newBuilder()\n          \n          \n            \n                        .setTypeUrn(BeamUrns.getUrn(StandardArtifacts.Types.DEFERRED))\n          \n          \n            \n                        .setTypePayload(\n          \n          \n            \n                            RunnerApi.DeferredArtifactPayload.newBuilder().setKey(id).build().toByteString())\n          \n          \n            \n                String key = UUID.randomUUID().toString();\n          \n          \n            \n                DefaultArtifactResolver.INSTANCE.register(\n          \n          \n            \n                    (info) -> {\n          \n          \n            \n                      if (BeamUrns.getUrn(StandardArtifacts.Types.DEFERRED).equals(info.getTypeUrn())) {\n          \n          \n            \n                        RunnerApi.DeferredArtifactPayload deferredArtifactPayload;\n          \n          \n            \n                        try {\n          \n          \n            \n                          deferredArtifactPayload =\n          \n          \n            \n                              RunnerApi.DeferredArtifactPayload.parseFrom(info.getTypePayload());\n          \n          \n            \n                        } catch (InvalidProtocolBufferException e) {\n          \n          \n            \n                          throw new RuntimeException(\"Error parsing deferred artifact payload.\", e);\n          \n          \n            \n                        }\n          \n          \n            \n                        if (key.equals(deferredArtifactPayload.getKey())) {\n          \n          \n            \n                          return lazyArtifacts.stream().map(Supplier::get).collect(Collectors.toList());\n          \n          \n            \n                        } else {\n          \n          \n            \n                          return ImmutableList.of();\n          \n          \n            \n                        }\n          \n          \n            \n                      } else {\n          \n          \n            \n                        return ImmutableList.of();\n          \n          \n            \n                      }\n          \n          \n            \n                    });\n          \n          \n            \n            \n          \n          \n            \n                return ImmutableList.of(\n          \n          \n            \n                    ArtifactInformation.newBuilder()\n          \n          \n            \n                        .setTypeUrn(BeamUrns.getUrn(StandardArtifacts.Types.DEFERRED))\n          \n          \n            \n                        .setTypePayload(\n          \n          \n            \n                            RunnerApi.DeferredArtifactPayload.newBuilder().setKey(key).build().toByteString())", "author": "lukecwik", "createdAt": "2020-04-03T02:22:59Z", "path": "runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/Environments.java", "diffHunk": "@@ -214,24 +220,87 @@ public static Environment createProcessEnvironment(\n       pathsToStage.addAll(stagingFiles);\n     }\n \n-    ImmutableList.Builder<ArtifactInformation> filesToStage = ImmutableList.builder();\n+    ImmutableList.Builder<Supplier<ArtifactInformation>> lazyArtifactsBuilder =\n+        ImmutableList.builder();\n     for (String path : pathsToStage) {\n       File file = new File(path);\n-      if (new File(path).exists()) {\n-        // Spurious items get added to the classpath. Filter by just those that exist.\n-        if (file.isDirectory()) {\n-          // Zip up directories so we can upload them to the artifact service.\n-          try {\n-            filesToStage.add(createArtifactInformation(zipDirectory(file)));\n-          } catch (IOException e) {\n-            throw new RuntimeException(e);\n-          }\n-        } else {\n-          filesToStage.add(createArtifactInformation(file));\n-        }\n+      // Spurious items get added to the classpath. Filter by just those that exist.\n+      if (file.exists()) {\n+        ArtifactInformation.Builder artifactBuilder = ArtifactInformation.newBuilder();\n+        artifactBuilder.setTypeUrn(BeamUrns.getUrn(StandardArtifacts.Types.FILE));\n+        artifactBuilder.setRoleUrn(BeamUrns.getUrn(StandardArtifacts.Roles.STAGING_TO));\n+        artifactBuilder.setRolePayload(\n+            RunnerApi.ArtifactStagingToRolePayload.newBuilder()\n+                .setStagedName(createStagingFileName(file))\n+                .build()\n+                .toByteString());\n+        lazyArtifactsBuilder.add(\n+            file.isDirectory()\n+                ? () -> {\n+                  File zippedFile;\n+                  HashCode hashCode;\n+                  try {\n+                    zippedFile = zipDirectory(file);\n+                    hashCode = Files.asByteSource(zippedFile).hash(Hashing.sha256());\n+                  } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                  }\n+                  return artifactBuilder\n+                      .setTypePayload(\n+                          RunnerApi.ArtifactFilePayload.newBuilder()\n+                              .setPath(zippedFile.getPath())\n+                              .setSha256(hashCode.toString())\n+                              .build()\n+                              .toByteString())\n+                      .build();\n+                }\n+                : () -> {\n+                  HashCode hashCode;\n+                  try {\n+                    hashCode = Files.asByteSource(file).hash(Hashing.sha256());\n+                  } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                  }\n+                  return artifactBuilder\n+                      .setTypePayload(\n+                          RunnerApi.ArtifactFilePayload.newBuilder()\n+                              .setPath(file.getPath())\n+                              .setSha256(hashCode.toString())\n+                              .build()\n+                              .toByteString())\n+                      .build();\n+                });\n       }\n     }\n-    return filesToStage.build();\n+\n+    List<Supplier<ArtifactInformation>> lazyArtifacts = lazyArtifactsBuilder.build();\n+    String id = UUID.randomUUID().toString();\n+    DefaultArtifactResolver.INSTANCE.register(\n+        (info) -> {\n+          if (BeamUrns.getUrn(StandardArtifacts.Types.DEFERRED).equals(info.getTypeUrn())) {\n+            RunnerApi.DeferredArtifactPayload deferredArtifactPayload;\n+            try {\n+              deferredArtifactPayload =\n+                  RunnerApi.DeferredArtifactPayload.parseFrom(info.getTypePayload());\n+            } catch (InvalidProtocolBufferException e) {\n+              throw new RuntimeException(\"Error parsing deferred artifact payload.\", e);\n+            }\n+            if (id.equals(deferredArtifactPayload.getKey())) {\n+              return lazyArtifacts.stream().map(Supplier::get).collect(Collectors.toList());\n+            } else {\n+              return ImmutableList.of();\n+            }\n+          } else {\n+            return ImmutableList.of();\n+          }\n+        });\n+\n+    return ImmutableList.of(\n+        ArtifactInformation.newBuilder()\n+            .setTypeUrn(BeamUrns.getUrn(StandardArtifacts.Types.DEFERRED))\n+            .setTypePayload(\n+                RunnerApi.DeferredArtifactPayload.newBuilder().setKey(id).build().toByteString())", "originalCommit": "0a0422e8b1de81ab21b715533de34a9e2e19ab5a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5550d1f5c758565133c0d1b7c703e7550b8fc3c7", "url": "https://github.com/apache/beam/commit/5550d1f5c758565133c0d1b7c703e7550b8fc3c7", "message": "[BEAM-9578] Enumerating artifacts is too expensive in Java", "committedDate": "2020-04-03T23:52:41Z", "type": "commit"}, {"oid": "5550d1f5c758565133c0d1b7c703e7550b8fc3c7", "url": "https://github.com/apache/beam/commit/5550d1f5c758565133c0d1b7c703e7550b8fc3c7", "message": "[BEAM-9578] Enumerating artifacts is too expensive in Java", "committedDate": "2020-04-03T23:52:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQwMzMzMg==", "url": "https://github.com/apache/beam/pull/11205#discussion_r403403332", "bodyText": "Is the empty list special? In particular sometimes a deferred artifact may resolve to nothing, which is different than not being able to be resolved... I think we still need optional or null or an exception to denote unresolveable by this resolver.", "author": "robertwb", "createdAt": "2020-04-04T01:14:38Z", "path": "runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/DefaultArtifactResolver.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.core.construction;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+\n+/**\n+ * A default artifact resolver. This resolver applies {@link ResolutionFn} in the reversed order\n+ * they registered i.e. the function registered later overrides the earlier one if they resolve the\n+ * same artifact.\n+ */\n+public class DefaultArtifactResolver implements ArtifactResolver {\n+  public static final ArtifactResolver INSTANCE = new DefaultArtifactResolver();\n+\n+  private List<ResolutionFn> fns =\n+      Lists.newArrayList(\n+          (info) -> {\n+            if (BeamUrns.getUrn(RunnerApi.StandardArtifacts.Types.FILE).equals(info.getTypeUrn())) {\n+              return ImmutableList.of(info);\n+            } else {\n+              return ImmutableList.of();", "originalCommit": "5550d1f5c758565133c0d1b7c703e7550b8fc3c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxMjYzNg==", "url": "https://github.com/apache/beam/pull/11205#discussion_r404412636", "bodyText": "Done. Optional list makes three choices: Failure, Success with empty output and Success with a list of artifacts.", "author": "ihji", "createdAt": "2020-04-06T21:55:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQwMzMzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQwMzc2Ng==", "url": "https://github.com/apache/beam/pull/11205#discussion_r403403766", "bodyText": "Should this be uid? Any collisions here could be bad...", "author": "robertwb", "createdAt": "2020-04-04T01:17:52Z", "path": "model/pipeline/src/main/proto/beam_runner_api.proto", "diffHunk": "@@ -1206,6 +1210,15 @@ message MavenPayload {\n   string repository_url = 2;\n }\n \n+message DeferredArtifactPayload {\n+  // A unique string identifier assigned by the creator of this payload. The creator may use this key to confirm\n+  // whether they can parse the data.\n+  string key = 1;", "originalCommit": "5550d1f5c758565133c0d1b7c703e7550b8fc3c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQwNzA4Mg==", "url": "https://github.com/apache/beam/pull/11205#discussion_r403407082", "bodyText": "This is going to have to get revamped for XLang and since it isn't being exported outside of the SDK for portable runners we can easily change it.", "author": "lukecwik", "createdAt": "2020-04-04T01:44:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQwMzc2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQwNTI3OA==", "url": "https://github.com/apache/beam/pull/11205#discussion_r403405278", "bodyText": "Don't we want this for loop to be lazy?\nRather than introducing intermediate streams of Suppliers, I think we could just rename the existing getArtifacts() something like getNonDeferredArtifacts() and then call it during resolution.\nif (key.equals(deferredArtifactPayload.getKey())) {\n      return getNonDeferredArtifacts(options);\n}", "author": "robertwb", "createdAt": "2020-04-04T01:30:40Z", "path": "runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/Environments.java", "diffHunk": "@@ -214,24 +220,90 @@ public static Environment createProcessEnvironment(\n       pathsToStage.addAll(stagingFiles);\n     }\n \n-    ImmutableList.Builder<ArtifactInformation> filesToStage = ImmutableList.builder();\n+    ImmutableList.Builder<Supplier<ArtifactInformation>> lazyArtifactsBuilder =\n+        ImmutableList.builder();\n     for (String path : pathsToStage) {", "originalCommit": "5550d1f5c758565133c0d1b7c703e7550b8fc3c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxMTk1MQ==", "url": "https://github.com/apache/beam/pull/11205#discussion_r404411951", "bodyText": "This for loop is fairly cheap and from stream of Suppliers we can easily get additional performance benefits by creating parallelStream. When we consider parallelizing expensive computations, some boilerplate codes are needed anyway in getNonDeferredArtifacts(). I think building a stream is a nice way to abstract them out.", "author": "ihji", "createdAt": "2020-04-06T21:54:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQwNTI3OA=="}], "type": "inlineReview"}, {"oid": "94a5a5fc3ce5dc6caf85412a9cf6e91ae90b4b0f", "url": "https://github.com/apache/beam/commit/94a5a5fc3ce5dc6caf85412a9cf6e91ae90b4b0f", "message": "allow explicit failure case", "committedDate": "2020-04-06T20:55:48Z", "type": "commit"}, {"oid": "8f419fbb34fd892094d1a98a24e251b2f0dfc477", "url": "https://github.com/apache/beam/commit/8f419fbb34fd892094d1a98a24e251b2f0dfc477", "message": "remove stream", "committedDate": "2020-04-07T00:36:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNjE2Mg==", "url": "https://github.com/apache/beam/pull/11205#discussion_r405136162", "bodyText": "Nit, there seems to be a fair amount of duplication between these two case.", "author": "robertwb", "createdAt": "2020-04-07T21:53:51Z", "path": "runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/Environments.java", "diffHunk": "@@ -207,31 +210,94 @@ public static Environment createProcessEnvironment(\n     }\n   }\n \n-  public static Collection<ArtifactInformation> getArtifacts(PipelineOptions options) {\n-    Set<String> pathsToStage = Sets.newHashSet();\n-    List<String> stagingFiles = options.as(PortablePipelineOptions.class).getFilesToStage();\n-    if (stagingFiles != null) {\n-      pathsToStage.addAll(stagingFiles);\n-    }\n-\n-    ImmutableList.Builder<ArtifactInformation> filesToStage = ImmutableList.builder();\n+  private static List<ArtifactInformation> getArtifacts(List<String> stagingFiles) {\n+    Set<String> pathsToStage = Sets.newHashSet(stagingFiles);\n+    ImmutableList.Builder<ArtifactInformation> artifactsBuilder = ImmutableList.builder();\n     for (String path : pathsToStage) {\n       File file = new File(path);\n-      if (new File(path).exists()) {\n-        // Spurious items get added to the classpath. Filter by just those that exist.\n+      // Spurious items get added to the classpath. Filter by just those that exist.\n+      if (file.exists()) {\n+        ArtifactInformation.Builder artifactBuilder = ArtifactInformation.newBuilder();\n+        artifactBuilder.setTypeUrn(BeamUrns.getUrn(StandardArtifacts.Types.FILE));\n+        artifactBuilder.setRoleUrn(BeamUrns.getUrn(StandardArtifacts.Roles.STAGING_TO));\n+        artifactBuilder.setRolePayload(\n+            RunnerApi.ArtifactStagingToRolePayload.newBuilder()\n+                .setStagedName(createStagingFileName(file))\n+                .build()\n+                .toByteString());\n         if (file.isDirectory()) {\n-          // Zip up directories so we can upload them to the artifact service.\n+          File zippedFile;", "originalCommit": "8f419fbb34fd892094d1a98a24e251b2f0dfc477", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNjQxOA==", "url": "https://github.com/apache/beam/pull/11205#discussion_r405136418", "bodyText": "Or would it be better to let the method throw an IOException?", "author": "robertwb", "createdAt": "2020-04-07T21:54:24Z", "path": "runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/Environments.java", "diffHunk": "@@ -207,31 +210,94 @@ public static Environment createProcessEnvironment(\n     }\n   }\n \n-  public static Collection<ArtifactInformation> getArtifacts(PipelineOptions options) {\n-    Set<String> pathsToStage = Sets.newHashSet();\n-    List<String> stagingFiles = options.as(PortablePipelineOptions.class).getFilesToStage();\n-    if (stagingFiles != null) {\n-      pathsToStage.addAll(stagingFiles);\n-    }\n-\n-    ImmutableList.Builder<ArtifactInformation> filesToStage = ImmutableList.builder();\n+  private static List<ArtifactInformation> getArtifacts(List<String> stagingFiles) {\n+    Set<String> pathsToStage = Sets.newHashSet(stagingFiles);\n+    ImmutableList.Builder<ArtifactInformation> artifactsBuilder = ImmutableList.builder();\n     for (String path : pathsToStage) {\n       File file = new File(path);\n-      if (new File(path).exists()) {\n-        // Spurious items get added to the classpath. Filter by just those that exist.\n+      // Spurious items get added to the classpath. Filter by just those that exist.\n+      if (file.exists()) {\n+        ArtifactInformation.Builder artifactBuilder = ArtifactInformation.newBuilder();\n+        artifactBuilder.setTypeUrn(BeamUrns.getUrn(StandardArtifacts.Types.FILE));\n+        artifactBuilder.setRoleUrn(BeamUrns.getUrn(StandardArtifacts.Roles.STAGING_TO));\n+        artifactBuilder.setRolePayload(\n+            RunnerApi.ArtifactStagingToRolePayload.newBuilder()\n+                .setStagedName(createStagingFileName(file))\n+                .build()\n+                .toByteString());\n         if (file.isDirectory()) {\n-          // Zip up directories so we can upload them to the artifact service.\n+          File zippedFile;\n+          HashCode hashCode;\n           try {\n-            filesToStage.add(createArtifactInformation(zipDirectory(file)));\n+            zippedFile = zipDirectory(file);\n+            hashCode = Files.asByteSource(zippedFile).hash(Hashing.sha256());\n           } catch (IOException e) {\n             throw new RuntimeException(e);\n           }\n+          artifactsBuilder.add(\n+              artifactBuilder\n+                  .setTypePayload(\n+                      RunnerApi.ArtifactFilePayload.newBuilder()\n+                          .setPath(zippedFile.getPath())\n+                          .setSha256(hashCode.toString())\n+                          .build()\n+                          .toByteString())\n+                  .build());\n         } else {\n-          filesToStage.add(createArtifactInformation(file));\n+          HashCode hashCode;\n+          try {\n+            hashCode = Files.asByteSource(file).hash(Hashing.sha256());\n+          } catch (IOException e) {\n+            throw new RuntimeException(e);", "originalCommit": "8f419fbb34fd892094d1a98a24e251b2f0dfc477", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}