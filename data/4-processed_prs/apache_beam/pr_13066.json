{"pr_number": 13066, "pr_title": "[BEAM-11052] Memoize to_pcollection", "pr_createdAt": "2020-10-09T23:01:48Z", "pr_url": "https://github.com/apache/beam/pull/13066", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcwNjIyNw==", "url": "https://github.com/apache/beam/pull/13066#discussion_r502706227", "bodyText": "Note this uses a global cache which can be problematic in testing. I don't think we need to worry about pcollections being shared across pipelines though since the dataframe expressions should have a reference to the pipeline through the to_dataframe roots.", "author": "TheNeuralBit", "createdAt": "2020-10-09T23:04:18Z", "path": "sdks/python/apache_beam/dataframe/convert.py", "diffHunk": "@@ -67,6 +68,9 @@ def to_dataframe(\n       expressions.PlaceholderExpression(proxy, pcoll))\n \n \n+TO_PCOLLECTION_CACHE = {}", "originalCommit": "2a9906a7496941bb2d4aacc6b2e5c08027a4a73b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxMjg4MA==", "url": "https://github.com/apache/beam/pull/13066#discussion_r502712880", "bodyText": "I'm actually more worried about global caches in production than testing--the expressions themselves should not collide between pipelines.\nMaybe we could use a weakref.WeakKeyDictionary.", "author": "robertwb", "createdAt": "2020-10-09T23:36:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcwNjIyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxNzMxMg==", "url": "https://github.com/apache/beam/pull/13066#discussion_r502717312", "bodyText": "Yeah agreed it could be a problem in production as well. WeakKeyDictionary is an interesting idea, I hadn't seen the weakref library before. I'll give that a shot.", "author": "TheNeuralBit", "createdAt": "2020-10-10T00:02:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcwNjIyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUwODU1NA==", "url": "https://github.com/apache/beam/pull/13066#discussion_r503508554", "bodyText": "Updated this to use WeakValueDictionary for the caches, PTAL", "author": "TheNeuralBit", "createdAt": "2020-10-12T20:08:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcwNjIyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxMzI0Mg==", "url": "https://github.com/apache/beam/pull/13066#discussion_r502713242", "bodyText": "Put ()'s around ix, pc for better formatting.", "author": "robertwb", "createdAt": "2020-10-09T23:38:32Z", "path": "sdks/python/apache_beam/dataframe/convert.py", "diffHunk": "@@ -138,21 +142,47 @@ def extract_input(placeholder):\n \n   placeholders = frozenset.union(\n       frozenset(), *[df._expr.placeholders() for df in dataframes])\n-  results = {p: extract_input(p)\n-             for p in placeholders\n-             } | label >> transforms._DataframeExpressionsTransform(\n-                 dict((ix, df._expr) for ix, df in enumerate(\n-                     dataframes)))  # type: Dict[Any, pvalue.PCollection]\n+\n+  # Exclude any dataframes that have already been converted to PCollections.\n+  # We only want to convert each DF expression once, then re-use.\n+  new_dataframes = [\n+      df for df in dataframes if df._expr not in TO_PCOLLECTION_CACHE\n+  ]\n+  new_results = {p: extract_input(p)\n+                 for p in placeholders\n+                 } | label >> transforms._DataframeExpressionsTransform(\n+                     dict(\n+                         (ix, df._expr) for ix, df in enumerate(new_dataframes))\n+                 )  # type: Dict[Any, pvalue.PCollection]\n+\n+  TO_PCOLLECTION_CACHE.update(\n+      {new_dataframes[ix]._expr: pc\n+       for ix, pc in new_results.items()})\n+\n+  raw_results = {\n+      ix: TO_PCOLLECTION_CACHE[df._expr]\n+      for ix, df in enumerate(dataframes)\n+  }\n \n   if yield_elements == \"schemas\":\n     results = {\n-        key: pc\n-        | \"Unbatch '%s'\" % dataframes[key]._expr._id >> schemas.UnbatchPandas(\n-            dataframes[key]._expr.proxy(), include_indexes=include_indexes)\n-        for (key, pc) in results.items()\n+        ix: _make_unbatched_pcoll(pc, dataframes[ix]._expr, include_indexes)\n+        for ix,", "originalCommit": "2a9906a7496941bb2d4aacc6b2e5c08027a4a73b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUwOTcxMQ==", "url": "https://github.com/apache/beam/pull/13066#discussion_r503509711", "bodyText": "Done, thanks", "author": "TheNeuralBit", "createdAt": "2020-10-12T20:10:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxMzI0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxMzY3MA==", "url": "https://github.com/apache/beam/pull/13066#discussion_r502713670", "bodyText": "Again, this grows without bound.", "author": "robertwb", "createdAt": "2020-10-09T23:40:43Z", "path": "sdks/python/apache_beam/dataframe/convert.py", "diffHunk": "@@ -138,21 +142,47 @@ def extract_input(placeholder):\n \n   placeholders = frozenset.union(\n       frozenset(), *[df._expr.placeholders() for df in dataframes])\n-  results = {p: extract_input(p)\n-             for p in placeholders\n-             } | label >> transforms._DataframeExpressionsTransform(\n-                 dict((ix, df._expr) for ix, df in enumerate(\n-                     dataframes)))  # type: Dict[Any, pvalue.PCollection]\n+\n+  # Exclude any dataframes that have already been converted to PCollections.\n+  # We only want to convert each DF expression once, then re-use.\n+  new_dataframes = [\n+      df for df in dataframes if df._expr not in TO_PCOLLECTION_CACHE\n+  ]\n+  new_results = {p: extract_input(p)\n+                 for p in placeholders\n+                 } | label >> transforms._DataframeExpressionsTransform(\n+                     dict(\n+                         (ix, df._expr) for ix, df in enumerate(new_dataframes))\n+                 )  # type: Dict[Any, pvalue.PCollection]\n+\n+  TO_PCOLLECTION_CACHE.update(\n+      {new_dataframes[ix]._expr: pc\n+       for ix, pc in new_results.items()})\n+\n+  raw_results = {\n+      ix: TO_PCOLLECTION_CACHE[df._expr]\n+      for ix, df in enumerate(dataframes)\n+  }\n \n   if yield_elements == \"schemas\":\n     results = {\n-        key: pc\n-        | \"Unbatch '%s'\" % dataframes[key]._expr._id >> schemas.UnbatchPandas(\n-            dataframes[key]._expr.proxy(), include_indexes=include_indexes)\n-        for (key, pc) in results.items()\n+        ix: _make_unbatched_pcoll(pc, dataframes[ix]._expr, include_indexes)\n+        for ix,\n+        pc in raw_results.items()\n     }\n+  else:\n+    results = raw_results\n \n   if len(results) == 1 and not always_return_tuple:\n     return results[0]\n   else:\n     return tuple(value for key, value in sorted(results.items()))\n+\n+\n+memoize = functools.lru_cache(maxsize=None)\n+\n+\n+@memoize", "originalCommit": "2a9906a7496941bb2d4aacc6b2e5c08027a4a73b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUwODI1OQ==", "url": "https://github.com/apache/beam/pull/13066#discussion_r503508259", "bodyText": "Right I used the same approach for both.", "author": "TheNeuralBit", "createdAt": "2020-10-12T20:07:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxMzY3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc0MjQ4NQ==", "url": "https://github.com/apache/beam/pull/13066#discussion_r506742485", "bodyText": "Dict comprehension (for consistency)?", "author": "robertwb", "createdAt": "2020-10-16T22:10:15Z", "path": "sdks/python/apache_beam/dataframe/convert.py", "diffHunk": "@@ -138,19 +161,36 @@ def extract_input(placeholder):\n \n   placeholders = frozenset.union(\n       frozenset(), *[df._expr.placeholders() for df in dataframes])\n-  results = {p: extract_input(p)\n-             for p in placeholders\n-             } | label >> transforms._DataframeExpressionsTransform(\n-                 dict((ix, df._expr) for ix, df in enumerate(\n-                     dataframes)))  # type: Dict[Any, pvalue.PCollection]\n+\n+  # Exclude any dataframes that have already been converted to PCollections.\n+  # We only want to convert each DF expression once, then re-use.\n+  new_dataframes = [\n+      df for df in dataframes if df._expr._id not in TO_PCOLLECTION_CACHE\n+  ]\n+  new_results = {p: extract_input(p)\n+                 for p in placeholders\n+                 } | label >> transforms._DataframeExpressionsTransform(\n+                     dict(", "originalCommit": "4f55313cd2e038f078d17ddea058b7b7540dd952", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk5NDg0OA==", "url": "https://github.com/apache/beam/pull/13066#discussion_r512994848", "bodyText": "Done", "author": "TheNeuralBit", "createdAt": "2020-10-27T20:02:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc0MjQ4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc0MzA3MA==", "url": "https://github.com/apache/beam/pull/13066#discussion_r506743070", "bodyText": "Nice. Perhaps it's worth noting that the pipeline (indirectly) holds references to the transforms which keep both the collections and expressions alive. (Keeping the expressions alive is important to ensure their ids never get accidentally re-used.)", "author": "robertwb", "createdAt": "2020-10-16T22:12:09Z", "path": "sdks/python/apache_beam/dataframe/convert.py", "diffHunk": "@@ -67,7 +69,28 @@ def to_dataframe(\n       expressions.PlaceholderExpression(proxy, pcoll))\n \n \n+# PCollections generated by to_pcollection are memoized.\n+# WeakValueDictionary is used so the caches are cleaned up with the parent\n+# pipelines", "originalCommit": "4f55313cd2e038f078d17ddea058b7b7540dd952", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY2Nzc3Nw==", "url": "https://github.com/apache/beam/pull/13066#discussion_r508667777", "bodyText": "Good idea, added that language", "author": "TheNeuralBit", "createdAt": "2020-10-20T16:22:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc0MzA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc0NDM3Mw==", "url": "https://github.com/apache/beam/pull/13066#discussion_r506744373", "bodyText": "This test (and below) seem largely copies of the test above, but we don't even need to run the pipeline to test what this is testing. Perhaps it'd be better to limit it to what we're trying to test for clarity, i.e. the ids are the same.", "author": "robertwb", "createdAt": "2020-10-16T22:16:50Z", "path": "sdks/python/apache_beam/dataframe/convert_test.py", "diffHunk": "@@ -85,6 +85,94 @@ def test_convert(self):\n       assert_that(pc_3a, equal_to(list(3 * a)), label='Check3a')\n       assert_that(pc_ab, equal_to(list(a * b)), label='Checkab')\n \n+  def test_convert_memoization(self):", "originalCommit": "4f55313cd2e038f078d17ddea058b7b7540dd952", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY1NzM1NQ==", "url": "https://github.com/apache/beam/pull/13066#discussion_r508657355", "bodyText": "Done", "author": "TheNeuralBit", "createdAt": "2020-10-20T16:10:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc0NDM3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc0NDQxOQ==", "url": "https://github.com/apache/beam/pull/13066#discussion_r506744419", "bodyText": "assertIs?", "author": "robertwb", "createdAt": "2020-10-16T22:16:56Z", "path": "sdks/python/apache_beam/dataframe/convert_test.py", "diffHunk": "@@ -85,6 +85,94 @@ def test_convert(self):\n       assert_that(pc_3a, equal_to(list(3 * a)), label='Check3a')\n       assert_that(pc_ab, equal_to(list(a * b)), label='Checkab')\n \n+  def test_convert_memoization(self):\n+    with beam.Pipeline() as p:\n+      a = pd.Series([1, 2, 3])\n+      b = pd.Series([100, 200, 300])\n+\n+      pc_a = p | 'A' >> beam.Create([a])\n+      pc_b = p | 'B' >> beam.Create([b])\n+\n+      df_a = convert.to_dataframe(pc_a, proxy=a[:0])\n+      df_b = convert.to_dataframe(pc_b, proxy=b[:0])\n+\n+      df_2a = 2 * df_a\n+      df_3a = 3 * df_a\n+      df_ab = df_a * df_b\n+\n+      # Converting multiple results at a time can be more efficient.\n+      pc_2a_, pc_ab_ = convert.to_pcollection(df_2a, df_ab)\n+      # Converting the same expressions should yeild the same pcolls\n+      pc_3a, pc_2a, pc_ab = convert.to_pcollection(df_3a, df_2a, df_ab)\n+\n+      self.assertEqual(id(pc_2a), id(pc_2a_))", "originalCommit": "4f55313cd2e038f078d17ddea058b7b7540dd952", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY1NzMwNA==", "url": "https://github.com/apache/beam/pull/13066#discussion_r508657304", "bodyText": "thanks, done", "author": "TheNeuralBit", "createdAt": "2020-10-20T16:10:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc0NDQxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc0NDg4OA==", "url": "https://github.com/apache/beam/pull/13066#discussion_r506744888", "bodyText": "Move these tests into the former, so you can also assert that to_pcollection(x, yield_elements='schema') != to_pcollection(x, yield_elements='pandas') (i.e. no accidental cross-cache contamination).", "author": "robertwb", "createdAt": "2020-10-16T22:18:32Z", "path": "sdks/python/apache_beam/dataframe/convert_test.py", "diffHunk": "@@ -85,6 +85,94 @@ def test_convert(self):\n       assert_that(pc_3a, equal_to(list(3 * a)), label='Check3a')\n       assert_that(pc_ab, equal_to(list(a * b)), label='Checkab')\n \n+  def test_convert_memoization(self):\n+    with beam.Pipeline() as p:\n+      a = pd.Series([1, 2, 3])\n+      b = pd.Series([100, 200, 300])\n+\n+      pc_a = p | 'A' >> beam.Create([a])\n+      pc_b = p | 'B' >> beam.Create([b])\n+\n+      df_a = convert.to_dataframe(pc_a, proxy=a[:0])\n+      df_b = convert.to_dataframe(pc_b, proxy=b[:0])\n+\n+      df_2a = 2 * df_a\n+      df_3a = 3 * df_a\n+      df_ab = df_a * df_b\n+\n+      # Converting multiple results at a time can be more efficient.\n+      pc_2a_, pc_ab_ = convert.to_pcollection(df_2a, df_ab)\n+      # Converting the same expressions should yeild the same pcolls\n+      pc_3a, pc_2a, pc_ab = convert.to_pcollection(df_3a, df_2a, df_ab)\n+\n+      self.assertEqual(id(pc_2a), id(pc_2a_))\n+      self.assertEqual(id(pc_ab), id(pc_ab_))\n+\n+      assert_that(pc_2a, equal_to(list(2 * a)), label='Check2a')\n+      assert_that(pc_3a, equal_to(list(3 * a)), label='Check3a')\n+      assert_that(pc_ab, equal_to(list(a * b)), label='Checkab')\n+\n+  def test_convert_memoization_yield_pandas(self):\n+    with beam.Pipeline() as p:\n+      a = pd.Series([1, 2, 3])\n+      b = pd.Series([100, 200, 300])\n+\n+      pc_a = p | 'A' >> beam.Create([a])\n+      pc_b = p | 'B' >> beam.Create([b])\n+\n+      df_a = convert.to_dataframe(pc_a, proxy=a[:0])\n+      df_b = convert.to_dataframe(pc_b, proxy=b[:0])\n+\n+      df_2a = 2 * df_a\n+      df_3a = 3 * df_a\n+      df_ab = df_a * df_b\n+\n+      # Converting multiple results at a time can be more efficient.\n+      pc_2a_, pc_ab_ = convert.to_pcollection(df_2a, df_ab,", "originalCommit": "4f55313cd2e038f078d17ddea058b7b7540dd952", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY1NzE3OA==", "url": "https://github.com/apache/beam/pull/13066#discussion_r508657178", "bodyText": "Done", "author": "TheNeuralBit", "createdAt": "2020-10-20T16:09:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc0NDg4OA=="}], "type": "inlineReview"}, {"oid": "af356a62ecdb54af4d90b3706f12ad3246be8404", "url": "https://github.com/apache/beam/commit/af356a62ecdb54af4d90b3706f12ad3246be8404", "message": "Memoize to_pcollection", "committedDate": "2020-10-28T22:37:01Z", "type": "commit"}, {"oid": "608faa0eed93214c4b75ba7cabd78e90be058135", "url": "https://github.com/apache/beam/commit/608faa0eed93214c4b75ba7cabd78e90be058135", "message": "Use WeakValueDictionary so cache doesn't grow without bound", "committedDate": "2020-10-28T22:39:34Z", "type": "commit"}, {"oid": "10e66386f14d52d5d2b8e753e6bbbbbf5a6ad9bd", "url": "https://github.com/apache/beam/commit/10e66386f14d52d5d2b8e753e6bbbbbf5a6ad9bd", "message": "combine pandas memoization test", "committedDate": "2020-10-28T22:40:51Z", "type": "commit"}, {"oid": "037fb36a6f2511dacb7a0e0696e4e565b2a7d86f", "url": "https://github.com/apache/beam/commit/037fb36a6f2511dacb7a0e0696e4e565b2a7d86f", "message": "Don't add a DataframeTransform computing 0 dataframes", "committedDate": "2020-10-28T22:40:51Z", "type": "commit"}, {"oid": "6dc091646950e26dca4e126405492108a7003afb", "url": "https://github.com/apache/beam/commit/6dc091646950e26dca4e126405492108a7003afb", "message": "docs", "committedDate": "2020-10-28T22:40:51Z", "type": "commit"}, {"oid": "6dc091646950e26dca4e126405492108a7003afb", "url": "https://github.com/apache/beam/commit/6dc091646950e26dca4e126405492108a7003afb", "message": "docs", "committedDate": "2020-10-28T22:40:51Z", "type": "forcePushed"}, {"oid": "73b530cac073bf6b1516e29019744a2cd923e743", "url": "https://github.com/apache/beam/commit/73b530cac073bf6b1516e29019744a2cd923e743", "message": "lint", "committedDate": "2020-11-02T19:43:36Z", "type": "commit"}, {"oid": "1db94a55c2e41b86979223cec64e5e0071b84435", "url": "https://github.com/apache/beam/commit/1db94a55c2e41b86979223cec64e5e0071b84435", "message": "mypy", "committedDate": "2020-11-02T20:11:38Z", "type": "commit"}, {"oid": "d458b2828d9bac1e0832d08323285584d6a3a71f", "url": "https://github.com/apache/beam/commit/d458b2828d9bac1e0832d08323285584d6a3a71f", "message": "mypy2", "committedDate": "2020-11-02T20:17:56Z", "type": "commit"}, {"oid": "b354e32a3b74b73f0e0b83f25014439b85ef9ad3", "url": "https://github.com/apache/beam/commit/b354e32a3b74b73f0e0b83f25014439b85ef9ad3", "message": "import order", "committedDate": "2020-11-02T20:24:37Z", "type": "commit"}]}