{"pr_number": 12473, "pr_title": "[BEAM-10601] DICOM API Beam IO connector e2e test", "pr_createdAt": "2020-08-05T19:22:35Z", "pr_url": "https://github.com/apache/beam/pull/12473", "timeline": [{"oid": "f6ec5c445950cc4dec0e55a1fd185a1aab665526", "url": "https://github.com/apache/beam/commit/f6ec5c445950cc4dec0e55a1fd185a1aab665526", "message": "add integration test", "committedDate": "2020-08-05T19:17:25Z", "type": "commit"}, {"oid": "8b4f46dc2309499872500c8b8b408d47dc845de4", "url": "https://github.com/apache/beam/commit/8b4f46dc2309499872500c8b8b408d47dc845de4", "message": "fix lint", "committedDate": "2020-08-05T19:21:51Z", "type": "commit"}, {"oid": "2f6bc77555aea24d02722f33951f5a02d708d9ce", "url": "https://github.com/apache/beam/commit/2f6bc77555aea24d02722f33951f5a02d708d9ce", "message": "fix style and update changes.md", "committedDate": "2020-08-05T19:51:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk3NjI5MQ==", "url": "https://github.com/apache/beam/pull/12473#discussion_r465976291", "bodyText": "If tests are run in parallel potentially the 2 stores could have the same name because you are using time. It may be best to generate a random string.", "author": "DanKotowski", "createdAt": "2020-08-05T20:12:19Z", "path": "sdks/python/apache_beam/io/gcp/dicomio_integration_test.py", "diffHunk": "@@ -0,0 +1,155 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Integration test for Google Cloud DICOM IO connector.\n+\"\"\"\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+\n+import json\n+import time\n+import unittest\n+\n+from google.auth import default\n+from google.auth.transport import requests\n+from google.cloud import storage\n+from nose.plugins.attrib import attr\n+\n+import apache_beam as beam\n+from apache_beam.io import fileio\n+from apache_beam.io.gcp.dicomio import DicomSearch\n+from apache_beam.io.gcp.dicomio import UploadToDicomStore\n+from apache_beam.testing.test_pipeline import TestPipeline\n+from apache_beam.testing.util import assert_that\n+from apache_beam.testing.util import equal_to\n+\n+REGION = 'us-central1'\n+DATA_SET_ID = 'apache-beam-integration-testing'\n+HEALTHCARE_BASE_URL = 'https://healthcare.googleapis.com/v1'\n+PERSISTENT_DICOM_STORE_NAME = \"dicom_it_persistent_store\"\n+DICOM_FILES_PATH = \"gs://temp-storage-for-dicom-io-tests/dicom_files\"\n+NUM_INSTANCE = 18\n+\n+\n+def create_dicom_store(project_id, dataset_id, region, dicom_store_id):\n+  # Create a an empty DICOM store\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+  api_endpoint = \"{}/projects/{}/locations/{}\".format(\n+      HEALTHCARE_BASE_URL, project_id, region)\n+\n+  # base of dicomweb path.\n+  dicomweb_path = \"{}/datasets/{}/dicomStores\".format(api_endpoint, dataset_id)\n+\n+  response = session.post(\n+      dicomweb_path, params={\"dicomStoreId\": dicom_store_id})\n+  response.raise_for_status()\n+  return response.status_code\n+\n+\n+def delete_dicom_store(project_id, dataset_id, region, dicom_store_id):\n+  # Delete an existing DICOM store\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+  api_endpoint = \"{}/projects/{}/locations/{}\".format(\n+      HEALTHCARE_BASE_URL, project_id, region)\n+\n+  # base of dicomweb path.\n+  dicomweb_path = \"{}/datasets/{}/dicomStores/{}\".format(\n+      api_endpoint, dataset_id, dicom_store_id)\n+\n+  response = session.delete(dicomweb_path)\n+  response.raise_for_status()\n+  return response.status_code\n+\n+\n+class DICOMIoIntegrationTest(unittest.TestCase):\n+  expected_output_metadata = None\n+\n+  def setUp(self):\n+    self.test_pipeline = TestPipeline(is_integration_test=True)\n+    self.project = self.test_pipeline.get_option('project')\n+\n+    # create a temp Dicom store based on the time stamp\n+    self.temp_dicom_store = \"DICOM_store_\" + str(time.time())", "originalCommit": "2f6bc77555aea24d02722f33951f5a02d708d9ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjEwOTMyNQ==", "url": "https://github.com/apache/beam/pull/12473#discussion_r466109325", "bodyText": "Changed", "author": "George-Wu", "createdAt": "2020-08-06T02:30:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk3NjI5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk3OTM4MA==", "url": "https://github.com/apache/beam/pull/12473#discussion_r465979380", "bodyText": "the name of the test should describe the behaviour you are testing, could you update all your tests names.", "author": "DanKotowski", "createdAt": "2020-08-05T20:18:18Z", "path": "sdks/python/apache_beam/io/gcp/dicomio_integration_test.py", "diffHunk": "@@ -0,0 +1,155 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Integration test for Google Cloud DICOM IO connector.\n+\"\"\"\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+\n+import json\n+import time\n+import unittest\n+\n+from google.auth import default\n+from google.auth.transport import requests\n+from google.cloud import storage\n+from nose.plugins.attrib import attr\n+\n+import apache_beam as beam\n+from apache_beam.io import fileio\n+from apache_beam.io.gcp.dicomio import DicomSearch\n+from apache_beam.io.gcp.dicomio import UploadToDicomStore\n+from apache_beam.testing.test_pipeline import TestPipeline\n+from apache_beam.testing.util import assert_that\n+from apache_beam.testing.util import equal_to\n+\n+REGION = 'us-central1'\n+DATA_SET_ID = 'apache-beam-integration-testing'\n+HEALTHCARE_BASE_URL = 'https://healthcare.googleapis.com/v1'\n+PERSISTENT_DICOM_STORE_NAME = \"dicom_it_persistent_store\"\n+DICOM_FILES_PATH = \"gs://temp-storage-for-dicom-io-tests/dicom_files\"\n+NUM_INSTANCE = 18\n+\n+\n+def create_dicom_store(project_id, dataset_id, region, dicom_store_id):\n+  # Create a an empty DICOM store\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+  api_endpoint = \"{}/projects/{}/locations/{}\".format(\n+      HEALTHCARE_BASE_URL, project_id, region)\n+\n+  # base of dicomweb path.\n+  dicomweb_path = \"{}/datasets/{}/dicomStores\".format(api_endpoint, dataset_id)\n+\n+  response = session.post(\n+      dicomweb_path, params={\"dicomStoreId\": dicom_store_id})\n+  response.raise_for_status()\n+  return response.status_code\n+\n+\n+def delete_dicom_store(project_id, dataset_id, region, dicom_store_id):\n+  # Delete an existing DICOM store\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+  api_endpoint = \"{}/projects/{}/locations/{}\".format(\n+      HEALTHCARE_BASE_URL, project_id, region)\n+\n+  # base of dicomweb path.\n+  dicomweb_path = \"{}/datasets/{}/dicomStores/{}\".format(\n+      api_endpoint, dataset_id, dicom_store_id)\n+\n+  response = session.delete(dicomweb_path)\n+  response.raise_for_status()\n+  return response.status_code\n+\n+\n+class DICOMIoIntegrationTest(unittest.TestCase):\n+  expected_output_metadata = None\n+\n+  def setUp(self):\n+    self.test_pipeline = TestPipeline(is_integration_test=True)\n+    self.project = self.test_pipeline.get_option('project')\n+\n+    # create a temp Dicom store based on the time stamp\n+    self.temp_dicom_store = \"DICOM_store_\" + str(time.time())\n+    create_dicom_store(self.project, DATA_SET_ID, REGION, self.temp_dicom_store)\n+    client = storage.Client()\n+    bucket = client.get_bucket('temp-storage-for-dicom-io-tests')\n+    blob = bucket.blob('meta_data_json/Dicom_io_it_test_data.json')\n+    data = json.loads(blob.download_as_string())\n+    self.expected_output_metadata = data\n+\n+  def tearDown(self):\n+    # clean up the temp Dicom store\n+    delete_dicom_store(self.project, DATA_SET_ID, REGION, self.temp_dicom_store)\n+\n+  @attr('IT')\n+  def test_dicom_search(self):", "originalCommit": "2f6bc77555aea24d02722f33951f5a02d708d9ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4MDI5Mg==", "url": "https://github.com/apache/beam/pull/12473#discussion_r465980292", "bodyText": "I think it would also make sense to add  a test where there is an additional which does a bit more of a complex search .", "author": "DanKotowski", "createdAt": "2020-08-05T20:20:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk3OTM4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjEwNDY2MQ==", "url": "https://github.com/apache/beam/pull/12473#discussion_r466104661", "bodyText": "test case added", "author": "George-Wu", "createdAt": "2020-08-06T02:13:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk3OTM4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4Mzc2OA==", "url": "https://github.com/apache/beam/pull/12473#discussion_r465983768", "bodyText": "We should define the expected value above and not inline.", "author": "DanKotowski", "createdAt": "2020-08-05T20:26:39Z", "path": "sdks/python/apache_beam/io/gcp/dicomio_integration_test.py", "diffHunk": "@@ -0,0 +1,155 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Integration test for Google Cloud DICOM IO connector.\n+\"\"\"\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+\n+import json\n+import time\n+import unittest\n+\n+from google.auth import default\n+from google.auth.transport import requests\n+from google.cloud import storage\n+from nose.plugins.attrib import attr\n+\n+import apache_beam as beam\n+from apache_beam.io import fileio\n+from apache_beam.io.gcp.dicomio import DicomSearch\n+from apache_beam.io.gcp.dicomio import UploadToDicomStore\n+from apache_beam.testing.test_pipeline import TestPipeline\n+from apache_beam.testing.util import assert_that\n+from apache_beam.testing.util import equal_to\n+\n+REGION = 'us-central1'\n+DATA_SET_ID = 'apache-beam-integration-testing'\n+HEALTHCARE_BASE_URL = 'https://healthcare.googleapis.com/v1'\n+PERSISTENT_DICOM_STORE_NAME = \"dicom_it_persistent_store\"\n+DICOM_FILES_PATH = \"gs://temp-storage-for-dicom-io-tests/dicom_files\"\n+NUM_INSTANCE = 18\n+\n+\n+def create_dicom_store(project_id, dataset_id, region, dicom_store_id):\n+  # Create a an empty DICOM store\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+  api_endpoint = \"{}/projects/{}/locations/{}\".format(\n+      HEALTHCARE_BASE_URL, project_id, region)\n+\n+  # base of dicomweb path.\n+  dicomweb_path = \"{}/datasets/{}/dicomStores\".format(api_endpoint, dataset_id)\n+\n+  response = session.post(\n+      dicomweb_path, params={\"dicomStoreId\": dicom_store_id})\n+  response.raise_for_status()\n+  return response.status_code\n+\n+\n+def delete_dicom_store(project_id, dataset_id, region, dicom_store_id):\n+  # Delete an existing DICOM store\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+  api_endpoint = \"{}/projects/{}/locations/{}\".format(\n+      HEALTHCARE_BASE_URL, project_id, region)\n+\n+  # base of dicomweb path.\n+  dicomweb_path = \"{}/datasets/{}/dicomStores/{}\".format(\n+      api_endpoint, dataset_id, dicom_store_id)\n+\n+  response = session.delete(dicomweb_path)\n+  response.raise_for_status()\n+  return response.status_code\n+\n+\n+class DICOMIoIntegrationTest(unittest.TestCase):\n+  expected_output_metadata = None\n+\n+  def setUp(self):\n+    self.test_pipeline = TestPipeline(is_integration_test=True)\n+    self.project = self.test_pipeline.get_option('project')\n+\n+    # create a temp Dicom store based on the time stamp\n+    self.temp_dicom_store = \"DICOM_store_\" + str(time.time())\n+    create_dicom_store(self.project, DATA_SET_ID, REGION, self.temp_dicom_store)\n+    client = storage.Client()\n+    bucket = client.get_bucket('temp-storage-for-dicom-io-tests')\n+    blob = bucket.blob('meta_data_json/Dicom_io_it_test_data.json')\n+    data = json.loads(blob.download_as_string())\n+    self.expected_output_metadata = data\n+\n+  def tearDown(self):\n+    # clean up the temp Dicom store\n+    delete_dicom_store(self.project, DATA_SET_ID, REGION, self.temp_dicom_store)\n+\n+  @attr('IT')\n+  def test_dicom_search(self):\n+    # Search and compare the metadata of a persistent DICOM store.\n+    input_dict = {}\n+    input_dict['project_id'] = self.project\n+    input_dict['region'] = REGION\n+    input_dict['dataset_id'] = DATA_SET_ID\n+    input_dict['dicom_store_id'] = PERSISTENT_DICOM_STORE_NAME\n+    input_dict['search_type'] = \"instances\"\n+\n+    expected_dict = {}\n+    expected_dict['result'] = self.expected_output_metadata\n+    expected_dict['status'] = 200\n+    expected_dict['input'] = input_dict\n+    expected_dict['success'] = True\n+\n+    with TestPipeline() as p:\n+      results = (p | beam.Create([input_dict]) | DicomSearch())\n+      assert_that(results, equal_to([expected_dict]))\n+\n+  @attr('IT')\n+  def test_dicom_store_instance(self):\n+    # Store DICOM files to a empty DICOM store from a GCS bucket,\n+    # then check if the store metadata match.\n+    input_dict = {}\n+    input_dict['project_id'] = self.project\n+    input_dict['region'] = REGION\n+    input_dict['dataset_id'] = DATA_SET_ID\n+    input_dict['dicom_store_id'] = self.temp_dicom_store\n+    input_dict['search_type'] = \"instances\"\n+\n+    expected_dict = {}\n+    expected_dict['result'] = self.expected_output_metadata\n+    expected_dict['status'] = 200\n+    expected_dict['input'] = input_dict\n+    expected_dict['success'] = True\n+\n+    with TestPipeline() as p:\n+      gcs_path = DICOM_FILES_PATH + \"/*\"\n+      results = (\n+          p\n+          | fileio.MatchFiles(gcs_path)\n+          | fileio.ReadMatches()\n+          | UploadToDicomStore(input_dict, 'fileio')\n+          | beam.Map(lambda x: x['success']))\n+      assert_that(results, equal_to([True] * NUM_INSTANCE))", "originalCommit": "2f6bc77555aea24d02722f33951f5a02d708d9ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjEwNDc1NA==", "url": "https://github.com/apache/beam/pull/12473#discussion_r466104754", "bodyText": "Changed", "author": "George-Wu", "createdAt": "2020-08-06T02:14:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4Mzc2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4NTI5Ng==", "url": "https://github.com/apache/beam/pull/12473#discussion_r465985296", "bodyText": "could we separate the input_dict between,  the store operation and the QIDO operation.", "author": "DanKotowski", "createdAt": "2020-08-05T20:29:43Z", "path": "sdks/python/apache_beam/io/gcp/dicomio_integration_test.py", "diffHunk": "@@ -0,0 +1,155 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Integration test for Google Cloud DICOM IO connector.\n+\"\"\"\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+\n+import json\n+import time\n+import unittest\n+\n+from google.auth import default\n+from google.auth.transport import requests\n+from google.cloud import storage\n+from nose.plugins.attrib import attr\n+\n+import apache_beam as beam\n+from apache_beam.io import fileio\n+from apache_beam.io.gcp.dicomio import DicomSearch\n+from apache_beam.io.gcp.dicomio import UploadToDicomStore\n+from apache_beam.testing.test_pipeline import TestPipeline\n+from apache_beam.testing.util import assert_that\n+from apache_beam.testing.util import equal_to\n+\n+REGION = 'us-central1'\n+DATA_SET_ID = 'apache-beam-integration-testing'\n+HEALTHCARE_BASE_URL = 'https://healthcare.googleapis.com/v1'\n+PERSISTENT_DICOM_STORE_NAME = \"dicom_it_persistent_store\"\n+DICOM_FILES_PATH = \"gs://temp-storage-for-dicom-io-tests/dicom_files\"\n+NUM_INSTANCE = 18\n+\n+\n+def create_dicom_store(project_id, dataset_id, region, dicom_store_id):\n+  # Create a an empty DICOM store\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+  api_endpoint = \"{}/projects/{}/locations/{}\".format(\n+      HEALTHCARE_BASE_URL, project_id, region)\n+\n+  # base of dicomweb path.\n+  dicomweb_path = \"{}/datasets/{}/dicomStores\".format(api_endpoint, dataset_id)\n+\n+  response = session.post(\n+      dicomweb_path, params={\"dicomStoreId\": dicom_store_id})\n+  response.raise_for_status()\n+  return response.status_code\n+\n+\n+def delete_dicom_store(project_id, dataset_id, region, dicom_store_id):\n+  # Delete an existing DICOM store\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+  api_endpoint = \"{}/projects/{}/locations/{}\".format(\n+      HEALTHCARE_BASE_URL, project_id, region)\n+\n+  # base of dicomweb path.\n+  dicomweb_path = \"{}/datasets/{}/dicomStores/{}\".format(\n+      api_endpoint, dataset_id, dicom_store_id)\n+\n+  response = session.delete(dicomweb_path)\n+  response.raise_for_status()\n+  return response.status_code\n+\n+\n+class DICOMIoIntegrationTest(unittest.TestCase):\n+  expected_output_metadata = None\n+\n+  def setUp(self):\n+    self.test_pipeline = TestPipeline(is_integration_test=True)\n+    self.project = self.test_pipeline.get_option('project')\n+\n+    # create a temp Dicom store based on the time stamp\n+    self.temp_dicom_store = \"DICOM_store_\" + str(time.time())\n+    create_dicom_store(self.project, DATA_SET_ID, REGION, self.temp_dicom_store)\n+    client = storage.Client()\n+    bucket = client.get_bucket('temp-storage-for-dicom-io-tests')\n+    blob = bucket.blob('meta_data_json/Dicom_io_it_test_data.json')\n+    data = json.loads(blob.download_as_string())\n+    self.expected_output_metadata = data\n+\n+  def tearDown(self):\n+    # clean up the temp Dicom store\n+    delete_dicom_store(self.project, DATA_SET_ID, REGION, self.temp_dicom_store)\n+\n+  @attr('IT')\n+  def test_dicom_search(self):\n+    # Search and compare the metadata of a persistent DICOM store.\n+    input_dict = {}\n+    input_dict['project_id'] = self.project\n+    input_dict['region'] = REGION\n+    input_dict['dataset_id'] = DATA_SET_ID\n+    input_dict['dicom_store_id'] = PERSISTENT_DICOM_STORE_NAME\n+    input_dict['search_type'] = \"instances\"\n+\n+    expected_dict = {}\n+    expected_dict['result'] = self.expected_output_metadata\n+    expected_dict['status'] = 200\n+    expected_dict['input'] = input_dict\n+    expected_dict['success'] = True\n+\n+    with TestPipeline() as p:\n+      results = (p | beam.Create([input_dict]) | DicomSearch())\n+      assert_that(results, equal_to([expected_dict]))\n+\n+  @attr('IT')\n+  def test_dicom_store_instance(self):\n+    # Store DICOM files to a empty DICOM store from a GCS bucket,\n+    # then check if the store metadata match.\n+    input_dict = {}\n+    input_dict['project_id'] = self.project\n+    input_dict['region'] = REGION\n+    input_dict['dataset_id'] = DATA_SET_ID\n+    input_dict['dicom_store_id'] = self.temp_dicom_store\n+    input_dict['search_type'] = \"instances\"\n+\n+    expected_dict = {}\n+    expected_dict['result'] = self.expected_output_metadata\n+    expected_dict['status'] = 200\n+    expected_dict['input'] = input_dict\n+    expected_dict['success'] = True\n+\n+    with TestPipeline() as p:\n+      gcs_path = DICOM_FILES_PATH + \"/*\"\n+      results = (\n+          p\n+          | fileio.MatchFiles(gcs_path)\n+          | fileio.ReadMatches()\n+          | UploadToDicomStore(input_dict, 'fileio')", "originalCommit": "2f6bc77555aea24d02722f33951f5a02d708d9ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjEwNDk3OA==", "url": "https://github.com/apache/beam/pull/12473#discussion_r466104978", "bodyText": "Changed", "author": "George-Wu", "createdAt": "2020-08-06T02:14:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4NTI5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4Njk4NQ==", "url": "https://github.com/apache/beam/pull/12473#discussion_r465986985", "bodyText": "Is it possible to add a pub/sub test, potentially we could run an UploadToDicomStore, and then check that we  are receiving the correct messages.", "author": "DanKotowski", "createdAt": "2020-08-05T20:32:58Z", "path": "sdks/python/apache_beam/io/gcp/dicomio_integration_test.py", "diffHunk": "@@ -0,0 +1,155 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Integration test for Google Cloud DICOM IO connector.\n+\"\"\"\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+\n+import json\n+import time\n+import unittest\n+\n+from google.auth import default\n+from google.auth.transport import requests\n+from google.cloud import storage\n+from nose.plugins.attrib import attr\n+\n+import apache_beam as beam\n+from apache_beam.io import fileio\n+from apache_beam.io.gcp.dicomio import DicomSearch\n+from apache_beam.io.gcp.dicomio import UploadToDicomStore\n+from apache_beam.testing.test_pipeline import TestPipeline\n+from apache_beam.testing.util import assert_that\n+from apache_beam.testing.util import equal_to\n+\n+REGION = 'us-central1'\n+DATA_SET_ID = 'apache-beam-integration-testing'\n+HEALTHCARE_BASE_URL = 'https://healthcare.googleapis.com/v1'\n+PERSISTENT_DICOM_STORE_NAME = \"dicom_it_persistent_store\"\n+DICOM_FILES_PATH = \"gs://temp-storage-for-dicom-io-tests/dicom_files\"\n+NUM_INSTANCE = 18\n+\n+\n+def create_dicom_store(project_id, dataset_id, region, dicom_store_id):\n+  # Create a an empty DICOM store\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+  api_endpoint = \"{}/projects/{}/locations/{}\".format(\n+      HEALTHCARE_BASE_URL, project_id, region)\n+\n+  # base of dicomweb path.\n+  dicomweb_path = \"{}/datasets/{}/dicomStores\".format(api_endpoint, dataset_id)\n+\n+  response = session.post(\n+      dicomweb_path, params={\"dicomStoreId\": dicom_store_id})\n+  response.raise_for_status()\n+  return response.status_code\n+\n+\n+def delete_dicom_store(project_id, dataset_id, region, dicom_store_id):\n+  # Delete an existing DICOM store\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+  api_endpoint = \"{}/projects/{}/locations/{}\".format(\n+      HEALTHCARE_BASE_URL, project_id, region)\n+\n+  # base of dicomweb path.\n+  dicomweb_path = \"{}/datasets/{}/dicomStores/{}\".format(\n+      api_endpoint, dataset_id, dicom_store_id)\n+\n+  response = session.delete(dicomweb_path)\n+  response.raise_for_status()\n+  return response.status_code\n+\n+\n+class DICOMIoIntegrationTest(unittest.TestCase):", "originalCommit": "2f6bc77555aea24d02722f33951f5a02d708d9ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjEwOTA0Mg==", "url": "https://github.com/apache/beam/pull/12473#discussion_r466109042", "bodyText": "I think maybe a test of pub/sub is unnecessary here because our connector has no direct dependency or invocation of pub/sub. The 'pubsub to search metadata' converter was tested in the unit test while read and write operations can be tested in an easier way here rather than using pub/sub. What's more, testing a streaming pipeline is complicated and needs much more work :(", "author": "George-Wu", "createdAt": "2020-08-06T02:29:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4Njk4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjQ2MzEzMg==", "url": "https://github.com/apache/beam/pull/12473#discussion_r466463132", "bodyText": "Alright, we can leave that then for now. I think the test that we have is a good start and give us basic coverage for the connector.", "author": "DanKotowski", "createdAt": "2020-08-06T14:41:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4Njk4NQ=="}], "type": "inlineReview"}, {"oid": "44177490f12302b8ebbe66a45c7bd943942d7975", "url": "https://github.com/apache/beam/commit/44177490f12302b8ebbe66a45c7bd943942d7975", "message": "resolved comments and fix dependency bug", "committedDate": "2020-08-06T05:29:56Z", "type": "commit"}, {"oid": "bd2ed5d1009eea14fca9e10d79b38fb88306e8df", "url": "https://github.com/apache/beam/commit/bd2ed5d1009eea14fca9e10d79b38fb88306e8df", "message": "fix dependency", "committedDate": "2020-08-06T13:55:50Z", "type": "commit"}, {"oid": "6d44a2e776f0140139c893817622a63b1dcf22cf", "url": "https://github.com/apache/beam/commit/6d44a2e776f0140139c893817622a63b1dcf22cf", "message": "fix dependency", "committedDate": "2020-08-06T13:56:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU1ODU3OA==", "url": "https://github.com/apache/beam/pull/12473#discussion_r466558578", "bodyText": "Can you please add detailed documentation on how the test works? for example, are there any instances of Dicom stores expected to be running? What files are used for the test?  (I see it all gets created, so that's great. just please document all of that here).", "author": "pabloem", "createdAt": "2020-08-06T17:07:52Z", "path": "sdks/python/apache_beam/io/gcp/dicomio_integration_test.py", "diffHunk": "@@ -0,0 +1,215 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Integration test for Google Cloud DICOM IO connector.", "originalCommit": "6d44a2e776f0140139c893817622a63b1dcf22cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjczNjY5NQ==", "url": "https://github.com/apache/beam/pull/12473#discussion_r466736695", "bodyText": "Added documentations", "author": "George-Wu", "createdAt": "2020-08-06T23:21:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU1ODU3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU1OTcyNA==", "url": "https://github.com/apache/beam/pull/12473#discussion_r466559724", "bodyText": "please make sure that this bucket has lifecycle policies to ensure any left over files will be erased automatically (or feel free to use any of the other temp-storage-* in Beam which do have lifecycle policies", "author": "pabloem", "createdAt": "2020-08-06T17:09:56Z", "path": "sdks/python/apache_beam/io/gcp/dicomio_integration_test.py", "diffHunk": "@@ -0,0 +1,215 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Integration test for Google Cloud DICOM IO connector.\n+\"\"\"\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+\n+import random\n+import string\n+import unittest\n+\n+from nose.plugins.attrib import attr\n+\n+import apache_beam as beam\n+from apache_beam.io import fileio\n+from apache_beam.testing.test_pipeline import TestPipeline\n+from apache_beam.testing.util import assert_that\n+from apache_beam.testing.util import equal_to\n+\n+# pylint: disable=wrong-import-order, wrong-import-position\n+try:\n+  from apache_beam.io.gcp.dicomio import DicomSearch\n+  from apache_beam.io.gcp.dicomio import UploadToDicomStore\n+  from google.auth import default\n+  from google.auth.transport import requests\n+except ImportError:\n+  DicomSearch = None\n+# pylint: enable=wrong-import-order, wrong-import-position\n+\n+REGION = 'us-central1'\n+DATA_SET_ID = 'apache-beam-integration-testing'\n+HEALTHCARE_BASE_URL = 'https://healthcare.googleapis.com/v1'\n+GCS_BASE_URL = 'https://storage.googleapis.com/storage/v1'\n+PERSISTENT_DICOM_STORE_NAME = \"dicom_it_persistent_store\"\n+TEMP_BUCKET_NAME = 'temp-storage-for-dicom-io-tests'", "originalCommit": "6d44a2e776f0140139c893817622a63b1dcf22cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjczNjc5OQ==", "url": "https://github.com/apache/beam/pull/12473#discussion_r466736799", "bodyText": "Changed to right storage", "author": "George-Wu", "createdAt": "2020-08-06T23:21:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU1OTcyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU2NDgyNg==", "url": "https://github.com/apache/beam/pull/12473#discussion_r466564826", "bodyText": "as you realized, each test takes 5 minutes to run. With that in mind, would it be possible to consolidate the all_instance and refined_instance searches into a single test case?\nSomething roughly like this:\nwith p:\n  refined = p | searchrefined\n  all = p | searchall\n  assert_that(exp_ref, refined)\n  assert_that(exp_all, all, \"allmatch\")", "author": "pabloem", "createdAt": "2020-08-06T17:18:33Z", "path": "sdks/python/apache_beam/io/gcp/dicomio_integration_test.py", "diffHunk": "@@ -0,0 +1,215 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Integration test for Google Cloud DICOM IO connector.\n+\"\"\"\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+\n+import random\n+import string\n+import unittest\n+\n+from nose.plugins.attrib import attr\n+\n+import apache_beam as beam\n+from apache_beam.io import fileio\n+from apache_beam.testing.test_pipeline import TestPipeline\n+from apache_beam.testing.util import assert_that\n+from apache_beam.testing.util import equal_to\n+\n+# pylint: disable=wrong-import-order, wrong-import-position\n+try:\n+  from apache_beam.io.gcp.dicomio import DicomSearch\n+  from apache_beam.io.gcp.dicomio import UploadToDicomStore\n+  from google.auth import default\n+  from google.auth.transport import requests\n+except ImportError:\n+  DicomSearch = None\n+# pylint: enable=wrong-import-order, wrong-import-position\n+\n+REGION = 'us-central1'\n+DATA_SET_ID = 'apache-beam-integration-testing'\n+HEALTHCARE_BASE_URL = 'https://healthcare.googleapis.com/v1'\n+GCS_BASE_URL = 'https://storage.googleapis.com/storage/v1'\n+PERSISTENT_DICOM_STORE_NAME = \"dicom_it_persistent_store\"\n+TEMP_BUCKET_NAME = 'temp-storage-for-dicom-io-tests'\n+TEMP_FILES_PATH = 'gs://' + TEMP_BUCKET_NAME\n+META_DATA_ALL_NAME = 'Dicom_io_it_test_data.json'\n+META_DATA_REFINED_NAME = 'Dicom_io_it_test_refined_data.json'\n+NUM_INSTANCE = 18\n+RAND_LEN = 15\n+\n+\n+def random_string_generator(length):\n+  letters_and_digits = string.ascii_letters + string.digits\n+  result = ''.join((random.choice(letters_and_digits) for i in range(length)))\n+  return result\n+\n+\n+def create_dicom_store(project_id, dataset_id, region, dicom_store_id):\n+  # Create a an empty DICOM store\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+  api_endpoint = \"{}/projects/{}/locations/{}\".format(\n+      HEALTHCARE_BASE_URL, project_id, region)\n+\n+  # base of dicomweb path.\n+  dicomweb_path = \"{}/datasets/{}/dicomStores\".format(api_endpoint, dataset_id)\n+\n+  response = session.post(\n+      dicomweb_path, params={\"dicomStoreId\": dicom_store_id})\n+  response.raise_for_status()\n+  return response.status_code\n+\n+\n+def delete_dicom_store(project_id, dataset_id, region, dicom_store_id):\n+  # Delete an existing DICOM store\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+  api_endpoint = \"{}/projects/{}/locations/{}\".format(\n+      HEALTHCARE_BASE_URL, project_id, region)\n+\n+  # base of dicomweb path.\n+  dicomweb_path = \"{}/datasets/{}/dicomStores/{}\".format(\n+      api_endpoint, dataset_id, dicom_store_id)\n+\n+  response = session.delete(dicomweb_path)\n+  response.raise_for_status()\n+  return response.status_code\n+\n+\n+def get_gcs_file_http(file_name):\n+  # Get gcs file from REST Api\n+  api_endpoint = \"{}/b/{}/o/{}?alt=media\".format(\n+      GCS_BASE_URL, TEMP_BUCKET_NAME, file_name)\n+\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+\n+  response = session.get(api_endpoint)\n+  response.raise_for_status()\n+  return response.json()\n+\n+\n+@unittest.skipIf(DicomSearch is None, 'GCP dependencies are not installed')\n+class DICOMIoIntegrationTest(unittest.TestCase):\n+  def setUp(self):\n+    self.test_pipeline = TestPipeline(is_integration_test=True)\n+    self.project = self.test_pipeline.get_option('project')\n+    self.expected_output_all_metadata = get_gcs_file_http(META_DATA_ALL_NAME)\n+    self.expected_output_refined_metadata = get_gcs_file_http(\n+        META_DATA_REFINED_NAME)\n+\n+    # create a temp Dicom store based on the time stamp\n+    self.temp_dicom_store = \"DICOM_store_\" + random_string_generator(RAND_LEN)\n+    create_dicom_store(self.project, DATA_SET_ID, REGION, self.temp_dicom_store)\n+\n+  def tearDown(self):\n+    # clean up the temp Dicom store\n+    delete_dicom_store(self.project, DATA_SET_ID, REGION, self.temp_dicom_store)\n+\n+  @attr('IT')\n+  def test_dicom_search_all_instances(self):", "originalCommit": "6d44a2e776f0140139c893817622a63b1dcf22cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjczNjg4Mw==", "url": "https://github.com/apache/beam/pull/12473#discussion_r466736883", "bodyText": "pipeline reduced", "author": "George-Wu", "createdAt": "2020-08-06T23:21:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU2NDgyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU2NjU3MQ==", "url": "https://github.com/apache/beam/pull/12473#discussion_r466566571", "bodyText": "in this test case you're running two pipelines. This will therefore take 10 minutes to run. Perhaps it's worth making this the single test case that tests upload and search (or perhaps remove the search pipeline from this case to avoid the super long runtime?)", "author": "pabloem", "createdAt": "2020-08-06T17:20:39Z", "path": "sdks/python/apache_beam/io/gcp/dicomio_integration_test.py", "diffHunk": "@@ -0,0 +1,215 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"\n+Integration test for Google Cloud DICOM IO connector.\n+\"\"\"\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+\n+import random\n+import string\n+import unittest\n+\n+from nose.plugins.attrib import attr\n+\n+import apache_beam as beam\n+from apache_beam.io import fileio\n+from apache_beam.testing.test_pipeline import TestPipeline\n+from apache_beam.testing.util import assert_that\n+from apache_beam.testing.util import equal_to\n+\n+# pylint: disable=wrong-import-order, wrong-import-position\n+try:\n+  from apache_beam.io.gcp.dicomio import DicomSearch\n+  from apache_beam.io.gcp.dicomio import UploadToDicomStore\n+  from google.auth import default\n+  from google.auth.transport import requests\n+except ImportError:\n+  DicomSearch = None\n+# pylint: enable=wrong-import-order, wrong-import-position\n+\n+REGION = 'us-central1'\n+DATA_SET_ID = 'apache-beam-integration-testing'\n+HEALTHCARE_BASE_URL = 'https://healthcare.googleapis.com/v1'\n+GCS_BASE_URL = 'https://storage.googleapis.com/storage/v1'\n+PERSISTENT_DICOM_STORE_NAME = \"dicom_it_persistent_store\"\n+TEMP_BUCKET_NAME = 'temp-storage-for-dicom-io-tests'\n+TEMP_FILES_PATH = 'gs://' + TEMP_BUCKET_NAME\n+META_DATA_ALL_NAME = 'Dicom_io_it_test_data.json'\n+META_DATA_REFINED_NAME = 'Dicom_io_it_test_refined_data.json'\n+NUM_INSTANCE = 18\n+RAND_LEN = 15\n+\n+\n+def random_string_generator(length):\n+  letters_and_digits = string.ascii_letters + string.digits\n+  result = ''.join((random.choice(letters_and_digits) for i in range(length)))\n+  return result\n+\n+\n+def create_dicom_store(project_id, dataset_id, region, dicom_store_id):\n+  # Create a an empty DICOM store\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+  api_endpoint = \"{}/projects/{}/locations/{}\".format(\n+      HEALTHCARE_BASE_URL, project_id, region)\n+\n+  # base of dicomweb path.\n+  dicomweb_path = \"{}/datasets/{}/dicomStores\".format(api_endpoint, dataset_id)\n+\n+  response = session.post(\n+      dicomweb_path, params={\"dicomStoreId\": dicom_store_id})\n+  response.raise_for_status()\n+  return response.status_code\n+\n+\n+def delete_dicom_store(project_id, dataset_id, region, dicom_store_id):\n+  # Delete an existing DICOM store\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+  api_endpoint = \"{}/projects/{}/locations/{}\".format(\n+      HEALTHCARE_BASE_URL, project_id, region)\n+\n+  # base of dicomweb path.\n+  dicomweb_path = \"{}/datasets/{}/dicomStores/{}\".format(\n+      api_endpoint, dataset_id, dicom_store_id)\n+\n+  response = session.delete(dicomweb_path)\n+  response.raise_for_status()\n+  return response.status_code\n+\n+\n+def get_gcs_file_http(file_name):\n+  # Get gcs file from REST Api\n+  api_endpoint = \"{}/b/{}/o/{}?alt=media\".format(\n+      GCS_BASE_URL, TEMP_BUCKET_NAME, file_name)\n+\n+  credential, _ = default()\n+  session = requests.AuthorizedSession(credential)\n+\n+  response = session.get(api_endpoint)\n+  response.raise_for_status()\n+  return response.json()\n+\n+\n+@unittest.skipIf(DicomSearch is None, 'GCP dependencies are not installed')\n+class DICOMIoIntegrationTest(unittest.TestCase):\n+  def setUp(self):\n+    self.test_pipeline = TestPipeline(is_integration_test=True)\n+    self.project = self.test_pipeline.get_option('project')\n+    self.expected_output_all_metadata = get_gcs_file_http(META_DATA_ALL_NAME)\n+    self.expected_output_refined_metadata = get_gcs_file_http(\n+        META_DATA_REFINED_NAME)\n+\n+    # create a temp Dicom store based on the time stamp\n+    self.temp_dicom_store = \"DICOM_store_\" + random_string_generator(RAND_LEN)\n+    create_dicom_store(self.project, DATA_SET_ID, REGION, self.temp_dicom_store)\n+\n+  def tearDown(self):\n+    # clean up the temp Dicom store\n+    delete_dicom_store(self.project, DATA_SET_ID, REGION, self.temp_dicom_store)\n+\n+  @attr('IT')\n+  def test_dicom_search_all_instances(self):\n+    # Search and compare the metadata of a persistent DICOM store.\n+    input_dict = {}\n+    input_dict['project_id'] = self.project\n+    input_dict['region'] = REGION\n+    input_dict['dataset_id'] = DATA_SET_ID\n+    input_dict['dicom_store_id'] = PERSISTENT_DICOM_STORE_NAME\n+    input_dict['search_type'] = \"instances\"\n+\n+    expected_dict = {}\n+    expected_dict['result'] = self.expected_output_all_metadata\n+    expected_dict['status'] = 200\n+    expected_dict['input'] = input_dict\n+    expected_dict['success'] = True\n+\n+    with self.test_pipeline as p:\n+      results = (p | beam.Create([input_dict]) | DicomSearch())\n+      assert_that(results, equal_to([expected_dict]), label='all search assert')\n+\n+  @attr('IT')\n+  def test_dicom_search_refined_instances(self):\n+    # Refine search and compare the metadata of a persistent DICOM store.\n+    input_dict = {}\n+    input_dict['project_id'] = self.project\n+    input_dict['region'] = REGION\n+    input_dict['dataset_id'] = DATA_SET_ID\n+    input_dict['dicom_store_id'] = PERSISTENT_DICOM_STORE_NAME\n+    input_dict['search_type'] = \"instances\"\n+    input_dict['params'] = {\n+        'StudyInstanceUID': 'study_000000001', 'limit': 500, 'offset': 0\n+    }\n+\n+    expected_dict = {}\n+    expected_dict['result'] = self.expected_output_refined_metadata\n+    expected_dict['status'] = 200\n+    expected_dict['input'] = input_dict\n+    expected_dict['success'] = True\n+\n+    with self.test_pipeline as p:\n+      results = (p | beam.Create([input_dict]) | DicomSearch())\n+      assert_that(\n+          results, equal_to([expected_dict]), label='refine search assert')\n+\n+  @attr('IT')\n+  def test_dicom_store_instance_from_gcs(self):\n+    # Store DICOM files to a empty DICOM store from a GCS bucket,\n+    # then check if the store metadata match.\n+    input_dict_store = {}\n+    input_dict_store['project_id'] = self.project\n+    input_dict_store['region'] = REGION\n+    input_dict_store['dataset_id'] = DATA_SET_ID\n+    input_dict_store['dicom_store_id'] = self.temp_dicom_store\n+\n+    expected_output = [True] * NUM_INSTANCE\n+\n+    with self.test_pipeline as p:\n+      gcs_path = TEMP_FILES_PATH + \"/dicom_files/*\"\n+      results = (\n+          p\n+          | fileio.MatchFiles(gcs_path)\n+          | fileio.ReadMatches()\n+          | UploadToDicomStore(input_dict_store, 'fileio')\n+          | beam.Map(lambda x: x['success']))\n+      assert_that(\n+          results, equal_to(expected_output), label='store first assert')\n+\n+    input_dict_search = {}\n+    input_dict_search['project_id'] = self.project\n+    input_dict_search['region'] = REGION\n+    input_dict_search['dataset_id'] = DATA_SET_ID\n+    input_dict_search['dicom_store_id'] = self.temp_dicom_store\n+    input_dict_search['search_type'] = \"instances\"\n+\n+    expected_dict = {}\n+    expected_dict['result'] = self.expected_output_all_metadata\n+    expected_dict['status'] = 200\n+    expected_dict['input'] = input_dict_search\n+    expected_dict['success'] = True\n+", "originalCommit": "6d44a2e776f0140139c893817622a63b1dcf22cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjczNjk0OA==", "url": "https://github.com/apache/beam/pull/12473#discussion_r466736948", "bodyText": "Pipeline reduced", "author": "George-Wu", "createdAt": "2020-08-06T23:22:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU2NjU3MQ=="}], "type": "inlineReview"}, {"oid": "15db728a5a7ea16c6535c41a19e8b6949f807e11", "url": "https://github.com/apache/beam/commit/15db728a5a7ea16c6535c41a19e8b6949f807e11", "message": "add documentation, use the right storage  and reduce number of pipelines.", "committedDate": "2020-08-06T23:19:22Z", "type": "commit"}, {"oid": "ab749d0b6d61dab91c14d0b7c29b63a70a26c8eb", "url": "https://github.com/apache/beam/commit/ab749d0b6d61dab91c14d0b7c29b63a70a26c8eb", "message": "add comment", "committedDate": "2020-08-07T00:04:09Z", "type": "commit"}, {"oid": "912a1f60d3cd40a8a7e3c72184c451086ef395bb", "url": "https://github.com/apache/beam/commit/912a1f60d3cd40a8a7e3c72184c451086ef395bb", "message": "modify client a little", "committedDate": "2020-08-07T18:29:30Z", "type": "commit"}]}