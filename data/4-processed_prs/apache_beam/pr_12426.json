{"pr_number": 12426, "pr_title": "[BEAM-7996] Add support for MapType and Nulls in container types for Python RowCoder", "pr_createdAt": "2020-07-30T18:34:46Z", "pr_url": "https://github.com/apache/beam/pull/12426", "timeline": [{"oid": "e850957ae3b7e6990cea32f76ce3645f5834a55e", "url": "https://github.com/apache/beam/commit/e850957ae3b7e6990cea32f76ce3645f5834a55e", "message": "Add support for encoding Maps and Nulls (in container types) in Python RowCoder", "committedDate": "2020-07-30T18:31:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE5NDUyNw==", "url": "https://github.com/apache/beam/pull/12426#discussion_r463194527", "bodyText": "This change is necessary because ImmutableMap (as well as Collectors.toMap) does not allow null values, so it errors on the new test cases.", "author": "TheNeuralBit", "createdAt": "2020-07-30T18:36:05Z", "path": "runners/core-construction-java/src/test/java/org/apache/beam/runners/core/construction/CommonCoderTest.java", "diffHunk": "@@ -366,12 +368,15 @@ private static Object parseField(Object value, Schema.FieldType fieldType) {\n                 .map((element) -> parseField(element, fieldType.getCollectionElementType()))\n                 .collect(toImmutableList());\n       case MAP:\n-        Map<Object, Object> kvMap = (Map<Object, Object>) value;\n-        return kvMap.entrySet().stream()\n-            .collect(\n-                toImmutableMap(\n-                    (pair) -> parseField(pair.getKey(), fieldType.getMapKeyType()),\n-                    (pair) -> parseField(pair.getValue(), fieldType.getMapValueType())));\n+        Map<Object, Object> kvMap = new HashMap<>();\n+        ((Map<Object, Object>) value)\n+            .entrySet().stream()\n+                .forEach(\n+                    (entry) ->\n+                        kvMap.put(\n+                            parseField(entry.getKey(), fieldType.getMapKeyType()),\n+                            parseField(entry.getValue(), fieldType.getMapValueType())));\n+        return kvMap;", "originalCommit": "e850957ae3b7e6990cea32f76ce3645f5834a55e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE5NDk1Nw==", "url": "https://github.com/apache/beam/pull/12426#discussion_r463194957", "bodyText": "FYI @lostluck - previously the encoding for MapType and for nullable types within containers was not documented.", "author": "TheNeuralBit", "createdAt": "2020-07-30T18:36:51Z", "path": "model/pipeline/src/main/proto/beam_runner_api.proto", "diffHunk": "@@ -855,10 +855,21 @@ message StandardCoders {\n     //     BOOLEAN:   beam:coder:bool:v1\n     //     BYTES:     beam:coder:bytes:v1\n     //   ArrayType:   beam:coder:iterable:v1 (always has a known length)\n-    //   MapType:     not yet a standard coder (BEAM-7996)\n+    //   MapType:     not a standard coder, specification defined below.\n     //   RowType:     beam:coder:row:v1\n     //   LogicalType: Uses the coder for its representation.\n     //\n+    // The MapType is encoded by:\n+    //   - An INT32 representing the size of the map (N)\n+    //   - Followed by N interleaved keys and values, encoded with their\n+    //     corresponding coder.\n+    //\n+    // Nullable types in container types (ArrayType, MapType) are encoded by:\n+    //   - A one byte null indicator, 0x00 for null values, or 0x01 for present\n+    //     values.\n+    //   - For present values the null indicator is followed by the value\n+    //     encoded with it's corresponding coder.\n+    //", "originalCommit": "e850957ae3b7e6990cea32f76ce3645f5834a55e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzIwODQwNA==", "url": "https://github.com/apache/beam/pull/12426#discussion_r463208404", "bodyText": "Ack! Thanks!", "author": "lostluck", "createdAt": "2020-07-30T19:02:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE5NDk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5MDk2MQ==", "url": "https://github.com/apache/beam/pull/12426#discussion_r463290961", "bodyText": "Is this just the encoding of a nullable type? (Why does it have to be called out specially?)", "author": "robertwb", "createdAt": "2020-07-30T21:49:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE5NDk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5MTk2OA==", "url": "https://github.com/apache/beam/pull/12426#discussion_r463291968", "bodyText": "For maps specifically, do we want to allow null keys? Is it valuable to have null values (as distinct from just not present)? I might lean towards disallowing nulls and then possibly allowing it in the future if we have good reason to, which will be forward compatible.", "author": "robertwb", "createdAt": "2020-07-30T21:51:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE5NDk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMxMTE5Nw==", "url": "https://github.com/apache/beam/pull/12426#discussion_r463311197", "bodyText": "This is specifically for nullable types that are elements of an Array or keys/values of a Map. For rows we encode nulls in a separate bitmask:\n\n  \n    \n      beam/model/pipeline/src/main/proto/beam_runner_api.proto\n    \n    \n        Lines 837 to 843\n      in\n      587dde5\n    \n    \n    \n    \n\n        \n          \n           //   - A byte array representing a packed bitset indicating null fields (a \n        \n\n        \n          \n           //     1 indicating a null) encoded with beam:coder:bytes:v1. The unused \n        \n\n        \n          \n           //     bits in the last byte must be set to 0. If there are no nulls an \n        \n\n        \n          \n           //     empty byte array is encoded. \n        \n\n        \n          \n           //     The two-byte bitset (not including the lenghth-prefix) for the row \n        \n\n        \n          \n           //     [NULL, 0, 0, 0, NULL, 0, 0, NULL, 0, NULL] would be \n        \n\n        \n          \n           //     [0b10010001, 0b00000010] \n        \n    \n  \n\n\nJava schemas will already let you use nullable types for keys and values in Maps. I doubt anyone is relying on it.. but there's a risk if we disallow it now.", "author": "TheNeuralBit", "createdAt": "2020-07-30T22:40:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE5NDk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU1MDIwNw==", "url": "https://github.com/apache/beam/pull/12426#discussion_r464550207", "bodyText": "Just so I understand it right, at the schema level, is nullability field is a property of the schema (rather than having an optional type)? So there's no way to declare a map as not (potentially) having null keys/values?", "author": "robertwb", "createdAt": "2020-08-03T17:17:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE5NDk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczMjMwNw==", "url": "https://github.com/apache/beam/pull/12426#discussion_r464732307", "bodyText": "That's right. Nullability is represented on the FieldType: \n  \n    \n      beam/model/pipeline/src/main/proto/schema.proto\n    \n    \n         Line 47\n      in\n      d5a6c2f\n    \n    \n    \n    \n\n        \n          \n           bool nullable = 1; \n        \n    \n  \n\n\nWe could document that schemas should not accept null keys/values in MapType and reject them in the SDKs. But there would still be an unused nullable field on the key and value FieldType:\n\n  \n    \n      beam/model/pipeline/src/main/proto/schema.proto\n    \n    \n        Lines 79 to 82\n      in\n      d5a6c2f\n    \n    \n    \n    \n\n        \n          \n           message MapType { \n        \n\n        \n          \n             FieldType key_type = 1; \n        \n\n        \n          \n             FieldType value_type = 2; \n        \n\n        \n          \n           }", "author": "TheNeuralBit", "createdAt": "2020-08-04T00:32:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE5NDk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE4MTAzMw==", "url": "https://github.com/apache/beam/pull/12426#discussion_r465181033", "bodyText": "So the verdict here is to ignore the nullability field of a FieldType when it's nested in a Map or Array?\nThat's... unfortunate. Must we bend over backwards to maintain compatibility with Java's previous encoding, which wasn't officially a schema encoding until this PR? It seems very strange that we're already relying on unspecified behaviour.", "author": "lostluck", "createdAt": "2020-08-04T16:34:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE5NDk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwMjkzMQ==", "url": "https://github.com/apache/beam/pull/12426#discussion_r465202931", "bodyText": "Also, this requirement means that all values must be pointers (or reference types) in Go as ordinary primitives cannot be nullable. That feels very strange.\nEDIT: Please disregard my last comments, I misread that this only applies to when the field is specified as nullable.\nI misunderstood that the discussion is orthogonal to that (whether to allow nullable map components at all.)", "author": "lostluck", "createdAt": "2020-08-04T17:11:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE5NDk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIyMzM5OA==", "url": "https://github.com/apache/beam/pull/12426#discussion_r465223398", "bodyText": "@robertwb Your comment fed my own misunderstanding. It is possible to declare a map in schemas as not having null/keys values, but not necessarily on the SDK side.\nTechnically, there's no reason that the SDK can't use a non-nullable containing version of the container if the Key and Value components are not themselves marked as nillable. IIRC, the Java SDK could converted ImmutableMaps or similar into just non-nullable Key and non-nullable Value types.\nThe issue as I'm understanding it is that the limitation is on the SDK Language side, rather than the schema specification side, as discussed the schemas fields can individually have their nullable bits set.\nEg. Go doesn't have this ambiguity for map types.\nOn the other hand, in Go, Iterable/array types which will be represented by slices will have this ambiguity when used as a field, as they can be nil, and could also still be pointers to said reference types. That ambiguity is well known enough that pointers to reference types (maps, slices, chans..) are strongly discouraged in idiomatic Go.", "author": "lostluck", "createdAt": "2020-08-04T17:46:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE5NDk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQwMDcxNw==", "url": "https://github.com/apache/beam/pull/12426#discussion_r465400717", "bodyText": "@lostluck The issue here is what kinds of objects the SDK must accept when receiving these from a foreign SDK. If nulls are allowed, you cannot let the element type be (say) a map[str, int] in go.\nIt looks like there is a way to specify in the schema whether the keys/values could be null (or explicitly disallow it for either or both). The encoding, on the other hand, always has this leading bit set (regardless of whether the schema allows null values), but is harder to change for backwards compatibility reasons. If this is the case, I'm OK with that.", "author": "robertwb", "createdAt": "2020-08-05T00:19:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE5NDk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQwMjE5OQ==", "url": "https://github.com/apache/beam/pull/12426#discussion_r465402199", "bodyText": "Nevermind, we set this prefix depending on the bit in the schema. All is good.", "author": "robertwb", "createdAt": "2020-08-05T00:25:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE5NDk1Nw=="}], "type": "inlineReview"}, {"oid": "587dde57cbb2b0095a1fa04b59798d1b62c66f18", "url": "https://github.com/apache/beam/commit/587dde57cbb2b0095a1fa04b59798d1b62c66f18", "message": "fixup! Add support for encoding Maps and Nulls (in container types) in Python RowCoder", "committedDate": "2020-07-30T21:05:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5MjY5NA==", "url": "https://github.com/apache/beam/pull/12426#discussion_r463292694", "bodyText": "We don't care about larger maps? Also, why not varint? (If that's what's conventionally used elsewhere, I'm fine with that, but iterable coder uses varint64.)", "author": "robertwb", "createdAt": "2020-07-30T21:52:57Z", "path": "sdks/python/apache_beam/coders/coder_impl.py", "diffHunk": "@@ -530,6 +530,88 @@ def estimate_size(self, unused_value, nested=False):\n     return 1\n \n \n+class MapCoderImpl(StreamCoderImpl):\n+  \"\"\"For internal use only; no backwards-compatibility guarantees.\n+\n+  A coder for typing.Mapping objects.\"\"\"\n+  def __init__(\n+      self,\n+      key_coder,  # type: CoderImpl\n+      value_coder  # type: CoderImpl\n+  ):\n+    self._key_coder = key_coder\n+    self._value_coder = value_coder\n+\n+  def encode_to_stream(self, value, out, nested):\n+    size = len(value)\n+    out.write_bigendian_int32(size)", "originalCommit": "587dde57cbb2b0095a1fa04b59798d1b62c66f18", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwODY5Mw==", "url": "https://github.com/apache/beam/pull/12426#discussion_r463308693", "bodyText": "Yeah I thought about that too. I was just trying to exactly replicate what we do in MapCoder.java for now though. Do you think I should switch this and MapCoder.java over to using varint here?", "author": "TheNeuralBit", "createdAt": "2020-07-30T22:32:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5MjY5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU1NDU2MA==", "url": "https://github.com/apache/beam/pull/12426#discussion_r464554560", "bodyText": "This is unfortunate. We can't change MapCoder because that would be backwards incompatible (and users might have encoded Maps stored in states or elsewhere), so I suppose we'll have to stick with this limitation.", "author": "robertwb", "createdAt": "2020-08-03T17:26:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5MjY5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY0Nzk2Ng==", "url": "https://github.com/apache/beam/pull/12426#discussion_r464647966", "bodyText": "As a practical matter, int32 max of any amount of data is bigger than our GRPC limits for receiving single values into an SDK. At least, until we add a large value protocol to stream in single large values somewhere.", "author": "lostluck", "createdAt": "2020-08-03T20:35:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5MjY5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5MzEwMQ==", "url": "https://github.com/apache/beam/pull/12426#discussion_r463293101", "bodyText": "Just nest everything. That'll simplify the logic and the definition of the coder.", "author": "robertwb", "createdAt": "2020-07-30T21:53:58Z", "path": "sdks/python/apache_beam/coders/coder_impl.py", "diffHunk": "@@ -530,6 +530,88 @@ def estimate_size(self, unused_value, nested=False):\n     return 1\n \n \n+class MapCoderImpl(StreamCoderImpl):\n+  \"\"\"For internal use only; no backwards-compatibility guarantees.\n+\n+  A coder for typing.Mapping objects.\"\"\"\n+  def __init__(\n+      self,\n+      key_coder,  # type: CoderImpl\n+      value_coder  # type: CoderImpl\n+  ):\n+    self._key_coder = key_coder\n+    self._value_coder = value_coder\n+\n+  def encode_to_stream(self, value, out, nested):\n+    size = len(value)\n+    out.write_bigendian_int32(size)\n+    for i, kv in enumerate(value.items()):\n+      key, value = kv\n+      last = i == size - 1", "originalCommit": "587dde57cbb2b0095a1fa04b59798d1b62c66f18", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwODkxNw==", "url": "https://github.com/apache/beam/pull/12426#discussion_r463308917", "bodyText": "Same comment as above, this was just an attempt to replicate the Java logic. I could change them both if you think we should", "author": "TheNeuralBit", "createdAt": "2020-07-30T22:33:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5MzEwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU1NjgwOQ==", "url": "https://github.com/apache/beam/pull/12426#discussion_r464556809", "bodyText": "Here we have a bit better luck. The coders in Schemas are always used in nested context. Let's change this to not branch on nested, and make a note that these agree in this context, but as raw coder Java's (non-standard) Map is different for value types that have a different nested encoding.", "author": "robertwb", "createdAt": "2020-08-03T17:30:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5MzEwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE5NDI5Ng==", "url": "https://github.com/apache/beam/pull/12426#discussion_r465194296", "bodyText": "Good point, done.", "author": "TheNeuralBit", "createdAt": "2020-08-04T16:56:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI5MzEwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3Mzg5OA==", "url": "https://github.com/apache/beam/pull/12426#discussion_r465173898", "bodyText": "If schema coders are always used in a nested context, why is nested: false?", "author": "lostluck", "createdAt": "2020-08-04T16:23:14Z", "path": "model/fn-execution/src/main/resources/org/apache/beam/model/fnexecution/v1/standard_coders.yaml", "diffHunk": "@@ -384,3 +384,31 @@ nested: false\n examples:\n   \"\\x02\\x01\\x02\\x01\": {f_bool: True, f_bytes: null}\n   \"\\x02\\x00\\x00\\x04ab\\x00c\": {f_bool: False, f_bytes: \"ab\\0c\"}\n+\n+---\n+\n+# Binary data generated with the python SDK:\n+#\n+# import typing\n+# import apache_beam as beam\n+# class Test(typing.NamedTuple):\n+#   f_map: typing.Mapping[str,int]\n+# schema = beam.typehints.schemas.named_tuple_to_schema(Test)\n+# coder = beam.coders.row_coder.RowCoder(schema)\n+# print(\"payload = %s\" % schema.SerializeToString())\n+# examples = (Test(f_map={}),\n+#             Test(f_map={\"foo\": 9001, \"bar\": 9223372036854775807}),\n+#             Test(f_map={\"everything\": None, \"is\": None, \"null!\": None, \"\u00af\\_(\u30c4)_/\u00af\": None}))\n+# for example in examples:\n+#   print(\"example = %s\" % coder.encode(example))\n+coder:\n+  urn: \"beam:coder:row:v1\"\n+  # f_map: map<str, nullable int64>\n+  payload: \"\\n\\x15\\n\\x05f_map\\x1a\\x0c*\\n\\n\\x02\\x10\\x07\\x12\\x04\\x08\\x01\\x10\\x04\\x12$d8c8f969-14e6-457f-a8b5-62a1aec7f1cd\"\n+  # map ordering is non-deterministic\n+  non_deterministic: True\n+nested: false", "originalCommit": "587dde57cbb2b0095a1fa04b59798d1b62c66f18", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE4MDgwMg==", "url": "https://github.com/apache/beam/pull/12426#discussion_r465180802", "bodyText": "Robert was saying that the coders used to encode each attribute value are always nested. In the Java implementation we always call the version of encode which does not accept a context (as I understand it most implementations default to the nested encoding in this case):\n\n  \n    \n      beam/sdks/java/core/src/main/java/org/apache/beam/sdk/coders/RowCoderGenerator.java\n    \n    \n        Lines 267 to 272\n      in\n      1bf60b9\n    \n    \n    \n    \n\n        \n          \n           for (int idx = 0; idx < value.getFieldCount(); ++idx) { \n        \n\n        \n          \n             Object fieldValue = value.getValue(idx); \n        \n\n        \n          \n             if (value.getValue(idx) != null) { \n        \n\n        \n          \n               coders[idx].encode(fieldValue, outputStream); \n        \n\n        \n          \n             } \n        \n\n        \n          \n           }", "author": "TheNeuralBit", "createdAt": "2020-08-04T16:34:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3Mzg5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE4OTAxMA==", "url": "https://github.com/apache/beam/pull/12426#discussion_r465189010", "bodyText": "As it stands, this is confusing for SDK authors writing tests against standard_coders.yaml, as I've got the go testing written I need to explicitly ignore the nested field for the row coders because they're all set to nested:false, rather than nested:true.\nThis is per my thread on the dev list: https://lists.apache.org/thread.html/r7da098363e6ce607ce96f9fbedb08f9f4757bedd68846aaeba5dd4f0%40%3Cdev.beam.apache.org%3E\nPortability only ever supports nested coders. The semantics of standard_coders.yaml say that\n#   nested: a boolean meaning whether the coder was used in the nested context. Missing means to\n#           test both contexts, a shorthand for when the coder is invariant across context.\n\n\n  \n    \n      beam/model/fn-execution/src/main/resources/org/apache/beam/model/fnexecution/v1/standard_coders.yaml\n    \n    \n         Line 24\n      in\n      587dde5\n    \n    \n    \n    \n\n        \n          \n           #   nested: a boolean meaning whether the coder was used in the nested context. Missing means to \n        \n    \n  \n\n\nMeaning that nested: false means that the outer most encoding has the length prefix if necessary.\nStructually, there's never a reason for a single schema value to have the wrapped length prefix (it's orthogonal to this aspect of the encoding, as any sub component is always nested as needed), so it's not included in the various payload examples.\nSo, I re-iterate: Why is nested: false, instead of nested true if the coding is going to be identical in both context?", "author": "lostluck", "createdAt": "2020-08-04T16:47:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3Mzg5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwNDA5Nw==", "url": "https://github.com/apache/beam/pull/12426#discussion_r465204097", "bodyText": "So, I re-iterate: Why is nested: false, instead of nested true if the coding is going to be identical in both context?\n\nYou're not re-iterating. You're asking the same question with a lot of new and different context.\nI don't think there's a good reason. If I had to guess - when I added the first row coder test I was new to Beam and coders and I didn't really understand nested vs un-nested, so I just picked one. I'm trying to change it now and it looks like Java is failing some of the nested=true cases - that's probably why. Looking into the failures now.", "author": "TheNeuralBit", "createdAt": "2020-08-04T17:13:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3Mzg5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIxMzQ2Mg==", "url": "https://github.com/apache/beam/pull/12426#discussion_r465213462", "bodyText": "Ack. Thank you. I figured as much. If it's not easy to clean up, I'm fine with the Go coder test blaming \"Legacy Java concerns\" in a comment for the hackaround.", "author": "lostluck", "createdAt": "2020-08-04T17:29:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3Mzg5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIxNTU1Nw==", "url": "https://github.com/apache/beam/pull/12426#discussion_r465215557", "bodyText": "Found the issue in Java. It's a bug in CommonCodersTest that occurs when testing both nested and un-nested. It happens because we share an object for the expected value:\n\n  \n    \n      beam/runners/core-construction-java/src/test/java/org/apache/beam/runners/core/construction/CommonCoderTest.java\n    \n    \n        Lines 193 to 196\n      in\n      1bf60b9\n    \n    \n    \n    \n\n        \n          \n           if (coderTestSpec.getNested() == null) { \n        \n\n        \n          \n             // Missing nested means both \n        \n\n        \n          \n             ret.add(OneCoderTestSpec.create(coder, true, serialized, value)); \n        \n\n        \n          \n             ret.add(OneCoderTestSpec.create(coder, false, serialized, value)); \n        \n    \n  \n\n\nand it get's mutated when parsing Rows:\n\n  \n    \n      beam/runners/core-construction-java/src/test/java/org/apache/beam/runners/core/construction/CommonCoderTest.java\n    \n    \n         Line 380\n      in\n      1bf60b9\n    \n    \n    \n    \n\n        \n          \n           Object element = rowMap.remove(field.getName()); \n        \n    \n  \n\n\nIt's a pretty easy fix I can apply here. Is it ok if the row test case just doesn't specify nested, or are you thinking it should be nested: true?", "author": "TheNeuralBit", "createdAt": "2020-08-04T17:33:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3Mzg5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIxNjEyMA==", "url": "https://github.com/apache/beam/pull/12426#discussion_r465216120", "bodyText": "I bet I ran into this way back when and I just opted to pick a (bad) value for nested rather than uncovering this issue.", "author": "TheNeuralBit", "createdAt": "2020-08-04T17:34:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3Mzg5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIyNDUwMg==", "url": "https://github.com/apache/beam/pull/12426#discussion_r465224502", "bodyText": "Not specifying it would be ideal, as it avoids the hack, so the SDK can only run the \"nested\" tests, just like the other values.", "author": "lostluck", "createdAt": "2020-08-04T17:48:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3Mzg5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIzODcwNQ==", "url": "https://github.com/apache/beam/pull/12426#discussion_r465238705", "bodyText": "Done! nested is no longer specified.", "author": "TheNeuralBit", "createdAt": "2020-08-04T18:14:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE3Mzg5OA=="}], "type": "inlineReview"}, {"oid": "0dfff978855e2e12087cd37f854eeffb6b2f2d91", "url": "https://github.com/apache/beam/commit/0dfff978855e2e12087cd37f854eeffb6b2f2d91", "message": "fixup! Add support for encoding Maps and Nulls (in container types) in Python RowCoder", "committedDate": "2020-08-04T16:56:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwMDYxOQ==", "url": "https://github.com/apache/beam/pull/12426#discussion_r465200619", "bodyText": "There needs to be a space between f_map: and {} in all three examples. Otherwise it doesn't parse as valid yaml.\nhttps://yaml.org/spec/1.2/spec.html#id2759963  Mappings use a colon and space  (\": \") to mark each key: value pair.\nI copied the example into my local working copy so I could get the code going, and the Go YAML parser I'm using is strict.", "author": "lostluck", "createdAt": "2020-08-04T17:07:22Z", "path": "model/fn-execution/src/main/resources/org/apache/beam/model/fnexecution/v1/standard_coders.yaml", "diffHunk": "@@ -384,3 +384,31 @@ nested: false\n examples:\n   \"\\x02\\x01\\x02\\x01\": {f_bool: True, f_bytes: null}\n   \"\\x02\\x00\\x00\\x04ab\\x00c\": {f_bool: False, f_bytes: \"ab\\0c\"}\n+\n+---\n+\n+# Binary data generated with the python SDK:\n+#\n+# import typing\n+# import apache_beam as beam\n+# class Test(typing.NamedTuple):\n+#   f_map: typing.Mapping[str,int]\n+# schema = beam.typehints.schemas.named_tuple_to_schema(Test)\n+# coder = beam.coders.row_coder.RowCoder(schema)\n+# print(\"payload = %s\" % schema.SerializeToString())\n+# examples = (Test(f_map={}),\n+#             Test(f_map={\"foo\": 9001, \"bar\": 9223372036854775807}),\n+#             Test(f_map={\"everything\": None, \"is\": None, \"null!\": None, \"\u00af\\_(\u30c4)_/\u00af\": None}))\n+# for example in examples:\n+#   print(\"example = %s\" % coder.encode(example))\n+coder:\n+  urn: \"beam:coder:row:v1\"\n+  # f_map: map<str, nullable int64>\n+  payload: \"\\n\\x15\\n\\x05f_map\\x1a\\x0c*\\n\\n\\x02\\x10\\x07\\x12\\x04\\x08\\x01\\x10\\x04\\x12$d8c8f969-14e6-457f-a8b5-62a1aec7f1cd\"\n+  # map ordering is non-deterministic\n+  non_deterministic: True\n+nested: false\n+examples:\n+  \"\\x01\\x00\\x00\\x00\\x00\\x00\": {f_map:{}}\n+  \"\\x01\\x00\\x00\\x00\\x00\\x02\\x03foo\\x01\\xa9F\\x03bar\\x01\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x7f\": {f_map:{\"foo\": 9001, \"bar\": 9223372036854775807}}\n+  \"\\x01\\x00\\x00\\x00\\x00\\x04\\neverything\\x00\\x02is\\x00\\x05null!\\x00\\r\\xc2\\xaf\\\\_(\\xe3\\x83\\x84)_/\\xc2\\xaf\\x00\": {f_map:{\"everything\":null, \"is\": null, \"null!\": null, \"\u00af\\\\_(\u30c4)_/\u00af\": null}}", "originalCommit": "587dde57cbb2b0095a1fa04b59798d1b62c66f18", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwNDIyMw==", "url": "https://github.com/apache/beam/pull/12426#discussion_r465204223", "bodyText": "Ack, thanks", "author": "TheNeuralBit", "createdAt": "2020-08-04T17:13:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwMDYxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIzODE1Ng==", "url": "https://github.com/apache/beam/pull/12426#discussion_r465238156", "bodyText": "Done!", "author": "TheNeuralBit", "createdAt": "2020-08-04T18:13:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwMDYxOQ=="}], "type": "inlineReview"}, {"oid": "16c06ea87222f3a35bb38dda66d71361722270d8", "url": "https://github.com/apache/beam/commit/16c06ea87222f3a35bb38dda66d71361722270d8", "message": "Don't specify nested in row coder tests", "committedDate": "2020-08-04T18:07:30Z", "type": "commit"}, {"oid": "33354403a0e22dd20646175e34f12b379a5ef75e", "url": "https://github.com/apache/beam/commit/33354403a0e22dd20646175e34f12b379a5ef75e", "message": "fixup! Add support for encoding Maps and Nulls (in container types) in Python RowCoder", "committedDate": "2020-08-04T18:07:52Z", "type": "commit"}, {"oid": "0416e2ed65e5e859c4db1466254758a30d2200b7", "url": "https://github.com/apache/beam/commit/0416e2ed65e5e859c4db1466254758a30d2200b7", "message": "Don't mutate value when reading rows", "committedDate": "2020-08-04T18:08:24Z", "type": "commit"}, {"oid": "9bb591d9a8238a87bd8e44a82f3be7a84ca4b4e7", "url": "https://github.com/apache/beam/commit/9bb591d9a8238a87bd8e44a82f3be7a84ca4b4e7", "message": "fixup! Add support for encoding Maps and Nulls (in container types) in Python RowCoder", "committedDate": "2020-08-04T18:11:07Z", "type": "commit"}, {"oid": "d4f55982291aa23dd4ea2284ee74194dc65ec9cc", "url": "https://github.com/apache/beam/commit/d4f55982291aa23dd4ea2284ee74194dc65ec9cc", "message": "fixup! Add support for encoding Maps and Nulls (in container types) in Python RowCoder", "committedDate": "2020-08-04T22:21:25Z", "type": "commit"}, {"oid": "73f5602c9eb2fc4a7971fdea12faa0badf0c26b0", "url": "https://github.com/apache/beam/commit/73f5602c9eb2fc4a7971fdea12faa0badf0c26b0", "message": "Python: Don't mutate value", "committedDate": "2020-08-04T22:22:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQwMTQ5OQ==", "url": "https://github.com/apache/beam/pull/12426#discussion_r465401499", "bodyText": "nit: no need to make this a local", "author": "robertwb", "createdAt": "2020-08-05T00:22:51Z", "path": "sdks/python/apache_beam/coders/coder_impl.py", "diffHunk": "@@ -530,6 +530,93 @@ def estimate_size(self, unused_value, nested=False):\n     return 1\n \n \n+class MapCoderImpl(StreamCoderImpl):\n+  \"\"\"For internal use only; no backwards-compatibility guarantees.\n+\n+  Note this implementation always uses nested context when encoding keys\n+  and values. This differs from Java's MapCoder, which uses\n+  nested=False if possible for the last value encoded.\n+\n+  This difference is acceptable because MapCoder is not standard. It is only\n+  used in a standard context by RowCoder which always uses nested context for\n+  attribute values.\n+\n+  A coder for typing.Mapping objects.\"\"\"\n+  def __init__(\n+      self,\n+      key_coder,  # type: CoderImpl\n+      value_coder  # type: CoderImpl\n+  ):\n+    self._key_coder = key_coder\n+    self._value_coder = value_coder\n+\n+  def encode_to_stream(self, dict_value, out, nested):\n+    size = len(dict_value)", "originalCommit": "73f5602c9eb2fc4a7971fdea12faa0badf0c26b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "31f246e62056ecf9c1acb0a816b2feef555020c2", "url": "https://github.com/apache/beam/commit/31f246e62056ecf9c1acb0a816b2feef555020c2", "message": "fixup! Add support for encoding Maps and Nulls (in container types) in Python RowCoder", "committedDate": "2020-08-05T21:45:20Z", "type": "commit"}]}