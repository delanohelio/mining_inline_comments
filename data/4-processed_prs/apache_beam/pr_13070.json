{"pr_number": 13070, "pr_title": "[BEAM-11020] Adding multi-window splitting to Go SDF.", "pr_createdAt": "2020-10-10T01:05:39Z", "pr_url": "https://github.com/apache/beam/pull/13070", "timeline": [{"oid": "fe29508cd852beb5de2c9e7670344ea39eaf1048", "url": "https://github.com/apache/beam/commit/fe29508cd852beb5de2c9e7670344ea39eaf1048", "message": "[BEAM-11020] Adding multi-window splitting to Go SDF.\n\nAdjust Go SDF splitting and execution code so that splits take exploded windows into consideration and perform splits at window boundaries. Also required adjusting various split logic to accept multiple residuals and primaries from splits.", "committedDate": "2020-10-10T01:01:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcyNzAyNA==", "url": "https://github.com/apache/beam/pull/13070#discussion_r502727024", "bodyText": "RM commented out line, OR swap the line below it with one that doesn't _ ignore the index. As far as I can read it,\nfor i, w := range elm.Windows {  should be identical and let you remove w := elm.Windows[i]", "author": "lostluck", "createdAt": "2020-10-10T01:18:55Z", "path": "sdks/go/pkg/beam/core/runtime/exec/sdf.go", "diffHunk": "@@ -338,12 +348,17 @@ func (n *ProcessSizedElementsAndRestrictions) ProcessElement(_ context.Context,\n \t\t// If we need to process the element in multiple windows, each one needs\n \t\t// its own RTracker and progress must be tracked among all windows by\n \t\t// currW updated between processing.\n-\t\tfor _, w := range elm.Windows {\n+\t\tn.numW = len(elm.Windows)\n+\n+\t\t//for _, w := range elm.Windows {", "originalCommit": "fe29508cd852beb5de2c9e7670344ea39eaf1048", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUyNjY5Mw==", "url": "https://github.com/apache/beam/pull/13070#discussion_r503526693", "bodyText": "Removed the commented out line. It's actually not identical because a dynamic split can modify n.numW if some of the windows are split with the residual, which is why I loop using numW instead. I could theoretically loop based on len(elm.Windows) instead, avoiding the range keyword, and directly trim the windows slice in the current element, but I don't know if there's any advantage to doing it that way and this seems simpler.", "author": "youngoli", "createdAt": "2020-10-12T20:53:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcyNzAyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ4NDQyNA==", "url": "https://github.com/apache/beam/pull/13070#discussion_r503484424", "bodyText": "Nit: nil seemed more explicit, why was this changed? (On that note, if one is empty must the other be empty as well, or is it OK to have one non-empty and treat that as an unsuccessful split?)", "author": "robertwb", "createdAt": "2020-10-12T19:13:24Z", "path": "sdks/go/pkg/beam/core/runtime/exec/datasource.go", "diffHunk": "@@ -354,12 +354,12 @@ func (n *DataSource) Split(splits []int64, frac float64, bufSize int64) (SplitRe\n \t\treturn SplitResult{PI: s - 1, RI: s}, nil\n \t}\n \t// Otherwise, perform a sub-element split.\n-\tp, r, err := su.Split(fr)\n+\tps, rs, err := su.Split(fr)\n \tif err != nil {\n \t\treturn SplitResult{}, err\n \t}\n \n-\tif p == nil || r == nil { // Unsuccessful split.\n+\tif len(ps) == 0 || len(rs) == 0 { // Unsuccessful split.", "originalCommit": "fe29508cd852beb5de2c9e7670344ea39eaf1048", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUzMDIwNQ==", "url": "https://github.com/apache/beam/pull/13070#discussion_r503530205", "bodyText": "Just because once I moved to slices, having an empty slice seemed to make more sense to indicate \"the function worked, but the result was empty\", rather than nil slices which is what gets returned for errors. I could switch it back to nil, since that was mostly a stylistic choice.\nChecking over the code, yeah it looks like if one is empty I always just return both empty. But I think I used an \"or\" here just to avoid relying on implementation details of the split. Basically, if even one of them is missing then then Datasource knows the split failed, and doesn't have to really know what exactly happened.", "author": "youngoli", "createdAt": "2020-10-12T21:01:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ4NDQyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU2OTU0MA==", "url": "https://github.com/apache/beam/pull/13070#discussion_r503569540", "bodyText": "Idiomatically, if there's no intended semantic real difference between nil and empty, then checking the length is the correct way to handle that. nil slices are also 0 length.\nThis catches the error case that empty slices are generated, and hints to the compiler that there's at least 1 entry in the slices after this if block.", "author": "lostluck", "createdAt": "2020-10-12T22:42:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ4NDQyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ5NDk4Ng==", "url": "https://github.com/apache/beam/pull/13070#discussion_r503494986", "bodyText": "Is there a convention here you could use to assert that there's only one element while getting it, rather than let any (unexpected?) other elements in the list be dropped?", "author": "robertwb", "createdAt": "2020-10-12T19:39:00Z", "path": "sdks/go/pkg/beam/core/runtime/exec/dynsplit_test.go", "diffHunk": "@@ -103,11 +103,11 @@ func TestDynamicSplit(t *testing.T) {\n \t\t\t// with the input coder to the path.\n \t\t\t// TODO(BEAM-10579) Switch to using splittable unit's input coder\n \t\t\t// once that is implemented.\n-\t\t\tp, err := decodeDynSplitElm(splitRes.split.PS, cdr)\n+\t\t\tp, err := decodeDynSplitElm(splitRes.split.PS[0], cdr)", "originalCommit": "fe29508cd852beb5de2c9e7670344ea39eaf1048", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUzMDU3OQ==", "url": "https://github.com/apache/beam/pull/13070#discussion_r503530579", "bodyText": "That would be useful. @lostluck , know of anything? If not I can just explicitly check that it only has a length of one, because that is an expectation of the test.", "author": "youngoli", "createdAt": "2020-10-12T21:02:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ5NDk4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3MDIxNw==", "url": "https://github.com/apache/beam/pull/13070#discussion_r503570217", "bodyText": "Go, being a simple language would have you put the if in there. It would be a waste to wrap it in a function unless the pattern is repeating. At least not until generics land and we can define a GetOnlyElement[T any](slice []T) { ... } helper.", "author": "lostluck", "createdAt": "2020-10-12T22:44:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ5NDk4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ5NjI0Mw==", "url": "https://github.com/apache/beam/pull/13070#discussion_r503496243", "bodyText": "Ws his an existing bug?", "author": "robertwb", "createdAt": "2020-10-12T19:42:14Z", "path": "sdks/go/pkg/beam/io/rtrackers/offsetrange/offsetrange.go", "diffHunk": "@@ -180,8 +180,8 @@ func (tracker *Tracker) TrySplit(fraction float64) (primary, residual interface{\n \n // GetProgress reports progress based on the claimed size and unclaimed sizes of the restriction.\n func (tracker *Tracker) GetProgress() (done, remaining float64) {\n-\tdone = float64(tracker.claimed - tracker.rest.Start)\n-\tremaining = float64(tracker.rest.End - tracker.claimed)\n+\tdone = float64((tracker.claimed + 1) - tracker.rest.Start)", "originalCommit": "fe29508cd852beb5de2c9e7670344ea39eaf1048", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUzMDgxNQ==", "url": "https://github.com/apache/beam/pull/13070#discussion_r503530815", "bodyText": "Yeah, it's something I missed because I was only testing this code with large ranges, and it's most noticeable with small ranges.", "author": "youngoli", "createdAt": "2020-10-12T21:03:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ5NjI0Mw=="}], "type": "inlineReview"}, {"oid": "39e18a699d766cfcbc5e5b5cc00a4f456c8fe71f", "url": "https://github.com/apache/beam/commit/39e18a699d766cfcbc5e5b5cc00a4f456c8fe71f", "message": "[BEAM-11020] Fixup", "committedDate": "2020-10-12T22:20:32Z", "type": "commit"}, {"oid": "2aed66719e86f7ce8a11a7011bd28bcd9bd16081", "url": "https://github.com/apache/beam/commit/2aed66719e86f7ce8a11a7011bd28bcd9bd16081", "message": "[BEAM-11020] More Fixup", "committedDate": "2020-10-14T00:41:05Z", "type": "commit"}]}