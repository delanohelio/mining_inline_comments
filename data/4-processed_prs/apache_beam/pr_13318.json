{"pr_number": 13318, "pr_title": "[BEAM-11300] Improve Nexmark performance:", "pr_createdAt": "2020-11-12T14:12:43Z", "pr_url": "https://github.com/apache/beam/pull/13318", "timeline": [{"oid": "3d980846c1da07171fb1615432f7424cef521038", "url": "https://github.com/apache/beam/commit/3d980846c1da07171fb1615432f7424cef521038", "message": "Improve Nexmark performance:\n\nChange Query3 to use stateful processing and timers without\nCoGroupByKey which introduces additional windowing and shuffling.\n\nChange Query5 to avoid unnecessary lists when combining.\n\nChange Query10 to avoid excessive logging.", "committedDate": "2020-11-12T21:02:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2ODAwOQ==", "url": "https://github.com/apache/beam/pull/13318#discussion_r525368009", "bodyText": "Simpler to do\n.apply(\"EventByAuctionSeller\", WithKeys.of(Auction::seller).withKeyType(TypeDescriptors.longs()))", "author": "reuvenlax", "createdAt": "2020-11-17T17:53:54Z", "path": "sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java", "diffHunk": "@@ -83,27 +75,29 @@ public Query3(NexmarkConfiguration configuration) {\n \n   @Override\n   public PCollection<NameCityStateId> expand(PCollection<Event> events) {\n-    int numEventsInPane = 30;\n-\n-    PCollection<Event> eventsWindowed =\n-        events.apply(\n-            Window.<Event>into(new GlobalWindows())\n-                .triggering(Repeatedly.forever(AfterPane.elementCountAtLeast(numEventsInPane)))\n-                .discardingFiredPanes()\n-                .withAllowedLateness(Duration.ZERO));\n-    PCollection<KV<Long, Auction>> auctionsBySellerId =\n-        eventsWindowed\n+    PCollection<KV<Long, Event>> auctionsBySellerId =\n+        events\n             // Only want the new auction events.\n             .apply(NexmarkQueryUtil.JUST_NEW_AUCTIONS)\n \n             // We only want auctions in category 10.\n             .apply(name + \".InCategory\", Filter.by(auction -> auction.category == 10))\n \n             // Key auctions by their seller id.\n-            .apply(\"AuctionBySeller\", NexmarkQueryUtil.AUCTION_BY_SELLER);\n-\n-    PCollection<KV<Long, Person>> personsById =\n-        eventsWindowed\n+            .apply(", "originalCommit": "3d980846c1da07171fb1615432f7424cef521038", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAxNzU4NQ==", "url": "https://github.com/apache/beam/pull/13318#discussion_r526017585", "bodyText": "this doesn't work because we also need to change to the union Event type.\nAlso Auction::seller has the error \"Objects is not a functional interface\".\nSo I kept as is, let me know if you'd rather WithKeys and then some auction->event with auction pardo. If you do, do you have suggestions on fixing the error?  My java is out of date so I'm not sure how to fix that off the top of my head.", "author": "scwhittle", "createdAt": "2020-11-18T11:34:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2ODAwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2ODIwMg==", "url": "https://github.com/apache/beam/pull/13318#discussion_r525368202", "bodyText": "Ditto - simpler to use WithKeys", "author": "reuvenlax", "createdAt": "2020-11-17T17:54:09Z", "path": "sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java", "diffHunk": "@@ -115,19 +109,23 @@ public Query3(NexmarkConfiguration configuration) {\n                         \"OR\".equals(person.state)\n                             || \"ID\".equals(person.state)\n                             || \"CA\".equals(person.state)))\n+            .apply(", "originalCommit": "3d980846c1da07171fb1615432f7424cef521038", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAxNzY0Ng==", "url": "https://github.com/apache/beam/pull/13318#discussion_r526017646", "bodyText": "ditto", "author": "scwhittle", "createdAt": "2020-11-18T11:34:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2ODIwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2OTQwNw==", "url": "https://github.com/apache/beam/pull/13318#discussion_r525369407", "bodyText": "Instead of ProcessContext just inject @element and OutputReceiver parameters", "author": "reuvenlax", "createdAt": "2020-11-17T17:55:50Z", "path": "sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java", "diffHunk": "@@ -197,85 +195,60 @@ private JoinDoFn(String name, int maxAuctionsWaitingTime) {\n     @ProcessElement\n     public void processElement(\n         ProcessContext c,", "originalCommit": "3d980846c1da07171fb1615432f7424cef521038", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAxNDI3Nw==", "url": "https://github.com/apache/beam/pull/13318#discussion_r526014277", "bodyText": "done", "author": "scwhittle", "createdAt": "2020-11-18T11:28:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2OTQwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3MDU1OA==", "url": "https://github.com/apache/beam/pull/13318#discussion_r525370558", "bodyText": "Comment - this is because Event is a union object, etc.", "author": "reuvenlax", "createdAt": "2020-11-17T17:57:29Z", "path": "sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java", "diffHunk": "@@ -197,85 +195,60 @@ private JoinDoFn(String name, int maxAuctionsWaitingTime) {\n     @ProcessElement\n     public void processElement(\n         ProcessContext c,\n-        @TimerId(PERSON_STATE_EXPIRING) Timer timer,\n-        @StateId(PERSON) ValueState<Person> personState,\n-        @StateId(AUCTIONS) ValueState<List<Auction>> auctionsState) {\n+        @TimerId(STATE_EXPIRING) Timer timer,\n+        @StateId(PERSON) @AlwaysFetched ValueState<Person> personState,\n+        @StateId(AUCTIONS) BagState<Auction> auctionsState) {\n       // We would *almost* implement this by  rewindowing into the global window and\n       // running a combiner over the result. The combiner's accumulator would be the\n       // state we use below. However, combiners cannot emit intermediate results, thus\n-      // we need to wait for the pending ReduceFn API.\n+      // we need to wait for the pending ReduceFn API\n \n       Person existingPerson = personState.read();\n-      if (existingPerson != null) {\n-        // We've already seen the new person event for this person id.\n-        // We can join with any new auctions on-the-fly without needing any\n-        // additional persistent state.\n-        for (Auction newAuction : c.element().getValue().getAll(NexmarkQueryUtil.AUCTION_TAG)) {\n-          newAuctionCounter.inc();\n-          newOldOutputCounter.inc();\n-          c.output(KV.of(newAuction, existingPerson));\n-        }\n-        return;\n-      }\n-\n-      Person theNewPerson = null;\n-      for (Person newPerson : c.element().getValue().getAll(NexmarkQueryUtil.PERSON_TAG)) {\n-        if (theNewPerson == null) {\n-          theNewPerson = newPerson;\n+      if (c.element().getValue().newPerson != null) {", "originalCommit": "3d980846c1da07171fb1615432f7424cef521038", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAxNTQ3MQ==", "url": "https://github.com/apache/beam/pull/13318#discussion_r526015471", "bodyText": "done", "author": "scwhittle", "createdAt": "2020-11-18T11:30:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3MDU1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3MTMzMg==", "url": "https://github.com/apache/beam/pull/13318#discussion_r525371332", "bodyText": "If this is not the first time this person has been seen, there's no point in even fetching auctionsState, right?", "author": "reuvenlax", "createdAt": "2020-11-17T17:58:43Z", "path": "sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java", "diffHunk": "@@ -197,85 +195,60 @@ private JoinDoFn(String name, int maxAuctionsWaitingTime) {\n     @ProcessElement\n     public void processElement(\n         ProcessContext c,\n-        @TimerId(PERSON_STATE_EXPIRING) Timer timer,\n-        @StateId(PERSON) ValueState<Person> personState,\n-        @StateId(AUCTIONS) ValueState<List<Auction>> auctionsState) {\n+        @TimerId(STATE_EXPIRING) Timer timer,\n+        @StateId(PERSON) @AlwaysFetched ValueState<Person> personState,\n+        @StateId(AUCTIONS) BagState<Auction> auctionsState) {\n       // We would *almost* implement this by  rewindowing into the global window and\n       // running a combiner over the result. The combiner's accumulator would be the\n       // state we use below. However, combiners cannot emit intermediate results, thus\n-      // we need to wait for the pending ReduceFn API.\n+      // we need to wait for the pending ReduceFn API\n \n       Person existingPerson = personState.read();\n-      if (existingPerson != null) {\n-        // We've already seen the new person event for this person id.\n-        // We can join with any new auctions on-the-fly without needing any\n-        // additional persistent state.\n-        for (Auction newAuction : c.element().getValue().getAll(NexmarkQueryUtil.AUCTION_TAG)) {\n-          newAuctionCounter.inc();\n-          newOldOutputCounter.inc();\n-          c.output(KV.of(newAuction, existingPerson));\n-        }\n-        return;\n-      }\n-\n-      Person theNewPerson = null;\n-      for (Person newPerson : c.element().getValue().getAll(NexmarkQueryUtil.PERSON_TAG)) {\n-        if (theNewPerson == null) {\n-          theNewPerson = newPerson;\n+      if (c.element().getValue().newPerson != null) {\n+        Person person = c.element().getValue().newPerson;\n+        if (existingPerson == null) {\n+          newPersonCounter.inc();\n+          personState.write(person);\n         } else {\n-          if (theNewPerson.equals(newPerson)) {\n-            LOG.error(\"Duplicate person {}\", theNewPerson);\n+          if (person.equals(existingPerson)) {\n+            LOG.error(\"Duplicate person {}\", person);\n           } else {\n-            LOG.error(\"Conflicting persons {} and {}\", theNewPerson, newPerson);\n+            LOG.error(\"Conflicting persons {} and {}\", existingPerson, person);\n           }\n           fatalCounter.inc();\n-          continue;\n         }\n-        newPersonCounter.inc();\n         // We've now seen the person for this person id so can flush any\n         // pending auctions for the same seller id (an auction is done by only one seller).", "originalCommit": "3d980846c1da07171fb1615432f7424cef521038", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAxNTUyMQ==", "url": "https://github.com/apache/beam/pull/13318#discussion_r526015521", "bodyText": "done", "author": "scwhittle", "createdAt": "2020-11-18T11:30:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3MTMzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3Mjk0OQ==", "url": "https://github.com/apache/beam/pull/13318#discussion_r525372949", "bodyText": "Why are you making the expiration timer a processing-time timer? Isn't event time more correct here?", "author": "reuvenlax", "createdAt": "2020-11-17T18:01:08Z", "path": "sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query3.java", "diffHunk": "@@ -164,21 +165,19 @@ public void processElement(ProcessContext c) {\n     @StateId(PERSON)\n     private static final StateSpec<ValueState<Person>> personSpec = StateSpecs.value(Person.CODER);\n \n-    private static final String PERSON_STATE_EXPIRING = \"personStateExpiring\";\n+    private static final String STATE_EXPIRING = \"stateExpiring\";\n \n     @StateId(AUCTIONS)\n-    private final StateSpec<ValueState<List<Auction>>> auctionsSpec =\n-        StateSpecs.value(ListCoder.of(Auction.CODER));\n+    private final StateSpec<BagState<Auction>> auctionsSpec = StateSpecs.bag(Auction.CODER);\n \n-    @TimerId(PERSON_STATE_EXPIRING)\n-    private final TimerSpec timerSpec = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n+    @TimerId(STATE_EXPIRING)", "originalCommit": "3d980846c1da07171fb1615432f7424cef521038", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAxOTA5MA==", "url": "https://github.com/apache/beam/pull/13318#discussion_r526019090", "bodyText": "Processing time is more equivalent to flink background GC, which is why I changed.  The previous code was never gc'ing auctions without persons, which seemed incorrect.  If we want to use an event time timer, it seems that we would need to keep some additional state to keep track of the highest event time of buffered auctions or people, otherwise we could reset timer inappropriately for late events. What do you think?", "author": "scwhittle", "createdAt": "2020-11-18T11:36:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3Mjk0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDExNTgwMA==", "url": "https://github.com/apache/beam/pull/13318#discussion_r534115800", "bodyText": "Changed back to event time timer.", "author": "scwhittle", "createdAt": "2020-12-02T12:04:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3Mjk0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM4MzgzNg==", "url": "https://github.com/apache/beam/pull/13318#discussion_r525383836", "bodyText": "AvroCoder tends to be very inefficient. Either write a custom coder or use SchemaCoder. To use SchemaCoder return the following from getAccumulatorCoder (unfortunately it appears that combiners have not been integrated yet with the SchemaRegistry, as otherwise it would be much simpler - just annotating with @DefaultSchema)\nJavaFieldSchema provider = new JavaFieldSchema();\nTypeDescriptor typeDescriptor = new TypeDescriptor{}();\nreturn SchemaCoder.of(provider.schemaFor(typeDescriptor), provider.toRowFunction(typeDescriptor), provider.fromRowFunction(typeDescriptor));", "author": "reuvenlax", "createdAt": "2020-11-17T18:17:54Z", "path": "sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query5.java", "diffHunk": "@@ -53,6 +56,48 @@\n public class Query5 extends NexmarkQueryTransform<AuctionCount> {\n   private final NexmarkConfiguration configuration;\n \n+  public static class TopCombineFn\n+      extends AccumulatingCombineFn<KV<Long, Long>, Accum, KV<Long, List<Long>>> {\n+    @Override\n+    public Accum createAccumulator() {\n+      return new Accum();\n+    }\n+\n+    @DefaultCoder(AvroCoder.class)", "originalCommit": "3d980846c1da07171fb1615432f7424cef521038", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjA3MDI4OQ==", "url": "https://github.com/apache/beam/pull/13318#discussion_r526070289", "bodyText": "done with tweaks", "author": "scwhittle", "createdAt": "2020-11-18T13:05:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM4MzgzNg=="}], "type": "inlineReview"}, {"oid": "69f9b9e24bf981bb1d1db3b5a0847220ebd55194", "url": "https://github.com/apache/beam/commit/69f9b9e24bf981bb1d1db3b5a0847220ebd55194", "message": "[BEAM-11300] Improve Nexmark performance:\n\nChange Query3 to use stateful processing and timers without\nCoGroupByKey which introduces additional windowing and shuffling.\n\nChange Query5 to avoid unnecessary lists when combining.\n\nChange Query10 to avoid excessive logging.", "committedDate": "2020-11-18T13:09:31Z", "type": "forcePushed"}, {"oid": "f9760400106ec5d06306d2f85b601f54b5545481", "url": "https://github.com/apache/beam/commit/f9760400106ec5d06306d2f85b601f54b5545481", "message": "[BEAM-11300] Improve Nexmark performance:\n\nChange Query3 to use stateful processing and timers without\nCoGroupByKey which introduces additional windowing and shuffling.\n\nChange Query5 to avoid unnecessary lists when combining.\n\nChange Query10 to avoid excessive logging.", "committedDate": "2020-11-19T11:59:01Z", "type": "forcePushed"}, {"oid": "77d9d45ab2243c47059408e0252d5f9e8cb389c9", "url": "https://github.com/apache/beam/commit/77d9d45ab2243c47059408e0252d5f9e8cb389c9", "message": "[BEAM-11300] Improve Nexmark performance:\n\nChange Query3 to use stateful processing and timers without\nCoGroupByKey which introduces additional windowing and shuffling.\n\nChange Query5 to avoid unnecessary lists when combining.\n\nChange Query10 to avoid excessive logging.", "committedDate": "2020-12-02T11:29:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQzMjA1Mg==", "url": "https://github.com/apache/beam/pull/13318#discussion_r534432052", "bodyText": "why do you call schemaFor twice?", "author": "reuvenlax", "createdAt": "2020-12-02T19:38:29Z", "path": "sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/Query5.java", "diffHunk": "@@ -53,6 +63,79 @@\n public class Query5 extends NexmarkQueryTransform<AuctionCount> {\n   private final NexmarkConfiguration configuration;\n \n+  public static class TopCombineFn\n+      extends AccumulatingCombineFn<KV<Long, Long>, Accum, KV<Long, List<Long>>> {\n+    @Override\n+    public Accum createAccumulator() {\n+      return new Accum();\n+    }\n+\n+    @Override\n+    public Coder<Accum> getAccumulatorCoder(\n+        @NonNull CoderRegistry registry, @NonNull Coder<KV<Long, Long>> inputCoder) {\n+      JavaFieldSchema provider = new JavaFieldSchema();\n+      TypeDescriptor<Accum> typeDescriptor = new TypeDescriptor<Accum>() {};\n+      provider.schemaFor(typeDescriptor);", "originalCommit": "77d9d45ab2243c47059408e0252d5f9e8cb389c9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7d88858e9fbce14befcc8f92dcbc932a6fe69b27", "url": "https://github.com/apache/beam/commit/7d88858e9fbce14befcc8f92dcbc932a6fe69b27", "message": "[BEAM-11300] Improve Nexmark performance:\n\nChange Query3 to use stateful processing and timers without\nCoGroupByKey which introduces additional windowing and shuffling.\n\nChange Query5 to avoid unnecessary lists when combining.\n\nChange Query10 to avoid excessive logging.", "committedDate": "2020-12-03T12:10:20Z", "type": "commit"}, {"oid": "7d88858e9fbce14befcc8f92dcbc932a6fe69b27", "url": "https://github.com/apache/beam/commit/7d88858e9fbce14befcc8f92dcbc932a6fe69b27", "message": "[BEAM-11300] Improve Nexmark performance:\n\nChange Query3 to use stateful processing and timers without\nCoGroupByKey which introduces additional windowing and shuffling.\n\nChange Query5 to avoid unnecessary lists when combining.\n\nChange Query10 to avoid excessive logging.", "committedDate": "2020-12-03T12:10:20Z", "type": "forcePushed"}]}