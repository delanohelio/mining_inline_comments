{"pr_number": 11074, "pr_title": "Store logical type values in Row instead of base values", "pr_createdAt": "2020-03-09T04:30:35Z", "pr_url": "https://github.com/apache/beam/pull/11074", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0MTk4OQ==", "url": "https://github.com/apache/beam/pull/11074#discussion_r389641989", "bodyText": "There is similar code in cb3dce0#diff-7ed3da1c0f656d0645423b9dab4da881R31\nThere are a few differences that might make sense to incorporate:\n\ndon't use rawtypes for better typesafety\noverride structuralValue\nexplicitly override constentWithEquals\nI wish we could do something better for contentWithEquals, but out of my head it would be unexpected to add any of this information to LogicalType\nhaving registerByteSizeObserver, isRegisterByteSizeObserverCheap might make sense\ngetCoderArguments could return baseCoder", "author": "kanterov", "createdAt": "2020-03-09T12:56:05Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/SchemaCoderHelpers.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.schemas;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.BigDecimalCoder;\n+import org.apache.beam.sdk.coders.BigEndianShortCoder;\n+import org.apache.beam.sdk.coders.BooleanCoder;\n+import org.apache.beam.sdk.coders.ByteArrayCoder;\n+import org.apache.beam.sdk.coders.ByteCoder;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.coders.CoderException;\n+import org.apache.beam.sdk.coders.DoubleCoder;\n+import org.apache.beam.sdk.coders.FloatCoder;\n+import org.apache.beam.sdk.coders.InstantCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.ListCoder;\n+import org.apache.beam.sdk.coders.MapCoder;\n+import org.apache.beam.sdk.coders.NullableCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.coders.VarIntCoder;\n+import org.apache.beam.sdk.coders.VarLongCoder;\n+import org.apache.beam.sdk.schemas.Schema.FieldType;\n+import org.apache.beam.sdk.schemas.Schema.LogicalType;\n+import org.apache.beam.sdk.schemas.Schema.TypeName;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+\n+public class SchemaCoderHelpers {\n+  // This contains a map of primitive types to their coders.\n+  public static final Map<TypeName, Coder> CODER_MAP =\n+      ImmutableMap.<TypeName, Coder>builder()\n+          .put(TypeName.BYTE, ByteCoder.of())\n+          .put(TypeName.BYTES, ByteArrayCoder.of())\n+          .put(TypeName.INT16, BigEndianShortCoder.of())\n+          .put(TypeName.INT32, VarIntCoder.of())\n+          .put(TypeName.INT64, VarLongCoder.of())\n+          .put(TypeName.DECIMAL, BigDecimalCoder.of())\n+          .put(TypeName.FLOAT, FloatCoder.of())\n+          .put(TypeName.DOUBLE, DoubleCoder.of())\n+          .put(TypeName.STRING, StringUtf8Coder.of())\n+          .put(TypeName.DATETIME, InstantCoder.of())\n+          .put(TypeName.BOOLEAN, BooleanCoder.of())\n+          .build();\n+\n+  private static class LogicalTypeCoder extends Coder {", "originalCommit": "d93eeda5771fca0b6a8d0c8f072cadbd8bc6ee42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI1MzU3OA==", "url": "https://github.com/apache/beam/pull/11074#discussion_r391253578", "bodyText": "Made these changes.\nWe should probably update SchemaCoder as well to do this properly, but that can be in a different PR IMO.", "author": "reuvenlax", "createdAt": "2020-03-11T20:36:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0MTk4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0Mjg0Mw==", "url": "https://github.com/apache/beam/pull/11074#discussion_r389642843", "bodyText": "What about replacing default with an explicit switch? There is error-prone rule that checks that switch cases are exhaustive, and it would help if we would add new TypeName. If not, it might make sense to throw a more elaborate exception if coder is null.", "author": "kanterov", "createdAt": "2020-03-09T12:57:45Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/SchemaCoderHelpers.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.schemas;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.BigDecimalCoder;\n+import org.apache.beam.sdk.coders.BigEndianShortCoder;\n+import org.apache.beam.sdk.coders.BooleanCoder;\n+import org.apache.beam.sdk.coders.ByteArrayCoder;\n+import org.apache.beam.sdk.coders.ByteCoder;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.coders.CoderException;\n+import org.apache.beam.sdk.coders.DoubleCoder;\n+import org.apache.beam.sdk.coders.FloatCoder;\n+import org.apache.beam.sdk.coders.InstantCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.ListCoder;\n+import org.apache.beam.sdk.coders.MapCoder;\n+import org.apache.beam.sdk.coders.NullableCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.coders.VarIntCoder;\n+import org.apache.beam.sdk.coders.VarLongCoder;\n+import org.apache.beam.sdk.schemas.Schema.FieldType;\n+import org.apache.beam.sdk.schemas.Schema.LogicalType;\n+import org.apache.beam.sdk.schemas.Schema.TypeName;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+\n+public class SchemaCoderHelpers {\n+  // This contains a map of primitive types to their coders.\n+  public static final Map<TypeName, Coder> CODER_MAP =\n+      ImmutableMap.<TypeName, Coder>builder()\n+          .put(TypeName.BYTE, ByteCoder.of())\n+          .put(TypeName.BYTES, ByteArrayCoder.of())\n+          .put(TypeName.INT16, BigEndianShortCoder.of())\n+          .put(TypeName.INT32, VarIntCoder.of())\n+          .put(TypeName.INT64, VarLongCoder.of())\n+          .put(TypeName.DECIMAL, BigDecimalCoder.of())\n+          .put(TypeName.FLOAT, FloatCoder.of())\n+          .put(TypeName.DOUBLE, DoubleCoder.of())\n+          .put(TypeName.STRING, StringUtf8Coder.of())\n+          .put(TypeName.DATETIME, InstantCoder.of())\n+          .put(TypeName.BOOLEAN, BooleanCoder.of())\n+          .build();\n+\n+  private static class LogicalTypeCoder extends Coder {\n+    private final LogicalType logicalType;\n+    private final Coder baseTypeCoder;\n+\n+    public LogicalTypeCoder(LogicalType logicalType, Coder baseTypeCoder) {\n+      this.logicalType = logicalType;\n+      this.baseTypeCoder = baseTypeCoder;\n+    }\n+\n+    @Override\n+    public void encode(Object value, OutputStream outStream) throws CoderException, IOException {\n+      Object baseType = logicalType.toBaseType(value);\n+      baseTypeCoder.encode(baseType, outStream);\n+    }\n+\n+    @Override\n+    public Object decode(InputStream inStream) throws CoderException, IOException {\n+      Object baseType = baseTypeCoder.decode(inStream);\n+      return logicalType.toInputType(baseType);\n+    }\n+\n+    @Override\n+    public List<? extends Coder<?>> getCoderArguments() {\n+      return Collections.emptyList();\n+    }\n+\n+    @Override\n+    public void verifyDeterministic() throws NonDeterministicException {\n+      baseTypeCoder.verifyDeterministic();\n+    }\n+  }\n+\n+  /** Returns the coder used for a given primitive type. */\n+  public static <T> Coder<T> coderForFieldType(FieldType fieldType) {\n+    Coder<T> coder;\n+    switch (fieldType.getTypeName()) {\n+      case ROW:\n+        coder = (Coder<T>) SchemaCoder.of(fieldType.getRowSchema());\n+        break;\n+      case ARRAY:\n+        coder = (Coder<T>) ListCoder.of(coderForFieldType(fieldType.getCollectionElementType()));\n+        break;\n+      case ITERABLE:\n+        coder =\n+            (Coder<T>) IterableCoder.of(coderForFieldType(fieldType.getCollectionElementType()));\n+        break;\n+      case MAP:\n+        coder =\n+            (Coder<T>)\n+                MapCoder.of(\n+                    coderForFieldType(fieldType.getMapKeyType()),\n+                    coderForFieldType(fieldType.getMapValueType()));\n+        break;\n+      case LOGICAL_TYPE:\n+        coder =\n+            new LogicalTypeCoder(\n+                fieldType.getLogicalType(),\n+                coderForFieldType(fieldType.getLogicalType().getBaseType()));\n+        break;\n+      default:\n+        coder = (Coder<T>) CODER_MAP.get(fieldType.getTypeName());", "originalCommit": "d93eeda5771fca0b6a8d0c8f072cadbd8bc6ee42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc2NDk5Mg==", "url": "https://github.com/apache/beam/pull/11074#discussion_r390764992", "bodyText": "Added  a null check.", "author": "reuvenlax", "createdAt": "2020-03-11T06:20:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0Mjg0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0NDI0OQ==", "url": "https://github.com/apache/beam/pull/11074#discussion_r389644249", "bodyText": "This looks rather unexpected that Combiner accepts int as an argument instead of EnumerationType.Value", "author": "kanterov", "createdAt": "2020-03-09T13:00:39Z", "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/transforms/GroupTest.java", "diffHunk": "@@ -620,6 +531,88 @@ public void testGloballyWithSchemaAggregateFnNestedFields() {\n     pipeline.run();\n   }\n \n+  @DefaultSchema(AutoValueSchema.class)\n+  @AutoValue\n+  abstract static class BasicEnum {\n+    enum Test {\n+      ZERO,\n+      ONE,\n+      TWO\n+    };\n+\n+    abstract String getKey();\n+\n+    abstract Test getEnumeration();\n+\n+    static BasicEnum of(String key, Test value) {\n+      return new AutoValue_GroupTest_BasicEnum(key, value);\n+    }\n+  }\n+\n+  static final EnumerationType BASIC_ENUM_ENUMERATION =\n+      EnumerationType.create(\"ZERO\", \"ONE\", \"TWO\");\n+  static final Schema BASIC_ENUM_SCHEMA =\n+      Schema.builder()\n+          .addStringField(\"key\")\n+          .addLogicalTypeField(\"enumeration\", BASIC_ENUM_ENUMERATION)\n+          .build();\n+\n+  @Test\n+  @Category(NeedsRunner.class)\n+  public void testAggregateBaseValuesGlobally() {\n+    Collection<BasicEnum> elements =\n+        Lists.newArrayList(\n+            BasicEnum.of(\"a\", BasicEnum.Test.ONE), BasicEnum.of(\"a\", BasicEnum.Test.TWO));\n+\n+    PCollection<Row> aggregate =\n+        pipeline\n+            .apply(Create.of(elements))\n+            .apply(\n+                Group.<BasicEnum>globally()\n+                    .aggregateFieldBaseValue(\"enumeration\", Sum.ofIntegers(), \"enum_sum\"));", "originalCommit": "d93eeda5771fca0b6a8d0c8f072cadbd8bc6ee42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc2NTE2Mg==", "url": "https://github.com/apache/beam/pull/11074#discussion_r390765162", "bodyText": "it's because aggregateFieldBaseValue is called instead of aggregateField. Would a different name make it more clear?", "author": "reuvenlax", "createdAt": "2020-03-11T06:21:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0NDI0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA5Mzg0Mw==", "url": "https://github.com/apache/beam/pull/11074#discussion_r391093843", "bodyText": "I see I didn't get it in the beginning, but now it all makes sense.", "author": "kanterov", "createdAt": "2020-03-11T16:18:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0NDI0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0NTAwNQ==", "url": "https://github.com/apache/beam/pull/11074#discussion_r389645005", "bodyText": "Does it only work because of type erasure, or is it actually aggregating EnumerationType.Value (not Integer)?", "author": "kanterov", "createdAt": "2020-03-09T13:02:13Z", "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/transforms/GroupTest.java", "diffHunk": "@@ -620,6 +531,88 @@ public void testGloballyWithSchemaAggregateFnNestedFields() {\n     pipeline.run();\n   }\n \n+  @DefaultSchema(AutoValueSchema.class)\n+  @AutoValue\n+  abstract static class BasicEnum {\n+    enum Test {\n+      ZERO,\n+      ONE,\n+      TWO\n+    };\n+\n+    abstract String getKey();\n+\n+    abstract Test getEnumeration();\n+\n+    static BasicEnum of(String key, Test value) {\n+      return new AutoValue_GroupTest_BasicEnum(key, value);\n+    }\n+  }\n+\n+  static final EnumerationType BASIC_ENUM_ENUMERATION =\n+      EnumerationType.create(\"ZERO\", \"ONE\", \"TWO\");\n+  static final Schema BASIC_ENUM_SCHEMA =\n+      Schema.builder()\n+          .addStringField(\"key\")\n+          .addLogicalTypeField(\"enumeration\", BASIC_ENUM_ENUMERATION)\n+          .build();\n+\n+  @Test\n+  @Category(NeedsRunner.class)\n+  public void testAggregateBaseValuesGlobally() {\n+    Collection<BasicEnum> elements =\n+        Lists.newArrayList(\n+            BasicEnum.of(\"a\", BasicEnum.Test.ONE), BasicEnum.of(\"a\", BasicEnum.Test.TWO));\n+\n+    PCollection<Row> aggregate =\n+        pipeline\n+            .apply(Create.of(elements))\n+            .apply(\n+                Group.<BasicEnum>globally()\n+                    .aggregateFieldBaseValue(\"enumeration\", Sum.ofIntegers(), \"enum_sum\"));\n+    Schema aggregateSchema = Schema.builder().addInt32Field(\"enum_sum\").build();\n+    Row expectedRow = Row.withSchema(aggregateSchema).addValues(3).build();\n+    PAssert.that(aggregate).containsInAnyOrder(expectedRow);\n+\n+    pipeline.run();\n+  }\n+\n+  @Test\n+  @Category(NeedsRunner.class)\n+  public void testAggregateLogicalValuesGlobally() {\n+    Collection<BasicEnum> elements =\n+        Lists.newArrayList(\n+            BasicEnum.of(\"a\", BasicEnum.Test.ONE), BasicEnum.of(\"a\", BasicEnum.Test.TWO));\n+\n+    SampleAnyCombineFn<EnumerationType.Value> sampleAnyCombineFn = new SampleAnyCombineFn<>(100);", "originalCommit": "d93eeda5771fca0b6a8d0c8f072cadbd8bc6ee42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc2NTM3OA==", "url": "https://github.com/apache/beam/pull/11074#discussion_r390765378", "bodyText": "No, it's actually aggregation EnumerationType.Value", "author": "reuvenlax", "createdAt": "2020-03-11T06:22:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0NTAwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA5NDkwMQ==", "url": "https://github.com/apache/beam/pull/11074#discussion_r391094901", "bodyText": "I see, there are two methods: aggregateFieldBaseValue and aggregateField", "author": "kanterov", "createdAt": "2020-03-11T16:20:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0NTAwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0NTc5Mg==", "url": "https://github.com/apache/beam/pull/11074#discussion_r389645792", "bodyText": "nit: we probably don't want System.err.println in tests", "author": "kanterov", "createdAt": "2020-03-09T13:03:52Z", "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/JavaFieldSchemaTest.java", "diffHunk": "@@ -592,41 +593,66 @@ public void testEnumFieldToRow() throws NoSuchSchemaException {\n     SchemaRegistry registry = SchemaRegistry.createDefault();\n     Schema schema = registry.getSchema(PojoWithEnum.class);\n     SchemaTestUtils.assertSchemaEquivalent(POJO_WITH_ENUM_SCHEMA, schema);\n-    EnumerationType enumerationType =\n-        POJO_WITH_ENUM_SCHEMA.getField(0).getType().getLogicalType(EnumerationType.class);\n+    EnumerationType enumerationType = ENUMERATION;\n \n+    List<EnumerationType.Value> allColors =\n+        Lists.newArrayList(\n+            enumerationType.valueOf(\"RED\"),\n+            enumerationType.valueOf(\"GREEN\"),\n+            enumerationType.valueOf(\"BLUE\"));\n     Row redRow =\n-        Row.withSchema(POJO_WITH_ENUM_SCHEMA).addValue(enumerationType.valueOf(\"RED\")).build();\n+        Row.withSchema(POJO_WITH_ENUM_SCHEMA)\n+            .addValues(enumerationType.valueOf(\"RED\"), allColors)\n+            .build();\n     Row greenRow =\n-        Row.withSchema(POJO_WITH_ENUM_SCHEMA).addValue(enumerationType.valueOf(\"GREEN\")).build();\n+        Row.withSchema(POJO_WITH_ENUM_SCHEMA)\n+            .addValues(enumerationType.valueOf(\"GREEN\"), allColors)\n+            .build();\n     Row blueRow =\n-        Row.withSchema(POJO_WITH_ENUM_SCHEMA).addValue(enumerationType.valueOf(\"BLUE\")).build();\n+        Row.withSchema(POJO_WITH_ENUM_SCHEMA)\n+            .addValues(enumerationType.valueOf(\"BLUE\"), allColors)\n+            .build();\n+\n+    List<Color> allColorsJava = Lists.newArrayList(Color.RED, Color.GREEN, Color.BLUE);\n \n     SerializableFunction<PojoWithEnum, Row> toRow = registry.getToRowFunction(PojoWithEnum.class);\n-    assertEquals(redRow, toRow.apply(new PojoWithEnum(Color.RED)));\n-    assertEquals(greenRow, toRow.apply(new PojoWithEnum(Color.GREEN)));\n-    assertEquals(blueRow, toRow.apply(new PojoWithEnum(Color.BLUE)));\n+    System.err.println(\"CONVERTED \" + toRow.apply(new PojoWithEnum(Color.RED, allColorsJava)));", "originalCommit": "d93eeda5771fca0b6a8d0c8f072cadbd8bc6ee42", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0NzE0OA==", "url": "https://github.com/apache/beam/pull/11074#discussion_r389647148", "bodyText": "nit: is it necessary to enforce? if yes, probably error message can be improved", "author": "kanterov", "createdAt": "2020-03-09T13:06:43Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/values/Row.java", "diffHunk": "@@ -362,7 +371,24 @@ public Boolean getBoolean(int idx) {\n   @Nullable\n   public <T> T getLogicalTypeValue(int idx, Class<T> clazz) {\n     LogicalType logicalType = checkNotNull(getSchema().getField(idx).getType().getLogicalType());\n-    return (T) logicalType.toInputType(getValue(idx));\n+    return (T) getValue(idx);\n+  }\n+\n+  /**\n+   * Returns the Logical Type base type for this field. If there are multiple nested logical types,\n+   * they are all resolved to the first non-logical type. {@link IllegalStateException} is thrown if\n+   * schema doesn't match.\n+   */\n+  @Nullable\n+  public <T> T getLogicalTypeBaseValue(int idx, Class<T> clazz) {\n+    Object value = getValue(idx);\n+    FieldType fieldType = getSchema().getField(idx).getType();\n+    checkArgument(fieldType.getTypeName().isLogicalType());", "originalCommit": "d93eeda5771fca0b6a8d0c8f072cadbd8bc6ee42", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0NzU3NA==", "url": "https://github.com/apache/beam/pull/11074#discussion_r389647574", "bodyText": "Should toBaseType handle null values for nullable fields or not? Can we assume that toBaseType(null) == null?", "author": "kanterov", "createdAt": "2020-03-09T13:07:40Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/values/Row.java", "diffHunk": "@@ -362,7 +371,24 @@ public Boolean getBoolean(int idx) {\n   @Nullable\n   public <T> T getLogicalTypeValue(int idx, Class<T> clazz) {\n     LogicalType logicalType = checkNotNull(getSchema().getField(idx).getType().getLogicalType());\n-    return (T) logicalType.toInputType(getValue(idx));\n+    return (T) getValue(idx);\n+  }\n+\n+  /**\n+   * Returns the Logical Type base type for this field. If there are multiple nested logical types,\n+   * they are all resolved to the first non-logical type. {@link IllegalStateException} is thrown if\n+   * schema doesn't match.\n+   */\n+  @Nullable\n+  public <T> T getLogicalTypeBaseValue(int idx, Class<T> clazz) {\n+    Object value = getValue(idx);\n+    FieldType fieldType = getSchema().getField(idx).getType();\n+    checkArgument(fieldType.getTypeName().isLogicalType());\n+    while (fieldType.getTypeName().isLogicalType()) {\n+      value = fieldType.getLogicalType().toBaseType(value);", "originalCommit": "d93eeda5771fca0b6a8d0c8f072cadbd8bc6ee42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc2NjA0NA==", "url": "https://github.com/apache/beam/pull/11074#discussion_r390766044", "bodyText": "good catch, we should.", "author": "reuvenlax", "createdAt": "2020-03-11T06:24:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0NzU3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0ODMyNw==", "url": "https://github.com/apache/beam/pull/11074#discussion_r389648327", "bodyText": "nit: doesn't look necessary, we can probably replicate this combiner in tests, instead of extending public API", "author": "kanterov", "createdAt": "2020-03-09T13:09:10Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/Sample.java", "diffHunk": "@@ -202,10 +202,10 @@ public void populateDisplayData(DisplayData.Builder builder) {\n   }\n \n   /** A {@link CombineFn} that combines into a {@link List} of up to limit elements. */\n-  private static class SampleAnyCombineFn<T> extends CombineFn<T, List<T>, Iterable<T>> {\n+  public static class SampleAnyCombineFn<T> extends CombineFn<T, List<T>, Iterable<T>> {", "originalCommit": "d93eeda5771fca0b6a8d0c8f072cadbd8bc6ee42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc2NjE0Mw==", "url": "https://github.com/apache/beam/pull/11074#discussion_r390766143", "bodyText": "Sample.anyCombineFn() exists, so I reverted this change", "author": "reuvenlax", "createdAt": "2020-03-11T06:25:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY0ODMyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY1MDE4Nw==", "url": "https://github.com/apache/beam/pull/11074#discussion_r389650187", "bodyText": "I find this was useful to have, and it was public. Instead, I would suggest SchemaCoderHelpers to be package-private, and this method to delegate to SchemaCoderHelpers.", "author": "kanterov", "createdAt": "2020-03-09T13:12:50Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/SchemaCoder.java", "diffHunk": "@@ -119,27 +86,6 @@ protected SchemaCoder(\n     return RowCoder.of(schema);\n   }\n \n-  /** Returns the coder used for a given primitive type. */\n-  public static <T> Coder<T> coderForFieldType(FieldType fieldType) {", "originalCommit": "d93eeda5771fca0b6a8d0c8f072cadbd8bc6ee42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc2NjE5NA==", "url": "https://github.com/apache/beam/pull/11074#discussion_r390766194", "bodyText": "done", "author": "reuvenlax", "createdAt": "2020-03-11T06:25:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY1MDE4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY1MjIwMg==", "url": "https://github.com/apache/beam/pull/11074#discussion_r389652202", "bodyText": "nit: not directly relevant to this PR, but I guess this field should be final, and name should follow convention", "author": "kanterov", "createdAt": "2020-03-09T13:16:40Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/coders/RowCoderGenerator.java", "diffHunk": "@@ -99,37 +97,14 @@\n @Experimental(Kind.SCHEMAS)\n public abstract class RowCoderGenerator {\n   private static final ByteBuddy BYTE_BUDDY = new ByteBuddy();\n-  private static final ForLoadedType CODER_TYPE = new ForLoadedType(Coder.class);\n-  private static final ForLoadedType LIST_CODER_TYPE = new ForLoadedType(ListCoder.class);\n-  private static final ForLoadedType ITERABLE_CODER_TYPE = new ForLoadedType(IterableCoder.class);\n-  private static final ForLoadedType MAP_CODER_TYPE = new ForLoadedType(MapCoder.class);\n   private static final BitSetCoder NULL_LIST_CODER = BitSetCoder.of();\n   private static final VarIntCoder VAR_INT_CODER = VarIntCoder.of();\n-  private static final ForLoadedType NULLABLE_CODER = new ForLoadedType(NullableCoder.class);\n \n   private static final String CODERS_FIELD_NAME = \"FIELD_CODERS\";\n \n-  // A map of primitive types -> StackManipulations to create their coders.\n-  private static final Map<TypeName, StackManipulation> CODER_MAP;\n-\n   // Cache for Coder class that are already generated.\n   private static Map<UUID, Coder<Row>> generatedCoders = Maps.newConcurrentMap();", "originalCommit": "d93eeda5771fca0b6a8d0c8f072cadbd8bc6ee42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc2NjIxMQ==", "url": "https://github.com/apache/beam/pull/11074#discussion_r390766211", "bodyText": "done", "author": "reuvenlax", "createdAt": "2020-03-11T06:25:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY1MjIwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY1MzQ1OA==", "url": "https://github.com/apache/beam/pull/11074#discussion_r389653458", "bodyText": "Probably I need to look into the code more. Why is OneOfType is a special case, while there is a generic branch for other logical types?", "author": "kanterov", "createdAt": "2020-03-09T13:19:03Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/FromRowUsingCreator.java", "diffHunk": "@@ -126,21 +127,25 @@ public T apply(Row row) {\n               valueType,\n               typeFactory);\n     } else {\n-      if (type.getTypeName().isLogicalType()\n-          && OneOfType.IDENTIFIER.equals(type.getLogicalType().getIdentifier())) {\n+      if (type.isLogicalType(OneOfType.IDENTIFIER)) {", "originalCommit": "d93eeda5771fca0b6a8d0c8f072cadbd8bc6ee42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc2NjQzMg==", "url": "https://github.com/apache/beam/pull/11074#discussion_r390766432", "bodyText": "because the actual conversion type changes depending on the oneOf case type. there might be a better way to handle this, but I'm not sure what it is yet.", "author": "reuvenlax", "createdAt": "2020-03-11T06:26:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY1MzQ1OA=="}], "type": "inlineReview"}, {"oid": "71ea5fc58a929dde6debf768f52bca89c472587e", "url": "https://github.com/apache/beam/commit/71ea5fc58a929dde6debf768f52bca89c472587e", "message": "store logical type values in Row instead of base values", "committedDate": "2020-03-19T22:45:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA3NDUyMQ==", "url": "https://github.com/apache/beam/pull/11074#discussion_r396074521", "bodyText": "Remove comment", "author": "alexvanboxel", "createdAt": "2020-03-22T09:54:51Z", "path": "sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/BeamComplexTypeTest.java", "diffHunk": "@@ -396,8 +396,8 @@ public void testLogicalTypes() {\n \n     PCollection<Row> outputRow =\n         pipeline\n-            .apply(Create.of(row))\n-            .setRowSchema(outputRowSchema)\n+            .apply(Create.of(row).withRowSchema(inputRowSchema))\n+            //  .setRowSchema(outputRowSchema)", "originalCommit": "71ea5fc58a929dde6debf768f52bca89c472587e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4d271736c5f88f3652fa7c80bd2c3e77c26fe27f", "url": "https://github.com/apache/beam/commit/4d271736c5f88f3652fa7c80bd2c3e77c26fe27f", "message": "fix spotbugs", "committedDate": "2020-03-23T05:42:36Z", "type": "forcePushed"}, {"oid": "f11a6b87aecb208656a9626253c7469d360b8df9", "url": "https://github.com/apache/beam/commit/f11a6b87aecb208656a9626253c7469d360b8df9", "message": "store logical type values in Row instead of base values", "committedDate": "2020-03-23T05:46:22Z", "type": "commit"}, {"oid": "6e77596a1d48a22ff8157faf76b90525bb05b445", "url": "https://github.com/apache/beam/commit/6e77596a1d48a22ff8157faf76b90525bb05b445", "message": "fix spotbugs", "committedDate": "2020-03-23T05:46:22Z", "type": "commit"}, {"oid": "6e77596a1d48a22ff8157faf76b90525bb05b445", "url": "https://github.com/apache/beam/commit/6e77596a1d48a22ff8157faf76b90525bb05b445", "message": "fix spotbugs", "committedDate": "2020-03-23T05:46:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQxMTk0Mw==", "url": "https://github.com/apache/beam/pull/11074#discussion_r396411943", "bodyText": "Why is this check needed?", "author": "kanterov", "createdAt": "2020-03-23T12:25:02Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/SchemaCoderHelpers.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.schemas;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.coders.BigDecimalCoder;\n+import org.apache.beam.sdk.coders.BigEndianShortCoder;\n+import org.apache.beam.sdk.coders.BooleanCoder;\n+import org.apache.beam.sdk.coders.ByteArrayCoder;\n+import org.apache.beam.sdk.coders.ByteCoder;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.coders.CoderException;\n+import org.apache.beam.sdk.coders.DoubleCoder;\n+import org.apache.beam.sdk.coders.FloatCoder;\n+import org.apache.beam.sdk.coders.InstantCoder;\n+import org.apache.beam.sdk.coders.IterableCoder;\n+import org.apache.beam.sdk.coders.ListCoder;\n+import org.apache.beam.sdk.coders.MapCoder;\n+import org.apache.beam.sdk.coders.NullableCoder;\n+import org.apache.beam.sdk.coders.StringUtf8Coder;\n+import org.apache.beam.sdk.coders.VarIntCoder;\n+import org.apache.beam.sdk.coders.VarLongCoder;\n+import org.apache.beam.sdk.schemas.Schema.FieldType;\n+import org.apache.beam.sdk.schemas.Schema.LogicalType;\n+import org.apache.beam.sdk.schemas.Schema.TypeName;\n+import org.apache.beam.sdk.util.common.ElementByteSizeObserver;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.joda.time.ReadableInstant;\n+\n+class SchemaCoderHelpers {\n+  // This contains a map of primitive types to their coders.\n+  private static final Map<TypeName, Coder> CODER_MAP =\n+      ImmutableMap.<TypeName, Coder>builder()\n+          .put(TypeName.BYTE, ByteCoder.of())\n+          .put(TypeName.BYTES, ByteArrayCoder.of())\n+          .put(TypeName.INT16, BigEndianShortCoder.of())\n+          .put(TypeName.INT32, VarIntCoder.of())\n+          .put(TypeName.INT64, VarLongCoder.of())\n+          .put(TypeName.DECIMAL, BigDecimalCoder.of())\n+          .put(TypeName.FLOAT, FloatCoder.of())\n+          .put(TypeName.DOUBLE, DoubleCoder.of())\n+          .put(TypeName.STRING, StringUtf8Coder.of())\n+          .put(TypeName.DATETIME, InstantCoder.of())\n+          .put(TypeName.BOOLEAN, BooleanCoder.of())\n+          .build();\n+\n+  private static class LogicalTypeCoder<InputT, BaseT> extends Coder<InputT> {\n+    private final LogicalType<InputT, BaseT> logicalType;\n+    private final Coder<BaseT> baseTypeCoder;\n+    private final boolean isDateTime;\n+\n+    LogicalTypeCoder(LogicalType<InputT, BaseT> logicalType, Coder baseTypeCoder) {\n+      this.logicalType = logicalType;\n+      this.baseTypeCoder = baseTypeCoder;\n+      this.isDateTime = logicalType.getBaseType().equals(FieldType.DATETIME);\n+    }\n+\n+    @Override\n+    public void encode(InputT value, OutputStream outStream) throws CoderException, IOException {\n+      BaseT baseType = logicalType.toBaseType(value);\n+      if (isDateTime) {\n+        baseType = (BaseT) ((ReadableInstant) baseType).toInstant();", "originalCommit": "6e77596a1d48a22ff8157faf76b90525bb05b445", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU4NjY2OQ==", "url": "https://github.com/apache/beam/pull/11074#discussion_r396586669", "bodyText": "It's to maintain the current invariant that any ReadableInstant can be passed in, while the current InstantCoder requires an Instant. This used to be enforced in the Row builder because we would call toBaseType there.\nWe need to redo DateTime types I think (really we have a timestamp type, not a datetime type), but until then I wanted to maintain the existing behavior.", "author": "reuvenlax", "createdAt": "2020-03-23T16:31:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQxMTk0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU4ODQzNg==", "url": "https://github.com/apache/beam/pull/11074#discussion_r396588436", "bodyText": "Thanks. Makes sense. Agree that DateTime types need to be redone.", "author": "kanterov", "createdAt": "2020-03-23T16:34:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQxMTk0Mw=="}], "type": "inlineReview"}]}