{"pr_number": 11305, "pr_title": "[BEAM-9577] Update container boot code to stage from dependencies, if present.", "pr_createdAt": "2020-04-03T17:36:40Z", "pr_url": "https://github.com/apache/beam/pull/11305", "timeline": [{"oid": "98112f63287b488b5058b54aaba1c00842d63b2d", "url": "https://github.com/apache/beam/commit/98112f63287b488b5058b54aaba1c00842d63b2d", "message": "[BEAM-9577] Update container boot code to stage from dependencies, if present.\n\nFalls back to legacy staging if no dependencies are present and the\nretrieval token is non-trivial.\n\nCurrently the dependencies must be of role staging_to. Future work\nto handle more expressive roles.", "committedDate": "2020-04-03T17:33:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI1MTMyNA==", "url": "https://github.com/apache/beam/pull/11305#discussion_r403251324", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tif err := fd.Close(); err != nil {\n          \n          \n            \n            \t\treturn err\n          \n          \n            \n            \t}\n          \n          \n            \n            \n          \n          \n            \n            \treturn nil\n          \n          \n            \n            \treturn fd.Close()", "author": "lostluck", "createdAt": "2020-04-03T19:04:06Z", "path": "sdks/go/pkg/beam/artifact/materialize.go", "diffHunk": "@@ -31,15 +31,148 @@ import (\n \n \t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n \tpb \"github.com/apache/beam/sdks/go/pkg/beam/model/jobmanagement_v1\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/util/errorx\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/util/grpcx\"\n+\t\"github.com/golang/protobuf/proto\"\n+)\n+\n+// TODO(lostluck): 2018/05/28 Extract these from their enum descriptors in the pipeline_v1 proto\n+const (\n+\tURNStagingTo      = \"beam:artifact:role:staging_to:v1\"\n+\tNoArtifactsStaged = \"__no_artifacts_staged__\"\n )\n \n // Materialize is a convenience helper for ensuring that all artifacts are\n // present and uncorrupted. It interprets each artifact name as a relative\n // path under the dest directory. It does not retrieve valid artifacts already\n // present.\n-func Materialize(ctx context.Context, endpoint string, rt string, dest string) ([]*pb.ArtifactMetadata, error) {\n+// TODO(BEAM-9577): Return a mapping of filename to dependency, rather than []*pb.ArtifactMetadata.\n+// TODO(BEAM-9577): Leverage richness of roles rather than magic names to understand artifacts.\n+func Materialize(ctx context.Context, endpoint string, dependencies []*pipeline_v1.ArtifactInformation, rt string, dest string) ([]*pb.ArtifactMetadata, error) {\n+\tif len(dependencies) > 0 {\n+\t\treturn newMaterialize(ctx, endpoint, dependencies, dest)\n+\t} else if rt == \"\" || rt == NoArtifactsStaged {\n+\t\treturn []*pb.ArtifactMetadata{}, nil\n+\t} else {\n+\t\treturn legacyMaterialize(ctx, endpoint, rt, dest)\n+\t}\n+}\n+\n+func newMaterialize(ctx context.Context, endpoint string, dependencies []*pipeline_v1.ArtifactInformation, dest string) ([]*pb.ArtifactMetadata, error) {\n+\tcc, err := grpcx.Dial(ctx, endpoint, 2*time.Minute)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer cc.Close()\n+\n+\treturn newMaterializeWithClient(ctx, pb.NewArtifactRetrievalServiceClient(cc), dependencies, dest)\n+}\n+\n+func newMaterializeWithClient(ctx context.Context, client pb.ArtifactRetrievalServiceClient, dependencies []*pipeline_v1.ArtifactInformation, dest string) ([]*pb.ArtifactMetadata, error) {\n+\tresolution, err := client.ResolveArtifact(ctx, &pb.ResolveArtifactRequest{Artifacts: dependencies})\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tvar md []*pb.ArtifactMetadata\n+\tvar list []retrievable\n+\tfor _, dep := range resolution.Replacements {\n+\t\tpath, err := extractStagingToPath(dep)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tmd = append(md, &pb.ArtifactMetadata{\n+\t\t\tName: path,\n+\t\t})\n+\n+\t\tlist = append(list, &artifact{\n+\t\t\tclient: client,\n+\t\t\tdep:    dep,\n+\t\t})\n+\t}\n+\n+\treturn md, MultiRetrieve(ctx, 10, list, dest)\n+}\n+\n+func extractStagingToPath(artifact *pipeline_v1.ArtifactInformation) (string, error) {\n+\tif artifact.RoleUrn != URNStagingTo {\n+\t\treturn \"\", errors.Errorf(\"Unsupported artifact role %s\", artifact.RoleUrn)\n+\t}\n+\trole := pipeline_v1.ArtifactStagingToRolePayload{}\n+\tif err := proto.Unmarshal(artifact.RolePayload, &role); err != nil {\n+\t\treturn \"\", err\n+\t}\n+\treturn role.StagedName, nil\n+}\n+\n+type artifact struct {\n+\tclient pb.ArtifactRetrievalServiceClient\n+\tdep    *pipeline_v1.ArtifactInformation\n+}\n+\n+func (a artifact) retrieve(ctx context.Context, dest string) error {\n+\tpath, err := extractStagingToPath(a.dep)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfilename := filepath.Join(dest, filepath.FromSlash(path))\n+\n+\t_, err = os.Stat(filename)\n+\tif err == nil {\n+\t\tif err = os.Remove(filename); err != nil {\n+\t\t\treturn errors.Errorf(\"failed to delete: %v (remove: %v)\", filename, err)\n+\t\t}\n+\t} else if !os.IsNotExist(err) {\n+\t\treturn errors.Wrapf(err, \"failed to stat %v\", filename)\n+\t}\n+\n+\tstream, err := a.client.GetArtifact(ctx, &pb.GetArtifactRequest{Artifact: a.dep})\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tfd, err := os.OpenFile(filename, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0755)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tw := bufio.NewWriter(fd)\n+\n+\terr = writeChunks(stream, w)\n+\tif err != nil {\n+\t\tfd.Close() // drop any buffered content\n+\t\treturn errors.Wrapf(err, \"failed to retrieve chunk for %v\", filename)\n+\t}\n+\tif err := w.Flush(); err != nil {\n+\t\tfd.Close()\n+\t\treturn errors.Wrapf(err, \"failed to flush chunks for %v\", filename)\n+\t}\n+\tif err := fd.Close(); err != nil {\n+\t\treturn err\n+\t}\n+\n+\treturn nil", "originalCommit": "98112f63287b488b5058b54aaba1c00842d63b2d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI2NTM4Nw==", "url": "https://github.com/apache/beam/pull/11305#discussion_r403265387", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t} else {\n          \n          \n            \n            \t\treturn nil, io.EOF\n          \n          \n            \n            \t}\n          \n          \n            \n            \t} \n          \n          \n            \n            \treturn nil, io.EOF", "author": "lostluck", "createdAt": "2020-04-03T19:30:52Z", "path": "sdks/go/pkg/beam/artifact/materialize_test.go", "diffHunk": "@@ -148,6 +153,156 @@ func stage(ctx context.Context, scl pb.LegacyArtifactStagingServiceClient, t *te\n \treturn md\n }\n \n+// Test for new artifact retrieval.\n+\n+func TestNewRetrieveWithManyFiles(t *testing.T) {\n+\texpected := map[string]string{\"a.txt\": \"a\", \"b.txt\": \"bbb\", \"c.txt\": \"cccccccc\"}\n+\n+\tclient := fakeRetrievalService{\n+\t\tartifacts: expected,\n+\t}\n+\n+\tdest := makeTempDir(t)\n+\tdefer os.RemoveAll(dest)\n+\tctx := grpcx.WriteWorkerID(context.Background(), \"worker\")\n+\n+\tmds, err := newMaterializeWithClient(ctx, client, client.resolvedArtifacts(), dest)\n+\tif err != nil {\n+\t\tt.Fatalf(\"materialize failed: %v\", err)\n+\t}\n+\n+\tcheckStagedFiles(mds, dest, expected, t)\n+}\n+\n+func TestNewRetrieveWithResolution(t *testing.T) {\n+\texpected := map[string]string{\"a.txt\": \"a\", \"b.txt\": \"bbb\", \"c.txt\": \"cccccccc\"}\n+\n+\tclient := fakeRetrievalService{\n+\t\tartifacts: expected,\n+\t}\n+\n+\tdest := makeTempDir(t)\n+\tdefer os.RemoveAll(dest)\n+\tctx := grpcx.WriteWorkerID(context.Background(), \"worker\")\n+\n+\tmds, err := newMaterializeWithClient(ctx, client, client.unresolvedArtifacts(), dest)\n+\tif err != nil {\n+\t\tt.Fatalf(\"materialize failed: %v\", err)\n+\t}\n+\n+\tcheckStagedFiles(mds, dest, expected, t)\n+}\n+\n+func checkStagedFiles(mds []*pb.ArtifactMetadata, dest string, expected map[string]string, t *testing.T) {\n+\tif len(mds) != len(expected) {\n+\t\tt.Errorf(\"wrong number of artifacts staged %v vs %v\", len(mds), len(expected))\n+\t}\n+\tfor _, md := range mds {\n+\t\tfilename := filepath.Join(dest, filepath.FromSlash(md.Name))\n+\t\tfd, err := os.Open(filename)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"error opening file %v\", err)\n+\t\t}\n+\t\tdefer fd.Close()\n+\n+\t\tdata := make([]byte, 1<<20)\n+\t\tn, err := fd.Read(data)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"error reading file %v\", err)\n+\t\t}\n+\n+\t\tif string(data[:n]) != expected[md.Name] {\n+\t\t\tt.Errorf(\"missmatched contents for %v: '%s' vs '%s'\", md.Name, string(data[:n]), expected[md.Name])\n+\t\t}\n+\t}\n+}\n+\n+type fakeRetrievalService struct {\n+\tartifacts map[string]string // name -> content\n+}\n+\n+func (fake fakeRetrievalService) resolvedArtifacts() []*pipeline_v1.ArtifactInformation {\n+\tvar artifacts []*pipeline_v1.ArtifactInformation\n+\tfor name, contents := range fake.artifacts {\n+\t\tpayload, _ := proto.Marshal(&pipeline_v1.ArtifactStagingToRolePayload{\n+\t\t\tStagedName: name})\n+\t\tartifacts = append(artifacts, &pipeline_v1.ArtifactInformation{\n+\t\t\tTypeUrn:     \"resolved\",\n+\t\t\tTypePayload: []byte(contents),\n+\t\t\tRoleUrn:     URNStagingTo,\n+\t\t\tRolePayload: payload,\n+\t\t})\n+\t}\n+\treturn artifacts\n+}\n+\n+func (fake fakeRetrievalService) unresolvedArtifacts() []*pipeline_v1.ArtifactInformation {\n+\treturn []*pipeline_v1.ArtifactInformation{\n+\t\t&pipeline_v1.ArtifactInformation{\n+\t\t\tTypeUrn: \"unresolved\",\n+\t\t},\n+\t}\n+}\n+\n+func (fake fakeRetrievalService) ResolveArtifact(ctx context.Context, request *pb.ResolveArtifactRequest, opts ...grpc.CallOption) (*pb.ResolveArtifactResponse, error) {\n+\tresponse := pb.ResolveArtifactResponse{}\n+\tfor _, dep := range request.Artifacts {\n+\t\tif dep.TypeUrn == \"unresolved\" {\n+\t\t\tresponse.Replacements = append(response.Replacements, fake.resolvedArtifacts()...)\n+\t\t} else {\n+\t\t\tresponse.Replacements = append(response.Replacements, dep)\n+\t\t}\n+\t}\n+\treturn &response, nil\n+}\n+\n+func (fake fakeRetrievalService) GetArtifact(ctx context.Context, request *pb.GetArtifactRequest, opts ...grpc.CallOption) (pb.ArtifactRetrievalService_GetArtifactClient, error) {\n+\tvar index int\n+\tif request.Artifact.TypeUrn == \"resolved\" {\n+\t\treturn fakeGetArtifactResponse{data: request.Artifact.TypePayload, index: &index}, nil\n+\t} else {\n+\t\treturn nil, errors.Errorf(\"Unsupported artifact %v\", request.Artifact)\n+\t}\n+}\n+\n+func (fake fakeGetArtifactResponse) Recv() (*pb.GetArtifactResponse, error) {\n+\tif *fake.index < len(fake.data) {\n+\t\t*fake.index += 1\n+\t\treturn &pb.GetArtifactResponse{Data: fake.data[*fake.index-1 : *fake.index]}, nil\n+\t} else {\n+\t\treturn nil, io.EOF\n+\t}", "originalCommit": "98112f63287b488b5058b54aaba1c00842d63b2d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI2NTUzMw==", "url": "https://github.com/apache/beam/pull/11305#discussion_r403265533", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t} else {\n          \n          \n            \n            \t\treturn nil, errors.Errorf(\"Unsupported artifact %v\", request.Artifact)\n          \n          \n            \n            \t}\n          \n          \n            \n            \t}\n          \n          \n            \n            \treturn nil, errors.Errorf(\"Unsupported artifact %v\", request.Artifact)", "author": "lostluck", "createdAt": "2020-04-03T19:31:08Z", "path": "sdks/go/pkg/beam/artifact/materialize_test.go", "diffHunk": "@@ -148,6 +153,156 @@ func stage(ctx context.Context, scl pb.LegacyArtifactStagingServiceClient, t *te\n \treturn md\n }\n \n+// Test for new artifact retrieval.\n+\n+func TestNewRetrieveWithManyFiles(t *testing.T) {\n+\texpected := map[string]string{\"a.txt\": \"a\", \"b.txt\": \"bbb\", \"c.txt\": \"cccccccc\"}\n+\n+\tclient := fakeRetrievalService{\n+\t\tartifacts: expected,\n+\t}\n+\n+\tdest := makeTempDir(t)\n+\tdefer os.RemoveAll(dest)\n+\tctx := grpcx.WriteWorkerID(context.Background(), \"worker\")\n+\n+\tmds, err := newMaterializeWithClient(ctx, client, client.resolvedArtifacts(), dest)\n+\tif err != nil {\n+\t\tt.Fatalf(\"materialize failed: %v\", err)\n+\t}\n+\n+\tcheckStagedFiles(mds, dest, expected, t)\n+}\n+\n+func TestNewRetrieveWithResolution(t *testing.T) {\n+\texpected := map[string]string{\"a.txt\": \"a\", \"b.txt\": \"bbb\", \"c.txt\": \"cccccccc\"}\n+\n+\tclient := fakeRetrievalService{\n+\t\tartifacts: expected,\n+\t}\n+\n+\tdest := makeTempDir(t)\n+\tdefer os.RemoveAll(dest)\n+\tctx := grpcx.WriteWorkerID(context.Background(), \"worker\")\n+\n+\tmds, err := newMaterializeWithClient(ctx, client, client.unresolvedArtifacts(), dest)\n+\tif err != nil {\n+\t\tt.Fatalf(\"materialize failed: %v\", err)\n+\t}\n+\n+\tcheckStagedFiles(mds, dest, expected, t)\n+}\n+\n+func checkStagedFiles(mds []*pb.ArtifactMetadata, dest string, expected map[string]string, t *testing.T) {\n+\tif len(mds) != len(expected) {\n+\t\tt.Errorf(\"wrong number of artifacts staged %v vs %v\", len(mds), len(expected))\n+\t}\n+\tfor _, md := range mds {\n+\t\tfilename := filepath.Join(dest, filepath.FromSlash(md.Name))\n+\t\tfd, err := os.Open(filename)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"error opening file %v\", err)\n+\t\t}\n+\t\tdefer fd.Close()\n+\n+\t\tdata := make([]byte, 1<<20)\n+\t\tn, err := fd.Read(data)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"error reading file %v\", err)\n+\t\t}\n+\n+\t\tif string(data[:n]) != expected[md.Name] {\n+\t\t\tt.Errorf(\"missmatched contents for %v: '%s' vs '%s'\", md.Name, string(data[:n]), expected[md.Name])\n+\t\t}\n+\t}\n+}\n+\n+type fakeRetrievalService struct {\n+\tartifacts map[string]string // name -> content\n+}\n+\n+func (fake fakeRetrievalService) resolvedArtifacts() []*pipeline_v1.ArtifactInformation {\n+\tvar artifacts []*pipeline_v1.ArtifactInformation\n+\tfor name, contents := range fake.artifacts {\n+\t\tpayload, _ := proto.Marshal(&pipeline_v1.ArtifactStagingToRolePayload{\n+\t\t\tStagedName: name})\n+\t\tartifacts = append(artifacts, &pipeline_v1.ArtifactInformation{\n+\t\t\tTypeUrn:     \"resolved\",\n+\t\t\tTypePayload: []byte(contents),\n+\t\t\tRoleUrn:     URNStagingTo,\n+\t\t\tRolePayload: payload,\n+\t\t})\n+\t}\n+\treturn artifacts\n+}\n+\n+func (fake fakeRetrievalService) unresolvedArtifacts() []*pipeline_v1.ArtifactInformation {\n+\treturn []*pipeline_v1.ArtifactInformation{\n+\t\t&pipeline_v1.ArtifactInformation{\n+\t\t\tTypeUrn: \"unresolved\",\n+\t\t},\n+\t}\n+}\n+\n+func (fake fakeRetrievalService) ResolveArtifact(ctx context.Context, request *pb.ResolveArtifactRequest, opts ...grpc.CallOption) (*pb.ResolveArtifactResponse, error) {\n+\tresponse := pb.ResolveArtifactResponse{}\n+\tfor _, dep := range request.Artifacts {\n+\t\tif dep.TypeUrn == \"unresolved\" {\n+\t\t\tresponse.Replacements = append(response.Replacements, fake.resolvedArtifacts()...)\n+\t\t} else {\n+\t\t\tresponse.Replacements = append(response.Replacements, dep)\n+\t\t}\n+\t}\n+\treturn &response, nil\n+}\n+\n+func (fake fakeRetrievalService) GetArtifact(ctx context.Context, request *pb.GetArtifactRequest, opts ...grpc.CallOption) (pb.ArtifactRetrievalService_GetArtifactClient, error) {\n+\tvar index int\n+\tif request.Artifact.TypeUrn == \"resolved\" {\n+\t\treturn fakeGetArtifactResponse{data: request.Artifact.TypePayload, index: &index}, nil\n+\t} else {\n+\t\treturn nil, errors.Errorf(\"Unsupported artifact %v\", request.Artifact)\n+\t}", "originalCommit": "98112f63287b488b5058b54aaba1c00842d63b2d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fb5178a4616eb6894ed465b3610bf2686e667385", "url": "https://github.com/apache/beam/commit/fb5178a4616eb6894ed465b3610bf2686e667385", "message": "Apply suggestions from code review\n\nCo-Authored-By: Robert Burke <lostluck@users.noreply.github.com>", "committedDate": "2020-04-03T19:36:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI2ODU0NQ==", "url": "https://github.com/apache/beam/pull/11305#discussion_r403268545", "bodyText": "I think It's a bit confusing that this is called a response when it's a fake Client which returns responses.", "author": "lostluck", "createdAt": "2020-04-03T19:35:07Z", "path": "sdks/go/pkg/beam/artifact/materialize_test.go", "diffHunk": "@@ -148,6 +153,156 @@ func stage(ctx context.Context, scl pb.LegacyArtifactStagingServiceClient, t *te\n \treturn md\n }\n \n+// Test for new artifact retrieval.\n+\n+func TestNewRetrieveWithManyFiles(t *testing.T) {\n+\texpected := map[string]string{\"a.txt\": \"a\", \"b.txt\": \"bbb\", \"c.txt\": \"cccccccc\"}\n+\n+\tclient := fakeRetrievalService{\n+\t\tartifacts: expected,\n+\t}\n+\n+\tdest := makeTempDir(t)\n+\tdefer os.RemoveAll(dest)\n+\tctx := grpcx.WriteWorkerID(context.Background(), \"worker\")\n+\n+\tmds, err := newMaterializeWithClient(ctx, client, client.resolvedArtifacts(), dest)\n+\tif err != nil {\n+\t\tt.Fatalf(\"materialize failed: %v\", err)\n+\t}\n+\n+\tcheckStagedFiles(mds, dest, expected, t)\n+}\n+\n+func TestNewRetrieveWithResolution(t *testing.T) {\n+\texpected := map[string]string{\"a.txt\": \"a\", \"b.txt\": \"bbb\", \"c.txt\": \"cccccccc\"}\n+\n+\tclient := fakeRetrievalService{\n+\t\tartifacts: expected,\n+\t}\n+\n+\tdest := makeTempDir(t)\n+\tdefer os.RemoveAll(dest)\n+\tctx := grpcx.WriteWorkerID(context.Background(), \"worker\")\n+\n+\tmds, err := newMaterializeWithClient(ctx, client, client.unresolvedArtifacts(), dest)\n+\tif err != nil {\n+\t\tt.Fatalf(\"materialize failed: %v\", err)\n+\t}\n+\n+\tcheckStagedFiles(mds, dest, expected, t)\n+}\n+\n+func checkStagedFiles(mds []*pb.ArtifactMetadata, dest string, expected map[string]string, t *testing.T) {\n+\tif len(mds) != len(expected) {\n+\t\tt.Errorf(\"wrong number of artifacts staged %v vs %v\", len(mds), len(expected))\n+\t}\n+\tfor _, md := range mds {\n+\t\tfilename := filepath.Join(dest, filepath.FromSlash(md.Name))\n+\t\tfd, err := os.Open(filename)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"error opening file %v\", err)\n+\t\t}\n+\t\tdefer fd.Close()\n+\n+\t\tdata := make([]byte, 1<<20)\n+\t\tn, err := fd.Read(data)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"error reading file %v\", err)\n+\t\t}\n+\n+\t\tif string(data[:n]) != expected[md.Name] {\n+\t\t\tt.Errorf(\"missmatched contents for %v: '%s' vs '%s'\", md.Name, string(data[:n]), expected[md.Name])\n+\t\t}\n+\t}\n+}\n+\n+type fakeRetrievalService struct {\n+\tartifacts map[string]string // name -> content\n+}\n+\n+func (fake fakeRetrievalService) resolvedArtifacts() []*pipeline_v1.ArtifactInformation {\n+\tvar artifacts []*pipeline_v1.ArtifactInformation\n+\tfor name, contents := range fake.artifacts {\n+\t\tpayload, _ := proto.Marshal(&pipeline_v1.ArtifactStagingToRolePayload{\n+\t\t\tStagedName: name})\n+\t\tartifacts = append(artifacts, &pipeline_v1.ArtifactInformation{\n+\t\t\tTypeUrn:     \"resolved\",\n+\t\t\tTypePayload: []byte(contents),\n+\t\t\tRoleUrn:     URNStagingTo,\n+\t\t\tRolePayload: payload,\n+\t\t})\n+\t}\n+\treturn artifacts\n+}\n+\n+func (fake fakeRetrievalService) unresolvedArtifacts() []*pipeline_v1.ArtifactInformation {\n+\treturn []*pipeline_v1.ArtifactInformation{\n+\t\t&pipeline_v1.ArtifactInformation{\n+\t\t\tTypeUrn: \"unresolved\",\n+\t\t},\n+\t}\n+}\n+\n+func (fake fakeRetrievalService) ResolveArtifact(ctx context.Context, request *pb.ResolveArtifactRequest, opts ...grpc.CallOption) (*pb.ResolveArtifactResponse, error) {\n+\tresponse := pb.ResolveArtifactResponse{}\n+\tfor _, dep := range request.Artifacts {\n+\t\tif dep.TypeUrn == \"unresolved\" {\n+\t\t\tresponse.Replacements = append(response.Replacements, fake.resolvedArtifacts()...)\n+\t\t} else {\n+\t\t\tresponse.Replacements = append(response.Replacements, dep)\n+\t\t}\n+\t}\n+\treturn &response, nil\n+}\n+\n+func (fake fakeRetrievalService) GetArtifact(ctx context.Context, request *pb.GetArtifactRequest, opts ...grpc.CallOption) (pb.ArtifactRetrievalService_GetArtifactClient, error) {\n+\tvar index int\n+\tif request.Artifact.TypeUrn == \"resolved\" {\n+\t\treturn fakeGetArtifactResponse{data: request.Artifact.TypePayload, index: &index}, nil\n+\t} else {\n+\t\treturn nil, errors.Errorf(\"Unsupported artifact %v\", request.Artifact)\n+\t}\n+}\n+\n+func (fake fakeGetArtifactResponse) Recv() (*pb.GetArtifactResponse, error) {", "originalCommit": "98112f63287b488b5058b54aaba1c00842d63b2d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI4NDMwNA==", "url": "https://github.com/apache/beam/pull/11305#discussion_r403284304", "bodyText": "It's the object that represents the response stream (and is returned by the actual client). Would naming it fakeGetArtifactResponseStream be better?", "author": "robertwb", "createdAt": "2020-04-03T19:55:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI2ODU0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI5MDg5Nw==", "url": "https://github.com/apache/beam/pull/11305#discussion_r403290897", "bodyText": "Yes.", "author": "lostluck", "createdAt": "2020-04-03T20:03:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI2ODU0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI3MDk0MQ==", "url": "https://github.com/apache/beam/pull/11305#discussion_r403270941", "bodyText": "Why a pointer to the index rather than make the methods on the pointer to the struct? The implementation seems to be trying to avoid the implicit value method copying, instead of just using pointer methods.\nSee https://golang.org/doc/effective_go.html#methods for more information.\ntldr; replacing all the (fake fakeGetArtifactResponse) with (fake *fakeGetArtifactResponse) puts the method on the pointer, which means that repeated calls have access to the full state, and you don't need the indirections to have index increment as expected.\nThis also applies to the other fakes or interfaces you've written, but given that you're only modifying reference state if at all (eg. maps, or pointers), then it doesn't matter so much that a value method is being used.\nThe general rule is that when in doubt, use a pointer receiver.", "author": "lostluck", "createdAt": "2020-04-03T19:38:12Z", "path": "sdks/go/pkg/beam/artifact/materialize_test.go", "diffHunk": "@@ -148,6 +153,156 @@ func stage(ctx context.Context, scl pb.LegacyArtifactStagingServiceClient, t *te\n \treturn md\n }\n \n+// Test for new artifact retrieval.\n+\n+func TestNewRetrieveWithManyFiles(t *testing.T) {\n+\texpected := map[string]string{\"a.txt\": \"a\", \"b.txt\": \"bbb\", \"c.txt\": \"cccccccc\"}\n+\n+\tclient := fakeRetrievalService{\n+\t\tartifacts: expected,\n+\t}\n+\n+\tdest := makeTempDir(t)\n+\tdefer os.RemoveAll(dest)\n+\tctx := grpcx.WriteWorkerID(context.Background(), \"worker\")\n+\n+\tmds, err := newMaterializeWithClient(ctx, client, client.resolvedArtifacts(), dest)\n+\tif err != nil {\n+\t\tt.Fatalf(\"materialize failed: %v\", err)\n+\t}\n+\n+\tcheckStagedFiles(mds, dest, expected, t)\n+}\n+\n+func TestNewRetrieveWithResolution(t *testing.T) {\n+\texpected := map[string]string{\"a.txt\": \"a\", \"b.txt\": \"bbb\", \"c.txt\": \"cccccccc\"}\n+\n+\tclient := fakeRetrievalService{\n+\t\tartifacts: expected,\n+\t}\n+\n+\tdest := makeTempDir(t)\n+\tdefer os.RemoveAll(dest)\n+\tctx := grpcx.WriteWorkerID(context.Background(), \"worker\")\n+\n+\tmds, err := newMaterializeWithClient(ctx, client, client.unresolvedArtifacts(), dest)\n+\tif err != nil {\n+\t\tt.Fatalf(\"materialize failed: %v\", err)\n+\t}\n+\n+\tcheckStagedFiles(mds, dest, expected, t)\n+}\n+\n+func checkStagedFiles(mds []*pb.ArtifactMetadata, dest string, expected map[string]string, t *testing.T) {\n+\tif len(mds) != len(expected) {\n+\t\tt.Errorf(\"wrong number of artifacts staged %v vs %v\", len(mds), len(expected))\n+\t}\n+\tfor _, md := range mds {\n+\t\tfilename := filepath.Join(dest, filepath.FromSlash(md.Name))\n+\t\tfd, err := os.Open(filename)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"error opening file %v\", err)\n+\t\t}\n+\t\tdefer fd.Close()\n+\n+\t\tdata := make([]byte, 1<<20)\n+\t\tn, err := fd.Read(data)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"error reading file %v\", err)\n+\t\t}\n+\n+\t\tif string(data[:n]) != expected[md.Name] {\n+\t\t\tt.Errorf(\"missmatched contents for %v: '%s' vs '%s'\", md.Name, string(data[:n]), expected[md.Name])\n+\t\t}\n+\t}\n+}\n+\n+type fakeRetrievalService struct {\n+\tartifacts map[string]string // name -> content\n+}\n+\n+func (fake fakeRetrievalService) resolvedArtifacts() []*pipeline_v1.ArtifactInformation {\n+\tvar artifacts []*pipeline_v1.ArtifactInformation\n+\tfor name, contents := range fake.artifacts {\n+\t\tpayload, _ := proto.Marshal(&pipeline_v1.ArtifactStagingToRolePayload{\n+\t\t\tStagedName: name})\n+\t\tartifacts = append(artifacts, &pipeline_v1.ArtifactInformation{\n+\t\t\tTypeUrn:     \"resolved\",\n+\t\t\tTypePayload: []byte(contents),\n+\t\t\tRoleUrn:     URNStagingTo,\n+\t\t\tRolePayload: payload,\n+\t\t})\n+\t}\n+\treturn artifacts\n+}\n+\n+func (fake fakeRetrievalService) unresolvedArtifacts() []*pipeline_v1.ArtifactInformation {\n+\treturn []*pipeline_v1.ArtifactInformation{\n+\t\t&pipeline_v1.ArtifactInformation{\n+\t\t\tTypeUrn: \"unresolved\",\n+\t\t},\n+\t}\n+}\n+\n+func (fake fakeRetrievalService) ResolveArtifact(ctx context.Context, request *pb.ResolveArtifactRequest, opts ...grpc.CallOption) (*pb.ResolveArtifactResponse, error) {\n+\tresponse := pb.ResolveArtifactResponse{}\n+\tfor _, dep := range request.Artifacts {\n+\t\tif dep.TypeUrn == \"unresolved\" {\n+\t\t\tresponse.Replacements = append(response.Replacements, fake.resolvedArtifacts()...)\n+\t\t} else {\n+\t\t\tresponse.Replacements = append(response.Replacements, dep)\n+\t\t}\n+\t}\n+\treturn &response, nil\n+}\n+\n+func (fake fakeRetrievalService) GetArtifact(ctx context.Context, request *pb.GetArtifactRequest, opts ...grpc.CallOption) (pb.ArtifactRetrievalService_GetArtifactClient, error) {\n+\tvar index int\n+\tif request.Artifact.TypeUrn == \"resolved\" {\n+\t\treturn fakeGetArtifactResponse{data: request.Artifact.TypePayload, index: &index}, nil\n+\t} else {\n+\t\treturn nil, errors.Errorf(\"Unsupported artifact %v\", request.Artifact)\n+\t}\n+}\n+\n+func (fake fakeGetArtifactResponse) Recv() (*pb.GetArtifactResponse, error) {\n+\tif *fake.index < len(fake.data) {\n+\t\t*fake.index += 1\n+\t\treturn &pb.GetArtifactResponse{Data: fake.data[*fake.index-1 : *fake.index]}, nil\n+\t} else {\n+\t\treturn nil, io.EOF\n+\t}\n+}\n+\n+type fakeGetArtifactResponse struct {\n+\tdata  []byte\n+\tindex *int", "originalCommit": "98112f63287b488b5058b54aaba1c00842d63b2d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI4MTY4Mw==", "url": "https://github.com/apache/beam/pull/11305#discussion_r403281683", "bodyText": "That is what I tried at first, but it complained that it didn't satisfy the interface.", "author": "robertwb", "createdAt": "2020-04-03T19:51:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI3MDk0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI5Mjc1Ng==", "url": "https://github.com/apache/beam/pull/11305#discussion_r403292756", "bodyText": "Answered at the definition of the instance.", "author": "lostluck", "createdAt": "2020-04-03T20:06:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI3MDk0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI5MjU2MQ==", "url": "https://github.com/apache/beam/pull/11305#discussion_r403292561", "bodyText": "You need to return the pointer instance here so that the pointer methods can satisfy the interface.\nValue methods are \"promoted\" to the derived pointer type, but not the other way around.\nFrom Effective Go:\nThe rule about pointers vs. values for receivers is that value methods can be invoked on pointers and values, but pointer methods can only be invoked on pointers.\nThis rule arises because pointer methods can modify the receiver; invoking them on a value would cause the method to receive a copy of the value, so any modifications would be discarded. The language therefore disallows this mistake. There is a handy exception, though. When the value is addressable, the language takes care of the common case of invoking a pointer method on a value by inserting the address operator automatically. In our example, the variable b is addressable, so we can call its Write method with just b.Write. The compiler will rewrite that to (&b).Write for us.", "author": "lostluck", "createdAt": "2020-04-03T20:06:01Z", "path": "sdks/go/pkg/beam/artifact/materialize_test.go", "diffHunk": "@@ -148,6 +153,154 @@ func stage(ctx context.Context, scl pb.LegacyArtifactStagingServiceClient, t *te\n \treturn md\n }\n \n+// Test for new artifact retrieval.\n+\n+func TestNewRetrieveWithManyFiles(t *testing.T) {\n+\texpected := map[string]string{\"a.txt\": \"a\", \"b.txt\": \"bbb\", \"c.txt\": \"cccccccc\"}\n+\n+\tclient := fakeRetrievalService{\n+\t\tartifacts: expected,\n+\t}\n+\n+\tdest := makeTempDir(t)\n+\tdefer os.RemoveAll(dest)\n+\tctx := grpcx.WriteWorkerID(context.Background(), \"worker\")\n+\n+\tmds, err := newMaterializeWithClient(ctx, client, client.resolvedArtifacts(), dest)\n+\tif err != nil {\n+\t\tt.Fatalf(\"materialize failed: %v\", err)\n+\t}\n+\n+\tcheckStagedFiles(mds, dest, expected, t)\n+}\n+\n+func TestNewRetrieveWithResolution(t *testing.T) {\n+\texpected := map[string]string{\"a.txt\": \"a\", \"b.txt\": \"bbb\", \"c.txt\": \"cccccccc\"}\n+\n+\tclient := fakeRetrievalService{\n+\t\tartifacts: expected,\n+\t}\n+\n+\tdest := makeTempDir(t)\n+\tdefer os.RemoveAll(dest)\n+\tctx := grpcx.WriteWorkerID(context.Background(), \"worker\")\n+\n+\tmds, err := newMaterializeWithClient(ctx, client, client.unresolvedArtifacts(), dest)\n+\tif err != nil {\n+\t\tt.Fatalf(\"materialize failed: %v\", err)\n+\t}\n+\n+\tcheckStagedFiles(mds, dest, expected, t)\n+}\n+\n+func checkStagedFiles(mds []*pb.ArtifactMetadata, dest string, expected map[string]string, t *testing.T) {\n+\tif len(mds) != len(expected) {\n+\t\tt.Errorf(\"wrong number of artifacts staged %v vs %v\", len(mds), len(expected))\n+\t}\n+\tfor _, md := range mds {\n+\t\tfilename := filepath.Join(dest, filepath.FromSlash(md.Name))\n+\t\tfd, err := os.Open(filename)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"error opening file %v\", err)\n+\t\t}\n+\t\tdefer fd.Close()\n+\n+\t\tdata := make([]byte, 1<<20)\n+\t\tn, err := fd.Read(data)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"error reading file %v\", err)\n+\t\t}\n+\n+\t\tif string(data[:n]) != expected[md.Name] {\n+\t\t\tt.Errorf(\"missmatched contents for %v: '%s' vs '%s'\", md.Name, string(data[:n]), expected[md.Name])\n+\t\t}\n+\t}\n+}\n+\n+type fakeRetrievalService struct {\n+\tartifacts map[string]string // name -> content\n+}\n+\n+func (fake fakeRetrievalService) resolvedArtifacts() []*pipeline_v1.ArtifactInformation {\n+\tvar artifacts []*pipeline_v1.ArtifactInformation\n+\tfor name, contents := range fake.artifacts {\n+\t\tpayload, _ := proto.Marshal(&pipeline_v1.ArtifactStagingToRolePayload{\n+\t\t\tStagedName: name})\n+\t\tartifacts = append(artifacts, &pipeline_v1.ArtifactInformation{\n+\t\t\tTypeUrn:     \"resolved\",\n+\t\t\tTypePayload: []byte(contents),\n+\t\t\tRoleUrn:     URNStagingTo,\n+\t\t\tRolePayload: payload,\n+\t\t})\n+\t}\n+\treturn artifacts\n+}\n+\n+func (fake fakeRetrievalService) unresolvedArtifacts() []*pipeline_v1.ArtifactInformation {\n+\treturn []*pipeline_v1.ArtifactInformation{\n+\t\t&pipeline_v1.ArtifactInformation{\n+\t\t\tTypeUrn: \"unresolved\",\n+\t\t},\n+\t}\n+}\n+\n+func (fake fakeRetrievalService) ResolveArtifact(ctx context.Context, request *pb.ResolveArtifactRequest, opts ...grpc.CallOption) (*pb.ResolveArtifactResponse, error) {\n+\tresponse := pb.ResolveArtifactResponse{}\n+\tfor _, dep := range request.Artifacts {\n+\t\tif dep.TypeUrn == \"unresolved\" {\n+\t\t\tresponse.Replacements = append(response.Replacements, fake.resolvedArtifacts()...)\n+\t\t} else {\n+\t\t\tresponse.Replacements = append(response.Replacements, dep)\n+\t\t}\n+\t}\n+\treturn &response, nil\n+}\n+\n+func (fake fakeRetrievalService) GetArtifact(ctx context.Context, request *pb.GetArtifactRequest, opts ...grpc.CallOption) (pb.ArtifactRetrievalService_GetArtifactClient, error) {\n+\tvar index int\n+\tif request.Artifact.TypeUrn == \"resolved\" {\n+\t\treturn fakeGetArtifactResponse{data: request.Artifact.TypePayload, index: &index}, nil", "originalCommit": "fb5178a4616eb6894ed465b3610bf2686e667385", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzMyMDE1MA==", "url": "https://github.com/apache/beam/pull/11305#discussion_r403320150", "bodyText": "Thanks for the helpful explication.", "author": "robertwb", "createdAt": "2020-04-03T20:42:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI5MjU2MQ=="}], "type": "inlineReview"}, {"oid": "73d07a8bcb532b38c5f422361e7fc1c6f24f8128", "url": "https://github.com/apache/beam/commit/73d07a8bcb532b38c5f422361e7fc1c6f24f8128", "message": "Use pointer recievers.", "committedDate": "2020-04-03T20:41:52Z", "type": "commit"}]}