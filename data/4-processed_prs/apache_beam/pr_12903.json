{"pr_number": 12903, "pr_title": "[BEAM-9616] Add RegisterDoFn", "pr_createdAt": "2020-09-22T16:38:43Z", "pr_url": "https://github.com/apache/beam/pull/12903", "timeline": [{"oid": "b874afc0d0fc2ae657fe42932859bf8e4277a2b2", "url": "https://github.com/apache/beam/commit/b874afc0d0fc2ae657fe42932859bf8e4277a2b2", "message": "[BEAM-9616] Add RegisterDoFn.", "committedDate": "2020-09-22T16:32:35Z", "type": "commit"}, {"oid": "642948589c3c30dba4d02fc0f72c7b5f5cfd0d91", "url": "https://github.com/apache/beam/commit/642948589c3c30dba4d02fc0f72c7b5f5cfd0d91", "message": "[BEAM-9616] Make starcgen understand RegisterDoFn", "committedDate": "2020-09-24T16:16:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY5NzUzNQ==", "url": "https://github.com/apache/beam/pull/12903#discussion_r494697535", "bodyText": "Could this just use the rt from near the top of the function? It's a bit confusing right now with it named the same as a different scoped variable in the same function.", "author": "youngoli", "createdAt": "2020-09-25T01:33:36Z", "path": "sdks/go/pkg/beam/core/runtime/genx/genx.go", "diffHunk": "@@ -0,0 +1,172 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package genx is a convenience package to better support the code\n+// generator. It can be depended on by the user facing beam package\n+// and be refered to by generated code.\n+//\n+// Similarly, it can depend on beam internals and access the canonical\n+// method list in the graph package, or other packages to filter out\n+// types that aren't necessary for registration (like context.Context).\n+package genx\n+\n+import (\n+\t\"reflect\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/funcx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime\"\n+)\n+\n+// RegisterDoFn is a convenience function for registering DoFns.\n+// Differs from RegisterFunction and RegisterType by introspecting\n+// all parameters and returns of Lifecycle methods on the dofn,\n+// and registers those types for you.\n+//\n+// Panics if not passed a dofn.\n+func RegisterDoFn(dofn interface{}) {\n+\tf, ts, err := registerDoFn(dofn)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\tif f != nil {\n+\t\truntime.RegisterFunction(f)\n+\t}\n+\tfor _, t := range ts {\n+\t\truntime.RegisterType(t)\n+\t}\n+}\n+\n+// registerDoFn returns all types associated with the provided DoFn.\n+// If passed a functional DoFn, the first return is a Function to\n+// register with runtime.RegisterFunction.\n+// The second return is all types to register with runtime.RegisterType.\n+// Returns an error if the passed in values are not DoFns.\n+func registerDoFn(dofn interface{}) (interface{}, []reflect.Type, error) {\n+\tif rt, ok := dofn.(reflect.Type); ok {\n+\t\tif rt.Kind() == reflect.Ptr {\n+\t\t\trt = rt.Elem()\n+\t\t}\n+\t\tdofn = reflect.New(rt).Interface()\n+\t}\n+\tfn, err := graph.NewFn(dofn)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\tc := cache{}\n+\tvar valid bool\n+\t// Validates that this is a DoFn or combineFn.\n+\tdo, err := graph.AsDoFn(fn, graph.MainUnknown)\n+\tif err == nil {\n+\t\tvalid = true\n+\t\thandleDoFn(do, c)\n+\t} else if cmb, err2 := graph.AsCombineFn(fn); err2 == nil {\n+\t\tvalid = true\n+\t\thandleCombineFn(cmb, c)\n+\t}\n+\tif !valid {\n+\t\t// Return the DoFn specific error as that's more common.\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tvar retFunc interface{}\n+\trt := reflect.TypeOf(dofn)", "originalCommit": "642948589c3c30dba4d02fc0f72c7b5f5cfd0d91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTEwNDU5OQ==", "url": "https://github.com/apache/beam/pull/12903#discussion_r495104599", "bodyText": "No, that rt is out of scope and it's only present if the user passed in a reflect.Type instance. It's scoped to the if statement. It's also nearly 30 lines up, which hampers readability a bit by having an extended distance between declaration and use. This is adjacent to the uses, and that if block at the start ensures that there's only one way to interpret the rt variable here. It's the type of the dofn.\nSemantically, this is identical to calling all error values err. I'm always calling arbitrary reflect.Type instances rt.", "author": "lostluck", "createdAt": "2020-09-25T16:35:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY5NzUzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY5ODYwNA==", "url": "https://github.com/apache/beam/pull/12903#discussion_r494698604", "bodyText": "What's the reason for creating a new interface from a reflect type for dofn here? Is it a way to reset the dofn to it's default values by creating a new instance?", "author": "youngoli", "createdAt": "2020-09-25T01:37:18Z", "path": "sdks/go/pkg/beam/core/runtime/genx/genx.go", "diffHunk": "@@ -0,0 +1,172 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package genx is a convenience package to better support the code\n+// generator. It can be depended on by the user facing beam package\n+// and be refered to by generated code.\n+//\n+// Similarly, it can depend on beam internals and access the canonical\n+// method list in the graph package, or other packages to filter out\n+// types that aren't necessary for registration (like context.Context).\n+package genx\n+\n+import (\n+\t\"reflect\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/funcx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime\"\n+)\n+\n+// RegisterDoFn is a convenience function for registering DoFns.\n+// Differs from RegisterFunction and RegisterType by introspecting\n+// all parameters and returns of Lifecycle methods on the dofn,\n+// and registers those types for you.\n+//\n+// Panics if not passed a dofn.\n+func RegisterDoFn(dofn interface{}) {\n+\tf, ts, err := registerDoFn(dofn)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\tif f != nil {\n+\t\truntime.RegisterFunction(f)\n+\t}\n+\tfor _, t := range ts {\n+\t\truntime.RegisterType(t)\n+\t}\n+}\n+\n+// registerDoFn returns all types associated with the provided DoFn.\n+// If passed a functional DoFn, the first return is a Function to\n+// register with runtime.RegisterFunction.\n+// The second return is all types to register with runtime.RegisterType.\n+// Returns an error if the passed in values are not DoFns.\n+func registerDoFn(dofn interface{}) (interface{}, []reflect.Type, error) {\n+\tif rt, ok := dofn.(reflect.Type); ok {\n+\t\tif rt.Kind() == reflect.Ptr {\n+\t\t\trt = rt.Elem()\n+\t\t}\n+\t\tdofn = reflect.New(rt).Interface()", "originalCommit": "642948589c3c30dba4d02fc0f72c7b5f5cfd0d91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTEwMjkwOA==", "url": "https://github.com/apache/beam/pull/12903#discussion_r495102908", "bodyText": "The graph.NewFn validator requires an actual instance of the DoFn, since graph.NewFn was designed for pipeline construction. This line creates such an instance, if what is passed in is reflect.Type.", "author": "lostluck", "createdAt": "2020-09-25T16:32:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY5ODYwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQwNzc4OA==", "url": "https://github.com/apache/beam/pull/12903#discussion_r495407788", "bodyText": "Oh, duh. I had a brain-fart that this statement only happens if the dofn is a reflect.Type. I was imagining turning an actual DoFn instance into a reflect.Type and back. Makes complete sense now.", "author": "youngoli", "createdAt": "2020-09-26T03:17:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY5ODYwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1MzQ2MA==", "url": "https://github.com/apache/beam/pull/12903#discussion_r494753460", "bodyText": "Note that while restrictions need to be serializable, restriction trackers don't (and probably can't). Registering RTrackers is probably not a problem as long as nothing actually tries to use the registered type, but otherwise you can probably avoid registering RTrackers by removing this line pulling CreateTrackerFn.", "author": "youngoli", "createdAt": "2020-09-25T05:21:33Z", "path": "sdks/go/pkg/beam/core/runtime/genx/genx.go", "diffHunk": "@@ -0,0 +1,172 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package genx is a convenience package to better support the code\n+// generator. It can be depended on by the user facing beam package\n+// and be refered to by generated code.\n+//\n+// Similarly, it can depend on beam internals and access the canonical\n+// method list in the graph package, or other packages to filter out\n+// types that aren't necessary for registration (like context.Context).\n+package genx\n+\n+import (\n+\t\"reflect\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/funcx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime\"\n+)\n+\n+// RegisterDoFn is a convenience function for registering DoFns.\n+// Differs from RegisterFunction and RegisterType by introspecting\n+// all parameters and returns of Lifecycle methods on the dofn,\n+// and registers those types for you.\n+//\n+// Panics if not passed a dofn.\n+func RegisterDoFn(dofn interface{}) {\n+\tf, ts, err := registerDoFn(dofn)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\tif f != nil {\n+\t\truntime.RegisterFunction(f)\n+\t}\n+\tfor _, t := range ts {\n+\t\truntime.RegisterType(t)\n+\t}\n+}\n+\n+// registerDoFn returns all types associated with the provided DoFn.\n+// If passed a functional DoFn, the first return is a Function to\n+// register with runtime.RegisterFunction.\n+// The second return is all types to register with runtime.RegisterType.\n+// Returns an error if the passed in values are not DoFns.\n+func registerDoFn(dofn interface{}) (interface{}, []reflect.Type, error) {\n+\tif rt, ok := dofn.(reflect.Type); ok {\n+\t\tif rt.Kind() == reflect.Ptr {\n+\t\t\trt = rt.Elem()\n+\t\t}\n+\t\tdofn = reflect.New(rt).Interface()\n+\t}\n+\tfn, err := graph.NewFn(dofn)\n+\tif err != nil {\n+\t\treturn nil, nil, err\n+\t}\n+\tc := cache{}\n+\tvar valid bool\n+\t// Validates that this is a DoFn or combineFn.\n+\tdo, err := graph.AsDoFn(fn, graph.MainUnknown)\n+\tif err == nil {\n+\t\tvalid = true\n+\t\thandleDoFn(do, c)\n+\t} else if cmb, err2 := graph.AsCombineFn(fn); err2 == nil {\n+\t\tvalid = true\n+\t\thandleCombineFn(cmb, c)\n+\t}\n+\tif !valid {\n+\t\t// Return the DoFn specific error as that's more common.\n+\t\treturn nil, nil, err\n+\t}\n+\n+\tvar retFunc interface{}\n+\trt := reflect.TypeOf(dofn)\n+\tswitch rt.Kind() {\n+\tcase reflect.Func:\n+\t\tretFunc = dofn\n+\t\tc.regFuncTypes(rt)\n+\tdefault:\n+\t\tc.regType(rt)\n+\t}\n+\tvar retTypes []reflect.Type\n+\tfor _, t := range c {\n+\t\tretTypes = append(retTypes, t)\n+\t}\n+\treturn retFunc, retTypes, nil\n+}\n+\n+func handleDoFn(fn *graph.DoFn, c cache) {\n+\tc.pullMethod(fn.SetupFn())\n+\tc.pullMethod(fn.StartBundleFn())\n+\tc.pullMethod(fn.ProcessElementFn())\n+\tc.pullMethod(fn.FinishBundleFn())\n+\tc.pullMethod(fn.TeardownFn())\n+\tif !fn.IsSplittable() {\n+\t\treturn\n+\t}\n+\tsdf := (*graph.SplittableDoFn)(fn)\n+\tc.pullMethod(sdf.CreateInitialRestrictionFn())\n+\tc.pullMethod(sdf.CreateTrackerFn())", "originalCommit": "642948589c3c30dba4d02fc0f72c7b5f5cfd0d91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTEwNzExMg==", "url": "https://github.com/apache/beam/pull/12903#discussion_r495107112", "bodyText": "RTs would be registered anyway since they show up in the ProcessElement signature. It's OK for extra types to be registered, the framework just won't automatically synthesize them like it needs to for other elements.", "author": "lostluck", "createdAt": "2020-09-25T16:40:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1MzQ2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1ODI4NA==", "url": "https://github.com/apache/beam/pull/12903#discussion_r494758284", "bodyText": "Nitpick: Is removing the last sentence intentional? If so, should it also be removed in forward.go?", "author": "youngoli", "createdAt": "2020-09-25T05:39:35Z", "path": "sdks/go/pkg/beam/core/runtime/symbols.go", "diffHunk": "@@ -72,7 +72,7 @@ type SymbolResolver interface {\n // RegisterFunction allows function registration. It is beneficial for performance\n // and is needed for functions -- such as custom coders -- serialized during unit\n // tests, where the underlying symbol table is not available. It should be called\n-// in init() only. Returns the external key for the function.\n+// in `init()` only.", "originalCommit": "642948589c3c30dba4d02fc0f72c7b5f5cfd0d91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTEwNzY1MA==", "url": "https://github.com/apache/beam/pull/12903#discussion_r495107650", "bodyText": "Great catch! It should be removed from forward.go! I removed it since this function doesn't return anything ever, so it was incorrect documentation.", "author": "lostluck", "createdAt": "2020-09-25T16:41:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc1ODI4NA=="}], "type": "inlineReview"}, {"oid": "0f4b41eb6596056f9c5e51b692de801aee8c8d96", "url": "https://github.com/apache/beam/commit/0f4b41eb6596056f9c5e51b692de801aee8c8d96", "message": "!fixup add documentation", "committedDate": "2020-09-25T16:50:00Z", "type": "commit"}, {"oid": "c190522a7c94dc8b07bac0de6dec3e04845be09d", "url": "https://github.com/apache/beam/commit/c190522a7c94dc8b07bac0de6dec3e04845be09d", "message": "!fixup usage documentation", "committedDate": "2020-09-25T17:02:16Z", "type": "commit"}]}