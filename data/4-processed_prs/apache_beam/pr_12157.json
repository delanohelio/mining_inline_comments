{"pr_number": 12157, "pr_title": "[BEAM-7587] Spark portable streaming", "pr_createdAt": "2020-07-01T22:28:32Z", "pr_url": "https://github.com/apache/beam/pull/12157", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY1NjQxMA==", "url": "https://github.com/apache/beam/pull/12157#discussion_r448656410", "bodyText": "Import classes instead of packages to avoid bloating the namespace.", "author": "ibzib", "createdAt": "2020-07-01T22:53:11Z", "path": "runners/spark/src/main/java/org/apache/beam/runners/spark/SparkPipelineRunner.java", "diffHunk": "@@ -40,9 +41,7 @@\n import org.apache.beam.runners.jobsubmission.PortablePipelineRunner;\n import org.apache.beam.runners.spark.aggregators.AggregatorsAccumulator;\n import org.apache.beam.runners.spark.metrics.MetricsAccumulator;\n-import org.apache.beam.runners.spark.translation.SparkBatchPortablePipelineTranslator;\n-import org.apache.beam.runners.spark.translation.SparkContextFactory;\n-import org.apache.beam.runners.spark.translation.SparkTranslationContext;\n+import org.apache.beam.runners.spark.translation.*;", "originalCommit": "a305406ee36064a0a35779a5669832068221cb55", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY1Njg5MQ==", "url": "https://github.com/apache/beam/pull/12157#discussion_r448656891", "bodyText": "Why are these access changes necessary?", "author": "ibzib", "createdAt": "2020-07-01T22:54:36Z", "path": "runners/spark/src/main/java/org/apache/beam/runners/spark/translation/SparkTranslationContext.java", "diffHunk": "@@ -35,15 +35,15 @@\n  * compute them after translation.\n  */\n public class SparkTranslationContext {\n-  private final JavaSparkContext jsc;\n+  protected final JavaSparkContext jsc;", "originalCommit": "a305406ee36064a0a35779a5669832068221cb55", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDI4MTczOQ==", "url": "https://github.com/apache/beam/pull/12157#discussion_r450281739", "bodyText": "You're right, they shouldn't be, I got confused with the inheritance", "author": "annaqin418", "createdAt": "2020-07-06T14:58:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY1Njg5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUyMTU0Mg==", "url": "https://github.com/apache/beam/pull/12157#discussion_r450521542", "bodyText": "This option only applies to Flink, it has no meaning in Spark. \n  \n    \n      beam/runners/flink/src/main/java/org/apache/beam/runners/flink/FlinkPipelineOptions.java\n    \n    \n         Line 74\n      in\n      103facb\n    \n    \n    \n    \n\n        \n          \n           Integer getParallelism();", "author": "ibzib", "createdAt": "2020-07-06T22:59:35Z", "path": "runners/spark/job-server/build.gradle", "diffHunk": "@@ -82,13 +82,21 @@ runShadow {\n     jvmArgs += [\"-Dorg.slf4j.simpleLogger.defaultLogLevel=${project.property('logLevel')}\"]\n }\n \n-def portableValidatesRunnerTask(String name) {\n+def portableValidatesRunnerTask(String name, Boolean streaming) {\n+  def pipelineOptions = [\n+          // Limit resource consumption via parallelism\n+          \"--parallelism=2\",", "originalCommit": "d2d3f3ef0e67e52bececf67a34f61b7123de1c47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "679dd939d8fae4ef191891e1fb1f78362799d683", "url": "https://github.com/apache/beam/commit/679dd939d8fae4ef191891e1fb1f78362799d683", "message": "flatten v0", "committedDate": "2020-07-17T21:30:17Z", "type": "forcePushed"}, {"oid": "ecbe519c5cdb569156a8805221747fc4710ebd3e", "url": "https://github.com/apache/beam/commit/ecbe519c5cdb569156a8805221747fc4710ebd3e", "message": "no-output sink", "committedDate": "2020-07-21T16:54:26Z", "type": "forcePushed"}, {"oid": "5fafd4dd77d9e7472360d5818106518774c2e10e", "url": "https://github.com/apache/beam/commit/5fafd4dd77d9e7472360d5818106518774c2e10e", "message": "start streaming context in portable runner; modified impulse and exec stage", "committedDate": "2020-08-03T22:14:31Z", "type": "forcePushed"}, {"oid": "37c2c94a9be216fdd724654ee2ce35c8415f8c61", "url": "https://github.com/apache/beam/commit/37c2c94a9be216fdd724654ee2ce35c8415f8c61", "message": "reshuffle v0", "committedDate": "2020-08-11T17:08:02Z", "type": "forcePushed"}, {"oid": "603b91685fa1283bb9f07bda6c93f710e8829a64", "url": "https://github.com/apache/beam/commit/603b91685fa1283bb9f07bda6c93f710e8829a64", "message": "added jenkins job, changed watermark timestamp", "committedDate": "2020-08-11T22:17:50Z", "type": "forcePushed"}, {"oid": "cfd50c3c366d153bb0e2151beb18ee3b207498f5", "url": "https://github.com/apache/beam/commit/cfd50c3c366d153bb0e2151beb18ee3b207498f5", "message": "timeout option for streaming v0.1", "committedDate": "2020-08-13T01:56:20Z", "type": "forcePushed"}, {"oid": "9e8c7b48be4996016437650aa5180e4a6c7b0219", "url": "https://github.com/apache/beam/commit/9e8c7b48be4996016437650aa5180e4a6c7b0219", "message": "spotless, checkstyle, spotbugs", "committedDate": "2020-08-13T22:54:16Z", "type": "forcePushed"}, {"oid": "b3fba9cb53d5c0e1e5950d5065736966af25b97a", "url": "https://github.com/apache/beam/commit/b3fba9cb53d5c0e1e5950d5065736966af25b97a", "message": "separate build task for streaming, updated registrar test", "committedDate": "2020-08-14T18:43:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg5MzM3MA==", "url": "https://github.com/apache/beam/pull/12157#discussion_r470893370", "bodyText": "Since the batch and streaming configurations only differ in three fields (pipelineOptions, testCategories, and testFilter),  they should share the rest to avoid code duplication.\nFYI createPortableValidatesRunnerTask is implicitly creating a PortableValidatesRunnerConfiguration object, to share code you will probably have to create one explicitly.\n\n  \n    \n      beam/buildSrc/src/main/groovy/org/apache/beam/gradle/BeamModulePlugin.groovy\n    \n    \n         Line 245\n      in\n      71c7760\n    \n    \n    \n    \n\n        \n          \n           class PortableValidatesRunnerConfiguration {", "author": "ibzib", "createdAt": "2020-08-14T22:39:01Z", "path": "runners/spark/job-server/build.gradle", "diffHunk": "@@ -82,53 +82,116 @@ runShadow {\n     jvmArgs += [\"-Dorg.slf4j.simpleLogger.defaultLogLevel=${project.property('logLevel')}\"]\n }\n \n-def portableValidatesRunnerTask(String name) {\n-  createPortableValidatesRunnerTask(\n-    name: \"validatesPortableRunner${name}\",\n-    jobServerDriver: \"org.apache.beam.runners.spark.SparkJobServerDriver\",\n-    jobServerConfig: \"--job-host=localhost,--job-port=0,--artifact-port=0,--expansion-port=0\",\n-    testClasspathConfiguration: configurations.validatesPortableRunner,\n-    numParallelTests: 4,\n-    environment: BeamModulePlugin.PortableValidatesRunnerConfiguration.Environment.EMBEDDED,\n-    systemProperties: [\n-      \"beam.spark.test.reuseSparkContext\": \"false\",\n-      \"spark.ui.enabled\": \"false\",\n-      \"spark.ui.showConsoleProgress\": \"false\",\n-    ],\n-    testCategories: {\n-      includeCategories 'org.apache.beam.sdk.testing.ValidatesRunner'\n-      excludeCategories 'org.apache.beam.sdk.testing.FlattenWithHeterogeneousCoders'\n-      excludeCategories 'org.apache.beam.sdk.testing.LargeKeys$Above100MB'\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesCommittedMetrics'\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesCustomWindowMerging'\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesFailureMessage'\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesGaugeMetrics'\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesParDoLifecycle'\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesMapState'\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesSetState'\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesOrderedListState'\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesTimerMap'\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesKeyInParDo'\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesOnWindowExpiration'\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesTestStream'\n-      //SplitableDoFnTests\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesBoundedSplittableParDo'\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesSplittableParDoWithWindowedSideInputs'\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesUnboundedSplittableParDo'\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesStrictTimerOrdering'\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesBundleFinalizer'\n-    },\n-    testFilter: {\n-      // TODO(BEAM-10094)\n-      excludeTestsMatching 'org.apache.beam.sdk.transforms.FlattenTest.testFlattenWithDifferentInputAndOutputCoders2'\n-    },\n-  )\n+def portableValidatesRunnerTask(String name, Boolean streaming) {\n+  def pipelineOptions = []\n+  if (streaming) {\n+    pipelineOptions += \"--streaming\"\n+    pipelineOptions += \"--timeout=20000\"\n+    // exclude unsupported tests\n+    createPortableValidatesRunnerTask(", "originalCommit": "b3fba9cb53d5c0e1e5950d5065736966af25b97a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg5NDU0MQ==", "url": "https://github.com/apache/beam/pull/12157#discussion_r470894541", "bodyText": "Nit: reorder this to make it more readable.\nboolean isStreaming = pipelineOptions.isStreaming() || hasUnboundedPCollections(pipeline);\nif (isStreaming) {\n...\n} else {\n...\n}", "author": "ibzib", "createdAt": "2020-08-14T22:44:23Z", "path": "runners/spark/src/main/java/org/apache/beam/runners/spark/SparkPipelineRunner.java", "diffHunk": "@@ -71,7 +79,15 @@ public SparkPipelineRunner(SparkPipelineOptions pipelineOptions) {\n \n   @Override\n   public PortablePipelineResult run(RunnerApi.Pipeline pipeline, JobInfo jobInfo) {\n-    SparkBatchPortablePipelineTranslator translator = new SparkBatchPortablePipelineTranslator();\n+    boolean isStreaming;\n+    SparkPortablePipelineTranslator translator;\n+    if (!pipelineOptions.isStreaming() && !hasUnboundedPCollections(pipeline)) {", "originalCommit": "b3fba9cb53d5c0e1e5950d5065736966af25b97a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg5NjY1OA==", "url": "https://github.com/apache/beam/pull/12157#discussion_r470896658", "bodyText": "Prefer to go through the logger rather than using printStackTrace.\nAll the LOG methods take an exception as an additional argument, like this: \n  \n    \n      beam/runners/spark/src/main/java/org/apache/beam/runners/spark/SparkJobServerDriver.java\n    \n    \n         Line 71\n      in\n      e725118\n    \n    \n    \n    \n\n        \n          \n           LOG.error(\"Unable to parse command line arguments.\", e);", "author": "ibzib", "createdAt": "2020-08-14T22:53:46Z", "path": "runners/spark/src/main/java/org/apache/beam/runners/spark/SparkPipelineRunner.java", "diffHunk": "@@ -106,39 +123,95 @@ public PortablePipelineResult run(RunnerApi.Pipeline pipeline, JobInfo jobInfo)\n         pipelineOptions.getFilesToStage().size());\n     LOG.debug(\"Staging files: {}\", pipelineOptions.getFilesToStage());\n \n+    PortablePipelineResult result;\n     final JavaSparkContext jsc = SparkContextFactory.getSparkContext(pipelineOptions);\n+\n     LOG.info(String.format(\"Running job %s on Spark master %s\", jobInfo.jobId(), jsc.master()));\n-    AggregatorsAccumulator.init(pipelineOptions, jsc);\n \n+    // Initialize accumulators.\n+    AggregatorsAccumulator.init(pipelineOptions, jsc);\n     MetricsEnvironment.setMetricsSupported(true);\n     MetricsAccumulator.init(pipelineOptions, jsc);\n \n     final SparkTranslationContext context =\n-        new SparkTranslationContext(jsc, pipelineOptions, jobInfo);\n+        translator.createTranslationContext(jsc, pipelineOptions, jobInfo);\n     final ExecutorService executorService = Executors.newSingleThreadExecutor();\n-    final Future<?> submissionFuture =\n-        executorService.submit(\n-            () -> {\n-              translator.translate(fusedPipeline, context);\n-              LOG.info(\n-                  String.format(\n-                      \"Job %s: Pipeline translated successfully. Computing outputs\",\n-                      jobInfo.jobId()));\n-              context.computeOutputs();\n-              LOG.info(String.format(\"Job %s finished.\", jobInfo.jobId()));\n-            });\n-\n-    PortablePipelineResult result =\n-        new SparkPipelineResult.PortableBatchMode(submissionFuture, jsc);\n+\n+    LOG.info(String.format(\"Running job %s on Spark master %s\", jobInfo.jobId(), jsc.master()));\n+\n+    if (isStreaming) {\n+      final JavaStreamingContext jssc =\n+          ((SparkStreamingTranslationContext) context).getStreamingContext();\n+\n+      jssc.addStreamingListener(\n+          new JavaStreamingListenerWrapper(\n+              new AggregatorsAccumulator.AccumulatorCheckpointingSparkListener()));\n+      jssc.addStreamingListener(\n+          new JavaStreamingListenerWrapper(\n+              new MetricsAccumulator.AccumulatorCheckpointingSparkListener()));\n+\n+      // register user-defined listeners.\n+      for (JavaStreamingListener listener :\n+          pipelineOptions.as(SparkContextOptions.class).getListeners()) {\n+        LOG.info(\"Registered listener {}.\" + listener.getClass().getSimpleName());\n+        jssc.addStreamingListener(new JavaStreamingListenerWrapper(listener));\n+      }\n+\n+      // register Watermarks listener to broadcast the advanced WMs.\n+      jssc.addStreamingListener(\n+          new JavaStreamingListenerWrapper(\n+              new GlobalWatermarkHolder.WatermarkAdvancingStreamingListener()));\n+\n+      jssc.checkpoint(pipelineOptions.getCheckpointDir());\n+\n+      // Obtain timeout from options.\n+      Long timeout = pipelineOptions.as(SparkPortableStreamingPipelineOptions.class).getTimeout();\n+\n+      final Future<?> submissionFuture =\n+          executorService.submit(\n+              () -> {\n+                translator.translate(fusedPipeline, context);\n+                LOG.info(\n+                    String.format(\n+                        \"Job %s: Pipeline translated successfully. Computing outputs\",\n+                        jobInfo.jobId()));\n+                context.computeOutputs();\n+\n+                jssc.start();\n+                try {\n+                  jssc.awaitTerminationOrTimeout(timeout);\n+                } catch (InterruptedException e) {\n+                  LOG.warn(\"Streaming context interrupted, shutting down.\");\n+                  e.printStackTrace();", "originalCommit": "b3fba9cb53d5c0e1e5950d5065736966af25b97a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg5NzY0NA==", "url": "https://github.com/apache/beam/pull/12157#discussion_r470897644", "bodyText": "If -1L has a special meaning (ie infinity), document it here.", "author": "ibzib", "createdAt": "2020-08-14T22:58:23Z", "path": "runners/spark/src/main/java/org/apache/beam/runners/spark/SparkPortableStreamingPipelineOptions.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.spark;\n+\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.options.Default;\n+import org.apache.beam.sdk.options.Description;\n+import org.apache.beam.sdk.options.PipelineOptions;\n+import org.apache.beam.sdk.options.PortablePipelineOptions;\n+\n+/**\n+ * Spark runner {@link PipelineOptions} handles Spark execution-related configurations, such as the\n+ * master address, batch-interval, and other user-related knobs.\n+ */\n+@Experimental\n+public interface SparkPortableStreamingPipelineOptions\n+    extends SparkPipelineOptions, PortablePipelineOptions, PipelineOptions {\n+  @Description(\"Timeout for testing Spark portable streaming, in milliseconds.\")", "originalCommit": "b3fba9cb53d5c0e1e5950d5065736966af25b97a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg5ODA1OQ==", "url": "https://github.com/apache/beam/pull/12157#discussion_r470898059", "bodyText": "Is -1L already treated as a special case by the Spark streaming context, or do we need to handle it specially in Beam?", "author": "ibzib", "createdAt": "2020-08-14T23:00:22Z", "path": "runners/spark/src/main/java/org/apache/beam/runners/spark/SparkPortableStreamingPipelineOptions.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.spark;\n+\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.options.Default;\n+import org.apache.beam.sdk.options.Description;\n+import org.apache.beam.sdk.options.PipelineOptions;\n+import org.apache.beam.sdk.options.PortablePipelineOptions;\n+\n+/**\n+ * Spark runner {@link PipelineOptions} handles Spark execution-related configurations, such as the\n+ * master address, batch-interval, and other user-related knobs.\n+ */\n+@Experimental\n+public interface SparkPortableStreamingPipelineOptions\n+    extends SparkPipelineOptions, PortablePipelineOptions, PipelineOptions {\n+  @Description(\"Timeout for testing Spark portable streaming, in milliseconds.\")\n+  @Default.Long(-1L)", "originalCommit": "b3fba9cb53d5c0e1e5950d5065736966af25b97a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE2OTU2Nw==", "url": "https://github.com/apache/beam/pull/12157#discussion_r471169567", "bodyText": "This is a good question, I couldn't find documentation on the proper way to have no timeout. Typically it seems that you would just use two entirely separate methods, awaitTermination() and awaitTerminationOrTimeout(). -1L simply appeared to give the desired behavior...", "author": "annaqin418", "createdAt": "2020-08-16T22:58:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg5ODA1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY2NzIxNA==", "url": "https://github.com/apache/beam/pull/12157#discussion_r471667214", "bodyText": "It's not really documented anywhere, but I found it in the Spark source. Looks like awaitTermination() is indeed equivalent to awaitTerminationOrTimeout(-1).\nhttps://github.com/apache/spark/blob/b03761e3303e979999d4faa5cf4d1719a82e06cb/streaming/src/main/scala/org/apache/spark/streaming/StreamingContext.scala#L637\nhttps://github.com/apache/spark/blob/b03761e3303e979999d4faa5cf4d1719a82e06cb/streaming/src/main/scala/org/apache/spark/streaming/ContextWaiter.scala#L58", "author": "ibzib", "createdAt": "2020-08-17T18:04:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg5ODA1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg5ODg4Nw==", "url": "https://github.com/apache/beam/pull/12157#discussion_r470898887", "bodyText": "Pipeline options all occupy the same namespace. We should give this option a name more specific to its purpose to prevent collisions.\nAlso, this is just personal preference, but I like when folks suffix their variable names with the units (here, Ms or Millis or Milliseconds) when using raw numbers as time values.", "author": "ibzib", "createdAt": "2020-08-14T23:04:14Z", "path": "runners/spark/src/main/java/org/apache/beam/runners/spark/SparkPortableStreamingPipelineOptions.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.spark;\n+\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.options.Default;\n+import org.apache.beam.sdk.options.Description;\n+import org.apache.beam.sdk.options.PipelineOptions;\n+import org.apache.beam.sdk.options.PortablePipelineOptions;\n+\n+/**\n+ * Spark runner {@link PipelineOptions} handles Spark execution-related configurations, such as the\n+ * master address, batch-interval, and other user-related knobs.\n+ */\n+@Experimental\n+public interface SparkPortableStreamingPipelineOptions\n+    extends SparkPipelineOptions, PortablePipelineOptions, PipelineOptions {\n+  @Description(\"Timeout for testing Spark portable streaming, in milliseconds.\")\n+  @Default.Long(-1L)\n+  Long getTimeout();", "originalCommit": "b3fba9cb53d5c0e1e5950d5065736966af25b97a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg5OTI3NA==", "url": "https://github.com/apache/beam/pull/12157#discussion_r470899274", "bodyText": "Change this.", "author": "ibzib", "createdAt": "2020-08-14T23:05:52Z", "path": "runners/spark/src/main/java/org/apache/beam/runners/spark/SparkPortableStreamingPipelineOptions.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.spark;\n+\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.options.Default;\n+import org.apache.beam.sdk.options.Description;\n+import org.apache.beam.sdk.options.PipelineOptions;\n+import org.apache.beam.sdk.options.PortablePipelineOptions;\n+\n+/**\n+ * Spark runner {@link PipelineOptions} handles Spark execution-related configurations, such as the", "originalCommit": "b3fba9cb53d5c0e1e5950d5065736966af25b97a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg5OTQzNQ==", "url": "https://github.com/apache/beam/pull/12157#discussion_r470899435", "bodyText": "We figured out we don't need to extend PipelineOptions directly. Remove it.", "author": "ibzib", "createdAt": "2020-08-14T23:06:42Z", "path": "runners/spark/src/main/java/org/apache/beam/runners/spark/SparkPortableStreamingPipelineOptions.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.spark;\n+\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.options.Default;\n+import org.apache.beam.sdk.options.Description;\n+import org.apache.beam.sdk.options.PipelineOptions;\n+import org.apache.beam.sdk.options.PortablePipelineOptions;\n+\n+/**\n+ * Spark runner {@link PipelineOptions} handles Spark execution-related configurations, such as the\n+ * master address, batch-interval, and other user-related knobs.\n+ */\n+@Experimental\n+public interface SparkPortableStreamingPipelineOptions\n+    extends SparkPipelineOptions, PortablePipelineOptions, PipelineOptions {", "originalCommit": "b3fba9cb53d5c0e1e5950d5065736966af25b97a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkwMTU4Mg==", "url": "https://github.com/apache/beam/pull/12157#discussion_r470901582", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /** Translates a bounded portable pipeline into a Spark job. */\n          \n          \n            \n            /** Translates an unbounded portable pipeline into a Spark job. */", "author": "ibzib", "createdAt": "2020-08-14T23:17:05Z", "path": "runners/spark/src/main/java/org/apache/beam/runners/spark/translation/SparkStreamingPortablePipelineTranslator.java", "diffHunk": "@@ -0,0 +1,393 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.spark.translation;\n+\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.createOutputMap;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getWindowingStrategy;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+import org.apache.beam.runners.core.construction.PTransformTranslation;\n+import org.apache.beam.runners.core.construction.graph.ExecutableStage;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode.PTransformNode;\n+import org.apache.beam.runners.core.construction.graph.QueryablePipeline;\n+import org.apache.beam.runners.fnexecution.provisioning.JobInfo;\n+import org.apache.beam.runners.fnexecution.wire.WireCoders;\n+import org.apache.beam.runners.spark.SparkPipelineOptions;\n+import org.apache.beam.runners.spark.coders.CoderHelpers;\n+import org.apache.beam.runners.spark.metrics.MetricsAccumulator;\n+import org.apache.beam.runners.spark.stateful.SparkGroupAlsoByWindowViaWindowSet;\n+import org.apache.beam.runners.spark.translation.streaming.UnboundedDataset;\n+import org.apache.beam.runners.spark.util.GlobalWatermarkHolder;\n+import org.apache.beam.runners.spark.util.SparkCompat;\n+import org.apache.beam.sdk.coders.ByteArrayCoder;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.transforms.join.RawUnionValue;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.GlobalWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.util.WindowedValue;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.TimestampedValue;\n+import org.apache.beam.sdk.values.WindowingStrategy;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.BiMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+import org.apache.spark.api.java.JavaRDD;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.broadcast.Broadcast;\n+import org.apache.spark.storage.StorageLevel;\n+import org.apache.spark.streaming.api.java.JavaDStream;\n+import org.apache.spark.streaming.api.java.JavaInputDStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import scala.Tuple2;\n+\n+/** Translates a bounded portable pipeline into a Spark job. */", "originalCommit": "b3fba9cb53d5c0e1e5950d5065736966af25b97a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkwMjMxNw==", "url": "https://github.com/apache/beam/pull/12157#discussion_r470902317", "bodyText": "Super nit: this line doesn't deserve a newline following it.", "author": "ibzib", "createdAt": "2020-08-14T23:20:28Z", "path": "runners/spark/src/main/java/org/apache/beam/runners/spark/translation/SparkStreamingPortablePipelineTranslator.java", "diffHunk": "@@ -0,0 +1,393 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.spark.translation;\n+\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.createOutputMap;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getWindowingStrategy;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+import org.apache.beam.runners.core.construction.PTransformTranslation;\n+import org.apache.beam.runners.core.construction.graph.ExecutableStage;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode.PTransformNode;\n+import org.apache.beam.runners.core.construction.graph.QueryablePipeline;\n+import org.apache.beam.runners.fnexecution.provisioning.JobInfo;\n+import org.apache.beam.runners.fnexecution.wire.WireCoders;\n+import org.apache.beam.runners.spark.SparkPipelineOptions;\n+import org.apache.beam.runners.spark.coders.CoderHelpers;\n+import org.apache.beam.runners.spark.metrics.MetricsAccumulator;\n+import org.apache.beam.runners.spark.stateful.SparkGroupAlsoByWindowViaWindowSet;\n+import org.apache.beam.runners.spark.translation.streaming.UnboundedDataset;\n+import org.apache.beam.runners.spark.util.GlobalWatermarkHolder;\n+import org.apache.beam.runners.spark.util.SparkCompat;\n+import org.apache.beam.sdk.coders.ByteArrayCoder;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.transforms.join.RawUnionValue;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.GlobalWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.util.WindowedValue;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.TimestampedValue;\n+import org.apache.beam.sdk.values.WindowingStrategy;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.BiMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+import org.apache.spark.api.java.JavaRDD;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.broadcast.Broadcast;\n+import org.apache.spark.storage.StorageLevel;\n+import org.apache.spark.streaming.api.java.JavaDStream;\n+import org.apache.spark.streaming.api.java.JavaInputDStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import scala.Tuple2;\n+\n+/** Translates a bounded portable pipeline into a Spark job. */\n+public class SparkStreamingPortablePipelineTranslator\n+    implements SparkPortablePipelineTranslator<SparkStreamingTranslationContext> {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(SparkStreamingPortablePipelineTranslator.class);\n+\n+  private final ImmutableMap<String, PTransformTranslator> urnToTransformTranslator;\n+\n+  interface PTransformTranslator {\n+\n+    /** Translates transformNode from Beam into the Spark context. */\n+    void translate(\n+        PTransformNode transformNode,\n+        RunnerApi.Pipeline pipeline,\n+        SparkStreamingTranslationContext context);\n+  }\n+\n+  @Override\n+  public Set<String> knownUrns() {\n+    return urnToTransformTranslator.keySet();\n+  }\n+\n+  public SparkStreamingPortablePipelineTranslator() {\n+    ImmutableMap.Builder<String, PTransformTranslator> translatorMap = ImmutableMap.builder();\n+    translatorMap.put(\n+        PTransformTranslation.IMPULSE_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateImpulse);\n+    translatorMap.put(\n+        PTransformTranslation.GROUP_BY_KEY_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateGroupByKey);\n+    translatorMap.put(\n+        ExecutableStage.URN, SparkStreamingPortablePipelineTranslator::translateExecutableStage);\n+    translatorMap.put(\n+        PTransformTranslation.FLATTEN_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateFlatten);\n+    translatorMap.put(\n+        PTransformTranslation.RESHUFFLE_URN,\n+        SparkStreamingPortablePipelineTranslator::translateReshuffle);\n+    this.urnToTransformTranslator = translatorMap.build();\n+  }\n+\n+  /** Translates pipeline from Beam into the Spark context. */\n+  @Override\n+  public void translate(\n+      final RunnerApi.Pipeline pipeline, SparkStreamingTranslationContext context) {\n+    QueryablePipeline p =\n+        QueryablePipeline.forTransforms(\n+            pipeline.getRootTransformIdsList(), pipeline.getComponents());\n+    for (PipelineNode.PTransformNode transformNode : p.getTopologicallyOrderedTransforms()) {\n+      urnToTransformTranslator\n+          .getOrDefault(\n+              transformNode.getTransform().getSpec().getUrn(),\n+              SparkStreamingPortablePipelineTranslator::urnNotFound)\n+          .translate(transformNode, pipeline, context);\n+    }\n+  }\n+\n+  private static void urnNotFound(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    throw new IllegalArgumentException(\n+        String.format(\n+            \"Transform %s has unknown URN %s\",\n+            transformNode.getId(), transformNode.getTransform().getSpec().getUrn()));\n+  }\n+\n+  private static void translateImpulse(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+\n+    TimestampedValue<byte[]> tsValue = TimestampedValue.atMinimumTimestamp(new byte[0]);\n+    Iterable<TimestampedValue<byte[]>> timestampedValues = Collections.singletonList(tsValue);\n+    Iterable<WindowedValue<byte[]>> windowedValues =\n+        StreamSupport.stream(timestampedValues.spliterator(), false)\n+            .map(\n+                timestampedValue ->\n+                    WindowedValue.of(\n+                        timestampedValue.getValue(),\n+                        timestampedValue.getTimestamp(),\n+                        GlobalWindow.INSTANCE,\n+                        PaneInfo.NO_FIRING))\n+            .collect(Collectors.toList());\n+\n+    ByteArrayCoder coder = ByteArrayCoder.of();", "originalCommit": "b3fba9cb53d5c0e1e5950d5065736966af25b97a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkwMjcxNw==", "url": "https://github.com/apache/beam/pull/12157#discussion_r470902717", "bodyText": "Nit: variable naming. An RDD containing an empty byte array is not empty itself.", "author": "ibzib", "createdAt": "2020-08-14T23:22:27Z", "path": "runners/spark/src/main/java/org/apache/beam/runners/spark/translation/SparkStreamingPortablePipelineTranslator.java", "diffHunk": "@@ -0,0 +1,393 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.spark.translation;\n+\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.createOutputMap;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getWindowingStrategy;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+import org.apache.beam.runners.core.construction.PTransformTranslation;\n+import org.apache.beam.runners.core.construction.graph.ExecutableStage;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode.PTransformNode;\n+import org.apache.beam.runners.core.construction.graph.QueryablePipeline;\n+import org.apache.beam.runners.fnexecution.provisioning.JobInfo;\n+import org.apache.beam.runners.fnexecution.wire.WireCoders;\n+import org.apache.beam.runners.spark.SparkPipelineOptions;\n+import org.apache.beam.runners.spark.coders.CoderHelpers;\n+import org.apache.beam.runners.spark.metrics.MetricsAccumulator;\n+import org.apache.beam.runners.spark.stateful.SparkGroupAlsoByWindowViaWindowSet;\n+import org.apache.beam.runners.spark.translation.streaming.UnboundedDataset;\n+import org.apache.beam.runners.spark.util.GlobalWatermarkHolder;\n+import org.apache.beam.runners.spark.util.SparkCompat;\n+import org.apache.beam.sdk.coders.ByteArrayCoder;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.transforms.join.RawUnionValue;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.GlobalWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.util.WindowedValue;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.TimestampedValue;\n+import org.apache.beam.sdk.values.WindowingStrategy;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.BiMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+import org.apache.spark.api.java.JavaRDD;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.broadcast.Broadcast;\n+import org.apache.spark.storage.StorageLevel;\n+import org.apache.spark.streaming.api.java.JavaDStream;\n+import org.apache.spark.streaming.api.java.JavaInputDStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import scala.Tuple2;\n+\n+/** Translates a bounded portable pipeline into a Spark job. */\n+public class SparkStreamingPortablePipelineTranslator\n+    implements SparkPortablePipelineTranslator<SparkStreamingTranslationContext> {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(SparkStreamingPortablePipelineTranslator.class);\n+\n+  private final ImmutableMap<String, PTransformTranslator> urnToTransformTranslator;\n+\n+  interface PTransformTranslator {\n+\n+    /** Translates transformNode from Beam into the Spark context. */\n+    void translate(\n+        PTransformNode transformNode,\n+        RunnerApi.Pipeline pipeline,\n+        SparkStreamingTranslationContext context);\n+  }\n+\n+  @Override\n+  public Set<String> knownUrns() {\n+    return urnToTransformTranslator.keySet();\n+  }\n+\n+  public SparkStreamingPortablePipelineTranslator() {\n+    ImmutableMap.Builder<String, PTransformTranslator> translatorMap = ImmutableMap.builder();\n+    translatorMap.put(\n+        PTransformTranslation.IMPULSE_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateImpulse);\n+    translatorMap.put(\n+        PTransformTranslation.GROUP_BY_KEY_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateGroupByKey);\n+    translatorMap.put(\n+        ExecutableStage.URN, SparkStreamingPortablePipelineTranslator::translateExecutableStage);\n+    translatorMap.put(\n+        PTransformTranslation.FLATTEN_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateFlatten);\n+    translatorMap.put(\n+        PTransformTranslation.RESHUFFLE_URN,\n+        SparkStreamingPortablePipelineTranslator::translateReshuffle);\n+    this.urnToTransformTranslator = translatorMap.build();\n+  }\n+\n+  /** Translates pipeline from Beam into the Spark context. */\n+  @Override\n+  public void translate(\n+      final RunnerApi.Pipeline pipeline, SparkStreamingTranslationContext context) {\n+    QueryablePipeline p =\n+        QueryablePipeline.forTransforms(\n+            pipeline.getRootTransformIdsList(), pipeline.getComponents());\n+    for (PipelineNode.PTransformNode transformNode : p.getTopologicallyOrderedTransforms()) {\n+      urnToTransformTranslator\n+          .getOrDefault(\n+              transformNode.getTransform().getSpec().getUrn(),\n+              SparkStreamingPortablePipelineTranslator::urnNotFound)\n+          .translate(transformNode, pipeline, context);\n+    }\n+  }\n+\n+  private static void urnNotFound(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    throw new IllegalArgumentException(\n+        String.format(\n+            \"Transform %s has unknown URN %s\",\n+            transformNode.getId(), transformNode.getTransform().getSpec().getUrn()));\n+  }\n+\n+  private static void translateImpulse(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+\n+    TimestampedValue<byte[]> tsValue = TimestampedValue.atMinimumTimestamp(new byte[0]);\n+    Iterable<TimestampedValue<byte[]>> timestampedValues = Collections.singletonList(tsValue);\n+    Iterable<WindowedValue<byte[]>> windowedValues =\n+        StreamSupport.stream(timestampedValues.spliterator(), false)\n+            .map(\n+                timestampedValue ->\n+                    WindowedValue.of(\n+                        timestampedValue.getValue(),\n+                        timestampedValue.getTimestamp(),\n+                        GlobalWindow.INSTANCE,\n+                        PaneInfo.NO_FIRING))\n+            .collect(Collectors.toList());\n+\n+    ByteArrayCoder coder = ByteArrayCoder.of();\n+\n+    WindowedValue.FullWindowedValueCoder<byte[]> windowCoder =\n+        WindowedValue.FullWindowedValueCoder.of(coder, GlobalWindow.Coder.INSTANCE);\n+    JavaRDD<WindowedValue<byte[]>> emptyRDD =", "originalCommit": "b3fba9cb53d5c0e1e5950d5065736966af25b97a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkwNDA0NA==", "url": "https://github.com/apache/beam/pull/12157#discussion_r470904044", "bodyText": "Nit: this comment is obvious from the code.", "author": "ibzib", "createdAt": "2020-08-14T23:29:40Z", "path": "runners/spark/src/main/java/org/apache/beam/runners/spark/translation/SparkStreamingPortablePipelineTranslator.java", "diffHunk": "@@ -0,0 +1,393 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.spark.translation;\n+\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.createOutputMap;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getWindowingStrategy;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+import org.apache.beam.runners.core.construction.PTransformTranslation;\n+import org.apache.beam.runners.core.construction.graph.ExecutableStage;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode.PTransformNode;\n+import org.apache.beam.runners.core.construction.graph.QueryablePipeline;\n+import org.apache.beam.runners.fnexecution.provisioning.JobInfo;\n+import org.apache.beam.runners.fnexecution.wire.WireCoders;\n+import org.apache.beam.runners.spark.SparkPipelineOptions;\n+import org.apache.beam.runners.spark.coders.CoderHelpers;\n+import org.apache.beam.runners.spark.metrics.MetricsAccumulator;\n+import org.apache.beam.runners.spark.stateful.SparkGroupAlsoByWindowViaWindowSet;\n+import org.apache.beam.runners.spark.translation.streaming.UnboundedDataset;\n+import org.apache.beam.runners.spark.util.GlobalWatermarkHolder;\n+import org.apache.beam.runners.spark.util.SparkCompat;\n+import org.apache.beam.sdk.coders.ByteArrayCoder;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.transforms.join.RawUnionValue;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.GlobalWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.util.WindowedValue;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.TimestampedValue;\n+import org.apache.beam.sdk.values.WindowingStrategy;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.BiMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+import org.apache.spark.api.java.JavaRDD;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.broadcast.Broadcast;\n+import org.apache.spark.storage.StorageLevel;\n+import org.apache.spark.streaming.api.java.JavaDStream;\n+import org.apache.spark.streaming.api.java.JavaInputDStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import scala.Tuple2;\n+\n+/** Translates a bounded portable pipeline into a Spark job. */\n+public class SparkStreamingPortablePipelineTranslator\n+    implements SparkPortablePipelineTranslator<SparkStreamingTranslationContext> {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(SparkStreamingPortablePipelineTranslator.class);\n+\n+  private final ImmutableMap<String, PTransformTranslator> urnToTransformTranslator;\n+\n+  interface PTransformTranslator {\n+\n+    /** Translates transformNode from Beam into the Spark context. */\n+    void translate(\n+        PTransformNode transformNode,\n+        RunnerApi.Pipeline pipeline,\n+        SparkStreamingTranslationContext context);\n+  }\n+\n+  @Override\n+  public Set<String> knownUrns() {\n+    return urnToTransformTranslator.keySet();\n+  }\n+\n+  public SparkStreamingPortablePipelineTranslator() {\n+    ImmutableMap.Builder<String, PTransformTranslator> translatorMap = ImmutableMap.builder();\n+    translatorMap.put(\n+        PTransformTranslation.IMPULSE_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateImpulse);\n+    translatorMap.put(\n+        PTransformTranslation.GROUP_BY_KEY_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateGroupByKey);\n+    translatorMap.put(\n+        ExecutableStage.URN, SparkStreamingPortablePipelineTranslator::translateExecutableStage);\n+    translatorMap.put(\n+        PTransformTranslation.FLATTEN_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateFlatten);\n+    translatorMap.put(\n+        PTransformTranslation.RESHUFFLE_URN,\n+        SparkStreamingPortablePipelineTranslator::translateReshuffle);\n+    this.urnToTransformTranslator = translatorMap.build();\n+  }\n+\n+  /** Translates pipeline from Beam into the Spark context. */\n+  @Override\n+  public void translate(\n+      final RunnerApi.Pipeline pipeline, SparkStreamingTranslationContext context) {\n+    QueryablePipeline p =\n+        QueryablePipeline.forTransforms(\n+            pipeline.getRootTransformIdsList(), pipeline.getComponents());\n+    for (PipelineNode.PTransformNode transformNode : p.getTopologicallyOrderedTransforms()) {\n+      urnToTransformTranslator\n+          .getOrDefault(\n+              transformNode.getTransform().getSpec().getUrn(),\n+              SparkStreamingPortablePipelineTranslator::urnNotFound)\n+          .translate(transformNode, pipeline, context);\n+    }\n+  }\n+\n+  private static void urnNotFound(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    throw new IllegalArgumentException(\n+        String.format(\n+            \"Transform %s has unknown URN %s\",\n+            transformNode.getId(), transformNode.getTransform().getSpec().getUrn()));\n+  }\n+\n+  private static void translateImpulse(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+\n+    TimestampedValue<byte[]> tsValue = TimestampedValue.atMinimumTimestamp(new byte[0]);\n+    Iterable<TimestampedValue<byte[]>> timestampedValues = Collections.singletonList(tsValue);\n+    Iterable<WindowedValue<byte[]>> windowedValues =\n+        StreamSupport.stream(timestampedValues.spliterator(), false)\n+            .map(\n+                timestampedValue ->\n+                    WindowedValue.of(\n+                        timestampedValue.getValue(),\n+                        timestampedValue.getTimestamp(),\n+                        GlobalWindow.INSTANCE,\n+                        PaneInfo.NO_FIRING))\n+            .collect(Collectors.toList());\n+\n+    ByteArrayCoder coder = ByteArrayCoder.of();\n+\n+    WindowedValue.FullWindowedValueCoder<byte[]> windowCoder =\n+        WindowedValue.FullWindowedValueCoder.of(coder, GlobalWindow.Coder.INSTANCE);\n+    JavaRDD<WindowedValue<byte[]>> emptyRDD =\n+        context\n+            .getSparkContext()\n+            .parallelize(CoderHelpers.toByteArrays(windowedValues, windowCoder))\n+            .map(CoderHelpers.fromByteFunction(windowCoder));\n+\n+    // create input DStream from RDD queue", "originalCommit": "b3fba9cb53d5c0e1e5950d5065736966af25b97a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkwNDIyNA==", "url": "https://github.com/apache/beam/pull/12157#discussion_r470904224", "bodyText": "Nit: should be named rddQueue.", "author": "ibzib", "createdAt": "2020-08-14T23:30:30Z", "path": "runners/spark/src/main/java/org/apache/beam/runners/spark/translation/SparkStreamingPortablePipelineTranslator.java", "diffHunk": "@@ -0,0 +1,393 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.spark.translation;\n+\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.createOutputMap;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getWindowingStrategy;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+import org.apache.beam.runners.core.construction.PTransformTranslation;\n+import org.apache.beam.runners.core.construction.graph.ExecutableStage;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode.PTransformNode;\n+import org.apache.beam.runners.core.construction.graph.QueryablePipeline;\n+import org.apache.beam.runners.fnexecution.provisioning.JobInfo;\n+import org.apache.beam.runners.fnexecution.wire.WireCoders;\n+import org.apache.beam.runners.spark.SparkPipelineOptions;\n+import org.apache.beam.runners.spark.coders.CoderHelpers;\n+import org.apache.beam.runners.spark.metrics.MetricsAccumulator;\n+import org.apache.beam.runners.spark.stateful.SparkGroupAlsoByWindowViaWindowSet;\n+import org.apache.beam.runners.spark.translation.streaming.UnboundedDataset;\n+import org.apache.beam.runners.spark.util.GlobalWatermarkHolder;\n+import org.apache.beam.runners.spark.util.SparkCompat;\n+import org.apache.beam.sdk.coders.ByteArrayCoder;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.transforms.join.RawUnionValue;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.GlobalWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.util.WindowedValue;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.TimestampedValue;\n+import org.apache.beam.sdk.values.WindowingStrategy;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.BiMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+import org.apache.spark.api.java.JavaRDD;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.broadcast.Broadcast;\n+import org.apache.spark.storage.StorageLevel;\n+import org.apache.spark.streaming.api.java.JavaDStream;\n+import org.apache.spark.streaming.api.java.JavaInputDStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import scala.Tuple2;\n+\n+/** Translates a bounded portable pipeline into a Spark job. */\n+public class SparkStreamingPortablePipelineTranslator\n+    implements SparkPortablePipelineTranslator<SparkStreamingTranslationContext> {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(SparkStreamingPortablePipelineTranslator.class);\n+\n+  private final ImmutableMap<String, PTransformTranslator> urnToTransformTranslator;\n+\n+  interface PTransformTranslator {\n+\n+    /** Translates transformNode from Beam into the Spark context. */\n+    void translate(\n+        PTransformNode transformNode,\n+        RunnerApi.Pipeline pipeline,\n+        SparkStreamingTranslationContext context);\n+  }\n+\n+  @Override\n+  public Set<String> knownUrns() {\n+    return urnToTransformTranslator.keySet();\n+  }\n+\n+  public SparkStreamingPortablePipelineTranslator() {\n+    ImmutableMap.Builder<String, PTransformTranslator> translatorMap = ImmutableMap.builder();\n+    translatorMap.put(\n+        PTransformTranslation.IMPULSE_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateImpulse);\n+    translatorMap.put(\n+        PTransformTranslation.GROUP_BY_KEY_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateGroupByKey);\n+    translatorMap.put(\n+        ExecutableStage.URN, SparkStreamingPortablePipelineTranslator::translateExecutableStage);\n+    translatorMap.put(\n+        PTransformTranslation.FLATTEN_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateFlatten);\n+    translatorMap.put(\n+        PTransformTranslation.RESHUFFLE_URN,\n+        SparkStreamingPortablePipelineTranslator::translateReshuffle);\n+    this.urnToTransformTranslator = translatorMap.build();\n+  }\n+\n+  /** Translates pipeline from Beam into the Spark context. */\n+  @Override\n+  public void translate(\n+      final RunnerApi.Pipeline pipeline, SparkStreamingTranslationContext context) {\n+    QueryablePipeline p =\n+        QueryablePipeline.forTransforms(\n+            pipeline.getRootTransformIdsList(), pipeline.getComponents());\n+    for (PipelineNode.PTransformNode transformNode : p.getTopologicallyOrderedTransforms()) {\n+      urnToTransformTranslator\n+          .getOrDefault(\n+              transformNode.getTransform().getSpec().getUrn(),\n+              SparkStreamingPortablePipelineTranslator::urnNotFound)\n+          .translate(transformNode, pipeline, context);\n+    }\n+  }\n+\n+  private static void urnNotFound(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    throw new IllegalArgumentException(\n+        String.format(\n+            \"Transform %s has unknown URN %s\",\n+            transformNode.getId(), transformNode.getTransform().getSpec().getUrn()));\n+  }\n+\n+  private static void translateImpulse(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+\n+    TimestampedValue<byte[]> tsValue = TimestampedValue.atMinimumTimestamp(new byte[0]);\n+    Iterable<TimestampedValue<byte[]>> timestampedValues = Collections.singletonList(tsValue);\n+    Iterable<WindowedValue<byte[]>> windowedValues =\n+        StreamSupport.stream(timestampedValues.spliterator(), false)\n+            .map(\n+                timestampedValue ->\n+                    WindowedValue.of(\n+                        timestampedValue.getValue(),\n+                        timestampedValue.getTimestamp(),\n+                        GlobalWindow.INSTANCE,\n+                        PaneInfo.NO_FIRING))\n+            .collect(Collectors.toList());\n+\n+    ByteArrayCoder coder = ByteArrayCoder.of();\n+\n+    WindowedValue.FullWindowedValueCoder<byte[]> windowCoder =\n+        WindowedValue.FullWindowedValueCoder.of(coder, GlobalWindow.Coder.INSTANCE);\n+    JavaRDD<WindowedValue<byte[]>> emptyRDD =\n+        context\n+            .getSparkContext()\n+            .parallelize(CoderHelpers.toByteArrays(windowedValues, windowCoder))\n+            .map(CoderHelpers.fromByteFunction(windowCoder));\n+\n+    // create input DStream from RDD queue\n+    Queue<JavaRDD<WindowedValue<byte[]>>> queueRDD = new LinkedBlockingQueue<>();", "originalCommit": "b3fba9cb53d5c0e1e5950d5065736966af25b97a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkwNTI1OQ==", "url": "https://github.com/apache/beam/pull/12157#discussion_r470905259", "bodyText": "Nit: it isn't immediately clear what is true here (without the help of an IDE). Use an inline comment:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    context.getStreamingContext().queueStream(queueRDD, true);\n          \n          \n            \n                    context.getStreamingContext().queueStream(queueRDD, true /* oneAtATime */);", "author": "ibzib", "createdAt": "2020-08-14T23:36:12Z", "path": "runners/spark/src/main/java/org/apache/beam/runners/spark/translation/SparkStreamingPortablePipelineTranslator.java", "diffHunk": "@@ -0,0 +1,393 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.spark.translation;\n+\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.createOutputMap;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getWindowingStrategy;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+import org.apache.beam.runners.core.construction.PTransformTranslation;\n+import org.apache.beam.runners.core.construction.graph.ExecutableStage;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode.PTransformNode;\n+import org.apache.beam.runners.core.construction.graph.QueryablePipeline;\n+import org.apache.beam.runners.fnexecution.provisioning.JobInfo;\n+import org.apache.beam.runners.fnexecution.wire.WireCoders;\n+import org.apache.beam.runners.spark.SparkPipelineOptions;\n+import org.apache.beam.runners.spark.coders.CoderHelpers;\n+import org.apache.beam.runners.spark.metrics.MetricsAccumulator;\n+import org.apache.beam.runners.spark.stateful.SparkGroupAlsoByWindowViaWindowSet;\n+import org.apache.beam.runners.spark.translation.streaming.UnboundedDataset;\n+import org.apache.beam.runners.spark.util.GlobalWatermarkHolder;\n+import org.apache.beam.runners.spark.util.SparkCompat;\n+import org.apache.beam.sdk.coders.ByteArrayCoder;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.transforms.join.RawUnionValue;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.GlobalWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.util.WindowedValue;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.TimestampedValue;\n+import org.apache.beam.sdk.values.WindowingStrategy;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.BiMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+import org.apache.spark.api.java.JavaRDD;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.broadcast.Broadcast;\n+import org.apache.spark.storage.StorageLevel;\n+import org.apache.spark.streaming.api.java.JavaDStream;\n+import org.apache.spark.streaming.api.java.JavaInputDStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import scala.Tuple2;\n+\n+/** Translates a bounded portable pipeline into a Spark job. */\n+public class SparkStreamingPortablePipelineTranslator\n+    implements SparkPortablePipelineTranslator<SparkStreamingTranslationContext> {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(SparkStreamingPortablePipelineTranslator.class);\n+\n+  private final ImmutableMap<String, PTransformTranslator> urnToTransformTranslator;\n+\n+  interface PTransformTranslator {\n+\n+    /** Translates transformNode from Beam into the Spark context. */\n+    void translate(\n+        PTransformNode transformNode,\n+        RunnerApi.Pipeline pipeline,\n+        SparkStreamingTranslationContext context);\n+  }\n+\n+  @Override\n+  public Set<String> knownUrns() {\n+    return urnToTransformTranslator.keySet();\n+  }\n+\n+  public SparkStreamingPortablePipelineTranslator() {\n+    ImmutableMap.Builder<String, PTransformTranslator> translatorMap = ImmutableMap.builder();\n+    translatorMap.put(\n+        PTransformTranslation.IMPULSE_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateImpulse);\n+    translatorMap.put(\n+        PTransformTranslation.GROUP_BY_KEY_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateGroupByKey);\n+    translatorMap.put(\n+        ExecutableStage.URN, SparkStreamingPortablePipelineTranslator::translateExecutableStage);\n+    translatorMap.put(\n+        PTransformTranslation.FLATTEN_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateFlatten);\n+    translatorMap.put(\n+        PTransformTranslation.RESHUFFLE_URN,\n+        SparkStreamingPortablePipelineTranslator::translateReshuffle);\n+    this.urnToTransformTranslator = translatorMap.build();\n+  }\n+\n+  /** Translates pipeline from Beam into the Spark context. */\n+  @Override\n+  public void translate(\n+      final RunnerApi.Pipeline pipeline, SparkStreamingTranslationContext context) {\n+    QueryablePipeline p =\n+        QueryablePipeline.forTransforms(\n+            pipeline.getRootTransformIdsList(), pipeline.getComponents());\n+    for (PipelineNode.PTransformNode transformNode : p.getTopologicallyOrderedTransforms()) {\n+      urnToTransformTranslator\n+          .getOrDefault(\n+              transformNode.getTransform().getSpec().getUrn(),\n+              SparkStreamingPortablePipelineTranslator::urnNotFound)\n+          .translate(transformNode, pipeline, context);\n+    }\n+  }\n+\n+  private static void urnNotFound(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    throw new IllegalArgumentException(\n+        String.format(\n+            \"Transform %s has unknown URN %s\",\n+            transformNode.getId(), transformNode.getTransform().getSpec().getUrn()));\n+  }\n+\n+  private static void translateImpulse(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+\n+    TimestampedValue<byte[]> tsValue = TimestampedValue.atMinimumTimestamp(new byte[0]);\n+    Iterable<TimestampedValue<byte[]>> timestampedValues = Collections.singletonList(tsValue);\n+    Iterable<WindowedValue<byte[]>> windowedValues =\n+        StreamSupport.stream(timestampedValues.spliterator(), false)\n+            .map(\n+                timestampedValue ->\n+                    WindowedValue.of(\n+                        timestampedValue.getValue(),\n+                        timestampedValue.getTimestamp(),\n+                        GlobalWindow.INSTANCE,\n+                        PaneInfo.NO_FIRING))\n+            .collect(Collectors.toList());\n+\n+    ByteArrayCoder coder = ByteArrayCoder.of();\n+\n+    WindowedValue.FullWindowedValueCoder<byte[]> windowCoder =\n+        WindowedValue.FullWindowedValueCoder.of(coder, GlobalWindow.Coder.INSTANCE);\n+    JavaRDD<WindowedValue<byte[]>> emptyRDD =\n+        context\n+            .getSparkContext()\n+            .parallelize(CoderHelpers.toByteArrays(windowedValues, windowCoder))\n+            .map(CoderHelpers.fromByteFunction(windowCoder));\n+\n+    // create input DStream from RDD queue\n+    Queue<JavaRDD<WindowedValue<byte[]>>> queueRDD = new LinkedBlockingQueue<>();\n+    queueRDD.offer(emptyRDD);\n+    JavaInputDStream<WindowedValue<byte[]>> emptyStream =\n+        context.getStreamingContext().queueStream(queueRDD, true);", "originalCommit": "b3fba9cb53d5c0e1e5950d5065736966af25b97a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkwNTg5Mw==", "url": "https://github.com/apache/beam/pull/12157#discussion_r470905893", "bodyText": "This block needs a comment (though maybe this should wait until we figure out what is going on in failing tests).", "author": "ibzib", "createdAt": "2020-08-14T23:39:27Z", "path": "runners/spark/src/main/java/org/apache/beam/runners/spark/translation/SparkStreamingPortablePipelineTranslator.java", "diffHunk": "@@ -0,0 +1,393 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.spark.translation;\n+\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.createOutputMap;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getWindowingStrategy;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+import org.apache.beam.runners.core.construction.PTransformTranslation;\n+import org.apache.beam.runners.core.construction.graph.ExecutableStage;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode.PTransformNode;\n+import org.apache.beam.runners.core.construction.graph.QueryablePipeline;\n+import org.apache.beam.runners.fnexecution.provisioning.JobInfo;\n+import org.apache.beam.runners.fnexecution.wire.WireCoders;\n+import org.apache.beam.runners.spark.SparkPipelineOptions;\n+import org.apache.beam.runners.spark.coders.CoderHelpers;\n+import org.apache.beam.runners.spark.metrics.MetricsAccumulator;\n+import org.apache.beam.runners.spark.stateful.SparkGroupAlsoByWindowViaWindowSet;\n+import org.apache.beam.runners.spark.translation.streaming.UnboundedDataset;\n+import org.apache.beam.runners.spark.util.GlobalWatermarkHolder;\n+import org.apache.beam.runners.spark.util.SparkCompat;\n+import org.apache.beam.sdk.coders.ByteArrayCoder;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.transforms.join.RawUnionValue;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.GlobalWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.util.WindowedValue;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.TimestampedValue;\n+import org.apache.beam.sdk.values.WindowingStrategy;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.BiMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+import org.apache.spark.api.java.JavaRDD;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.broadcast.Broadcast;\n+import org.apache.spark.storage.StorageLevel;\n+import org.apache.spark.streaming.api.java.JavaDStream;\n+import org.apache.spark.streaming.api.java.JavaInputDStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import scala.Tuple2;\n+\n+/** Translates a bounded portable pipeline into a Spark job. */\n+public class SparkStreamingPortablePipelineTranslator\n+    implements SparkPortablePipelineTranslator<SparkStreamingTranslationContext> {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(SparkStreamingPortablePipelineTranslator.class);\n+\n+  private final ImmutableMap<String, PTransformTranslator> urnToTransformTranslator;\n+\n+  interface PTransformTranslator {\n+\n+    /** Translates transformNode from Beam into the Spark context. */\n+    void translate(\n+        PTransformNode transformNode,\n+        RunnerApi.Pipeline pipeline,\n+        SparkStreamingTranslationContext context);\n+  }\n+\n+  @Override\n+  public Set<String> knownUrns() {\n+    return urnToTransformTranslator.keySet();\n+  }\n+\n+  public SparkStreamingPortablePipelineTranslator() {\n+    ImmutableMap.Builder<String, PTransformTranslator> translatorMap = ImmutableMap.builder();\n+    translatorMap.put(\n+        PTransformTranslation.IMPULSE_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateImpulse);\n+    translatorMap.put(\n+        PTransformTranslation.GROUP_BY_KEY_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateGroupByKey);\n+    translatorMap.put(\n+        ExecutableStage.URN, SparkStreamingPortablePipelineTranslator::translateExecutableStage);\n+    translatorMap.put(\n+        PTransformTranslation.FLATTEN_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateFlatten);\n+    translatorMap.put(\n+        PTransformTranslation.RESHUFFLE_URN,\n+        SparkStreamingPortablePipelineTranslator::translateReshuffle);\n+    this.urnToTransformTranslator = translatorMap.build();\n+  }\n+\n+  /** Translates pipeline from Beam into the Spark context. */\n+  @Override\n+  public void translate(\n+      final RunnerApi.Pipeline pipeline, SparkStreamingTranslationContext context) {\n+    QueryablePipeline p =\n+        QueryablePipeline.forTransforms(\n+            pipeline.getRootTransformIdsList(), pipeline.getComponents());\n+    for (PipelineNode.PTransformNode transformNode : p.getTopologicallyOrderedTransforms()) {\n+      urnToTransformTranslator\n+          .getOrDefault(\n+              transformNode.getTransform().getSpec().getUrn(),\n+              SparkStreamingPortablePipelineTranslator::urnNotFound)\n+          .translate(transformNode, pipeline, context);\n+    }\n+  }\n+\n+  private static void urnNotFound(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    throw new IllegalArgumentException(\n+        String.format(\n+            \"Transform %s has unknown URN %s\",\n+            transformNode.getId(), transformNode.getTransform().getSpec().getUrn()));\n+  }\n+\n+  private static void translateImpulse(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+\n+    TimestampedValue<byte[]> tsValue = TimestampedValue.atMinimumTimestamp(new byte[0]);\n+    Iterable<TimestampedValue<byte[]>> timestampedValues = Collections.singletonList(tsValue);\n+    Iterable<WindowedValue<byte[]>> windowedValues =\n+        StreamSupport.stream(timestampedValues.spliterator(), false)\n+            .map(\n+                timestampedValue ->\n+                    WindowedValue.of(\n+                        timestampedValue.getValue(),\n+                        timestampedValue.getTimestamp(),\n+                        GlobalWindow.INSTANCE,\n+                        PaneInfo.NO_FIRING))\n+            .collect(Collectors.toList());\n+\n+    ByteArrayCoder coder = ByteArrayCoder.of();\n+\n+    WindowedValue.FullWindowedValueCoder<byte[]> windowCoder =\n+        WindowedValue.FullWindowedValueCoder.of(coder, GlobalWindow.Coder.INSTANCE);\n+    JavaRDD<WindowedValue<byte[]>> emptyRDD =\n+        context\n+            .getSparkContext()\n+            .parallelize(CoderHelpers.toByteArrays(windowedValues, windowCoder))\n+            .map(CoderHelpers.fromByteFunction(windowCoder));\n+\n+    // create input DStream from RDD queue\n+    Queue<JavaRDD<WindowedValue<byte[]>>> queueRDD = new LinkedBlockingQueue<>();\n+    queueRDD.offer(emptyRDD);\n+    JavaInputDStream<WindowedValue<byte[]>> emptyStream =\n+        context.getStreamingContext().queueStream(queueRDD, true);\n+\n+    UnboundedDataset<byte[]> output =\n+        new UnboundedDataset<>(\n+            emptyStream, Collections.singletonList(emptyStream.inputDStream().id()));\n+\n+    GlobalWatermarkHolder.SparkWatermarks sparkWatermark =", "originalCommit": "b3fba9cb53d5c0e1e5950d5065736966af25b97a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkwNjkxNA==", "url": "https://github.com/apache/beam/pull/12157#discussion_r470906914", "bodyText": "Create a JIRA and point to it here:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // TODO: handle side inputs?\n          \n          \n            \n                // TODO(BEAM-XXXXX): handle side inputs.", "author": "ibzib", "createdAt": "2020-08-14T23:45:07Z", "path": "runners/spark/src/main/java/org/apache/beam/runners/spark/translation/SparkStreamingPortablePipelineTranslator.java", "diffHunk": "@@ -0,0 +1,393 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.spark.translation;\n+\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.createOutputMap;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getWindowingStrategy;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+import org.apache.beam.runners.core.construction.PTransformTranslation;\n+import org.apache.beam.runners.core.construction.graph.ExecutableStage;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode.PTransformNode;\n+import org.apache.beam.runners.core.construction.graph.QueryablePipeline;\n+import org.apache.beam.runners.fnexecution.provisioning.JobInfo;\n+import org.apache.beam.runners.fnexecution.wire.WireCoders;\n+import org.apache.beam.runners.spark.SparkPipelineOptions;\n+import org.apache.beam.runners.spark.coders.CoderHelpers;\n+import org.apache.beam.runners.spark.metrics.MetricsAccumulator;\n+import org.apache.beam.runners.spark.stateful.SparkGroupAlsoByWindowViaWindowSet;\n+import org.apache.beam.runners.spark.translation.streaming.UnboundedDataset;\n+import org.apache.beam.runners.spark.util.GlobalWatermarkHolder;\n+import org.apache.beam.runners.spark.util.SparkCompat;\n+import org.apache.beam.sdk.coders.ByteArrayCoder;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.transforms.join.RawUnionValue;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.GlobalWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.util.WindowedValue;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.TimestampedValue;\n+import org.apache.beam.sdk.values.WindowingStrategy;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.BiMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+import org.apache.spark.api.java.JavaRDD;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.broadcast.Broadcast;\n+import org.apache.spark.storage.StorageLevel;\n+import org.apache.spark.streaming.api.java.JavaDStream;\n+import org.apache.spark.streaming.api.java.JavaInputDStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import scala.Tuple2;\n+\n+/** Translates a bounded portable pipeline into a Spark job. */\n+public class SparkStreamingPortablePipelineTranslator\n+    implements SparkPortablePipelineTranslator<SparkStreamingTranslationContext> {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(SparkStreamingPortablePipelineTranslator.class);\n+\n+  private final ImmutableMap<String, PTransformTranslator> urnToTransformTranslator;\n+\n+  interface PTransformTranslator {\n+\n+    /** Translates transformNode from Beam into the Spark context. */\n+    void translate(\n+        PTransformNode transformNode,\n+        RunnerApi.Pipeline pipeline,\n+        SparkStreamingTranslationContext context);\n+  }\n+\n+  @Override\n+  public Set<String> knownUrns() {\n+    return urnToTransformTranslator.keySet();\n+  }\n+\n+  public SparkStreamingPortablePipelineTranslator() {\n+    ImmutableMap.Builder<String, PTransformTranslator> translatorMap = ImmutableMap.builder();\n+    translatorMap.put(\n+        PTransformTranslation.IMPULSE_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateImpulse);\n+    translatorMap.put(\n+        PTransformTranslation.GROUP_BY_KEY_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateGroupByKey);\n+    translatorMap.put(\n+        ExecutableStage.URN, SparkStreamingPortablePipelineTranslator::translateExecutableStage);\n+    translatorMap.put(\n+        PTransformTranslation.FLATTEN_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateFlatten);\n+    translatorMap.put(\n+        PTransformTranslation.RESHUFFLE_URN,\n+        SparkStreamingPortablePipelineTranslator::translateReshuffle);\n+    this.urnToTransformTranslator = translatorMap.build();\n+  }\n+\n+  /** Translates pipeline from Beam into the Spark context. */\n+  @Override\n+  public void translate(\n+      final RunnerApi.Pipeline pipeline, SparkStreamingTranslationContext context) {\n+    QueryablePipeline p =\n+        QueryablePipeline.forTransforms(\n+            pipeline.getRootTransformIdsList(), pipeline.getComponents());\n+    for (PipelineNode.PTransformNode transformNode : p.getTopologicallyOrderedTransforms()) {\n+      urnToTransformTranslator\n+          .getOrDefault(\n+              transformNode.getTransform().getSpec().getUrn(),\n+              SparkStreamingPortablePipelineTranslator::urnNotFound)\n+          .translate(transformNode, pipeline, context);\n+    }\n+  }\n+\n+  private static void urnNotFound(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    throw new IllegalArgumentException(\n+        String.format(\n+            \"Transform %s has unknown URN %s\",\n+            transformNode.getId(), transformNode.getTransform().getSpec().getUrn()));\n+  }\n+\n+  private static void translateImpulse(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+\n+    TimestampedValue<byte[]> tsValue = TimestampedValue.atMinimumTimestamp(new byte[0]);\n+    Iterable<TimestampedValue<byte[]>> timestampedValues = Collections.singletonList(tsValue);\n+    Iterable<WindowedValue<byte[]>> windowedValues =\n+        StreamSupport.stream(timestampedValues.spliterator(), false)\n+            .map(\n+                timestampedValue ->\n+                    WindowedValue.of(\n+                        timestampedValue.getValue(),\n+                        timestampedValue.getTimestamp(),\n+                        GlobalWindow.INSTANCE,\n+                        PaneInfo.NO_FIRING))\n+            .collect(Collectors.toList());\n+\n+    ByteArrayCoder coder = ByteArrayCoder.of();\n+\n+    WindowedValue.FullWindowedValueCoder<byte[]> windowCoder =\n+        WindowedValue.FullWindowedValueCoder.of(coder, GlobalWindow.Coder.INSTANCE);\n+    JavaRDD<WindowedValue<byte[]>> emptyRDD =\n+        context\n+            .getSparkContext()\n+            .parallelize(CoderHelpers.toByteArrays(windowedValues, windowCoder))\n+            .map(CoderHelpers.fromByteFunction(windowCoder));\n+\n+    // create input DStream from RDD queue\n+    Queue<JavaRDD<WindowedValue<byte[]>>> queueRDD = new LinkedBlockingQueue<>();\n+    queueRDD.offer(emptyRDD);\n+    JavaInputDStream<WindowedValue<byte[]>> emptyStream =\n+        context.getStreamingContext().queueStream(queueRDD, true);\n+\n+    UnboundedDataset<byte[]> output =\n+        new UnboundedDataset<>(\n+            emptyStream, Collections.singletonList(emptyStream.inputDStream().id()));\n+\n+    GlobalWatermarkHolder.SparkWatermarks sparkWatermark =\n+        new GlobalWatermarkHolder.SparkWatermarks(\n+            GlobalWindow.INSTANCE.maxTimestamp(),\n+            BoundedWindow.TIMESTAMP_MAX_VALUE,\n+            context.getFirstTimestamp());\n+    GlobalWatermarkHolder.add(output.getStreamSources().get(0), sparkWatermark);\n+\n+    context.pushDataset(getOutputId(transformNode), output);\n+  }\n+\n+  private static <K, V> void translateGroupByKey(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    RunnerApi.Components components = pipeline.getComponents();\n+    String inputId = getInputId(transformNode);\n+    UnboundedDataset<KV<K, V>> inputDataset =\n+        (UnboundedDataset<KV<K, V>>) context.popDataset(inputId);\n+    List<Integer> streamSources = inputDataset.getStreamSources();\n+    JavaDStream<WindowedValue<KV<K, V>>> dStream = inputDataset.getDStream();\n+    WindowedValue.WindowedValueCoder<KV<K, V>> inputCoder =\n+        getWindowedValueCoder(inputId, components);\n+    KvCoder<K, V> inputKvCoder = (KvCoder<K, V>) inputCoder.getValueCoder();\n+    Coder<K> inputKeyCoder = inputKvCoder.getKeyCoder();\n+    Coder<V> inputValueCoder = inputKvCoder.getValueCoder();\n+    final WindowingStrategy windowingStrategy = getWindowingStrategy(inputId, components);\n+    final WindowFn<Object, BoundedWindow> windowFn = windowingStrategy.getWindowFn();\n+    final WindowedValue.WindowedValueCoder<V> wvCoder =\n+        WindowedValue.FullWindowedValueCoder.of(inputValueCoder, windowFn.windowCoder());\n+\n+    JavaDStream<WindowedValue<KV<K, Iterable<V>>>> outStream =\n+        SparkGroupAlsoByWindowViaWindowSet.groupByKeyAndWindow(\n+            dStream,\n+            inputKeyCoder,\n+            wvCoder,\n+            windowingStrategy,\n+            context.getSerializableOptions(),\n+            streamSources,\n+            transformNode.getId());\n+\n+    context.pushDataset(\n+        getOutputId(transformNode), new UnboundedDataset<>(outStream, streamSources));\n+  }\n+\n+  private static <InputT, OutputT, SideInputT> void translateExecutableStage(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    RunnerApi.ExecutableStagePayload stagePayload;\n+    try {\n+      stagePayload =\n+          RunnerApi.ExecutableStagePayload.parseFrom(\n+              transformNode.getTransform().getSpec().getPayload());\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n+\n+    String inputPCollectionId = stagePayload.getInput();\n+    UnboundedDataset<InputT> inputDataset =\n+        (UnboundedDataset<InputT>) context.popDataset(inputPCollectionId);\n+    List<Integer> streamSources = inputDataset.getStreamSources();\n+    JavaDStream<WindowedValue<InputT>> inputDStream = inputDataset.getDStream();\n+    Map<String, String> outputs = transformNode.getTransform().getOutputsMap();\n+    BiMap<String, Integer> outputMap = createOutputMap(outputs.values());\n+\n+    RunnerApi.Components components = pipeline.getComponents();\n+    Coder windowCoder =\n+        getWindowingStrategy(inputPCollectionId, components).getWindowFn().windowCoder();\n+\n+    // TODO: handle side inputs?", "originalCommit": "b3fba9cb53d5c0e1e5950d5065736966af25b97a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkwNzUyNg==", "url": "https://github.com/apache/beam/pull/12157#discussion_r470907526", "bodyText": "Nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // pop dataset to mark RDD as used\n          \n          \n            \n                // pop dataset to mark DStream as used", "author": "ibzib", "createdAt": "2020-08-14T23:47:18Z", "path": "runners/spark/src/main/java/org/apache/beam/runners/spark/translation/SparkStreamingPortablePipelineTranslator.java", "diffHunk": "@@ -0,0 +1,393 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.spark.translation;\n+\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.createOutputMap;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getWindowingStrategy;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+import org.apache.beam.runners.core.construction.PTransformTranslation;\n+import org.apache.beam.runners.core.construction.graph.ExecutableStage;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode.PTransformNode;\n+import org.apache.beam.runners.core.construction.graph.QueryablePipeline;\n+import org.apache.beam.runners.fnexecution.provisioning.JobInfo;\n+import org.apache.beam.runners.fnexecution.wire.WireCoders;\n+import org.apache.beam.runners.spark.SparkPipelineOptions;\n+import org.apache.beam.runners.spark.coders.CoderHelpers;\n+import org.apache.beam.runners.spark.metrics.MetricsAccumulator;\n+import org.apache.beam.runners.spark.stateful.SparkGroupAlsoByWindowViaWindowSet;\n+import org.apache.beam.runners.spark.translation.streaming.UnboundedDataset;\n+import org.apache.beam.runners.spark.util.GlobalWatermarkHolder;\n+import org.apache.beam.runners.spark.util.SparkCompat;\n+import org.apache.beam.sdk.coders.ByteArrayCoder;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.transforms.join.RawUnionValue;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.GlobalWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.util.WindowedValue;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.TimestampedValue;\n+import org.apache.beam.sdk.values.WindowingStrategy;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.BiMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+import org.apache.spark.api.java.JavaRDD;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.broadcast.Broadcast;\n+import org.apache.spark.storage.StorageLevel;\n+import org.apache.spark.streaming.api.java.JavaDStream;\n+import org.apache.spark.streaming.api.java.JavaInputDStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import scala.Tuple2;\n+\n+/** Translates a bounded portable pipeline into a Spark job. */\n+public class SparkStreamingPortablePipelineTranslator\n+    implements SparkPortablePipelineTranslator<SparkStreamingTranslationContext> {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(SparkStreamingPortablePipelineTranslator.class);\n+\n+  private final ImmutableMap<String, PTransformTranslator> urnToTransformTranslator;\n+\n+  interface PTransformTranslator {\n+\n+    /** Translates transformNode from Beam into the Spark context. */\n+    void translate(\n+        PTransformNode transformNode,\n+        RunnerApi.Pipeline pipeline,\n+        SparkStreamingTranslationContext context);\n+  }\n+\n+  @Override\n+  public Set<String> knownUrns() {\n+    return urnToTransformTranslator.keySet();\n+  }\n+\n+  public SparkStreamingPortablePipelineTranslator() {\n+    ImmutableMap.Builder<String, PTransformTranslator> translatorMap = ImmutableMap.builder();\n+    translatorMap.put(\n+        PTransformTranslation.IMPULSE_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateImpulse);\n+    translatorMap.put(\n+        PTransformTranslation.GROUP_BY_KEY_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateGroupByKey);\n+    translatorMap.put(\n+        ExecutableStage.URN, SparkStreamingPortablePipelineTranslator::translateExecutableStage);\n+    translatorMap.put(\n+        PTransformTranslation.FLATTEN_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateFlatten);\n+    translatorMap.put(\n+        PTransformTranslation.RESHUFFLE_URN,\n+        SparkStreamingPortablePipelineTranslator::translateReshuffle);\n+    this.urnToTransformTranslator = translatorMap.build();\n+  }\n+\n+  /** Translates pipeline from Beam into the Spark context. */\n+  @Override\n+  public void translate(\n+      final RunnerApi.Pipeline pipeline, SparkStreamingTranslationContext context) {\n+    QueryablePipeline p =\n+        QueryablePipeline.forTransforms(\n+            pipeline.getRootTransformIdsList(), pipeline.getComponents());\n+    for (PipelineNode.PTransformNode transformNode : p.getTopologicallyOrderedTransforms()) {\n+      urnToTransformTranslator\n+          .getOrDefault(\n+              transformNode.getTransform().getSpec().getUrn(),\n+              SparkStreamingPortablePipelineTranslator::urnNotFound)\n+          .translate(transformNode, pipeline, context);\n+    }\n+  }\n+\n+  private static void urnNotFound(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    throw new IllegalArgumentException(\n+        String.format(\n+            \"Transform %s has unknown URN %s\",\n+            transformNode.getId(), transformNode.getTransform().getSpec().getUrn()));\n+  }\n+\n+  private static void translateImpulse(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+\n+    TimestampedValue<byte[]> tsValue = TimestampedValue.atMinimumTimestamp(new byte[0]);\n+    Iterable<TimestampedValue<byte[]>> timestampedValues = Collections.singletonList(tsValue);\n+    Iterable<WindowedValue<byte[]>> windowedValues =\n+        StreamSupport.stream(timestampedValues.spliterator(), false)\n+            .map(\n+                timestampedValue ->\n+                    WindowedValue.of(\n+                        timestampedValue.getValue(),\n+                        timestampedValue.getTimestamp(),\n+                        GlobalWindow.INSTANCE,\n+                        PaneInfo.NO_FIRING))\n+            .collect(Collectors.toList());\n+\n+    ByteArrayCoder coder = ByteArrayCoder.of();\n+\n+    WindowedValue.FullWindowedValueCoder<byte[]> windowCoder =\n+        WindowedValue.FullWindowedValueCoder.of(coder, GlobalWindow.Coder.INSTANCE);\n+    JavaRDD<WindowedValue<byte[]>> emptyRDD =\n+        context\n+            .getSparkContext()\n+            .parallelize(CoderHelpers.toByteArrays(windowedValues, windowCoder))\n+            .map(CoderHelpers.fromByteFunction(windowCoder));\n+\n+    // create input DStream from RDD queue\n+    Queue<JavaRDD<WindowedValue<byte[]>>> queueRDD = new LinkedBlockingQueue<>();\n+    queueRDD.offer(emptyRDD);\n+    JavaInputDStream<WindowedValue<byte[]>> emptyStream =\n+        context.getStreamingContext().queueStream(queueRDD, true);\n+\n+    UnboundedDataset<byte[]> output =\n+        new UnboundedDataset<>(\n+            emptyStream, Collections.singletonList(emptyStream.inputDStream().id()));\n+\n+    GlobalWatermarkHolder.SparkWatermarks sparkWatermark =\n+        new GlobalWatermarkHolder.SparkWatermarks(\n+            GlobalWindow.INSTANCE.maxTimestamp(),\n+            BoundedWindow.TIMESTAMP_MAX_VALUE,\n+            context.getFirstTimestamp());\n+    GlobalWatermarkHolder.add(output.getStreamSources().get(0), sparkWatermark);\n+\n+    context.pushDataset(getOutputId(transformNode), output);\n+  }\n+\n+  private static <K, V> void translateGroupByKey(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    RunnerApi.Components components = pipeline.getComponents();\n+    String inputId = getInputId(transformNode);\n+    UnboundedDataset<KV<K, V>> inputDataset =\n+        (UnboundedDataset<KV<K, V>>) context.popDataset(inputId);\n+    List<Integer> streamSources = inputDataset.getStreamSources();\n+    JavaDStream<WindowedValue<KV<K, V>>> dStream = inputDataset.getDStream();\n+    WindowedValue.WindowedValueCoder<KV<K, V>> inputCoder =\n+        getWindowedValueCoder(inputId, components);\n+    KvCoder<K, V> inputKvCoder = (KvCoder<K, V>) inputCoder.getValueCoder();\n+    Coder<K> inputKeyCoder = inputKvCoder.getKeyCoder();\n+    Coder<V> inputValueCoder = inputKvCoder.getValueCoder();\n+    final WindowingStrategy windowingStrategy = getWindowingStrategy(inputId, components);\n+    final WindowFn<Object, BoundedWindow> windowFn = windowingStrategy.getWindowFn();\n+    final WindowedValue.WindowedValueCoder<V> wvCoder =\n+        WindowedValue.FullWindowedValueCoder.of(inputValueCoder, windowFn.windowCoder());\n+\n+    JavaDStream<WindowedValue<KV<K, Iterable<V>>>> outStream =\n+        SparkGroupAlsoByWindowViaWindowSet.groupByKeyAndWindow(\n+            dStream,\n+            inputKeyCoder,\n+            wvCoder,\n+            windowingStrategy,\n+            context.getSerializableOptions(),\n+            streamSources,\n+            transformNode.getId());\n+\n+    context.pushDataset(\n+        getOutputId(transformNode), new UnboundedDataset<>(outStream, streamSources));\n+  }\n+\n+  private static <InputT, OutputT, SideInputT> void translateExecutableStage(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    RunnerApi.ExecutableStagePayload stagePayload;\n+    try {\n+      stagePayload =\n+          RunnerApi.ExecutableStagePayload.parseFrom(\n+              transformNode.getTransform().getSpec().getPayload());\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n+\n+    String inputPCollectionId = stagePayload.getInput();\n+    UnboundedDataset<InputT> inputDataset =\n+        (UnboundedDataset<InputT>) context.popDataset(inputPCollectionId);\n+    List<Integer> streamSources = inputDataset.getStreamSources();\n+    JavaDStream<WindowedValue<InputT>> inputDStream = inputDataset.getDStream();\n+    Map<String, String> outputs = transformNode.getTransform().getOutputsMap();\n+    BiMap<String, Integer> outputMap = createOutputMap(outputs.values());\n+\n+    RunnerApi.Components components = pipeline.getComponents();\n+    Coder windowCoder =\n+        getWindowingStrategy(inputPCollectionId, components).getWindowFn().windowCoder();\n+\n+    // TODO: handle side inputs?\n+    ImmutableMap<\n+            String, Tuple2<Broadcast<List<byte[]>>, WindowedValue.WindowedValueCoder<SideInputT>>>\n+        broadcastVariables = ImmutableMap.copyOf(new HashMap<>());\n+\n+    SparkExecutableStageFunction<InputT, SideInputT> function =\n+        new SparkExecutableStageFunction<>(\n+            stagePayload,\n+            context.jobInfo,\n+            outputMap,\n+            SparkExecutableStageContextFactory.getInstance(),\n+            broadcastVariables,\n+            MetricsAccumulator.getInstance(),\n+            windowCoder);\n+    JavaDStream<RawUnionValue> staged = inputDStream.mapPartitions(function);\n+\n+    String intermediateId = getExecutableStageIntermediateId(transformNode);\n+    context.pushDataset(\n+        intermediateId,\n+        new Dataset() {\n+          @Override\n+          public void cache(String storageLevel, Coder<?> coder) {\n+            StorageLevel level = StorageLevel.fromString(storageLevel);\n+            staged.persist(level);\n+          }\n+\n+          @Override\n+          public void action() {\n+            // Empty function to force computation of RDD.\n+            staged.foreachRDD(TranslationUtils.emptyVoidFunction());\n+          }\n+\n+          @Override\n+          public void setName(String name) {\n+            // ignore\n+          }\n+        });\n+    // pop dataset to mark RDD as used", "originalCommit": "b3fba9cb53d5c0e1e5950d5065736966af25b97a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxMTM3Mg==", "url": "https://github.com/apache/beam/pull/12157#discussion_r470911372", "bodyText": "We should move these common methods into a shared class like PipelineTranslatorUtils.", "author": "ibzib", "createdAt": "2020-08-15T00:09:47Z", "path": "runners/spark/src/main/java/org/apache/beam/runners/spark/translation/SparkStreamingPortablePipelineTranslator.java", "diffHunk": "@@ -0,0 +1,393 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.spark.translation;\n+\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.createOutputMap;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getWindowingStrategy;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+import org.apache.beam.runners.core.construction.PTransformTranslation;\n+import org.apache.beam.runners.core.construction.graph.ExecutableStage;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode.PTransformNode;\n+import org.apache.beam.runners.core.construction.graph.QueryablePipeline;\n+import org.apache.beam.runners.fnexecution.provisioning.JobInfo;\n+import org.apache.beam.runners.fnexecution.wire.WireCoders;\n+import org.apache.beam.runners.spark.SparkPipelineOptions;\n+import org.apache.beam.runners.spark.coders.CoderHelpers;\n+import org.apache.beam.runners.spark.metrics.MetricsAccumulator;\n+import org.apache.beam.runners.spark.stateful.SparkGroupAlsoByWindowViaWindowSet;\n+import org.apache.beam.runners.spark.translation.streaming.UnboundedDataset;\n+import org.apache.beam.runners.spark.util.GlobalWatermarkHolder;\n+import org.apache.beam.runners.spark.util.SparkCompat;\n+import org.apache.beam.sdk.coders.ByteArrayCoder;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.transforms.join.RawUnionValue;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.GlobalWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.util.WindowedValue;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.TimestampedValue;\n+import org.apache.beam.sdk.values.WindowingStrategy;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.BiMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+import org.apache.spark.api.java.JavaRDD;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.broadcast.Broadcast;\n+import org.apache.spark.storage.StorageLevel;\n+import org.apache.spark.streaming.api.java.JavaDStream;\n+import org.apache.spark.streaming.api.java.JavaInputDStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import scala.Tuple2;\n+\n+/** Translates a bounded portable pipeline into a Spark job. */\n+public class SparkStreamingPortablePipelineTranslator\n+    implements SparkPortablePipelineTranslator<SparkStreamingTranslationContext> {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(SparkStreamingPortablePipelineTranslator.class);\n+\n+  private final ImmutableMap<String, PTransformTranslator> urnToTransformTranslator;\n+\n+  interface PTransformTranslator {\n+\n+    /** Translates transformNode from Beam into the Spark context. */\n+    void translate(\n+        PTransformNode transformNode,\n+        RunnerApi.Pipeline pipeline,\n+        SparkStreamingTranslationContext context);\n+  }\n+\n+  @Override\n+  public Set<String> knownUrns() {\n+    return urnToTransformTranslator.keySet();\n+  }\n+\n+  public SparkStreamingPortablePipelineTranslator() {\n+    ImmutableMap.Builder<String, PTransformTranslator> translatorMap = ImmutableMap.builder();\n+    translatorMap.put(\n+        PTransformTranslation.IMPULSE_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateImpulse);\n+    translatorMap.put(\n+        PTransformTranslation.GROUP_BY_KEY_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateGroupByKey);\n+    translatorMap.put(\n+        ExecutableStage.URN, SparkStreamingPortablePipelineTranslator::translateExecutableStage);\n+    translatorMap.put(\n+        PTransformTranslation.FLATTEN_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateFlatten);\n+    translatorMap.put(\n+        PTransformTranslation.RESHUFFLE_URN,\n+        SparkStreamingPortablePipelineTranslator::translateReshuffle);\n+    this.urnToTransformTranslator = translatorMap.build();\n+  }\n+\n+  /** Translates pipeline from Beam into the Spark context. */\n+  @Override\n+  public void translate(\n+      final RunnerApi.Pipeline pipeline, SparkStreamingTranslationContext context) {\n+    QueryablePipeline p =\n+        QueryablePipeline.forTransforms(\n+            pipeline.getRootTransformIdsList(), pipeline.getComponents());\n+    for (PipelineNode.PTransformNode transformNode : p.getTopologicallyOrderedTransforms()) {\n+      urnToTransformTranslator\n+          .getOrDefault(\n+              transformNode.getTransform().getSpec().getUrn(),\n+              SparkStreamingPortablePipelineTranslator::urnNotFound)\n+          .translate(transformNode, pipeline, context);\n+    }\n+  }\n+\n+  private static void urnNotFound(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    throw new IllegalArgumentException(\n+        String.format(\n+            \"Transform %s has unknown URN %s\",\n+            transformNode.getId(), transformNode.getTransform().getSpec().getUrn()));\n+  }\n+\n+  private static void translateImpulse(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+\n+    TimestampedValue<byte[]> tsValue = TimestampedValue.atMinimumTimestamp(new byte[0]);\n+    Iterable<TimestampedValue<byte[]>> timestampedValues = Collections.singletonList(tsValue);\n+    Iterable<WindowedValue<byte[]>> windowedValues =\n+        StreamSupport.stream(timestampedValues.spliterator(), false)\n+            .map(\n+                timestampedValue ->\n+                    WindowedValue.of(\n+                        timestampedValue.getValue(),\n+                        timestampedValue.getTimestamp(),\n+                        GlobalWindow.INSTANCE,\n+                        PaneInfo.NO_FIRING))\n+            .collect(Collectors.toList());\n+\n+    ByteArrayCoder coder = ByteArrayCoder.of();\n+\n+    WindowedValue.FullWindowedValueCoder<byte[]> windowCoder =\n+        WindowedValue.FullWindowedValueCoder.of(coder, GlobalWindow.Coder.INSTANCE);\n+    JavaRDD<WindowedValue<byte[]>> emptyRDD =\n+        context\n+            .getSparkContext()\n+            .parallelize(CoderHelpers.toByteArrays(windowedValues, windowCoder))\n+            .map(CoderHelpers.fromByteFunction(windowCoder));\n+\n+    // create input DStream from RDD queue\n+    Queue<JavaRDD<WindowedValue<byte[]>>> queueRDD = new LinkedBlockingQueue<>();\n+    queueRDD.offer(emptyRDD);\n+    JavaInputDStream<WindowedValue<byte[]>> emptyStream =\n+        context.getStreamingContext().queueStream(queueRDD, true);\n+\n+    UnboundedDataset<byte[]> output =\n+        new UnboundedDataset<>(\n+            emptyStream, Collections.singletonList(emptyStream.inputDStream().id()));\n+\n+    GlobalWatermarkHolder.SparkWatermarks sparkWatermark =\n+        new GlobalWatermarkHolder.SparkWatermarks(\n+            GlobalWindow.INSTANCE.maxTimestamp(),\n+            BoundedWindow.TIMESTAMP_MAX_VALUE,\n+            context.getFirstTimestamp());\n+    GlobalWatermarkHolder.add(output.getStreamSources().get(0), sparkWatermark);\n+\n+    context.pushDataset(getOutputId(transformNode), output);\n+  }\n+\n+  private static <K, V> void translateGroupByKey(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    RunnerApi.Components components = pipeline.getComponents();\n+    String inputId = getInputId(transformNode);\n+    UnboundedDataset<KV<K, V>> inputDataset =\n+        (UnboundedDataset<KV<K, V>>) context.popDataset(inputId);\n+    List<Integer> streamSources = inputDataset.getStreamSources();\n+    JavaDStream<WindowedValue<KV<K, V>>> dStream = inputDataset.getDStream();\n+    WindowedValue.WindowedValueCoder<KV<K, V>> inputCoder =\n+        getWindowedValueCoder(inputId, components);\n+    KvCoder<K, V> inputKvCoder = (KvCoder<K, V>) inputCoder.getValueCoder();\n+    Coder<K> inputKeyCoder = inputKvCoder.getKeyCoder();\n+    Coder<V> inputValueCoder = inputKvCoder.getValueCoder();\n+    final WindowingStrategy windowingStrategy = getWindowingStrategy(inputId, components);\n+    final WindowFn<Object, BoundedWindow> windowFn = windowingStrategy.getWindowFn();\n+    final WindowedValue.WindowedValueCoder<V> wvCoder =\n+        WindowedValue.FullWindowedValueCoder.of(inputValueCoder, windowFn.windowCoder());\n+\n+    JavaDStream<WindowedValue<KV<K, Iterable<V>>>> outStream =\n+        SparkGroupAlsoByWindowViaWindowSet.groupByKeyAndWindow(\n+            dStream,\n+            inputKeyCoder,\n+            wvCoder,\n+            windowingStrategy,\n+            context.getSerializableOptions(),\n+            streamSources,\n+            transformNode.getId());\n+\n+    context.pushDataset(\n+        getOutputId(transformNode), new UnboundedDataset<>(outStream, streamSources));\n+  }\n+\n+  private static <InputT, OutputT, SideInputT> void translateExecutableStage(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    RunnerApi.ExecutableStagePayload stagePayload;\n+    try {\n+      stagePayload =\n+          RunnerApi.ExecutableStagePayload.parseFrom(\n+              transformNode.getTransform().getSpec().getPayload());\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n+\n+    String inputPCollectionId = stagePayload.getInput();\n+    UnboundedDataset<InputT> inputDataset =\n+        (UnboundedDataset<InputT>) context.popDataset(inputPCollectionId);\n+    List<Integer> streamSources = inputDataset.getStreamSources();\n+    JavaDStream<WindowedValue<InputT>> inputDStream = inputDataset.getDStream();\n+    Map<String, String> outputs = transformNode.getTransform().getOutputsMap();\n+    BiMap<String, Integer> outputMap = createOutputMap(outputs.values());\n+\n+    RunnerApi.Components components = pipeline.getComponents();\n+    Coder windowCoder =\n+        getWindowingStrategy(inputPCollectionId, components).getWindowFn().windowCoder();\n+\n+    // TODO: handle side inputs?\n+    ImmutableMap<\n+            String, Tuple2<Broadcast<List<byte[]>>, WindowedValue.WindowedValueCoder<SideInputT>>>\n+        broadcastVariables = ImmutableMap.copyOf(new HashMap<>());\n+\n+    SparkExecutableStageFunction<InputT, SideInputT> function =\n+        new SparkExecutableStageFunction<>(\n+            stagePayload,\n+            context.jobInfo,\n+            outputMap,\n+            SparkExecutableStageContextFactory.getInstance(),\n+            broadcastVariables,\n+            MetricsAccumulator.getInstance(),\n+            windowCoder);\n+    JavaDStream<RawUnionValue> staged = inputDStream.mapPartitions(function);\n+\n+    String intermediateId = getExecutableStageIntermediateId(transformNode);\n+    context.pushDataset(\n+        intermediateId,\n+        new Dataset() {\n+          @Override\n+          public void cache(String storageLevel, Coder<?> coder) {\n+            StorageLevel level = StorageLevel.fromString(storageLevel);\n+            staged.persist(level);\n+          }\n+\n+          @Override\n+          public void action() {\n+            // Empty function to force computation of RDD.\n+            staged.foreachRDD(TranslationUtils.emptyVoidFunction());\n+          }\n+\n+          @Override\n+          public void setName(String name) {\n+            // ignore\n+          }\n+        });\n+    // pop dataset to mark RDD as used\n+    context.popDataset(intermediateId);\n+\n+    for (String outputId : outputs.values()) {\n+      JavaDStream<WindowedValue<OutputT>> outStream =\n+          staged.flatMap(new SparkExecutableStageExtractionFunction<>(outputMap.get(outputId)));\n+      context.pushDataset(outputId, new UnboundedDataset<>(outStream, streamSources));\n+    }\n+\n+    if (outputs.isEmpty()) {\n+      // Add sink to ensure all outputs are computed\n+      JavaDStream<WindowedValue<OutputT>> outStream =\n+          staged.flatMap((rawUnionValue) -> Collections.emptyIterator());\n+      context.pushDataset(\n+          String.format(\"EmptyOutputSink_%d\", context.nextSinkId()),\n+          new UnboundedDataset<>(outStream, streamSources));\n+    }\n+  }\n+\n+  private static <T> void translateFlatten(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    Map<String, String> inputsMap = transformNode.getTransform().getInputsMap();\n+    JavaDStream<WindowedValue<T>> unifiedStreams;\n+    final List<Integer> streamSources = new ArrayList<>();\n+\n+    if (inputsMap.isEmpty()) {\n+      Queue<JavaRDD<WindowedValue<T>>> q = new LinkedBlockingQueue<>();\n+      q.offer(context.getSparkContext().emptyRDD());\n+      unifiedStreams = context.getStreamingContext().queueStream(q);\n+    } else {\n+      final List<JavaDStream<WindowedValue<T>>> dStreams = new ArrayList<>();\n+      for (String inputId : inputsMap.values()) {\n+        Dataset dataset = context.popDataset(inputId);\n+        if (dataset instanceof UnboundedDataset) {\n+          UnboundedDataset<T> unboundedDataset = (UnboundedDataset<T>) dataset;\n+          streamSources.addAll(unboundedDataset.getStreamSources());\n+          dStreams.add(unboundedDataset.getDStream());\n+        } else {\n+          // create a single RDD stream.\n+          Queue<JavaRDD<WindowedValue<T>>> q = new LinkedBlockingQueue<>();\n+          q.offer(((BoundedDataset) dataset).getRDD());\n+          // TODO: this is not recoverable from checkpoint!\n+          JavaDStream<WindowedValue<T>> dStream = context.getStreamingContext().queueStream(q);\n+          dStreams.add(dStream);\n+        }\n+      }\n+      // Unify streams into a single stream.\n+      unifiedStreams = SparkCompat.joinStreams(context.getStreamingContext(), dStreams);\n+    }\n+\n+    context.pushDataset(\n+        getOutputId(transformNode), new UnboundedDataset<>(unifiedStreams, streamSources));\n+  }\n+\n+  private static <T> void translateReshuffle(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    String inputId = getInputId(transformNode);\n+    UnboundedDataset<T> inputDataset = (UnboundedDataset<T>) context.popDataset(inputId);\n+    List<Integer> streamSources = inputDataset.getStreamSources();\n+    JavaDStream<WindowedValue<T>> dStream = inputDataset.getDStream();\n+    WindowedValue.WindowedValueCoder<T> coder =\n+        getWindowedValueCoder(inputId, pipeline.getComponents());\n+\n+    JavaDStream<WindowedValue<T>> reshuffledStream =\n+        dStream.transform(rdd -> GroupCombineFunctions.reshuffle(rdd, coder));\n+\n+    context.pushDataset(\n+        getOutputId(transformNode), new UnboundedDataset<>(reshuffledStream, streamSources));\n+  }\n+\n+  private static String getInputId(PTransformNode transformNode) {\n+    return Iterables.getOnlyElement(transformNode.getTransform().getInputsMap().values());\n+  }\n+\n+  private static String getOutputId(PTransformNode transformNode) {\n+    return Iterables.getOnlyElement(transformNode.getTransform().getOutputsMap().values());\n+  }\n+\n+  private static String getExecutableStageIntermediateId(PTransformNode transformNode) {\n+    return transformNode.getId();\n+  }\n+\n+  private static <T> WindowedValue.WindowedValueCoder<T> getWindowedValueCoder(", "originalCommit": "b3fba9cb53d5c0e1e5950d5065736966af25b97a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxMTY0Mw==", "url": "https://github.com/apache/beam/pull/12157#discussion_r470911643", "bodyText": "Nit: this comment is technically accurate, but it should mention streaming.", "author": "ibzib", "createdAt": "2020-08-15T00:11:24Z", "path": "runners/spark/src/main/java/org/apache/beam/runners/spark/translation/SparkStreamingTranslationContext.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.spark.translation;\n+\n+import org.apache.beam.runners.fnexecution.provisioning.JobInfo;\n+import org.apache.beam.runners.spark.SparkPipelineOptions;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.streaming.Duration;\n+import org.apache.spark.streaming.api.java.JavaStreamingContext;\n+import org.joda.time.Instant;\n+\n+/**\n+ * Translation context used to lazily store Spark data sets during portable pipeline translation and", "originalCommit": "b3fba9cb53d5c0e1e5950d5065736966af25b97a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxMTgzMw==", "url": "https://github.com/apache/beam/pull/12157#discussion_r470911833", "bodyText": "Make these methods package-private.", "author": "ibzib", "createdAt": "2020-08-15T00:12:28Z", "path": "runners/spark/src/main/java/org/apache/beam/runners/spark/translation/SparkStreamingTranslationContext.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.spark.translation;\n+\n+import org.apache.beam.runners.fnexecution.provisioning.JobInfo;\n+import org.apache.beam.runners.spark.SparkPipelineOptions;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.streaming.Duration;\n+import org.apache.spark.streaming.api.java.JavaStreamingContext;\n+import org.joda.time.Instant;\n+\n+/**\n+ * Translation context used to lazily store Spark data sets during portable pipeline translation and\n+ * compute them after translation.\n+ */\n+public class SparkStreamingTranslationContext extends SparkTranslationContext {\n+  private final JavaStreamingContext streamingContext;\n+  private final Instant firstTimestamp;\n+\n+  public SparkStreamingTranslationContext(\n+      JavaSparkContext jsc, SparkPipelineOptions options, JobInfo jobInfo) {\n+    super(jsc, options, jobInfo);\n+    Duration batchDuration = new Duration(options.getBatchIntervalMillis());\n+    this.streamingContext = new JavaStreamingContext(jsc, batchDuration);\n+    this.firstTimestamp = new Instant();\n+  }\n+\n+  public JavaStreamingContext getStreamingContext() {", "originalCommit": "b3fba9cb53d5c0e1e5950d5065736966af25b97a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE5ODA2NQ==", "url": "https://github.com/apache/beam/pull/12157#discussion_r471198065", "bodyText": "I'm not sure I can do so, since the SparkPipelineRunner calls this method but is outside of the translation package?", "author": "annaqin418", "createdAt": "2020-08-17T02:11:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxMTgzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY2MzA0OQ==", "url": "https://github.com/apache/beam/pull/12157#discussion_r471663049", "bodyText": "Ah okay. Disregard then.", "author": "ibzib", "createdAt": "2020-08-17T17:56:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxMTgzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxMTk5Ng==", "url": "https://github.com/apache/beam/pull/12157#discussion_r470911996", "bodyText": "Nit: firstTimestamp sounds a little strange here, since it's the only timestamp around. Maybe initialTimestamp or something?", "author": "ibzib", "createdAt": "2020-08-15T00:13:36Z", "path": "runners/spark/src/main/java/org/apache/beam/runners/spark/translation/SparkStreamingTranslationContext.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.spark.translation;\n+\n+import org.apache.beam.runners.fnexecution.provisioning.JobInfo;\n+import org.apache.beam.runners.spark.SparkPipelineOptions;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.streaming.Duration;\n+import org.apache.spark.streaming.api.java.JavaStreamingContext;\n+import org.joda.time.Instant;\n+\n+/**\n+ * Translation context used to lazily store Spark data sets during portable pipeline translation and\n+ * compute them after translation.\n+ */\n+public class SparkStreamingTranslationContext extends SparkTranslationContext {\n+  private final JavaStreamingContext streamingContext;\n+  private final Instant firstTimestamp;", "originalCommit": "b3fba9cb53d5c0e1e5950d5065736966af25b97a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxMjU1Mw==", "url": "https://github.com/apache/beam/pull/12157#discussion_r470912553", "bodyText": "Maybe we don't have to do it in this PR, but I'd be in favor of removing this test. It's kind of pointless to test a constant.", "author": "ibzib", "createdAt": "2020-08-15T00:17:11Z", "path": "runners/spark/src/test/java/org/apache/beam/runners/spark/SparkRunnerRegistrarTest.java", "diffHunk": "@@ -37,7 +37,10 @@\n   @Test\n   public void testOptions() {\n     assertEquals(\n-        ImmutableList.of(SparkPipelineOptions.class, SparkStructuredStreamingPipelineOptions.class),\n+        ImmutableList.of(", "originalCommit": "b3fba9cb53d5c0e1e5950d5065736966af25b97a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxMzI5MA==", "url": "https://github.com/apache/beam/pull/12157#discussion_r470913290", "bodyText": "If possible, exclude test categories instead of test classes.", "author": "ibzib", "createdAt": "2020-08-15T00:22:30Z", "path": "runners/spark/job-server/build.gradle", "diffHunk": "@@ -82,53 +82,116 @@ runShadow {\n     jvmArgs += [\"-Dorg.slf4j.simpleLogger.defaultLogLevel=${project.property('logLevel')}\"]\n }\n \n-def portableValidatesRunnerTask(String name) {\n-  createPortableValidatesRunnerTask(\n-    name: \"validatesPortableRunner${name}\",\n-    jobServerDriver: \"org.apache.beam.runners.spark.SparkJobServerDriver\",\n-    jobServerConfig: \"--job-host=localhost,--job-port=0,--artifact-port=0,--expansion-port=0\",\n-    testClasspathConfiguration: configurations.validatesPortableRunner,\n-    numParallelTests: 4,\n-    environment: BeamModulePlugin.PortableValidatesRunnerConfiguration.Environment.EMBEDDED,\n-    systemProperties: [\n-      \"beam.spark.test.reuseSparkContext\": \"false\",\n-      \"spark.ui.enabled\": \"false\",\n-      \"spark.ui.showConsoleProgress\": \"false\",\n-    ],\n-    testCategories: {\n-      includeCategories 'org.apache.beam.sdk.testing.ValidatesRunner'\n-      excludeCategories 'org.apache.beam.sdk.testing.FlattenWithHeterogeneousCoders'\n-      excludeCategories 'org.apache.beam.sdk.testing.LargeKeys$Above100MB'\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesCommittedMetrics'\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesCustomWindowMerging'\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesFailureMessage'\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesGaugeMetrics'\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesParDoLifecycle'\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesMapState'\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesSetState'\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesOrderedListState'\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesTimerMap'\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesKeyInParDo'\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesOnWindowExpiration'\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesTestStream'\n-      //SplitableDoFnTests\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesBoundedSplittableParDo'\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesSplittableParDoWithWindowedSideInputs'\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesUnboundedSplittableParDo'\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesStrictTimerOrdering'\n-      excludeCategories 'org.apache.beam.sdk.testing.UsesBundleFinalizer'\n-    },\n-    testFilter: {\n-      // TODO(BEAM-10094)\n-      excludeTestsMatching 'org.apache.beam.sdk.transforms.FlattenTest.testFlattenWithDifferentInputAndOutputCoders2'\n-    },\n-  )\n+def portableValidatesRunnerTask(String name, Boolean streaming) {\n+  def pipelineOptions = []\n+  if (streaming) {\n+    pipelineOptions += \"--streaming\"\n+    pipelineOptions += \"--timeout=20000\"\n+    // exclude unsupported tests\n+    createPortableValidatesRunnerTask(\n+            name: \"validatesPortableRunner${name}\",\n+            jobServerDriver: \"org.apache.beam.runners.spark.SparkJobServerDriver\",\n+            jobServerConfig: \"--job-host=localhost,--job-port=0,--artifact-port=0,--expansion-port=0\",\n+            testClasspathConfiguration: configurations.validatesPortableRunner,\n+            numParallelTests: 4,\n+            pipelineOpts: pipelineOptions,\n+            environment: BeamModulePlugin.PortableValidatesRunnerConfiguration.Environment.EMBEDDED,\n+            systemProperties: [\n+                    \"beam.spark.test.reuseSparkContext\": \"false\",\n+                    \"spark.ui.enabled\": \"false\",\n+                    \"spark.ui.showConsoleProgress\": \"false\",\n+            ],\n+            testCategories: {\n+              includeCategories 'org.apache.beam.sdk.testing.ValidatesRunner'\n+              excludeCategories 'org.apache.beam.sdk.testing.FlattenWithHeterogeneousCoders'\n+              excludeCategories 'org.apache.beam.sdk.testing.LargeKeys$Above100MB'\n+              excludeCategories 'org.apache.beam.sdk.testing.UsesCommittedMetrics'\n+              excludeCategories 'org.apache.beam.sdk.testing.UsesCustomWindowMerging'\n+              excludeCategories 'org.apache.beam.sdk.testing.UsesFailureMessage'\n+              excludeCategories 'org.apache.beam.sdk.testing.UsesGaugeMetrics'\n+              excludeCategories 'org.apache.beam.sdk.testing.UsesParDoLifecycle'\n+              excludeCategories 'org.apache.beam.sdk.testing.UsesMapState'\n+              excludeCategories 'org.apache.beam.sdk.testing.UsesSetState'\n+              excludeCategories 'org.apache.beam.sdk.testing.UsesOrderedListState'\n+              excludeCategories 'org.apache.beam.sdk.testing.UsesTimerMap'\n+              excludeCategories 'org.apache.beam.sdk.testing.UsesKeyInParDo'\n+              excludeCategories 'org.apache.beam.sdk.testing.UsesOnWindowExpiration'\n+              excludeCategories 'org.apache.beam.sdk.testing.UsesTestStream'\n+              //SplitableDoFnTests\n+              excludeCategories 'org.apache.beam.sdk.testing.UsesBoundedSplittableParDo'\n+              excludeCategories 'org.apache.beam.sdk.testing.UsesSplittableParDoWithWindowedSideInputs'\n+              excludeCategories 'org.apache.beam.sdk.testing.UsesUnboundedSplittableParDo'\n+              excludeCategories 'org.apache.beam.sdk.testing.UsesStrictTimerOrdering'\n+              excludeCategories 'org.apache.beam.sdk.testing.UsesBundleFinalizer'\n+              // Tests to exclude when streaming\n+              excludeCategories 'org.apache.beam.sdk.testing.UsesSideInputs'\n+            },\n+            testFilter: {\n+              // TODO(BEAM-10094)\n+              excludeTestsMatching 'org.apache.beam.sdk.transforms.FlattenTest.testFlattenWithDifferentInputAndOutputCoders2'\n+              // Tests to exclude when streaming\n+              excludeTestsMatching 'org.apache.beam.sdk.transforms.CombineTest'\n+              excludeTestsMatching 'org.apache.beam.sdk.transforms.CombineFnsTest'\n+              excludeTestsMatching 'org.apache.beam.sdk.transforms.ParDoTest$MultipleInputsAndOutputTests'\n+              excludeTestsMatching 'org.apache.beam.sdk.transforms.ParDoTest$StateCoderInferenceTests'\n+              excludeTestsMatching 'org.apache.beam.sdk.transforms.ParDoTest$StateTests'\n+              excludeTestsMatching 'org.apache.beam.sdk.transforms.ParDoTest$TimerTests'", "originalCommit": "b3fba9cb53d5c0e1e5950d5065736966af25b97a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e13a378c1d372b3099f4cc13a6984e16245462f4", "url": "https://github.com/apache/beam/commit/e13a378c1d372b3099f4cc13a6984e16245462f4", "message": "spotlessApply", "committedDate": "2020-08-17T22:32:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTgzODc5Nw==", "url": "https://github.com/apache/beam/pull/12157#discussion_r471838797", "bodyText": "Link JIRAs for side input, state, and timer support.", "author": "ibzib", "createdAt": "2020-08-18T00:02:43Z", "path": "runners/spark/job-server/build.gradle", "diffHunk": "@@ -82,20 +82,60 @@ runShadow {\n     jvmArgs += [\"-Dorg.slf4j.simpleLogger.defaultLogLevel=${project.property('logLevel')}\"]\n }\n \n-def portableValidatesRunnerTask(String name) {\n-  createPortableValidatesRunnerTask(\n-    name: \"validatesPortableRunner${name}\",\n-    jobServerDriver: \"org.apache.beam.runners.spark.SparkJobServerDriver\",\n-    jobServerConfig: \"--job-host=localhost,--job-port=0,--artifact-port=0,--expansion-port=0\",\n-    testClasspathConfiguration: configurations.validatesPortableRunner,\n-    numParallelTests: 4,\n-    environment: BeamModulePlugin.PortableValidatesRunnerConfiguration.Environment.EMBEDDED,\n-    systemProperties: [\n-      \"beam.spark.test.reuseSparkContext\": \"false\",\n-      \"spark.ui.enabled\": \"false\",\n-      \"spark.ui.showConsoleProgress\": \"false\",\n-    ],\n-    testCategories: {\n+def portableValidatesRunnerTask(String name, Boolean streaming) {\n+  def pipelineOptions = []\n+  def testCategories\n+  def testFilter\n+\n+  if (streaming) {\n+    pipelineOptions += \"--streaming\"\n+    pipelineOptions += \"--streamingTimeoutMs=20000\"\n+\n+    testCategories = {\n+      includeCategories 'org.apache.beam.sdk.testing.ValidatesRunner'\n+      excludeCategories 'org.apache.beam.sdk.testing.FlattenWithHeterogeneousCoders'\n+      excludeCategories 'org.apache.beam.sdk.testing.LargeKeys$Above100MB'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesCommittedMetrics'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesCustomWindowMerging'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesFailureMessage'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesGaugeMetrics'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesParDoLifecycle'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesMapState'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesSetState'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesOrderedListState'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesTimerMap'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesKeyInParDo'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesOnWindowExpiration'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesTestStream'\n+      // SplittableDoFnTests\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesBoundedSplittableParDo'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesSplittableParDoWithWindowedSideInputs'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesUnboundedSplittableParDo'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesStrictTimerOrdering'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesBundleFinalizer'\n+      // Currently unsupported in portable streaming\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesSideInputs'", "originalCommit": "e13a378c1d372b3099f4cc13a6984e16245462f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "de3819877b2f80c4b138f503377802966566c20d", "url": "https://github.com/apache/beam/commit/de3819877b2f80c4b138f503377802966566c20d", "message": "checkstyle", "committedDate": "2020-08-20T22:31:54Z", "type": "forcePushed"}, {"oid": "c08ae930843714cf4ea17edf502d4b08f11915d3", "url": "https://github.com/apache/beam/commit/c08ae930843714cf4ea17edf502d4b08f11915d3", "message": "checkstyle\n\nspotless", "committedDate": "2020-08-20T22:35:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMxNjgzMw==", "url": "https://github.com/apache/beam/pull/12157#discussion_r474316833", "bodyText": "We should file a JIRA for all these (since they are conspicuously all windowing related).", "author": "ibzib", "createdAt": "2020-08-20T22:59:05Z", "path": "runners/spark/job-server/build.gradle", "diffHunk": "@@ -82,20 +82,68 @@ runShadow {\n     jvmArgs += [\"-Dorg.slf4j.simpleLogger.defaultLogLevel=${project.property('logLevel')}\"]\n }\n \n-def portableValidatesRunnerTask(String name) {\n-  createPortableValidatesRunnerTask(\n-    name: \"validatesPortableRunner${name}\",\n-    jobServerDriver: \"org.apache.beam.runners.spark.SparkJobServerDriver\",\n-    jobServerConfig: \"--job-host=localhost,--job-port=0,--artifact-port=0,--expansion-port=0\",\n-    testClasspathConfiguration: configurations.validatesPortableRunner,\n-    numParallelTests: 4,\n-    environment: BeamModulePlugin.PortableValidatesRunnerConfiguration.Environment.EMBEDDED,\n-    systemProperties: [\n-      \"beam.spark.test.reuseSparkContext\": \"false\",\n-      \"spark.ui.enabled\": \"false\",\n-      \"spark.ui.showConsoleProgress\": \"false\",\n-    ],\n-    testCategories: {\n+def portableValidatesRunnerTask(String name, Boolean streaming) {\n+  def pipelineOptions = []\n+  def testCategories\n+  def testFilter\n+\n+  if (streaming) {\n+    pipelineOptions += \"--streaming\"\n+    pipelineOptions += \"--streamingTimeoutMs=30000\"\n+\n+    testCategories = {\n+      includeCategories 'org.apache.beam.sdk.testing.ValidatesRunner'\n+      excludeCategories 'org.apache.beam.sdk.testing.FlattenWithHeterogeneousCoders'\n+      excludeCategories 'org.apache.beam.sdk.testing.LargeKeys$Above100MB'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesCommittedMetrics'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesCustomWindowMerging'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesFailureMessage'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesGaugeMetrics'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesParDoLifecycle'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesMapState'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesSetState'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesOrderedListState'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesTimerMap'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesKeyInParDo'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesOnWindowExpiration'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesTestStream'\n+      // SplittableDoFnTests\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesBoundedSplittableParDo'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesSplittableParDoWithWindowedSideInputs'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesUnboundedSplittableParDo'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesStrictTimerOrdering'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesBundleFinalizer'\n+      // Currently unsupported in portable streaming:\n+      // TODO (BEAM-10712)\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesSideInputs'\n+      // TODO (BEAM-10754)\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesStatefulParDo'\n+      // TODO (BEAM-10755)\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesTimersInParDo'\n+    }\n+\n+    testFilter = {\n+      // TODO(BEAM-10094)\n+      excludeTestsMatching 'org.apache.beam.sdk.transforms.FlattenTest.testFlattenWithDifferentInputAndOutputCoders2'\n+      // Currently unsupported in portable streaming:", "originalCommit": "c08ae930843714cf4ea17edf502d4b08f11915d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMxODA1Nw==", "url": "https://github.com/apache/beam/pull/12157#discussion_r474318057", "bodyText": "This should've been there before, but the jira for this (BEAM-7222) should be linked.", "author": "ibzib", "createdAt": "2020-08-20T23:02:52Z", "path": "runners/spark/job-server/build.gradle", "diffHunk": "@@ -82,20 +82,68 @@ runShadow {\n     jvmArgs += [\"-Dorg.slf4j.simpleLogger.defaultLogLevel=${project.property('logLevel')}\"]\n }\n \n-def portableValidatesRunnerTask(String name) {\n-  createPortableValidatesRunnerTask(\n-    name: \"validatesPortableRunner${name}\",\n-    jobServerDriver: \"org.apache.beam.runners.spark.SparkJobServerDriver\",\n-    jobServerConfig: \"--job-host=localhost,--job-port=0,--artifact-port=0,--expansion-port=0\",\n-    testClasspathConfiguration: configurations.validatesPortableRunner,\n-    numParallelTests: 4,\n-    environment: BeamModulePlugin.PortableValidatesRunnerConfiguration.Environment.EMBEDDED,\n-    systemProperties: [\n-      \"beam.spark.test.reuseSparkContext\": \"false\",\n-      \"spark.ui.enabled\": \"false\",\n-      \"spark.ui.showConsoleProgress\": \"false\",\n-    ],\n-    testCategories: {\n+def portableValidatesRunnerTask(String name, Boolean streaming) {\n+  def pipelineOptions = []\n+  def testCategories\n+  def testFilter\n+\n+  if (streaming) {\n+    pipelineOptions += \"--streaming\"\n+    pipelineOptions += \"--streamingTimeoutMs=30000\"\n+\n+    testCategories = {\n+      includeCategories 'org.apache.beam.sdk.testing.ValidatesRunner'\n+      excludeCategories 'org.apache.beam.sdk.testing.FlattenWithHeterogeneousCoders'\n+      excludeCategories 'org.apache.beam.sdk.testing.LargeKeys$Above100MB'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesCommittedMetrics'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesCustomWindowMerging'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesFailureMessage'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesGaugeMetrics'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesParDoLifecycle'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesMapState'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesSetState'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesOrderedListState'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesTimerMap'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesKeyInParDo'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesOnWindowExpiration'\n+      excludeCategories 'org.apache.beam.sdk.testing.UsesTestStream'\n+      // SplittableDoFnTests", "originalCommit": "c08ae930843714cf4ea17edf502d4b08f11915d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyMDM3NQ==", "url": "https://github.com/apache/beam/pull/12157#discussion_r474320375", "bodyText": "Collections.emptyIterator() has the same behavior, but is more concise.", "author": "ibzib", "createdAt": "2020-08-20T23:10:22Z", "path": "runners/spark/src/main/java/org/apache/beam/runners/spark/translation/SparkExecutableStageFunction.java", "diffHunk": "@@ -118,6 +118,12 @@\n \n   @Override\n   public Iterator<RawUnionValue> call(Iterator<WindowedValue<InputT>> inputs) throws Exception {\n+    // Do not call processElements if there are no inputs\n+    // Otherwise, this may cause validation errors (e.g. ParDoTest)\n+    if (!inputs.hasNext()) {\n+      return new ConcurrentLinkedQueue<RawUnionValue>().iterator();", "originalCommit": "c08ae930843714cf4ea17edf502d4b08f11915d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyMTMzNg==", "url": "https://github.com/apache/beam/pull/12157#discussion_r474321336", "bodyText": "\"streaming and portable\" should be \"streaming and batch.\"", "author": "ibzib", "createdAt": "2020-08-20T23:13:49Z", "path": "runners/spark/src/main/java/org/apache/beam/runners/spark/translation/SparkPortablePipelineTranslator.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.spark.translation;\n+\n+import java.util.Set;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+import org.apache.beam.runners.fnexecution.provisioning.JobInfo;\n+import org.apache.beam.runners.spark.SparkPipelineOptions;\n+import org.apache.spark.api.java.JavaSparkContext;\n+\n+/**\n+ * Interface for portable Spark translators. This allows for a uniform invocation pattern for\n+ * pipeline translation between streaming and portable runners.", "originalCommit": "c08ae930843714cf4ea17edf502d4b08f11915d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMyMzE5NA==", "url": "https://github.com/apache/beam/pull/12157#discussion_r474323194", "bodyText": "Nit: \"dummy\" sounds a lot like mocks or stubs, which are technical terms that describe the implementation of test objects. This list isn't a \"dummy\" in that sense; it's a real list, albeit one constructed for test purposes.\ntl;dr rename this inputs.", "author": "ibzib", "createdAt": "2020-08-20T23:20:05Z", "path": "runners/spark/src/test/java/org/apache/beam/runners/spark/translation/SparkExecutableStageFunctionTest.java", "diffHunk": "@@ -101,7 +104,9 @@ public void setUpMocks() throws Exception {\n   public void sdkErrorsSurfaceOnClose() throws Exception {\n     SparkExecutableStageFunction<Integer, ?> function = getFunction(Collections.emptyMap());\n     doThrow(new Exception()).when(remoteBundle).close();\n-    function.call(Collections.emptyIterator());\n+    List<WindowedValue<Integer>> dummyList = new ArrayList<>();", "originalCommit": "c08ae930843714cf4ea17edf502d4b08f11915d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ca707137600be0b54bc95e378546620a7ce77887", "url": "https://github.com/apache/beam/commit/ca707137600be0b54bc95e378546620a7ce77887", "message": "addressing comments", "committedDate": "2020-08-21T02:20:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM4NzkxMg==", "url": "https://github.com/apache/beam/pull/12157#discussion_r474387912", "bodyText": "It seems it'd be easier construct this with\nCollections.singletonList(\n    WindowedValue.of(...));\n\nrather than use an intermediate timestamped value list.", "author": "robertwb", "createdAt": "2020-08-21T03:27:13Z", "path": "runners/spark/src/main/java/org/apache/beam/runners/spark/translation/SparkStreamingPortablePipelineTranslator.java", "diffHunk": "@@ -0,0 +1,366 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.spark.translation;\n+\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.createOutputMap;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getExecutableStageIntermediateId;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getInputId;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getOutputId;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getWindowedValueCoder;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getWindowingStrategy;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+import org.apache.beam.runners.core.construction.PTransformTranslation;\n+import org.apache.beam.runners.core.construction.graph.ExecutableStage;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode.PTransformNode;\n+import org.apache.beam.runners.core.construction.graph.QueryablePipeline;\n+import org.apache.beam.runners.fnexecution.provisioning.JobInfo;\n+import org.apache.beam.runners.spark.SparkPipelineOptions;\n+import org.apache.beam.runners.spark.coders.CoderHelpers;\n+import org.apache.beam.runners.spark.metrics.MetricsAccumulator;\n+import org.apache.beam.runners.spark.stateful.SparkGroupAlsoByWindowViaWindowSet;\n+import org.apache.beam.runners.spark.translation.streaming.UnboundedDataset;\n+import org.apache.beam.runners.spark.util.GlobalWatermarkHolder;\n+import org.apache.beam.runners.spark.util.SparkCompat;\n+import org.apache.beam.sdk.coders.ByteArrayCoder;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.transforms.join.RawUnionValue;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.GlobalWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.util.WindowedValue;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.TimestampedValue;\n+import org.apache.beam.sdk.values.WindowingStrategy;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.BiMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.spark.api.java.JavaRDD;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.broadcast.Broadcast;\n+import org.apache.spark.storage.StorageLevel;\n+import org.apache.spark.streaming.api.java.JavaDStream;\n+import org.apache.spark.streaming.api.java.JavaInputDStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import scala.Tuple2;\n+\n+/** Translates an unbounded portable pipeline into a Spark job. */\n+public class SparkStreamingPortablePipelineTranslator\n+    implements SparkPortablePipelineTranslator<SparkStreamingTranslationContext> {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(SparkStreamingPortablePipelineTranslator.class);\n+\n+  private final ImmutableMap<String, PTransformTranslator> urnToTransformTranslator;\n+\n+  interface PTransformTranslator {\n+\n+    /** Translates transformNode from Beam into the Spark context. */\n+    void translate(\n+        PTransformNode transformNode,\n+        RunnerApi.Pipeline pipeline,\n+        SparkStreamingTranslationContext context);\n+  }\n+\n+  @Override\n+  public Set<String> knownUrns() {\n+    return urnToTransformTranslator.keySet();\n+  }\n+\n+  public SparkStreamingPortablePipelineTranslator() {\n+    ImmutableMap.Builder<String, PTransformTranslator> translatorMap = ImmutableMap.builder();\n+    translatorMap.put(\n+        PTransformTranslation.IMPULSE_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateImpulse);\n+    translatorMap.put(\n+        PTransformTranslation.GROUP_BY_KEY_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateGroupByKey);\n+    translatorMap.put(\n+        ExecutableStage.URN, SparkStreamingPortablePipelineTranslator::translateExecutableStage);\n+    translatorMap.put(\n+        PTransformTranslation.FLATTEN_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateFlatten);\n+    translatorMap.put(\n+        PTransformTranslation.RESHUFFLE_URN,\n+        SparkStreamingPortablePipelineTranslator::translateReshuffle);\n+    this.urnToTransformTranslator = translatorMap.build();\n+  }\n+\n+  /** Translates pipeline from Beam into the Spark context. */\n+  @Override\n+  public void translate(\n+      final RunnerApi.Pipeline pipeline, SparkStreamingTranslationContext context) {\n+    QueryablePipeline p =\n+        QueryablePipeline.forTransforms(\n+            pipeline.getRootTransformIdsList(), pipeline.getComponents());\n+    for (PipelineNode.PTransformNode transformNode : p.getTopologicallyOrderedTransforms()) {\n+      urnToTransformTranslator\n+          .getOrDefault(\n+              transformNode.getTransform().getSpec().getUrn(),\n+              SparkStreamingPortablePipelineTranslator::urnNotFound)\n+          .translate(transformNode, pipeline, context);\n+    }\n+  }\n+\n+  private static void urnNotFound(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    throw new IllegalArgumentException(\n+        String.format(\n+            \"Transform %s has unknown URN %s\",\n+            transformNode.getId(), transformNode.getTransform().getSpec().getUrn()));\n+  }\n+\n+  private static void translateImpulse(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+\n+    TimestampedValue<byte[]> tsValue = TimestampedValue.atMinimumTimestamp(new byte[0]);\n+    Iterable<TimestampedValue<byte[]>> timestampedValues = Collections.singletonList(tsValue);\n+    Iterable<WindowedValue<byte[]>> windowedValues =", "originalCommit": "ca707137600be0b54bc95e378546620a7ce77887", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM4ODM1Ng==", "url": "https://github.com/apache/beam/pull/12157#discussion_r474388356", "bodyText": "You could even defer the singleton iterable wrapping to here and use windowCoder.encode(...) rather than use CoderHelpers.toByteArrays.", "author": "robertwb", "createdAt": "2020-08-21T03:29:15Z", "path": "runners/spark/src/main/java/org/apache/beam/runners/spark/translation/SparkStreamingPortablePipelineTranslator.java", "diffHunk": "@@ -0,0 +1,366 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.spark.translation;\n+\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.createOutputMap;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getExecutableStageIntermediateId;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getInputId;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getOutputId;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getWindowedValueCoder;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getWindowingStrategy;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+import org.apache.beam.runners.core.construction.PTransformTranslation;\n+import org.apache.beam.runners.core.construction.graph.ExecutableStage;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode.PTransformNode;\n+import org.apache.beam.runners.core.construction.graph.QueryablePipeline;\n+import org.apache.beam.runners.fnexecution.provisioning.JobInfo;\n+import org.apache.beam.runners.spark.SparkPipelineOptions;\n+import org.apache.beam.runners.spark.coders.CoderHelpers;\n+import org.apache.beam.runners.spark.metrics.MetricsAccumulator;\n+import org.apache.beam.runners.spark.stateful.SparkGroupAlsoByWindowViaWindowSet;\n+import org.apache.beam.runners.spark.translation.streaming.UnboundedDataset;\n+import org.apache.beam.runners.spark.util.GlobalWatermarkHolder;\n+import org.apache.beam.runners.spark.util.SparkCompat;\n+import org.apache.beam.sdk.coders.ByteArrayCoder;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.transforms.join.RawUnionValue;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.GlobalWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.util.WindowedValue;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.TimestampedValue;\n+import org.apache.beam.sdk.values.WindowingStrategy;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.BiMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.spark.api.java.JavaRDD;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.broadcast.Broadcast;\n+import org.apache.spark.storage.StorageLevel;\n+import org.apache.spark.streaming.api.java.JavaDStream;\n+import org.apache.spark.streaming.api.java.JavaInputDStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import scala.Tuple2;\n+\n+/** Translates an unbounded portable pipeline into a Spark job. */\n+public class SparkStreamingPortablePipelineTranslator\n+    implements SparkPortablePipelineTranslator<SparkStreamingTranslationContext> {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(SparkStreamingPortablePipelineTranslator.class);\n+\n+  private final ImmutableMap<String, PTransformTranslator> urnToTransformTranslator;\n+\n+  interface PTransformTranslator {\n+\n+    /** Translates transformNode from Beam into the Spark context. */\n+    void translate(\n+        PTransformNode transformNode,\n+        RunnerApi.Pipeline pipeline,\n+        SparkStreamingTranslationContext context);\n+  }\n+\n+  @Override\n+  public Set<String> knownUrns() {\n+    return urnToTransformTranslator.keySet();\n+  }\n+\n+  public SparkStreamingPortablePipelineTranslator() {\n+    ImmutableMap.Builder<String, PTransformTranslator> translatorMap = ImmutableMap.builder();\n+    translatorMap.put(\n+        PTransformTranslation.IMPULSE_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateImpulse);\n+    translatorMap.put(\n+        PTransformTranslation.GROUP_BY_KEY_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateGroupByKey);\n+    translatorMap.put(\n+        ExecutableStage.URN, SparkStreamingPortablePipelineTranslator::translateExecutableStage);\n+    translatorMap.put(\n+        PTransformTranslation.FLATTEN_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateFlatten);\n+    translatorMap.put(\n+        PTransformTranslation.RESHUFFLE_URN,\n+        SparkStreamingPortablePipelineTranslator::translateReshuffle);\n+    this.urnToTransformTranslator = translatorMap.build();\n+  }\n+\n+  /** Translates pipeline from Beam into the Spark context. */\n+  @Override\n+  public void translate(\n+      final RunnerApi.Pipeline pipeline, SparkStreamingTranslationContext context) {\n+    QueryablePipeline p =\n+        QueryablePipeline.forTransforms(\n+            pipeline.getRootTransformIdsList(), pipeline.getComponents());\n+    for (PipelineNode.PTransformNode transformNode : p.getTopologicallyOrderedTransforms()) {\n+      urnToTransformTranslator\n+          .getOrDefault(\n+              transformNode.getTransform().getSpec().getUrn(),\n+              SparkStreamingPortablePipelineTranslator::urnNotFound)\n+          .translate(transformNode, pipeline, context);\n+    }\n+  }\n+\n+  private static void urnNotFound(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    throw new IllegalArgumentException(\n+        String.format(\n+            \"Transform %s has unknown URN %s\",\n+            transformNode.getId(), transformNode.getTransform().getSpec().getUrn()));\n+  }\n+\n+  private static void translateImpulse(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+\n+    TimestampedValue<byte[]> tsValue = TimestampedValue.atMinimumTimestamp(new byte[0]);\n+    Iterable<TimestampedValue<byte[]>> timestampedValues = Collections.singletonList(tsValue);\n+    Iterable<WindowedValue<byte[]>> windowedValues =\n+        StreamSupport.stream(timestampedValues.spliterator(), false)\n+            .map(\n+                timestampedValue ->\n+                    WindowedValue.of(\n+                        timestampedValue.getValue(),\n+                        timestampedValue.getTimestamp(),\n+                        GlobalWindow.INSTANCE,\n+                        PaneInfo.NO_FIRING))\n+            .collect(Collectors.toList());\n+\n+    ByteArrayCoder coder = ByteArrayCoder.of();\n+    WindowedValue.FullWindowedValueCoder<byte[]> windowCoder =\n+        WindowedValue.FullWindowedValueCoder.of(coder, GlobalWindow.Coder.INSTANCE);\n+    JavaRDD<WindowedValue<byte[]>> emptyByteArrayRDD =\n+        context\n+            .getSparkContext()\n+            .parallelize(CoderHelpers.toByteArrays(windowedValues, windowCoder))", "originalCommit": "ca707137600be0b54bc95e378546620a7ce77887", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM4ODY4OQ==", "url": "https://github.com/apache/beam/pull/12157#discussion_r474388689", "bodyText": "This stream isn't empty, is it?", "author": "robertwb", "createdAt": "2020-08-21T03:30:44Z", "path": "runners/spark/src/main/java/org/apache/beam/runners/spark/translation/SparkStreamingPortablePipelineTranslator.java", "diffHunk": "@@ -0,0 +1,366 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.spark.translation;\n+\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.createOutputMap;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getExecutableStageIntermediateId;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getInputId;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getOutputId;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getWindowedValueCoder;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getWindowingStrategy;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+import org.apache.beam.runners.core.construction.PTransformTranslation;\n+import org.apache.beam.runners.core.construction.graph.ExecutableStage;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode.PTransformNode;\n+import org.apache.beam.runners.core.construction.graph.QueryablePipeline;\n+import org.apache.beam.runners.fnexecution.provisioning.JobInfo;\n+import org.apache.beam.runners.spark.SparkPipelineOptions;\n+import org.apache.beam.runners.spark.coders.CoderHelpers;\n+import org.apache.beam.runners.spark.metrics.MetricsAccumulator;\n+import org.apache.beam.runners.spark.stateful.SparkGroupAlsoByWindowViaWindowSet;\n+import org.apache.beam.runners.spark.translation.streaming.UnboundedDataset;\n+import org.apache.beam.runners.spark.util.GlobalWatermarkHolder;\n+import org.apache.beam.runners.spark.util.SparkCompat;\n+import org.apache.beam.sdk.coders.ByteArrayCoder;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.transforms.join.RawUnionValue;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.GlobalWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.util.WindowedValue;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.TimestampedValue;\n+import org.apache.beam.sdk.values.WindowingStrategy;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.BiMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.spark.api.java.JavaRDD;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.broadcast.Broadcast;\n+import org.apache.spark.storage.StorageLevel;\n+import org.apache.spark.streaming.api.java.JavaDStream;\n+import org.apache.spark.streaming.api.java.JavaInputDStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import scala.Tuple2;\n+\n+/** Translates an unbounded portable pipeline into a Spark job. */\n+public class SparkStreamingPortablePipelineTranslator\n+    implements SparkPortablePipelineTranslator<SparkStreamingTranslationContext> {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(SparkStreamingPortablePipelineTranslator.class);\n+\n+  private final ImmutableMap<String, PTransformTranslator> urnToTransformTranslator;\n+\n+  interface PTransformTranslator {\n+\n+    /** Translates transformNode from Beam into the Spark context. */\n+    void translate(\n+        PTransformNode transformNode,\n+        RunnerApi.Pipeline pipeline,\n+        SparkStreamingTranslationContext context);\n+  }\n+\n+  @Override\n+  public Set<String> knownUrns() {\n+    return urnToTransformTranslator.keySet();\n+  }\n+\n+  public SparkStreamingPortablePipelineTranslator() {\n+    ImmutableMap.Builder<String, PTransformTranslator> translatorMap = ImmutableMap.builder();\n+    translatorMap.put(\n+        PTransformTranslation.IMPULSE_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateImpulse);\n+    translatorMap.put(\n+        PTransformTranslation.GROUP_BY_KEY_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateGroupByKey);\n+    translatorMap.put(\n+        ExecutableStage.URN, SparkStreamingPortablePipelineTranslator::translateExecutableStage);\n+    translatorMap.put(\n+        PTransformTranslation.FLATTEN_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateFlatten);\n+    translatorMap.put(\n+        PTransformTranslation.RESHUFFLE_URN,\n+        SparkStreamingPortablePipelineTranslator::translateReshuffle);\n+    this.urnToTransformTranslator = translatorMap.build();\n+  }\n+\n+  /** Translates pipeline from Beam into the Spark context. */\n+  @Override\n+  public void translate(\n+      final RunnerApi.Pipeline pipeline, SparkStreamingTranslationContext context) {\n+    QueryablePipeline p =\n+        QueryablePipeline.forTransforms(\n+            pipeline.getRootTransformIdsList(), pipeline.getComponents());\n+    for (PipelineNode.PTransformNode transformNode : p.getTopologicallyOrderedTransforms()) {\n+      urnToTransformTranslator\n+          .getOrDefault(\n+              transformNode.getTransform().getSpec().getUrn(),\n+              SparkStreamingPortablePipelineTranslator::urnNotFound)\n+          .translate(transformNode, pipeline, context);\n+    }\n+  }\n+\n+  private static void urnNotFound(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    throw new IllegalArgumentException(\n+        String.format(\n+            \"Transform %s has unknown URN %s\",\n+            transformNode.getId(), transformNode.getTransform().getSpec().getUrn()));\n+  }\n+\n+  private static void translateImpulse(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+\n+    TimestampedValue<byte[]> tsValue = TimestampedValue.atMinimumTimestamp(new byte[0]);\n+    Iterable<TimestampedValue<byte[]>> timestampedValues = Collections.singletonList(tsValue);\n+    Iterable<WindowedValue<byte[]>> windowedValues =\n+        StreamSupport.stream(timestampedValues.spliterator(), false)\n+            .map(\n+                timestampedValue ->\n+                    WindowedValue.of(\n+                        timestampedValue.getValue(),\n+                        timestampedValue.getTimestamp(),\n+                        GlobalWindow.INSTANCE,\n+                        PaneInfo.NO_FIRING))\n+            .collect(Collectors.toList());\n+\n+    ByteArrayCoder coder = ByteArrayCoder.of();\n+    WindowedValue.FullWindowedValueCoder<byte[]> windowCoder =\n+        WindowedValue.FullWindowedValueCoder.of(coder, GlobalWindow.Coder.INSTANCE);\n+    JavaRDD<WindowedValue<byte[]>> emptyByteArrayRDD =\n+        context\n+            .getSparkContext()\n+            .parallelize(CoderHelpers.toByteArrays(windowedValues, windowCoder))\n+            .map(CoderHelpers.fromByteFunction(windowCoder));\n+\n+    Queue<JavaRDD<WindowedValue<byte[]>>> rddQueue = new LinkedBlockingQueue<>();\n+    rddQueue.offer(emptyByteArrayRDD);\n+    JavaInputDStream<WindowedValue<byte[]>> emptyStream =", "originalCommit": "ca707137600be0b54bc95e378546620a7ce77887", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM4OTMwOQ==", "url": "https://github.com/apache/beam/pull/12157#discussion_r474389309", "bodyText": "I have to admit I'm a bit fuzzy on how this holds back (or doesn't) the watermark.", "author": "robertwb", "createdAt": "2020-08-21T03:33:39Z", "path": "runners/spark/src/main/java/org/apache/beam/runners/spark/translation/SparkStreamingPortablePipelineTranslator.java", "diffHunk": "@@ -0,0 +1,366 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.spark.translation;\n+\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.createOutputMap;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getExecutableStageIntermediateId;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getInputId;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getOutputId;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getWindowedValueCoder;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getWindowingStrategy;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+import org.apache.beam.runners.core.construction.PTransformTranslation;\n+import org.apache.beam.runners.core.construction.graph.ExecutableStage;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode.PTransformNode;\n+import org.apache.beam.runners.core.construction.graph.QueryablePipeline;\n+import org.apache.beam.runners.fnexecution.provisioning.JobInfo;\n+import org.apache.beam.runners.spark.SparkPipelineOptions;\n+import org.apache.beam.runners.spark.coders.CoderHelpers;\n+import org.apache.beam.runners.spark.metrics.MetricsAccumulator;\n+import org.apache.beam.runners.spark.stateful.SparkGroupAlsoByWindowViaWindowSet;\n+import org.apache.beam.runners.spark.translation.streaming.UnboundedDataset;\n+import org.apache.beam.runners.spark.util.GlobalWatermarkHolder;\n+import org.apache.beam.runners.spark.util.SparkCompat;\n+import org.apache.beam.sdk.coders.ByteArrayCoder;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.transforms.join.RawUnionValue;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.GlobalWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.util.WindowedValue;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.TimestampedValue;\n+import org.apache.beam.sdk.values.WindowingStrategy;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.BiMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.spark.api.java.JavaRDD;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.broadcast.Broadcast;\n+import org.apache.spark.storage.StorageLevel;\n+import org.apache.spark.streaming.api.java.JavaDStream;\n+import org.apache.spark.streaming.api.java.JavaInputDStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import scala.Tuple2;\n+\n+/** Translates an unbounded portable pipeline into a Spark job. */\n+public class SparkStreamingPortablePipelineTranslator\n+    implements SparkPortablePipelineTranslator<SparkStreamingTranslationContext> {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(SparkStreamingPortablePipelineTranslator.class);\n+\n+  private final ImmutableMap<String, PTransformTranslator> urnToTransformTranslator;\n+\n+  interface PTransformTranslator {\n+\n+    /** Translates transformNode from Beam into the Spark context. */\n+    void translate(\n+        PTransformNode transformNode,\n+        RunnerApi.Pipeline pipeline,\n+        SparkStreamingTranslationContext context);\n+  }\n+\n+  @Override\n+  public Set<String> knownUrns() {\n+    return urnToTransformTranslator.keySet();\n+  }\n+\n+  public SparkStreamingPortablePipelineTranslator() {\n+    ImmutableMap.Builder<String, PTransformTranslator> translatorMap = ImmutableMap.builder();\n+    translatorMap.put(\n+        PTransformTranslation.IMPULSE_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateImpulse);\n+    translatorMap.put(\n+        PTransformTranslation.GROUP_BY_KEY_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateGroupByKey);\n+    translatorMap.put(\n+        ExecutableStage.URN, SparkStreamingPortablePipelineTranslator::translateExecutableStage);\n+    translatorMap.put(\n+        PTransformTranslation.FLATTEN_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateFlatten);\n+    translatorMap.put(\n+        PTransformTranslation.RESHUFFLE_URN,\n+        SparkStreamingPortablePipelineTranslator::translateReshuffle);\n+    this.urnToTransformTranslator = translatorMap.build();\n+  }\n+\n+  /** Translates pipeline from Beam into the Spark context. */\n+  @Override\n+  public void translate(\n+      final RunnerApi.Pipeline pipeline, SparkStreamingTranslationContext context) {\n+    QueryablePipeline p =\n+        QueryablePipeline.forTransforms(\n+            pipeline.getRootTransformIdsList(), pipeline.getComponents());\n+    for (PipelineNode.PTransformNode transformNode : p.getTopologicallyOrderedTransforms()) {\n+      urnToTransformTranslator\n+          .getOrDefault(\n+              transformNode.getTransform().getSpec().getUrn(),\n+              SparkStreamingPortablePipelineTranslator::urnNotFound)\n+          .translate(transformNode, pipeline, context);\n+    }\n+  }\n+\n+  private static void urnNotFound(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    throw new IllegalArgumentException(\n+        String.format(\n+            \"Transform %s has unknown URN %s\",\n+            transformNode.getId(), transformNode.getTransform().getSpec().getUrn()));\n+  }\n+\n+  private static void translateImpulse(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+\n+    TimestampedValue<byte[]> tsValue = TimestampedValue.atMinimumTimestamp(new byte[0]);\n+    Iterable<TimestampedValue<byte[]>> timestampedValues = Collections.singletonList(tsValue);\n+    Iterable<WindowedValue<byte[]>> windowedValues =\n+        StreamSupport.stream(timestampedValues.spliterator(), false)\n+            .map(\n+                timestampedValue ->\n+                    WindowedValue.of(\n+                        timestampedValue.getValue(),\n+                        timestampedValue.getTimestamp(),\n+                        GlobalWindow.INSTANCE,\n+                        PaneInfo.NO_FIRING))\n+            .collect(Collectors.toList());\n+\n+    ByteArrayCoder coder = ByteArrayCoder.of();\n+    WindowedValue.FullWindowedValueCoder<byte[]> windowCoder =\n+        WindowedValue.FullWindowedValueCoder.of(coder, GlobalWindow.Coder.INSTANCE);\n+    JavaRDD<WindowedValue<byte[]>> emptyByteArrayRDD =\n+        context\n+            .getSparkContext()\n+            .parallelize(CoderHelpers.toByteArrays(windowedValues, windowCoder))\n+            .map(CoderHelpers.fromByteFunction(windowCoder));\n+\n+    Queue<JavaRDD<WindowedValue<byte[]>>> rddQueue = new LinkedBlockingQueue<>();\n+    rddQueue.offer(emptyByteArrayRDD);\n+    JavaInputDStream<WindowedValue<byte[]>> emptyStream =\n+        context.getStreamingContext().queueStream(rddQueue, true /* oneAtATime */);\n+\n+    UnboundedDataset<byte[]> output =\n+        new UnboundedDataset<>(\n+            emptyStream, Collections.singletonList(emptyStream.inputDStream().id()));\n+\n+    // Add watermark to holder and advance to infinity to ensure future watermarks can be updated\n+    GlobalWatermarkHolder.SparkWatermarks sparkWatermark =\n+        new GlobalWatermarkHolder.SparkWatermarks(\n+            GlobalWindow.INSTANCE.maxTimestamp(),\n+            BoundedWindow.TIMESTAMP_MAX_VALUE,\n+            context.getFirstTimestamp());\n+    GlobalWatermarkHolder.add(output.getStreamSources().get(0), sparkWatermark);", "originalCommit": "ca707137600be0b54bc95e378546620a7ce77887", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM4OTQ4NA==", "url": "https://github.com/apache/beam/pull/12157#discussion_r474389484", "bodyText": "Be consistent on what's declared final vs. what's not.", "author": "robertwb", "createdAt": "2020-08-21T03:34:27Z", "path": "runners/spark/src/main/java/org/apache/beam/runners/spark/translation/SparkStreamingPortablePipelineTranslator.java", "diffHunk": "@@ -0,0 +1,366 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.spark.translation;\n+\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.createOutputMap;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getExecutableStageIntermediateId;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getInputId;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getOutputId;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getWindowedValueCoder;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getWindowingStrategy;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+import org.apache.beam.runners.core.construction.PTransformTranslation;\n+import org.apache.beam.runners.core.construction.graph.ExecutableStage;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode.PTransformNode;\n+import org.apache.beam.runners.core.construction.graph.QueryablePipeline;\n+import org.apache.beam.runners.fnexecution.provisioning.JobInfo;\n+import org.apache.beam.runners.spark.SparkPipelineOptions;\n+import org.apache.beam.runners.spark.coders.CoderHelpers;\n+import org.apache.beam.runners.spark.metrics.MetricsAccumulator;\n+import org.apache.beam.runners.spark.stateful.SparkGroupAlsoByWindowViaWindowSet;\n+import org.apache.beam.runners.spark.translation.streaming.UnboundedDataset;\n+import org.apache.beam.runners.spark.util.GlobalWatermarkHolder;\n+import org.apache.beam.runners.spark.util.SparkCompat;\n+import org.apache.beam.sdk.coders.ByteArrayCoder;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.transforms.join.RawUnionValue;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.GlobalWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.util.WindowedValue;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.TimestampedValue;\n+import org.apache.beam.sdk.values.WindowingStrategy;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.BiMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.spark.api.java.JavaRDD;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.broadcast.Broadcast;\n+import org.apache.spark.storage.StorageLevel;\n+import org.apache.spark.streaming.api.java.JavaDStream;\n+import org.apache.spark.streaming.api.java.JavaInputDStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import scala.Tuple2;\n+\n+/** Translates an unbounded portable pipeline into a Spark job. */\n+public class SparkStreamingPortablePipelineTranslator\n+    implements SparkPortablePipelineTranslator<SparkStreamingTranslationContext> {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(SparkStreamingPortablePipelineTranslator.class);\n+\n+  private final ImmutableMap<String, PTransformTranslator> urnToTransformTranslator;\n+\n+  interface PTransformTranslator {\n+\n+    /** Translates transformNode from Beam into the Spark context. */\n+    void translate(\n+        PTransformNode transformNode,\n+        RunnerApi.Pipeline pipeline,\n+        SparkStreamingTranslationContext context);\n+  }\n+\n+  @Override\n+  public Set<String> knownUrns() {\n+    return urnToTransformTranslator.keySet();\n+  }\n+\n+  public SparkStreamingPortablePipelineTranslator() {\n+    ImmutableMap.Builder<String, PTransformTranslator> translatorMap = ImmutableMap.builder();\n+    translatorMap.put(\n+        PTransformTranslation.IMPULSE_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateImpulse);\n+    translatorMap.put(\n+        PTransformTranslation.GROUP_BY_KEY_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateGroupByKey);\n+    translatorMap.put(\n+        ExecutableStage.URN, SparkStreamingPortablePipelineTranslator::translateExecutableStage);\n+    translatorMap.put(\n+        PTransformTranslation.FLATTEN_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateFlatten);\n+    translatorMap.put(\n+        PTransformTranslation.RESHUFFLE_URN,\n+        SparkStreamingPortablePipelineTranslator::translateReshuffle);\n+    this.urnToTransformTranslator = translatorMap.build();\n+  }\n+\n+  /** Translates pipeline from Beam into the Spark context. */\n+  @Override\n+  public void translate(\n+      final RunnerApi.Pipeline pipeline, SparkStreamingTranslationContext context) {\n+    QueryablePipeline p =\n+        QueryablePipeline.forTransforms(\n+            pipeline.getRootTransformIdsList(), pipeline.getComponents());\n+    for (PipelineNode.PTransformNode transformNode : p.getTopologicallyOrderedTransforms()) {\n+      urnToTransformTranslator\n+          .getOrDefault(\n+              transformNode.getTransform().getSpec().getUrn(),\n+              SparkStreamingPortablePipelineTranslator::urnNotFound)\n+          .translate(transformNode, pipeline, context);\n+    }\n+  }\n+\n+  private static void urnNotFound(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    throw new IllegalArgumentException(\n+        String.format(\n+            \"Transform %s has unknown URN %s\",\n+            transformNode.getId(), transformNode.getTransform().getSpec().getUrn()));\n+  }\n+\n+  private static void translateImpulse(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+\n+    TimestampedValue<byte[]> tsValue = TimestampedValue.atMinimumTimestamp(new byte[0]);\n+    Iterable<TimestampedValue<byte[]>> timestampedValues = Collections.singletonList(tsValue);\n+    Iterable<WindowedValue<byte[]>> windowedValues =\n+        StreamSupport.stream(timestampedValues.spliterator(), false)\n+            .map(\n+                timestampedValue ->\n+                    WindowedValue.of(\n+                        timestampedValue.getValue(),\n+                        timestampedValue.getTimestamp(),\n+                        GlobalWindow.INSTANCE,\n+                        PaneInfo.NO_FIRING))\n+            .collect(Collectors.toList());\n+\n+    ByteArrayCoder coder = ByteArrayCoder.of();\n+    WindowedValue.FullWindowedValueCoder<byte[]> windowCoder =\n+        WindowedValue.FullWindowedValueCoder.of(coder, GlobalWindow.Coder.INSTANCE);\n+    JavaRDD<WindowedValue<byte[]>> emptyByteArrayRDD =\n+        context\n+            .getSparkContext()\n+            .parallelize(CoderHelpers.toByteArrays(windowedValues, windowCoder))\n+            .map(CoderHelpers.fromByteFunction(windowCoder));\n+\n+    Queue<JavaRDD<WindowedValue<byte[]>>> rddQueue = new LinkedBlockingQueue<>();\n+    rddQueue.offer(emptyByteArrayRDD);\n+    JavaInputDStream<WindowedValue<byte[]>> emptyStream =\n+        context.getStreamingContext().queueStream(rddQueue, true /* oneAtATime */);\n+\n+    UnboundedDataset<byte[]> output =\n+        new UnboundedDataset<>(\n+            emptyStream, Collections.singletonList(emptyStream.inputDStream().id()));\n+\n+    // Add watermark to holder and advance to infinity to ensure future watermarks can be updated\n+    GlobalWatermarkHolder.SparkWatermarks sparkWatermark =\n+        new GlobalWatermarkHolder.SparkWatermarks(\n+            GlobalWindow.INSTANCE.maxTimestamp(),\n+            BoundedWindow.TIMESTAMP_MAX_VALUE,\n+            context.getFirstTimestamp());\n+    GlobalWatermarkHolder.add(output.getStreamSources().get(0), sparkWatermark);\n+\n+    context.pushDataset(getOutputId(transformNode), output);\n+  }\n+\n+  private static <K, V> void translateGroupByKey(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    RunnerApi.Components components = pipeline.getComponents();\n+    String inputId = getInputId(transformNode);\n+    UnboundedDataset<KV<K, V>> inputDataset =\n+        (UnboundedDataset<KV<K, V>>) context.popDataset(inputId);\n+    List<Integer> streamSources = inputDataset.getStreamSources();\n+    JavaDStream<WindowedValue<KV<K, V>>> dStream = inputDataset.getDStream();\n+    WindowedValue.WindowedValueCoder<KV<K, V>> inputCoder =\n+        getWindowedValueCoder(inputId, components);\n+    KvCoder<K, V> inputKvCoder = (KvCoder<K, V>) inputCoder.getValueCoder();\n+    Coder<K> inputKeyCoder = inputKvCoder.getKeyCoder();\n+    Coder<V> inputValueCoder = inputKvCoder.getValueCoder();\n+    final WindowingStrategy windowingStrategy = getWindowingStrategy(inputId, components);", "originalCommit": "ca707137600be0b54bc95e378546620a7ce77887", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM5MDgzMg==", "url": "https://github.com/apache/beam/pull/12157#discussion_r474390832", "bodyText": "Nit: I'm noticing the pattern of assigning a huge number of locals at the top of a function and then only using them once below. Often (not always) the code would be more concise if the declarations were used inline (e.g. use inputDataset.getDStream() rather than assign to an intermediate inputDStream).", "author": "robertwb", "createdAt": "2020-08-21T03:40:06Z", "path": "runners/spark/src/main/java/org/apache/beam/runners/spark/translation/SparkStreamingPortablePipelineTranslator.java", "diffHunk": "@@ -0,0 +1,366 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.spark.translation;\n+\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.createOutputMap;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getExecutableStageIntermediateId;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getInputId;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getOutputId;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getWindowedValueCoder;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getWindowingStrategy;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+import org.apache.beam.runners.core.construction.PTransformTranslation;\n+import org.apache.beam.runners.core.construction.graph.ExecutableStage;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode.PTransformNode;\n+import org.apache.beam.runners.core.construction.graph.QueryablePipeline;\n+import org.apache.beam.runners.fnexecution.provisioning.JobInfo;\n+import org.apache.beam.runners.spark.SparkPipelineOptions;\n+import org.apache.beam.runners.spark.coders.CoderHelpers;\n+import org.apache.beam.runners.spark.metrics.MetricsAccumulator;\n+import org.apache.beam.runners.spark.stateful.SparkGroupAlsoByWindowViaWindowSet;\n+import org.apache.beam.runners.spark.translation.streaming.UnboundedDataset;\n+import org.apache.beam.runners.spark.util.GlobalWatermarkHolder;\n+import org.apache.beam.runners.spark.util.SparkCompat;\n+import org.apache.beam.sdk.coders.ByteArrayCoder;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.transforms.join.RawUnionValue;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.GlobalWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.util.WindowedValue;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.TimestampedValue;\n+import org.apache.beam.sdk.values.WindowingStrategy;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.BiMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.spark.api.java.JavaRDD;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.broadcast.Broadcast;\n+import org.apache.spark.storage.StorageLevel;\n+import org.apache.spark.streaming.api.java.JavaDStream;\n+import org.apache.spark.streaming.api.java.JavaInputDStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import scala.Tuple2;\n+\n+/** Translates an unbounded portable pipeline into a Spark job. */\n+public class SparkStreamingPortablePipelineTranslator\n+    implements SparkPortablePipelineTranslator<SparkStreamingTranslationContext> {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(SparkStreamingPortablePipelineTranslator.class);\n+\n+  private final ImmutableMap<String, PTransformTranslator> urnToTransformTranslator;\n+\n+  interface PTransformTranslator {\n+\n+    /** Translates transformNode from Beam into the Spark context. */\n+    void translate(\n+        PTransformNode transformNode,\n+        RunnerApi.Pipeline pipeline,\n+        SparkStreamingTranslationContext context);\n+  }\n+\n+  @Override\n+  public Set<String> knownUrns() {\n+    return urnToTransformTranslator.keySet();\n+  }\n+\n+  public SparkStreamingPortablePipelineTranslator() {\n+    ImmutableMap.Builder<String, PTransformTranslator> translatorMap = ImmutableMap.builder();\n+    translatorMap.put(\n+        PTransformTranslation.IMPULSE_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateImpulse);\n+    translatorMap.put(\n+        PTransformTranslation.GROUP_BY_KEY_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateGroupByKey);\n+    translatorMap.put(\n+        ExecutableStage.URN, SparkStreamingPortablePipelineTranslator::translateExecutableStage);\n+    translatorMap.put(\n+        PTransformTranslation.FLATTEN_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateFlatten);\n+    translatorMap.put(\n+        PTransformTranslation.RESHUFFLE_URN,\n+        SparkStreamingPortablePipelineTranslator::translateReshuffle);\n+    this.urnToTransformTranslator = translatorMap.build();\n+  }\n+\n+  /** Translates pipeline from Beam into the Spark context. */\n+  @Override\n+  public void translate(\n+      final RunnerApi.Pipeline pipeline, SparkStreamingTranslationContext context) {\n+    QueryablePipeline p =\n+        QueryablePipeline.forTransforms(\n+            pipeline.getRootTransformIdsList(), pipeline.getComponents());\n+    for (PipelineNode.PTransformNode transformNode : p.getTopologicallyOrderedTransforms()) {\n+      urnToTransformTranslator\n+          .getOrDefault(\n+              transformNode.getTransform().getSpec().getUrn(),\n+              SparkStreamingPortablePipelineTranslator::urnNotFound)\n+          .translate(transformNode, pipeline, context);\n+    }\n+  }\n+\n+  private static void urnNotFound(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    throw new IllegalArgumentException(\n+        String.format(\n+            \"Transform %s has unknown URN %s\",\n+            transformNode.getId(), transformNode.getTransform().getSpec().getUrn()));\n+  }\n+\n+  private static void translateImpulse(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+\n+    TimestampedValue<byte[]> tsValue = TimestampedValue.atMinimumTimestamp(new byte[0]);\n+    Iterable<TimestampedValue<byte[]>> timestampedValues = Collections.singletonList(tsValue);\n+    Iterable<WindowedValue<byte[]>> windowedValues =\n+        StreamSupport.stream(timestampedValues.spliterator(), false)\n+            .map(\n+                timestampedValue ->\n+                    WindowedValue.of(\n+                        timestampedValue.getValue(),\n+                        timestampedValue.getTimestamp(),\n+                        GlobalWindow.INSTANCE,\n+                        PaneInfo.NO_FIRING))\n+            .collect(Collectors.toList());\n+\n+    ByteArrayCoder coder = ByteArrayCoder.of();\n+    WindowedValue.FullWindowedValueCoder<byte[]> windowCoder =\n+        WindowedValue.FullWindowedValueCoder.of(coder, GlobalWindow.Coder.INSTANCE);\n+    JavaRDD<WindowedValue<byte[]>> emptyByteArrayRDD =\n+        context\n+            .getSparkContext()\n+            .parallelize(CoderHelpers.toByteArrays(windowedValues, windowCoder))\n+            .map(CoderHelpers.fromByteFunction(windowCoder));\n+\n+    Queue<JavaRDD<WindowedValue<byte[]>>> rddQueue = new LinkedBlockingQueue<>();\n+    rddQueue.offer(emptyByteArrayRDD);\n+    JavaInputDStream<WindowedValue<byte[]>> emptyStream =\n+        context.getStreamingContext().queueStream(rddQueue, true /* oneAtATime */);\n+\n+    UnboundedDataset<byte[]> output =\n+        new UnboundedDataset<>(\n+            emptyStream, Collections.singletonList(emptyStream.inputDStream().id()));\n+\n+    // Add watermark to holder and advance to infinity to ensure future watermarks can be updated\n+    GlobalWatermarkHolder.SparkWatermarks sparkWatermark =\n+        new GlobalWatermarkHolder.SparkWatermarks(\n+            GlobalWindow.INSTANCE.maxTimestamp(),\n+            BoundedWindow.TIMESTAMP_MAX_VALUE,\n+            context.getFirstTimestamp());\n+    GlobalWatermarkHolder.add(output.getStreamSources().get(0), sparkWatermark);\n+\n+    context.pushDataset(getOutputId(transformNode), output);\n+  }\n+\n+  private static <K, V> void translateGroupByKey(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    RunnerApi.Components components = pipeline.getComponents();\n+    String inputId = getInputId(transformNode);\n+    UnboundedDataset<KV<K, V>> inputDataset =\n+        (UnboundedDataset<KV<K, V>>) context.popDataset(inputId);\n+    List<Integer> streamSources = inputDataset.getStreamSources();\n+    JavaDStream<WindowedValue<KV<K, V>>> dStream = inputDataset.getDStream();\n+    WindowedValue.WindowedValueCoder<KV<K, V>> inputCoder =\n+        getWindowedValueCoder(inputId, components);\n+    KvCoder<K, V> inputKvCoder = (KvCoder<K, V>) inputCoder.getValueCoder();\n+    Coder<K> inputKeyCoder = inputKvCoder.getKeyCoder();\n+    Coder<V> inputValueCoder = inputKvCoder.getValueCoder();\n+    final WindowingStrategy windowingStrategy = getWindowingStrategy(inputId, components);\n+    final WindowFn<Object, BoundedWindow> windowFn = windowingStrategy.getWindowFn();\n+    final WindowedValue.WindowedValueCoder<V> wvCoder =\n+        WindowedValue.FullWindowedValueCoder.of(inputValueCoder, windowFn.windowCoder());\n+\n+    JavaDStream<WindowedValue<KV<K, Iterable<V>>>> outStream =\n+        SparkGroupAlsoByWindowViaWindowSet.groupByKeyAndWindow(\n+            dStream,\n+            inputKeyCoder,\n+            wvCoder,\n+            windowingStrategy,\n+            context.getSerializableOptions(),\n+            streamSources,\n+            transformNode.getId());\n+\n+    context.pushDataset(\n+        getOutputId(transformNode), new UnboundedDataset<>(outStream, streamSources));\n+  }\n+\n+  private static <InputT, OutputT, SideInputT> void translateExecutableStage(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    RunnerApi.ExecutableStagePayload stagePayload;\n+    try {\n+      stagePayload =\n+          RunnerApi.ExecutableStagePayload.parseFrom(\n+              transformNode.getTransform().getSpec().getPayload());\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n+\n+    String inputPCollectionId = stagePayload.getInput();\n+    UnboundedDataset<InputT> inputDataset =\n+        (UnboundedDataset<InputT>) context.popDataset(inputPCollectionId);\n+    List<Integer> streamSources = inputDataset.getStreamSources();\n+    JavaDStream<WindowedValue<InputT>> inputDStream = inputDataset.getDStream();", "originalCommit": "ca707137600be0b54bc95e378546620a7ce77887", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM5MTAwMg==", "url": "https://github.com/apache/beam/pull/12157#discussion_r474391002", "bodyText": "Trow a clear exception here if the executable stage declares itself as having side inputs.", "author": "robertwb", "createdAt": "2020-08-21T03:40:49Z", "path": "runners/spark/src/main/java/org/apache/beam/runners/spark/translation/SparkStreamingPortablePipelineTranslator.java", "diffHunk": "@@ -0,0 +1,366 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.spark.translation;\n+\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.createOutputMap;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getExecutableStageIntermediateId;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getInputId;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getOutputId;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getWindowedValueCoder;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getWindowingStrategy;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+import org.apache.beam.runners.core.construction.PTransformTranslation;\n+import org.apache.beam.runners.core.construction.graph.ExecutableStage;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode.PTransformNode;\n+import org.apache.beam.runners.core.construction.graph.QueryablePipeline;\n+import org.apache.beam.runners.fnexecution.provisioning.JobInfo;\n+import org.apache.beam.runners.spark.SparkPipelineOptions;\n+import org.apache.beam.runners.spark.coders.CoderHelpers;\n+import org.apache.beam.runners.spark.metrics.MetricsAccumulator;\n+import org.apache.beam.runners.spark.stateful.SparkGroupAlsoByWindowViaWindowSet;\n+import org.apache.beam.runners.spark.translation.streaming.UnboundedDataset;\n+import org.apache.beam.runners.spark.util.GlobalWatermarkHolder;\n+import org.apache.beam.runners.spark.util.SparkCompat;\n+import org.apache.beam.sdk.coders.ByteArrayCoder;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.transforms.join.RawUnionValue;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.GlobalWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.util.WindowedValue;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.TimestampedValue;\n+import org.apache.beam.sdk.values.WindowingStrategy;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.BiMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.spark.api.java.JavaRDD;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.broadcast.Broadcast;\n+import org.apache.spark.storage.StorageLevel;\n+import org.apache.spark.streaming.api.java.JavaDStream;\n+import org.apache.spark.streaming.api.java.JavaInputDStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import scala.Tuple2;\n+\n+/** Translates an unbounded portable pipeline into a Spark job. */\n+public class SparkStreamingPortablePipelineTranslator\n+    implements SparkPortablePipelineTranslator<SparkStreamingTranslationContext> {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(SparkStreamingPortablePipelineTranslator.class);\n+\n+  private final ImmutableMap<String, PTransformTranslator> urnToTransformTranslator;\n+\n+  interface PTransformTranslator {\n+\n+    /** Translates transformNode from Beam into the Spark context. */\n+    void translate(\n+        PTransformNode transformNode,\n+        RunnerApi.Pipeline pipeline,\n+        SparkStreamingTranslationContext context);\n+  }\n+\n+  @Override\n+  public Set<String> knownUrns() {\n+    return urnToTransformTranslator.keySet();\n+  }\n+\n+  public SparkStreamingPortablePipelineTranslator() {\n+    ImmutableMap.Builder<String, PTransformTranslator> translatorMap = ImmutableMap.builder();\n+    translatorMap.put(\n+        PTransformTranslation.IMPULSE_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateImpulse);\n+    translatorMap.put(\n+        PTransformTranslation.GROUP_BY_KEY_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateGroupByKey);\n+    translatorMap.put(\n+        ExecutableStage.URN, SparkStreamingPortablePipelineTranslator::translateExecutableStage);\n+    translatorMap.put(\n+        PTransformTranslation.FLATTEN_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateFlatten);\n+    translatorMap.put(\n+        PTransformTranslation.RESHUFFLE_URN,\n+        SparkStreamingPortablePipelineTranslator::translateReshuffle);\n+    this.urnToTransformTranslator = translatorMap.build();\n+  }\n+\n+  /** Translates pipeline from Beam into the Spark context. */\n+  @Override\n+  public void translate(\n+      final RunnerApi.Pipeline pipeline, SparkStreamingTranslationContext context) {\n+    QueryablePipeline p =\n+        QueryablePipeline.forTransforms(\n+            pipeline.getRootTransformIdsList(), pipeline.getComponents());\n+    for (PipelineNode.PTransformNode transformNode : p.getTopologicallyOrderedTransforms()) {\n+      urnToTransformTranslator\n+          .getOrDefault(\n+              transformNode.getTransform().getSpec().getUrn(),\n+              SparkStreamingPortablePipelineTranslator::urnNotFound)\n+          .translate(transformNode, pipeline, context);\n+    }\n+  }\n+\n+  private static void urnNotFound(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    throw new IllegalArgumentException(\n+        String.format(\n+            \"Transform %s has unknown URN %s\",\n+            transformNode.getId(), transformNode.getTransform().getSpec().getUrn()));\n+  }\n+\n+  private static void translateImpulse(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+\n+    TimestampedValue<byte[]> tsValue = TimestampedValue.atMinimumTimestamp(new byte[0]);\n+    Iterable<TimestampedValue<byte[]>> timestampedValues = Collections.singletonList(tsValue);\n+    Iterable<WindowedValue<byte[]>> windowedValues =\n+        StreamSupport.stream(timestampedValues.spliterator(), false)\n+            .map(\n+                timestampedValue ->\n+                    WindowedValue.of(\n+                        timestampedValue.getValue(),\n+                        timestampedValue.getTimestamp(),\n+                        GlobalWindow.INSTANCE,\n+                        PaneInfo.NO_FIRING))\n+            .collect(Collectors.toList());\n+\n+    ByteArrayCoder coder = ByteArrayCoder.of();\n+    WindowedValue.FullWindowedValueCoder<byte[]> windowCoder =\n+        WindowedValue.FullWindowedValueCoder.of(coder, GlobalWindow.Coder.INSTANCE);\n+    JavaRDD<WindowedValue<byte[]>> emptyByteArrayRDD =\n+        context\n+            .getSparkContext()\n+            .parallelize(CoderHelpers.toByteArrays(windowedValues, windowCoder))\n+            .map(CoderHelpers.fromByteFunction(windowCoder));\n+\n+    Queue<JavaRDD<WindowedValue<byte[]>>> rddQueue = new LinkedBlockingQueue<>();\n+    rddQueue.offer(emptyByteArrayRDD);\n+    JavaInputDStream<WindowedValue<byte[]>> emptyStream =\n+        context.getStreamingContext().queueStream(rddQueue, true /* oneAtATime */);\n+\n+    UnboundedDataset<byte[]> output =\n+        new UnboundedDataset<>(\n+            emptyStream, Collections.singletonList(emptyStream.inputDStream().id()));\n+\n+    // Add watermark to holder and advance to infinity to ensure future watermarks can be updated\n+    GlobalWatermarkHolder.SparkWatermarks sparkWatermark =\n+        new GlobalWatermarkHolder.SparkWatermarks(\n+            GlobalWindow.INSTANCE.maxTimestamp(),\n+            BoundedWindow.TIMESTAMP_MAX_VALUE,\n+            context.getFirstTimestamp());\n+    GlobalWatermarkHolder.add(output.getStreamSources().get(0), sparkWatermark);\n+\n+    context.pushDataset(getOutputId(transformNode), output);\n+  }\n+\n+  private static <K, V> void translateGroupByKey(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    RunnerApi.Components components = pipeline.getComponents();\n+    String inputId = getInputId(transformNode);\n+    UnboundedDataset<KV<K, V>> inputDataset =\n+        (UnboundedDataset<KV<K, V>>) context.popDataset(inputId);\n+    List<Integer> streamSources = inputDataset.getStreamSources();\n+    JavaDStream<WindowedValue<KV<K, V>>> dStream = inputDataset.getDStream();\n+    WindowedValue.WindowedValueCoder<KV<K, V>> inputCoder =\n+        getWindowedValueCoder(inputId, components);\n+    KvCoder<K, V> inputKvCoder = (KvCoder<K, V>) inputCoder.getValueCoder();\n+    Coder<K> inputKeyCoder = inputKvCoder.getKeyCoder();\n+    Coder<V> inputValueCoder = inputKvCoder.getValueCoder();\n+    final WindowingStrategy windowingStrategy = getWindowingStrategy(inputId, components);\n+    final WindowFn<Object, BoundedWindow> windowFn = windowingStrategy.getWindowFn();\n+    final WindowedValue.WindowedValueCoder<V> wvCoder =\n+        WindowedValue.FullWindowedValueCoder.of(inputValueCoder, windowFn.windowCoder());\n+\n+    JavaDStream<WindowedValue<KV<K, Iterable<V>>>> outStream =\n+        SparkGroupAlsoByWindowViaWindowSet.groupByKeyAndWindow(\n+            dStream,\n+            inputKeyCoder,\n+            wvCoder,\n+            windowingStrategy,\n+            context.getSerializableOptions(),\n+            streamSources,\n+            transformNode.getId());\n+\n+    context.pushDataset(\n+        getOutputId(transformNode), new UnboundedDataset<>(outStream, streamSources));\n+  }\n+\n+  private static <InputT, OutputT, SideInputT> void translateExecutableStage(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    RunnerApi.ExecutableStagePayload stagePayload;\n+    try {\n+      stagePayload =\n+          RunnerApi.ExecutableStagePayload.parseFrom(\n+              transformNode.getTransform().getSpec().getPayload());\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n+\n+    String inputPCollectionId = stagePayload.getInput();\n+    UnboundedDataset<InputT> inputDataset =\n+        (UnboundedDataset<InputT>) context.popDataset(inputPCollectionId);\n+    List<Integer> streamSources = inputDataset.getStreamSources();\n+    JavaDStream<WindowedValue<InputT>> inputDStream = inputDataset.getDStream();\n+    Map<String, String> outputs = transformNode.getTransform().getOutputsMap();\n+    BiMap<String, Integer> outputMap = createOutputMap(outputs.values());\n+\n+    RunnerApi.Components components = pipeline.getComponents();\n+    Coder windowCoder =\n+        getWindowingStrategy(inputPCollectionId, components).getWindowFn().windowCoder();\n+\n+    // TODO (BEAM-10712): handle side inputs.", "originalCommit": "ca707137600be0b54bc95e378546620a7ce77887", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM5MTcyMQ==", "url": "https://github.com/apache/beam/pull/12157#discussion_r474391721", "bodyText": "In this case there are no outputs (per the above line). Perhaps just say something to the effect that we want to ensure the stage is executed.", "author": "robertwb", "createdAt": "2020-08-21T03:44:17Z", "path": "runners/spark/src/main/java/org/apache/beam/runners/spark/translation/SparkStreamingPortablePipelineTranslator.java", "diffHunk": "@@ -0,0 +1,366 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.spark.translation;\n+\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.createOutputMap;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getExecutableStageIntermediateId;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getInputId;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getOutputId;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getWindowedValueCoder;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getWindowingStrategy;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+import org.apache.beam.runners.core.construction.PTransformTranslation;\n+import org.apache.beam.runners.core.construction.graph.ExecutableStage;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode.PTransformNode;\n+import org.apache.beam.runners.core.construction.graph.QueryablePipeline;\n+import org.apache.beam.runners.fnexecution.provisioning.JobInfo;\n+import org.apache.beam.runners.spark.SparkPipelineOptions;\n+import org.apache.beam.runners.spark.coders.CoderHelpers;\n+import org.apache.beam.runners.spark.metrics.MetricsAccumulator;\n+import org.apache.beam.runners.spark.stateful.SparkGroupAlsoByWindowViaWindowSet;\n+import org.apache.beam.runners.spark.translation.streaming.UnboundedDataset;\n+import org.apache.beam.runners.spark.util.GlobalWatermarkHolder;\n+import org.apache.beam.runners.spark.util.SparkCompat;\n+import org.apache.beam.sdk.coders.ByteArrayCoder;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.transforms.join.RawUnionValue;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.GlobalWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.util.WindowedValue;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.TimestampedValue;\n+import org.apache.beam.sdk.values.WindowingStrategy;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.BiMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.spark.api.java.JavaRDD;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.broadcast.Broadcast;\n+import org.apache.spark.storage.StorageLevel;\n+import org.apache.spark.streaming.api.java.JavaDStream;\n+import org.apache.spark.streaming.api.java.JavaInputDStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import scala.Tuple2;\n+\n+/** Translates an unbounded portable pipeline into a Spark job. */\n+public class SparkStreamingPortablePipelineTranslator\n+    implements SparkPortablePipelineTranslator<SparkStreamingTranslationContext> {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(SparkStreamingPortablePipelineTranslator.class);\n+\n+  private final ImmutableMap<String, PTransformTranslator> urnToTransformTranslator;\n+\n+  interface PTransformTranslator {\n+\n+    /** Translates transformNode from Beam into the Spark context. */\n+    void translate(\n+        PTransformNode transformNode,\n+        RunnerApi.Pipeline pipeline,\n+        SparkStreamingTranslationContext context);\n+  }\n+\n+  @Override\n+  public Set<String> knownUrns() {\n+    return urnToTransformTranslator.keySet();\n+  }\n+\n+  public SparkStreamingPortablePipelineTranslator() {\n+    ImmutableMap.Builder<String, PTransformTranslator> translatorMap = ImmutableMap.builder();\n+    translatorMap.put(\n+        PTransformTranslation.IMPULSE_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateImpulse);\n+    translatorMap.put(\n+        PTransformTranslation.GROUP_BY_KEY_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateGroupByKey);\n+    translatorMap.put(\n+        ExecutableStage.URN, SparkStreamingPortablePipelineTranslator::translateExecutableStage);\n+    translatorMap.put(\n+        PTransformTranslation.FLATTEN_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateFlatten);\n+    translatorMap.put(\n+        PTransformTranslation.RESHUFFLE_URN,\n+        SparkStreamingPortablePipelineTranslator::translateReshuffle);\n+    this.urnToTransformTranslator = translatorMap.build();\n+  }\n+\n+  /** Translates pipeline from Beam into the Spark context. */\n+  @Override\n+  public void translate(\n+      final RunnerApi.Pipeline pipeline, SparkStreamingTranslationContext context) {\n+    QueryablePipeline p =\n+        QueryablePipeline.forTransforms(\n+            pipeline.getRootTransformIdsList(), pipeline.getComponents());\n+    for (PipelineNode.PTransformNode transformNode : p.getTopologicallyOrderedTransforms()) {\n+      urnToTransformTranslator\n+          .getOrDefault(\n+              transformNode.getTransform().getSpec().getUrn(),\n+              SparkStreamingPortablePipelineTranslator::urnNotFound)\n+          .translate(transformNode, pipeline, context);\n+    }\n+  }\n+\n+  private static void urnNotFound(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    throw new IllegalArgumentException(\n+        String.format(\n+            \"Transform %s has unknown URN %s\",\n+            transformNode.getId(), transformNode.getTransform().getSpec().getUrn()));\n+  }\n+\n+  private static void translateImpulse(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+\n+    TimestampedValue<byte[]> tsValue = TimestampedValue.atMinimumTimestamp(new byte[0]);\n+    Iterable<TimestampedValue<byte[]>> timestampedValues = Collections.singletonList(tsValue);\n+    Iterable<WindowedValue<byte[]>> windowedValues =\n+        StreamSupport.stream(timestampedValues.spliterator(), false)\n+            .map(\n+                timestampedValue ->\n+                    WindowedValue.of(\n+                        timestampedValue.getValue(),\n+                        timestampedValue.getTimestamp(),\n+                        GlobalWindow.INSTANCE,\n+                        PaneInfo.NO_FIRING))\n+            .collect(Collectors.toList());\n+\n+    ByteArrayCoder coder = ByteArrayCoder.of();\n+    WindowedValue.FullWindowedValueCoder<byte[]> windowCoder =\n+        WindowedValue.FullWindowedValueCoder.of(coder, GlobalWindow.Coder.INSTANCE);\n+    JavaRDD<WindowedValue<byte[]>> emptyByteArrayRDD =\n+        context\n+            .getSparkContext()\n+            .parallelize(CoderHelpers.toByteArrays(windowedValues, windowCoder))\n+            .map(CoderHelpers.fromByteFunction(windowCoder));\n+\n+    Queue<JavaRDD<WindowedValue<byte[]>>> rddQueue = new LinkedBlockingQueue<>();\n+    rddQueue.offer(emptyByteArrayRDD);\n+    JavaInputDStream<WindowedValue<byte[]>> emptyStream =\n+        context.getStreamingContext().queueStream(rddQueue, true /* oneAtATime */);\n+\n+    UnboundedDataset<byte[]> output =\n+        new UnboundedDataset<>(\n+            emptyStream, Collections.singletonList(emptyStream.inputDStream().id()));\n+\n+    // Add watermark to holder and advance to infinity to ensure future watermarks can be updated\n+    GlobalWatermarkHolder.SparkWatermarks sparkWatermark =\n+        new GlobalWatermarkHolder.SparkWatermarks(\n+            GlobalWindow.INSTANCE.maxTimestamp(),\n+            BoundedWindow.TIMESTAMP_MAX_VALUE,\n+            context.getFirstTimestamp());\n+    GlobalWatermarkHolder.add(output.getStreamSources().get(0), sparkWatermark);\n+\n+    context.pushDataset(getOutputId(transformNode), output);\n+  }\n+\n+  private static <K, V> void translateGroupByKey(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    RunnerApi.Components components = pipeline.getComponents();\n+    String inputId = getInputId(transformNode);\n+    UnboundedDataset<KV<K, V>> inputDataset =\n+        (UnboundedDataset<KV<K, V>>) context.popDataset(inputId);\n+    List<Integer> streamSources = inputDataset.getStreamSources();\n+    JavaDStream<WindowedValue<KV<K, V>>> dStream = inputDataset.getDStream();\n+    WindowedValue.WindowedValueCoder<KV<K, V>> inputCoder =\n+        getWindowedValueCoder(inputId, components);\n+    KvCoder<K, V> inputKvCoder = (KvCoder<K, V>) inputCoder.getValueCoder();\n+    Coder<K> inputKeyCoder = inputKvCoder.getKeyCoder();\n+    Coder<V> inputValueCoder = inputKvCoder.getValueCoder();\n+    final WindowingStrategy windowingStrategy = getWindowingStrategy(inputId, components);\n+    final WindowFn<Object, BoundedWindow> windowFn = windowingStrategy.getWindowFn();\n+    final WindowedValue.WindowedValueCoder<V> wvCoder =\n+        WindowedValue.FullWindowedValueCoder.of(inputValueCoder, windowFn.windowCoder());\n+\n+    JavaDStream<WindowedValue<KV<K, Iterable<V>>>> outStream =\n+        SparkGroupAlsoByWindowViaWindowSet.groupByKeyAndWindow(\n+            dStream,\n+            inputKeyCoder,\n+            wvCoder,\n+            windowingStrategy,\n+            context.getSerializableOptions(),\n+            streamSources,\n+            transformNode.getId());\n+\n+    context.pushDataset(\n+        getOutputId(transformNode), new UnboundedDataset<>(outStream, streamSources));\n+  }\n+\n+  private static <InputT, OutputT, SideInputT> void translateExecutableStage(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    RunnerApi.ExecutableStagePayload stagePayload;\n+    try {\n+      stagePayload =\n+          RunnerApi.ExecutableStagePayload.parseFrom(\n+              transformNode.getTransform().getSpec().getPayload());\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n+\n+    String inputPCollectionId = stagePayload.getInput();\n+    UnboundedDataset<InputT> inputDataset =\n+        (UnboundedDataset<InputT>) context.popDataset(inputPCollectionId);\n+    List<Integer> streamSources = inputDataset.getStreamSources();\n+    JavaDStream<WindowedValue<InputT>> inputDStream = inputDataset.getDStream();\n+    Map<String, String> outputs = transformNode.getTransform().getOutputsMap();\n+    BiMap<String, Integer> outputMap = createOutputMap(outputs.values());\n+\n+    RunnerApi.Components components = pipeline.getComponents();\n+    Coder windowCoder =\n+        getWindowingStrategy(inputPCollectionId, components).getWindowFn().windowCoder();\n+\n+    // TODO (BEAM-10712): handle side inputs.\n+    ImmutableMap<\n+            String, Tuple2<Broadcast<List<byte[]>>, WindowedValue.WindowedValueCoder<SideInputT>>>\n+        broadcastVariables = ImmutableMap.copyOf(new HashMap<>());\n+\n+    SparkExecutableStageFunction<InputT, SideInputT> function =\n+        new SparkExecutableStageFunction<>(\n+            stagePayload,\n+            context.jobInfo,\n+            outputMap,\n+            SparkExecutableStageContextFactory.getInstance(),\n+            broadcastVariables,\n+            MetricsAccumulator.getInstance(),\n+            windowCoder);\n+    JavaDStream<RawUnionValue> staged = inputDStream.mapPartitions(function);\n+\n+    String intermediateId = getExecutableStageIntermediateId(transformNode);\n+    context.pushDataset(\n+        intermediateId,\n+        new Dataset() {\n+          @Override\n+          public void cache(String storageLevel, Coder<?> coder) {\n+            StorageLevel level = StorageLevel.fromString(storageLevel);\n+            staged.persist(level);\n+          }\n+\n+          @Override\n+          public void action() {\n+            // Empty function to force computation of RDD.\n+            staged.foreachRDD(TranslationUtils.emptyVoidFunction());\n+          }\n+\n+          @Override\n+          public void setName(String name) {\n+            // ignore\n+          }\n+        });\n+    // pop dataset to mark DStream as used\n+    context.popDataset(intermediateId);\n+\n+    for (String outputId : outputs.values()) {\n+      JavaDStream<WindowedValue<OutputT>> outStream =\n+          staged.flatMap(new SparkExecutableStageExtractionFunction<>(outputMap.get(outputId)));\n+      context.pushDataset(outputId, new UnboundedDataset<>(outStream, streamSources));\n+    }\n+\n+    if (outputs.isEmpty()) {\n+      // Add sink to ensure all outputs are computed", "originalCommit": "ca707137600be0b54bc95e378546620a7ce77887", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM5MTg5Nw==", "url": "https://github.com/apache/beam/pull/12157#discussion_r474391897", "bodyText": "File and reference a JIRA.", "author": "robertwb", "createdAt": "2020-08-21T03:45:02Z", "path": "runners/spark/src/main/java/org/apache/beam/runners/spark/translation/SparkStreamingPortablePipelineTranslator.java", "diffHunk": "@@ -0,0 +1,366 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.spark.translation;\n+\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.createOutputMap;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getExecutableStageIntermediateId;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getInputId;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getOutputId;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getWindowedValueCoder;\n+import static org.apache.beam.runners.fnexecution.translation.PipelineTranslatorUtils.getWindowingStrategy;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+import org.apache.beam.runners.core.construction.PTransformTranslation;\n+import org.apache.beam.runners.core.construction.graph.ExecutableStage;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode;\n+import org.apache.beam.runners.core.construction.graph.PipelineNode.PTransformNode;\n+import org.apache.beam.runners.core.construction.graph.QueryablePipeline;\n+import org.apache.beam.runners.fnexecution.provisioning.JobInfo;\n+import org.apache.beam.runners.spark.SparkPipelineOptions;\n+import org.apache.beam.runners.spark.coders.CoderHelpers;\n+import org.apache.beam.runners.spark.metrics.MetricsAccumulator;\n+import org.apache.beam.runners.spark.stateful.SparkGroupAlsoByWindowViaWindowSet;\n+import org.apache.beam.runners.spark.translation.streaming.UnboundedDataset;\n+import org.apache.beam.runners.spark.util.GlobalWatermarkHolder;\n+import org.apache.beam.runners.spark.util.SparkCompat;\n+import org.apache.beam.sdk.coders.ByteArrayCoder;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.transforms.join.RawUnionValue;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.transforms.windowing.GlobalWindow;\n+import org.apache.beam.sdk.transforms.windowing.PaneInfo;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.util.WindowedValue;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.TimestampedValue;\n+import org.apache.beam.sdk.values.WindowingStrategy;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.BiMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.spark.api.java.JavaRDD;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.broadcast.Broadcast;\n+import org.apache.spark.storage.StorageLevel;\n+import org.apache.spark.streaming.api.java.JavaDStream;\n+import org.apache.spark.streaming.api.java.JavaInputDStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import scala.Tuple2;\n+\n+/** Translates an unbounded portable pipeline into a Spark job. */\n+public class SparkStreamingPortablePipelineTranslator\n+    implements SparkPortablePipelineTranslator<SparkStreamingTranslationContext> {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(SparkStreamingPortablePipelineTranslator.class);\n+\n+  private final ImmutableMap<String, PTransformTranslator> urnToTransformTranslator;\n+\n+  interface PTransformTranslator {\n+\n+    /** Translates transformNode from Beam into the Spark context. */\n+    void translate(\n+        PTransformNode transformNode,\n+        RunnerApi.Pipeline pipeline,\n+        SparkStreamingTranslationContext context);\n+  }\n+\n+  @Override\n+  public Set<String> knownUrns() {\n+    return urnToTransformTranslator.keySet();\n+  }\n+\n+  public SparkStreamingPortablePipelineTranslator() {\n+    ImmutableMap.Builder<String, PTransformTranslator> translatorMap = ImmutableMap.builder();\n+    translatorMap.put(\n+        PTransformTranslation.IMPULSE_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateImpulse);\n+    translatorMap.put(\n+        PTransformTranslation.GROUP_BY_KEY_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateGroupByKey);\n+    translatorMap.put(\n+        ExecutableStage.URN, SparkStreamingPortablePipelineTranslator::translateExecutableStage);\n+    translatorMap.put(\n+        PTransformTranslation.FLATTEN_TRANSFORM_URN,\n+        SparkStreamingPortablePipelineTranslator::translateFlatten);\n+    translatorMap.put(\n+        PTransformTranslation.RESHUFFLE_URN,\n+        SparkStreamingPortablePipelineTranslator::translateReshuffle);\n+    this.urnToTransformTranslator = translatorMap.build();\n+  }\n+\n+  /** Translates pipeline from Beam into the Spark context. */\n+  @Override\n+  public void translate(\n+      final RunnerApi.Pipeline pipeline, SparkStreamingTranslationContext context) {\n+    QueryablePipeline p =\n+        QueryablePipeline.forTransforms(\n+            pipeline.getRootTransformIdsList(), pipeline.getComponents());\n+    for (PipelineNode.PTransformNode transformNode : p.getTopologicallyOrderedTransforms()) {\n+      urnToTransformTranslator\n+          .getOrDefault(\n+              transformNode.getTransform().getSpec().getUrn(),\n+              SparkStreamingPortablePipelineTranslator::urnNotFound)\n+          .translate(transformNode, pipeline, context);\n+    }\n+  }\n+\n+  private static void urnNotFound(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    throw new IllegalArgumentException(\n+        String.format(\n+            \"Transform %s has unknown URN %s\",\n+            transformNode.getId(), transformNode.getTransform().getSpec().getUrn()));\n+  }\n+\n+  private static void translateImpulse(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+\n+    TimestampedValue<byte[]> tsValue = TimestampedValue.atMinimumTimestamp(new byte[0]);\n+    Iterable<TimestampedValue<byte[]>> timestampedValues = Collections.singletonList(tsValue);\n+    Iterable<WindowedValue<byte[]>> windowedValues =\n+        StreamSupport.stream(timestampedValues.spliterator(), false)\n+            .map(\n+                timestampedValue ->\n+                    WindowedValue.of(\n+                        timestampedValue.getValue(),\n+                        timestampedValue.getTimestamp(),\n+                        GlobalWindow.INSTANCE,\n+                        PaneInfo.NO_FIRING))\n+            .collect(Collectors.toList());\n+\n+    ByteArrayCoder coder = ByteArrayCoder.of();\n+    WindowedValue.FullWindowedValueCoder<byte[]> windowCoder =\n+        WindowedValue.FullWindowedValueCoder.of(coder, GlobalWindow.Coder.INSTANCE);\n+    JavaRDD<WindowedValue<byte[]>> emptyByteArrayRDD =\n+        context\n+            .getSparkContext()\n+            .parallelize(CoderHelpers.toByteArrays(windowedValues, windowCoder))\n+            .map(CoderHelpers.fromByteFunction(windowCoder));\n+\n+    Queue<JavaRDD<WindowedValue<byte[]>>> rddQueue = new LinkedBlockingQueue<>();\n+    rddQueue.offer(emptyByteArrayRDD);\n+    JavaInputDStream<WindowedValue<byte[]>> emptyStream =\n+        context.getStreamingContext().queueStream(rddQueue, true /* oneAtATime */);\n+\n+    UnboundedDataset<byte[]> output =\n+        new UnboundedDataset<>(\n+            emptyStream, Collections.singletonList(emptyStream.inputDStream().id()));\n+\n+    // Add watermark to holder and advance to infinity to ensure future watermarks can be updated\n+    GlobalWatermarkHolder.SparkWatermarks sparkWatermark =\n+        new GlobalWatermarkHolder.SparkWatermarks(\n+            GlobalWindow.INSTANCE.maxTimestamp(),\n+            BoundedWindow.TIMESTAMP_MAX_VALUE,\n+            context.getFirstTimestamp());\n+    GlobalWatermarkHolder.add(output.getStreamSources().get(0), sparkWatermark);\n+\n+    context.pushDataset(getOutputId(transformNode), output);\n+  }\n+\n+  private static <K, V> void translateGroupByKey(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    RunnerApi.Components components = pipeline.getComponents();\n+    String inputId = getInputId(transformNode);\n+    UnboundedDataset<KV<K, V>> inputDataset =\n+        (UnboundedDataset<KV<K, V>>) context.popDataset(inputId);\n+    List<Integer> streamSources = inputDataset.getStreamSources();\n+    JavaDStream<WindowedValue<KV<K, V>>> dStream = inputDataset.getDStream();\n+    WindowedValue.WindowedValueCoder<KV<K, V>> inputCoder =\n+        getWindowedValueCoder(inputId, components);\n+    KvCoder<K, V> inputKvCoder = (KvCoder<K, V>) inputCoder.getValueCoder();\n+    Coder<K> inputKeyCoder = inputKvCoder.getKeyCoder();\n+    Coder<V> inputValueCoder = inputKvCoder.getValueCoder();\n+    final WindowingStrategy windowingStrategy = getWindowingStrategy(inputId, components);\n+    final WindowFn<Object, BoundedWindow> windowFn = windowingStrategy.getWindowFn();\n+    final WindowedValue.WindowedValueCoder<V> wvCoder =\n+        WindowedValue.FullWindowedValueCoder.of(inputValueCoder, windowFn.windowCoder());\n+\n+    JavaDStream<WindowedValue<KV<K, Iterable<V>>>> outStream =\n+        SparkGroupAlsoByWindowViaWindowSet.groupByKeyAndWindow(\n+            dStream,\n+            inputKeyCoder,\n+            wvCoder,\n+            windowingStrategy,\n+            context.getSerializableOptions(),\n+            streamSources,\n+            transformNode.getId());\n+\n+    context.pushDataset(\n+        getOutputId(transformNode), new UnboundedDataset<>(outStream, streamSources));\n+  }\n+\n+  private static <InputT, OutputT, SideInputT> void translateExecutableStage(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    RunnerApi.ExecutableStagePayload stagePayload;\n+    try {\n+      stagePayload =\n+          RunnerApi.ExecutableStagePayload.parseFrom(\n+              transformNode.getTransform().getSpec().getPayload());\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n+\n+    String inputPCollectionId = stagePayload.getInput();\n+    UnboundedDataset<InputT> inputDataset =\n+        (UnboundedDataset<InputT>) context.popDataset(inputPCollectionId);\n+    List<Integer> streamSources = inputDataset.getStreamSources();\n+    JavaDStream<WindowedValue<InputT>> inputDStream = inputDataset.getDStream();\n+    Map<String, String> outputs = transformNode.getTransform().getOutputsMap();\n+    BiMap<String, Integer> outputMap = createOutputMap(outputs.values());\n+\n+    RunnerApi.Components components = pipeline.getComponents();\n+    Coder windowCoder =\n+        getWindowingStrategy(inputPCollectionId, components).getWindowFn().windowCoder();\n+\n+    // TODO (BEAM-10712): handle side inputs.\n+    ImmutableMap<\n+            String, Tuple2<Broadcast<List<byte[]>>, WindowedValue.WindowedValueCoder<SideInputT>>>\n+        broadcastVariables = ImmutableMap.copyOf(new HashMap<>());\n+\n+    SparkExecutableStageFunction<InputT, SideInputT> function =\n+        new SparkExecutableStageFunction<>(\n+            stagePayload,\n+            context.jobInfo,\n+            outputMap,\n+            SparkExecutableStageContextFactory.getInstance(),\n+            broadcastVariables,\n+            MetricsAccumulator.getInstance(),\n+            windowCoder);\n+    JavaDStream<RawUnionValue> staged = inputDStream.mapPartitions(function);\n+\n+    String intermediateId = getExecutableStageIntermediateId(transformNode);\n+    context.pushDataset(\n+        intermediateId,\n+        new Dataset() {\n+          @Override\n+          public void cache(String storageLevel, Coder<?> coder) {\n+            StorageLevel level = StorageLevel.fromString(storageLevel);\n+            staged.persist(level);\n+          }\n+\n+          @Override\n+          public void action() {\n+            // Empty function to force computation of RDD.\n+            staged.foreachRDD(TranslationUtils.emptyVoidFunction());\n+          }\n+\n+          @Override\n+          public void setName(String name) {\n+            // ignore\n+          }\n+        });\n+    // pop dataset to mark DStream as used\n+    context.popDataset(intermediateId);\n+\n+    for (String outputId : outputs.values()) {\n+      JavaDStream<WindowedValue<OutputT>> outStream =\n+          staged.flatMap(new SparkExecutableStageExtractionFunction<>(outputMap.get(outputId)));\n+      context.pushDataset(outputId, new UnboundedDataset<>(outStream, streamSources));\n+    }\n+\n+    if (outputs.isEmpty()) {\n+      // Add sink to ensure all outputs are computed\n+      JavaDStream<WindowedValue<OutputT>> outStream =\n+          staged.flatMap((rawUnionValue) -> Collections.emptyIterator());\n+      context.pushDataset(\n+          String.format(\"EmptyOutputSink_%d\", context.nextSinkId()),\n+          new UnboundedDataset<>(outStream, streamSources));\n+    }\n+  }\n+\n+  private static <T> void translateFlatten(\n+      PTransformNode transformNode,\n+      RunnerApi.Pipeline pipeline,\n+      SparkStreamingTranslationContext context) {\n+    Map<String, String> inputsMap = transformNode.getTransform().getInputsMap();\n+    JavaDStream<WindowedValue<T>> unifiedStreams;\n+    final List<Integer> streamSources = new ArrayList<>();\n+\n+    if (inputsMap.isEmpty()) {\n+      Queue<JavaRDD<WindowedValue<T>>> q = new LinkedBlockingQueue<>();\n+      q.offer(context.getSparkContext().emptyRDD());\n+      unifiedStreams = context.getStreamingContext().queueStream(q);\n+    } else {\n+      final List<JavaDStream<WindowedValue<T>>> dStreams = new ArrayList<>();\n+      for (String inputId : inputsMap.values()) {\n+        Dataset dataset = context.popDataset(inputId);\n+        if (dataset instanceof UnboundedDataset) {\n+          UnboundedDataset<T> unboundedDataset = (UnboundedDataset<T>) dataset;\n+          streamSources.addAll(unboundedDataset.getStreamSources());\n+          dStreams.add(unboundedDataset.getDStream());\n+        } else {\n+          // create a single RDD stream.\n+          Queue<JavaRDD<WindowedValue<T>>> q = new LinkedBlockingQueue<>();\n+          q.offer(((BoundedDataset) dataset).getRDD());\n+          // TODO: this is not recoverable from checkpoint!", "originalCommit": "ca707137600be0b54bc95e378546620a7ce77887", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "42bcf99006e27f5b9638f82e6df92cd37213385a", "url": "https://github.com/apache/beam/commit/42bcf99006e27f5b9638f82e6df92cd37213385a", "message": "addressing translator comments", "committedDate": "2020-08-21T19:02:38Z", "type": "forcePushed"}, {"oid": "67f771ca62701a2af5f555c09c52926f2dd0ccad", "url": "https://github.com/apache/beam/commit/67f771ca62701a2af5f555c09c52926f2dd0ccad", "message": "[BEAM-7587] preliminary interface changes", "committedDate": "2020-08-22T04:04:11Z", "type": "commit"}, {"oid": "498498f9e848c24ce83b2e119e2b71c0860018e6", "url": "https://github.com/apache/beam/commit/498498f9e848c24ce83b2e119e2b71c0860018e6", "message": "spotlessApply formatting", "committedDate": "2020-08-22T04:04:11Z", "type": "commit"}, {"oid": "85608fe0cec922777c5076650cde84a58790aa57", "url": "https://github.com/apache/beam/commit/85608fe0cec922777c5076650cde84a58790aa57", "message": "fixes from feedback", "committedDate": "2020-08-22T04:04:11Z", "type": "commit"}, {"oid": "a1583f60125133da94463aaa980e1d9f6edc0533", "url": "https://github.com/apache/beam/commit/a1583f60125133da94463aaa980e1d9f6edc0533", "message": "impulse v0", "committedDate": "2020-08-22T04:04:11Z", "type": "commit"}, {"oid": "8b3f39fb27a3215e32d76d0304d7448dc964cd28", "url": "https://github.com/apache/beam/commit/8b3f39fb27a3215e32d76d0304d7448dc964cd28", "message": "formatting", "committedDate": "2020-08-22T04:04:11Z", "type": "commit"}, {"oid": "0a871c3409161f43703ac4c08ffdc7146162c61b", "url": "https://github.com/apache/beam/commit/0a871c3409161f43703ac4c08ffdc7146162c61b", "message": "add streaming option in build.gradle", "committedDate": "2020-08-22T04:04:11Z", "type": "commit"}, {"oid": "2edb934c835e64d56f5b68580bd9197f8f51c044", "url": "https://github.com/apache/beam/commit/2edb934c835e64d56f5b68580bd9197f8f51c044", "message": "transform group by key v0", "committedDate": "2020-08-22T04:04:11Z", "type": "commit"}, {"oid": "c220242a8e26bb90d170cae4777cbe02158047c6", "url": "https://github.com/apache/beam/commit/c220242a8e26bb90d170cae4777cbe02158047c6", "message": "streaming pipeline result", "committedDate": "2020-08-22T04:04:12Z", "type": "commit"}, {"oid": "34dbd5b4fcf6271013ec8a3186669a4fad59bb0a", "url": "https://github.com/apache/beam/commit/34dbd5b4fcf6271013ec8a3186669a4fad59bb0a", "message": "changed RDD creation in impulse translation", "committedDate": "2020-08-22T04:04:12Z", "type": "commit"}, {"oid": "159b7f66de925d56d84aecfa8663be372ea167e3", "url": "https://github.com/apache/beam/commit/159b7f66de925d56d84aecfa8663be372ea167e3", "message": "executable stage v0", "committedDate": "2020-08-22T04:04:12Z", "type": "commit"}, {"oid": "b5fe54028fa757fd26736f56cd2816fb95ab8a1c", "url": "https://github.com/apache/beam/commit/b5fe54028fa757fd26736f56cd2816fb95ab8a1c", "message": "flatten v0", "committedDate": "2020-08-22T04:04:12Z", "type": "commit"}, {"oid": "ba50d6c13dd0778bc925b495d015213eb1da071d", "url": "https://github.com/apache/beam/commit/ba50d6c13dd0778bc925b495d015213eb1da071d", "message": "no-output sink", "committedDate": "2020-08-22T04:04:12Z", "type": "commit"}, {"oid": "d59c015b18de06abe5c4f73e2beaa8d6c8d5e01a", "url": "https://github.com/apache/beam/commit/d59c015b18de06abe5c4f73e2beaa8d6c8d5e01a", "message": "start streaming context in portable runner; modified impulse and exec stage", "committedDate": "2020-08-22T04:04:12Z", "type": "commit"}, {"oid": "fc57c1ed6a7688bc5217cd799157b077af916ee6", "url": "https://github.com/apache/beam/commit/fc57c1ed6a7688bc5217cd799157b077af916ee6", "message": "add watermark in impulse, max timestamp", "committedDate": "2020-08-22T04:04:12Z", "type": "commit"}, {"oid": "a97a147e58a3adec95c626e83f80a24050bb6e23", "url": "https://github.com/apache/beam/commit/a97a147e58a3adec95c626e83f80a24050bb6e23", "message": "reshuffle v0", "committedDate": "2020-08-22T04:04:13Z", "type": "commit"}, {"oid": "5b4ee13dc49f210303838205e3e1d7cdc8d69af7", "url": "https://github.com/apache/beam/commit/5b4ee13dc49f210303838205e3e1d7cdc8d69af7", "message": "added jenkins job, changed watermark timestamp", "committedDate": "2020-08-22T04:04:13Z", "type": "commit"}, {"oid": "e5675a08994f9c64ed1f7d6efe3a817223076862", "url": "https://github.com/apache/beam/commit/e5675a08994f9c64ed1f7d6efe3a817223076862", "message": "timeout option for streaming", "committedDate": "2020-08-22T04:04:13Z", "type": "commit"}, {"oid": "d57a0dfafd451eefd6d8ca77489180cf002dfa06", "url": "https://github.com/apache/beam/commit/d57a0dfafd451eefd6d8ca77489180cf002dfa06", "message": "spotless, checkstyle, spotbugs", "committedDate": "2020-08-22T04:04:13Z", "type": "commit"}, {"oid": "bc352ae9043f4695f89ebebf7876586893d8307a", "url": "https://github.com/apache/beam/commit/bc352ae9043f4695f89ebebf7876586893d8307a", "message": "flatten v1, handle empty PCollections", "committedDate": "2020-08-22T04:04:13Z", "type": "commit"}, {"oid": "829d32b5825cceb309cc8a7d62b4dce402a8baf4", "url": "https://github.com/apache/beam/commit/829d32b5825cceb309cc8a7d62b4dce402a8baf4", "message": "separate build task for streaming, updated registrar test", "committedDate": "2020-08-22T04:04:13Z", "type": "commit"}, {"oid": "55039cb6d9f712b1c866542d5c645e55c3c16454", "url": "https://github.com/apache/beam/commit/55039cb6d9f712b1c866542d5c645e55c3c16454", "message": "address minor review comments", "committedDate": "2020-08-22T04:04:14Z", "type": "commit"}, {"oid": "8793ed19e6ca8b6f403820ea487341570f6510e0", "url": "https://github.com/apache/beam/commit/8793ed19e6ca8b6f403820ea487341570f6510e0", "message": "moved translator util functions to shared file", "committedDate": "2020-08-22T04:04:14Z", "type": "commit"}, {"oid": "eef8bcf976a619c625991048270a4106fa0e8f1e", "url": "https://github.com/apache/beam/commit/eef8bcf976a619c625991048270a4106fa0e8f1e", "message": "refactor build.gradle", "committedDate": "2020-08-22T04:04:14Z", "type": "commit"}, {"oid": "0cdeaf2eb9f953b2ba067ab5b295c48c2b599d0d", "url": "https://github.com/apache/beam/commit/0cdeaf2eb9f953b2ba067ab5b295c48c2b599d0d", "message": "rename timeout option\n\nrename timeout option", "committedDate": "2020-08-22T04:04:14Z", "type": "commit"}, {"oid": "22d0c3f057f885a69dc040e45cae63fc6f7b2e5a", "url": "https://github.com/apache/beam/commit/22d0c3f057f885a69dc040e45cae63fc6f7b2e5a", "message": "spotlessApply", "committedDate": "2020-08-22T04:04:14Z", "type": "commit"}, {"oid": "e1fcbeef8d994a383224ad96ebbe939293a772c3", "url": "https://github.com/apache/beam/commit/e1fcbeef8d994a383224ad96ebbe939293a772c3", "message": "add jira links", "committedDate": "2020-08-22T04:04:14Z", "type": "commit"}, {"oid": "18a35f1ae464696e456b94a23a8b1a81ee1dbd42", "url": "https://github.com/apache/beam/commit/18a35f1ae464696e456b94a23a8b1a81ee1dbd42", "message": "do not processElements if inputs is empty in executable stage function", "committedDate": "2020-08-22T04:04:15Z", "type": "commit"}, {"oid": "42c97eb9e1cf4f9004eb00d3dbefbb197bbc3cf4", "url": "https://github.com/apache/beam/commit/42c97eb9e1cf4f9004eb00d3dbefbb197bbc3cf4", "message": "modified SESF test to check that empty input iterators are not processed", "committedDate": "2020-08-22T04:04:15Z", "type": "commit"}, {"oid": "dcbd09689ceea25ef9b3ec665bb6eab9175dbd75", "url": "https://github.com/apache/beam/commit/dcbd09689ceea25ef9b3ec665bb6eab9175dbd75", "message": "filter tests in gradle build file", "committedDate": "2020-08-22T04:04:15Z", "type": "commit"}, {"oid": "f057c944eef27ae5cb2a22219ae0801a577b380d", "url": "https://github.com/apache/beam/commit/f057c944eef27ae5cb2a22219ae0801a577b380d", "message": "checkstyle\n\nspotless", "committedDate": "2020-08-22T04:04:15Z", "type": "commit"}, {"oid": "d7518fcb6c70588bf609f087c79b20504ccdb042", "url": "https://github.com/apache/beam/commit/d7518fcb6c70588bf609f087c79b20504ccdb042", "message": "addressing comments", "committedDate": "2020-08-22T04:04:15Z", "type": "commit"}, {"oid": "5601d4cd39944669f084511325da1fac3e6f26b5", "url": "https://github.com/apache/beam/commit/5601d4cd39944669f084511325da1fac3e6f26b5", "message": "addressing translator comments", "committedDate": "2020-08-22T04:04:15Z", "type": "commit"}, {"oid": "202e5c494ee14043123de13146f13589ed4a6743", "url": "https://github.com/apache/beam/commit/202e5c494ee14043123de13146f13589ed4a6743", "message": "exclude unbounded pcollection tests in batch mode", "committedDate": "2020-08-22T04:04:15Z", "type": "commit"}, {"oid": "202e5c494ee14043123de13146f13589ed4a6743", "url": "https://github.com/apache/beam/commit/202e5c494ee14043123de13146f13589ed4a6743", "message": "exclude unbounded pcollection tests in batch mode", "committedDate": "2020-08-22T04:04:15Z", "type": "forcePushed"}]}