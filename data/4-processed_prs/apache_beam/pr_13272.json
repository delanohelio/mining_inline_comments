{"pr_number": 13272, "pr_title": "[BEAM-11207] Metric Extraction via proto RPC API", "pr_createdAt": "2020-11-05T16:07:26Z", "pr_url": "https://github.com/apache/beam/pull/13272", "timeline": [{"oid": "ffb7ed79f8a5d1d2c99d332c1126dc5359b902d3", "url": "https://github.com/apache/beam/commit/ffb7ed79f8a5d1d2c99d332c1126dc5359b902d3", "message": "wip: Metric Extraction via proto RPC API", "committedDate": "2020-11-05T15:47:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM4NTE1Mw==", "url": "https://github.com/apache/beam/pull/13272#discussion_r518385153", "bodyText": "Please file a JIRA (https://issues.apache.org/jira/projects/BEAM/issues) under the sdk-go component for this PRs and followup work. Then add the JIRA [BEAM-#####] as a prefix to the PR title.", "author": "lostluck", "createdAt": "2020-11-05T21:40:04Z", "path": "sdks/go/pkg/beam/core/metrics/metrics.go", "diffHunk": "@@ -448,3 +453,50 @@ func (m *gauge) get() (int64, time.Time) {\n \tdefer m.mu.Unlock()\n \treturn m.v, m.t\n }\n+\n+// GaugeValue is the value of a Gauge metric.\n+type GaugeValue struct {\n+\tValue     int64\n+\tTimestamp time.Time\n+}\n+\n+// MetricResults queries for all metric values that match a given filter.\n+type MetricResults interface {\n+\t// TODO: Implement metrics filtering", "originalCommit": "ffb7ed79f8a5d1d2c99d332c1126dc5359b902d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk2MjcyMg==", "url": "https://github.com/apache/beam/pull/13272#discussion_r518962722", "bodyText": "Style nit: Consider changing this to a switch case statement.", "author": "lostluck", "createdAt": "2020-11-06T19:36:09Z", "path": "sdks/go/pkg/beam/core/metrics/monitoring_infos.go", "diffHunk": "@@ -0,0 +1,211 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package metrics\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"log\"\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/coder\"\n+\tjobpb \"github.com/apache/beam/sdks/go/pkg/beam/model/jobmanagement_v1\"\n+\tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+)\n+\n+// FromMonitoringInfos extracts metrics from GetJobMetrics's response and\n+// groups them into counters, distributions and gauges.\n+func FromMonitoringInfos(resultsProto *jobpb.MetricResults) (\n+\t[]CounterResult,\n+\t[]DistributionResult,\n+\t[]GaugeResult) {\n+\tac, ad, ag := groupByType(resultsProto.Attempted)\n+\tcc, cd, cg := groupByType(resultsProto.Committed)\n+\n+\tc := mergeCounters(ac, cc)\n+\td := mergeDistributions(ad, cd)\n+\tg := mergeGauges(ag, cg)\n+\n+\treturn c, d, g\n+}\n+\n+// IsCounter returns true if the monitoring info is a counter metric.\n+func IsCounter(mi *pipepb.MonitoringInfo) bool {\n+\treturn mi.GetType() == \"beam:metrics:sum_int64:v1\"\n+}\n+\n+// IsDistribution returns true if the monitoring info is a distribution metric.\n+func IsDistribution(mi *pipepb.MonitoringInfo) bool {\n+\treturn mi.GetType() == \"beam:metrics:distribution_int64:v1\"\n+}\n+\n+// IsGauge returns true if the monitoring info is a gauge metric.\n+func IsGauge(mi *pipepb.MonitoringInfo) bool {\n+\tswitch mi.GetType() {\n+\tcase\n+\t\t\"beam:metrics:latest_int64:v1\",\n+\t\t\"beam:metrics:top_n_int64:v1\",\n+\t\t\"beam:metrics:bottom_n_int64:v1\":\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func groupByType(minfos []*pipepb.MonitoringInfo) (\n+\tmap[MetricKey]int64,\n+\tmap[MetricKey]DistributionValue,\n+\tmap[MetricKey]GaugeValue) {\n+\tcounters := make(map[MetricKey]int64)\n+\tdistributions := make(map[MetricKey]DistributionValue)\n+\tgauges := make(map[MetricKey]GaugeValue)\n+\n+\tfor _, minfo := range minfos {\n+\t\tkey, err := extractKey(minfo)\n+\t\tif err != nil {\n+\t\t\tlog.Println(err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tr := bytes.NewReader(minfo.GetPayload())\n+\n+\t\tif IsCounter(minfo) {", "originalCommit": "ffb7ed79f8a5d1d2c99d332c1126dc5359b902d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk2MzY3OA==", "url": "https://github.com/apache/beam/pull/13272#discussion_r518963678", "bodyText": "Style nit: Makes it clearer that the only difference between the two clauses is the value of v.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tif v, ok := committed[k]; ok {\n          \n          \n            \n            \t\t\tres = append(res, CounterResult{Attempted: attempted[k], Committed: v, Key: k})\n          \n          \n            \n            \t\t} else {\n          \n          \n            \n            \t\t\tres = append(res, CounterResult{Attempted: attempted[k], Committed: -1, Key: k})\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \t\tv, ok := committed[k] \n          \n          \n            \n            \t\tif !ok {\n          \n          \n            \n            \t\t  v = -1\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \t\tres = append(res, CounterResult{Attempted: attempted[k], Committed: v, Key: k})\n          \n      \n    \n    \n  \n\nIf you make this change, please make the change for distributions and gauges below for consistency,", "author": "lostluck", "createdAt": "2020-11-06T19:38:22Z", "path": "sdks/go/pkg/beam/core/metrics/monitoring_infos.go", "diffHunk": "@@ -0,0 +1,211 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package metrics\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"log\"\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/coder\"\n+\tjobpb \"github.com/apache/beam/sdks/go/pkg/beam/model/jobmanagement_v1\"\n+\tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+)\n+\n+// FromMonitoringInfos extracts metrics from GetJobMetrics's response and\n+// groups them into counters, distributions and gauges.\n+func FromMonitoringInfos(resultsProto *jobpb.MetricResults) (\n+\t[]CounterResult,\n+\t[]DistributionResult,\n+\t[]GaugeResult) {\n+\tac, ad, ag := groupByType(resultsProto.Attempted)\n+\tcc, cd, cg := groupByType(resultsProto.Committed)\n+\n+\tc := mergeCounters(ac, cc)\n+\td := mergeDistributions(ad, cd)\n+\tg := mergeGauges(ag, cg)\n+\n+\treturn c, d, g\n+}\n+\n+// IsCounter returns true if the monitoring info is a counter metric.\n+func IsCounter(mi *pipepb.MonitoringInfo) bool {\n+\treturn mi.GetType() == \"beam:metrics:sum_int64:v1\"\n+}\n+\n+// IsDistribution returns true if the monitoring info is a distribution metric.\n+func IsDistribution(mi *pipepb.MonitoringInfo) bool {\n+\treturn mi.GetType() == \"beam:metrics:distribution_int64:v1\"\n+}\n+\n+// IsGauge returns true if the monitoring info is a gauge metric.\n+func IsGauge(mi *pipepb.MonitoringInfo) bool {\n+\tswitch mi.GetType() {\n+\tcase\n+\t\t\"beam:metrics:latest_int64:v1\",\n+\t\t\"beam:metrics:top_n_int64:v1\",\n+\t\t\"beam:metrics:bottom_n_int64:v1\":\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func groupByType(minfos []*pipepb.MonitoringInfo) (\n+\tmap[MetricKey]int64,\n+\tmap[MetricKey]DistributionValue,\n+\tmap[MetricKey]GaugeValue) {\n+\tcounters := make(map[MetricKey]int64)\n+\tdistributions := make(map[MetricKey]DistributionValue)\n+\tgauges := make(map[MetricKey]GaugeValue)\n+\n+\tfor _, minfo := range minfos {\n+\t\tkey, err := extractKey(minfo)\n+\t\tif err != nil {\n+\t\t\tlog.Println(err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tr := bytes.NewReader(minfo.GetPayload())\n+\n+\t\tif IsCounter(minfo) {\n+\t\t\tvalue, err := extractCounterResult(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tcounters[key] = value\n+\t\t} else if IsDistribution(minfo) {\n+\t\t\tvalue, err := extractDistributionValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tdistributions[key] = value\n+\t\t} else if IsGauge(minfo) {\n+\t\t\tvalue, err := extractGaugeValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tgauges[key] = value\n+\t\t} else {\n+\t\t\tlog.Println(\"unknown metric type\")\n+\t\t}\n+\t}\n+\treturn counters, distributions, gauges\n+}\n+\n+func mergeCounters(attempted map[MetricKey]int64, committed map[MetricKey]int64) []CounterResult {\n+\tres := make([]CounterResult, 0)\n+\n+\tfor k := range attempted {\n+\t\tif v, ok := committed[k]; ok {\n+\t\t\tres = append(res, CounterResult{Attempted: attempted[k], Committed: v, Key: k})\n+\t\t} else {\n+\t\t\tres = append(res, CounterResult{Attempted: attempted[k], Committed: -1, Key: k})\n+\t\t}", "originalCommit": "ffb7ed79f8a5d1d2c99d332c1126dc5359b902d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk2NjQ3OQ==", "url": "https://github.com/apache/beam/pull/13272#discussion_r518966479", "bodyText": "For consistency and ease of finding related work, also put the same JIRA id here.", "author": "lostluck", "createdAt": "2020-11-06T19:44:28Z", "path": "sdks/go/pkg/beam/runners/universal/runnerlib/execute.go", "diffHunk": "@@ -79,15 +81,79 @@ func Execute(ctx context.Context, p *pipepb.Pipeline, endpoint string, opt *JobO\n \n \tjobID, err := Submit(ctx, client, prepID, token)\n \tif err != nil {\n-\t\treturn \"\", err\n+\t\treturn presult, err\n \t}\n \n \tlog.Infof(ctx, \"Submitted job: %v\", jobID)\n \n \t// (4) Wait for completion.\n \n \tif async {\n-\t\treturn jobID, nil\n+\t\treturn presult, nil\n \t}\n-\treturn jobID, WaitForCompletion(ctx, client, jobID)\n+\terr = WaitForCompletion(ctx, client, jobID)\n+\n+\tres, err := newUniversalPipelineResult(ctx, jobID, client)\n+\tif err != nil {\n+\t\treturn presult, err\n+\t}\n+\tpresult = res\n+\n+\treturn presult, err\n+}\n+\n+type UniversalPipelineResult struct {\n+\tJobID   string\n+\tmetrics *UniversalMetrics\n+}\n+\n+func newUniversalPipelineResult(ctx context.Context, jobID string, client jobpb.JobServiceClient) (*UniversalPipelineResult, error) {\n+\tmetrics, err := newUniversalMetrics(ctx, jobID, client)\n+\tif err != nil {\n+\t\treturn &UniversalPipelineResult{jobID, nil}, err\n+\t}\n+\treturn &UniversalPipelineResult{jobID, metrics}, err\n+}\n+\n+func (pr UniversalPipelineResult) Metrics() metrics.MetricResults {\n+\treturn pr.metrics\n+}\n+\n+func newUniversalMetrics(ctx context.Context, jobID string, client jobpb.JobServiceClient) (*UniversalMetrics, error) {\n+\trequest := &jobpb.GetJobMetricsRequest{JobId: jobID}\n+\tresponse, err := client.GetJobMetrics(ctx, request)\n+\tif err != nil {\n+\t\treturn nil, errors.Wrap(err, \"failed to get metrics\")\n+\t}\n+\tc, d, g := metrics.FromMonitoringInfos(response.GetMetrics())\n+\treturn &UniversalMetrics{c, d, g}, err\n+}\n+\n+type UniversalMetrics struct {\n+\tcounters      []metrics.CounterResult\n+\tdistributions []metrics.DistributionResult\n+\tgauges        []metrics.GaugeResult\n+}\n+\n+func (um UniversalMetrics) Query() metrics.MetricQueryResults {\n+\t// TODO: Implement metrics filtering", "originalCommit": "ffb7ed79f8a5d1d2c99d332c1126dc5359b902d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1MjgyNw==", "url": "https://github.com/apache/beam/pull/13272#discussion_r519052827", "bodyText": "We should consider changing ptest or at least having a new ptest.RunWithMetrics endpoint that also returns the pipeline results, as metrics are very valuable and convenient to check in testing situations. That can be handled as a TODO (BEAM--####) however, rather than as a part of this PR, since ptest is pervasive.", "author": "lostluck", "createdAt": "2020-11-06T23:23:51Z", "path": "sdks/go/pkg/beam/testing/ptest/ptest.go", "diffHunk": "@@ -73,7 +73,8 @@ func Run(p *beam.Pipeline) error {\n \tif *Runner == \"\" {\n \t\t*Runner = defaultRunner\n \t}\n-\treturn beam.Run(context.Background(), *Runner, p)\n+\t_, err := beam.Run(context.Background(), *Runner, p)\n+\treturn err", "originalCommit": "ffb7ed79f8a5d1d2c99d332c1126dc5359b902d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYyOTI4MQ==", "url": "https://github.com/apache/beam/pull/13272#discussion_r520629281", "bodyText": "Filled https://issues.apache.org/jira/browse/BEAM-11218", "author": "kamilwu", "createdAt": "2020-11-10T15:00:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1MjgyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1MzE1NA==", "url": "https://github.com/apache/beam/pull/13272#discussion_r519053154", "bodyText": "I'd omit the \"Pipeline\" as it's already clear from the parameter type, and the other Run function that pipelines are going to be executed.", "author": "lostluck", "createdAt": "2020-11-06T23:25:06Z", "path": "sdks/go/pkg/beam/x/beamx/run.go", "diffHunk": "@@ -40,5 +40,13 @@ var runner = flag.String(\"runner\", \"direct\", \"Pipeline runner.\")\n // defaults to the direct runner, but all beam-distributed runners and textio\n // filesystems are implicitly registered.\n func Run(ctx context.Context, p *beam.Pipeline) error {\n+\t_, err := beam.Run(ctx, *runner, p)\n+\treturn err\n+}\n+\n+// RunPipelineWithMetrics invokes beam.Run with the runner supplied by the\n+// flag \"runner\". Returns a beam.PipelineResult objects, which can be\n+// accessed to query the pipeline's metrics.\n+func RunPipelineWithMetrics(ctx context.Context, p *beam.Pipeline) (beam.PipelineResult, error) {", "originalCommit": "ffb7ed79f8a5d1d2c99d332c1126dc5359b902d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3f16527bcc11f95fe6eaa5d14a8f3f40d91ed60d", "url": "https://github.com/apache/beam/commit/3f16527bcc11f95fe6eaa5d14a8f3f40d91ed60d", "message": "fix: style fixes", "committedDate": "2020-11-09T14:39:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAzNjM0NQ==", "url": "https://github.com/apache/beam/pull/13272#discussion_r520036345", "bodyText": "Please move the new package to under beam/core/runtime/monitoring instead of just in raw core. runtime is where code that depends on the protocol buffers tends to live.\nI'm not against a new package for this handling, but I think I'm against moving the code that is harness only being moved out of the harness. That code isn't intended to be part of any external API. There's also nothing relating the code beyond \"they use the MonitoringInfos\". That's not reason enough to put the code into the same package. To match the other convention around protos, perhaps we can call the package \"metricsx\" to go along with runtime/graphx which also handles protocol buffers.\nFurther, WRT Testing, you only seem to be using the encoding functions. Please simply copy those helpers into the test file instead of trying to deduplicate. A little bit of copying is better than a little bit of dependency.", "author": "lostluck", "createdAt": "2020-11-09T18:45:17Z", "path": "sdks/go/pkg/beam/core/monitoring/monitoring.go", "diffHunk": "@@ -13,10 +13,12 @@\n // See the License for the specific language governing permissions and\n // limitations under the License.\n \n-package harness\n+package monitoring", "originalCommit": "9e4968ce09ebbc6f11357f70dcbafda819d047a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA3MDQ0Mw==", "url": "https://github.com/apache/beam/pull/13272#discussion_r520070443", "bodyText": "That said, doing the inverse: Having the new metricx package have Exported payload encoding helpers, and have the harness specific monitoring code depend on those, would be a good move, if you don't like the copying.", "author": "lostluck", "createdAt": "2020-11-09T19:35:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAzNjM0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYwNzkwMA==", "url": "https://github.com/apache/beam/pull/13272#discussion_r520607900", "bodyText": "I created the new metricsx package which exports payload helpers and urn constants (which are required both by harness and my changes). I don't like copying over 100 lines of code, so the package seems like a good idea.", "author": "kamilwu", "createdAt": "2020-11-10T14:33:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAzNjM0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAzNzY1Ng==", "url": "https://github.com/apache/beam/pull/13272#discussion_r520037656", "bodyText": "Every exported identifier should have a doc comment.\nhttps://golang.org/doc/effective_go.html#commentary\n// ShortIDsToInfos translates a slice shortids from a monitoring request to their fully qualified MonitoringInfos\n// based on the contents of the defaultShortIDCache.", "author": "lostluck", "createdAt": "2020-11-09T18:47:32Z", "path": "sdks/go/pkg/beam/core/monitoring/monitoring.go", "diffHunk": "@@ -199,11 +201,11 @@ func getShortID(l metrics.Labels, urn mUrn) string {\n \treturn defaultShortIDCache.getShortID(l, urn)\n }\n \n-func shortIdsToInfos(shortids []string) map[string]*pipepb.MonitoringInfo {\n+func ShortIdsToInfos(shortids []string) map[string]*pipepb.MonitoringInfo {", "originalCommit": "9e4968ce09ebbc6f11357f70dcbafda819d047a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYwODg1Mg==", "url": "https://github.com/apache/beam/pull/13272#discussion_r520608852", "bodyText": "No longer relevant.", "author": "kamilwu", "createdAt": "2020-11-10T14:35:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAzNzY1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAzNzY4OA==", "url": "https://github.com/apache/beam/pull/13272#discussion_r520037688", "bodyText": "Every exported identifier should have a doc comment.\nhttps://golang.org/doc/effective_go.html#commentary\n// Monitoring extracts and translates metrics from an execution plan into the associated MonitoringInfos and short id mappings.", "author": "lostluck", "createdAt": "2020-11-09T18:47:35Z", "path": "sdks/go/pkg/beam/core/monitoring/monitoring.go", "diffHunk": "@@ -199,11 +201,11 @@ func getShortID(l metrics.Labels, urn mUrn) string {\n \treturn defaultShortIDCache.getShortID(l, urn)\n }\n \n-func shortIdsToInfos(shortids []string) map[string]*pipepb.MonitoringInfo {\n+func ShortIdsToInfos(shortids []string) map[string]*pipepb.MonitoringInfo {\n \treturn defaultShortIDCache.shortIdsToInfos(shortids)\n }\n \n-func monitoring(p *exec.Plan) ([]*pipepb.MonitoringInfo, map[string][]byte) {\n+func Monitoring(p *exec.Plan) ([]*pipepb.MonitoringInfo, map[string][]byte) {", "originalCommit": "9e4968ce09ebbc6f11357f70dcbafda819d047a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYwODYyMA==", "url": "https://github.com/apache/beam/pull/13272#discussion_r520608620", "bodyText": "No longer relevant.", "author": "kamilwu", "createdAt": "2020-11-10T14:34:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAzNzY4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA0NDAxNg==", "url": "https://github.com/apache/beam/pull/13272#discussion_r520044016", "bodyText": "Please drop the \"Metric\" prefix when putting things into the metrics package.\nOtherwise users of this type will always be typing metrics.MetricQueryResult.", "author": "lostluck", "createdAt": "2020-11-09T18:57:48Z", "path": "sdks/go/pkg/beam/core/metrics/metrics.go", "diffHunk": "@@ -448,3 +453,73 @@ func (m *gauge) get() (int64, time.Time) {\n \tdefer m.mu.Unlock()\n \treturn m.v, m.t\n }\n+\n+// GaugeValue is the value of a Gauge metric.\n+type GaugeValue struct {\n+\tValue     int64\n+\tTimestamp time.Time\n+}\n+\n+// MetricResults queries for all metric values that match a given filter.\n+type MetricResults struct {\n+\tCounters      []CounterResult\n+\tDistributions []DistributionResult\n+\tGauges        []GaugeResult\n+}\n+\n+// AllMetrics returns all metrics from a MetricResults instance.\n+func (mr MetricResults) AllMetrics() MetricQueryResults {\n+\treturn MetricQueryResults{mr.Counters, mr.Distributions, mr.Gauges}\n+}\n+\n+// TODO: Implement Query(MetricsFilter) and metrics filtering\n+\n+// MetricQueryResults is the results of a query. Allows accessing all of the\n+// metrics that matched the filter.\n+type MetricQueryResults struct {", "originalCommit": "9e4968ce09ebbc6f11357f70dcbafda819d047a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA0NDE4NA==", "url": "https://github.com/apache/beam/pull/13272#discussion_r520044184", "bodyText": "Please drop the \"Metric\" prefix when putting things into the metrics package.\nOtherwise users of this type will always be typing metrics.MetricResults.", "author": "lostluck", "createdAt": "2020-11-09T18:58:06Z", "path": "sdks/go/pkg/beam/core/metrics/metrics.go", "diffHunk": "@@ -448,3 +453,73 @@ func (m *gauge) get() (int64, time.Time) {\n \tdefer m.mu.Unlock()\n \treturn m.v, m.t\n }\n+\n+// GaugeValue is the value of a Gauge metric.\n+type GaugeValue struct {\n+\tValue     int64\n+\tTimestamp time.Time\n+}\n+\n+// MetricResults queries for all metric values that match a given filter.\n+type MetricResults struct {", "originalCommit": "9e4968ce09ebbc6f11357f70dcbafda819d047a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA0NTIyMA==", "url": "https://github.com/apache/beam/pull/13272#discussion_r520045220", "bodyText": "Please drop the \"Metric\" prefix when putting things into the metrics package.\nOtherwise users of this type will always be typing metrics.MetricKey\nThere are also metrics that aren't associated with DoFns (eg PCollection specific ones), that may warrant different key types, rather than a \"global\" key.  Maybe DoFnKey or StepKey?\nConsider documenting what this is used for, rather than what it is. \"StepKey uniquely identifies a metric\"", "author": "lostluck", "createdAt": "2020-11-09T18:59:47Z", "path": "sdks/go/pkg/beam/core/metrics/metrics.go", "diffHunk": "@@ -448,3 +453,73 @@ func (m *gauge) get() (int64, time.Time) {\n \tdefer m.mu.Unlock()\n \treturn m.v, m.t\n }\n+\n+// GaugeValue is the value of a Gauge metric.\n+type GaugeValue struct {\n+\tValue     int64\n+\tTimestamp time.Time\n+}\n+\n+// MetricResults queries for all metric values that match a given filter.\n+type MetricResults struct {\n+\tCounters      []CounterResult\n+\tDistributions []DistributionResult\n+\tGauges        []GaugeResult\n+}\n+\n+// AllMetrics returns all metrics from a MetricResults instance.\n+func (mr MetricResults) AllMetrics() MetricQueryResults {\n+\treturn MetricQueryResults{mr.Counters, mr.Distributions, mr.Gauges}\n+}\n+\n+// TODO: Implement Query(MetricsFilter) and metrics filtering\n+\n+// MetricQueryResults is the results of a query. Allows accessing all of the\n+// metrics that matched the filter.\n+type MetricQueryResults struct {\n+\tcounters      []CounterResult\n+\tdistributions []DistributionResult\n+\tgauges        []GaugeResult\n+}\n+\n+// GetCounters returns an array of counter metrics.\n+func (qr MetricQueryResults) GetCounters() []CounterResult {\n+\treturn qr.counters\n+}\n+\n+// GetDistributions returns an array of distribution metrics.\n+func (qr MetricQueryResults) GetDistributions() []DistributionResult {\n+\treturn qr.distributions\n+}\n+\n+// GetGauges returns an array of gauges metrics.\n+func (qr MetricQueryResults) GetGauges() []GaugeResult {\n+\treturn qr.gauges\n+}\n+\n+// CounterResult is an attempted and a commited value of a Counter metric plus\n+// key.\n+type CounterResult struct {\n+\tAttempted, Committed int64\n+\tKey                  MetricKey\n+}\n+\n+// DistributionResult is an attempted and a commited value of a Distribution\n+// metric plus key.\n+type DistributionResult struct {\n+\tAttempted, Committed DistributionValue\n+\tKey                  MetricKey\n+}\n+\n+// GaugeResult is an attempted and a commited value of a Gauge metric plus\n+// key.\n+type GaugeResult struct {\n+\tAttempted, Committed GaugeValue\n+\tKey                  MetricKey\n+}\n+\n+// MetricKey includes the namespace and the name of the metric, as well as\n+// the step that reported the metric.\n+type MetricKey struct {", "originalCommit": "9e4968ce09ebbc6f11357f70dcbafda819d047a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYxMTU2OA==", "url": "https://github.com/apache/beam/pull/13272#discussion_r520611568", "bodyText": "StepKey sounds good. Thanks for suggestion.", "author": "kamilwu", "createdAt": "2020-11-10T14:38:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA0NTIyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA1NTk1OQ==", "url": "https://github.com/apache/beam/pull/13272#discussion_r520055959", "bodyText": "Why not return a metrics.Results instead? Is the intent to force a breaking change if a new class of results is added?\nConversely, by using a metrics.Results, no such breaking change needs to happen, and things can change more gracefully (such as when generics land in Go).", "author": "lostluck", "createdAt": "2020-11-09T19:11:23Z", "path": "sdks/go/pkg/beam/core/monitoring/monitoring.go", "diffHunk": "@@ -341,3 +343,189 @@ func int64Distribution(count, sum, min, max int64) ([]byte, error) {\n \t}\n \treturn buf.Bytes(), nil\n }\n+\n+// FromMonitoringInfos extracts metrics from GetJobMetrics's response and\n+// groups them into counters, distributions and gauges.\n+func FromMonitoringInfos(attempted []*pipepb.MonitoringInfo, committed []*pipepb.MonitoringInfo) (\n+\t[]metrics.CounterResult,\n+\t[]metrics.DistributionResult,\n+\t[]metrics.GaugeResult) {", "originalCommit": "9e4968ce09ebbc6f11357f70dcbafda819d047a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYxMDM3Mw==", "url": "https://github.com/apache/beam/pull/13272#discussion_r520610373", "bodyText": "Good spot! Of course it should return metrics.Results. Thanks.", "author": "kamilwu", "createdAt": "2020-11-10T14:37:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA1NTk1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA2MDkxOQ==", "url": "https://github.com/apache/beam/pull/13272#discussion_r520060919", "bodyText": "Same comment that I had before about consider changing this if-else ladder into a switch/case statement.", "author": "lostluck", "createdAt": "2020-11-09T19:19:31Z", "path": "sdks/go/pkg/beam/core/monitoring/monitoring.go", "diffHunk": "@@ -341,3 +343,189 @@ func int64Distribution(count, sum, min, max int64) ([]byte, error) {\n \t}\n \treturn buf.Bytes(), nil\n }\n+\n+// FromMonitoringInfos extracts metrics from GetJobMetrics's response and\n+// groups them into counters, distributions and gauges.\n+func FromMonitoringInfos(attempted []*pipepb.MonitoringInfo, committed []*pipepb.MonitoringInfo) (\n+\t[]metrics.CounterResult,\n+\t[]metrics.DistributionResult,\n+\t[]metrics.GaugeResult) {\n+\tac, ad, ag := groupByType(attempted)\n+\tcc, cd, cg := groupByType(committed)\n+\n+\tc := mergeCounters(ac, cc)\n+\td := mergeDistributions(ad, cd)\n+\tg := mergeGauges(ag, cg)\n+\n+\treturn c, d, g\n+}\n+\n+// IsCounter returns true if the monitoring info is a counter metric.\n+func IsCounter(mi *pipepb.MonitoringInfo) bool {\n+\treturn mi.GetType() == \"beam:metrics:sum_int64:v1\"\n+}\n+\n+// IsDistribution returns true if the monitoring info is a distribution metric.\n+func IsDistribution(mi *pipepb.MonitoringInfo) bool {\n+\treturn mi.GetType() == \"beam:metrics:distribution_int64:v1\"\n+}\n+\n+// IsGauge returns true if the monitoring info is a gauge metric.\n+func IsGauge(mi *pipepb.MonitoringInfo) bool {\n+\tswitch mi.GetType() {\n+\tcase\n+\t\t\"beam:metrics:latest_int64:v1\",\n+\t\t\"beam:metrics:top_n_int64:v1\",\n+\t\t\"beam:metrics:bottom_n_int64:v1\":\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func groupByType(minfos []*pipepb.MonitoringInfo) (\n+\tmap[metrics.MetricKey]int64,\n+\tmap[metrics.MetricKey]metrics.DistributionValue,\n+\tmap[metrics.MetricKey]metrics.GaugeValue) {\n+\tcounters := make(map[metrics.MetricKey]int64)\n+\tdistributions := make(map[metrics.MetricKey]metrics.DistributionValue)\n+\tgauges := make(map[metrics.MetricKey]metrics.GaugeValue)\n+\n+\tfor _, minfo := range minfos {\n+\t\tkey, err := extractKey(minfo)\n+\t\tif err != nil {\n+\t\t\tlog.Println(err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tr := bytes.NewReader(minfo.GetPayload())\n+\n+\t\tif IsCounter(minfo) {", "originalCommit": "9e4968ce09ebbc6f11357f70dcbafda819d047a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYxMzE5OA==", "url": "https://github.com/apache/beam/pull/13272#discussion_r520613198", "bodyText": "Changed it into a switch/case statement. Do you think that using raw strings is ok? Or should I define a new enum type for representing different types of metrics?", "author": "kamilwu", "createdAt": "2020-11-10T14:40:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA2MDkxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA2MTc1OQ==", "url": "https://github.com/apache/beam/pull/13272#discussion_r520061759", "bodyText": "This function doesn't do anything other than serve as a comment. Consider simply calling labels.Transform() directly at the only call site.", "author": "lostluck", "createdAt": "2020-11-09T19:20:52Z", "path": "sdks/go/pkg/beam/core/monitoring/monitoring.go", "diffHunk": "@@ -341,3 +343,189 @@ func int64Distribution(count, sum, min, max int64) ([]byte, error) {\n \t}\n \treturn buf.Bytes(), nil\n }\n+\n+// FromMonitoringInfos extracts metrics from GetJobMetrics's response and\n+// groups them into counters, distributions and gauges.\n+func FromMonitoringInfos(attempted []*pipepb.MonitoringInfo, committed []*pipepb.MonitoringInfo) (\n+\t[]metrics.CounterResult,\n+\t[]metrics.DistributionResult,\n+\t[]metrics.GaugeResult) {\n+\tac, ad, ag := groupByType(attempted)\n+\tcc, cd, cg := groupByType(committed)\n+\n+\tc := mergeCounters(ac, cc)\n+\td := mergeDistributions(ad, cd)\n+\tg := mergeGauges(ag, cg)\n+\n+\treturn c, d, g\n+}\n+\n+// IsCounter returns true if the monitoring info is a counter metric.\n+func IsCounter(mi *pipepb.MonitoringInfo) bool {\n+\treturn mi.GetType() == \"beam:metrics:sum_int64:v1\"\n+}\n+\n+// IsDistribution returns true if the monitoring info is a distribution metric.\n+func IsDistribution(mi *pipepb.MonitoringInfo) bool {\n+\treturn mi.GetType() == \"beam:metrics:distribution_int64:v1\"\n+}\n+\n+// IsGauge returns true if the monitoring info is a gauge metric.\n+func IsGauge(mi *pipepb.MonitoringInfo) bool {\n+\tswitch mi.GetType() {\n+\tcase\n+\t\t\"beam:metrics:latest_int64:v1\",\n+\t\t\"beam:metrics:top_n_int64:v1\",\n+\t\t\"beam:metrics:bottom_n_int64:v1\":\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func groupByType(minfos []*pipepb.MonitoringInfo) (\n+\tmap[metrics.MetricKey]int64,\n+\tmap[metrics.MetricKey]metrics.DistributionValue,\n+\tmap[metrics.MetricKey]metrics.GaugeValue) {\n+\tcounters := make(map[metrics.MetricKey]int64)\n+\tdistributions := make(map[metrics.MetricKey]metrics.DistributionValue)\n+\tgauges := make(map[metrics.MetricKey]metrics.GaugeValue)\n+\n+\tfor _, minfo := range minfos {\n+\t\tkey, err := extractKey(minfo)\n+\t\tif err != nil {\n+\t\t\tlog.Println(err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tr := bytes.NewReader(minfo.GetPayload())\n+\n+\t\tif IsCounter(minfo) {\n+\t\t\tvalue, err := extractCounterValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tcounters[key] = value\n+\t\t} else if IsDistribution(minfo) {\n+\t\t\tvalue, err := extractDistributionValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tdistributions[key] = value\n+\t\t} else if IsGauge(minfo) {\n+\t\t\tvalue, err := extractGaugeValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tgauges[key] = value\n+\t\t} else {\n+\t\t\tlog.Println(\"unknown metric type\")\n+\t\t}\n+\t}\n+\treturn counters, distributions, gauges\n+}\n+\n+func mergeCounters(\n+\tattempted map[metrics.MetricKey]int64,\n+\tcommitted map[metrics.MetricKey]int64) []metrics.CounterResult {\n+\tres := make([]metrics.CounterResult, 0)\n+\n+\tfor k := range attempted {\n+\t\tv, ok := committed[k]\n+\t\tif !ok {\n+\t\t\tv = -1\n+\t\t}\n+\t\tres = append(res, metrics.CounterResult{Attempted: attempted[k], Committed: v, Key: k})\n+\t}\n+\treturn res\n+}\n+\n+func mergeDistributions(\n+\tattempted map[metrics.MetricKey]metrics.DistributionValue,\n+\tcommitted map[metrics.MetricKey]metrics.DistributionValue) []metrics.DistributionResult {\n+\tres := make([]metrics.DistributionResult, 0)\n+\n+\tfor k := range attempted {\n+\t\tv, ok := committed[k]\n+\t\tif !ok {\n+\t\t\tv = metrics.DistributionValue{}\n+\t\t}\n+\t\tres = append(res, metrics.DistributionResult{Attempted: attempted[k], Committed: v, Key: k})\n+\t}\n+\treturn res\n+}\n+\n+func mergeGauges(\n+\tattempted map[metrics.MetricKey]metrics.GaugeValue,\n+\tcommitted map[metrics.MetricKey]metrics.GaugeValue) []metrics.GaugeResult {\n+\tres := make([]metrics.GaugeResult, 0)\n+\n+\tfor k := range attempted {\n+\t\tv, ok := committed[k]\n+\t\tif !ok {\n+\t\t\tv = metrics.GaugeValue{}\n+\t\t}\n+\t\tres = append(res, metrics.GaugeResult{Attempted: attempted[k], Committed: v, Key: k})\n+\t}\n+\treturn res\n+}\n+\n+func extractKey(mi *pipepb.MonitoringInfo) (metrics.MetricKey, error) {\n+\tlabels := newLabels(mi.GetLabels())\n+\tstepName := getStepName(labels)\n+\tif stepName == \"\" {\n+\t\treturn metrics.MetricKey{}, fmt.Errorf(\"Failed to deduce Step from MonitoringInfo: %v\", mi)\n+\t}\n+\treturn metrics.MetricKey{Step: stepName, Name: labels.Name(), Namespace: labels.Namespace()}, nil\n+}\n+\n+func extractCounterValue(reader *bytes.Reader) (int64, error) {\n+\tvalue, err := coder.DecodeVarInt(reader)\n+\tif err != nil {\n+\t\treturn -1, err\n+\t}\n+\treturn value, nil\n+}\n+\n+func extractDistributionValue(reader *bytes.Reader) (metrics.DistributionValue, error) {\n+\tvalues, err := decodeMany(reader, 4)\n+\tif err != nil {\n+\t\treturn metrics.DistributionValue{}, err\n+\t}\n+\treturn metrics.DistributionValue{Count: values[0], Sum: values[1], Min: values[2], Max: values[3]}, nil\n+}\n+\n+func extractGaugeValue(reader *bytes.Reader) (metrics.GaugeValue, error) {\n+\tvalues, err := decodeMany(reader, 2)\n+\tif err != nil {\n+\t\treturn metrics.GaugeValue{}, err\n+\t}\n+\treturn metrics.GaugeValue{Timestamp: time.Unix(0, values[0]*int64(time.Millisecond)), Value: values[1]}, nil\n+}\n+\n+func newLabels(miLabels map[string]string) *metrics.Labels {\n+\tlabels := metrics.UserLabels(\n+\t\tmiLabels[\"PTRANSFORM\"],\n+\t\tmiLabels[pipepb.MonitoringInfo_NAMESPACE.String()],\n+\t\tmiLabels[pipepb.MonitoringInfo_NAME.String()])\n+\treturn &labels\n+}\n+\n+func getStepName(labels *metrics.Labels) string {\n+\treturn labels.Transform()\n+}", "originalCommit": "9e4968ce09ebbc6f11357f70dcbafda819d047a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA2MzA3MQ==", "url": "https://github.com/apache/beam/pull/13272#discussion_r520063071", "bodyText": "Consider just using the constants\"NAMESPACE\" and \"NAME\". Or go the other way, and pull PTRANSFORM from the enum instead. The inconsistency is odd.", "author": "lostluck", "createdAt": "2020-11-09T19:23:01Z", "path": "sdks/go/pkg/beam/core/monitoring/monitoring.go", "diffHunk": "@@ -341,3 +343,189 @@ func int64Distribution(count, sum, min, max int64) ([]byte, error) {\n \t}\n \treturn buf.Bytes(), nil\n }\n+\n+// FromMonitoringInfos extracts metrics from GetJobMetrics's response and\n+// groups them into counters, distributions and gauges.\n+func FromMonitoringInfos(attempted []*pipepb.MonitoringInfo, committed []*pipepb.MonitoringInfo) (\n+\t[]metrics.CounterResult,\n+\t[]metrics.DistributionResult,\n+\t[]metrics.GaugeResult) {\n+\tac, ad, ag := groupByType(attempted)\n+\tcc, cd, cg := groupByType(committed)\n+\n+\tc := mergeCounters(ac, cc)\n+\td := mergeDistributions(ad, cd)\n+\tg := mergeGauges(ag, cg)\n+\n+\treturn c, d, g\n+}\n+\n+// IsCounter returns true if the monitoring info is a counter metric.\n+func IsCounter(mi *pipepb.MonitoringInfo) bool {\n+\treturn mi.GetType() == \"beam:metrics:sum_int64:v1\"\n+}\n+\n+// IsDistribution returns true if the monitoring info is a distribution metric.\n+func IsDistribution(mi *pipepb.MonitoringInfo) bool {\n+\treturn mi.GetType() == \"beam:metrics:distribution_int64:v1\"\n+}\n+\n+// IsGauge returns true if the monitoring info is a gauge metric.\n+func IsGauge(mi *pipepb.MonitoringInfo) bool {\n+\tswitch mi.GetType() {\n+\tcase\n+\t\t\"beam:metrics:latest_int64:v1\",\n+\t\t\"beam:metrics:top_n_int64:v1\",\n+\t\t\"beam:metrics:bottom_n_int64:v1\":\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func groupByType(minfos []*pipepb.MonitoringInfo) (\n+\tmap[metrics.MetricKey]int64,\n+\tmap[metrics.MetricKey]metrics.DistributionValue,\n+\tmap[metrics.MetricKey]metrics.GaugeValue) {\n+\tcounters := make(map[metrics.MetricKey]int64)\n+\tdistributions := make(map[metrics.MetricKey]metrics.DistributionValue)\n+\tgauges := make(map[metrics.MetricKey]metrics.GaugeValue)\n+\n+\tfor _, minfo := range minfos {\n+\t\tkey, err := extractKey(minfo)\n+\t\tif err != nil {\n+\t\t\tlog.Println(err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tr := bytes.NewReader(minfo.GetPayload())\n+\n+\t\tif IsCounter(minfo) {\n+\t\t\tvalue, err := extractCounterValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tcounters[key] = value\n+\t\t} else if IsDistribution(minfo) {\n+\t\t\tvalue, err := extractDistributionValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tdistributions[key] = value\n+\t\t} else if IsGauge(minfo) {\n+\t\t\tvalue, err := extractGaugeValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tgauges[key] = value\n+\t\t} else {\n+\t\t\tlog.Println(\"unknown metric type\")\n+\t\t}\n+\t}\n+\treturn counters, distributions, gauges\n+}\n+\n+func mergeCounters(\n+\tattempted map[metrics.MetricKey]int64,\n+\tcommitted map[metrics.MetricKey]int64) []metrics.CounterResult {\n+\tres := make([]metrics.CounterResult, 0)\n+\n+\tfor k := range attempted {\n+\t\tv, ok := committed[k]\n+\t\tif !ok {\n+\t\t\tv = -1\n+\t\t}\n+\t\tres = append(res, metrics.CounterResult{Attempted: attempted[k], Committed: v, Key: k})\n+\t}\n+\treturn res\n+}\n+\n+func mergeDistributions(\n+\tattempted map[metrics.MetricKey]metrics.DistributionValue,\n+\tcommitted map[metrics.MetricKey]metrics.DistributionValue) []metrics.DistributionResult {\n+\tres := make([]metrics.DistributionResult, 0)\n+\n+\tfor k := range attempted {\n+\t\tv, ok := committed[k]\n+\t\tif !ok {\n+\t\t\tv = metrics.DistributionValue{}\n+\t\t}\n+\t\tres = append(res, metrics.DistributionResult{Attempted: attempted[k], Committed: v, Key: k})\n+\t}\n+\treturn res\n+}\n+\n+func mergeGauges(\n+\tattempted map[metrics.MetricKey]metrics.GaugeValue,\n+\tcommitted map[metrics.MetricKey]metrics.GaugeValue) []metrics.GaugeResult {\n+\tres := make([]metrics.GaugeResult, 0)\n+\n+\tfor k := range attempted {\n+\t\tv, ok := committed[k]\n+\t\tif !ok {\n+\t\t\tv = metrics.GaugeValue{}\n+\t\t}\n+\t\tres = append(res, metrics.GaugeResult{Attempted: attempted[k], Committed: v, Key: k})\n+\t}\n+\treturn res\n+}\n+\n+func extractKey(mi *pipepb.MonitoringInfo) (metrics.MetricKey, error) {\n+\tlabels := newLabels(mi.GetLabels())\n+\tstepName := getStepName(labels)\n+\tif stepName == \"\" {\n+\t\treturn metrics.MetricKey{}, fmt.Errorf(\"Failed to deduce Step from MonitoringInfo: %v\", mi)\n+\t}\n+\treturn metrics.MetricKey{Step: stepName, Name: labels.Name(), Namespace: labels.Namespace()}, nil\n+}\n+\n+func extractCounterValue(reader *bytes.Reader) (int64, error) {\n+\tvalue, err := coder.DecodeVarInt(reader)\n+\tif err != nil {\n+\t\treturn -1, err\n+\t}\n+\treturn value, nil\n+}\n+\n+func extractDistributionValue(reader *bytes.Reader) (metrics.DistributionValue, error) {\n+\tvalues, err := decodeMany(reader, 4)\n+\tif err != nil {\n+\t\treturn metrics.DistributionValue{}, err\n+\t}\n+\treturn metrics.DistributionValue{Count: values[0], Sum: values[1], Min: values[2], Max: values[3]}, nil\n+}\n+\n+func extractGaugeValue(reader *bytes.Reader) (metrics.GaugeValue, error) {\n+\tvalues, err := decodeMany(reader, 2)\n+\tif err != nil {\n+\t\treturn metrics.GaugeValue{}, err\n+\t}\n+\treturn metrics.GaugeValue{Timestamp: time.Unix(0, values[0]*int64(time.Millisecond)), Value: values[1]}, nil\n+}\n+\n+func newLabels(miLabels map[string]string) *metrics.Labels {\n+\tlabels := metrics.UserLabels(\n+\t\tmiLabels[\"PTRANSFORM\"],\n+\t\tmiLabels[pipepb.MonitoringInfo_NAMESPACE.String()],", "originalCommit": "9e4968ce09ebbc6f11357f70dcbafda819d047a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYyMzQ3Mg==", "url": "https://github.com/apache/beam/pull/13272#discussion_r520623472", "bodyText": "pipepb.MonitoringInfo_PTRANSFORM.String() keeps returning TRANSFORM, without the \"P\" prefix. I'm not sure why is that, TRANSFORM is invalid in this context and we should use PTRANSFORM. I changed it so that only the constants are used.\nJust out of my curiosity, why the generated .pb.go files are committed into a git repository? for example:  https://github.com/apache/beam/tree/master/sdks/go/pkg/beam/model/pipeline_v1. Is there some kind of problem with generating those files locally?", "author": "kamilwu", "createdAt": "2020-11-10T14:53:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA2MzA3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY5NDcwMg==", "url": "https://github.com/apache/beam/pull/13272#discussion_r521694702", "bodyText": "I think it's a legacy issue that hasn't migrated yet. I'm surprised, I thought lcwik handled that already. I'd add a comment about the discrepancy then. It's likely a legacy issue then. I see the existing monitoring code uses \"PTRANSFORM\" as a result too.\n\nRegarding the protos: Great question! Please bear with the length of this topic.\nThe short answer is: that's the idiom for generated Go files: submit them.\nJava relies heavily on external build/package management to create jars, which contain the code generated from the PBs.\nPython uses a one time setup script users use to do so locally, and an abundance of external management (pip, pyenv etc)\nThey also deliver everything via archives/wheels/jars.\nGo on the other hand deliberately avoids those approaches, and pointedly delivers everything via open source code. This works reasonably well in this day and age, of micro services. If you really want to deliver something a client runs on their machine, without delivering the source, a binary happens, or you simply spin up a service on the internet. No source needed.\nOne of Go's better touted features is that binaries are generally statically compiled without needing specific DLLs or other libaries resident on the OS.\nWhile this can lead to larger binaries, that's certainly less of a problem than before with how cheap storage and RAM is these days.\nFurther, Go has made it's way by having excellent tooling around testing and packages and execution. If you want to install a binary that's available as go code? You go install it and the tool takes care of the rest. However, there are limits to that. Go's build cycle deliberately doesn't invoke other processes, including additional code generators like the proto compiler.\nThere is support for pre-build time code generation, using the go generate command\nSpecifically, idiomatically, package users should never need to run go generate to get one of their received libraries to work. go generate is for package authors, not users.\nAs a result, anything generated by that command ends up needing to be committed to allow the users to access it.\nSo to answer the question again: that approach isn't desirable from a user point of view, as it assumes and forces our implementation details on the user, instead of centralizing them on the project.\n\nThis can then devolve into Go Package versioning, and the short answer there is, the Go Beam SDK doesn't currently respect versions, and won't until we migrate it to use Go Modules. Hopefully soon. After I finish Schemas and this Beam Release work...", "author": "lostluck", "createdAt": "2020-11-11T23:16:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA2MzA3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI4ODY5Nw==", "url": "https://github.com/apache/beam/pull/13272#discussion_r522288697", "bodyText": "That's a wonderful summary! From my point of view, as a contributor, I can add that it was tricky to get the go generate command to work. Missing system-wide dependencies (like protobuf headers), path problems in the gen.go file, etc. In Python SDK it's much easier, as all you need to do is too install build dependencies into a virtual environment.\nIt makes sense now to commit those files to the repo.", "author": "kamilwu", "createdAt": "2020-11-12T17:33:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA2MzA3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM0NDkyOA==", "url": "https://github.com/apache/beam/pull/13272#discussion_r522344928", "bodyText": "This will certainly become easier once we're on Go Modules. Right now it's tricky due to ensuring we have the right versions of the proto code generators.  Heck, at a certain point, one could script installing protoc and installing the go proto plugin so go generate for the protos is fairly self contained for contributors.\nNothing you've been doing in this PR requires re-generating the protos, or code generated type assertion \"shims\", so hopefully you haven't run into places where it was implied that was necessary.", "author": "lostluck", "createdAt": "2020-11-12T19:02:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDA2MzA3MQ=="}], "type": "inlineReview"}, {"oid": "f87a7b96cd08271d00750b8598c4fa96fedb7bd3", "url": "https://github.com/apache/beam/commit/f87a7b96cd08271d00750b8598c4fa96fedb7bd3", "message": "fix: create metricsx package that exports urn constants and payload encoding helpers", "committedDate": "2020-11-10T12:32:08Z", "type": "commit"}, {"oid": "2596fb76edd925c4c54e2d33fc08b453355d5411", "url": "https://github.com/apache/beam/commit/2596fb76edd925c4c54e2d33fc08b453355d5411", "message": "fix: review changes", "committedDate": "2020-11-10T13:24:07Z", "type": "commit"}, {"oid": "9bbc69ca1befdc5e5c62a58aff4e237527ca7ee7", "url": "https://github.com/apache/beam/commit/9bbc69ca1befdc5e5c62a58aff4e237527ca7ee7", "message": "fix: add jira ticket id", "committedDate": "2020-11-10T14:25:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYzMzY0MQ==", "url": "https://github.com/apache/beam/pull/13272#discussion_r520633641", "bodyText": "Perhaps we could skip these getters and expose QueryResults's fields directly. We don't need to follow Java API that much. @lostluck What do you think?", "author": "kamilwu", "createdAt": "2020-11-10T15:06:16Z", "path": "sdks/go/pkg/beam/core/metrics/metrics.go", "diffHunk": "@@ -448,3 +453,73 @@ func (m *gauge) get() (int64, time.Time) {\n \tdefer m.mu.Unlock()\n \treturn m.v, m.t\n }\n+\n+// GaugeValue is the value of a Gauge metric.\n+type GaugeValue struct {\n+\tValue     int64\n+\tTimestamp time.Time\n+}\n+\n+// Results represents all metrics gathered during the job's execution.\n+// It allows for querying metrics using a provided filter.\n+type Results struct {\n+\tcounters      []CounterResult\n+\tdistributions []DistributionResult\n+\tgauges        []GaugeResult\n+}\n+\n+// AllMetrics returns all metrics from a Results instance.\n+func (mr Results) AllMetrics() QueryResults {\n+\treturn QueryResults{mr.counters, mr.distributions, mr.gauges}\n+}\n+\n+// TODO(BEAM-11217): Implement Query(Filter) and metrics filtering\n+\n+// QueryResults is the result of a query. Allows accessing all of the\n+// metrics that matched the filter.\n+type QueryResults struct {\n+\tcounters      []CounterResult\n+\tdistributions []DistributionResult\n+\tgauges        []GaugeResult\n+}\n+\n+// GetCounters returns an array of counter metrics.\n+func (qr QueryResults) GetCounters() []CounterResult {", "originalCommit": "9bbc69ca1befdc5e5c62a58aff4e237527ca7ee7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY5OTE2Ng==", "url": "https://github.com/apache/beam/pull/13272#discussion_r521699166", "bodyText": "That would still be idiomatic go. The question is whether we need to \"hide\" this behind an interface or not. I'm leaning no to that.\nThe real \"trick\" is probably copying out the results so users can query/mutate their own copies freely, without worrying about aliasing issues. Slices are not immutable, and are a pointer to a backing array which can be shared by multiple headers. The current method sets have just as many aliasing issues as having raw fields, so the fields aren't helping much.\nIdiomatically BTW if we were keeping these methods, we wouldn't have the Get* prefix which is very much a javaism.", "author": "lostluck", "createdAt": "2020-11-11T23:23:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYzMzY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI3Njg1Mw==", "url": "https://github.com/apache/beam/pull/13272#discussion_r522276853", "bodyText": "Let's keep these methods, but remove the Get* prefix.\nRegarding the results, a safer option is probably to return their copies instead. The structs don't have any underlying pointers, so it's not a problem to use built-in copy function.", "author": "kamilwu", "createdAt": "2020-11-12T17:18:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYzMzY0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTcwNjc4NQ==", "url": "https://github.com/apache/beam/pull/13272#discussion_r521706785", "bodyText": "Consider moving the contents of this file into the new metricx package, which is where I thought it was going to move last time. Any specific reason this code can't go there instead of this metrics package?\nPart of the separation we have is to avoid having the protos dependended on by the same user construction packages, which is why there are x and non-x versions of packages for the most part.\nEg. Graph which is a pure go representation of handling the pipeline graph, and graphx which translates that graph into the proto representation. Similarly, the coder and coderx packages which are the representation of the coders, and the actual execution of the coders.\nThis notionally allows much of the Go SDK front end to be re-used for a non-beam backend without depending on the beam proto structure, and keeps the protos away from pipeline authors, for whome the protos should be implementation details.\nSpecifically, we try to hide the proto details from pipeline authors, not runner authors. Runner authors have to deal with the protos by definition, but pipeline authors  should need a limited subset of those, and certainly not the protos. We try to have most user facing things be part of the beam package, but that's not appropriate for everything (it makes the package too big, too central, and harder to maintain).", "author": "lostluck", "createdAt": "2020-11-11T23:40:21Z", "path": "sdks/go/pkg/beam/core/metrics/monitoring_infos.go", "diffHunk": "@@ -0,0 +1,176 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package metrics\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"log\"\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/coder\"\n+\tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"", "originalCommit": "9bbc69ca1befdc5e5c62a58aff4e237527ca7ee7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI3MjQzNA==", "url": "https://github.com/apache/beam/pull/13272#discussion_r522272434", "bodyText": "Thanks, now I understand that distinction between x and non-x versions of packages. I moved this code to the metricsx package.\nWhen it comes to urns constants and encoding helpers, I moved them to urns.go file within the same package (metricsx)", "author": "kamilwu", "createdAt": "2020-11-12T17:11:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTcwNjc4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMzMDYxMg==", "url": "https://github.com/apache/beam/pull/13272#discussion_r522330612", "bodyText": "That's a good move. Go packages can be spread over multiple files as needed.", "author": "lostluck", "createdAt": "2020-11-12T18:39:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTcwNjc4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTcwNzI0MA==", "url": "https://github.com/apache/beam/pull/13272#discussion_r521707240", "bodyText": "Similarly, these tests should be in the metricsx package.", "author": "lostluck", "createdAt": "2020-11-11T23:41:41Z", "path": "sdks/go/pkg/beam/core/metrics/monitoring_infos_test.go", "diffHunk": "@@ -0,0 +1,165 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package metrics\n+\n+import (\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/metricsx\"\n+\tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+)\n+\n+func TestCounterExtraction(t *testing.T) {", "originalCommit": "9bbc69ca1befdc5e5c62a58aff4e237527ca7ee7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTcxMDkwNQ==", "url": "https://github.com/apache/beam/pull/13272#discussion_r521710905", "bodyText": "Is it necessary to isolate this part in it's own function? It's only used in the \"newUniversalPipelineResult\" which takes all the same arguments.  If this is tested separately sure, but I don't see a reason to do that separately from the newUniversalPipelineResult for the previous reason.", "author": "lostluck", "createdAt": "2020-11-11T23:53:19Z", "path": "sdks/go/pkg/beam/runners/universal/runnerlib/execute.go", "diffHunk": "@@ -79,15 +81,50 @@ func Execute(ctx context.Context, p *pipepb.Pipeline, endpoint string, opt *JobO\n \n \tjobID, err := Submit(ctx, client, prepID, token)\n \tif err != nil {\n-\t\treturn \"\", err\n+\t\treturn presult, err\n \t}\n \n \tlog.Infof(ctx, \"Submitted job: %v\", jobID)\n \n \t// (4) Wait for completion.\n \n \tif async {\n-\t\treturn jobID, nil\n+\t\treturn presult, nil\n \t}\n-\treturn jobID, WaitForCompletion(ctx, client, jobID)\n+\terr = WaitForCompletion(ctx, client, jobID)\n+\n+\tres, err := newUniversalPipelineResult(ctx, jobID, client)\n+\tif err != nil {\n+\t\treturn presult, err\n+\t}\n+\tpresult = res\n+\n+\treturn presult, err\n+}\n+\n+type universalPipelineResult struct {\n+\tJobID   string\n+\tmetrics *metrics.Results\n+}\n+\n+func newUniversalPipelineResult(ctx context.Context, jobID string, client jobpb.JobServiceClient) (*universalPipelineResult, error) {\n+\tmetrics, err := getMetrics(ctx, jobID, client)\n+\tif err != nil {\n+\t\treturn &universalPipelineResult{jobID, nil}, err\n+\t}\n+\treturn &universalPipelineResult{jobID, metrics}, err\n+}\n+\n+func (pr universalPipelineResult) Metrics() metrics.Results {\n+\treturn *pr.metrics\n+}\n+\n+func getMetrics(ctx context.Context, jobID string, client jobpb.JobServiceClient) (*metrics.Results, error) {", "originalCommit": "9bbc69ca1befdc5e5c62a58aff4e237527ca7ee7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "152caca5708ebff7705725c7a9aa1f664d8814b8", "url": "https://github.com/apache/beam/commit/152caca5708ebff7705725c7a9aa1f664d8814b8", "message": "fix: move monitoring_info content to newly created metricsx package", "committedDate": "2020-11-12T16:33:26Z", "type": "commit"}, {"oid": "cfd09d5c451f7242e52ea0eff6fd9de7c65dbcc4", "url": "https://github.com/apache/beam/commit/cfd09d5c451f7242e52ea0eff6fd9de7c65dbcc4", "message": "fix: review changes", "committedDate": "2020-11-12T17:21:39Z", "type": "commit"}, {"oid": "cfd09d5c451f7242e52ea0eff6fd9de7c65dbcc4", "url": "https://github.com/apache/beam/commit/cfd09d5c451f7242e52ea0eff6fd9de7c65dbcc4", "message": "fix: review changes", "committedDate": "2020-11-12T17:21:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM0NzM5NQ==", "url": "https://github.com/apache/beam/pull/13272#discussion_r522347395", "bodyText": "In go comments, it's reasonable to call this \"a slice\". In particular, arrays in Go are fixed size and have different implications compared to variable sized slices. Here and below.\nvar slice []int // a slice of ints\nvar array [4]int // an array of ints of length 4\n\nslice = []int{1,2,3,4}\narray = [4]int{1,2,3,4}\narray = [...]int{1,2,3,4}  // Have the compiler determine the array size based on the construction time parameters\n// array =  [2]int{1, 2} // a compiler error\nslice  = array[1:len(array)] // a slice of array, excluding the first element.\n// This is backed by array, which will lead to aliasing issues if care isn't taken...", "author": "lostluck", "createdAt": "2020-11-12T19:06:23Z", "path": "sdks/go/pkg/beam/core/metrics/metrics.go", "diffHunk": "@@ -448,3 +453,116 @@ func (m *gauge) get() (int64, time.Time) {\n \tdefer m.mu.Unlock()\n \treturn m.v, m.t\n }\n+\n+// GaugeValue is the value of a Gauge metric.\n+type GaugeValue struct {\n+\tValue     int64\n+\tTimestamp time.Time\n+}\n+\n+// Results represents all metrics gathered during the job's execution.\n+// It allows for querying metrics using a provided filter.\n+type Results struct {\n+\tcounters      []CounterResult\n+\tdistributions []DistributionResult\n+\tgauges        []GaugeResult\n+}\n+\n+// NewResults creates a new Results.\n+func NewResults(\n+\tcounters []CounterResult,\n+\tdistributions []DistributionResult,\n+\tgauges []GaugeResult) *Results {\n+\treturn &Results{counters, distributions, gauges}\n+}\n+\n+// AllMetrics returns all metrics from a Results instance.\n+func (mr Results) AllMetrics() QueryResults {\n+\treturn QueryResults{mr.counters, mr.distributions, mr.gauges}\n+}\n+\n+// TODO(BEAM-11217): Implement Query(Filter) and metrics filtering\n+\n+// QueryResults is the result of a query. Allows accessing all of the\n+// metrics that matched the filter.\n+type QueryResults struct {\n+\tcounters      []CounterResult\n+\tdistributions []DistributionResult\n+\tgauges        []GaugeResult\n+}\n+\n+// Counters returns an array of counter metrics.", "originalCommit": "cfd09d5c451f7242e52ea0eff6fd9de7c65dbcc4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM3MDQ4Ng==", "url": "https://github.com/apache/beam/pull/13272#discussion_r522370486", "bodyText": "Since this is a  map to values (rather than pointers), v will already be the zero value for the type. In short, this code is identical to simply v := commited[k]\nhttps://golang.org/doc/effective_go.html#maps", "author": "lostluck", "createdAt": "2020-11-12T19:34:27Z", "path": "sdks/go/pkg/beam/core/runtime/metricsx/metricsx.go", "diffHunk": "@@ -0,0 +1,181 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package metricsx\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"log\"\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/coder\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/metrics\"\n+\tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+)\n+\n+// FromMonitoringInfos extracts metrics from monitored states and\n+// groups them into counters, distributions and gauges.\n+func FromMonitoringInfos(attempted []*pipepb.MonitoringInfo, committed []*pipepb.MonitoringInfo) *metrics.Results {\n+\tac, ad, ag := groupByType(attempted)\n+\tcc, cd, cg := groupByType(committed)\n+\n+\treturn metrics.NewResults(mergeCounters(ac, cc), mergeDistributions(ad, cd), mergeGauges(ag, cg))\n+}\n+\n+func groupByType(minfos []*pipepb.MonitoringInfo) (\n+\tmap[metrics.StepKey]int64,\n+\tmap[metrics.StepKey]metrics.DistributionValue,\n+\tmap[metrics.StepKey]metrics.GaugeValue) {\n+\tcounters := make(map[metrics.StepKey]int64)\n+\tdistributions := make(map[metrics.StepKey]metrics.DistributionValue)\n+\tgauges := make(map[metrics.StepKey]metrics.GaugeValue)\n+\n+\tfor _, minfo := range minfos {\n+\t\tkey, err := extractKey(minfo)\n+\t\tif err != nil {\n+\t\t\tlog.Println(err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tr := bytes.NewReader(minfo.GetPayload())\n+\n+\t\tswitch minfo.GetType() {\n+\t\tcase \"beam:metrics:sum_int64:v1\":\n+\t\t\tvalue, err := extractCounterValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tcounters[key] = value\n+\t\tcase \"beam:metrics:distribution_int64:v1\":\n+\t\t\tvalue, err := extractDistributionValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tdistributions[key] = value\n+\t\tcase\n+\t\t\t\"beam:metrics:latest_int64:v1\",\n+\t\t\t\"beam:metrics:top_n_int64:v1\",\n+\t\t\t\"beam:metrics:bottom_n_int64:v1\":\n+\t\t\tvalue, err := extractGaugeValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tgauges[key] = value\n+\t\tdefault:\n+\t\t\tlog.Println(\"unknown metric type\")\n+\t\t}\n+\t}\n+\treturn counters, distributions, gauges\n+}\n+\n+func mergeCounters(\n+\tattempted map[metrics.StepKey]int64,\n+\tcommitted map[metrics.StepKey]int64) []metrics.CounterResult {\n+\tres := make([]metrics.CounterResult, 0)\n+\n+\tfor k := range attempted {\n+\t\tv, ok := committed[k]\n+\t\tif !ok {\n+\t\t\tv = -1\n+\t\t}\n+\t\tres = append(res, metrics.CounterResult{Attempted: attempted[k], Committed: v, Key: k})\n+\t}\n+\treturn res\n+}\n+\n+func mergeDistributions(\n+\tattempted map[metrics.StepKey]metrics.DistributionValue,\n+\tcommitted map[metrics.StepKey]metrics.DistributionValue) []metrics.DistributionResult {\n+\tres := make([]metrics.DistributionResult, 0)\n+\n+\tfor k := range attempted {\n+\t\tv, ok := committed[k]\n+\t\tif !ok {\n+\t\t\tv = metrics.DistributionValue{}\n+\t\t}", "originalCommit": "cfd09d5c451f7242e52ea0eff6fd9de7c65dbcc4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM3MTMzMA==", "url": "https://github.com/apache/beam/pull/13272#discussion_r522371330", "bodyText": "Is the -1 part of the spec here? Wouldn't a 0 notionally be correct if there are no commited values for a key?", "author": "lostluck", "createdAt": "2020-11-12T19:35:58Z", "path": "sdks/go/pkg/beam/core/runtime/metricsx/metricsx.go", "diffHunk": "@@ -0,0 +1,181 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package metricsx\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"log\"\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/coder\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/metrics\"\n+\tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+)\n+\n+// FromMonitoringInfos extracts metrics from monitored states and\n+// groups them into counters, distributions and gauges.\n+func FromMonitoringInfos(attempted []*pipepb.MonitoringInfo, committed []*pipepb.MonitoringInfo) *metrics.Results {\n+\tac, ad, ag := groupByType(attempted)\n+\tcc, cd, cg := groupByType(committed)\n+\n+\treturn metrics.NewResults(mergeCounters(ac, cc), mergeDistributions(ad, cd), mergeGauges(ag, cg))\n+}\n+\n+func groupByType(minfos []*pipepb.MonitoringInfo) (\n+\tmap[metrics.StepKey]int64,\n+\tmap[metrics.StepKey]metrics.DistributionValue,\n+\tmap[metrics.StepKey]metrics.GaugeValue) {\n+\tcounters := make(map[metrics.StepKey]int64)\n+\tdistributions := make(map[metrics.StepKey]metrics.DistributionValue)\n+\tgauges := make(map[metrics.StepKey]metrics.GaugeValue)\n+\n+\tfor _, minfo := range minfos {\n+\t\tkey, err := extractKey(minfo)\n+\t\tif err != nil {\n+\t\t\tlog.Println(err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tr := bytes.NewReader(minfo.GetPayload())\n+\n+\t\tswitch minfo.GetType() {\n+\t\tcase \"beam:metrics:sum_int64:v1\":\n+\t\t\tvalue, err := extractCounterValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tcounters[key] = value\n+\t\tcase \"beam:metrics:distribution_int64:v1\":\n+\t\t\tvalue, err := extractDistributionValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tdistributions[key] = value\n+\t\tcase\n+\t\t\t\"beam:metrics:latest_int64:v1\",\n+\t\t\t\"beam:metrics:top_n_int64:v1\",\n+\t\t\t\"beam:metrics:bottom_n_int64:v1\":\n+\t\t\tvalue, err := extractGaugeValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tgauges[key] = value\n+\t\tdefault:\n+\t\t\tlog.Println(\"unknown metric type\")\n+\t\t}\n+\t}\n+\treturn counters, distributions, gauges\n+}\n+\n+func mergeCounters(\n+\tattempted map[metrics.StepKey]int64,\n+\tcommitted map[metrics.StepKey]int64) []metrics.CounterResult {\n+\tres := make([]metrics.CounterResult, 0)\n+\n+\tfor k := range attempted {\n+\t\tv, ok := committed[k]\n+\t\tif !ok {\n+\t\t\tv = -1\n+\t\t}", "originalCommit": "cfd09d5c451f7242e52ea0eff6fd9de7c65dbcc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg4OTIyOQ==", "url": "https://github.com/apache/beam/pull/13272#discussion_r522889229", "bodyText": "What if a user created a counter in the pipeline, but the counter hasn't been incremented? If the runner supports committed metrics, the correct value is 0. I'm leaning towards we can't use the same value in \"does not exist\" context. -1 is a good candidate, because it will never be a correct value for a counter.", "author": "kamilwu", "createdAt": "2020-11-13T11:21:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM3MTMzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzEyODEzOQ==", "url": "https://github.com/apache/beam/pull/13272#discussion_r523128139", "bodyText": "If the user created a counter, and no increments occurred, the counter will never appear in the final results. It would be missing entirely. Beam counters operate on a \"diff per bundle\" set up, and the counters aren't known to the runner a-priory, so a runner can't known about them in advanced.\n0 would be correct for committed values that have an attempted value, as no count has been committed.\nI can't think of a useful case of distinguishing between \"does not exist\" for committed only, and simply saying 0.\nAnother reason: users can also use negative values for counters/increments if they so choose. It's not incorrect. So -1 isn't a useful way to signal non-existance.", "author": "lostluck", "createdAt": "2020-11-13T17:58:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM3MTMzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDE0MzIzMQ==", "url": "https://github.com/apache/beam/pull/13272#discussion_r524143231", "bodyText": "TIL. In that case I have on further objections. Let's use 0.", "author": "kamilwu", "createdAt": "2020-11-16T11:18:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM3MTMzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM3MzEyOA==", "url": "https://github.com/apache/beam/pull/13272#discussion_r522373128", "bodyText": "In Go, if a non-nil error is returned, conventionally the non-error returns should be ignored. There's no need to have a special marker value for an error, since that's what the error is for. Specifically if the value returned is still valid in some way when an error is returned, that is the exception, and should be documented.\n(As it literally doesn't matter, no change required here, so just pointing it out for teaching purposes.)", "author": "lostluck", "createdAt": "2020-11-12T19:39:21Z", "path": "sdks/go/pkg/beam/core/runtime/metricsx/metricsx.go", "diffHunk": "@@ -0,0 +1,181 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package metricsx\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"log\"\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/coder\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/metrics\"\n+\tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+)\n+\n+// FromMonitoringInfos extracts metrics from monitored states and\n+// groups them into counters, distributions and gauges.\n+func FromMonitoringInfos(attempted []*pipepb.MonitoringInfo, committed []*pipepb.MonitoringInfo) *metrics.Results {\n+\tac, ad, ag := groupByType(attempted)\n+\tcc, cd, cg := groupByType(committed)\n+\n+\treturn metrics.NewResults(mergeCounters(ac, cc), mergeDistributions(ad, cd), mergeGauges(ag, cg))\n+}\n+\n+func groupByType(minfos []*pipepb.MonitoringInfo) (\n+\tmap[metrics.StepKey]int64,\n+\tmap[metrics.StepKey]metrics.DistributionValue,\n+\tmap[metrics.StepKey]metrics.GaugeValue) {\n+\tcounters := make(map[metrics.StepKey]int64)\n+\tdistributions := make(map[metrics.StepKey]metrics.DistributionValue)\n+\tgauges := make(map[metrics.StepKey]metrics.GaugeValue)\n+\n+\tfor _, minfo := range minfos {\n+\t\tkey, err := extractKey(minfo)\n+\t\tif err != nil {\n+\t\t\tlog.Println(err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tr := bytes.NewReader(minfo.GetPayload())\n+\n+\t\tswitch minfo.GetType() {\n+\t\tcase \"beam:metrics:sum_int64:v1\":\n+\t\t\tvalue, err := extractCounterValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tcounters[key] = value\n+\t\tcase \"beam:metrics:distribution_int64:v1\":\n+\t\t\tvalue, err := extractDistributionValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tdistributions[key] = value\n+\t\tcase\n+\t\t\t\"beam:metrics:latest_int64:v1\",\n+\t\t\t\"beam:metrics:top_n_int64:v1\",\n+\t\t\t\"beam:metrics:bottom_n_int64:v1\":\n+\t\t\tvalue, err := extractGaugeValue(r)\n+\t\t\tif err != nil {\n+\t\t\t\tlog.Println(err)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tgauges[key] = value\n+\t\tdefault:\n+\t\t\tlog.Println(\"unknown metric type\")\n+\t\t}\n+\t}\n+\treturn counters, distributions, gauges\n+}\n+\n+func mergeCounters(\n+\tattempted map[metrics.StepKey]int64,\n+\tcommitted map[metrics.StepKey]int64) []metrics.CounterResult {\n+\tres := make([]metrics.CounterResult, 0)\n+\n+\tfor k := range attempted {\n+\t\tv, ok := committed[k]\n+\t\tif !ok {\n+\t\t\tv = -1\n+\t\t}\n+\t\tres = append(res, metrics.CounterResult{Attempted: attempted[k], Committed: v, Key: k})\n+\t}\n+\treturn res\n+}\n+\n+func mergeDistributions(\n+\tattempted map[metrics.StepKey]metrics.DistributionValue,\n+\tcommitted map[metrics.StepKey]metrics.DistributionValue) []metrics.DistributionResult {\n+\tres := make([]metrics.DistributionResult, 0)\n+\n+\tfor k := range attempted {\n+\t\tv, ok := committed[k]\n+\t\tif !ok {\n+\t\t\tv = metrics.DistributionValue{}\n+\t\t}\n+\t\tres = append(res, metrics.DistributionResult{Attempted: attempted[k], Committed: v, Key: k})\n+\t}\n+\treturn res\n+}\n+\n+func mergeGauges(\n+\tattempted map[metrics.StepKey]metrics.GaugeValue,\n+\tcommitted map[metrics.StepKey]metrics.GaugeValue) []metrics.GaugeResult {\n+\tres := make([]metrics.GaugeResult, 0)\n+\n+\tfor k := range attempted {\n+\t\tv, ok := committed[k]\n+\t\tif !ok {\n+\t\t\tv = metrics.GaugeValue{}\n+\t\t}\n+\t\tres = append(res, metrics.GaugeResult{Attempted: attempted[k], Committed: v, Key: k})\n+\t}\n+\treturn res\n+}\n+\n+func extractKey(mi *pipepb.MonitoringInfo) (metrics.StepKey, error) {\n+\tlabels := newLabels(mi.GetLabels())\n+\tstepName := labels.Transform()\n+\tif stepName == \"\" {\n+\t\treturn metrics.StepKey{}, fmt.Errorf(\"Failed to deduce Step from MonitoringInfo: %v\", mi)\n+\t}\n+\treturn metrics.StepKey{Step: stepName, Name: labels.Name(), Namespace: labels.Namespace()}, nil\n+}\n+\n+func extractCounterValue(reader *bytes.Reader) (int64, error) {\n+\tvalue, err := coder.DecodeVarInt(reader)\n+\tif err != nil {\n+\t\treturn -1, err", "originalCommit": "cfd09d5c451f7242e52ea0eff6fd9de7c65dbcc4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM3NDU5Nw==", "url": "https://github.com/apache/beam/pull/13272#discussion_r522374597", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            // StepKey uniquely identifies a metric.\n          \n          \n            \n            // StepKey uniquely identifies a metric within a pipeline graph.", "author": "lostluck", "createdAt": "2020-11-12T19:42:00Z", "path": "sdks/go/pkg/beam/core/metrics/metrics.go", "diffHunk": "@@ -448,3 +453,116 @@ func (m *gauge) get() (int64, time.Time) {\n \tdefer m.mu.Unlock()\n \treturn m.v, m.t\n }\n+\n+// GaugeValue is the value of a Gauge metric.\n+type GaugeValue struct {\n+\tValue     int64\n+\tTimestamp time.Time\n+}\n+\n+// Results represents all metrics gathered during the job's execution.\n+// It allows for querying metrics using a provided filter.\n+type Results struct {\n+\tcounters      []CounterResult\n+\tdistributions []DistributionResult\n+\tgauges        []GaugeResult\n+}\n+\n+// NewResults creates a new Results.\n+func NewResults(\n+\tcounters []CounterResult,\n+\tdistributions []DistributionResult,\n+\tgauges []GaugeResult) *Results {\n+\treturn &Results{counters, distributions, gauges}\n+}\n+\n+// AllMetrics returns all metrics from a Results instance.\n+func (mr Results) AllMetrics() QueryResults {\n+\treturn QueryResults{mr.counters, mr.distributions, mr.gauges}\n+}\n+\n+// TODO(BEAM-11217): Implement Query(Filter) and metrics filtering\n+\n+// QueryResults is the result of a query. Allows accessing all of the\n+// metrics that matched the filter.\n+type QueryResults struct {\n+\tcounters      []CounterResult\n+\tdistributions []DistributionResult\n+\tgauges        []GaugeResult\n+}\n+\n+// Counters returns an array of counter metrics.\n+func (qr QueryResults) Counters() []CounterResult {\n+\tout := make([]CounterResult, len(qr.counters))\n+\tcopy(out, qr.counters)\n+\treturn out\n+}\n+\n+// Distributions returns an array of distribution metrics.\n+func (qr QueryResults) Distributions() []DistributionResult {\n+\tout := make([]DistributionResult, len(qr.distributions))\n+\tcopy(out, qr.distributions)\n+\treturn out\n+}\n+\n+// Gauges returns an array of gauge metrics.\n+func (qr QueryResults) Gauges() []GaugeResult {\n+\tout := make([]GaugeResult, len(qr.gauges))\n+\tcopy(out, qr.gauges)\n+\treturn out\n+}\n+\n+// CounterResult is an attempted and a commited value of a counter metric plus\n+// key.\n+type CounterResult struct {\n+\tAttempted, Committed int64\n+\tKey                  StepKey\n+}\n+\n+// Result returns committed metrics. Falls back to attempted metrics if committed\n+// are not populated (e.g. due to not being supported on a given runner).\n+func (r CounterResult) Result() int64 {\n+\tif r.Committed != -1 {\n+\t\treturn r.Committed\n+\t}\n+\treturn r.Attempted\n+}\n+\n+// DistributionResult is an attempted and a commited value of a distribution\n+// metric plus key.\n+type DistributionResult struct {\n+\tAttempted, Committed DistributionValue\n+\tKey                  StepKey\n+}\n+\n+// Result returns committed metrics. Falls back to attempted metrics if committed\n+// are not populated (e.g. due to not being supported on a given runner).\n+func (r DistributionResult) Result() DistributionValue {\n+\tempty := DistributionValue{}\n+\tif r.Committed != empty {\n+\t\treturn r.Committed\n+\t}\n+\treturn r.Attempted\n+}\n+\n+// GaugeResult is an attempted and a commited value of a gauge metric plus\n+// key.\n+type GaugeResult struct {\n+\tAttempted, Committed GaugeValue\n+\tKey                  StepKey\n+}\n+\n+// Result returns committed metrics. Falls back to attempted metrics if committed\n+// are not populated (e.g. due to not being supported on a given runner).\n+func (r GaugeResult) Result() GaugeValue {\n+\tempty := GaugeValue{}\n+\tif r.Committed != empty {\n+\t\treturn r.Committed\n+\t}\n+\treturn r.Attempted\n+}\n+\n+// StepKey uniquely identifies a metric.", "originalCommit": "cfd09d5c451f7242e52ea0eff6fd9de7c65dbcc4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM3ODcxMA==", "url": "https://github.com/apache/beam/pull/13272#discussion_r522378710", "bodyText": "Prefer a t.Fatal here instead, and be clear that the encoding the Int64Distribution returned an error.\nAs a rule, never panic if you don't have to. In tests, it's better to clearly explain why you're failing the test run anyway. https://golang.org/doc/effective_go.html#panic", "author": "lostluck", "createdAt": "2020-11-12T19:48:52Z", "path": "sdks/go/pkg/beam/core/runtime/metricsx/metricsx_test.go", "diffHunk": "@@ -0,0 +1,165 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package metricsx\n+\n+import (\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/metrics\"\n+\tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+)\n+\n+func TestCounterExtraction(t *testing.T) {\n+\tvar value int64 = 15\n+\twant := metrics.CounterResult{\n+\t\tAttempted: 15,\n+\t\tCommitted: -1,\n+\t\tKey: metrics.StepKey{\n+\t\t\tStep:      \"main.customDoFn\",\n+\t\t\tName:      \"customCounter\",\n+\t\t\tNamespace: \"customDoFn\",\n+\t\t}}\n+\n+\tpayload, err := Int64Counter(value)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\n+\tlabels := map[string]string{\n+\t\t\"PTRANSFORM\": \"main.customDoFn\",\n+\t\t\"NAMESPACE\":  \"customDoFn\",\n+\t\t\"NAME\":       \"customCounter\",\n+\t}\n+\n+\tmInfo := &pipepb.MonitoringInfo{\n+\t\tUrn:     UrnToString(UrnUserSumInt64),\n+\t\tType:    UrnToType(UrnUserSumInt64),\n+\t\tLabels:  labels,\n+\t\tPayload: payload,\n+\t}\n+\n+\tattempted := []*pipepb.MonitoringInfo{mInfo}\n+\tcommitted := []*pipepb.MonitoringInfo{}\n+\n+\tgot := FromMonitoringInfos(attempted, committed).AllMetrics().Counters()\n+\tsize := len(got)\n+\tif size < 1 {\n+\t\tt.Fatalf(\"Invalid array's size: got: %v, expected: %v\", size, 1)\n+\t}\n+\tif got[0] != want {\n+\t\tt.Fatalf(\"Invalid counter: got: %v, want: %v\",\n+\t\t\tgot[0], want)\n+\t}\n+}\n+\n+func TestDistributionExtraction(t *testing.T) {\n+\tvar count, sum, min, max int64 = 100, 5, -12, 30\n+\n+\twant := metrics.DistributionResult{\n+\t\tAttempted: metrics.DistributionValue{\n+\t\t\tCount: 100,\n+\t\t\tSum:   5,\n+\t\t\tMin:   -12,\n+\t\t\tMax:   30,\n+\t\t},\n+\t\tCommitted: metrics.DistributionValue{},\n+\t\tKey: metrics.StepKey{\n+\t\t\tStep:      \"main.customDoFn\",\n+\t\t\tName:      \"customDist\",\n+\t\t\tNamespace: \"customDoFn\",\n+\t\t}}\n+\n+\tpayload, err := Int64Distribution(count, sum, min, max)\n+\tif err != nil {\n+\t\tpanic(err)", "originalCommit": "cfd09d5c451f7242e52ea0eff6fd9de7c65dbcc4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM3OTU1Mw==", "url": "https://github.com/apache/beam/pull/13272#discussion_r522379553", "bodyText": "Same comment here, prefer a t.Fatalf here instead of a panic.", "author": "lostluck", "createdAt": "2020-11-12T19:50:08Z", "path": "sdks/go/pkg/beam/core/runtime/metricsx/metricsx_test.go", "diffHunk": "@@ -0,0 +1,165 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package metricsx\n+\n+import (\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/metrics\"\n+\tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+)\n+\n+func TestCounterExtraction(t *testing.T) {\n+\tvar value int64 = 15\n+\twant := metrics.CounterResult{\n+\t\tAttempted: 15,\n+\t\tCommitted: -1,\n+\t\tKey: metrics.StepKey{\n+\t\t\tStep:      \"main.customDoFn\",\n+\t\t\tName:      \"customCounter\",\n+\t\t\tNamespace: \"customDoFn\",\n+\t\t}}\n+\n+\tpayload, err := Int64Counter(value)\n+\tif err != nil {\n+\t\tpanic(err)", "originalCommit": "cfd09d5c451f7242e52ea0eff6fd9de7c65dbcc4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM3OTYwNg==", "url": "https://github.com/apache/beam/pull/13272#discussion_r522379606", "bodyText": "Same comment here, prefer a t.Fatalf here instead of a panic.", "author": "lostluck", "createdAt": "2020-11-12T19:50:14Z", "path": "sdks/go/pkg/beam/core/runtime/metricsx/metricsx_test.go", "diffHunk": "@@ -0,0 +1,165 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package metricsx\n+\n+import (\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/metrics\"\n+\tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+)\n+\n+func TestCounterExtraction(t *testing.T) {\n+\tvar value int64 = 15\n+\twant := metrics.CounterResult{\n+\t\tAttempted: 15,\n+\t\tCommitted: -1,\n+\t\tKey: metrics.StepKey{\n+\t\t\tStep:      \"main.customDoFn\",\n+\t\t\tName:      \"customCounter\",\n+\t\t\tNamespace: \"customDoFn\",\n+\t\t}}\n+\n+\tpayload, err := Int64Counter(value)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\n+\tlabels := map[string]string{\n+\t\t\"PTRANSFORM\": \"main.customDoFn\",\n+\t\t\"NAMESPACE\":  \"customDoFn\",\n+\t\t\"NAME\":       \"customCounter\",\n+\t}\n+\n+\tmInfo := &pipepb.MonitoringInfo{\n+\t\tUrn:     UrnToString(UrnUserSumInt64),\n+\t\tType:    UrnToType(UrnUserSumInt64),\n+\t\tLabels:  labels,\n+\t\tPayload: payload,\n+\t}\n+\n+\tattempted := []*pipepb.MonitoringInfo{mInfo}\n+\tcommitted := []*pipepb.MonitoringInfo{}\n+\n+\tgot := FromMonitoringInfos(attempted, committed).AllMetrics().Counters()\n+\tsize := len(got)\n+\tif size < 1 {\n+\t\tt.Fatalf(\"Invalid array's size: got: %v, expected: %v\", size, 1)\n+\t}\n+\tif got[0] != want {\n+\t\tt.Fatalf(\"Invalid counter: got: %v, want: %v\",\n+\t\t\tgot[0], want)\n+\t}\n+}\n+\n+func TestDistributionExtraction(t *testing.T) {\n+\tvar count, sum, min, max int64 = 100, 5, -12, 30\n+\n+\twant := metrics.DistributionResult{\n+\t\tAttempted: metrics.DistributionValue{\n+\t\t\tCount: 100,\n+\t\t\tSum:   5,\n+\t\t\tMin:   -12,\n+\t\t\tMax:   30,\n+\t\t},\n+\t\tCommitted: metrics.DistributionValue{},\n+\t\tKey: metrics.StepKey{\n+\t\t\tStep:      \"main.customDoFn\",\n+\t\t\tName:      \"customDist\",\n+\t\t\tNamespace: \"customDoFn\",\n+\t\t}}\n+\n+\tpayload, err := Int64Distribution(count, sum, min, max)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\n+\tlabels := map[string]string{\n+\t\t\"PTRANSFORM\": \"main.customDoFn\",\n+\t\t\"NAMESPACE\":  \"customDoFn\",\n+\t\t\"NAME\":       \"customDist\",\n+\t}\n+\n+\tmInfo := &pipepb.MonitoringInfo{\n+\t\tUrn:     UrnToString(UrnUserDistInt64),\n+\t\tType:    UrnToType(UrnUserDistInt64),\n+\t\tLabels:  labels,\n+\t\tPayload: payload,\n+\t}\n+\n+\tattempted := []*pipepb.MonitoringInfo{mInfo}\n+\tcommitted := []*pipepb.MonitoringInfo{}\n+\n+\tgot := FromMonitoringInfos(attempted, committed).AllMetrics().Distributions()\n+\tsize := len(got)\n+\tif size < 1 {\n+\t\tt.Fatalf(\"Invalid array's size: got: %v, expected: %v\", size, 1)\n+\t}\n+\tif got[0] != want {\n+\t\tt.Fatalf(\"Invalid distribution: got: %v, want: %v\",\n+\t\t\tgot[0], want)\n+\t}\n+}\n+\n+func TestGaugeExtraction(t *testing.T) {\n+\tvar value int64 = 100\n+\tloc, _ := time.LoadLocation(\"Local\")\n+\ttm := time.Date(2020, 11, 9, 17, 52, 28, 462*int(time.Millisecond), loc)\n+\n+\twant := metrics.GaugeResult{\n+\t\tAttempted: metrics.GaugeValue{\n+\t\t\tValue:     100,\n+\t\t\tTimestamp: tm,\n+\t\t},\n+\t\tCommitted: metrics.GaugeValue{},\n+\t\tKey: metrics.StepKey{\n+\t\t\tStep:      \"main.customDoFn\",\n+\t\t\tName:      \"customGauge\",\n+\t\t\tNamespace: \"customDoFn\",\n+\t\t}}\n+\n+\tpayload, err := Int64Latest(tm, value)\n+\tif err != nil {\n+\t\tpanic(err)", "originalCommit": "cfd09d5c451f7242e52ea0eff6fd9de7c65dbcc4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM4MjQ3MA==", "url": "https://github.com/apache/beam/pull/13272#discussion_r522382470", "bodyText": "Do this comparison using the cmp package instead.\n\"github.com/google/go-cmp/cmp\"\nif d := cmp.Diff(want, got[0]); d != \"\" {\n  t.Fatalf(\"Invalid counter: %v\", d)\n}\n\nHere and below.", "author": "lostluck", "createdAt": "2020-11-12T19:55:11Z", "path": "sdks/go/pkg/beam/core/runtime/metricsx/metricsx_test.go", "diffHunk": "@@ -0,0 +1,165 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package metricsx\n+\n+import (\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/metrics\"\n+\tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+)\n+\n+func TestCounterExtraction(t *testing.T) {\n+\tvar value int64 = 15\n+\twant := metrics.CounterResult{\n+\t\tAttempted: 15,\n+\t\tCommitted: -1,\n+\t\tKey: metrics.StepKey{\n+\t\t\tStep:      \"main.customDoFn\",\n+\t\t\tName:      \"customCounter\",\n+\t\t\tNamespace: \"customDoFn\",\n+\t\t}}\n+\n+\tpayload, err := Int64Counter(value)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\n+\tlabels := map[string]string{\n+\t\t\"PTRANSFORM\": \"main.customDoFn\",\n+\t\t\"NAMESPACE\":  \"customDoFn\",\n+\t\t\"NAME\":       \"customCounter\",\n+\t}\n+\n+\tmInfo := &pipepb.MonitoringInfo{\n+\t\tUrn:     UrnToString(UrnUserSumInt64),\n+\t\tType:    UrnToType(UrnUserSumInt64),\n+\t\tLabels:  labels,\n+\t\tPayload: payload,\n+\t}\n+\n+\tattempted := []*pipepb.MonitoringInfo{mInfo}\n+\tcommitted := []*pipepb.MonitoringInfo{}\n+\n+\tgot := FromMonitoringInfos(attempted, committed).AllMetrics().Counters()\n+\tsize := len(got)\n+\tif size < 1 {\n+\t\tt.Fatalf(\"Invalid array's size: got: %v, expected: %v\", size, 1)\n+\t}\n+\tif got[0] != want {", "originalCommit": "cfd09d5c451f7242e52ea0eff6fd9de7c65dbcc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQyMzY4Mw==", "url": "https://github.com/apache/beam/pull/13272#discussion_r522423683", "bodyText": "Here's an example in repo: \n  \n    \n      beam/sdks/go/pkg/beam/core/graph/coder/bytes_test.go\n    \n    \n         Line 46\n      in\n      e7a3392\n    \n    \n    \n    \n\n        \n          \n           if d := cmp.Diff(test.encoded, buf.Bytes()); d != \"\" {", "author": "lostluck", "createdAt": "2020-11-12T21:01:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM4MjQ3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM4MzA1OA==", "url": "https://github.com/apache/beam/pull/13272#discussion_r522383058", "bodyText": "In go tests, never say \"expected\" when you can simply say \"want\".  Otherwise this test output is excellent. Here and below.", "author": "lostluck", "createdAt": "2020-11-12T19:56:11Z", "path": "sdks/go/pkg/beam/core/runtime/metricsx/metricsx_test.go", "diffHunk": "@@ -0,0 +1,165 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package metricsx\n+\n+import (\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/metrics\"\n+\tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+)\n+\n+func TestCounterExtraction(t *testing.T) {\n+\tvar value int64 = 15\n+\twant := metrics.CounterResult{\n+\t\tAttempted: 15,\n+\t\tCommitted: -1,\n+\t\tKey: metrics.StepKey{\n+\t\t\tStep:      \"main.customDoFn\",\n+\t\t\tName:      \"customCounter\",\n+\t\t\tNamespace: \"customDoFn\",\n+\t\t}}\n+\n+\tpayload, err := Int64Counter(value)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\n+\tlabels := map[string]string{\n+\t\t\"PTRANSFORM\": \"main.customDoFn\",\n+\t\t\"NAMESPACE\":  \"customDoFn\",\n+\t\t\"NAME\":       \"customCounter\",\n+\t}\n+\n+\tmInfo := &pipepb.MonitoringInfo{\n+\t\tUrn:     UrnToString(UrnUserSumInt64),\n+\t\tType:    UrnToType(UrnUserSumInt64),\n+\t\tLabels:  labels,\n+\t\tPayload: payload,\n+\t}\n+\n+\tattempted := []*pipepb.MonitoringInfo{mInfo}\n+\tcommitted := []*pipepb.MonitoringInfo{}\n+\n+\tgot := FromMonitoringInfos(attempted, committed).AllMetrics().Counters()\n+\tsize := len(got)\n+\tif size < 1 {\n+\t\tt.Fatalf(\"Invalid array's size: got: %v, expected: %v\", size, 1)", "originalCommit": "cfd09d5c451f7242e52ea0eff6fd9de7c65dbcc4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM4ODAxNg==", "url": "https://github.com/apache/beam/pull/13272#discussion_r522388016", "bodyText": "Test names are related to the code as much as possible. In this case, the thing we're properly testing is FromMonitoringInfos, and specifically Counters so func TestFromMonitoringInfos_Counters is an idiomatic test name.\nThere's also an opportunity for subtests... but that's difficult here without generics right now., and that's not until 2022. You can see more here https://gobyexample.com/testing and https://blog.golang.org/subtests", "author": "lostluck", "createdAt": "2020-11-12T20:04:51Z", "path": "sdks/go/pkg/beam/core/runtime/metricsx/metricsx_test.go", "diffHunk": "@@ -0,0 +1,165 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package metricsx\n+\n+import (\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/metrics\"\n+\tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+)\n+\n+func TestCounterExtraction(t *testing.T) {", "originalCommit": "cfd09d5c451f7242e52ea0eff6fd9de7c65dbcc4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b0b1ffbee05892c87446486f67bf0c03333ecc5f", "url": "https://github.com/apache/beam/commit/b0b1ffbee05892c87446486f67bf0c03333ecc5f", "message": "fix: many minor improvements", "committedDate": "2020-11-13T11:27:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzEyNDIxNQ==", "url": "https://github.com/apache/beam/pull/13272#discussion_r523124215", "bodyText": "You'll want to have want before got when using cmp.Diff. Otherwise your diff guidance is wrong.\ncmp.Diff(want, got[0]) means the diff will be (-want,+got) that is saying what is missing from want, and extra in got, which is a useful way to read them. cmp.Diff(got[0],want) means the diff will be (+want,-got), which will be confusing.", "author": "lostluck", "createdAt": "2020-11-13T17:51:14Z", "path": "sdks/go/pkg/beam/core/runtime/metricsx/metricsx_test.go", "diffHunk": "@@ -0,0 +1,166 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package metricsx\n+\n+import (\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/metrics\"\n+\tpipepb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n+\t\"github.com/google/go-cmp/cmp\"\n+)\n+\n+func TestFromMonitoringInfos_Counters(t *testing.T) {\n+\tvar value int64 = 15\n+\twant := metrics.CounterResult{\n+\t\tAttempted: 15,\n+\t\tCommitted: -1,\n+\t\tKey: metrics.StepKey{\n+\t\t\tStep:      \"main.customDoFn\",\n+\t\t\tName:      \"customCounter\",\n+\t\t\tNamespace: \"customDoFn\",\n+\t\t}}\n+\n+\tpayload, err := Int64Counter(value)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Failed to encode Int64Counter: %v\", err)\n+\t}\n+\n+\tlabels := map[string]string{\n+\t\t\"PTRANSFORM\": \"main.customDoFn\",\n+\t\t\"NAMESPACE\":  \"customDoFn\",\n+\t\t\"NAME\":       \"customCounter\",\n+\t}\n+\n+\tmInfo := &pipepb.MonitoringInfo{\n+\t\tUrn:     UrnToString(UrnUserSumInt64),\n+\t\tType:    UrnToType(UrnUserSumInt64),\n+\t\tLabels:  labels,\n+\t\tPayload: payload,\n+\t}\n+\n+\tattempted := []*pipepb.MonitoringInfo{mInfo}\n+\tcommitted := []*pipepb.MonitoringInfo{}\n+\n+\tgot := FromMonitoringInfos(attempted, committed).AllMetrics().Counters()\n+\tsize := len(got)\n+\tif size < 1 {\n+\t\tt.Fatalf(\"Invalid array's size: got: %v, want: %v\", size, 1)\n+\t}\n+\tif d := cmp.Diff(got[0], want); d != \"\" {", "originalCommit": "b0b1ffbee05892c87446486f67bf0c03333ecc5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "becacbdb7453c1a9695be089e0b31cf0199eb49a", "url": "https://github.com/apache/beam/commit/becacbdb7453c1a9695be089e0b31cf0199eb49a", "message": "fix: use 0 instead of -1 if there are no committed values, fix cmp.Diff", "committedDate": "2020-11-16T11:11:09Z", "type": "commit"}]}