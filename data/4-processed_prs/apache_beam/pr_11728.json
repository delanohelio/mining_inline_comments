{"pr_number": 11728, "pr_title": "[BEAM-9951] Creating a synthetic step for the Go SDK.", "pr_createdAt": "2020-05-15T22:00:32Z", "pr_url": "https://github.com/apache/beam/pull/11728", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3MjAyNQ==", "url": "https://github.com/apache/beam/pull/11728#discussion_r426072025", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tsplits = append(splits, rest)\n          \n          \n            \n            \t\treturn splits\n          \n          \n            \n            \t\treturn append(splits, rest)", "author": "lostluck", "createdAt": "2020-05-15T22:23:13Z", "path": "sdks/go/pkg/beam/io/synthetic/step.go", "diffHunk": "@@ -0,0 +1,191 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package synthetic\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/io/rtrackers/offsetrange\"\n+\t\"math/rand\"\n+\t\"time\"\n+)\n+\n+// Step creates a synthetic step transform that receives KV<[]byte, []byte>\n+// elements from other synthetic transforms, and outputs KV<[]byte, []byte>\n+// elements based on its inputs.\n+//\n+// This function accepts a StepConfig to configure the behavior of the synthetic\n+// step, including whether that step is implemented as a splittable or\n+// non-splittable DoFn.\n+//\n+// StepConfigs are recommended to be created via the DefaultStepConfig and\n+// modified before being passed to this method. Example:\n+//\n+//    cfg := synthetic.DefaultStepConfig()\n+//    cfg.OutputPerInput = 1000\n+//    cfg.Splittable = true\n+//    cfg.InitialSplits = 2\n+//    step := synthetic.Step(s, cfg, input)\n+func Step(s beam.Scope, cfg StepConfig, col beam.PCollection) beam.PCollection {\n+\ts = s.Scope(\"synthetic.Step\")\n+\tif cfg.Splittable {\n+\t\treturn beam.ParDo(s, &sdfStepFn{cfg: cfg}, col)\n+\t} else {\n+\t\treturn beam.ParDo(s, &stepFn{cfg: cfg}, col)\n+\t}\n+}\n+\n+// stepFn is a DoFn implementing behavior for synthetic steps. For usage\n+// information, see synthetic.Step.\n+//\n+// The stepFn is expected to be initialized with a cfg and will follow that\n+// config to determine its behavior when emitting elements.\n+type stepFn struct {\n+\tcfg StepConfig\n+\trng randWrapper\n+}\n+\n+// Setup sets up the random number generator.\n+func (fn *stepFn) Setup() {\n+\tfn.rng = rand.New(rand.NewSource(time.Now().UnixNano()))\n+}\n+\n+// ProcessElement takes an input and either filters it or produces a number of\n+// outputs identical to that input based on the outputs per input configuration\n+// in StepConfig.\n+func (fn *stepFn) ProcessElement(key, val []byte, emit func([]byte, []byte)) {\n+\tif fn.cfg.FilterRatio > 0 && fn.rng.Float64() < fn.cfg.FilterRatio {\n+\t\treturn\n+\t}\n+\tfor i := 0; i < fn.cfg.OutputPerInput; i++ {\n+\t\temit(key, val)\n+\t}\n+}\n+\n+// sdfStepFn is a splittable DoFn implementing behavior for synthetic steps.\n+// For usage information, see synthetic.Step.\n+//\n+// The sdfStepFn is expected to be initialized with a cfg and will follow\n+// that config to determine its behavior when splitting and emitting elements.\n+type sdfStepFn struct {\n+\tcfg StepConfig\n+\trng randWrapper\n+}\n+\n+// CreateInitialRestriction creates an offset range restriction representing\n+// the number of elements to emit for this received element, as specified by\n+// the output per input configuration in StepConfig.\n+func (fn *sdfStepFn) CreateInitialRestriction(key, val []byte) offsetrange.Restriction {\n+\treturn offsetrange.Restriction{\n+\t\tStart: 0,\n+\t\tEnd:   int64(fn.cfg.OutputPerInput),\n+\t}\n+}\n+\n+// SplitRestriction splits restrictions equally according to the number of\n+// initial splits specified in StepConfig. Each restriction output by this\n+// method will contain at least one element, so the number of splits will not\n+// exceed the number of elements.\n+func (fn *sdfStepFn) SplitRestriction(key, val []byte, rest offsetrange.Restriction) (splits []offsetrange.Restriction) {\n+\tif fn.cfg.InitialSplits <= 1 {\n+\t\t// Don't split, just return original restriction.\n+\t\tsplits = append(splits, rest)\n+\t\treturn splits", "originalCommit": "af7039c4fd76a0e6a1dd7dc78fa0965ee1ccd57b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEwMzkxNg==", "url": "https://github.com/apache/beam/pull/11728#discussion_r426103916", "bodyText": "Done.", "author": "youngoli", "createdAt": "2020-05-16T01:28:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3MjAyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3ODQyNQ==", "url": "https://github.com/apache/beam/pull/11728#discussion_r426078425", "bodyText": "Comment cuts out.", "author": "lostluck", "createdAt": "2020-05-15T22:48:31Z", "path": "sdks/go/pkg/beam/io/synthetic/step.go", "diffHunk": "@@ -0,0 +1,191 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package synthetic\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/io/rtrackers/offsetrange\"\n+\t\"math/rand\"\n+\t\"time\"\n+)\n+\n+// Step creates a synthetic step transform that receives KV<[]byte, []byte>\n+// elements from other synthetic transforms, and outputs KV<[]byte, []byte>\n+// elements based on its inputs.\n+//\n+// This function accepts a StepConfig to configure the behavior of the synthetic\n+// step, including whether that step is implemented as a splittable or\n+// non-splittable DoFn.\n+//\n+// StepConfigs are recommended to be created via the DefaultStepConfig and\n+// modified before being passed to this method. Example:\n+//\n+//    cfg := synthetic.DefaultStepConfig()\n+//    cfg.OutputPerInput = 1000\n+//    cfg.Splittable = true\n+//    cfg.InitialSplits = 2\n+//    step := synthetic.Step(s, cfg, input)\n+func Step(s beam.Scope, cfg StepConfig, col beam.PCollection) beam.PCollection {\n+\ts = s.Scope(\"synthetic.Step\")\n+\tif cfg.Splittable {\n+\t\treturn beam.ParDo(s, &sdfStepFn{cfg: cfg}, col)\n+\t} else {\n+\t\treturn beam.ParDo(s, &stepFn{cfg: cfg}, col)\n+\t}\n+}\n+\n+// stepFn is a DoFn implementing behavior for synthetic steps. For usage\n+// information, see synthetic.Step.\n+//\n+// The stepFn is expected to be initialized with a cfg and will follow that\n+// config to determine its behavior when emitting elements.\n+type stepFn struct {\n+\tcfg StepConfig\n+\trng randWrapper\n+}\n+\n+// Setup sets up the random number generator.\n+func (fn *stepFn) Setup() {\n+\tfn.rng = rand.New(rand.NewSource(time.Now().UnixNano()))\n+}\n+\n+// ProcessElement takes an input and either filters it or produces a number of\n+// outputs identical to that input based on the outputs per input configuration\n+// in StepConfig.\n+func (fn *stepFn) ProcessElement(key, val []byte, emit func([]byte, []byte)) {\n+\tif fn.cfg.FilterRatio > 0 && fn.rng.Float64() < fn.cfg.FilterRatio {\n+\t\treturn\n+\t}\n+\tfor i := 0; i < fn.cfg.OutputPerInput; i++ {\n+\t\temit(key, val)\n+\t}\n+}\n+\n+// sdfStepFn is a splittable DoFn implementing behavior for synthetic steps.\n+// For usage information, see synthetic.Step.\n+//\n+// The sdfStepFn is expected to be initialized with a cfg and will follow\n+// that config to determine its behavior when splitting and emitting elements.\n+type sdfStepFn struct {\n+\tcfg StepConfig\n+\trng randWrapper\n+}\n+\n+// CreateInitialRestriction creates an offset range restriction representing\n+// the number of elements to emit for this received element, as specified by\n+// the output per input configuration in StepConfig.\n+func (fn *sdfStepFn) CreateInitialRestriction(key, val []byte) offsetrange.Restriction {\n+\treturn offsetrange.Restriction{\n+\t\tStart: 0,\n+\t\tEnd:   int64(fn.cfg.OutputPerInput),\n+\t}\n+}\n+\n+// SplitRestriction splits restrictions equally according to the number of\n+// initial splits specified in StepConfig. Each restriction output by this\n+// method will contain at least one element, so the number of splits will not\n+// exceed the number of elements.\n+func (fn *sdfStepFn) SplitRestriction(key, val []byte, rest offsetrange.Restriction) (splits []offsetrange.Restriction) {\n+\tif fn.cfg.InitialSplits <= 1 {\n+\t\t// Don't split, just return original restriction.\n+\t\tsplits = append(splits, rest)\n+\t\treturn splits\n+\t}\n+\n+\t// TODO(BEAM-9978) Move this implementation of the offset range restriction\n+\t// splitting to the restriction itself, and add testing.\n+\tnum := int64(fn.cfg.InitialSplits)\n+\toffset := rest.Start\n+\tsize := rest.End - rest.Start\n+\tfor i := int64(0); i < num; i++ {\n+\t\tsplit := offsetrange.Restriction{\n+\t\t\tStart: offset + (i * size / num),\n+\t\t\tEnd:   offset + ((i + 1) * size / num),\n+\t\t}\n+\t\t// Skip restrictions that end up empty.\n+\t\tif split.End-split.Start <= 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tsplits = append(splits, split)\n+\t}\n+\treturn splits\n+}\n+\n+// RestrictionSize outputs the size of the restriction as the number of elements\n+// that restriction will output.\n+func (fn *sdfStepFn) RestrictionSize(key, val []byte, rest offsetrange.Restriction) float64 {\n+\t// TODO(BEAM-9978) Move this size implementation to the offset range restriction itself.\n+\treturn float64(rest.End - rest.Start)\n+}\n+\n+// CreateTracker creates an offset range restriction tracker for the\n+// restriction.\n+func (fn *sdfStepFn) CreateTracker(rest offsetrange.Restriction) *offsetrange.Tracker {\n+\treturn offsetrange.NewTracker(rest)\n+}\n+\n+// Setup sets up the random number generator.\n+func (fn *sdfStepFn) Setup() {\n+\tfn.rng = rand.New(rand.NewSource(time.Now().UnixNano()))\n+}\n+\n+// ProcessElement takes an input and either filters it or produces a number of\n+// outputs identical to that input based on the restriction size.\n+func (fn *sdfStepFn) ProcessElement(rt *offsetrange.Tracker, key, val []byte, emit func([]byte, []byte)) {\n+\tif fn.cfg.FilterRatio > 0 && fn.rng.Float64() < fn.cfg.FilterRatio {\n+\t\treturn\n+\t}\n+\tfor i := rt.Rest.Start; rt.TryClaim(i) == true; i++ {\n+\t\temit(key, val)\n+\t}\n+}\n+\n+// DefaultSourceConfig creates a SourceConfig with intended defaults for its\n+// fields. SourceConfigs should be initialized with this method.\n+func DefaultStepConfig() StepConfig {\n+\treturn StepConfig{\n+\t\tOutputPerInput: 1,     // Defaults shouldn't drop elements, so at least 1.\n+\t\tFilterRatio:    0.0,   // Defaults shouldn't drop elements, so don't filter.\n+\t\tSplittable:     false, // Default to non-splittable, SDFs are situational.\n+\t\tInitialSplits:  1,     // Defaults to 1, i.e. no initial splitting.\n+\t}\n+}\n+\n+// StepConfig is a struct containing all the configuration options for a\n+// synthetic step.\n+type StepConfig struct {\n+\t// OutputPerInput is the number of outputs to emit per input received. Each\n+\t// output is identical to the original input. A value of 0 drops each input.\n+\tOutputPerInput int\n+\n+\t// FilterRatio indicates the random chance that an input will be filtered\n+\t// out, meaning that no outputs will get emitted for it. For example, a\n+\t// FilterRatio of 0.25 means that 25% of inputs will get filtered out.\n+\tFilterRatio float64\n+\n+\t// Splittable indicates whether the step should use the splittable DoFn or\n+\t// non-splittable DoFn implementation. When a splittable", "originalCommit": "af7039c4fd76a0e6a1dd7dc78fa0965ee1ccd57b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEwNDY5NA==", "url": "https://github.com/apache/beam/pull/11728#discussion_r426104694", "bodyText": "Whoops, fixed.", "author": "youngoli", "createdAt": "2020-05-16T01:37:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3ODQyNQ=="}], "type": "inlineReview"}, {"oid": "849113bbad9b81337246d298645a9089ed6ced4b", "url": "https://github.com/apache/beam/commit/849113bbad9b81337246d298645a9089ed6ced4b", "message": "[BEAM-9951] Creating a synthetic step for the Go SDK.\n\nBuilding off the synthetic source, adding a synthetic step. Still need\nto update the way the configs are built though.", "committedDate": "2020-05-16T01:37:44Z", "type": "commit"}, {"oid": "849113bbad9b81337246d298645a9089ed6ced4b", "url": "https://github.com/apache/beam/commit/849113bbad9b81337246d298645a9089ed6ced4b", "message": "[BEAM-9951] Creating a synthetic step for the Go SDK.\n\nBuilding off the synthetic source, adding a synthetic step. Still need\nto update the way the configs are built though.", "committedDate": "2020-05-16T01:37:44Z", "type": "forcePushed"}]}