{"pr_number": 10766, "pr_title": "[BEAM-4461] Add Selected.flattenedSchema", "pr_createdAt": "2020-02-04T20:29:09Z", "pr_url": "https://github.com/apache/beam/pull/10766", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk2NjAwMw==", "url": "https://github.com/apache/beam/pull/10766#discussion_r374966003", "bodyText": "It took me a minute to understand what's going on with \"selectFields\" here and in process. I had no idea that the value on FieldAccess could be an id referencing a member FieldAccessDescriptor until I dug into the code. Let's document that as part of BEAM-9217 as well.", "author": "TheNeuralBit", "createdAt": "2020-02-04T22:43:43Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/transforms/Select.java", "diffHunk": "@@ -69,55 +75,117 @@\n  * }</pre>\n  */\n @Experimental(Kind.SCHEMAS)\n-public class Select<T> extends PTransform<PCollection<T>, PCollection<Row>> {\n-  private final FieldAccessDescriptor fieldAccessDescriptor;\n-\n-  private Select(FieldAccessDescriptor fieldAccessDescriptor) {\n-    this.fieldAccessDescriptor = fieldAccessDescriptor;\n+public class Select {\n+  public static <T> Select.Fields<T> create() {\n+    return new Fields<>(FieldAccessDescriptor.create());\n   }\n \n   /** Select a set of top-level field ids from the row. */\n-  public static <T> Select<T> fieldIds(Integer... ids) {\n-    return new Select<>(FieldAccessDescriptor.withFieldIds(ids));\n+  public static <T> Fields<T> fieldIds(Integer... ids) {\n+    return new Fields<>(FieldAccessDescriptor.withFieldIds(ids));\n   }\n \n   /** Select a set of top-level field names from the row. */\n-  public static <T> Select<T> fieldNames(String... names) {\n-    return new Select<>(FieldAccessDescriptor.withFieldNames(names));\n+  public static <T> Fields<T> fieldNames(String... names) {\n+    return new Fields<>(FieldAccessDescriptor.withFieldNames(names));\n   }\n \n   /**\n    * Select a set of fields described in a {@link FieldAccessDescriptor}.\n    *\n    * <p>This allows for nested fields to be selected as well.\n    */\n-  public static <T> Select<T> fieldAccess(FieldAccessDescriptor fieldAccessDescriptor) {\n-    return new Select<>(fieldAccessDescriptor);\n+  public static <T> Fields<T> fieldAccess(FieldAccessDescriptor fieldAccessDescriptor) {\n+    return new Fields<>(fieldAccessDescriptor);\n+  }\n+\n+  /**\n+   * Selects every leaf-level field. This results in a a nested schema being flattened into a single\n+   * top-level schema.\n+   */\n+  public static <T> Flattened<T> flattenedSchema() {\n+    return new Flattened<>();\n+  }\n+\n+  private static class SelectDoFn<T> extends DoFn<T, Row> {\n+    private FieldAccessDescriptor fieldAccessDescriptor;\n+    private Schema inputSchema;\n+    private Schema outputSchema;\n+\n+    // TODO: This should be the same as resolved so that Beam knows which fields\n+    // are being accessed. Currently Beam only supports wildcard descriptors.\n+    // Once BEAM-4457 is fixed, fix this.\n+    @FieldAccess(\"selectFields\")\n+    final FieldAccessDescriptor fieldAccess = FieldAccessDescriptor.withAllFields();", "originalCommit": "091a5323b302b5e0ac8fb322ef80a38503957d0b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk2NjIwOA==", "url": "https://github.com/apache/beam/pull/10766#discussion_r374966208", "bodyText": "Does BEAM-4457 unblock this? it doesn't mention anything about wildcard descriptors.", "author": "TheNeuralBit", "createdAt": "2020-02-04T22:44:15Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/transforms/Select.java", "diffHunk": "@@ -69,55 +75,117 @@\n  * }</pre>\n  */\n @Experimental(Kind.SCHEMAS)\n-public class Select<T> extends PTransform<PCollection<T>, PCollection<Row>> {\n-  private final FieldAccessDescriptor fieldAccessDescriptor;\n-\n-  private Select(FieldAccessDescriptor fieldAccessDescriptor) {\n-    this.fieldAccessDescriptor = fieldAccessDescriptor;\n+public class Select {\n+  public static <T> Select.Fields<T> create() {\n+    return new Fields<>(FieldAccessDescriptor.create());\n   }\n \n   /** Select a set of top-level field ids from the row. */\n-  public static <T> Select<T> fieldIds(Integer... ids) {\n-    return new Select<>(FieldAccessDescriptor.withFieldIds(ids));\n+  public static <T> Fields<T> fieldIds(Integer... ids) {\n+    return new Fields<>(FieldAccessDescriptor.withFieldIds(ids));\n   }\n \n   /** Select a set of top-level field names from the row. */\n-  public static <T> Select<T> fieldNames(String... names) {\n-    return new Select<>(FieldAccessDescriptor.withFieldNames(names));\n+  public static <T> Fields<T> fieldNames(String... names) {\n+    return new Fields<>(FieldAccessDescriptor.withFieldNames(names));\n   }\n \n   /**\n    * Select a set of fields described in a {@link FieldAccessDescriptor}.\n    *\n    * <p>This allows for nested fields to be selected as well.\n    */\n-  public static <T> Select<T> fieldAccess(FieldAccessDescriptor fieldAccessDescriptor) {\n-    return new Select<>(fieldAccessDescriptor);\n+  public static <T> Fields<T> fieldAccess(FieldAccessDescriptor fieldAccessDescriptor) {\n+    return new Fields<>(fieldAccessDescriptor);\n+  }\n+\n+  /**\n+   * Selects every leaf-level field. This results in a a nested schema being flattened into a single\n+   * top-level schema.\n+   */\n+  public static <T> Flattened<T> flattenedSchema() {\n+    return new Flattened<>();\n+  }\n+\n+  private static class SelectDoFn<T> extends DoFn<T, Row> {\n+    private FieldAccessDescriptor fieldAccessDescriptor;\n+    private Schema inputSchema;\n+    private Schema outputSchema;\n+\n+    // TODO: This should be the same as resolved so that Beam knows which fields\n+    // are being accessed. Currently Beam only supports wildcard descriptors.\n+    // Once BEAM-4457 is fixed, fix this.", "originalCommit": "091a5323b302b5e0ac8fb322ef80a38503957d0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk5NTUwMw==", "url": "https://github.com/apache/beam/pull/10766#discussion_r374995503", "bodyText": "This is an old comment. I don't know that we've fully decided what to do about BEAM-4457", "author": "reuvenlax", "createdAt": "2020-02-05T00:11:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk2NjIwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk2NzQ5Mw==", "url": "https://github.com/apache/beam/pull/10766#discussion_r374967493", "bodyText": "Field names can contain an underscore, right? So in theory we could still end up with a non-unique name here if the schema had two nested fields like:\n\nlayer1.layer2_layer3 -> \"layer1_layer2_layer3\"\nlayer1.layer2.layer3 -> \"layer1_layer2_layer3\"", "author": "TheNeuralBit", "createdAt": "2020-02-04T22:47:32Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/transforms/Select.java", "diffHunk": "@@ -69,55 +75,117 @@\n  * }</pre>\n  */\n @Experimental(Kind.SCHEMAS)\n-public class Select<T> extends PTransform<PCollection<T>, PCollection<Row>> {\n-  private final FieldAccessDescriptor fieldAccessDescriptor;\n-\n-  private Select(FieldAccessDescriptor fieldAccessDescriptor) {\n-    this.fieldAccessDescriptor = fieldAccessDescriptor;\n+public class Select {\n+  public static <T> Select.Fields<T> create() {\n+    return new Fields<>(FieldAccessDescriptor.create());\n   }\n \n   /** Select a set of top-level field ids from the row. */\n-  public static <T> Select<T> fieldIds(Integer... ids) {\n-    return new Select<>(FieldAccessDescriptor.withFieldIds(ids));\n+  public static <T> Fields<T> fieldIds(Integer... ids) {\n+    return new Fields<>(FieldAccessDescriptor.withFieldIds(ids));\n   }\n \n   /** Select a set of top-level field names from the row. */\n-  public static <T> Select<T> fieldNames(String... names) {\n-    return new Select<>(FieldAccessDescriptor.withFieldNames(names));\n+  public static <T> Fields<T> fieldNames(String... names) {\n+    return new Fields<>(FieldAccessDescriptor.withFieldNames(names));\n   }\n \n   /**\n    * Select a set of fields described in a {@link FieldAccessDescriptor}.\n    *\n    * <p>This allows for nested fields to be selected as well.\n    */\n-  public static <T> Select<T> fieldAccess(FieldAccessDescriptor fieldAccessDescriptor) {\n-    return new Select<>(fieldAccessDescriptor);\n+  public static <T> Fields<T> fieldAccess(FieldAccessDescriptor fieldAccessDescriptor) {\n+    return new Fields<>(fieldAccessDescriptor);\n+  }\n+\n+  /**\n+   * Selects every leaf-level field. This results in a a nested schema being flattened into a single\n+   * top-level schema.\n+   */\n+  public static <T> Flattened<T> flattenedSchema() {\n+    return new Flattened<>();\n+  }\n+\n+  private static class SelectDoFn<T> extends DoFn<T, Row> {\n+    private FieldAccessDescriptor fieldAccessDescriptor;\n+    private Schema inputSchema;\n+    private Schema outputSchema;\n+\n+    // TODO: This should be the same as resolved so that Beam knows which fields\n+    // are being accessed. Currently Beam only supports wildcard descriptors.\n+    // Once BEAM-4457 is fixed, fix this.\n+    @FieldAccess(\"selectFields\")\n+    final FieldAccessDescriptor fieldAccess = FieldAccessDescriptor.withAllFields();\n+\n+    public SelectDoFn(\n+        FieldAccessDescriptor fieldAccessDescriptor, Schema inputSchema, Schema outputSchema) {\n+      this.fieldAccessDescriptor = fieldAccessDescriptor;\n+      this.inputSchema = inputSchema;\n+      this.outputSchema = outputSchema;\n+    }\n+\n+    @ProcessElement\n+    public void process(@FieldAccess(\"selectFields\") @Element Row row, OutputReceiver<Row> r) {\n+      r.output(SelectHelpers.selectRow(row, fieldAccessDescriptor, inputSchema, outputSchema));\n+    }\n+  }\n+\n+  public static class Fields<T> extends PTransform<PCollection<T>, PCollection<Row>> {\n+    private FieldAccessDescriptor fieldAccessDescriptor;\n+\n+    public Fields(FieldAccessDescriptor fieldAccessDescriptor) {\n+      this.fieldAccessDescriptor = fieldAccessDescriptor;\n+    }\n+\n+    @Override\n+    public PCollection<Row> expand(PCollection<T> input) {\n+      Schema inputSchema = input.getSchema();\n+      FieldAccessDescriptor resolved = fieldAccessDescriptor.resolve(inputSchema);\n+      Schema outputSchema = SelectHelpers.getOutputSchema(inputSchema, resolved);\n+      return input\n+          .apply(ParDo.of(new SelectDoFn<>(resolved, inputSchema, outputSchema)))\n+          .setRowSchema(outputSchema);\n+    }\n   }\n \n-  @Override\n-  public PCollection<Row> expand(PCollection<T> input) {\n-    Schema inputSchema = input.getSchema();\n-    FieldAccessDescriptor resolved = fieldAccessDescriptor.resolve(inputSchema);\n-    Schema outputSchema = SelectHelpers.getOutputSchema(inputSchema, resolved);\n-\n-    return input\n-        .apply(\n-            ParDo.of(\n-                new DoFn<T, Row>() {\n-                  // TODO: This should be the same as resolved so that Beam knows which fields\n-                  // are being accessed. Currently Beam only supports wildcard descriptors.\n-                  // Once BEAM-4457 is fixed, fix this.\n-                  @FieldAccess(\"selectFields\")\n-                  final FieldAccessDescriptor fieldAccessDescriptor =\n-                      FieldAccessDescriptor.withAllFields();\n-\n-                  @ProcessElement\n-                  public void process(\n-                      @FieldAccess(\"selectFields\") @Element Row row, OutputReceiver<Row> r) {\n-                    r.output(SelectHelpers.selectRow(row, resolved, inputSchema, outputSchema));\n-                  }\n-                }))\n-        .setRowSchema(outputSchema);\n+  /** A {@link PTransform} representing a flattened schema. */\n+  public static class Flattened<T> extends PTransform<PCollection<T>, PCollection<Row>> {\n+    private SerializableFunction<List<String>, String> nameFn;\n+\n+    Flattened() {\n+      this(CONCAT_FIELD_NAMES);\n+    }\n+\n+    Flattened(SerializableFunction<List<String>, String> nameFn) {\n+      this.nameFn = nameFn;\n+    }\n+\n+    /**\n+     * For nested fields, concatenate all the names separated by a _ character in the flattened\n+     * schema.", "originalCommit": "091a5323b302b5e0ac8fb322ef80a38503957d0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk5NTc4Mw==", "url": "https://github.com/apache/beam/pull/10766#discussion_r374995783", "bodyText": "yeah, though I think we should maybe make underscore a reserved character in fields. We also don't prevent users from putting dots in field names, but all sorts of things will break if they do.", "author": "reuvenlax", "createdAt": "2020-02-05T00:12:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk2NzQ5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjAzODQzNQ==", "url": "https://github.com/apache/beam/pull/10766#discussion_r376038435", "bodyText": "Added withFieldNameAs to allow the user to rename fields", "author": "reuvenlax", "createdAt": "2020-02-06T19:32:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk2NzQ5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk2Nzc5MA==", "url": "https://github.com/apache/beam/pull/10766#discussion_r374967790", "bodyText": "maybe keepMostNestedFieldName for consistency? up to you", "author": "TheNeuralBit", "createdAt": "2020-02-04T22:48:18Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/transforms/Select.java", "diffHunk": "@@ -69,55 +75,117 @@\n  * }</pre>\n  */\n @Experimental(Kind.SCHEMAS)\n-public class Select<T> extends PTransform<PCollection<T>, PCollection<Row>> {\n-  private final FieldAccessDescriptor fieldAccessDescriptor;\n-\n-  private Select(FieldAccessDescriptor fieldAccessDescriptor) {\n-    this.fieldAccessDescriptor = fieldAccessDescriptor;\n+public class Select {\n+  public static <T> Select.Fields<T> create() {\n+    return new Fields<>(FieldAccessDescriptor.create());\n   }\n \n   /** Select a set of top-level field ids from the row. */\n-  public static <T> Select<T> fieldIds(Integer... ids) {\n-    return new Select<>(FieldAccessDescriptor.withFieldIds(ids));\n+  public static <T> Fields<T> fieldIds(Integer... ids) {\n+    return new Fields<>(FieldAccessDescriptor.withFieldIds(ids));\n   }\n \n   /** Select a set of top-level field names from the row. */\n-  public static <T> Select<T> fieldNames(String... names) {\n-    return new Select<>(FieldAccessDescriptor.withFieldNames(names));\n+  public static <T> Fields<T> fieldNames(String... names) {\n+    return new Fields<>(FieldAccessDescriptor.withFieldNames(names));\n   }\n \n   /**\n    * Select a set of fields described in a {@link FieldAccessDescriptor}.\n    *\n    * <p>This allows for nested fields to be selected as well.\n    */\n-  public static <T> Select<T> fieldAccess(FieldAccessDescriptor fieldAccessDescriptor) {\n-    return new Select<>(fieldAccessDescriptor);\n+  public static <T> Fields<T> fieldAccess(FieldAccessDescriptor fieldAccessDescriptor) {\n+    return new Fields<>(fieldAccessDescriptor);\n+  }\n+\n+  /**\n+   * Selects every leaf-level field. This results in a a nested schema being flattened into a single\n+   * top-level schema.\n+   */\n+  public static <T> Flattened<T> flattenedSchema() {\n+    return new Flattened<>();\n+  }\n+\n+  private static class SelectDoFn<T> extends DoFn<T, Row> {\n+    private FieldAccessDescriptor fieldAccessDescriptor;\n+    private Schema inputSchema;\n+    private Schema outputSchema;\n+\n+    // TODO: This should be the same as resolved so that Beam knows which fields\n+    // are being accessed. Currently Beam only supports wildcard descriptors.\n+    // Once BEAM-4457 is fixed, fix this.\n+    @FieldAccess(\"selectFields\")\n+    final FieldAccessDescriptor fieldAccess = FieldAccessDescriptor.withAllFields();\n+\n+    public SelectDoFn(\n+        FieldAccessDescriptor fieldAccessDescriptor, Schema inputSchema, Schema outputSchema) {\n+      this.fieldAccessDescriptor = fieldAccessDescriptor;\n+      this.inputSchema = inputSchema;\n+      this.outputSchema = outputSchema;\n+    }\n+\n+    @ProcessElement\n+    public void process(@FieldAccess(\"selectFields\") @Element Row row, OutputReceiver<Row> r) {\n+      r.output(SelectHelpers.selectRow(row, fieldAccessDescriptor, inputSchema, outputSchema));\n+    }\n+  }\n+\n+  public static class Fields<T> extends PTransform<PCollection<T>, PCollection<Row>> {\n+    private FieldAccessDescriptor fieldAccessDescriptor;\n+\n+    public Fields(FieldAccessDescriptor fieldAccessDescriptor) {\n+      this.fieldAccessDescriptor = fieldAccessDescriptor;\n+    }\n+\n+    @Override\n+    public PCollection<Row> expand(PCollection<T> input) {\n+      Schema inputSchema = input.getSchema();\n+      FieldAccessDescriptor resolved = fieldAccessDescriptor.resolve(inputSchema);\n+      Schema outputSchema = SelectHelpers.getOutputSchema(inputSchema, resolved);\n+      return input\n+          .apply(ParDo.of(new SelectDoFn<>(resolved, inputSchema, outputSchema)))\n+          .setRowSchema(outputSchema);\n+    }\n   }\n \n-  @Override\n-  public PCollection<Row> expand(PCollection<T> input) {\n-    Schema inputSchema = input.getSchema();\n-    FieldAccessDescriptor resolved = fieldAccessDescriptor.resolve(inputSchema);\n-    Schema outputSchema = SelectHelpers.getOutputSchema(inputSchema, resolved);\n-\n-    return input\n-        .apply(\n-            ParDo.of(\n-                new DoFn<T, Row>() {\n-                  // TODO: This should be the same as resolved so that Beam knows which fields\n-                  // are being accessed. Currently Beam only supports wildcard descriptors.\n-                  // Once BEAM-4457 is fixed, fix this.\n-                  @FieldAccess(\"selectFields\")\n-                  final FieldAccessDescriptor fieldAccessDescriptor =\n-                      FieldAccessDescriptor.withAllFields();\n-\n-                  @ProcessElement\n-                  public void process(\n-                      @FieldAccess(\"selectFields\") @Element Row row, OutputReceiver<Row> r) {\n-                    r.output(SelectHelpers.selectRow(row, resolved, inputSchema, outputSchema));\n-                  }\n-                }))\n-        .setRowSchema(outputSchema);\n+  /** A {@link PTransform} representing a flattened schema. */\n+  public static class Flattened<T> extends PTransform<PCollection<T>, PCollection<Row>> {\n+    private SerializableFunction<List<String>, String> nameFn;\n+\n+    Flattened() {\n+      this(CONCAT_FIELD_NAMES);\n+    }\n+\n+    Flattened(SerializableFunction<List<String>, String> nameFn) {\n+      this.nameFn = nameFn;\n+    }\n+\n+    /**\n+     * For nested fields, concatenate all the names separated by a _ character in the flattened\n+     * schema.\n+     */\n+    public Flattened<T> concatFieldNames() {\n+      return new Flattened<>(CONCAT_FIELD_NAMES);\n+    }\n+\n+    /**\n+     * For nested fields, keep just the most-nested field name. Will fail if this name is not\n+     * unique.\n+     */\n+    public Flattened<T> keepMostNestedField() {", "originalCommit": "091a5323b302b5e0ac8fb322ef80a38503957d0b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk2OTQwOA==", "url": "https://github.com/apache/beam/pull/10766#discussion_r374969408", "bodyText": "This should probably indicate it will concat field names with underscores", "author": "TheNeuralBit", "createdAt": "2020-02-04T22:52:24Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/transforms/Select.java", "diffHunk": "@@ -69,55 +75,117 @@\n  * }</pre>\n  */\n @Experimental(Kind.SCHEMAS)\n-public class Select<T> extends PTransform<PCollection<T>, PCollection<Row>> {\n-  private final FieldAccessDescriptor fieldAccessDescriptor;\n-\n-  private Select(FieldAccessDescriptor fieldAccessDescriptor) {\n-    this.fieldAccessDescriptor = fieldAccessDescriptor;\n+public class Select {\n+  public static <T> Select.Fields<T> create() {\n+    return new Fields<>(FieldAccessDescriptor.create());\n   }\n \n   /** Select a set of top-level field ids from the row. */\n-  public static <T> Select<T> fieldIds(Integer... ids) {\n-    return new Select<>(FieldAccessDescriptor.withFieldIds(ids));\n+  public static <T> Fields<T> fieldIds(Integer... ids) {\n+    return new Fields<>(FieldAccessDescriptor.withFieldIds(ids));\n   }\n \n   /** Select a set of top-level field names from the row. */\n-  public static <T> Select<T> fieldNames(String... names) {\n-    return new Select<>(FieldAccessDescriptor.withFieldNames(names));\n+  public static <T> Fields<T> fieldNames(String... names) {\n+    return new Fields<>(FieldAccessDescriptor.withFieldNames(names));\n   }\n \n   /**\n    * Select a set of fields described in a {@link FieldAccessDescriptor}.\n    *\n    * <p>This allows for nested fields to be selected as well.\n    */\n-  public static <T> Select<T> fieldAccess(FieldAccessDescriptor fieldAccessDescriptor) {\n-    return new Select<>(fieldAccessDescriptor);\n+  public static <T> Fields<T> fieldAccess(FieldAccessDescriptor fieldAccessDescriptor) {\n+    return new Fields<>(fieldAccessDescriptor);\n+  }\n+\n+  /**\n+   * Selects every leaf-level field. This results in a a nested schema being flattened into a single\n+   * top-level schema.\n+   */", "originalCommit": "091a5323b302b5e0ac8fb322ef80a38503957d0b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk2OTY5MQ==", "url": "https://github.com/apache/beam/pull/10766#discussion_r374969691", "bodyText": "bike-shed: Nothing in this file actually makes this a default, seems to be a hold-over from when the function was in Unnest", "author": "TheNeuralBit", "createdAt": "2020-02-04T22:53:09Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/utils/SelectHelpers.java", "diffHunk": "@@ -344,4 +352,46 @@ private static void selectIntoRowWithQualifiers(\n         throw new RuntimeException(\"Unexpected type \" + qualifier.getKind());\n     }\n   }\n+\n+  /**\n+   * This is the default naming policy for naming fields. Every field name in the path to a given\n+   * field is concated with _ characters.\n+   */", "originalCommit": "091a5323b302b5e0ac8fb322ef80a38503957d0b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk3MDEyOA==", "url": "https://github.com/apache/beam/pull/10766#discussion_r374970128", "bodyText": "Similar bike-shed: This mentions unnesting which isn't a thing after this change, maybe change to flattening?", "author": "TheNeuralBit", "createdAt": "2020-02-04T22:54:14Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/utils/SelectHelpers.java", "diffHunk": "@@ -344,4 +352,46 @@ private static void selectIntoRowWithQualifiers(\n         throw new RuntimeException(\"Unexpected type \" + qualifier.getKind());\n     }\n   }\n+\n+  /**\n+   * This is the default naming policy for naming fields. Every field name in the path to a given\n+   * field is concated with _ characters.\n+   */\n+  public static final SerializableFunction<List<String>, String> CONCAT_FIELD_NAMES =\n+      l -> {\n+        return String.join(\"_\", l);\n+      };\n+  /**\n+   * This policy keeps the raw nested field name. If two differently-nested fields have the same\n+   * name, unnesting will fail with this policy.\n+   */", "originalCommit": "091a5323b302b5e0ac8fb322ef80a38503957d0b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk3MzA3OA==", "url": "https://github.com/apache/beam/pull/10766#discussion_r374973078", "bodyText": "This looks nifty, but maybe made it into this PR by accident? I don't see it used anywhere", "author": "TheNeuralBit", "createdAt": "2020-02-04T23:01:46Z", "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/schemas/utils/SchemaTestUtils.java", "diffHunk": "@@ -90,4 +91,71 @@ public void describeTo(Description description) {\n       description.appendText(expected.toString());\n     }\n   }\n+\n+  public static class RowFieldMatcher extends BaseMatcher<Row> {", "originalCommit": "091a5323b302b5e0ac8fb322ef80a38503957d0b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk3Mzc3MQ==", "url": "https://github.com/apache/beam/pull/10766#discussion_r374973771", "bodyText": "I assume there's no concern with removing Unnest outright (rather than deprecating for a period and pointing to Select.flattenedSchema) since this is all Experimental?", "author": "TheNeuralBit", "createdAt": "2020-02-04T23:03:30Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/transforms/Unnest.java", "diffHunk": "@@ -1,171 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.beam.sdk.schemas.transforms;\n-\n-import com.google.auto.value.AutoValue;\n-import java.util.List;\n-import org.apache.beam.sdk.annotations.Experimental;\n-import org.apache.beam.sdk.annotations.Experimental.Kind;\n-import org.apache.beam.sdk.schemas.Schema;\n-import org.apache.beam.sdk.schemas.Schema.Field;\n-import org.apache.beam.sdk.transforms.DoFn;\n-import org.apache.beam.sdk.transforms.PTransform;\n-import org.apache.beam.sdk.transforms.ParDo;\n-import org.apache.beam.sdk.transforms.SerializableFunction;\n-import org.apache.beam.sdk.values.PCollection;\n-import org.apache.beam.sdk.values.Row;\n-import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n-\n-/**\n- * A {@link PTransform} to unnest nested rows.\n- *\n- * <p>For example, consider a Row with the following nestedschema:\n- *\n- * <p>UserEvent Schema: userid: INT64 timestamp: DATETIME location: LatLong\n- *\n- * <p>LatLong Schema: latitude: DOUBLE longitude: DOUBLE\n- *\n- * <p>After unnesting, all of the rows will be converted to rows satisfying the following schema:\n- *\n- * <p>UserEvent Schema: userid: INT64 timestamp: DATETIME location.latitude: DOUBLE\n- * location.longitude: DOUBLE\n- *\n- * <p>By default nested names are concatenated to generated the unnested name, however {@link\n- * Unnest.Inner#withFieldNameFunction} can be used to specify a custom naming policy.\n- *\n- * <p>Note that currently array and map values are not unnested.\n- */\n-@Experimental(Kind.SCHEMAS)\n-public class Unnest {", "originalCommit": "091a5323b302b5e0ac8fb322ef80a38503957d0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjAyOTYwOA==", "url": "https://github.com/apache/beam/pull/10766#discussion_r376029608", "bodyText": "yeah - should be fine I think.", "author": "reuvenlax", "createdAt": "2020-02-06T19:15:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk3Mzc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk3NDY2Mg==", "url": "https://github.com/apache/beam/pull/10766#discussion_r374974662", "bodyText": "Consider adding a test for this in FieldAccessDescriptorTest, and adding a docstring", "author": "TheNeuralBit", "createdAt": "2020-02-04T23:06:01Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/FieldAccessDescriptor.java", "diffHunk": "@@ -300,6 +340,16 @@ public FieldAccessDescriptor withNestedField(\n     return withNestedField(field, fieldAccess);\n   }\n \n+  public FieldAccessDescriptor withNestedFieldAs(\n+      String nestedFieldName, String nestedFieldRename, FieldAccessDescriptor fieldAccess) {\n+    FieldDescriptor field =\n+        FieldDescriptor.builder()\n+            .setFieldName(nestedFieldName)\n+            .setFieldRename(nestedFieldRename)\n+            .build();\n+    return withNestedField(field, fieldAccess);\n+  }\n+", "originalCommit": "091a5323b302b5e0ac8fb322ef80a38503957d0b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dca23a25452eed259d23851097648215d83e8983", "url": "https://github.com/apache/beam/commit/dca23a25452eed259d23851097648215d83e8983", "message": "Add Selected.flattenedSchema", "committedDate": "2020-02-07T22:20:39Z", "type": "commit"}, {"oid": "dca23a25452eed259d23851097648215d83e8983", "url": "https://github.com/apache/beam/commit/dca23a25452eed259d23851097648215d83e8983", "message": "Add Selected.flattenedSchema", "committedDate": "2020-02-07T22:20:39Z", "type": "forcePushed"}, {"oid": "0fcc2bb47c928163c1f881d89467be9c9a6cc0e6", "url": "https://github.com/apache/beam/commit/0fcc2bb47c928163c1f881d89467be9c9a6cc0e6", "message": "spotless", "committedDate": "2020-02-07T22:25:56Z", "type": "commit"}, {"oid": "5feb89d184d0fccf0899bbbaf6ec4e913b63f7a7", "url": "https://github.com/apache/beam/commit/5feb89d184d0fccf0899bbbaf6ec4e913b63f7a7", "message": "fix spotbugs", "committedDate": "2020-02-07T23:48:31Z", "type": "commit"}]}