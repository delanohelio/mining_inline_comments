{"pr_number": 11185, "pr_title": "[BEAM-8019] Updates Python SDK to handle remote SDK coders and preserve tags added by remote SDKs and propagate restriction coders.", "pr_createdAt": "2020-03-20T21:55:49Z", "pr_url": "https://github.com/apache/beam/pull/11185", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk0NDAzMw==", "url": "https://github.com/apache/beam/pull/11185#discussion_r395944033", "bodyText": "yapf -ir path/to/files/...", "author": "robertwb", "createdAt": "2020-03-21T00:47:35Z", "path": "sdks/python/apache_beam/coders/coders.py", "diffHunk": "@@ -1383,22 +1377,67 @@ def from_runner_api_parameter(payload, components, context):\n         write_state_threshold=int(payload))\n \n \n-class RunnerAPICoderHolder(Coder):\n-  \"\"\"A `Coder` that holds a runner API `Coder` proto.\n+class ElementTypeHolder(typehints.TypeConstraint):\n+  \"\"\"A dummy element type for external coders that cannot be parsed in Python\"\"\"\n \n-  This is used for coders for which corresponding objects cannot be\n-  initialized in Python SDK. For example, coders for remote SDKs that may\n-  be available in Python SDK transform graph when expanding a cross-language\n-  transform.\n-  \"\"\"\n-  def __init__(self, proto):\n-    self._proto = proto\n+  def __init__(self, coder, context):\n+    self.coder = coder\n+    self.context = context\n \n-  def proto(self):\n-    return self._proto\n \n-  def to_runner_api(self, context):\n-    return self._proto\n+class ExternalCoder(Coder):\n \n-  def to_type_hint(self):\n-    return Any\n+  coder_count = 0\n+\n+  def __init__(self, element_type_holder):\n+    self.element_type_holder = element_type_holder\n+\n+  def as_cloud_object(self, coders_context=None):\n+    if not coders_context:\n+      raise Exception(\n+          'coders_context must be specified to correctly encode external coders')\n+    coder_id = coders_context.get_by_proto(\n+        self.element_type_holder.coder, deduplicate=True)\n+\n+    coder_proto = self.element_type_holder.coder\n+\n+\n+    kind_str = 'kind:external' + str(ExternalCoder.coder_count)\n+    ExternalCoder.coder_count = ExternalCoder.coder_count + 1\n+    component_encodings = []\n+    if coder_proto.spec.urn == 'beam:coder:kv:v1':\n+      kind_str = 'kind:pair'\n+      for component_coder_id in coder_proto.component_coder_ids:\n+        component_encodings.append({\n+            '@type': 'kind:external' + str(ExternalCoder.coder_count),\n+            'pipeline_proto_coder_id': component_coder_id\n+        })\n+        ExternalCoder.coder_count = ExternalCoder.coder_count + 1\n+\n+    value = {\n+        # This is a placeholder type. Dataflow will get the actual coder from\n+        # pipeline proto using the pipeline_proto_coder_id property.\n+        '@type': kind_str,\n+        'pipeline_proto_coder_id': coder_id\n+    }\n+    if component_encodings:\n+      value['is_pair_like'] = True\n+      value['component_encodings'] = component_encodings\n+\n+    return value\n+\n+  @staticmethod\n+  def from_type_hint(typehint, unused_registry):\n+    if isinstance(typehint, ElementTypeHolder):\n+      return ExternalCoder(typehint)\n+    else:\n+      raise ValueError((\n+          'Expected an instance of ElementTypeHolder'\n+          ', but got a %s' % typehint))\n+", "originalCommit": "5d0a1e81ef2253087c764cede44d3a587e9aea7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYxOTc4MQ==", "url": "https://github.com/apache/beam/pull/11185#discussion_r396619781", "bodyText": "Done.", "author": "chamikaramj", "createdAt": "2020-03-23T17:17:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk0NDAzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk0NDMzMw==", "url": "https://github.com/apache/beam/pull/11185#discussion_r395944333", "bodyText": "This all seems rather fragile. Would it be possible to just make side_inputs a dict everywhere in the internal SDK representation? (Or is there introspection with the legacy worker code that would make this hard?)", "author": "robertwb", "createdAt": "2020-03-21T00:49:58Z", "path": "sdks/python/apache_beam/pipeline.py", "diffHunk": "@@ -1127,30 +1133,79 @@ def transform_to_runner_api(transform,  # type: Optional[ptransform.PTransform]\n   def from_runner_api(proto,  # type: beam_runner_api_pb2.PTransform\n                       context  # type: PipelineContext\n                      ):\n+    side_input_tags = []\n+    if common_urns.primitives.PAR_DO.urn == proto.spec.urn:\n+      # Preserving side input tags.\n+      from apache_beam.utils import proto_utils\n+      from apache_beam.portability.api import beam_runner_api_pb2\n+      payload = (\n+          proto_utils.parse_Bytes(\n+              proto.spec.payload, beam_runner_api_pb2.ParDoPayload))\n+      for tag, si in payload.side_inputs.items():\n+        side_input_tags.append(tag)\n+\n     # type: (...) -> AppliedPTransform\n-    def is_side_input(tag):\n-      # type: (str) -> bool\n+    def is_python_side_input(tag):\n       # As per named_inputs() above.\n-      return tag.startswith('side')\n+      return re.match(SIDE_INPUT_REGEX, tag)\n+\n+    all_input_tags = [tag for tag, id in proto.inputs.items()]\n+\n+    # All side inputs have to be available in input tags\n+    python_indexed_side_inputs = False\n+    for side_tag in side_input_tags:\n+      if side_tag not in all_input_tags:\n+        raise Exception(\n+            'Side input tag %s is not available in list of input tags %r' %\n+            (side_tag, all_input_tags))\n+\n+      # We process Python and external side inputs differently. We fail early\n+      # here if we cannot decide which way to go.\n+      if is_python_side_input(side_tag):\n+        python_indexed_side_inputs = True\n+      else:\n+        if python_indexed_side_inputs:\n+          raise Exception(\n+              'Cannot process side inputs due to inconsistent sideinput '\n+              'naming. If using an external transform consider re-naming side '\n+              'inputs to not match Python indexed format %s' %\n+              SIDE_INPUT_REGEX)\n \n     main_inputs = [\n         context.pcollections.get_by_id(id) for tag,\n-        id in proto.inputs.items() if not is_side_input(tag)\n+        id in proto.inputs.items() if tag not in side_input_tags\n     ]\n \n-    # Ordering is important here.\n-    indexed_side_inputs = [\n-        (get_sideinput_index(tag), context.pcollections.get_by_id(id)) for tag,\n-        id in proto.inputs.items() if is_side_input(tag)\n-    ]\n-    side_inputs = [si for _, si in sorted(indexed_side_inputs)]\n+    if python_indexed_side_inputs:\n+      # Ordering is important here.", "originalCommit": "5d0a1e81ef2253087c764cede44d3a587e9aea7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYyMDg4Mg==", "url": "https://github.com/apache/beam/pull/11185#discussion_r396620882", "bodyText": "I slightly reverted some of the code here to preserve the old behavior for Python. New changes are basically to preserve input tags for remote SDKs instead of letting Python override tags (which breaks Java).", "author": "chamikaramj", "createdAt": "2020-03-23T17:19:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk0NDMzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NDA3OA==", "url": "https://github.com/apache/beam/pull/11185#discussion_r402674078", "bodyText": "Thanks. This is still has to work around the existing ugliness, but looks much better now.", "author": "robertwb", "createdAt": "2020-04-03T00:39:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk0NDMzMw=="}], "type": "inlineReview"}, {"oid": "e84f6e8db3f9f69c04664370b67fd8dcea6319b4", "url": "https://github.com/apache/beam/commit/e84f6e8db3f9f69c04664370b67fd8dcea6319b4", "message": "Fixes to tests and lint.", "committedDate": "2020-03-23T17:14:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUzODkyMw==", "url": "https://github.com/apache/beam/pull/11185#discussion_r397538923", "bodyText": "I see this referenced half a dozen times below. Perhaps encapsulate the increment+return in a method _unique_id or similar?", "author": "robertwb", "createdAt": "2020-03-25T00:18:10Z", "path": "sdks/python/apache_beam/coders/coders.py", "diffHunk": "@@ -1383,22 +1375,74 @@ def from_runner_api_parameter(payload, components, context):\n         write_state_threshold=int(payload))\n \n \n-class RunnerAPICoderHolder(Coder):\n+class ElementTypeHolder(typehints.TypeConstraint):\n+  \"\"\"A dummy element type for external coders that cannot be parsed in Python\"\"\"\n+  def __init__(self, coder, context):\n+    self.coder = coder\n+    self.context = context\n+\n+\n+class ExternalCoder(Coder):\n   \"\"\"A `Coder` that holds a runner API `Coder` proto.\n \n   This is used for coders for which corresponding objects cannot be\n   initialized in Python SDK. For example, coders for remote SDKs that may\n   be available in Python SDK transform graph when expanding a cross-language\n   transform.\n   \"\"\"\n-  def __init__(self, proto):\n-    self._proto = proto\n \n-  def proto(self):\n-    return self._proto\n+  coder_count = 0", "originalCommit": "8937c8aee599482b656bb2c832946beacf639286", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk1NzM5NA==", "url": "https://github.com/apache/beam/pull/11185#discussion_r397957394", "bodyText": "This was just added for logging/debugging. Removed.", "author": "chamikaramj", "createdAt": "2020-03-25T15:42:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUzODkyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUzOTA4Mg==", "url": "https://github.com/apache/beam/pull/11185#discussion_r397539082", "bodyText": "s/coder/coder_proto/ to be clear what it is?", "author": "robertwb", "createdAt": "2020-03-25T00:18:40Z", "path": "sdks/python/apache_beam/coders/coders.py", "diffHunk": "@@ -1383,22 +1375,74 @@ def from_runner_api_parameter(payload, components, context):\n         write_state_threshold=int(payload))\n \n \n-class RunnerAPICoderHolder(Coder):\n+class ElementTypeHolder(typehints.TypeConstraint):\n+  \"\"\"A dummy element type for external coders that cannot be parsed in Python\"\"\"\n+  def __init__(self, coder, context):", "originalCommit": "8937c8aee599482b656bb2c832946beacf639286", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk0NjcxOA==", "url": "https://github.com/apache/beam/pull/11185#discussion_r397946718", "bodyText": "Done.", "author": "chamikaramj", "createdAt": "2020-03-25T15:29:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUzOTA4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU0MDA4OA==", "url": "https://github.com/apache/beam/pull/11185#discussion_r397540088", "bodyText": "What about correctly handling kind:stream? Perhaps others? It seems it would be preferable to instead try to only use external_coder for the unknown leafs rather than duplicate this special-dataflow logic here.", "author": "robertwb", "createdAt": "2020-03-25T00:22:05Z", "path": "sdks/python/apache_beam/coders/coders.py", "diffHunk": "@@ -1383,22 +1375,74 @@ def from_runner_api_parameter(payload, components, context):\n         write_state_threshold=int(payload))\n \n \n-class RunnerAPICoderHolder(Coder):\n+class ElementTypeHolder(typehints.TypeConstraint):\n+  \"\"\"A dummy element type for external coders that cannot be parsed in Python\"\"\"\n+  def __init__(self, coder, context):\n+    self.coder = coder\n+    self.context = context\n+\n+\n+class ExternalCoder(Coder):\n   \"\"\"A `Coder` that holds a runner API `Coder` proto.\n \n   This is used for coders for which corresponding objects cannot be\n   initialized in Python SDK. For example, coders for remote SDKs that may\n   be available in Python SDK transform graph when expanding a cross-language\n   transform.\n   \"\"\"\n-  def __init__(self, proto):\n-    self._proto = proto\n \n-  def proto(self):\n-    return self._proto\n+  coder_count = 0\n \n-  def to_runner_api(self, context):\n-    return self._proto\n+  def __init__(self, element_type_holder):\n+    self.element_type_holder = element_type_holder\n \n-  def to_type_hint(self):\n-    return Any\n+  def as_cloud_object(self, coders_context=None):\n+    if not coders_context:\n+      raise Exception(\n+          'coders_context must be specified to correctly encode external coders'\n+      )\n+    coder_id = coders_context.get_by_proto(\n+        self.element_type_holder.coder, deduplicate=True)\n+\n+    coder_proto = self.element_type_holder.coder\n+\n+    kind_str = 'kind:external' + str(ExternalCoder.coder_count)\n+    ExternalCoder.coder_count = ExternalCoder.coder_count + 1\n+    component_encodings = []\n+    if coder_proto.spec.urn == 'beam:coder:kv:v1':", "originalCommit": "8937c8aee599482b656bb2c832946beacf639286", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM0ODUyNA==", "url": "https://github.com/apache/beam/pull/11185#discussion_r399348524", "bodyText": "This does not seems to be needed for now (at least to get the test suite working). So I added a TODO here.  Also, note that 'kind:extenal' was used to represent Java only Void coder here, so we'll probably continue to need that even if we handle 'kind:stream' here. Lemme know if you think this is inadequate for this PR.", "author": "chamikaramj", "createdAt": "2020-03-27T15:28:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU0MDA4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU2MzM3Mg==", "url": "https://github.com/apache/beam/pull/11185#discussion_r399563372", "bodyText": "I anticipate kind:stream will be needed to handle GBK of unknown types. Others may be needed for other cases, or in the future, and it seems risky to enumerate them here and in the dataflow runner. There may also be cases where we have to go more than one level deep. We should try to return the same thing the external SDK would have returned just to be safe, and that means wrapping only the leaves as external coders. I think that'll clean stuff up as well (e.g. no need for _coerce_to_kv_type_from_external_type).", "author": "robertwb", "createdAt": "2020-03-27T22:18:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU0MDA4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyNTM5MA==", "url": "https://github.com/apache/beam/pull/11185#discussion_r401225390", "bodyText": "Cleaned this up. Now we only handle unknown types here.", "author": "chamikaramj", "createdAt": "2020-03-31T21:26:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU0MDA4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU0MDk2MA==", "url": "https://github.com/apache/beam/pull/11185#discussion_r397540960", "bodyText": "Why raise NotImplementedError here instead of returning this in place of the empty tuple below?", "author": "robertwb", "createdAt": "2020-03-25T00:24:48Z", "path": "sdks/python/apache_beam/coders/coders.py", "diffHunk": "@@ -1383,22 +1375,74 @@ def from_runner_api_parameter(payload, components, context):\n         write_state_threshold=int(payload))\n \n \n-class RunnerAPICoderHolder(Coder):\n+class ElementTypeHolder(typehints.TypeConstraint):\n+  \"\"\"A dummy element type for external coders that cannot be parsed in Python\"\"\"\n+  def __init__(self, coder, context):\n+    self.coder = coder\n+    self.context = context\n+\n+\n+class ExternalCoder(Coder):\n   \"\"\"A `Coder` that holds a runner API `Coder` proto.\n \n   This is used for coders for which corresponding objects cannot be\n   initialized in Python SDK. For example, coders for remote SDKs that may\n   be available in Python SDK transform graph when expanding a cross-language\n   transform.\n   \"\"\"\n-  def __init__(self, proto):\n-    self._proto = proto\n \n-  def proto(self):\n-    return self._proto\n+  coder_count = 0\n \n-  def to_runner_api(self, context):\n-    return self._proto\n+  def __init__(self, element_type_holder):\n+    self.element_type_holder = element_type_holder\n \n-  def to_type_hint(self):\n-    return Any\n+  def as_cloud_object(self, coders_context=None):\n+    if not coders_context:\n+      raise Exception(\n+          'coders_context must be specified to correctly encode external coders'\n+      )\n+    coder_id = coders_context.get_by_proto(\n+        self.element_type_holder.coder, deduplicate=True)\n+\n+    coder_proto = self.element_type_holder.coder\n+\n+    kind_str = 'kind:external' + str(ExternalCoder.coder_count)\n+    ExternalCoder.coder_count = ExternalCoder.coder_count + 1\n+    component_encodings = []\n+    if coder_proto.spec.urn == 'beam:coder:kv:v1':\n+      kind_str = 'kind:pair'\n+      for component_coder_id in coder_proto.component_coder_ids:\n+        component_encodings.append({\n+            '@type': 'kind:external' + str(ExternalCoder.coder_count),\n+            'pipeline_proto_coder_id': component_coder_id\n+        })\n+        ExternalCoder.coder_count = ExternalCoder.coder_count + 1\n+\n+    value = {\n+        # This is a placeholder type. Dataflow will get the actual coder from\n+        # pipeline proto using the pipeline_proto_coder_id property.\n+        '@type': kind_str,\n+        'pipeline_proto_coder_id': coder_id\n+    }\n+    if component_encodings:\n+      value['is_pair_like'] = True\n+      value['component_encodings'] = component_encodings\n+\n+    return value\n+\n+  @staticmethod\n+  def from_type_hint(typehint, unused_registry):\n+    if isinstance(typehint, ElementTypeHolder):\n+      return ExternalCoder(typehint)\n+    else:\n+      raise ValueError((\n+          'Expected an instance of ElementTypeHolder'\n+          ', but got a %s' % typehint))\n+\n+  def to_runner_api_parameter(self, context):\n+    if self.element_type_holder.coder.component_coder_ids:\n+      raise NotImplementedError", "originalCommit": "8937c8aee599482b656bb2c832946beacf639286", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODExOTMwNA==", "url": "https://github.com/apache/beam/pull/11185#discussion_r398119304", "bodyText": "Done.", "author": "chamikaramj", "createdAt": "2020-03-25T19:36:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU0MDk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU0MTk0Mg==", "url": "https://github.com/apache/beam/pull/11185#discussion_r397541942", "bodyText": "new_context.put_proto?", "author": "robertwb", "createdAt": "2020-03-25T00:28:30Z", "path": "sdks/python/apache_beam/pvalue.py", "diffHunk": "@@ -181,11 +185,32 @@ def from_(pcoll):\n     \"\"\"\n     return PCollection(pcoll.pipeline, is_bounded=pcoll.is_bounded)\n \n+  def _recursively_add_external_coders(\n+      self, new_context, old_context, coder_proto):\n+    for component_coder_id in coder_proto.component_coder_ids:\n+      component_coder_proto = (\n+          old_context.coders.get_id_to_proto_map()[component_coder_id])\n+      new_context.coders.get_id_to_proto_map()[component_coder_id] = (", "originalCommit": "8937c8aee599482b656bb2c832946beacf639286", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE2MTM0Mw==", "url": "https://github.com/apache/beam/pull/11185#discussion_r398161343", "bodyText": "Done.", "author": "chamikaramj", "createdAt": "2020-03-25T20:52:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU0MTk0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU0MjE1Mg==", "url": "https://github.com/apache/beam/pull/11185#discussion_r397542152", "bodyText": "You could add a get_proto(id) method.", "author": "robertwb", "createdAt": "2020-03-25T00:29:05Z", "path": "sdks/python/apache_beam/pvalue.py", "diffHunk": "@@ -181,11 +185,32 @@ def from_(pcoll):\n     \"\"\"\n     return PCollection(pcoll.pipeline, is_bounded=pcoll.is_bounded)\n \n+  def _recursively_add_external_coders(\n+      self, new_context, old_context, coder_proto):\n+    for component_coder_id in coder_proto.component_coder_ids:\n+      component_coder_proto = (\n+          old_context.coders.get_id_to_proto_map()[component_coder_id])", "originalCommit": "8937c8aee599482b656bb2c832946beacf639286", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE2MTI4MA==", "url": "https://github.com/apache/beam/pull/11185#discussion_r398161280", "bodyText": "Done.", "author": "chamikaramj", "createdAt": "2020-03-25T20:51:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU0MjE1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU0MjU0Mg==", "url": "https://github.com/apache/beam/pull/11185#discussion_r397542542", "bodyText": "Could you make this work generically rather than having an isinstance(self.element_type, ElementTypeHolder) check above?", "author": "robertwb", "createdAt": "2020-03-25T00:30:31Z", "path": "sdks/python/apache_beam/pvalue.py", "diffHunk": "@@ -181,11 +185,32 @@ def from_(pcoll):\n     \"\"\"\n     return PCollection(pcoll.pipeline, is_bounded=pcoll.is_bounded)\n \n+  def _recursively_add_external_coders(\n+      self, new_context, old_context, coder_proto):\n+    for component_coder_id in coder_proto.component_coder_ids:\n+      component_coder_proto = (\n+          old_context.coders.get_id_to_proto_map()[component_coder_id])\n+      new_context.coders.get_id_to_proto_map()[component_coder_id] = (\n+          component_coder_proto)\n+      self._recursively_add_external_coders(\n+          new_context, old_context, component_coder_proto)\n+\n   def to_runner_api(self, context):\n     # type: (PipelineContext) -> beam_runner_api_pb2.PCollection\n+\n+    if isinstance(self.element_type, ElementTypeHolder):\n+      # This is potentially an coder in an external SDK that cannot be directly\n+      # parsed in Python SDK.\n+      coder_proto = self.element_type.coder\n+      coder_id = context.coders.get_by_proto(coder_proto, deduplicate=True)\n+      self._recursively_add_external_coders(\n+          context, self.element_type.context, coder_proto)\n+    else:\n+      coder_id = context.coder_id_from_element_type(self.element_type)", "originalCommit": "8937c8aee599482b656bb2c832946beacf639286", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU0MjY0OQ==", "url": "https://github.com/apache/beam/pull/11185#discussion_r397542649", "bodyText": "Maybe this'd require populating the map above with actual Coders as well as their protos.", "author": "robertwb", "createdAt": "2020-03-25T00:30:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU0MjU0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkzMjczMA==", "url": "https://github.com/apache/beam/pull/11185#discussion_r398932730", "bodyText": "Done.", "author": "chamikaramj", "createdAt": "2020-03-26T22:34:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU0MjU0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU0MzIzMw==", "url": "https://github.com/apache/beam/pull/11185#discussion_r397543233", "bodyText": "Have this method do the ExternalCoder stuff rather than catching an exception here. Possibly it would not even be needed if the coders map is properly populated beforehand.", "author": "robertwb", "createdAt": "2020-03-25T00:33:04Z", "path": "sdks/python/apache_beam/pvalue.py", "diffHunk": "@@ -208,9 +233,23 @@ def from_runner_api(proto, context):\n     # deserialization.  It will be populated soon after this call, in\n     # Pipeline.from_runner_api(). This brief period is the only time that\n     # PCollection.pipeline is allowed to be None.\n+\n+    try:\n+      element_type = context.element_type_from_coder_id(proto.coder_id)", "originalCommit": "8937c8aee599482b656bb2c832946beacf639286", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkyMjE0OA==", "url": "https://github.com/apache/beam/pull/11185#discussion_r398922148", "bodyText": "Done.", "author": "chamikaramj", "createdAt": "2020-03-26T22:08:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU0MzIzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU0MzUxOQ==", "url": "https://github.com/apache/beam/pull/11185#discussion_r397543519", "bodyText": "If you want to use this, let's put it in a shared utils file.", "author": "robertwb", "createdAt": "2020-03-25T00:33:52Z", "path": "sdks/python/apache_beam/runners/dataflow/dataflow_runner.py", "diffHunk": "@@ -380,7 +381,12 @@ def visit_transform(self, transform_node):\n         # pylint: disable=wrong-import-order, wrong-import-position\n         from apache_beam import Flatten\n         if isinstance(transform_node.transform, Flatten):\n-          output_pcoll = transform_node.outputs[None]\n+          from apache_beam.runners.portability.fn_api_runner.translations \\", "originalCommit": "8937c8aee599482b656bb2c832946beacf639286", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMxODY4Nw==", "url": "https://github.com/apache/beam/pull/11185#discussion_r399318687", "bodyText": "Implementation seems to be pretty straightforward. So just added a version to this file.", "author": "chamikaramj", "createdAt": "2020-03-27T14:47:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU0MzUxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU0MzgyMA==", "url": "https://github.com/apache/beam/pull/11185#discussion_r397543820", "bodyText": "only_element is fine to use everywhere, no need to branch on the key being None.", "author": "robertwb", "createdAt": "2020-03-25T00:35:03Z", "path": "sdks/python/apache_beam/runners/dataflow/dataflow_runner.py", "diffHunk": "@@ -380,7 +381,12 @@ def visit_transform(self, transform_node):\n         # pylint: disable=wrong-import-order, wrong-import-position\n         from apache_beam import Flatten\n         if isinstance(transform_node.transform, Flatten):\n-          output_pcoll = transform_node.outputs[None]\n+          from apache_beam.runners.portability.fn_api_runner.translations \\\n+            import only_element\n+          output_pcoll = (\n+              transform_node.outputs[None] if None in transform_node.outputs\n+              else only_element(transform_node.outputs.values()))", "originalCommit": "8937c8aee599482b656bb2c832946beacf639286", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkzODA4MQ==", "url": "https://github.com/apache/beam/pull/11185#discussion_r398938081", "bodyText": "Done.", "author": "chamikaramj", "createdAt": "2020-03-26T22:49:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU0MzgyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU2MTc5Ng==", "url": "https://github.com/apache/beam/pull/11185#discussion_r399561796", "bodyText": "I'd rather not do this for arbitrary exceptions, instead let's do this iff coder_proto.spec.urn is not in cls._known_urns.", "author": "robertwb", "createdAt": "2020-03-27T22:13:02Z", "path": "sdks/python/apache_beam/coders/coders.py", "diffHunk": "@@ -370,7 +370,8 @@ def from_runner_api(cls, coder_proto, context):\n     except Exception:\n       if context.allow_proto_holders:\n         # ignore this typing scenario for now, since it can't be easily tracked\n-        return RunnerAPICoderHolder(coder_proto)  # type: ignore\n+        return ExternalCoder(", "originalCommit": "80849ad2bfa61cab08055b9d8233d9cb8de5bfef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg1NTA2Mg==", "url": "https://github.com/apache/beam/pull/11185#discussion_r399855062", "bodyText": "Done.", "author": "chamikaramj", "createdAt": "2020-03-29T21:15:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU2MTc5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY2ODk4NQ==", "url": "https://github.com/apache/beam/pull/11185#discussion_r402668985", "bodyText": "Thanks. I think it'd be cleaner to just put this if instead of the try, and not have a broadly-catching \"except Exception\" block.", "author": "robertwb", "createdAt": "2020-04-03T00:21:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU2MTc5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI1MTk2Mg==", "url": "https://github.com/apache/beam/pull/11185#discussion_r403251962", "bodyText": "Done.", "author": "chamikaramj", "createdAt": "2020-04-03T19:05:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU2MTc5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU2MzkxOQ==", "url": "https://github.com/apache/beam/pull/11185#discussion_r399563919", "bodyText": "maybe is one word.", "author": "robertwb", "createdAt": "2020-03-27T22:19:50Z", "path": "sdks/python/apache_beam/pipeline.py", "diffHunk": "@@ -1102,6 +1105,10 @@ def transform_to_runner_api(transform,  # type: Optional[ptransform.PTransform]\n         (transform_urn in Pipeline.sdk_transforms_with_environment())):\n       environment_id = context.default_environment_id()\n \n+    def _may_be_preserve_tag(new_tag, pc, input_tags_to_preserve):", "originalCommit": "80849ad2bfa61cab08055b9d8233d9cb8de5bfef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg1NzcyMw==", "url": "https://github.com/apache/beam/pull/11185#discussion_r399857723", "bodyText": "Done.", "author": "chamikaramj", "createdAt": "2020-03-29T21:40:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU2MzkxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU2NDUzNg==", "url": "https://github.com/apache/beam/pull/11185#discussion_r399564536", "bodyText": "This'll break if a java user names their side inputs coincidentally something that matches.", "author": "robertwb", "createdAt": "2020-03-27T22:22:05Z", "path": "sdks/python/apache_beam/pipeline.py", "diffHunk": "@@ -1128,29 +1136,67 @@ def from_runner_api(proto,  # type: beam_runner_api_pb2.PTransform\n                       context  # type: PipelineContext\n                      ):\n     # type: (...) -> AppliedPTransform\n-    def is_side_input(tag):\n+    def is_python_side_input(tag):\n       # type: (str) -> bool\n       # As per named_inputs() above.\n-      return tag.startswith('side')\n+      return re.match(SIDE_INPUT_REGEX, tag)", "originalCommit": "80849ad2bfa61cab08055b9d8233d9cb8de5bfef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg5Njg3MA==", "url": "https://github.com/apache/beam/pull/11185#discussion_r399896870", "bodyText": "I changed the Python side input prefix from 'side' to 'python_side_input' (SIDE_INPUT_PREFIX) to make this tighter. This is still not 100% fail safe (an external SDK might still start side input tags with 'python_side_input') but I don't think this will be an issue in practice.", "author": "chamikaramj", "createdAt": "2020-03-30T02:27:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU2NDUzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU2NDg3Nw==", "url": "https://github.com/apache/beam/pull/11185#discussion_r399564877", "bodyText": "While we're here, did yapf not like this on the previous line? Maybe write (tag, pc) (unless it tries to split that too).", "author": "robertwb", "createdAt": "2020-03-27T22:23:11Z", "path": "sdks/python/apache_beam/pipeline.py", "diffHunk": "@@ -1110,7 +1117,8 @@ def transform_to_runner_api(transform,  # type: Optional[ptransform.PTransform]\n             for part in self.parts\n         ],\n         inputs={\n-            tag: context.pcollections.get_id(pc)\n+            _may_be_preserve_tag(tag, pc, self.input_tags_to_preserve):\n+            context.pcollections.get_id(pc)\n             for tag,\n             pc in sorted(self.named_inputs().items())", "originalCommit": "80849ad2bfa61cab08055b9d8233d9cb8de5bfef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYwNjI2NA==", "url": "https://github.com/apache/beam/pull/11185#discussion_r400606264", "bodyText": "Done.", "author": "chamikaramj", "createdAt": "2020-03-31T02:30:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU2NDg3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU2NTQzOQ==", "url": "https://github.com/apache/beam/pull/11185#discussion_r399565439", "bodyText": "Import at the top unless there's a reason (e.g. circular imports) that prevents it.", "author": "robertwb", "createdAt": "2020-03-27T22:25:12Z", "path": "sdks/python/apache_beam/pipeline.py", "diffHunk": "@@ -1128,29 +1136,67 @@ def from_runner_api(proto,  # type: beam_runner_api_pb2.PTransform\n                       context  # type: PipelineContext\n                      ):\n     # type: (...) -> AppliedPTransform\n-    def is_side_input(tag):\n+    def is_python_side_input(tag):\n       # type: (str) -> bool\n       # As per named_inputs() above.\n-      return tag.startswith('side')\n+      return re.match(SIDE_INPUT_REGEX, tag)\n+\n+    side_input_tags = []\n+    if common_urns.primitives.PAR_DO.urn == proto.spec.urn:\n+      # Preserving side input tags.\n+      from apache_beam.utils import proto_utils", "originalCommit": "80849ad2bfa61cab08055b9d8233d9cb8de5bfef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTAwOTEwOQ==", "url": "https://github.com/apache/beam/pull/11185#discussion_r401009109", "bodyText": "Moved proto_utils but left beam_runner_api_pb2 to prevent adding a dependency that to all runners (seems like this is imported similarly in other places in this file I suspect for the same reason).", "author": "chamikaramj", "createdAt": "2020-03-31T15:32:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU2NTQzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU2NjAyOQ==", "url": "https://github.com/apache/beam/pull/11185#discussion_r399566029", "bodyText": "List comprehension? Or just\nif ...:\n  ...\n  side_input_tags = list(payload.side_inputs.keys())\nelse:\n  side_input_tags = []", "author": "robertwb", "createdAt": "2020-03-27T22:27:10Z", "path": "sdks/python/apache_beam/pipeline.py", "diffHunk": "@@ -1128,29 +1136,67 @@ def from_runner_api(proto,  # type: beam_runner_api_pb2.PTransform\n                       context  # type: PipelineContext\n                      ):\n     # type: (...) -> AppliedPTransform\n-    def is_side_input(tag):\n+    def is_python_side_input(tag):\n       # type: (str) -> bool\n       # As per named_inputs() above.\n-      return tag.startswith('side')\n+      return re.match(SIDE_INPUT_REGEX, tag)\n+\n+    side_input_tags = []\n+    if common_urns.primitives.PAR_DO.urn == proto.spec.urn:\n+      # Preserving side input tags.\n+      from apache_beam.utils import proto_utils\n+      from apache_beam.portability.api import beam_runner_api_pb2\n+      payload = (\n+          proto_utils.parse_Bytes(\n+              proto.spec.payload, beam_runner_api_pb2.ParDoPayload))\n+      for tag, si in payload.side_inputs.items():", "originalCommit": "80849ad2bfa61cab08055b9d8233d9cb8de5bfef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg2ODk4MQ==", "url": "https://github.com/apache/beam/pull/11185#discussion_r399868981", "bodyText": "Done.", "author": "chamikaramj", "createdAt": "2020-03-29T23:20:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU2NjAyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU2ODk2Mw==", "url": "https://github.com/apache/beam/pull/11185#discussion_r399568963", "bodyText": "https://engdoc.corp.google.com/eng/doc/devguide/py/totw/026.md?cl=head", "author": "robertwb", "createdAt": "2020-03-27T22:37:27Z", "path": "sdks/python/apache_beam/pipeline.py", "diffHunk": "@@ -1128,29 +1136,67 @@ def from_runner_api(proto,  # type: beam_runner_api_pb2.PTransform\n                       context  # type: PipelineContext\n                      ):\n     # type: (...) -> AppliedPTransform\n-    def is_side_input(tag):\n+    def is_python_side_input(tag):\n       # type: (str) -> bool\n       # As per named_inputs() above.\n-      return tag.startswith('side')\n+      return re.match(SIDE_INPUT_REGEX, tag)\n+\n+    side_input_tags = []\n+    if common_urns.primitives.PAR_DO.urn == proto.spec.urn:\n+      # Preserving side input tags.\n+      from apache_beam.utils import proto_utils\n+      from apache_beam.portability.api import beam_runner_api_pb2\n+      payload = (\n+          proto_utils.parse_Bytes(\n+              proto.spec.payload, beam_runner_api_pb2.ParDoPayload))\n+      for tag, si in payload.side_inputs.items():\n+        side_input_tags.append(tag)\n \n     main_inputs = [\n         context.pcollections.get_by_id(id) for tag,\n-        id in proto.inputs.items() if not is_side_input(tag)\n+        id in proto.inputs.items() if tag not in side_input_tags\n     ]\n \n-    # Ordering is important here.\n-    indexed_side_inputs = [\n-        (get_sideinput_index(tag), context.pcollections.get_by_id(id)) for tag,\n-        id in proto.inputs.items() if is_side_input(tag)\n-    ]\n+    # Using a list here so that we can pass this into a function\n+    # TODO: use nonlocal after fully migrated to Python3.\n+    next_index = [0]\n+\n+    def _get_sideinput_index(tag, next_index):\n+      if is_python_side_input(tag):\n+        return get_sideinput_index(tag)\n+      else:\n+        index = next_index[0]\n+        next_index[0] = next_index[0] + 1\n+        return index\n+\n+    # Ordering is important here for Python sideinputs.\n+    indexed_side_inputs = [(\n+        _get_sideinput_index(tag, next_index),\n+        context.pcollections.get_by_id(id)) for tag,\n+                           id in proto.inputs.items() if tag in side_input_tags]\n     side_inputs = [si for _, si in sorted(indexed_side_inputs)]\n+\n+    input_tags_to_preserve = {}", "originalCommit": "80849ad2bfa61cab08055b9d8233d9cb8de5bfef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg3NDY5Nw==", "url": "https://github.com/apache/beam/pull/11185#discussion_r399874697", "bodyText": "Done.", "author": "chamikaramj", "createdAt": "2020-03-30T00:08:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU2ODk2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU2OTE1NQ==", "url": "https://github.com/apache/beam/pull/11185#discussion_r399569155", "bodyText": "Is AsMultiMap always the right thing to use?", "author": "robertwb", "createdAt": "2020-03-27T22:38:03Z", "path": "sdks/python/apache_beam/pipeline.py", "diffHunk": "@@ -1128,29 +1136,67 @@ def from_runner_api(proto,  # type: beam_runner_api_pb2.PTransform\n                       context  # type: PipelineContext\n                      ):\n     # type: (...) -> AppliedPTransform\n-    def is_side_input(tag):\n+    def is_python_side_input(tag):\n       # type: (str) -> bool\n       # As per named_inputs() above.\n-      return tag.startswith('side')\n+      return re.match(SIDE_INPUT_REGEX, tag)\n+\n+    side_input_tags = []\n+    if common_urns.primitives.PAR_DO.urn == proto.spec.urn:\n+      # Preserving side input tags.\n+      from apache_beam.utils import proto_utils\n+      from apache_beam.portability.api import beam_runner_api_pb2\n+      payload = (\n+          proto_utils.parse_Bytes(\n+              proto.spec.payload, beam_runner_api_pb2.ParDoPayload))\n+      for tag, si in payload.side_inputs.items():\n+        side_input_tags.append(tag)\n \n     main_inputs = [\n         context.pcollections.get_by_id(id) for tag,\n-        id in proto.inputs.items() if not is_side_input(tag)\n+        id in proto.inputs.items() if tag not in side_input_tags\n     ]\n \n-    # Ordering is important here.\n-    indexed_side_inputs = [\n-        (get_sideinput_index(tag), context.pcollections.get_by_id(id)) for tag,\n-        id in proto.inputs.items() if is_side_input(tag)\n-    ]\n+    # Using a list here so that we can pass this into a function\n+    # TODO: use nonlocal after fully migrated to Python3.\n+    next_index = [0]\n+\n+    def _get_sideinput_index(tag, next_index):\n+      if is_python_side_input(tag):\n+        return get_sideinput_index(tag)\n+      else:\n+        index = next_index[0]\n+        next_index[0] = next_index[0] + 1\n+        return index\n+\n+    # Ordering is important here for Python sideinputs.\n+    indexed_side_inputs = [(\n+        _get_sideinput_index(tag, next_index),\n+        context.pcollections.get_by_id(id)) for tag,\n+                           id in proto.inputs.items() if tag in side_input_tags]\n     side_inputs = [si for _, si in sorted(indexed_side_inputs)]\n+\n+    input_tags_to_preserve = {}\n+\n     transform = ptransform.PTransform.from_runner_api(proto, context)\n+    if isinstance(transform, RunnerAPIPTransformHolder):\n+      # For external transforms that are ParDos, we have to set side-inputs\n+      # manually and preserve input tags.\n+      transform.side_inputs = [pvalue.AsMultiMap(pc) for pc in side_inputs]", "originalCommit": "80849ad2bfa61cab08055b9d8233d9cb8de5bfef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDIzNTM1MQ==", "url": "https://github.com/apache/beam/pull/11185#discussion_r400235351", "bodyText": "I think this is always represented as a MultiMap given following but lemme know if I misunderstood this.\nhttps://github.com/apache/beam/blob/master/model/pipeline/src/main/proto/beam_runner_api.proto#L1115", "author": "chamikaramj", "createdAt": "2020-03-30T14:27:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU2OTE1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NTIyNg==", "url": "https://github.com/apache/beam/pull/11185#discussion_r402675226", "bodyText": "That's out of date: https://github.com/apache/beam/blob/master/model/pipeline/src/main/proto/beam_runner_api.proto#L395\nWe should be able to use pvalue.SideInputData.from_runner_api here.", "author": "robertwb", "createdAt": "2020-04-03T00:43:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU2OTE1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM1NDUwOQ==", "url": "https://github.com/apache/beam/pull/11185#discussion_r403354509", "bodyText": "Unfortunately 'pvalue.SideInputData.from_runner_api' is Python only and fails for external side inputs: https://github.com/apache/beam/blob/master/sdks/python/apache_beam/pvalue.py#L463\nSo enumerated the two supported types here and added a TODO.", "author": "chamikaramj", "createdAt": "2020-04-03T21:53:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU2OTE1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU2OTgzNA==", "url": "https://github.com/apache/beam/pull/11185#discussion_r399569834", "bodyText": "Is the sorting by python side input index needed at all in this path? If not, perhaps it should be in an else clause (where get_sideinput_index could be used unconditionally)?", "author": "robertwb", "createdAt": "2020-03-27T22:40:33Z", "path": "sdks/python/apache_beam/pipeline.py", "diffHunk": "@@ -1128,29 +1136,67 @@ def from_runner_api(proto,  # type: beam_runner_api_pb2.PTransform\n                       context  # type: PipelineContext\n                      ):\n     # type: (...) -> AppliedPTransform\n-    def is_side_input(tag):\n+    def is_python_side_input(tag):\n       # type: (str) -> bool\n       # As per named_inputs() above.\n-      return tag.startswith('side')\n+      return re.match(SIDE_INPUT_REGEX, tag)\n+\n+    side_input_tags = []\n+    if common_urns.primitives.PAR_DO.urn == proto.spec.urn:\n+      # Preserving side input tags.\n+      from apache_beam.utils import proto_utils\n+      from apache_beam.portability.api import beam_runner_api_pb2\n+      payload = (\n+          proto_utils.parse_Bytes(\n+              proto.spec.payload, beam_runner_api_pb2.ParDoPayload))\n+      for tag, si in payload.side_inputs.items():\n+        side_input_tags.append(tag)\n \n     main_inputs = [\n         context.pcollections.get_by_id(id) for tag,\n-        id in proto.inputs.items() if not is_side_input(tag)\n+        id in proto.inputs.items() if tag not in side_input_tags\n     ]\n \n-    # Ordering is important here.\n-    indexed_side_inputs = [\n-        (get_sideinput_index(tag), context.pcollections.get_by_id(id)) for tag,\n-        id in proto.inputs.items() if is_side_input(tag)\n-    ]\n+    # Using a list here so that we can pass this into a function\n+    # TODO: use nonlocal after fully migrated to Python3.\n+    next_index = [0]\n+\n+    def _get_sideinput_index(tag, next_index):\n+      if is_python_side_input(tag):\n+        return get_sideinput_index(tag)\n+      else:\n+        index = next_index[0]\n+        next_index[0] = next_index[0] + 1\n+        return index\n+\n+    # Ordering is important here for Python sideinputs.\n+    indexed_side_inputs = [(\n+        _get_sideinput_index(tag, next_index),\n+        context.pcollections.get_by_id(id)) for tag,\n+                           id in proto.inputs.items() if tag in side_input_tags]\n     side_inputs = [si for _, si in sorted(indexed_side_inputs)]\n+\n+    input_tags_to_preserve = {}\n+\n     transform = ptransform.PTransform.from_runner_api(proto, context)\n+    if isinstance(transform, RunnerAPIPTransformHolder):", "originalCommit": "80849ad2bfa61cab08055b9d8233d9cb8de5bfef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDIyODk0NQ==", "url": "https://github.com/apache/beam/pull/11185#discussion_r400228945", "bodyText": "It's only needed for Python. Updated.", "author": "chamikaramj", "createdAt": "2020-03-30T14:19:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU2OTgzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3MDEzOA==", "url": "https://github.com/apache/beam/pull/11185#discussion_r399570138", "bodyText": "It feels like this could result in duplicate indices if side one has tags named ['tag', 'side0', ...]. But maybe in that case it's OK?\nPlease reference (create?) a JIRA about making side inputs always key-valued rather than having this kind of logic (here and elsewhere).", "author": "robertwb", "createdAt": "2020-03-27T22:41:42Z", "path": "sdks/python/apache_beam/pipeline.py", "diffHunk": "@@ -1128,29 +1136,67 @@ def from_runner_api(proto,  # type: beam_runner_api_pb2.PTransform\n                       context  # type: PipelineContext\n                      ):\n     # type: (...) -> AppliedPTransform\n-    def is_side_input(tag):\n+    def is_python_side_input(tag):\n       # type: (str) -> bool\n       # As per named_inputs() above.\n-      return tag.startswith('side')\n+      return re.match(SIDE_INPUT_REGEX, tag)\n+\n+    side_input_tags = []\n+    if common_urns.primitives.PAR_DO.urn == proto.spec.urn:\n+      # Preserving side input tags.\n+      from apache_beam.utils import proto_utils\n+      from apache_beam.portability.api import beam_runner_api_pb2\n+      payload = (\n+          proto_utils.parse_Bytes(\n+              proto.spec.payload, beam_runner_api_pb2.ParDoPayload))\n+      for tag, si in payload.side_inputs.items():\n+        side_input_tags.append(tag)\n \n     main_inputs = [\n         context.pcollections.get_by_id(id) for tag,\n-        id in proto.inputs.items() if not is_side_input(tag)\n+        id in proto.inputs.items() if tag not in side_input_tags\n     ]\n \n-    # Ordering is important here.\n-    indexed_side_inputs = [\n-        (get_sideinput_index(tag), context.pcollections.get_by_id(id)) for tag,\n-        id in proto.inputs.items() if is_side_input(tag)\n-    ]\n+    # Using a list here so that we can pass this into a function\n+    # TODO: use nonlocal after fully migrated to Python3.\n+    next_index = [0]\n+\n+    def _get_sideinput_index(tag, next_index):", "originalCommit": "80849ad2bfa61cab08055b9d8233d9cb8de5bfef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDIyODQxMw==", "url": "https://github.com/apache/beam/pull/11185#discussion_r400228413", "bodyText": "Refactored this logic to better separate out Python and external SDK paths and added a JIRA.", "author": "chamikaramj", "createdAt": "2020-03-30T14:18:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3MDEzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3MDUwMA==", "url": "https://github.com/apache/beam/pull/11185#discussion_r399570500", "bodyText": "Can apache_beam.coders.coders not be imported at the top? In which case, it seems this whole method can be a one-liner at the call site.", "author": "robertwb", "createdAt": "2020-03-27T22:43:10Z", "path": "sdks/python/apache_beam/runners/dataflow/dataflow_runner.py", "diffHunk": "@@ -558,6 +564,14 @@ def run_pipeline(self, pipeline, options):\n     result.metric_results = self._metrics\n     return result\n \n+  def _get_encoding_for_external_environment(self, element):\n+    if not isinstance(element, ElementTypeHolder):\n+      raise Exception(\n+          'Expected to receive an object of type ElementTypeHolder '\n+          'but received %r' % element)\n+    from apache_beam.coders.coders import ExternalCoder", "originalCommit": "80849ad2bfa61cab08055b9d8233d9cb8de5bfef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIwNjUyMQ==", "url": "https://github.com/apache/beam/pull/11185#discussion_r401206521", "bodyText": "Done.", "author": "chamikaramj", "createdAt": "2020-03-31T20:49:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3MDUwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3MTA1Mg==", "url": "https://github.com/apache/beam/pull/11185#discussion_r399571052", "bodyText": "Ditto on import. (And any below.)", "author": "robertwb", "createdAt": "2020-03-27T22:45:07Z", "path": "sdks/python/apache_beam/runners/dataflow/dataflow_runner.py", "diffHunk": "@@ -597,19 +611,47 @@ def _get_side_input_encoding(self, input_encoding):\n         },\n     }\n \n-  def _get_encoded_output_coder(self, transform_node, window_value=True):\n-    \"\"\"Returns the cloud encoding of the coder for the output of a transform.\"\"\"\n-    from apache_beam.runners.portability.fn_api_runner.translations import \\\n-      only_element\n-    if len(transform_node.outputs) == 1:\n-      output_tag = only_element(transform_node.outputs.keys())\n-      # TODO(robertwb): Handle type hints for multi-output transforms.\n+  def _get_encoded_output_coder(\n+      self, transform_node, window_value=True, output_tag=None):\n+    \"\"\"Returns the cloud encoding of the coder for the output of a transform.\n+\n+    If output_tag is not specified, we assume all outputs to have the same\n+    encoding.\n+    \"\"\"\n+    from apache_beam.transforms.core import RunnerAPIPTransformHolder", "originalCommit": "80849ad2bfa61cab08055b9d8233d9cb8de5bfef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIwNjg4Mg==", "url": "https://github.com/apache/beam/pull/11185#discussion_r401206882", "bodyText": "Done.", "author": "chamikaramj", "createdAt": "2020-03-31T20:50:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3MTA1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3MTI5NQ==", "url": "https://github.com/apache/beam/pull/11185#discussion_r399571295", "bodyText": "This is only legal if there is only one output, right? Given the logic, it seems it's never actually used.", "author": "robertwb", "createdAt": "2020-03-27T22:46:03Z", "path": "sdks/python/apache_beam/runners/dataflow/dataflow_runner.py", "diffHunk": "@@ -597,19 +611,47 @@ def _get_side_input_encoding(self, input_encoding):\n         },\n     }\n \n-  def _get_encoded_output_coder(self, transform_node, window_value=True):\n-    \"\"\"Returns the cloud encoding of the coder for the output of a transform.\"\"\"\n-    from apache_beam.runners.portability.fn_api_runner.translations import \\\n-      only_element\n-    if len(transform_node.outputs) == 1:\n-      output_tag = only_element(transform_node.outputs.keys())\n-      # TODO(robertwb): Handle type hints for multi-output transforms.\n+  def _get_encoded_output_coder(\n+      self, transform_node, window_value=True, output_tag=None):\n+    \"\"\"Returns the cloud encoding of the coder for the output of a transform.\n+\n+    If output_tag is not specified, we assume all outputs to have the same\n+    encoding.\n+    \"\"\"\n+    from apache_beam.transforms.core import RunnerAPIPTransformHolder\n+    external_transform = isinstance(\n+        transform_node.transform, RunnerAPIPTransformHolder)\n+    if external_transform and not output_tag:\n+      raise Exception('For external transforms, output_tag must be specified')\n+\n+    if not output_tag:\n+      output_tag = next(iter(transform_node.outputs.keys()))", "originalCommit": "80849ad2bfa61cab08055b9d8233d9cb8de5bfef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDI5OTIxMw==", "url": "https://github.com/apache/beam/pull/11185#discussion_r400299213", "bodyText": "Restructured the code.", "author": "chamikaramj", "createdAt": "2020-03-30T15:48:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3MTI5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3MTM1MA==", "url": "https://github.com/apache/beam/pull/11185#discussion_r399571350", "bodyText": "Why?", "author": "robertwb", "createdAt": "2020-03-27T22:46:17Z", "path": "sdks/python/apache_beam/runners/dataflow/dataflow_runner.py", "diffHunk": "@@ -597,19 +611,47 @@ def _get_side_input_encoding(self, input_encoding):\n         },\n     }\n \n-  def _get_encoded_output_coder(self, transform_node, window_value=True):\n-    \"\"\"Returns the cloud encoding of the coder for the output of a transform.\"\"\"\n-    from apache_beam.runners.portability.fn_api_runner.translations import \\\n-      only_element\n-    if len(transform_node.outputs) == 1:\n-      output_tag = only_element(transform_node.outputs.keys())\n-      # TODO(robertwb): Handle type hints for multi-output transforms.\n+  def _get_encoded_output_coder(\n+      self, transform_node, window_value=True, output_tag=None):\n+    \"\"\"Returns the cloud encoding of the coder for the output of a transform.\n+\n+    If output_tag is not specified, we assume all outputs to have the same\n+    encoding.\n+    \"\"\"\n+    from apache_beam.transforms.core import RunnerAPIPTransformHolder\n+    external_transform = isinstance(\n+        transform_node.transform, RunnerAPIPTransformHolder)\n+    if external_transform and not output_tag:\n+      raise Exception('For external transforms, output_tag must be specified')", "originalCommit": "80849ad2bfa61cab08055b9d8233d9cb8de5bfef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDI5ODk4OA==", "url": "https://github.com/apache/beam/pull/11185#discussion_r400298988", "bodyText": "Due to \"typehints.Any\" falling back to a Python only coder. Also restructured the code.", "author": "chamikaramj", "createdAt": "2020-03-30T15:48:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3MTM1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3Mjc3MQ==", "url": "https://github.com/apache/beam/pull/11185#discussion_r399572771", "bodyText": "Seems the logic should be\nif output_tag:\n  element_type = transform_node.outputs[output_tag].element_type\nelif len(transform_node.outputs) == 1:\n  element_type = only_element(transform_node.outputs).element_type\nelif external:\n    raise \"Tag required for external...\"\nelse:\n  element_type = typehints.Any", "author": "robertwb", "createdAt": "2020-03-27T22:51:38Z", "path": "sdks/python/apache_beam/runners/dataflow/dataflow_runner.py", "diffHunk": "@@ -597,19 +611,47 @@ def _get_side_input_encoding(self, input_encoding):\n         },\n     }\n \n-  def _get_encoded_output_coder(self, transform_node, window_value=True):\n-    \"\"\"Returns the cloud encoding of the coder for the output of a transform.\"\"\"\n-    from apache_beam.runners.portability.fn_api_runner.translations import \\\n-      only_element\n-    if len(transform_node.outputs) == 1:\n-      output_tag = only_element(transform_node.outputs.keys())\n-      # TODO(robertwb): Handle type hints for multi-output transforms.\n+  def _get_encoded_output_coder(\n+      self, transform_node, window_value=True, output_tag=None):\n+    \"\"\"Returns the cloud encoding of the coder for the output of a transform.\n+\n+    If output_tag is not specified, we assume all outputs to have the same\n+    encoding.\n+    \"\"\"\n+    from apache_beam.transforms.core import RunnerAPIPTransformHolder\n+    external_transform = isinstance(\n+        transform_node.transform, RunnerAPIPTransformHolder)\n+    if external_transform and not output_tag:\n+      raise Exception('For external transforms, output_tag must be specified')\n+\n+    if not output_tag:\n+      output_tag = next(iter(transform_node.outputs.keys()))\n+\n+    element_type = None\n+    if external_transform:", "originalCommit": "80849ad2bfa61cab08055b9d8233d9cb8de5bfef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDI5OTMzOA==", "url": "https://github.com/apache/beam/pull/11185#discussion_r400299338", "bodyText": "Done. Thanks.", "author": "chamikaramj", "createdAt": "2020-03-30T15:48:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3Mjc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3MzI1OQ==", "url": "https://github.com/apache/beam/pull/11185#discussion_r399573259", "bodyText": "Don't duplicate this logic, instead augment _get_typehint_based_encoding (well, really coders.registry.get_coder) to do the natural thing for ElementTypeHolders.", "author": "robertwb", "createdAt": "2020-03-27T22:53:17Z", "path": "sdks/python/apache_beam/runners/dataflow/dataflow_runner.py", "diffHunk": "@@ -597,19 +611,47 @@ def _get_side_input_encoding(self, input_encoding):\n         },\n     }\n \n-  def _get_encoded_output_coder(self, transform_node, window_value=True):\n-    \"\"\"Returns the cloud encoding of the coder for the output of a transform.\"\"\"\n-    from apache_beam.runners.portability.fn_api_runner.translations import \\\n-      only_element\n-    if len(transform_node.outputs) == 1:\n-      output_tag = only_element(transform_node.outputs.keys())\n-      # TODO(robertwb): Handle type hints for multi-output transforms.\n+  def _get_encoded_output_coder(\n+      self, transform_node, window_value=True, output_tag=None):\n+    \"\"\"Returns the cloud encoding of the coder for the output of a transform.\n+\n+    If output_tag is not specified, we assume all outputs to have the same\n+    encoding.\n+    \"\"\"\n+    from apache_beam.transforms.core import RunnerAPIPTransformHolder\n+    external_transform = isinstance(\n+        transform_node.transform, RunnerAPIPTransformHolder)\n+    if external_transform and not output_tag:\n+      raise Exception('For external transforms, output_tag must be specified')\n+\n+    if not output_tag:\n+      output_tag = next(iter(transform_node.outputs.keys()))\n+\n+    element_type = None\n+    if external_transform:\n       element_type = transform_node.outputs[output_tag].element_type\n+      # We perform special encoding for any external coders that cannot be\n+      # parsed in Python SDK.\n+      if isinstance(element_type, ElementTypeHolder):\n+        coder = self._get_encoding_for_external_environment(element_type)\n+        if window_value:", "originalCommit": "80849ad2bfa61cab08055b9d8233d9cb8de5bfef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQyNTgxOA==", "url": "https://github.com/apache/beam/pull/11185#discussion_r400425818", "bodyText": "Done.", "author": "chamikaramj", "createdAt": "2020-03-30T19:04:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3MzI1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3NDEzMw==", "url": "https://github.com/apache/beam/pull/11185#discussion_r399574133", "bodyText": "It seems cleaner to simply not populate the label_renames map in this case rather than add a branch here.", "author": "robertwb", "createdAt": "2020-03-27T22:56:38Z", "path": "sdks/python/apache_beam/runners/dataflow/dataflow_runner.py", "diffHunk": "@@ -925,8 +970,11 @@ def run_ParDo(self, transform_node, options):\n         (transform_proto.spec.urn == common_urns.primitives.PAR_DO.urn or\n          use_unified_worker)):\n       # Patch side input ids to be unique across a given pipeline.\n-      if (label_renames and\n-          transform_proto.spec.urn == common_urns.primitives.PAR_DO.urn):\n+      # This should not be done for external transforms since external SDKs may", "originalCommit": "80849ad2bfa61cab08055b9d8233d9cb8de5bfef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYwMTMyNw==", "url": "https://github.com/apache/beam/pull/11185#discussion_r400601327", "bodyText": "Done.", "author": "chamikaramj", "createdAt": "2020-03-31T02:11:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3NDEzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3NDk1OA==", "url": "https://github.com/apache/beam/pull/11185#discussion_r399574958", "bodyText": "Why do we need to branch on external_transform her?", "author": "robertwb", "createdAt": "2020-03-27T22:59:43Z", "path": "sdks/python/apache_beam/runners/dataflow/dataflow_runner.py", "diffHunk": "@@ -995,10 +1044,13 @@ def run_ParDo(self, transform_node, options):\n       # The assumption here is that all outputs will have the same typehint\n       # and coder as the main output. This is certainly the case right now\n       # but conceivably it could change in the future.\n+      encoding = self._get_encoded_output_coder(\n+          transform_node,\n+          output_tag=side_tag) if external_transform else step.encoding", "originalCommit": "80849ad2bfa61cab08055b9d8233d9cb8de5bfef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYwNDYxMw==", "url": "https://github.com/apache/beam/pull/11185#discussion_r400604613", "bodyText": "We don't have to. Previously we were using same encoding for all outputs for Python but seems like we can just generalize this without issues.", "author": "chamikaramj", "createdAt": "2020-03-31T02:24:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3NDk1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3NTYxMA==", "url": "https://github.com/apache/beam/pull/11185#discussion_r399575610", "bodyText": "If ignore_duplicates=True, should we ensure that the protos are the same?", "author": "robertwb", "createdAt": "2020-03-27T23:02:34Z", "path": "sdks/python/apache_beam/runners/pipeline_context.py", "diffHunk": "@@ -115,9 +115,12 @@ def get_id_to_proto_map(self):\n     # type: () -> Dict[str, message.Message]\n     return self._id_to_proto\n \n-  def put_proto(self, id, proto):\n+  def get_proto_from_id(self, id):\n+    return self.get_id_to_proto_map()[id]\n+\n+  def put_proto(self, id, proto, ignore_duplicates=False):\n     # type: (str, message.Message) -> str\n-    if id in self._id_to_proto:\n+    if not ignore_duplicates and id in self._id_to_proto:", "originalCommit": "80849ad2bfa61cab08055b9d8233d9cb8de5bfef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDYwNTQwMQ==", "url": "https://github.com/apache/beam/pull/11185#discussion_r400605401", "bodyText": "Done.", "author": "chamikaramj", "createdAt": "2020-03-31T02:27:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3NTYxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3NjQzNA==", "url": "https://github.com/apache/beam/pull/11185#discussion_r399576434", "bodyText": "Should this be an ExternalElementType?\nEven better, perhaps this should be a CoderElementType that holds a Coder (external or not), and then an ExternalCoder would be a Coder that holds a proto.", "author": "robertwb", "createdAt": "2020-03-27T23:05:55Z", "path": "sdks/python/apache_beam/coders/coders.py", "diffHunk": "@@ -1383,22 +1384,69 @@ def from_runner_api_parameter(payload, components, context):\n         write_state_threshold=int(payload))\n \n \n-class RunnerAPICoderHolder(Coder):\n+class ElementTypeHolder(typehints.TypeConstraint):", "originalCommit": "80849ad2bfa61cab08055b9d8233d9cb8de5bfef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg1NjYxMQ==", "url": "https://github.com/apache/beam/pull/11185#discussion_r399856611", "bodyText": "Done.", "author": "chamikaramj", "createdAt": "2020-03-29T21:29:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3NjQzNA=="}], "type": "inlineReview"}, {"oid": "e88eba0422cef69a9f8e90be0cddc350534a9222", "url": "https://github.com/apache/beam/commit/e88eba0422cef69a9f8e90be0cddc350534a9222", "message": "Addresses reviewer comments.", "committedDate": "2020-03-29T00:00:37Z", "type": "forcePushed"}, {"oid": "e5dfdc9396a4e71c06893bd5b90d27cebd11c1f7", "url": "https://github.com/apache/beam/commit/e5dfdc9396a4e71c06893bd5b90d27cebd11c1f7", "message": "Addresses reviewer comments.", "committedDate": "2020-04-02T01:24:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MjE4NQ==", "url": "https://github.com/apache/beam/pull/11185#discussion_r402672185", "bodyText": "Logically the ElementType should hold the ExternalCoder, and the ExternalCoder should hold the proto. (This will also help some issues where coders are requested manually and then not respected.)", "author": "robertwb", "createdAt": "2020-04-03T00:32:29Z", "path": "sdks/python/apache_beam/coders/coders.py", "diffHunk": "@@ -1383,22 +1385,50 @@ def from_runner_api_parameter(payload, components, context):\n         write_state_threshold=int(payload))\n \n \n-class RunnerAPICoderHolder(Coder):\n+class CoderElementType(typehints.TypeConstraint):\n+  \"\"\"An element type that just holds a coder proto.\"\"\"\n+  def __init__(self, coder_proto, context):\n+    self.coder_proto = coder_proto", "originalCommit": "44d99a4b82fed731414dea55877bf3d5d0a13335", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzMxOTA1Mw==", "url": "https://github.com/apache/beam/pull/11185#discussion_r403319053", "bodyText": "Done.", "author": "chamikaramj", "createdAt": "2020-04-03T20:41:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MjE4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MjcxOA==", "url": "https://github.com/apache/beam/pull/11185#discussion_r402672718", "bodyText": "Put (ix, si) to help yapf do the right thing.", "author": "robertwb", "createdAt": "2020-04-03T00:34:12Z", "path": "sdks/python/apache_beam/pipeline.py", "diffHunk": "@@ -1065,10 +1070,9 @@ def named_inputs(self):\n         input in enumerate(self.inputs)\n         if isinstance(input, pvalue.PCollection)\n     }\n-    side_inputs = {\n-        'side%s' % ix: si.pvalue\n-        for ix, si in enumerate(self.side_inputs)\n-    }\n+    side_inputs = {(SIDE_INPUT_PREFIX + '%s') % ix: si.pvalue\n+                   for ix,", "originalCommit": "44d99a4b82fed731414dea55877bf3d5d0a13335", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzMyMDU3Nw==", "url": "https://github.com/apache/beam/pull/11185#discussion_r403320577", "bodyText": "Done.", "author": "chamikaramj", "createdAt": "2020-04-03T20:43:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MjcxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MzU1OQ==", "url": "https://github.com/apache/beam/pull/11185#discussion_r402673559", "bodyText": "Add a TODO(BEAM-1833) to get rid of this.", "author": "robertwb", "createdAt": "2020-04-03T00:37:37Z", "path": "sdks/python/apache_beam/pipeline.py", "diffHunk": "@@ -1107,6 +1111,10 @@ def transform_to_runner_api(transform,  # type: Optional[ptransform.PTransform]\n         (transform_urn in Pipeline.sdk_transforms_with_environment())):\n       environment_id = context.default_environment_id()\n \n+    def _maybe_preserve_tag(new_tag, pc, input_tags_to_preserve):", "originalCommit": "44d99a4b82fed731414dea55877bf3d5d0a13335", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzMyMzMyOQ==", "url": "https://github.com/apache/beam/pull/11185#discussion_r403323329", "bodyText": "Done.", "author": "chamikaramj", "createdAt": "2020-04-03T20:47:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MzU1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NjQxOA==", "url": "https://github.com/apache/beam/pull/11185#discussion_r402676418", "bodyText": "Where does transform.side_inputs in this path?", "author": "robertwb", "createdAt": "2020-04-03T00:47:45Z", "path": "sdks/python/apache_beam/pipeline.py", "diffHunk": "@@ -1133,29 +1141,67 @@ def from_runner_api(proto,  # type: beam_runner_api_pb2.PTransform\n                       context  # type: PipelineContext\n                      ):\n     # type: (...) -> AppliedPTransform\n-    def is_side_input(tag):\n-      # type: (str) -> bool\n-      # As per named_inputs() above.\n-      return tag.startswith('side')\n+\n+    if common_urns.primitives.PAR_DO.urn == proto.spec.urn:\n+      # Preserving side input tags.\n+      from apache_beam.portability.api import beam_runner_api_pb2\n+      payload = (\n+          proto_utils.parse_Bytes(\n+              proto.spec.payload, beam_runner_api_pb2.ParDoPayload))\n+      side_input_tags = list(payload.side_inputs.keys())\n+    else:\n+      side_input_tags = []\n \n     main_inputs = [\n         context.pcollections.get_by_id(id) for tag,\n-        id in proto.inputs.items() if not is_side_input(tag)\n+        id in proto.inputs.items() if tag not in side_input_tags\n     ]\n \n-    # Ordering is important here.\n-    indexed_side_inputs = [\n-        (get_sideinput_index(tag), context.pcollections.get_by_id(id)) for tag,\n-        id in proto.inputs.items() if is_side_input(tag)\n-    ]\n-    side_inputs = [si for _, si in sorted(indexed_side_inputs)]\n+    def is_python_side_input(tag):\n+      # type: (str) -> bool\n+      # As per named_inputs() above.\n+      return re.match(SIDE_INPUT_REGEX, tag)\n+\n+    uses_python_sideinput_tags = (\n+        is_python_side_input(side_input_tags[0]) if side_input_tags else False)\n+\n+    if uses_python_sideinput_tags:\n+      # Ordering is important here.\n+      # TODO(BEAM-9635): use key, value pairs instead of depending on tags with\n+      # index as a suffix.\n+      indexed_side_inputs = [\n+          (get_sideinput_index(tag), context.pcollections.get_by_id(id))\n+          for tag,\n+          id in proto.inputs.items() if tag in side_input_tags\n+      ]\n+      side_inputs = [si for _, si in sorted(indexed_side_inputs)]\n+    else:\n+      side_inputs = [\n+          context.pcollections.get_by_id(id) for tag,\n+          id in proto.inputs.items() if tag in side_input_tags\n+      ]\n+\n     transform = ptransform.PTransform.from_runner_api(proto, context)\n+    if isinstance(transform, RunnerAPIPTransformHolder):\n+      # For external transforms that are ParDos, we have to set side-inputs\n+      # manually and preserve input tags.\n+      transform.side_inputs = [pvalue.AsMultiMap(pc) for pc in side_inputs]\n+      input_tags_to_preserve = {\n+          context.pcollections.get_by_id(id): tag\n+          for tag,\n+          id in proto.inputs.items()\n+      }\n+    else:", "originalCommit": "44d99a4b82fed731414dea55877bf3d5d0a13335", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM1MTkxNg==", "url": "https://github.com/apache/beam/pull/11185#discussion_r403351916", "bodyText": "That's done in respective from_runner_api methods. For example,\nhttps://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/core.py#L1361\nBut RunnerAPIPTransformHolder is a holder type that is constructed directly so setting it here seemed like the best option (we may be able to move this to constructor but that would require passing in additional parameters to get access to inputs etc. since using Python only pvalue.SideInputData.from_runner_api is not an option).", "author": "chamikaramj", "createdAt": "2020-04-03T21:46:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NjQxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NjY0MQ==", "url": "https://github.com/apache/beam/pull/11185#discussion_r402676641", "bodyText": "The conditional is a tautology; just return  _only_element(transform_node.outputs.keys()).", "author": "robertwb", "createdAt": "2020-04-03T00:48:34Z", "path": "sdks/python/apache_beam/runners/dataflow/dataflow_runner.py", "diffHunk": "@@ -269,11 +277,9 @@ def visit_transform(self, transform_node):\n               pcoll.element_type, transform_node.full_label)\n           key_type, value_type = pcoll.element_type.tuple_types\n           if transform_node.outputs:\n-            from apache_beam.runners.portability.fn_api_runner.translations \\\n-              import only_element\n             key = (\n-                None if None in transform_node.outputs.keys() else only_element(\n-                    transform_node.outputs.keys()))\n+                None if None in transform_node.outputs.keys() else\n+                DataflowRunner._only_element(transform_node.outputs.keys()))", "originalCommit": "44d99a4b82fed731414dea55877bf3d5d0a13335", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM5MDk1NQ==", "url": "https://github.com/apache/beam/pull/11185#discussion_r403390955", "bodyText": "Done. I assume this is because there can be only one output here.", "author": "chamikaramj", "createdAt": "2020-04-04T00:06:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NjY0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3Njc5MQ==", "url": "https://github.com/apache/beam/pull/11185#discussion_r402676791", "bodyText": "Nit: is_external_transform.", "author": "robertwb", "createdAt": "2020-04-03T00:49:03Z", "path": "sdks/python/apache_beam/runners/dataflow/dataflow_runner.py", "diffHunk": "@@ -597,14 +604,22 @@ def _get_side_input_encoding(self, input_encoding):\n         },\n     }\n \n-  def _get_encoded_output_coder(self, transform_node, window_value=True):\n+  def _get_encoded_output_coder(\n+      self, transform_node, window_value=True, output_tag=None):\n     \"\"\"Returns the cloud encoding of the coder for the output of a transform.\"\"\"\n-    from apache_beam.runners.portability.fn_api_runner.translations import \\\n-      only_element\n-    if len(transform_node.outputs) == 1:\n-      output_tag = only_element(transform_node.outputs.keys())\n+    external_transform = isinstance(", "originalCommit": "44d99a4b82fed731414dea55877bf3d5d0a13335", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM5MTQwNQ==", "url": "https://github.com/apache/beam/pull/11185#discussion_r403391405", "bodyText": "Done.", "author": "chamikaramj", "createdAt": "2020-04-04T00:08:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3Njc5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3Nzc5MA==", "url": "https://github.com/apache/beam/pull/11185#discussion_r402677790", "bodyText": "Do we still need this?", "author": "robertwb", "createdAt": "2020-04-03T00:52:52Z", "path": "sdks/python/apache_beam/typehints/typehints.py", "diffHunk": "@@ -1180,6 +1180,28 @@ def get_yielded_type(type_hint):\n   raise ValueError('%s is not iterable' % type_hint)\n \n \n+def _coerce_to_kv_type_from_external_type(element_type_holder):", "originalCommit": "44d99a4b82fed731414dea55877bf3d5d0a13335", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM5MzMyMg==", "url": "https://github.com/apache/beam/pull/11185#discussion_r403393322", "bodyText": "We don't. Removed :)", "author": "chamikaramj", "createdAt": "2020-04-04T00:17:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3Nzc5MA=="}], "type": "inlineReview"}, {"oid": "1459f8a47d94b418bcc4c8e9f903d201717b87b0", "url": "https://github.com/apache/beam/commit/1459f8a47d94b418bcc4c8e9f903d201717b87b0", "message": "Some generalizations to support cross-language transforms.\n\nThese are needed for for runners that need to build a Python object graph from a runner API proto with external transforms (for example, Dataflow).", "committedDate": "2020-04-04T00:43:39Z", "type": "commit"}, {"oid": "0dc9b2959ffbcef15b226d011270831b455170ad", "url": "https://github.com/apache/beam/commit/0dc9b2959ffbcef15b226d011270831b455170ad", "message": "Fixes to tests and lint.", "committedDate": "2020-04-04T00:43:39Z", "type": "commit"}, {"oid": "2dd84581d2cfecd3a34edcb1e3b58b80468f3c05", "url": "https://github.com/apache/beam/commit/2dd84581d2cfecd3a34edcb1e3b58b80468f3c05", "message": "Test and lint fixes.", "committedDate": "2020-04-04T00:43:39Z", "type": "commit"}, {"oid": "96c3a81072db8d83d54bcf9874d13915654bf5a7", "url": "https://github.com/apache/beam/commit/96c3a81072db8d83d54bcf9874d13915654bf5a7", "message": "Addresses reviewer comments.", "committedDate": "2020-04-04T00:43:40Z", "type": "commit"}, {"oid": "2be17e6764c4e28da20613c621caa79d700c77c2", "url": "https://github.com/apache/beam/commit/2be17e6764c4e28da20613c621caa79d700c77c2", "message": "Addresses reviewer comments.", "committedDate": "2020-04-04T00:43:40Z", "type": "commit"}, {"oid": "33a18ec3f9a33a59d294cef8dd41b4cad970d0fd", "url": "https://github.com/apache/beam/commit/33a18ec3f9a33a59d294cef8dd41b4cad970d0fd", "message": "Fixes lint.", "committedDate": "2020-04-04T00:43:40Z", "type": "commit"}, {"oid": "ac308c635e89ac36136952be3ca1950bf24fbcf7", "url": "https://github.com/apache/beam/commit/ac308c635e89ac36136952be3ca1950bf24fbcf7", "message": "Addressed reviewer comments.", "committedDate": "2020-04-04T01:57:02Z", "type": "commit"}, {"oid": "ac308c635e89ac36136952be3ca1950bf24fbcf7", "url": "https://github.com/apache/beam/commit/ac308c635e89ac36136952be3ca1950bf24fbcf7", "message": "Addressed reviewer comments.", "committedDate": "2020-04-04T01:57:02Z", "type": "forcePushed"}]}