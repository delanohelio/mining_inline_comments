{"pr_number": 11935, "pr_title": "[BEAM-9577] Remove use of legacy artifact service in Python.", "pr_createdAt": "2020-06-05T17:43:01Z", "pr_url": "https://github.com/apache/beam/pull/11935", "timeline": [{"oid": "647d21d055f3c10178eda0b5d2f1613abf3c6a56", "url": "https://github.com/apache/beam/commit/647d21d055f3c10178eda0b5d2f1613abf3c6a56", "message": "[BEAM-9577] Remove use of legacy artifact service in Python.", "committedDate": "2020-06-05T19:19:45Z", "type": "commit"}, {"oid": "647d21d055f3c10178eda0b5d2f1613abf3c6a56", "url": "https://github.com/apache/beam/commit/647d21d055f3c10178eda0b5d2f1613abf3c6a56", "message": "[BEAM-9577] Remove use of legacy artifact service in Python.", "committedDate": "2020-06-05T19:19:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM3MDYxNw==", "url": "https://github.com/apache/beam/pull/11935#discussion_r438370617", "bodyText": "Do you want to keep this comment?", "author": "ihji", "createdAt": "2020-06-10T19:51:21Z", "path": "sdks/python/apache_beam/runners/portability/artifact_service.py", "diffHunk": "@@ -55,272 +52,6 @@\n   from typing import Iterable\n   from typing import MutableMapping\n \n-# The legacy artifact staging and retrieval services.\n-\n-\n-class AbstractArtifactService(\n-    beam_artifact_api_pb2_grpc.LegacyArtifactStagingServiceServicer,\n-    beam_artifact_api_pb2_grpc.LegacyArtifactRetrievalServiceServicer):\n-\n-  _DEFAULT_CHUNK_SIZE = 2 << 20  # 2mb\n-\n-  def __init__(self, root, chunk_size=None):\n-    self._root = root\n-    self._chunk_size = chunk_size or self._DEFAULT_CHUNK_SIZE\n-\n-  def _sha256(self, string):\n-    return hashlib.sha256(string.encode('utf-8')).hexdigest()\n-\n-  def _join(self, *args):\n-    # type: (*str) -> str\n-    raise NotImplementedError(type(self))\n-\n-  def _dirname(self, path):\n-    # type: (str) -> str\n-    raise NotImplementedError(type(self))\n-\n-  def _temp_path(self, path):\n-    # type: (str) -> str\n-    return path + '.tmp'\n-\n-  def _open(self, path, mode):\n-    raise NotImplementedError(type(self))\n-\n-  def _rename(self, src, dest):\n-    # type: (str, str) -> None\n-    raise NotImplementedError(type(self))\n-\n-  def _delete(self, path):\n-    # type: (str) -> None\n-    raise NotImplementedError(type(self))\n-\n-  def _artifact_path(self, retrieval_token, name):\n-    # type: (str, str) -> str\n-    return self._join(self._dirname(retrieval_token), self._sha256(name))\n-\n-  def _manifest_path(self, retrieval_token):\n-    # type: (str) -> str\n-    return retrieval_token\n-\n-  def _get_manifest_proxy(self, retrieval_token):\n-    # type: (str) -> beam_artifact_api_pb2.ProxyManifest\n-    with self._open(self._manifest_path(retrieval_token), 'r') as fin:\n-      return json_format.Parse(\n-          fin.read().decode('utf-8'), beam_artifact_api_pb2.ProxyManifest())\n-\n-  def retrieval_token(self, staging_session_token):\n-    # type: (str) -> str\n-    return self._join(\n-        self._root, self._sha256(staging_session_token), 'MANIFEST')\n-\n-  def PutArtifact(self, request_iterator, context=None):\n-    # type: (...) -> beam_artifact_api_pb2.PutArtifactResponse\n-    first = True\n-    for request in request_iterator:\n-      if first:\n-        first = False\n-        metadata = request.metadata.metadata\n-        retrieval_token = self.retrieval_token(\n-            request.metadata.staging_session_token)\n-        artifact_path = self._artifact_path(retrieval_token, metadata.name)\n-        temp_path = self._temp_path(artifact_path)\n-        fout = self._open(temp_path, 'w')\n-        hasher = hashlib.sha256()\n-      else:\n-        hasher.update(request.data.data)\n-        fout.write(request.data.data)\n-    fout.close()\n-    data_hash = hasher.hexdigest()\n-    if metadata.sha256 and metadata.sha256 != data_hash:\n-      self._delete(temp_path)\n-      raise ValueError(\n-          'Bad metadata hash: %s vs %s' % (metadata.sha256, data_hash))\n-    self._rename(temp_path, artifact_path)\n-    return beam_artifact_api_pb2.PutArtifactResponse()\n-\n-  def CommitManifest(self,\n-                     request,  # type: beam_artifact_api_pb2.CommitManifestRequest\n-                     context=None):\n-    # type: (...) -> beam_artifact_api_pb2.CommitManifestResponse\n-    retrieval_token = self.retrieval_token(request.staging_session_token)\n-    proxy_manifest = beam_artifact_api_pb2.ProxyManifest(\n-        manifest=request.manifest,\n-        location=[\n-            beam_artifact_api_pb2.ProxyManifest.Location(\n-                name=metadata.name,\n-                uri=self._artifact_path(retrieval_token, metadata.name))\n-            for metadata in request.manifest.artifact\n-        ])\n-    with self._open(self._manifest_path(retrieval_token), 'w') as fout:\n-      fout.write(json_format.MessageToJson(proxy_manifest).encode('utf-8'))\n-    return beam_artifact_api_pb2.CommitManifestResponse(\n-        retrieval_token=retrieval_token)\n-\n-  def GetManifest(self,\n-                  request,  # type: beam_artifact_api_pb2.GetManifestRequest\n-                  context=None):\n-    # type: (...) -> beam_artifact_api_pb2.GetManifestResponse\n-    return beam_artifact_api_pb2.GetManifestResponse(\n-        manifest=self._get_manifest_proxy(request.retrieval_token).manifest)\n-\n-  def GetArtifact(self,\n-                  request,  # type: beam_artifact_api_pb2.LegacyGetArtifactRequest\n-                  context=None):\n-    # type: (...) -> Iterator[beam_artifact_api_pb2.ArtifactChunk]\n-    for artifact in self._get_manifest_proxy(request.retrieval_token).location:\n-      if artifact.name == request.name:\n-        with self._open(artifact.uri, 'r') as fin:\n-          # This value is not emitted, but lets us yield a single empty\n-          # chunk on an empty file.\n-          chunk = b'1'\n-          while chunk:\n-            chunk = fin.read(self._chunk_size)\n-            yield beam_artifact_api_pb2.ArtifactChunk(data=chunk)\n-        break\n-    else:\n-      raise ValueError('Unknown artifact: %s' % request.name)\n-\n-\n-class ZipFileArtifactService(AbstractArtifactService):\n-  \"\"\"Stores artifacts in a zip file.\n-\n-  This is particularly useful for storing artifacts as part of an UberJar for\n-  submitting to an upstream runner's cluster.\n-\n-  Writing to zip files requires Python 3.6+.\n-  \"\"\"\n-  def __init__(self, path, internal_root, chunk_size=None):\n-    if sys.version_info < (3, 6):\n-      raise RuntimeError(\n-          'Writing to zip files requires Python 3.6+, '\n-          'but current version is %s' % sys.version)\n-    super(ZipFileArtifactService, self).__init__(internal_root, chunk_size)\n-    self._zipfile = zipfile.ZipFile(path, 'a')\n-    self._lock = threading.Lock()\n-\n-  def _join(self, *args):\n-    # type: (*str) -> str\n-    return '/'.join(args)\n-\n-  def _dirname(self, path):\n-    # type: (str) -> str\n-    return path.rsplit('/', 1)[0]\n-\n-  def _temp_path(self, path):\n-    # type: (str) -> str\n-    return path  # ZipFile offers no move operation.\n-\n-  def _rename(self, src, dest):\n-    # type: (str, str) -> None\n-    assert src == dest\n-\n-  def _delete(self, path):\n-    # type: (str) -> None\n-    # ZipFile offers no delete operation: https://bugs.python.org/issue6818\n-    pass\n-\n-  def _open(self, path, mode):\n-    if path.startswith('/'):\n-      raise ValueError(\n-          'ZIP file entry %s invalid: '\n-          'path must not contain a leading slash.' % path)\n-    return self._zipfile.open(path, mode, force_zip64=True)\n-\n-  def PutArtifact(self, request_iterator, context=None):\n-    # ZipFile only supports one writable channel at a time.\n-    with self._lock:\n-      return super(ZipFileArtifactService,\n-                   self).PutArtifact(request_iterator, context)\n-\n-  def CommitManifest(self, request, context=None):\n-    # ZipFile only supports one writable channel at a time.\n-    with self._lock:\n-      return super(ZipFileArtifactService,\n-                   self).CommitManifest(request, context)\n-\n-  def GetManifest(self, request, context=None):\n-    # ZipFile appears to not be threadsafe on some platforms.\n-    with self._lock:\n-      return super(ZipFileArtifactService, self).GetManifest(request, context)\n-\n-  def GetArtifact(self, request, context=None):\n-    # ZipFile appears to not be threadsafe on some platforms.\n-    with self._lock:\n-      for chunk in super(ZipFileArtifactService, self).GetArtifact(request,\n-                                                                   context):\n-        yield chunk\n-\n-  def close(self):\n-    self._zipfile.close()\n-\n-\n-class BeamFilesystemArtifactService(AbstractArtifactService):\n-  def _join(self, *args):\n-    # type: (*str) -> str\n-    return filesystems.FileSystems.join(*args)\n-\n-  def _dirname(self, path):\n-    # type: (str) -> str\n-    return filesystems.FileSystems.split(path)[0]\n-\n-  def _rename(self, src, dest):\n-    # type: (str, str) -> None\n-    filesystems.FileSystems.rename([src], [dest])\n-\n-  def _delete(self, path):\n-    # type: (str) -> None\n-    filesystems.FileSystems.delete([path])\n-\n-  def _open(self, path, mode='r'):\n-    dir = self._dirname(path)\n-    if not filesystems.FileSystems.exists(dir):\n-      try:\n-        filesystems.FileSystems.mkdirs(dir)\n-      except Exception:\n-        pass\n-\n-    if 'w' in mode:\n-      return filesystems.FileSystems.create(path)\n-    else:\n-      return filesystems.FileSystems.open(path)\n-\n-\n-# The dependency-aware artifact staging and retrieval services.", "originalCommit": "647d21d055f3c10178eda0b5d2f1613abf3c6a56", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM5NTg2Ng==", "url": "https://github.com/apache/beam/pull/11935#discussion_r438395866", "bodyText": "No, as there's only one now.", "author": "robertwb", "createdAt": "2020-06-10T20:41:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM3MDYxNw=="}], "type": "inlineReview"}]}