{"pr_number": 11590, "pr_title": "[BEAM-8944] Improve UnboundedThreadPoolExecutor performance", "pr_createdAt": "2020-05-01T20:31:21Z", "pr_url": "https://github.com/apache/beam/pull/11590", "timeline": [{"oid": "a0d215c2c57fc2860ca87b825920be7d15d64e2b", "url": "https://github.com/apache/beam/commit/a0d215c2c57fc2860ca87b825920be7d15d64e2b", "message": "[BEAM-8944] Improve UnboundedThreadPoolExecutor performance\n\nExisting performance suffered because of the use of timed waits and also due to the increase in number of \"threading\" objects being invoked.\n\nUsing the benchmark from https://issues.apache.org/jira/browse/BEAM-8944?focusedCommentId=17074641&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-17074641\n\nImproved performance from 5.52s down to 1.82s which is faster then the ThreadPoolExecutor with 12 threads (the default being used before) but still slower then the ThreadPoolExecutor with 1 thread.\n\nThe prior performance was:\n<apache_beam.utils.thread_pool_executor.UnboundedThreadPoolExecutor object at 0x7feee655c8d0> uses 5.52247905731\n         584051 function calls in 5.495 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n    86250    4.386    0.000    4.386    0.000 {method 'acquire' of 'thread.lock' objects}\n    19800    0.150    0.000    4.773    0.000 Queue.py:150(get)\n    29698    0.123    0.000    0.365    0.000 threading.py:373(notify)\n     9900    0.114    0.000    0.114    0.000 {method '__enter__' of 'thread.lock' objects}\n     9899    0.106    0.000    0.463    0.000 thread_pool_executor.py:103(accepted_work)\n     9188    0.089    0.000    4.095    0.000 threading.py:309(wait)\n     9903    0.078    0.000    0.129    0.000 threading.py:260(__init__)\n     9900    0.061    0.000    1.092    0.000 thread_pool_executor.py:133(submit)\n     9899    0.055    0.000    0.358    0.000 threading.py:576(set)\n    38886    0.044    0.000    0.285    0.000 threading.py:300(_is_owned)\n     9900    0.041    0.000    0.186    0.000 _base.py:318(__init__)\n    28987    0.023    0.000    0.031    0.000 Queue.py:200(_qsize)\n     9900    0.022    0.000    0.030    0.000 threading.py:132(__init__)\n    38887    0.021    0.000    0.021    0.000 threading.py:64(_note)\n     9899    0.019    0.000    0.163    0.000 threading.py:400(notifyAll)\n    19799    0.018    0.000    0.023    0.000 Queue.py:208(_get)\n    38887    0.016    0.000    0.016    0.000 {method 'release' of 'thread.lock' objects}\n     9903    0.016    0.000    0.145    0.000 threading.py:242(Condition)\n    19806    0.014    0.000    0.014    0.000 threading.py:59(__init__)\n     9900    0.014    0.000    0.127    0.000 threading.py:285(__enter__)\n     9188    0.013    0.000    0.090    0.000 threading.py:297(_acquire_restore)\n     9900    0.013    0.000    0.043    0.000 threading.py:114(RLock)\n     9900    0.011    0.000    0.011    0.000 thread_pool_executor.py:34(__init__)\n    38886    0.011    0.000    0.011    0.000 {len}\n     9900    0.010    0.000    0.012    0.000 threading.py:288(__exit__)\n     9188    0.008    0.000    0.012    0.000 threading.py:294(_release_save)\n    19092    0.006    0.000    0.006    0.000 {thread.allocate_lock}\n    19799    0.005    0.000    0.005    0.000 {method 'popleft' of 'collections.deque' objects}\n     9188    0.004    0.000    0.004    0.000 {method 'append' of 'list' objects}\n     9899    0.003    0.000    0.003    0.000 {method 'remove' of 'list' objects}\n     9900    0.002    0.000    0.002    0.000 {method '__exit__' of 'thread.lock' objects}\n        1    0.000    0.000    0.000    0.000 {thread.start_new_thread}\n        1    0.000    0.000    0.000    0.000 threading.py:647(__init__)\n        1    0.000    0.000    0.000    0.000 threading.py:717(start)\n        1    0.000    0.000    0.000    0.000 thread_pool_executor.py:58(__init__)\n        1    0.000    0.000    0.000    0.000 threading.py:620(_newname)\n        1    0.000    0.000    0.000    0.000 _weakrefset.py:83(add)\n        1    0.000    0.000    0.000    0.000 threading.py:597(wait)\n        2    0.000    0.000    0.000    0.000 threading.py:561(__init__)\n        1    0.000    0.000    0.000    0.000 threading.py:1142(currentThread)\n        2    0.000    0.000    0.000    0.000 threading.py:542(Event)\n        1    0.000    0.000    0.000    0.000 threading.py:700(_set_daemon)\n        1    0.000    0.000    0.000    0.000 threading.py:1014(daemon)\n        2    0.000    0.000    0.000    0.000 threading.py:570(isSet)\n        1    0.000    0.000    0.000    0.000 threading.py:999(daemon)\n        1    0.000    0.000    0.000    0.000 {thread.get_ident}\n        1    0.000    0.000    0.000    0.000 {method 'add' of 'set' objects}\n        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\n\nThe new performance is:\n<apache_beam.utils.thread_pool_executor.UnboundedThreadPoolExecutor object at 0x7f71dd5cacd0> uses 1.82196497917\n         504935 function calls in 1.787 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n    62233    0.940    0.000    0.940    0.000 {method 'acquire' of 'thread.lock' objects}\n     9900    0.142    0.000    1.248    0.000 thread_pool_executor.py:98(submit)\n    29698    0.102    0.000    0.364    0.000 threading.py:373(notify)\n    19800    0.101    0.000    0.880    0.000 Queue.py:150(get)\n     9900    0.068    0.000    0.068    0.000 {method '__enter__' of 'thread.lock' objects}\n    40304    0.063    0.000    0.063    0.000 {method 'release' of 'thread.lock' objects}\n     9899    0.053    0.000    0.323    0.000 threading.py:479(release)\n     9899    0.044    0.000    0.299    0.000 Queue.py:86(qsize)\n     9903    0.043    0.000    0.082    0.000 threading.py:260(__init__)\n    30407    0.031    0.000    0.221    0.000 threading.py:300(_is_owned)\n     9900    0.027    0.000    0.119    0.000 _base.py:318(__init__)\n    30407    0.022    0.000    0.027    0.000 Queue.py:200(_qsize)\n     9900    0.017    0.000    0.025    0.000 threading.py:132(__init__)\n    19799    0.016    0.000    0.019    0.000 Queue.py:208(_get)\n     9899    0.015    0.000    0.338    0.000 thread_pool_executor.py:77(assign_work)\n    40307    0.015    0.000    0.015    0.000 threading.py:64(_note)\n     9900    0.015    0.000    0.019    0.000 threading.py:288(__exit__)\n     9903    0.011    0.000    0.093    0.000 threading.py:242(Condition)\n    19806    0.010    0.000    0.010    0.000 threading.py:59(__init__)\n     9900    0.009    0.000    0.034    0.000 threading.py:114(RLock)\n     9900    0.009    0.000    0.077    0.000 threading.py:285(__enter__)\n      709    0.007    0.000    0.148    0.000 threading.py:309(wait)\n     9900    0.007    0.000    0.007    0.000 thread_pool_executor.py:34(__init__)\n    30407    0.005    0.000    0.005    0.000 {len}\n     9900    0.004    0.000    0.004    0.000 {method '__exit__' of 'thread.lock' objects}\n    10613    0.003    0.000    0.003    0.000 {thread.allocate_lock}\n    19799    0.003    0.000    0.003    0.000 {method 'popleft' of 'collections.deque' objects}\n     9896    0.002    0.000    0.002    0.000 {method 'remove' of 'list' objects}\n      709    0.001    0.000    0.023    0.000 threading.py:297(_acquire_restore)\n      709    0.001    0.000    0.002    0.000 threading.py:294(_release_save)\n      709    0.000    0.000    0.000    0.000 {method 'append' of 'list' objects}\n        1    0.000    0.000    0.000    0.000 {thread.start_new_thread}\n        1    0.000    0.000    0.000    0.000 threading.py:717(start)\n        1    0.000    0.000    0.000    0.000 threading.py:647(__init__)\n        1    0.000    0.000    0.000    0.000 threading.py:620(_newname)\n        1    0.000    0.000    0.000    0.000 thread_pool_executor.py:58(__init__)\n        1    0.000    0.000    0.000    0.000 threading.py:1142(currentThread)\n        1    0.000    0.000    0.000    0.000 _weakrefset.py:83(add)\n        1    0.000    0.000    0.000    0.000 threading.py:597(wait)\n        1    0.000    0.000    0.000    0.000 threading.py:433(__init__)\n        1    0.000    0.000    0.000    0.000 threading.py:700(_set_daemon)\n        1    0.000    0.000    0.000    0.000 threading.py:542(Event)\n        1    0.000    0.000    0.000    0.000 threading.py:561(__init__)\n        1    0.000    0.000    0.000    0.000 threading.py:1014(daemon)\n        1    0.000    0.000    0.000    0.000 threading.py:412(Semaphore)\n        2    0.000    0.000    0.000    0.000 threading.py:570(isSet)\n        1    0.000    0.000    0.000    0.000 threading.py:999(daemon)\n        1    0.000    0.000    0.000    0.000 {thread.get_ident}\n        1    0.000    0.000    0.000    0.000 {method 'add' of 'set' objects}\n        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\n\nThe max_workers=1 ThreadPoolExecutor is:\n<concurrent.futures.thread.ThreadPoolExecutor object at 0x7f71dd5e7710> uses 1.03040599823\n         436503 function calls in 1.011 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n    59160    0.462    0.000    0.462    0.000 {method 'acquire' of 'thread.lock' objects}\n     9900    0.114    0.000    0.114    0.000 {method '__enter__' of 'thread.lock' objects}\n     9900    0.072    0.000    0.537    0.000 thread.py:128(submit)\n     9900    0.045    0.000    0.474    0.000 Queue.py:150(get)\n     9900    0.034    0.000    0.167    0.000 threading.py:440(acquire)\n     9900    0.034    0.000    0.061    0.000 threading.py:260(__init__)\n    19800    0.033    0.000    0.112    0.000 threading.py:373(notify)\n     9900    0.031    0.000    0.192    0.000 Queue.py:107(put)\n     4890    0.024    0.000    0.269    0.000 threading.py:309(wait)\n     9900    0.022    0.000    0.092    0.000 _base.py:318(__init__)\n    25561    0.017    0.000    0.017    0.000 {method 'release' of 'thread.lock' objects}\n    24690    0.016    0.000    0.091    0.000 threading.py:300(_is_owned)\n     9900    0.011    0.000    0.016    0.000 threading.py:132(__init__)\n    34590    0.010    0.000    0.010    0.000 threading.py:64(_note)\n     9900    0.009    0.000    0.176    0.000 thread.py:141(_adjust_thread_count)\n     9900    0.009    0.000    0.070    0.000 threading.py:242(Condition)\n     9900    0.007    0.000    0.023    0.000 threading.py:114(RLock)\n    14790    0.007    0.000    0.009    0.000 Queue.py:200(_qsize)\n    19800    0.007    0.000    0.007    0.000 threading.py:59(__init__)\n     9900    0.007    0.000    0.008    0.000 Queue.py:208(_get)\n     9900    0.006    0.000    0.010    0.000 threading.py:288(__exit__)\n     9900    0.006    0.000    0.007    0.000 Queue.py:204(_put)\n     9900    0.006    0.000    0.119    0.000 threading.py:285(__enter__)\n     9900    0.006    0.000    0.006    0.000 thread.py:52(__init__)\n     9900    0.003    0.000    0.003    0.000 {method '__exit__' of 'thread.lock' objects}\n    14790    0.003    0.000    0.003    0.000 {thread.allocate_lock}\n     4890    0.003    0.000    0.020    0.000 threading.py:297(_acquire_restore)\n     4890    0.003    0.000    0.008    0.000 threading.py:294(_release_save)\n    14790    0.002    0.000    0.002    0.000 {len}\n     9900    0.001    0.000    0.001    0.000 {method 'popleft' of 'collections.deque' objects}\n     9900    0.001    0.000    0.001    0.000 {method 'append' of 'collections.deque' objects}\n     4890    0.001    0.000    0.001    0.000 {method 'append' of 'list' objects}\n      871    0.000    0.000    0.000    0.000 {method 'remove' of 'list' objects}\n        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\n\nThe max_workers=12 ThreadPoolExecutor is:\n<concurrent.futures.thread.ThreadPoolExecutor object at 0x7f71dd575d90> uses 2.03954315186\n         402533 function calls in 2.002 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n    44284    0.878    0.000    0.878    0.000 {method 'acquire' of 'thread.lock' objects}\n     9902    0.228    0.000    0.228    0.000 {method '__enter__' of 'thread.lock' objects}\n     9900    0.207    0.000    1.342    0.000 thread.py:128(submit)\n     9900    0.084    0.000    0.660    0.000 Queue.py:150(get)\n    19800    0.084    0.000    0.269    0.000 threading.py:373(notify)\n     9900    0.080    0.000    0.351    0.000 threading.py:440(acquire)\n    30862    0.069    0.000    0.069    0.000 {method 'release' of 'thread.lock' objects}\n     9900    0.054    0.000    0.594    0.000 Queue.py:107(put)\n     9904    0.054    0.000    0.102    0.000 threading.py:260(__init__)\n     9900    0.032    0.000    0.150    0.000 _base.py:318(__init__)\n    20971    0.027    0.000    0.144    0.000 threading.py:300(_is_owned)\n     9900    0.022    0.000    0.383    0.000 thread.py:141(_adjust_thread_count)\n     9900    0.018    0.000    0.028    0.000 threading.py:132(__init__)\n    30871    0.017    0.000    0.017    0.000 threading.py:64(_note)\n     9904    0.016    0.000    0.118    0.000 threading.py:242(Condition)\n     9902    0.015    0.000    0.244    0.000 threading.py:285(__enter__)\n     9902    0.014    0.000    0.020    0.000 threading.py:288(__exit__)\n    19808    0.013    0.000    0.013    0.000 threading.py:59(__init__)\n    11069    0.013    0.000    0.016    0.000 Queue.py:200(_qsize)\n     9900    0.013    0.000    0.041    0.000 threading.py:114(RLock)\n     1171    0.011    0.000    0.234    0.000 threading.py:309(wait)\n     9900    0.011    0.000    0.012    0.000 Queue.py:204(_put)\n     9900    0.011    0.000    0.012    0.000 Queue.py:208(_get)\n     9900    0.008    0.000    0.008    0.000 thread.py:52(__init__)\n     9902    0.007    0.000    0.007    0.000 {method '__exit__' of 'thread.lock' objects}\n    11075    0.005    0.000    0.005    0.000 {thread.allocate_lock}\n    11071    0.003    0.000    0.003    0.000 {len}\n     9891    0.002    0.000    0.002    0.000 {method 'remove' of 'list' objects}\n     9900    0.002    0.000    0.002    0.000 {method 'popleft' of 'collections.deque' objects}\n     9900    0.002    0.000    0.002    0.000 {method 'append' of 'collections.deque' objects}\n     1171    0.001    0.000    0.041    0.000 threading.py:297(_acquire_restore)\n     1171    0.001    0.000    0.004    0.000 threading.py:294(_release_save)\n     1171    0.000    0.000    0.000    0.000 {method 'append' of 'list' objects}\n        2    0.000    0.000    0.000    0.000 {thread.start_new_thread}\n        2    0.000    0.000    0.000    0.000 threading.py:647(__init__)\n        2    0.000    0.000    0.010    0.005 threading.py:717(start)\n        2    0.000    0.000    0.010    0.005 threading.py:597(wait)\n        2    0.000    0.000    0.000    0.000 threading.py:700(_set_daemon)\n        2    0.000    0.000    0.000    0.000 weakref.py:368(__setitem__)\n        2    0.000    0.000    0.000    0.000 threading.py:542(Event)\n        2    0.000    0.000    0.000    0.000 threading.py:1142(currentThread)\n        2    0.000    0.000    0.000    0.000 threading.py:561(__init__)\n        2    0.000    0.000    0.000    0.000 threading.py:1014(daemon)\n        2    0.000    0.000    0.000    0.000 {method 'add' of 'set' objects}\n        2    0.000    0.000    0.000    0.000 threading.py:999(daemon)\n        4    0.000    0.000    0.000    0.000 threading.py:570(isSet)\n        2    0.000    0.000    0.000    0.000 {thread.get_ident}\n        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}", "committedDate": "2020-05-01T20:32:38Z", "type": "commit"}, {"oid": "a0d215c2c57fc2860ca87b825920be7d15d64e2b", "url": "https://github.com/apache/beam/commit/a0d215c2c57fc2860ca87b825920be7d15d64e2b", "message": "[BEAM-8944] Improve UnboundedThreadPoolExecutor performance\n\nExisting performance suffered because of the use of timed waits and also due to the increase in number of \"threading\" objects being invoked.\n\nUsing the benchmark from https://issues.apache.org/jira/browse/BEAM-8944?focusedCommentId=17074641&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-17074641\n\nImproved performance from 5.52s down to 1.82s which is faster then the ThreadPoolExecutor with 12 threads (the default being used before) but still slower then the ThreadPoolExecutor with 1 thread.\n\nThe prior performance was:\n<apache_beam.utils.thread_pool_executor.UnboundedThreadPoolExecutor object at 0x7feee655c8d0> uses 5.52247905731\n         584051 function calls in 5.495 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n    86250    4.386    0.000    4.386    0.000 {method 'acquire' of 'thread.lock' objects}\n    19800    0.150    0.000    4.773    0.000 Queue.py:150(get)\n    29698    0.123    0.000    0.365    0.000 threading.py:373(notify)\n     9900    0.114    0.000    0.114    0.000 {method '__enter__' of 'thread.lock' objects}\n     9899    0.106    0.000    0.463    0.000 thread_pool_executor.py:103(accepted_work)\n     9188    0.089    0.000    4.095    0.000 threading.py:309(wait)\n     9903    0.078    0.000    0.129    0.000 threading.py:260(__init__)\n     9900    0.061    0.000    1.092    0.000 thread_pool_executor.py:133(submit)\n     9899    0.055    0.000    0.358    0.000 threading.py:576(set)\n    38886    0.044    0.000    0.285    0.000 threading.py:300(_is_owned)\n     9900    0.041    0.000    0.186    0.000 _base.py:318(__init__)\n    28987    0.023    0.000    0.031    0.000 Queue.py:200(_qsize)\n     9900    0.022    0.000    0.030    0.000 threading.py:132(__init__)\n    38887    0.021    0.000    0.021    0.000 threading.py:64(_note)\n     9899    0.019    0.000    0.163    0.000 threading.py:400(notifyAll)\n    19799    0.018    0.000    0.023    0.000 Queue.py:208(_get)\n    38887    0.016    0.000    0.016    0.000 {method 'release' of 'thread.lock' objects}\n     9903    0.016    0.000    0.145    0.000 threading.py:242(Condition)\n    19806    0.014    0.000    0.014    0.000 threading.py:59(__init__)\n     9900    0.014    0.000    0.127    0.000 threading.py:285(__enter__)\n     9188    0.013    0.000    0.090    0.000 threading.py:297(_acquire_restore)\n     9900    0.013    0.000    0.043    0.000 threading.py:114(RLock)\n     9900    0.011    0.000    0.011    0.000 thread_pool_executor.py:34(__init__)\n    38886    0.011    0.000    0.011    0.000 {len}\n     9900    0.010    0.000    0.012    0.000 threading.py:288(__exit__)\n     9188    0.008    0.000    0.012    0.000 threading.py:294(_release_save)\n    19092    0.006    0.000    0.006    0.000 {thread.allocate_lock}\n    19799    0.005    0.000    0.005    0.000 {method 'popleft' of 'collections.deque' objects}\n     9188    0.004    0.000    0.004    0.000 {method 'append' of 'list' objects}\n     9899    0.003    0.000    0.003    0.000 {method 'remove' of 'list' objects}\n     9900    0.002    0.000    0.002    0.000 {method '__exit__' of 'thread.lock' objects}\n        1    0.000    0.000    0.000    0.000 {thread.start_new_thread}\n        1    0.000    0.000    0.000    0.000 threading.py:647(__init__)\n        1    0.000    0.000    0.000    0.000 threading.py:717(start)\n        1    0.000    0.000    0.000    0.000 thread_pool_executor.py:58(__init__)\n        1    0.000    0.000    0.000    0.000 threading.py:620(_newname)\n        1    0.000    0.000    0.000    0.000 _weakrefset.py:83(add)\n        1    0.000    0.000    0.000    0.000 threading.py:597(wait)\n        2    0.000    0.000    0.000    0.000 threading.py:561(__init__)\n        1    0.000    0.000    0.000    0.000 threading.py:1142(currentThread)\n        2    0.000    0.000    0.000    0.000 threading.py:542(Event)\n        1    0.000    0.000    0.000    0.000 threading.py:700(_set_daemon)\n        1    0.000    0.000    0.000    0.000 threading.py:1014(daemon)\n        2    0.000    0.000    0.000    0.000 threading.py:570(isSet)\n        1    0.000    0.000    0.000    0.000 threading.py:999(daemon)\n        1    0.000    0.000    0.000    0.000 {thread.get_ident}\n        1    0.000    0.000    0.000    0.000 {method 'add' of 'set' objects}\n        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\n\nThe new performance is:\n<apache_beam.utils.thread_pool_executor.UnboundedThreadPoolExecutor object at 0x7f71dd5cacd0> uses 1.82196497917\n         504935 function calls in 1.787 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n    62233    0.940    0.000    0.940    0.000 {method 'acquire' of 'thread.lock' objects}\n     9900    0.142    0.000    1.248    0.000 thread_pool_executor.py:98(submit)\n    29698    0.102    0.000    0.364    0.000 threading.py:373(notify)\n    19800    0.101    0.000    0.880    0.000 Queue.py:150(get)\n     9900    0.068    0.000    0.068    0.000 {method '__enter__' of 'thread.lock' objects}\n    40304    0.063    0.000    0.063    0.000 {method 'release' of 'thread.lock' objects}\n     9899    0.053    0.000    0.323    0.000 threading.py:479(release)\n     9899    0.044    0.000    0.299    0.000 Queue.py:86(qsize)\n     9903    0.043    0.000    0.082    0.000 threading.py:260(__init__)\n    30407    0.031    0.000    0.221    0.000 threading.py:300(_is_owned)\n     9900    0.027    0.000    0.119    0.000 _base.py:318(__init__)\n    30407    0.022    0.000    0.027    0.000 Queue.py:200(_qsize)\n     9900    0.017    0.000    0.025    0.000 threading.py:132(__init__)\n    19799    0.016    0.000    0.019    0.000 Queue.py:208(_get)\n     9899    0.015    0.000    0.338    0.000 thread_pool_executor.py:77(assign_work)\n    40307    0.015    0.000    0.015    0.000 threading.py:64(_note)\n     9900    0.015    0.000    0.019    0.000 threading.py:288(__exit__)\n     9903    0.011    0.000    0.093    0.000 threading.py:242(Condition)\n    19806    0.010    0.000    0.010    0.000 threading.py:59(__init__)\n     9900    0.009    0.000    0.034    0.000 threading.py:114(RLock)\n     9900    0.009    0.000    0.077    0.000 threading.py:285(__enter__)\n      709    0.007    0.000    0.148    0.000 threading.py:309(wait)\n     9900    0.007    0.000    0.007    0.000 thread_pool_executor.py:34(__init__)\n    30407    0.005    0.000    0.005    0.000 {len}\n     9900    0.004    0.000    0.004    0.000 {method '__exit__' of 'thread.lock' objects}\n    10613    0.003    0.000    0.003    0.000 {thread.allocate_lock}\n    19799    0.003    0.000    0.003    0.000 {method 'popleft' of 'collections.deque' objects}\n     9896    0.002    0.000    0.002    0.000 {method 'remove' of 'list' objects}\n      709    0.001    0.000    0.023    0.000 threading.py:297(_acquire_restore)\n      709    0.001    0.000    0.002    0.000 threading.py:294(_release_save)\n      709    0.000    0.000    0.000    0.000 {method 'append' of 'list' objects}\n        1    0.000    0.000    0.000    0.000 {thread.start_new_thread}\n        1    0.000    0.000    0.000    0.000 threading.py:717(start)\n        1    0.000    0.000    0.000    0.000 threading.py:647(__init__)\n        1    0.000    0.000    0.000    0.000 threading.py:620(_newname)\n        1    0.000    0.000    0.000    0.000 thread_pool_executor.py:58(__init__)\n        1    0.000    0.000    0.000    0.000 threading.py:1142(currentThread)\n        1    0.000    0.000    0.000    0.000 _weakrefset.py:83(add)\n        1    0.000    0.000    0.000    0.000 threading.py:597(wait)\n        1    0.000    0.000    0.000    0.000 threading.py:433(__init__)\n        1    0.000    0.000    0.000    0.000 threading.py:700(_set_daemon)\n        1    0.000    0.000    0.000    0.000 threading.py:542(Event)\n        1    0.000    0.000    0.000    0.000 threading.py:561(__init__)\n        1    0.000    0.000    0.000    0.000 threading.py:1014(daemon)\n        1    0.000    0.000    0.000    0.000 threading.py:412(Semaphore)\n        2    0.000    0.000    0.000    0.000 threading.py:570(isSet)\n        1    0.000    0.000    0.000    0.000 threading.py:999(daemon)\n        1    0.000    0.000    0.000    0.000 {thread.get_ident}\n        1    0.000    0.000    0.000    0.000 {method 'add' of 'set' objects}\n        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\n\nThe max_workers=1 ThreadPoolExecutor is:\n<concurrent.futures.thread.ThreadPoolExecutor object at 0x7f71dd5e7710> uses 1.03040599823\n         436503 function calls in 1.011 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n    59160    0.462    0.000    0.462    0.000 {method 'acquire' of 'thread.lock' objects}\n     9900    0.114    0.000    0.114    0.000 {method '__enter__' of 'thread.lock' objects}\n     9900    0.072    0.000    0.537    0.000 thread.py:128(submit)\n     9900    0.045    0.000    0.474    0.000 Queue.py:150(get)\n     9900    0.034    0.000    0.167    0.000 threading.py:440(acquire)\n     9900    0.034    0.000    0.061    0.000 threading.py:260(__init__)\n    19800    0.033    0.000    0.112    0.000 threading.py:373(notify)\n     9900    0.031    0.000    0.192    0.000 Queue.py:107(put)\n     4890    0.024    0.000    0.269    0.000 threading.py:309(wait)\n     9900    0.022    0.000    0.092    0.000 _base.py:318(__init__)\n    25561    0.017    0.000    0.017    0.000 {method 'release' of 'thread.lock' objects}\n    24690    0.016    0.000    0.091    0.000 threading.py:300(_is_owned)\n     9900    0.011    0.000    0.016    0.000 threading.py:132(__init__)\n    34590    0.010    0.000    0.010    0.000 threading.py:64(_note)\n     9900    0.009    0.000    0.176    0.000 thread.py:141(_adjust_thread_count)\n     9900    0.009    0.000    0.070    0.000 threading.py:242(Condition)\n     9900    0.007    0.000    0.023    0.000 threading.py:114(RLock)\n    14790    0.007    0.000    0.009    0.000 Queue.py:200(_qsize)\n    19800    0.007    0.000    0.007    0.000 threading.py:59(__init__)\n     9900    0.007    0.000    0.008    0.000 Queue.py:208(_get)\n     9900    0.006    0.000    0.010    0.000 threading.py:288(__exit__)\n     9900    0.006    0.000    0.007    0.000 Queue.py:204(_put)\n     9900    0.006    0.000    0.119    0.000 threading.py:285(__enter__)\n     9900    0.006    0.000    0.006    0.000 thread.py:52(__init__)\n     9900    0.003    0.000    0.003    0.000 {method '__exit__' of 'thread.lock' objects}\n    14790    0.003    0.000    0.003    0.000 {thread.allocate_lock}\n     4890    0.003    0.000    0.020    0.000 threading.py:297(_acquire_restore)\n     4890    0.003    0.000    0.008    0.000 threading.py:294(_release_save)\n    14790    0.002    0.000    0.002    0.000 {len}\n     9900    0.001    0.000    0.001    0.000 {method 'popleft' of 'collections.deque' objects}\n     9900    0.001    0.000    0.001    0.000 {method 'append' of 'collections.deque' objects}\n     4890    0.001    0.000    0.001    0.000 {method 'append' of 'list' objects}\n      871    0.000    0.000    0.000    0.000 {method 'remove' of 'list' objects}\n        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}\n\nThe max_workers=12 ThreadPoolExecutor is:\n<concurrent.futures.thread.ThreadPoolExecutor object at 0x7f71dd575d90> uses 2.03954315186\n         402533 function calls in 2.002 seconds\n\n   Ordered by: internal time\n\n   ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n    44284    0.878    0.000    0.878    0.000 {method 'acquire' of 'thread.lock' objects}\n     9902    0.228    0.000    0.228    0.000 {method '__enter__' of 'thread.lock' objects}\n     9900    0.207    0.000    1.342    0.000 thread.py:128(submit)\n     9900    0.084    0.000    0.660    0.000 Queue.py:150(get)\n    19800    0.084    0.000    0.269    0.000 threading.py:373(notify)\n     9900    0.080    0.000    0.351    0.000 threading.py:440(acquire)\n    30862    0.069    0.000    0.069    0.000 {method 'release' of 'thread.lock' objects}\n     9900    0.054    0.000    0.594    0.000 Queue.py:107(put)\n     9904    0.054    0.000    0.102    0.000 threading.py:260(__init__)\n     9900    0.032    0.000    0.150    0.000 _base.py:318(__init__)\n    20971    0.027    0.000    0.144    0.000 threading.py:300(_is_owned)\n     9900    0.022    0.000    0.383    0.000 thread.py:141(_adjust_thread_count)\n     9900    0.018    0.000    0.028    0.000 threading.py:132(__init__)\n    30871    0.017    0.000    0.017    0.000 threading.py:64(_note)\n     9904    0.016    0.000    0.118    0.000 threading.py:242(Condition)\n     9902    0.015    0.000    0.244    0.000 threading.py:285(__enter__)\n     9902    0.014    0.000    0.020    0.000 threading.py:288(__exit__)\n    19808    0.013    0.000    0.013    0.000 threading.py:59(__init__)\n    11069    0.013    0.000    0.016    0.000 Queue.py:200(_qsize)\n     9900    0.013    0.000    0.041    0.000 threading.py:114(RLock)\n     1171    0.011    0.000    0.234    0.000 threading.py:309(wait)\n     9900    0.011    0.000    0.012    0.000 Queue.py:204(_put)\n     9900    0.011    0.000    0.012    0.000 Queue.py:208(_get)\n     9900    0.008    0.000    0.008    0.000 thread.py:52(__init__)\n     9902    0.007    0.000    0.007    0.000 {method '__exit__' of 'thread.lock' objects}\n    11075    0.005    0.000    0.005    0.000 {thread.allocate_lock}\n    11071    0.003    0.000    0.003    0.000 {len}\n     9891    0.002    0.000    0.002    0.000 {method 'remove' of 'list' objects}\n     9900    0.002    0.000    0.002    0.000 {method 'popleft' of 'collections.deque' objects}\n     9900    0.002    0.000    0.002    0.000 {method 'append' of 'collections.deque' objects}\n     1171    0.001    0.000    0.041    0.000 threading.py:297(_acquire_restore)\n     1171    0.001    0.000    0.004    0.000 threading.py:294(_release_save)\n     1171    0.000    0.000    0.000    0.000 {method 'append' of 'list' objects}\n        2    0.000    0.000    0.000    0.000 {thread.start_new_thread}\n        2    0.000    0.000    0.000    0.000 threading.py:647(__init__)\n        2    0.000    0.000    0.010    0.005 threading.py:717(start)\n        2    0.000    0.000    0.010    0.005 threading.py:597(wait)\n        2    0.000    0.000    0.000    0.000 threading.py:700(_set_daemon)\n        2    0.000    0.000    0.000    0.000 weakref.py:368(__setitem__)\n        2    0.000    0.000    0.000    0.000 threading.py:542(Event)\n        2    0.000    0.000    0.000    0.000 threading.py:1142(currentThread)\n        2    0.000    0.000    0.000    0.000 threading.py:561(__init__)\n        2    0.000    0.000    0.000    0.000 threading.py:1014(daemon)\n        2    0.000    0.000    0.000    0.000 {method 'add' of 'set' objects}\n        2    0.000    0.000    0.000    0.000 threading.py:999(daemon)\n        4    0.000    0.000    0.000    0.000 threading.py:570(isSet)\n        2    0.000    0.000    0.000    0.000 {thread.get_ident}\n        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}", "committedDate": "2020-05-01T20:32:38Z", "type": "forcePushed"}, {"oid": "b740404ec4f9c06940cfcd06388f3fb920364a62", "url": "https://github.com/apache/beam/commit/b740404ec4f9c06940cfcd06388f3fb920364a62", "message": "fixup! Fix lint", "committedDate": "2020-05-01T21:14:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2ODE3MQ==", "url": "https://github.com/apache/beam/pull/11590#discussion_r420468171", "bodyText": "should we remove a total of self._max_idle_threads - self._idle_worker_queue.qsize() workers rather than just one?\nIIUC, this is the only point (besides shutdown) where workers are removed, so maybe yes?", "author": "pabloem", "createdAt": "2020-05-05T23:32:22Z", "path": "sdks/python/apache_beam/utils/thread_pool_executor.py", "diffHunk": "@@ -137,35 +101,33 @@ def submit(self, fn, *args, **kwargs):\n     \"\"\"\n     future = _base.Future()\n     work_item = _WorkItem(future, fn, args, kwargs)\n-    try:\n-      # Keep trying to get an idle worker from the queue until we find one\n-      # that accepts the work.\n-      while not self._idle_worker_queue.get(\n-          block=False).accepted_work(work_item):\n-        pass\n-      return future\n-    except queue.Empty:\n-      with self._lock:\n-        if self._shutdown:\n-          raise RuntimeError(\n-              'Cannot schedule new tasks after thread pool '\n-              'has been shutdown.')\n-\n-        worker = _Worker(\n-            self._idle_worker_queue,\n-            self._permitted_thread_age_in_seconds,\n-            work_item)\n+    with self._lock:\n+      if self._shutdown:\n+        raise RuntimeError(\n+            'Cannot schedule new tasks after thread pool has been shutdown.')\n+      try:\n+        self._idle_worker_queue.get(block=False).assign_work(work_item)\n+\n+        # If we have more idle threads then the max allowed, shutdown a thread.\n+        if self._idle_worker_queue.qsize() > self._max_idle_threads:\n+          try:\n+            self._idle_worker_queue.get(block=False).shutdown()", "originalCommit": "b740404ec4f9c06940cfcd06388f3fb920364a62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg5NDkyMA==", "url": "https://github.com/apache/beam/pull/11590#discussion_r420894920", "bodyText": "I was thinking removing one at a time to reduce the rate at which we kill threads would \"average\" out the thread creation/death rate better but I have no data to support this hunch.", "author": "lukecwik", "createdAt": "2020-05-06T15:44:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2ODE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkyNjkzNA==", "url": "https://github.com/apache/beam/pull/11590#discussion_r420926934", "bodyText": "Removing one thread at a time seems sensible to me.", "author": "mxm", "createdAt": "2020-05-06T16:29:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2ODE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk4MzMxNg==", "url": "https://github.com/apache/beam/pull/11590#discussion_r420983316", "bodyText": "sounds good then!", "author": "pabloem", "createdAt": "2020-05-06T17:56:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2ODE3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDczNTc0MQ==", "url": "https://github.com/apache/beam/pull/11590#discussion_r424735741", "bodyText": "Also remove the shutdown worker from self._workers?", "author": "udim", "createdAt": "2020-05-13T21:15:55Z", "path": "sdks/python/apache_beam/utils/thread_pool_executor.py", "diffHunk": "@@ -137,35 +101,33 @@ def submit(self, fn, *args, **kwargs):\n     \"\"\"\n     future = _base.Future()\n     work_item = _WorkItem(future, fn, args, kwargs)\n-    try:\n-      # Keep trying to get an idle worker from the queue until we find one\n-      # that accepts the work.\n-      while not self._idle_worker_queue.get(\n-          block=False).accepted_work(work_item):\n-        pass\n-      return future\n-    except queue.Empty:\n-      with self._lock:\n-        if self._shutdown:\n-          raise RuntimeError(\n-              'Cannot schedule new tasks after thread pool '\n-              'has been shutdown.')\n-\n-        worker = _Worker(\n-            self._idle_worker_queue,\n-            self._permitted_thread_age_in_seconds,\n-            work_item)\n+    with self._lock:\n+      if self._shutdown:\n+        raise RuntimeError(\n+            'Cannot schedule new tasks after thread pool has been shutdown.')\n+      try:\n+        self._idle_worker_queue.get(block=False).assign_work(work_item)\n+\n+        # If we have more idle threads then the max allowed, shutdown a thread.\n+        if self._idle_worker_queue.qsize() > self._max_idle_threads:\n+          try:\n+            self._idle_worker_queue.get(block=False).shutdown()", "originalCommit": "b740404ec4f9c06940cfcd06388f3fb920364a62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1NTM3Mw==", "url": "https://github.com/apache/beam/pull/11590#discussion_r424755373", "bodyText": "self._workers is a weakref set so when the thread dies it should automatically be removed from the set. Calling shutdown multiple times should be a non-issue as well for each worker as all it does is make the worker eligible to wake up.\nDo you have any more details as to why you think this is an issue?", "author": "lukecwik", "createdAt": "2020-05-13T21:59:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDczNTc0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc3NDc3OQ==", "url": "https://github.com/apache/beam/pull/11590#discussion_r424774779", "bodyText": "Sorry, I missed that it was a WeakSet. Multiple shutdowns look ok as well.", "author": "udim", "createdAt": "2020-05-13T22:49:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDczNTc0MQ=="}], "type": "inlineReview"}]}