{"pr_number": 12469, "pr_title": "[BEAM-9547] Lift associative aggregations.", "pr_createdAt": "2020-08-05T00:10:43Z", "pr_url": "https://github.com/apache/beam/pull/12469", "timeline": [{"oid": "0858f29df681b6e3538b5793bd29739effdcabed", "url": "https://github.com/apache/beam/commit/0858f29df681b6e3538b5793bd29739effdcabed", "message": "[BEAM-9547] Lift associative aggregations.\n\nAlso fix issue with inputs getting used in downstream stages.", "committedDate": "2020-08-05T00:09:39Z", "type": "commit"}, {"oid": "7a169fd059670561fe925c79b77d06b4e40c33d5", "url": "https://github.com/apache/beam/commit/7a169fd059670561fe925c79b77d06b4e40c33d5", "message": "fix lint, py 3.5 issue", "committedDate": "2020-08-05T23:38:23Z", "type": "commit"}, {"oid": "d24e048925ae6c787735925b7001ac8e2f204c77", "url": "https://github.com/apache/beam/commit/d24e048925ae6c787735925b7001ac8e2f204c77", "message": "Merge branch 'master' into dataframes-agg", "committedDate": "2020-08-05T23:41:36Z", "type": "commit"}, {"oid": "c5ddbe63b3ad77f1cf5f769b5ce59178118e4ff6", "url": "https://github.com/apache/beam/commit/c5ddbe63b3ad77f1cf5f769b5ce59178118e4ff6", "message": "cleanup", "committedDate": "2020-08-05T23:43:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgzNTc0Mw==", "url": "https://github.com/apache/beam/pull/12469#discussion_r468835743", "bodyText": "Would it be reasonable to re-order the columns by name when asserting equality?", "author": "TheNeuralBit", "createdAt": "2020-08-11T20:10:05Z", "path": "sdks/python/apache_beam/dataframe/frames_test.py", "diffHunk": "@@ -80,6 +81,24 @@ def test_loc(self):\n     self._run_test(lambda df: df.loc[df.A > 10], df)\n     self._run_test(lambda df: df.loc[lambda df: df.A > 10], df)\n \n+  def test_series_agg(self):\n+    s = pd.Series(list(range(16)))\n+    self._run_test(lambda s: s.agg('sum'), s)\n+    self._run_test(lambda s: s.agg(['sum']), s)\n+    self._run_test(lambda s: s.agg(['sum', 'mean']), s)\n+    self._run_test(lambda s: s.agg(['mean']), s)\n+    self._run_test(lambda s: s.agg('mean'), s)\n+\n+  @unittest.skipIf(sys.version_info < (3, 6), 'Nondeterministic dict ordering.')", "originalCommit": "c5ddbe63b3ad77f1cf5f769b5ce59178118e4ff6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYxNjc2MQ==", "url": "https://github.com/apache/beam/pull/12469#discussion_r469616761", "bodyText": "Column ordering seems to be a fairly fundamental property of dataframes that I'd prefer to check in general, and 3.5 won't be supported for long.", "author": "robertwb", "createdAt": "2020-08-13T00:14:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgzNTc0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQwODI3Mw==", "url": "https://github.com/apache/beam/pull/12469#discussion_r469408273", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  for arg in expr.args():\n          \n          \n            \n                    if arg in inputs:\n          \n          \n            \n                      stage.inputs.add(arg)\n          \n          \n            \n                  # Ensure that any inputs for the overall transform are added in downstream stages\n          \n          \n            \n                  for arg in expr.args():\n          \n          \n            \n                    if arg in inputs:\n          \n          \n            \n                      stage.inputs.add(arg)", "author": "TheNeuralBit", "createdAt": "2020-08-12T17:02:48Z", "path": "sdks/python/apache_beam/dataframe/transforms.py", "diffHunk": "@@ -244,6 +261,9 @@ def expr_to_stages(expr):\n             # It also must be declared as an output of the producing stage.\n             expr_to_stage(arg).outputs.add(arg)\n       stage.ops.append(expr)\n+      for arg in expr.args():\n+        if arg in inputs:\n+          stage.inputs.add(arg)", "originalCommit": "c5ddbe63b3ad77f1cf5f769b5ce59178118e4ff6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYxNzA1OA==", "url": "https://github.com/apache/beam/pull/12469#discussion_r469617058", "bodyText": "Done.", "author": "robertwb", "createdAt": "2020-08-13T00:16:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQwODI3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQwOTg0MQ==", "url": "https://github.com/apache/beam/pull/12469#discussion_r469409841", "bodyText": "Could you add some comments describing the case each if is handling? I had a hard time making sense of them all", "author": "TheNeuralBit", "createdAt": "2020-08-12T17:05:33Z", "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -150,35 +164,79 @@ def at(self, *args, **kwargs):\n   def loc(self):\n     return _DeferredLoc(self)\n \n-  @frame_base.args_to_kwargs(pd.DataFrame)\n-  @frame_base.populate_defaults(pd.DataFrame)\n-  def aggregate(self, axis, **kwargs):\n+  def aggregate(self, func, axis=0, *args, **kwargs):\n     if axis is None:\n-      return self.agg(axis=1, **kwargs).agg(axis=0, **kwargs)\n-    return frame_base.DeferredFrame.wrap(\n+      return self.agg(func, *args, **dict(kwargs, axis=1)).agg(\n+          func, *args, **dict(kwargs, axis=0))\n+    elif axis in (1, 'columns'):\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              'aggregate',\n+              lambda df: df.agg(func, axis=1, *args, **kwargs),\n+              [self._expr],\n+              requires_partition_by=partitionings.Nothing()))\n+    elif len(self._expr.proxy().columns) == 0 or args or kwargs:\n+      return frame_base.DeferredFrame.wrap(\n         expressions.ComputedExpression(\n             'aggregate',\n-            lambda df: df.agg(axis=axis, **kwargs),\n+            lambda df: df.agg(func, *args, **kwargs),\n             [self._expr],\n-            # TODO(robertwb): Sub-aggregate when possible.\n             requires_partition_by=partitionings.Singleton()))\n+    else:\n+      if not isinstance(func, dict):\n+        col_names = list(self._expr.proxy().columns)\n+        func = {col: func for col in col_names}\n+      else:\n+        col_names = list(func.keys())\n+      aggregated_cols = []\n+      for col in col_names:\n+        funcs = func[col]\n+        if not isinstance(funcs, list):\n+          funcs = [funcs]\n+        aggregated_cols.append(self[col].agg(funcs, *args, **kwargs))\n+      if any(isinstance(funcs, list) for funcs in func.values()):\n+        return frame_base.DeferredFrame.wrap(\n+            expressions.ComputedExpression(\n+                'join_aggregate',\n+                lambda *cols: pd.DataFrame(\n+                    {col: value for col, value in zip(col_names, cols)}),\n+                [col._expr for col in aggregated_cols]))\n+      else:\n+        return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              'join_aggregate',\n+                lambda *cols: pd.Series(\n+                    {col: value[0] for col, value in zip(col_names, cols)}),\n+              [col._expr for col in aggregated_cols],\n+              proxy=self._expr.proxy().agg(func, *args, **kwargs)))", "originalCommit": "c5ddbe63b3ad77f1cf5f769b5ce59178118e4ff6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYxNzMyMw==", "url": "https://github.com/apache/beam/pull/12469#discussion_r469617323", "bodyText": "Done.", "author": "robertwb", "createdAt": "2020-08-13T00:16:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQwOTg0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQxMDEzNA==", "url": "https://github.com/apache/beam/pull/12469#discussion_r469410134", "bodyText": "Here as well", "author": "TheNeuralBit", "createdAt": "2020-08-12T17:06:02Z", "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -35,20 +35,34 @@ def __array__(self, dtype=None):\n   transform = frame_base._elementwise_method(\n       'transform', restrictions={'axis': 0})\n \n-  def agg(self, *args, **kwargs):\n-    return frame_base.DeferredFrame.wrap(\n-        expressions.ComputedExpression(\n-            'agg',\n-            lambda df: df.agg(*args, **kwargs), [self._expr],\n-            preserves_partition_by=partitionings.Singleton(),\n-            requires_partition_by=partitionings.Singleton()))\n-\n-  all = frame_base._associative_agg_method('all')\n-  any = frame_base._associative_agg_method('any')\n-  min = frame_base._associative_agg_method('min')\n-  max = frame_base._associative_agg_method('max')\n-  prod = product = frame_base._associative_agg_method('prod')\n-  sum = frame_base._associative_agg_method('sum')\n+  def agg(self, func, axis=0, *args, **kwargs):\n+    if isinstance(func, list) and len(func) > 1:\n+      rows = [self.agg([f], *args, **kwargs) for f in func]\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              'join_aggregate',\n+              lambda *rows: pd.concat(rows), [row._expr for row in rows]))\n+    else:\n+      base_func = func[0] if isinstance(func, list) else func\n+      if _is_associative(base_func) and not args and not kwargs:\n+        intermediate = expressions.elementwise_expression(\n+            'pre_agg',\n+            lambda s: s.agg([base_func], *args, **kwargs), [self._expr])\n+      else:\n+        intermediate = self._expr\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              'agg',\n+              lambda s: s.agg(func, *args, **kwargs), [intermediate],\n+              preserves_partition_by=partitionings.Singleton(),\n+              requires_partition_by=partitionings.Singleton()))", "originalCommit": "c5ddbe63b3ad77f1cf5f769b5ce59178118e4ff6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYxNzM2Mg==", "url": "https://github.com/apache/beam/pull/12469#discussion_r469617362", "bodyText": "Done.", "author": "robertwb", "createdAt": "2020-08-13T00:17:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQxMDEzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQxMDgwMA==", "url": "https://github.com/apache/beam/pull/12469#discussion_r469410800", "bodyText": "I think we're missing this alias in Series", "author": "TheNeuralBit", "createdAt": "2020-08-12T17:07:12Z", "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -150,35 +164,79 @@ def at(self, *args, **kwargs):\n   def loc(self):\n     return _DeferredLoc(self)\n \n-  @frame_base.args_to_kwargs(pd.DataFrame)\n-  @frame_base.populate_defaults(pd.DataFrame)\n-  def aggregate(self, axis, **kwargs):\n+  def aggregate(self, func, axis=0, *args, **kwargs):\n     if axis is None:\n-      return self.agg(axis=1, **kwargs).agg(axis=0, **kwargs)\n-    return frame_base.DeferredFrame.wrap(\n+      return self.agg(func, *args, **dict(kwargs, axis=1)).agg(\n+          func, *args, **dict(kwargs, axis=0))\n+    elif axis in (1, 'columns'):\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              'aggregate',\n+              lambda df: df.agg(func, axis=1, *args, **kwargs),\n+              [self._expr],\n+              requires_partition_by=partitionings.Nothing()))\n+    elif len(self._expr.proxy().columns) == 0 or args or kwargs:\n+      return frame_base.DeferredFrame.wrap(\n         expressions.ComputedExpression(\n             'aggregate',\n-            lambda df: df.agg(axis=axis, **kwargs),\n+            lambda df: df.agg(func, *args, **kwargs),\n             [self._expr],\n-            # TODO(robertwb): Sub-aggregate when possible.\n             requires_partition_by=partitionings.Singleton()))\n+    else:\n+      if not isinstance(func, dict):\n+        col_names = list(self._expr.proxy().columns)\n+        func = {col: func for col in col_names}\n+      else:\n+        col_names = list(func.keys())\n+      aggregated_cols = []\n+      for col in col_names:\n+        funcs = func[col]\n+        if not isinstance(funcs, list):\n+          funcs = [funcs]\n+        aggregated_cols.append(self[col].agg(funcs, *args, **kwargs))\n+      if any(isinstance(funcs, list) for funcs in func.values()):\n+        return frame_base.DeferredFrame.wrap(\n+            expressions.ComputedExpression(\n+                'join_aggregate',\n+                lambda *cols: pd.DataFrame(\n+                    {col: value for col, value in zip(col_names, cols)}),\n+                [col._expr for col in aggregated_cols]))\n+      else:\n+        return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              'join_aggregate',\n+                lambda *cols: pd.Series(\n+                    {col: value[0] for col, value in zip(col_names, cols)}),\n+              [col._expr for col in aggregated_cols],\n+              proxy=self._expr.proxy().agg(func, *args, **kwargs)))\n \n   agg = aggregate", "originalCommit": "c5ddbe63b3ad77f1cf5f769b5ce59178118e4ff6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYxNzI4Ng==", "url": "https://github.com/apache/beam/pull/12469#discussion_r469617286", "bodyText": "Good call. Done.", "author": "robertwb", "createdAt": "2020-08-13T00:16:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQxMDgwMA=="}], "type": "inlineReview"}, {"oid": "afaf3e67be30b0324d40dc85e78cc69b9608365d", "url": "https://github.com/apache/beam/commit/afaf3e67be30b0324d40dc85e78cc69b9608365d", "message": "fixup", "committedDate": "2020-08-13T00:17:29Z", "type": "commit"}, {"oid": "b101ee22a485405aabc50ded1c6fb8bfd8bd69e9", "url": "https://github.com/apache/beam/commit/b101ee22a485405aabc50ded1c6fb8bfd8bd69e9", "message": "Merge branch 'master' into dataframes-agg", "committedDate": "2020-08-13T16:23:54Z", "type": "commit"}, {"oid": "238d1e55343b384972e852c1b58c008ffa30740a", "url": "https://github.com/apache/beam/commit/238d1e55343b384972e852c1b58c008ffa30740a", "message": "merge and update wrt non-parallel-operations decorator and check", "committedDate": "2020-08-13T16:35:05Z", "type": "commit"}]}