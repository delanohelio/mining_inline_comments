{"pr_number": 11231, "pr_title": "[BEAM-4374] Shortids for the Go SDK", "pr_createdAt": "2020-03-26T00:29:53Z", "pr_url": "https://github.com/apache/beam/pull/11231", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc2MDQzMQ==", "url": "https://github.com/apache/beam/pull/11231#discussion_r398760431", "bodyText": "This won't be enough as the key. There are things that have the same labels but different URNs, e.g start/process/finish msecs\nI would suggest using the MonitoringInfo with the payload field \"blanked\" as the key of the map.", "author": "lukecwik", "createdAt": "2020-03-26T17:32:54Z", "path": "sdks/go/pkg/beam/core/runtime/harness/monitoring.go", "diffHunk": "@@ -16,20 +16,71 @@\n package harness\n \n import (\n+\t\"bytes\"\n+\t\"strconv\"\n+\t\"sync\"\n+\t\"sync/atomic\"\n \t\"time\"\n \n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/coder\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/mtime\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/core/metrics\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/exec\"\n \tfnpb \"github.com/apache/beam/sdks/go/pkg/beam/model/fnexecution_v1\"\n \tppb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n \t\"github.com/golang/protobuf/ptypes\"\n )\n \n-func monitoring(p *exec.Plan) (*fnpb.Metrics, []*ppb.MonitoringInfo) {\n+// TODO: 2020/03/26 - measure mutex overhead vs sync.Map for this case.\n+// sync.Map might have lower contention for this read heavy load.\n+var (\n+\tshortMu         sync.Mutex\n+\tlabels2ShortIds map[metrics.Labels]string", "originalCommit": "d0acbc58a3ef4ce722f52accbcd2032d44010fc3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODgxODM5MQ==", "url": "https://github.com/apache/beam/pull/11231#discussion_r398818391", "bodyText": "Ah good to know. Thanks!", "author": "lostluck", "createdAt": "2020-03-26T18:58:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc2MDQzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg4NjY2NA==", "url": "https://github.com/apache/beam/pull/11231#discussion_r398886664", "bodyText": "Ah good point.\nCan't use protos as Go Map keys, because of all the magic fields they have, but I can use other things.\nI've put in aligned constants, types, and string arrays for the proto specified strings, so these lookups don't end up hashing the strings every time (and instead use a uint32, which is very fast for go maps to deal with.) There's still the hashing of the fields in metrics.Labels, but we can do the same hashing in the metrics code at a later time, to allow for faster lookups for those instead.", "author": "lostluck", "createdAt": "2020-03-26T20:57:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc2MDQzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc2MTEyMw==", "url": "https://github.com/apache/beam/pull/11231#discussion_r398761123", "bodyText": "+1", "author": "lukecwik", "createdAt": "2020-03-26T17:33:52Z", "path": "sdks/go/pkg/beam/core/runtime/harness/monitoring.go", "diffHunk": "@@ -16,20 +16,71 @@\n package harness\n \n import (\n+\t\"bytes\"\n+\t\"strconv\"\n+\t\"sync\"\n+\t\"sync/atomic\"\n \t\"time\"\n \n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/coder\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/mtime\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/core/metrics\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/exec\"\n \tfnpb \"github.com/apache/beam/sdks/go/pkg/beam/model/fnexecution_v1\"\n \tppb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n \t\"github.com/golang/protobuf/ptypes\"\n )\n \n-func monitoring(p *exec.Plan) (*fnpb.Metrics, []*ppb.MonitoringInfo) {\n+// TODO: 2020/03/26 - measure mutex overhead vs sync.Map for this case.\n+// sync.Map might have lower contention for this read heavy load.\n+var (\n+\tshortMu         sync.Mutex\n+\tlabels2ShortIds map[metrics.Labels]string\n+\tshortIds2Infos  map[string]*ppb.MonitoringInfo\n+\n+\tlastShortID int64\n+)\n+\n+func getNextShortID() string {\n+\tid := atomic.AddInt64(&lastShortID, 1)\n+\t// No reason not to use the smallest string short ids possible.", "originalCommit": "d0acbc58a3ef4ce722f52accbcd2032d44010fc3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODgxODYzNg==", "url": "https://github.com/apache/beam/pull/11231#discussion_r398818636", "bodyText": "Base36: It's what efficiency craves.", "author": "lostluck", "createdAt": "2020-03-26T18:58:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc2MTEyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk0ODE5OA==", "url": "https://github.com/apache/beam/pull/11231#discussion_r398948198", "bodyText": "heads up that this has now been exploded so that each MonitoringInfoSpec has a unique urn meaning that you'll see:\nbeam:metric:user:sum_int64:v1, beam:metric:user:sum_double:v1, ...", "author": "lukecwik", "createdAt": "2020-03-26T23:18:48Z", "path": "sdks/go/pkg/beam/core/runtime/harness/monitoring.go", "diffHunk": "@@ -16,20 +16,165 @@\n package harness\n \n import (\n+\t\"bytes\"\n+\t\"strconv\"\n+\t\"sync\"\n+\t\"sync/atomic\"\n \t\"time\"\n \n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/coder\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/mtime\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/core/metrics\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/exec\"\n \tfnpb \"github.com/apache/beam/sdks/go/pkg/beam/model/fnexecution_v1\"\n \tppb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n \t\"github.com/golang/protobuf/ptypes\"\n )\n \n-func monitoring(p *exec.Plan) (*fnpb.Metrics, []*ppb.MonitoringInfo) {\n+type mUrn uint32\n+type mType uint32\n+\n+// TODO: Pull these from the protos.\n+var sUrns = []string{\n+\t\"beam:metric:user:v1\",", "originalCommit": "59ebb380724411bdc5c5f7c35cf90aac50540809", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk0ODYwNA==", "url": "https://github.com/apache/beam/pull/11231#discussion_r398948604", "bodyText": "Since the urns uniquely identify the type now, you don't need this anymore and a monitoring info is uniquely described by urn + labels.", "author": "lukecwik", "createdAt": "2020-03-26T23:19:56Z", "path": "sdks/go/pkg/beam/core/runtime/harness/monitoring.go", "diffHunk": "@@ -16,20 +16,165 @@\n package harness\n \n import (\n+\t\"bytes\"\n+\t\"strconv\"\n+\t\"sync\"\n+\t\"sync/atomic\"\n \t\"time\"\n \n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/coder\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/mtime\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/core/metrics\"\n \t\"github.com/apache/beam/sdks/go/pkg/beam/core/runtime/exec\"\n \tfnpb \"github.com/apache/beam/sdks/go/pkg/beam/model/fnexecution_v1\"\n \tppb \"github.com/apache/beam/sdks/go/pkg/beam/model/pipeline_v1\"\n \t\"github.com/golang/protobuf/ptypes\"\n )\n \n-func monitoring(p *exec.Plan) (*fnpb.Metrics, []*ppb.MonitoringInfo) {\n+type mUrn uint32\n+type mType uint32\n+\n+// TODO: Pull these from the protos.\n+var sUrns = []string{\n+\t\"beam:metric:user:v1\",\n+\t\"beam:metric:element_count:v1\",\n+\t\"beam:metric:pardo_execution_time:start_bundle_msecs:v1\",\n+\t\"beam:metric:pardo_execution_time:process_bundle_msecs:v1\",\n+\t\"beam:metric:pardo_execution_time:finish_bundle_msecs:v1\",\n+\t\"beam:metric:ptransform_progress:remaining:v1\",\n+\t\"beam:metric:ptransform_progress:completed:v1\",\n+\n+\t\"TestingSentinelUrn\", // Must remain last.\n+}\n+\n+const (\n+\turnUser mUrn = iota\n+\turnElementCount\n+\turnStartBundle\n+\turnProcessBundle\n+\turnFinishBundle\n+\turnProgressRemaining\n+\turnProgressCompleted\n+\n+\turnTestSentinel // Must remain last.\n+)\n+\n+var sTypes = []string{\n+\t\"beam:metrics:sum_int64:v1\",\n+\t\"beam:metrics:sum_double:v1\",\n+\t\"beam:metrics:distribution_int64:v1\",\n+\t\"beam:metrics:distribution_double:v1\",\n+\t\"beam:metrics:latest_int64:v1\",\n+\t\"beam:metrics:latest_double:v1\",\n+\t\"beam:metrics:top_n_int64:v1\",\n+\t\"beam:metrics:top_n_double:v1\",\n+\t\"beam:metrics:bottom_n_int64:v1\",\n+\t\"beam:metrics:bottom_n_double:v1\",\n+\t\"beam:metrics:monitoring_table:v1\",\n+\t\"beam:metrics:progress:v1\",\n+\n+\t\"TestingSentinelType\", // Must remain last.\n+}\n+\n+const (", "originalCommit": "59ebb380724411bdc5c5f7c35cf90aac50540809", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTYwMjM0MA==", "url": "https://github.com/apache/beam/pull/11231#discussion_r399602340", "bodyText": "Ack. I've kept the extra marker type around for the moment, but I might collapse things into the function to simplify some thing.", "author": "lostluck", "createdAt": "2020-03-28T01:33:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk0ODYwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk0OTY5MA==", "url": "https://github.com/apache/beam/pull/11231#discussion_r398949690", "bodyText": "Can you add the case where the same urn but unique labels are used gets a different short id?", "author": "lukecwik", "createdAt": "2020-03-26T23:23:08Z", "path": "sdks/go/pkg/beam/core/runtime/harness/monitoring_test.go", "diffHunk": "@@ -0,0 +1,122 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package harness\n+\n+import (\n+\t\"testing\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/metrics\"\n+)\n+\n+func TestGetShortID(t *testing.T) {\n+\ttests := []struct {\n+\t\tid           string\n+\t\turn          mUrn\n+\t\ttyp          mType\n+\t\texpectedUrn  string\n+\t\texpectedType string\n+\t}{\n+\t\t{\n+\t\t\tid:           \"1\",\n+\t\t\turn:          urnUser,", "originalCommit": "59ebb380724411bdc5c5f7c35cf90aac50540809", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bcce0ea6ff8c7d344af24105bd210431d2af589e", "url": "https://github.com/apache/beam/commit/bcce0ea6ff8c7d344af24105bd210431d2af589e", "message": "accept generated metrics", "committedDate": "2020-03-28T01:26:49Z", "type": "forcePushed"}, {"oid": "26064992766a1f1c001f97dc523b1580998f841f", "url": "https://github.com/apache/beam/commit/26064992766a1f1c001f97dc523b1580998f841f", "message": "accept generated metrics", "committedDate": "2020-03-28T01:28:27Z", "type": "commit"}, {"oid": "26064992766a1f1c001f97dc523b1580998f841f", "url": "https://github.com/apache/beam/commit/26064992766a1f1c001f97dc523b1580998f841f", "message": "accept generated metrics", "committedDate": "2020-03-28T01:28:27Z", "type": "forcePushed"}, {"oid": "a66b380b9c481574183811de03067c3132e459c0", "url": "https://github.com/apache/beam/commit/a66b380b9c481574183811de03067c3132e459c0", "message": "Remove mType and move type urns to urnToType", "committedDate": "2020-03-28T04:30:16Z", "type": "commit"}, {"oid": "046e2f835cbda3614129f59786f2c9180d4c0a88", "url": "https://github.com/apache/beam/commit/046e2f835cbda3614129f59786f2c9180d4c0a88", "message": "add missing pcollection payload", "committedDate": "2020-03-28T04:51:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2OTA0NA==", "url": "https://github.com/apache/beam/pull/11231#discussion_r401969044", "bodyText": "Is the locking correct here? I'd think you'd want to acquire the lock in getShortId since that's where the race condition could occur. This function is only reading shortIds2Infos which should only gain more entries over time and entries are never modified, so I'd think it would be thread-safe even without acquiring the lock. Am I missing something?", "author": "TheNeuralBit", "createdAt": "2020-04-01T23:31:18Z", "path": "sdks/go/pkg/beam/core/runtime/harness/monitoring.go", "diffHunk": "@@ -28,10 +31,180 @@ import (\n \t\"github.com/golang/protobuf/ptypes\"\n )\n \n-func monitoring(p *exec.Plan) (*fnpb.Metrics, []*ppb.MonitoringInfo) {\n+type mUrn uint32\n+\n+// TODO: Pull these from the protos.\n+var sUrns = [...]string{\n+\t\"beam:metric:user:sum_int64:v1\",\n+\t\"beam:metric:user:sum_double:v1\",\n+\t\"beam:metric:user:distribution_int64:v1\",\n+\t\"beam:metric:user:distribution_double:v1\",\n+\t\"beam:metric:user:latest_int64:v1\",\n+\t\"beam:metric:user:latest_double:v1\",\n+\t\"beam:metric:user:top_n_int64:v1\",\n+\t\"beam:metric:user:top_n_double:v1\",\n+\t\"beam:metric:user:bottom_n_int64:v1\",\n+\t\"beam:metric:user:bottom_n_double:v1\",\n+\n+\t\"beam:metric:element_count:v1\",\n+\t\"beam:metric:sampled_byte_size:v1\",\n+\n+\t\"beam:metric:pardo_execution_time:start_bundle_msecs:v1\",\n+\t\"beam:metric:pardo_execution_time:process_bundle_msecs:v1\",\n+\t\"beam:metric:pardo_execution_time:finish_bundle_msecs:v1\",\n+\t\"beam:metric:ptransform_execution_time:total_msecs:v1\",\n+\n+\t\"beam:metric:ptransform_progress:remaining:v1\",\n+\t\"beam:metric:ptransform_progress:completed:v1\",\n+\n+\t\"TestingSentinelUrn\", // Must remain last.\n+}\n+\n+const (\n+\turnUserSumInt64 mUrn = iota\n+\turnUserSumFloat64\n+\turnUserDistInt64\n+\turnUserDistFloat64\n+\turnUserLatestMsInt64\n+\turnUserLatestMsFloat64\n+\turnUserTopNInt64\n+\turnUserTopNFloat64\n+\turnUserBottomNInt64\n+\turnUserBottomNFloat64\n+\n+\turnElementCount\n+\turnSampledByteSize\n+\n+\turnStartBundle\n+\turnProcessBundle\n+\turnFinishBundle\n+\turnTransformTotalTime\n+\n+\turnProgressRemaining\n+\turnProgressCompleted\n+\n+\turnTestSentinel // Must remain last.\n+)\n+\n+// urnToType maps the urn to it's encoding type.\n+// This function is written to be inlinable by the compiler.\n+func urnToType(u mUrn) string {\n+\tswitch u {\n+\tcase urnUserSumInt64, urnElementCount, urnStartBundle, urnProcessBundle, urnFinishBundle, urnTransformTotalTime:\n+\t\treturn \"beam:metrics:sum_int64:v1\"\n+\tcase urnUserSumFloat64:\n+\t\treturn \"beam:metrics:sum_double:v1\"\n+\tcase urnUserDistInt64, urnSampledByteSize:\n+\t\treturn \"beam:metrics:distribution_int64:v1\"\n+\tcase urnUserDistFloat64:\n+\t\treturn \"beam:metrics:distribution_double:v1\"\n+\tcase urnUserLatestMsInt64:\n+\t\treturn \"beam:metrics:latest_int64:v1\"\n+\tcase urnUserLatestMsFloat64:\n+\t\treturn \"beam:metrics:latest_double:v1\"\n+\tcase urnUserTopNInt64:\n+\t\treturn \"beam:metrics:top_n_int64:v1\"\n+\tcase urnUserTopNFloat64:\n+\t\treturn \"beam:metrics:top_n_double:v1\"\n+\tcase urnUserBottomNInt64:\n+\t\treturn \"beam:metrics:bottom_n_int64:v1\"\n+\tcase urnUserBottomNFloat64:\n+\t\treturn \"beam:metrics:bottom_n_double:v1\"\n+\n+\tcase urnProgressRemaining, urnProgressCompleted:\n+\t\treturn \"beam:metrics:progress:v1\"\n+\n+\t// Monitoring Table isn't currently in the protos.\n+\t// case ???:\n+\t//\treturn \"beam:metrics:monitoring_table:v1\"\n+\n+\tcase urnTestSentinel:\n+\t\treturn \"TestingSentinelType\"\n+\n+\tdefault:\n+\t\tpanic(\"metric urn without specified type\" + sUrns[u])\n+\t}\n+}\n+\n+type shortKey struct {\n+\tmetrics.Labels\n+\tUrn mUrn // Urns fully specify their type.\n+}\n+\n+// shortIDCache retains lookup caches for short ids to the full monitoring\n+// info metadata.\n+//\n+// TODO: 2020/03/26 - measure mutex overhead vs sync.Map for this case.\n+// sync.Map might have lower contention for this read heavy load.\n+type shortIDCache struct {\n+\tmu              sync.Mutex\n+\tlabels2ShortIds map[shortKey]string\n+\tshortIds2Infos  map[string]*ppb.MonitoringInfo\n+\n+\tlastShortID int64\n+}\n+\n+func newShortIDCache() *shortIDCache {\n+\treturn &shortIDCache{\n+\t\tlabels2ShortIds: make(map[shortKey]string),\n+\t\tshortIds2Infos:  make(map[string]*ppb.MonitoringInfo),\n+\t}\n+}\n+\n+func (c *shortIDCache) getNextShortID() string {\n+\tid := atomic.AddInt64(&c.lastShortID, 1)\n+\t// No reason not to use the smallest string short ids possible.\n+\treturn strconv.FormatInt(id, 36)\n+}\n+\n+// getShortID returns the short id for the given metric, and if\n+// it doesn't exist yet, stores the metadata.\n+// Assumes c.mu lock is held.\n+func (c *shortIDCache) getShortID(l metrics.Labels, urn mUrn) string {\n+\tk := shortKey{l, urn}\n+\ts, ok := c.labels2ShortIds[k]\n+\tif ok {\n+\t\treturn s\n+\t}\n+\ts = c.getNextShortID()\n+\tc.labels2ShortIds[k] = s\n+\tc.shortIds2Infos[s] = &ppb.MonitoringInfo{\n+\t\tUrn:    sUrns[urn],\n+\t\tType:   urnToType(urn),\n+\t\tLabels: userLabels(l),\n+\t}\n+\treturn s\n+}\n+\n+func (c *shortIDCache) shortIdsToInfos(shortids []string) map[string]*ppb.MonitoringInfo {\n+\tc.mu.Lock()\n+\tdefer c.mu.Unlock()", "originalCommit": "046e2f835cbda3614129f59786f2c9180d4c0a88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3NDQ1NQ==", "url": "https://github.com/apache/beam/pull/11231#discussion_r401974455", "bodyText": "CC: @lostluck\nThats a good point, it looks like we should also acquire the lock in getShortID after we generate the short id.", "author": "lukecwik", "createdAt": "2020-04-01T23:48:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2OTA0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3NDYzNg==", "url": "https://github.com/apache/beam/pull/11231#discussion_r401974636", "bodyText": "Locking by itself is a reasonably expensive operation so I made the choice to lock per metrics request. getShortId is called multiple times in that critical section.\nshortIdsToInfo though is called outside that critical section, by potentially a different thread, so the lock here is to protect the reads from hitting the mutations in getShortId.\nThough come to think of it, the Go SDK harness handles all runner requests other than the ProcessBundle instructions on the grpc goroutine, so we might not need any locking at all, which would definitely simplify things and make it faster.  In order to unblock the proto changes I didn't optimize this section entirely so there's still work and clean up that can happen here.", "author": "lostluck", "createdAt": "2020-04-01T23:49:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2OTA0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAyMDA4Nw==", "url": "https://github.com/apache/beam/pull/11231#discussion_r402020087", "bodyText": "Also, I did comment that getShortId assumes the lock is held.", "author": "lostluck", "createdAt": "2020-04-02T02:40:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2OTA0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAyNjI3OQ==", "url": "https://github.com/apache/beam/pull/11231#discussion_r402026279", "bodyText": "Thanks for the explanation again, I knew this before but blanked when @TheNeuralBit brought it up.", "author": "lukecwik", "createdAt": "2020-04-02T03:05:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2OTA0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQyNTkyNQ==", "url": "https://github.com/apache/beam/pull/11231#discussion_r402425925", "bodyText": "Oops sorry for the noise @lostluck, thanks for the explanation", "author": "TheNeuralBit", "createdAt": "2020-04-02T15:57:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk2OTA0NA=="}], "type": "inlineReview"}]}