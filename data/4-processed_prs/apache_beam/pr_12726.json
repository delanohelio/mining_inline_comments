{"pr_number": 12726, "pr_title": "[BEAM-10475] Add max buffering duration to GroupIntoBatches (Java)", "pr_createdAt": "2020-08-28T23:53:04Z", "pr_url": "https://github.com/apache/beam/pull/12726", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4NjM0MQ==", "url": "https://github.com/apache/beam/pull/12726#discussion_r480286341", "bodyText": "It seems like we want to clear the timer when the flush is triggered by batch size/end of window. I think we can just clear the timer when flushBatch is called by window timer expiration and num >= batchSize.", "author": "boyuanzz", "createdAt": "2020-08-31T17:44:11Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/GroupIntoBatches.java", "diffHunk": "@@ -150,70 +184,95 @@ public long apply(long left, long right) {\n               });\n \n       this.keySpec = StateSpecs.value(inputKeyCoder);\n-      // prefetch every 20% of batchSize elements. Do not prefetch if batchSize is too little\n+      // Prefetch every 20% of batchSize elements. Do not prefetch if batchSize is too little\n       this.prefetchFrequency = ((batchSize / 5) <= 1) ? Long.MAX_VALUE : (batchSize / 5);\n     }\n \n     @ProcessElement\n     public void processElement(\n-        @TimerId(END_OF_WINDOW_ID) Timer timer,\n+        @TimerId(END_OF_WINDOW_ID) Timer windowTimer,\n+        @TimerId(END_OF_BUFFERING_ID) Timer bufferingTimer,\n         @StateId(BATCH_ID) BagState<InputT> batch,\n         @StateId(NUM_ELEMENTS_IN_BATCH_ID) CombiningState<Long, long[], Long> numElementsInBatch,\n         @StateId(KEY_ID) ValueState<K> key,\n         @Element KV<K, InputT> element,\n         BoundedWindow window,\n         OutputReceiver<KV<K, Iterable<InputT>>> receiver) {\n-      Instant windowExpires = window.maxTimestamp().plus(allowedLateness);\n-\n-      LOG.debug(\n-          \"*** SET TIMER *** to point in time {} for window {}\",\n-          windowExpires.toString(),\n-          window.toString());\n-      timer.set(windowExpires);\n+      Instant windowEnds = window.maxTimestamp().plus(allowedLateness);\n+      LOG.debug(\"*** SET TIMER *** to point in time {} for window {}\", windowEnds, window);\n+      windowTimer.set(windowEnds);\n       key.write(element.getKey());\n+      LOG.debug(\"*** BATCH *** Add element for window {} \", window);\n       batch.add(element.getValue());\n-      LOG.debug(\"*** BATCH *** Add element for window {} \", window.toString());\n-      // blind add is supported with combiningState\n+      // Blind add is supported with combiningState\n       numElementsInBatch.add(1L);\n+\n       Long num = numElementsInBatch.read();\n+      if (num == 1 && maxBufferingDuration.isLongerThan(Duration.ZERO)) {\n+        // This is the first element in batch. Start counting buffering time if a limit was set.\n+        bufferingTimer.offset(maxBufferingDuration).setRelative();\n+      }\n       if (num % prefetchFrequency == 0) {\n-        // prefetch data and modify batch state (readLater() modifies this)\n+        // Prefetch data and modify batch state (readLater() modifies this)\n         batch.readLater();\n       }\n       if (num >= batchSize) {\n         LOG.debug(\"*** END OF BATCH *** for window {}\", window.toString());\n-        flushBatch(receiver, key, batch, numElementsInBatch);\n+        flushBatch(receiver, key, batch, numElementsInBatch, bufferingTimer);\n       }\n     }\n \n+    @OnTimer(END_OF_BUFFERING_ID)\n+    public void onBufferingTimer(\n+        OutputReceiver<KV<K, Iterable<InputT>>> receiver,\n+        @Timestamp Instant timestamp,\n+        @StateId(KEY_ID) ValueState<K> key,\n+        @StateId(BATCH_ID) BagState<InputT> batch,\n+        @StateId(NUM_ELEMENTS_IN_BATCH_ID) CombiningState<Long, long[], Long> numElementsInBatch,\n+        @TimerId(END_OF_BUFFERING_ID) Timer bufferingTimer) {\n+      LOG.debug(\n+          \"*** END OF BUFFERING *** for timer timestamp {} with buffering duration {}\",\n+          timestamp,\n+          maxBufferingDuration);\n+      flushBatch(receiver, key, batch, numElementsInBatch, bufferingTimer);\n+    }\n+\n     @OnTimer(END_OF_WINDOW_ID)\n-    public void onTimerCallback(\n+    public void onWindowTimer(\n         OutputReceiver<KV<K, Iterable<InputT>>> receiver,\n         @Timestamp Instant timestamp,\n         @StateId(KEY_ID) ValueState<K> key,\n         @StateId(BATCH_ID) BagState<InputT> batch,\n         @StateId(NUM_ELEMENTS_IN_BATCH_ID) CombiningState<Long, long[], Long> numElementsInBatch,\n+        @TimerId(END_OF_BUFFERING_ID) Timer bufferingTimer,\n         BoundedWindow window) {\n       LOG.debug(\n           \"*** END OF WINDOW *** for timer timestamp {} in windows {}\",\n           timestamp,\n           window.toString());\n-      flushBatch(receiver, key, batch, numElementsInBatch);\n+      flushBatch(receiver, key, batch, numElementsInBatch, bufferingTimer);\n     }\n \n     private void flushBatch(\n         OutputReceiver<KV<K, Iterable<InputT>>> receiver,\n         ValueState<K> key,\n         BagState<InputT> batch,\n-        CombiningState<Long, long[], Long> numElementsInBatch) {\n+        CombiningState<Long, long[], Long> numElementsInBatch,\n+        Timer bufferingTimer) {\n       Iterable<InputT> values = batch.read();\n-      // when the timer fires, batch state might be empty\n+      // When the timer fires, batch state might be empty\n       if (!Iterables.isEmpty(values)) {\n         receiver.output(KV.of(key.read(), values));\n       }\n       batch.clear();\n       LOG.debug(\"*** BATCH *** clear\");\n       numElementsInBatch.clear();\n+      // We might reach here due to batch size being reached, window expiration or buffering time\n+      // limit being reached. Reset the buffering timer anyway since the state is empty now. It'll\n+      // be reset again if a new element arrives before the expiration time set here.\n+      if (maxBufferingDuration.isLongerThan(Duration.ZERO)) {\n+        bufferingTimer.offset(maxBufferingDuration).setRelative();", "originalCommit": "a0d977fa115a50df77c4e29300f15197321b9540", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxMDk0OQ==", "url": "https://github.com/apache/beam/pull/12726#discussion_r481510949", "bodyText": "By clearing the timer, do you mean to extend the deadline like what I am doing now or set it to something else?\nI feel it's a little bit cleaner to put it in FlushBatch since we always want to reset the buffering time when a batch is flushed, whatever the reason is. wdyt?", "author": "nehsyc", "createdAt": "2020-09-02T00:46:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4NjM0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI1OTk3OA==", "url": "https://github.com/apache/beam/pull/12726#discussion_r482259978", "bodyText": "I thought we have exposed clear API to java timer but it turns out we haven't. Extending timer sounds good to me before we have clear API.\nAnother problem is when the bufferTimer is fired, we still reset the bufferTimer in the flushBatch, which is not necessary. It seems like we can pass /*bufferingTimer=*/=null when onBufferingTimer  invokes fluchBatch,", "author": "boyuanzz", "createdAt": "2020-09-02T17:56:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4NjM0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ3MzEwNg==", "url": "https://github.com/apache/beam/pull/12726#discussion_r482473106", "bodyText": "Sounds good. Uploaded a commit to address this.", "author": "nehsyc", "createdAt": "2020-09-02T21:08:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4NjM0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxMzgxOQ==", "url": "https://github.com/apache/beam/pull/12726#discussion_r487313819", "bodyText": "Can we use null here?", "author": "boyuanzz", "createdAt": "2020-09-11T22:14:14Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/GroupIntoBatches.java", "diffHunk": "@@ -66,25 +68,49 @@\n  *         }\n  *     }}));\n  * </pre>\n+ *\n+ * <p>Example 2 (batch unbounded input in a global window):\n+ *\n+ * <pre>{@code\n+ * PCollection<KV<String, String>> unboundedInput = ...;\n+ * long batchSize = 100L;\n+ * Duration maxBufferingDuration = Duration.standardSeconds(10);\n+ * PCollection<KV<String, Iterable<String>>> batched = unboundedInput\n+ *     .apply(Window.<KV<String, String>>into(new GlobalWindows())\n+ *         .triggering(Repeatedly.forever(AfterPane.elementCountAtLeast(1)))\n+ *         .discardingFiredPanes())\n+ *     .apply(GroupIntoBatches.<String, String>ofSize(batchSize)\n+ *         .withMaxBufferingDuration(maxBufferingDuration));\n+ * }</pre>\n  */\n public class GroupIntoBatches<K, InputT>\n     extends PTransform<PCollection<KV<K, InputT>>, PCollection<KV<K, Iterable<InputT>>>> {\n \n   private final long batchSize;\n+  private final Duration maxBufferingDuration;\n \n-  private GroupIntoBatches(long batchSize) {\n+  private GroupIntoBatches(long batchSize, Duration maxBufferingDuration) {\n     this.batchSize = batchSize;\n+    this.maxBufferingDuration = maxBufferingDuration;\n   }\n \n   public static <K, InputT> GroupIntoBatches<K, InputT> ofSize(long batchSize) {\n-    return new GroupIntoBatches<>(batchSize);\n+    return new GroupIntoBatches<>(batchSize, Duration.ZERO);", "originalCommit": "0c30decd9b9b375c0ce2b4d1efe46c770d811d49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQ0MzE0NA==", "url": "https://github.com/apache/beam/pull/12726#discussion_r487443144", "bodyText": "Changed it to null.", "author": "nehsyc", "createdAt": "2020-09-12T19:58:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxMzgxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxNDgyOQ==", "url": "https://github.com/apache/beam/pull/12726#discussion_r487314829", "bodyText": "If Duration.ZERO is not preferred, we can have a check here.", "author": "boyuanzz", "createdAt": "2020-09-11T22:18:02Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/GroupIntoBatches.java", "diffHunk": "@@ -66,25 +68,49 @@\n  *         }\n  *     }}));\n  * </pre>\n+ *\n+ * <p>Example 2 (batch unbounded input in a global window):\n+ *\n+ * <pre>{@code\n+ * PCollection<KV<String, String>> unboundedInput = ...;\n+ * long batchSize = 100L;\n+ * Duration maxBufferingDuration = Duration.standardSeconds(10);\n+ * PCollection<KV<String, Iterable<String>>> batched = unboundedInput\n+ *     .apply(Window.<KV<String, String>>into(new GlobalWindows())\n+ *         .triggering(Repeatedly.forever(AfterPane.elementCountAtLeast(1)))\n+ *         .discardingFiredPanes())\n+ *     .apply(GroupIntoBatches.<String, String>ofSize(batchSize)\n+ *         .withMaxBufferingDuration(maxBufferingDuration));\n+ * }</pre>\n  */\n public class GroupIntoBatches<K, InputT>\n     extends PTransform<PCollection<KV<K, InputT>>, PCollection<KV<K, Iterable<InputT>>>> {\n \n   private final long batchSize;\n+  private final Duration maxBufferingDuration;\n \n-  private GroupIntoBatches(long batchSize) {\n+  private GroupIntoBatches(long batchSize, Duration maxBufferingDuration) {\n     this.batchSize = batchSize;\n+    this.maxBufferingDuration = maxBufferingDuration;\n   }\n \n   public static <K, InputT> GroupIntoBatches<K, InputT> ofSize(long batchSize) {\n-    return new GroupIntoBatches<>(batchSize);\n+    return new GroupIntoBatches<>(batchSize, Duration.ZERO);\n   }\n \n   /** Returns the size of the batch. */\n   public long getBatchSize() {\n     return batchSize;\n   }\n \n+  /**\n+   * Set a time limit (in processing time) on how long an incomplete batch of elements is allowed to\n+   * be buffered. Once a batch is flushed to output, the timer is reset.\n+   */\n+  public GroupIntoBatches<K, InputT> withMaxBufferingDuration(Duration duration) {\n+    return new GroupIntoBatches<>(batchSize, duration);", "originalCommit": "0c30decd9b9b375c0ce2b4d1efe46c770d811d49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQ0MzEzMA==", "url": "https://github.com/apache/beam/pull/12726#discussion_r487443130", "bodyText": "Added a check. But we still need additional checks on null value. See my reply below.", "author": "nehsyc", "createdAt": "2020-09-12T19:58:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxNDgyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxNTg1Mg==", "url": "https://github.com/apache/beam/pull/12726#discussion_r487315852", "bodyText": "We want to pass bufferingTimer to null when flushBatchis called here since there is no need to clear the bufferTimer when it's fired.", "author": "boyuanzz", "createdAt": "2020-09-11T22:21:48Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/GroupIntoBatches.java", "diffHunk": "@@ -150,70 +185,96 @@ public long apply(long left, long right) {\n               });\n \n       this.keySpec = StateSpecs.value(inputKeyCoder);\n-      // prefetch every 20% of batchSize elements. Do not prefetch if batchSize is too little\n+      // Prefetch every 20% of batchSize elements. Do not prefetch if batchSize is too little\n       this.prefetchFrequency = ((batchSize / 5) <= 1) ? Long.MAX_VALUE : (batchSize / 5);\n     }\n \n     @ProcessElement\n     public void processElement(\n-        @TimerId(END_OF_WINDOW_ID) Timer timer,\n+        @TimerId(END_OF_WINDOW_ID) Timer windowTimer,\n+        @TimerId(END_OF_BUFFERING_ID) Timer bufferingTimer,\n         @StateId(BATCH_ID) BagState<InputT> batch,\n         @StateId(NUM_ELEMENTS_IN_BATCH_ID) CombiningState<Long, long[], Long> numElementsInBatch,\n         @StateId(KEY_ID) ValueState<K> key,\n         @Element KV<K, InputT> element,\n         BoundedWindow window,\n         OutputReceiver<KV<K, Iterable<InputT>>> receiver) {\n-      Instant windowExpires = window.maxTimestamp().plus(allowedLateness);\n-\n-      LOG.debug(\n-          \"*** SET TIMER *** to point in time {} for window {}\",\n-          windowExpires.toString(),\n-          window.toString());\n-      timer.set(windowExpires);\n+      Instant windowEnds = window.maxTimestamp().plus(allowedLateness);\n+      LOG.debug(\"*** SET TIMER *** to point in time {} for window {}\", windowEnds, window);\n+      windowTimer.set(windowEnds);\n       key.write(element.getKey());\n+      LOG.debug(\"*** BATCH *** Add element for window {} \", window);\n       batch.add(element.getValue());\n-      LOG.debug(\"*** BATCH *** Add element for window {} \", window.toString());\n-      // blind add is supported with combiningState\n+      // Blind add is supported with combiningState\n       numElementsInBatch.add(1L);\n+\n       Long num = numElementsInBatch.read();\n+      if (num == 1 && maxBufferingDuration.isLongerThan(Duration.ZERO)) {\n+        // This is the first element in batch. Start counting buffering time if a limit was set.\n+        bufferingTimer.offset(maxBufferingDuration).setRelative();\n+      }\n       if (num % prefetchFrequency == 0) {\n-        // prefetch data and modify batch state (readLater() modifies this)\n+        // Prefetch data and modify batch state (readLater() modifies this)\n         batch.readLater();\n       }\n       if (num >= batchSize) {\n         LOG.debug(\"*** END OF BATCH *** for window {}\", window.toString());\n-        flushBatch(receiver, key, batch, numElementsInBatch);\n+        flushBatch(receiver, key, batch, numElementsInBatch, bufferingTimer);\n       }\n     }\n \n+    @OnTimer(END_OF_BUFFERING_ID)\n+    public void onBufferingTimer(\n+        OutputReceiver<KV<K, Iterable<InputT>>> receiver,\n+        @Timestamp Instant timestamp,\n+        @StateId(KEY_ID) ValueState<K> key,\n+        @StateId(BATCH_ID) BagState<InputT> batch,\n+        @StateId(NUM_ELEMENTS_IN_BATCH_ID) CombiningState<Long, long[], Long> numElementsInBatch,\n+        @TimerId(END_OF_BUFFERING_ID) Timer bufferingTimer) {\n+      LOG.debug(\n+          \"*** END OF BUFFERING *** for timer timestamp {} with buffering duration {}\",\n+          timestamp,\n+          maxBufferingDuration);\n+      flushBatch(receiver, key, batch, numElementsInBatch, bufferingTimer);", "originalCommit": "0c30decd9b9b375c0ce2b4d1efe46c770d811d49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQ0MzEyOA==", "url": "https://github.com/apache/beam/pull/12726#discussion_r487443128", "bodyText": "Good catch! Corrected.", "author": "nehsyc", "createdAt": "2020-09-12T19:57:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxNTg1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxNjM1Mw==", "url": "https://github.com/apache/beam/pull/12726#discussion_r487316353", "bodyText": "Instead, we want to pass actual bufferingTimer here since we want to clear it.", "author": "boyuanzz", "createdAt": "2020-09-11T22:23:37Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/GroupIntoBatches.java", "diffHunk": "@@ -150,70 +185,96 @@ public long apply(long left, long right) {\n               });\n \n       this.keySpec = StateSpecs.value(inputKeyCoder);\n-      // prefetch every 20% of batchSize elements. Do not prefetch if batchSize is too little\n+      // Prefetch every 20% of batchSize elements. Do not prefetch if batchSize is too little\n       this.prefetchFrequency = ((batchSize / 5) <= 1) ? Long.MAX_VALUE : (batchSize / 5);\n     }\n \n     @ProcessElement\n     public void processElement(\n-        @TimerId(END_OF_WINDOW_ID) Timer timer,\n+        @TimerId(END_OF_WINDOW_ID) Timer windowTimer,\n+        @TimerId(END_OF_BUFFERING_ID) Timer bufferingTimer,\n         @StateId(BATCH_ID) BagState<InputT> batch,\n         @StateId(NUM_ELEMENTS_IN_BATCH_ID) CombiningState<Long, long[], Long> numElementsInBatch,\n         @StateId(KEY_ID) ValueState<K> key,\n         @Element KV<K, InputT> element,\n         BoundedWindow window,\n         OutputReceiver<KV<K, Iterable<InputT>>> receiver) {\n-      Instant windowExpires = window.maxTimestamp().plus(allowedLateness);\n-\n-      LOG.debug(\n-          \"*** SET TIMER *** to point in time {} for window {}\",\n-          windowExpires.toString(),\n-          window.toString());\n-      timer.set(windowExpires);\n+      Instant windowEnds = window.maxTimestamp().plus(allowedLateness);\n+      LOG.debug(\"*** SET TIMER *** to point in time {} for window {}\", windowEnds, window);\n+      windowTimer.set(windowEnds);\n       key.write(element.getKey());\n+      LOG.debug(\"*** BATCH *** Add element for window {} \", window);\n       batch.add(element.getValue());\n-      LOG.debug(\"*** BATCH *** Add element for window {} \", window.toString());\n-      // blind add is supported with combiningState\n+      // Blind add is supported with combiningState\n       numElementsInBatch.add(1L);\n+\n       Long num = numElementsInBatch.read();\n+      if (num == 1 && maxBufferingDuration.isLongerThan(Duration.ZERO)) {\n+        // This is the first element in batch. Start counting buffering time if a limit was set.\n+        bufferingTimer.offset(maxBufferingDuration).setRelative();\n+      }\n       if (num % prefetchFrequency == 0) {\n-        // prefetch data and modify batch state (readLater() modifies this)\n+        // Prefetch data and modify batch state (readLater() modifies this)\n         batch.readLater();\n       }\n       if (num >= batchSize) {\n         LOG.debug(\"*** END OF BATCH *** for window {}\", window.toString());\n-        flushBatch(receiver, key, batch, numElementsInBatch);\n+        flushBatch(receiver, key, batch, numElementsInBatch, bufferingTimer);\n       }\n     }\n \n+    @OnTimer(END_OF_BUFFERING_ID)\n+    public void onBufferingTimer(\n+        OutputReceiver<KV<K, Iterable<InputT>>> receiver,\n+        @Timestamp Instant timestamp,\n+        @StateId(KEY_ID) ValueState<K> key,\n+        @StateId(BATCH_ID) BagState<InputT> batch,\n+        @StateId(NUM_ELEMENTS_IN_BATCH_ID) CombiningState<Long, long[], Long> numElementsInBatch,\n+        @TimerId(END_OF_BUFFERING_ID) Timer bufferingTimer) {\n+      LOG.debug(\n+          \"*** END OF BUFFERING *** for timer timestamp {} with buffering duration {}\",\n+          timestamp,\n+          maxBufferingDuration);\n+      flushBatch(receiver, key, batch, numElementsInBatch, bufferingTimer);\n+    }\n+\n     @OnTimer(END_OF_WINDOW_ID)\n-    public void onTimerCallback(\n+    public void onWindowTimer(\n         OutputReceiver<KV<K, Iterable<InputT>>> receiver,\n         @Timestamp Instant timestamp,\n         @StateId(KEY_ID) ValueState<K> key,\n         @StateId(BATCH_ID) BagState<InputT> batch,\n         @StateId(NUM_ELEMENTS_IN_BATCH_ID) CombiningState<Long, long[], Long> numElementsInBatch,\n+        @TimerId(END_OF_BUFFERING_ID) Timer bufferingTimer,\n         BoundedWindow window) {\n       LOG.debug(\n           \"*** END OF WINDOW *** for timer timestamp {} in windows {}\",\n           timestamp,\n           window.toString());\n-      flushBatch(receiver, key, batch, numElementsInBatch);\n+      flushBatch(receiver, key, batch, numElementsInBatch, null);", "originalCommit": "0c30decd9b9b375c0ce2b4d1efe46c770d811d49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxNzAwMw==", "url": "https://github.com/apache/beam/pull/12726#discussion_r487317003", "bodyText": "If we checkArgument(duration != Duration.ZERO) when withMaxBufferingDuration (), then we can drop the check here.", "author": "boyuanzz", "createdAt": "2020-09-11T22:25:45Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/GroupIntoBatches.java", "diffHunk": "@@ -150,70 +185,96 @@ public long apply(long left, long right) {\n               });\n \n       this.keySpec = StateSpecs.value(inputKeyCoder);\n-      // prefetch every 20% of batchSize elements. Do not prefetch if batchSize is too little\n+      // Prefetch every 20% of batchSize elements. Do not prefetch if batchSize is too little\n       this.prefetchFrequency = ((batchSize / 5) <= 1) ? Long.MAX_VALUE : (batchSize / 5);\n     }\n \n     @ProcessElement\n     public void processElement(\n-        @TimerId(END_OF_WINDOW_ID) Timer timer,\n+        @TimerId(END_OF_WINDOW_ID) Timer windowTimer,\n+        @TimerId(END_OF_BUFFERING_ID) Timer bufferingTimer,\n         @StateId(BATCH_ID) BagState<InputT> batch,\n         @StateId(NUM_ELEMENTS_IN_BATCH_ID) CombiningState<Long, long[], Long> numElementsInBatch,\n         @StateId(KEY_ID) ValueState<K> key,\n         @Element KV<K, InputT> element,\n         BoundedWindow window,\n         OutputReceiver<KV<K, Iterable<InputT>>> receiver) {\n-      Instant windowExpires = window.maxTimestamp().plus(allowedLateness);\n-\n-      LOG.debug(\n-          \"*** SET TIMER *** to point in time {} for window {}\",\n-          windowExpires.toString(),\n-          window.toString());\n-      timer.set(windowExpires);\n+      Instant windowEnds = window.maxTimestamp().plus(allowedLateness);\n+      LOG.debug(\"*** SET TIMER *** to point in time {} for window {}\", windowEnds, window);\n+      windowTimer.set(windowEnds);\n       key.write(element.getKey());\n+      LOG.debug(\"*** BATCH *** Add element for window {} \", window);\n       batch.add(element.getValue());\n-      LOG.debug(\"*** BATCH *** Add element for window {} \", window.toString());\n-      // blind add is supported with combiningState\n+      // Blind add is supported with combiningState\n       numElementsInBatch.add(1L);\n+\n       Long num = numElementsInBatch.read();\n+      if (num == 1 && maxBufferingDuration.isLongerThan(Duration.ZERO)) {", "originalCommit": "0c30decd9b9b375c0ce2b4d1efe46c770d811d49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQ0MzEwOQ==", "url": "https://github.com/apache/beam/pull/12726#discussion_r487443109", "bodyText": "We still need the check on non-null value here, if not non-zero, since we should not set the timer in the case where the buffering duration is not set (i.e., when only ofSize() is called).", "author": "nehsyc", "createdAt": "2020-09-12T19:57:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxNzAwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxNzE4MA==", "url": "https://github.com/apache/beam/pull/12726#discussion_r487317180", "bodyText": "Same above.", "author": "boyuanzz", "createdAt": "2020-09-11T22:26:27Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/GroupIntoBatches.java", "diffHunk": "@@ -150,70 +185,96 @@ public long apply(long left, long right) {\n               });\n \n       this.keySpec = StateSpecs.value(inputKeyCoder);\n-      // prefetch every 20% of batchSize elements. Do not prefetch if batchSize is too little\n+      // Prefetch every 20% of batchSize elements. Do not prefetch if batchSize is too little\n       this.prefetchFrequency = ((batchSize / 5) <= 1) ? Long.MAX_VALUE : (batchSize / 5);\n     }\n \n     @ProcessElement\n     public void processElement(\n-        @TimerId(END_OF_WINDOW_ID) Timer timer,\n+        @TimerId(END_OF_WINDOW_ID) Timer windowTimer,\n+        @TimerId(END_OF_BUFFERING_ID) Timer bufferingTimer,\n         @StateId(BATCH_ID) BagState<InputT> batch,\n         @StateId(NUM_ELEMENTS_IN_BATCH_ID) CombiningState<Long, long[], Long> numElementsInBatch,\n         @StateId(KEY_ID) ValueState<K> key,\n         @Element KV<K, InputT> element,\n         BoundedWindow window,\n         OutputReceiver<KV<K, Iterable<InputT>>> receiver) {\n-      Instant windowExpires = window.maxTimestamp().plus(allowedLateness);\n-\n-      LOG.debug(\n-          \"*** SET TIMER *** to point in time {} for window {}\",\n-          windowExpires.toString(),\n-          window.toString());\n-      timer.set(windowExpires);\n+      Instant windowEnds = window.maxTimestamp().plus(allowedLateness);\n+      LOG.debug(\"*** SET TIMER *** to point in time {} for window {}\", windowEnds, window);\n+      windowTimer.set(windowEnds);\n       key.write(element.getKey());\n+      LOG.debug(\"*** BATCH *** Add element for window {} \", window);\n       batch.add(element.getValue());\n-      LOG.debug(\"*** BATCH *** Add element for window {} \", window.toString());\n-      // blind add is supported with combiningState\n+      // Blind add is supported with combiningState\n       numElementsInBatch.add(1L);\n+\n       Long num = numElementsInBatch.read();\n+      if (num == 1 && maxBufferingDuration.isLongerThan(Duration.ZERO)) {\n+        // This is the first element in batch. Start counting buffering time if a limit was set.\n+        bufferingTimer.offset(maxBufferingDuration).setRelative();\n+      }\n       if (num % prefetchFrequency == 0) {\n-        // prefetch data and modify batch state (readLater() modifies this)\n+        // Prefetch data and modify batch state (readLater() modifies this)\n         batch.readLater();\n       }\n       if (num >= batchSize) {\n         LOG.debug(\"*** END OF BATCH *** for window {}\", window.toString());\n-        flushBatch(receiver, key, batch, numElementsInBatch);\n+        flushBatch(receiver, key, batch, numElementsInBatch, bufferingTimer);\n       }\n     }\n \n+    @OnTimer(END_OF_BUFFERING_ID)\n+    public void onBufferingTimer(\n+        OutputReceiver<KV<K, Iterable<InputT>>> receiver,\n+        @Timestamp Instant timestamp,\n+        @StateId(KEY_ID) ValueState<K> key,\n+        @StateId(BATCH_ID) BagState<InputT> batch,\n+        @StateId(NUM_ELEMENTS_IN_BATCH_ID) CombiningState<Long, long[], Long> numElementsInBatch,\n+        @TimerId(END_OF_BUFFERING_ID) Timer bufferingTimer) {\n+      LOG.debug(\n+          \"*** END OF BUFFERING *** for timer timestamp {} with buffering duration {}\",\n+          timestamp,\n+          maxBufferingDuration);\n+      flushBatch(receiver, key, batch, numElementsInBatch, bufferingTimer);\n+    }\n+\n     @OnTimer(END_OF_WINDOW_ID)\n-    public void onTimerCallback(\n+    public void onWindowTimer(\n         OutputReceiver<KV<K, Iterable<InputT>>> receiver,\n         @Timestamp Instant timestamp,\n         @StateId(KEY_ID) ValueState<K> key,\n         @StateId(BATCH_ID) BagState<InputT> batch,\n         @StateId(NUM_ELEMENTS_IN_BATCH_ID) CombiningState<Long, long[], Long> numElementsInBatch,\n+        @TimerId(END_OF_BUFFERING_ID) Timer bufferingTimer,\n         BoundedWindow window) {\n       LOG.debug(\n           \"*** END OF WINDOW *** for timer timestamp {} in windows {}\",\n           timestamp,\n           window.toString());\n-      flushBatch(receiver, key, batch, numElementsInBatch);\n+      flushBatch(receiver, key, batch, numElementsInBatch, null);\n     }\n \n     private void flushBatch(\n         OutputReceiver<KV<K, Iterable<InputT>>> receiver,\n         ValueState<K> key,\n         BagState<InputT> batch,\n-        CombiningState<Long, long[], Long> numElementsInBatch) {\n+        CombiningState<Long, long[], Long> numElementsInBatch,\n+        @Nullable Timer bufferingTimer) {\n       Iterable<InputT> values = batch.read();\n-      // when the timer fires, batch state might be empty\n+      // When the timer fires, batch state might be empty\n       if (!Iterables.isEmpty(values)) {\n         receiver.output(KV.of(key.read(), values));\n       }\n       batch.clear();\n       LOG.debug(\"*** BATCH *** clear\");\n       numElementsInBatch.clear();\n+      // We might reach here due to batch size being reached or window expiration. Reset the\n+      // buffering timer (if not null) since the state is empty now. It'll be extended again if a\n+      // new element arrives prior to the expiration time set here.\n+      // TODO(BEAM-10887): Use clear() when it's available.\n+      if (bufferingTimer != null && maxBufferingDuration.isLongerThan(Duration.ZERO)) {", "originalCommit": "0c30decd9b9b375c0ce2b4d1efe46c770d811d49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ad21380ce9969372697192c37d2e3dc62c74d6d9", "url": "https://github.com/apache/beam/commit/ad21380ce9969372697192c37d2e3dc62c74d6d9", "message": "Add max buffering duration to GroupIntoBatches", "committedDate": "2020-09-14T17:24:15Z", "type": "commit"}, {"oid": "ad21380ce9969372697192c37d2e3dc62c74d6d9", "url": "https://github.com/apache/beam/commit/ad21380ce9969372697192c37d2e3dc62c74d6d9", "message": "Add max buffering duration to GroupIntoBatches", "committedDate": "2020-09-14T17:24:15Z", "type": "forcePushed"}]}