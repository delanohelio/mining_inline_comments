{"pr_number": 13370, "pr_title": "[BEAM-11188] Adding unit test for mergeExpandedWithPipeline", "pr_createdAt": "2020-11-18T02:54:46Z", "pr_url": "https://github.com/apache/beam/pull/13370", "timeline": [{"oid": "c0fde1b63a708b6606e72404d9e045f8c2b3f09f", "url": "https://github.com/apache/beam/commit/c0fde1b63a708b6606e72404d9e045f8c2b3f09f", "message": "[BEAM-11188] Adding unit test for mergeExpandedWithPipeline\n\nThis is meant to be part of a larger change adding unit tests for the various pipeline transformations in graphx/xlang.go.", "committedDate": "2020-11-18T02:52:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI5OTM2Mw==", "url": "https://github.com/apache/beam/pull/13370#discussion_r526299363", "bodyText": "In this case, you probably just want cmp.Equal instead of cmp.Diff, since we never use the diff result.\nhttps://pkg.go.dev/github.com/google/go-cmp/cmp#Equal", "author": "lostluck", "createdAt": "2020-11-18T17:50:17Z", "path": "sdks/go/pkg/beam/core/runtime/graphx/xlang_test.go", "diffHunk": "@@ -203,3 +203,214 @@ func TestExpandedComponents(t *testing.T) {\n \n \t})\n }\n+\n+var testExternal = graph.ExternalTransform{\n+\tUrn:           \"test_urn\",\n+\tPayload:       nil,\n+\tExpansionAddr: \"test_addr\",\n+\tExpanded:      &testExpanded,\n+}\n+\n+var testComponents = pipepb.Components{\n+\tTransforms:          map[string]*pipepb.PTransform{\"transform_id1\": {UniqueName: \"test_components_transform\"}},\n+\tPcollections:        map[string]*pipepb.PCollection{\"pcollection_id1\": {UniqueName: \"test_components_pcollection\"}},\n+\tWindowingStrategies: map[string]*pipepb.WindowingStrategy{\"windowing_id1\": {WindowCoderId: \"test_components_windowing\"}},\n+\tCoders:              map[string]*pipepb.Coder{\"coder_id1\": {Spec: &pipepb.FunctionSpec{Urn: \"test_components_coder\"}}},\n+\tEnvironments:        map[string]*pipepb.Environment{\"environment_id1\": {Urn: \"test_components_environment\"}},\n+}\n+\n+var testRequirements = []string{\"test_requirement1\", \"test_requirement2\"}\n+\n+var testTransform = pipepb.PTransform{\n+\tUniqueName: \"test_transform\",\n+}\n+\n+var testExpanded = graph.ExpandedTransform{\n+\tComponents:   &testComponents,\n+\tTransform:    &testTransform,\n+\tRequirements: testRequirements,\n+}\n+\n+var testExternal2 = graph.ExternalTransform{\n+\tUrn:           \"test_urn2\",\n+\tPayload:       nil,\n+\tExpansionAddr: \"test_addr2\",\n+\tExpanded:      &testExpanded2,\n+}\n+\n+var testComponents2 = pipepb.Components{\n+\tTransforms:          map[string]*pipepb.PTransform{\"transform_id2\": {UniqueName: \"test_components2_transform\"}},\n+\tPcollections:        map[string]*pipepb.PCollection{\"pcollection_id2\": {UniqueName: \"test_components2_pcollection\"}},\n+\tWindowingStrategies: map[string]*pipepb.WindowingStrategy{\"windowing_id2\": {WindowCoderId: \"test_components2_windowing\"}},\n+\tCoders:              map[string]*pipepb.Coder{\"coder_id2\": {Spec: &pipepb.FunctionSpec{Urn: \"test_components2_coder\"}}},\n+\tEnvironments:        map[string]*pipepb.Environment{\"environment_id2\": {Urn: \"test_components2_environment\"}},\n+}\n+\n+var testRequirements2 = []string{\"test_requirement2\", \"test_requirement3\"}\n+\n+var testTransform2 = pipepb.PTransform{\n+\tUniqueName: \"test_transform2\",\n+}\n+\n+var testExpanded2 = graph.ExpandedTransform{\n+\tComponents:   &testComponents2,\n+\tTransform:    &testTransform2,\n+\tRequirements: testRequirements2,\n+}\n+\n+// TestMergeExpandedWithPipeline tests that mergeExpandedWithPipeline properly\n+// adds data from external transforms to a pipeline.\n+func TestMergeExpandedWithPipeline(t *testing.T) {\n+\t// Create slices of MultiEdges containing external edges, and make sure all\n+\t// relevant data from the external edges is properly added to an empty\n+\t// pipeline.\n+\ttests := []struct {\n+\t\tname          string\n+\t\tmakeEdges     func(g *graph.Graph) []*graph.MultiEdge\n+\t\twantExpandeds []graph.ExpandedTransform\n+\t}{\n+\t\t{\n+\t\t\tname: \"SingleTransform\",\n+\t\t\tmakeEdges: func(g *graph.Graph) []*graph.MultiEdge {\n+\t\t\t\ts := g.Root()\n+\t\t\t\tedge := g.NewEdge(s)\n+\t\t\t\tedge.Op = graph.External\n+\t\t\t\tedge.External = &testExternal\n+\n+\t\t\t\treturn []*graph.MultiEdge{edge}\n+\t\t\t},\n+\t\t\twantExpandeds: []graph.ExpandedTransform{testExpanded},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"MultiTransforms\",\n+\t\t\tmakeEdges: func(g *graph.Graph) []*graph.MultiEdge {\n+\t\t\t\ts := g.Root()\n+\t\t\t\tedge := g.NewEdge(s)\n+\t\t\t\tedge.Op = graph.External\n+\t\t\t\tedge.External = &testExternal\n+\t\t\t\tedge2 := g.NewEdge(s)\n+\t\t\t\tedge2.Op = graph.External\n+\t\t\t\tedge2.External = &testExternal2\n+\n+\t\t\t\treturn []*graph.MultiEdge{edge, edge2}\n+\t\t\t},\n+\t\t\twantExpandeds: []graph.ExpandedTransform{testExpanded, testExpanded2},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"NonExternalTransforms\",\n+\t\t\tmakeEdges: func(g *graph.Graph) []*graph.MultiEdge {\n+\t\t\t\ts := g.Root()\n+\t\t\t\tedge := g.NewEdge(s)\n+\t\t\t\tedge.Op = graph.External\n+\t\t\t\tedge.External = &testExternal\n+\t\t\t\tedge2 := g.NewEdge(s)\n+\t\t\t\tedge2.Op = graph.External\n+\t\t\t\tedge2.External = &testExternal2\n+\t\t\t\timpulse := graph.NewImpulse(g, s, []byte{1})\n+\t\t\t\timpulse2 := graph.NewImpulse(g, s, []byte{2})\n+\n+\t\t\t\treturn []*graph.MultiEdge{edge, edge2, impulse, impulse2}\n+\t\t\t},\n+\t\t\twantExpandeds: []graph.ExpandedTransform{testExpanded, testExpanded2},\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\ttest := test\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tg := graph.New()\n+\t\t\tedges := test.makeEdges(g)\n+\t\t\tvar p pipepb.Pipeline\n+\t\t\tp.Components = &pipepb.Components{\n+\t\t\t\tTransforms:          make(map[string]*pipepb.PTransform),\n+\t\t\t\tPcollections:        make(map[string]*pipepb.PCollection),\n+\t\t\t\tWindowingStrategies: make(map[string]*pipepb.WindowingStrategy),\n+\t\t\t\tCoders:              make(map[string]*pipepb.Coder),\n+\t\t\t\tEnvironments:        make(map[string]*pipepb.Environment),\n+\t\t\t}\n+\t\t\tmergeExpandedWithPipeline(edges, &p)\n+\n+\t\t\t// Check that all wanted expanded components have been added to\n+\t\t\t// pipeline components.\n+\t\t\tfor _, exp := range test.wantExpandeds {\n+\t\t\t\twantComps := exp.Components.(*pipepb.Components)\n+\t\t\t\tgotComps := p.GetComponents()\n+\t\t\t\tvalidateComponents(t, wantComps, gotComps)\n+\n+\t\t\t\t// Check that expanded transform is present. Need to search.\n+\t\t\t\twantTransform := exp.Transform.(*pipepb.PTransform)\n+\t\t\t\tvar found bool\n+\t\t\t\tfor _, gotTransform := range gotComps.GetTransforms() {\n+\t\t\t\t\tif d := cmp.Diff(wantTransform, gotTransform, protocmp.Transform()); d == \"\" {", "originalCommit": "c0fde1b63a708b6606e72404d9e045f8c2b3f09f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUzMDQ1NQ==", "url": "https://github.com/apache/beam/pull/13370#discussion_r526530455", "bodyText": "Whoops, kinda embarrassed I missed that. Done.", "author": "youngoli", "createdAt": "2020-11-19T01:23:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI5OTM2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMwMTYzMw==", "url": "https://github.com/apache/beam/pull/13370#discussion_r526301633", "bodyText": "I'm confused why this is broken out rather than simply using a single cmp.Diff(wantComps, gotComps, protocmp.Transform()) ?\nI'm assuming that you wanted additional granularity on the parts that were missing/extra for each component, and the full diff was less clear than this output?\nConsider adding a comment documenting that reasoning.", "author": "lostluck", "createdAt": "2020-11-18T17:53:33Z", "path": "sdks/go/pkg/beam/core/runtime/graphx/xlang_test.go", "diffHunk": "@@ -203,3 +203,214 @@ func TestExpandedComponents(t *testing.T) {\n \n \t})\n }\n+\n+var testExternal = graph.ExternalTransform{\n+\tUrn:           \"test_urn\",\n+\tPayload:       nil,\n+\tExpansionAddr: \"test_addr\",\n+\tExpanded:      &testExpanded,\n+}\n+\n+var testComponents = pipepb.Components{\n+\tTransforms:          map[string]*pipepb.PTransform{\"transform_id1\": {UniqueName: \"test_components_transform\"}},\n+\tPcollections:        map[string]*pipepb.PCollection{\"pcollection_id1\": {UniqueName: \"test_components_pcollection\"}},\n+\tWindowingStrategies: map[string]*pipepb.WindowingStrategy{\"windowing_id1\": {WindowCoderId: \"test_components_windowing\"}},\n+\tCoders:              map[string]*pipepb.Coder{\"coder_id1\": {Spec: &pipepb.FunctionSpec{Urn: \"test_components_coder\"}}},\n+\tEnvironments:        map[string]*pipepb.Environment{\"environment_id1\": {Urn: \"test_components_environment\"}},\n+}\n+\n+var testRequirements = []string{\"test_requirement1\", \"test_requirement2\"}\n+\n+var testTransform = pipepb.PTransform{\n+\tUniqueName: \"test_transform\",\n+}\n+\n+var testExpanded = graph.ExpandedTransform{\n+\tComponents:   &testComponents,\n+\tTransform:    &testTransform,\n+\tRequirements: testRequirements,\n+}\n+\n+var testExternal2 = graph.ExternalTransform{\n+\tUrn:           \"test_urn2\",\n+\tPayload:       nil,\n+\tExpansionAddr: \"test_addr2\",\n+\tExpanded:      &testExpanded2,\n+}\n+\n+var testComponents2 = pipepb.Components{\n+\tTransforms:          map[string]*pipepb.PTransform{\"transform_id2\": {UniqueName: \"test_components2_transform\"}},\n+\tPcollections:        map[string]*pipepb.PCollection{\"pcollection_id2\": {UniqueName: \"test_components2_pcollection\"}},\n+\tWindowingStrategies: map[string]*pipepb.WindowingStrategy{\"windowing_id2\": {WindowCoderId: \"test_components2_windowing\"}},\n+\tCoders:              map[string]*pipepb.Coder{\"coder_id2\": {Spec: &pipepb.FunctionSpec{Urn: \"test_components2_coder\"}}},\n+\tEnvironments:        map[string]*pipepb.Environment{\"environment_id2\": {Urn: \"test_components2_environment\"}},\n+}\n+\n+var testRequirements2 = []string{\"test_requirement2\", \"test_requirement3\"}\n+\n+var testTransform2 = pipepb.PTransform{\n+\tUniqueName: \"test_transform2\",\n+}\n+\n+var testExpanded2 = graph.ExpandedTransform{\n+\tComponents:   &testComponents2,\n+\tTransform:    &testTransform2,\n+\tRequirements: testRequirements2,\n+}\n+\n+// TestMergeExpandedWithPipeline tests that mergeExpandedWithPipeline properly\n+// adds data from external transforms to a pipeline.\n+func TestMergeExpandedWithPipeline(t *testing.T) {\n+\t// Create slices of MultiEdges containing external edges, and make sure all\n+\t// relevant data from the external edges is properly added to an empty\n+\t// pipeline.\n+\ttests := []struct {\n+\t\tname          string\n+\t\tmakeEdges     func(g *graph.Graph) []*graph.MultiEdge\n+\t\twantExpandeds []graph.ExpandedTransform\n+\t}{\n+\t\t{\n+\t\t\tname: \"SingleTransform\",\n+\t\t\tmakeEdges: func(g *graph.Graph) []*graph.MultiEdge {\n+\t\t\t\ts := g.Root()\n+\t\t\t\tedge := g.NewEdge(s)\n+\t\t\t\tedge.Op = graph.External\n+\t\t\t\tedge.External = &testExternal\n+\n+\t\t\t\treturn []*graph.MultiEdge{edge}\n+\t\t\t},\n+\t\t\twantExpandeds: []graph.ExpandedTransform{testExpanded},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"MultiTransforms\",\n+\t\t\tmakeEdges: func(g *graph.Graph) []*graph.MultiEdge {\n+\t\t\t\ts := g.Root()\n+\t\t\t\tedge := g.NewEdge(s)\n+\t\t\t\tedge.Op = graph.External\n+\t\t\t\tedge.External = &testExternal\n+\t\t\t\tedge2 := g.NewEdge(s)\n+\t\t\t\tedge2.Op = graph.External\n+\t\t\t\tedge2.External = &testExternal2\n+\n+\t\t\t\treturn []*graph.MultiEdge{edge, edge2}\n+\t\t\t},\n+\t\t\twantExpandeds: []graph.ExpandedTransform{testExpanded, testExpanded2},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"NonExternalTransforms\",\n+\t\t\tmakeEdges: func(g *graph.Graph) []*graph.MultiEdge {\n+\t\t\t\ts := g.Root()\n+\t\t\t\tedge := g.NewEdge(s)\n+\t\t\t\tedge.Op = graph.External\n+\t\t\t\tedge.External = &testExternal\n+\t\t\t\tedge2 := g.NewEdge(s)\n+\t\t\t\tedge2.Op = graph.External\n+\t\t\t\tedge2.External = &testExternal2\n+\t\t\t\timpulse := graph.NewImpulse(g, s, []byte{1})\n+\t\t\t\timpulse2 := graph.NewImpulse(g, s, []byte{2})\n+\n+\t\t\t\treturn []*graph.MultiEdge{edge, edge2, impulse, impulse2}\n+\t\t\t},\n+\t\t\twantExpandeds: []graph.ExpandedTransform{testExpanded, testExpanded2},\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\ttest := test\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\tg := graph.New()\n+\t\t\tedges := test.makeEdges(g)\n+\t\t\tvar p pipepb.Pipeline\n+\t\t\tp.Components = &pipepb.Components{\n+\t\t\t\tTransforms:          make(map[string]*pipepb.PTransform),\n+\t\t\t\tPcollections:        make(map[string]*pipepb.PCollection),\n+\t\t\t\tWindowingStrategies: make(map[string]*pipepb.WindowingStrategy),\n+\t\t\t\tCoders:              make(map[string]*pipepb.Coder),\n+\t\t\t\tEnvironments:        make(map[string]*pipepb.Environment),\n+\t\t\t}\n+\t\t\tmergeExpandedWithPipeline(edges, &p)\n+\n+\t\t\t// Check that all wanted expanded components have been added to\n+\t\t\t// pipeline components.\n+\t\t\tfor _, exp := range test.wantExpandeds {\n+\t\t\t\twantComps := exp.Components.(*pipepb.Components)\n+\t\t\t\tgotComps := p.GetComponents()\n+\t\t\t\tvalidateComponents(t, wantComps, gotComps)\n+\n+\t\t\t\t// Check that expanded transform is present. Need to search.\n+\t\t\t\twantTransform := exp.Transform.(*pipepb.PTransform)\n+\t\t\t\tvar found bool\n+\t\t\t\tfor _, gotTransform := range gotComps.GetTransforms() {\n+\t\t\t\t\tif d := cmp.Diff(wantTransform, gotTransform, protocmp.Transform()); d == \"\" {\n+\t\t\t\t\t\tfound = true\n+\t\t\t\t\t\tbreak\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif !found {\n+\t\t\t\t\tt.Errorf(\"Pipeline components missing expected expanded transform: %v\", wantTransform)\n+\t\t\t\t}\n+\n+\t\t\t\t// Check that requirements are present.\n+\t\t\t\tfor _, wantReq := range exp.Requirements {\n+\t\t\t\t\tvar found bool\n+\t\t\t\t\tfor _, gotReq := range p.GetRequirements() {\n+\t\t\t\t\t\tif wantReq == gotReq {\n+\t\t\t\t\t\t\tfound = true\n+\t\t\t\t\t\t\tbreak\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif !found {\n+\t\t\t\t\t\tt.Errorf(\"Pipeline missing expected requirement: %v\", wantReq)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+func validateComponents(t *testing.T, wantComps, gotComps *pipepb.Components) {", "originalCommit": "c0fde1b63a708b6606e72404d9e045f8c2b3f09f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUzMTgzMQ==", "url": "https://github.com/apache/beam/pull/13370#discussion_r526531831", "bodyText": "Actually, the main reason was because the pipeline object can contain the components from multiple external transforms, so just diffing the components wouldn't work. What I needed to validate is that the components of the external transform are a subset of the pipeline components, not that they're exactly equal.\nI'll add a comment explaining that, because I agree it's not immediately obvious.", "author": "youngoli", "createdAt": "2020-11-19T01:27:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMwMTYzMw=="}], "type": "inlineReview"}, {"oid": "bea50ec2035af611a1eb15e940d15ef4d569e424", "url": "https://github.com/apache/beam/commit/bea50ec2035af611a1eb15e940d15ef4d569e424", "message": "[BEAM-11188] Fixup", "committedDate": "2020-11-19T01:35:01Z", "type": "commit"}]}