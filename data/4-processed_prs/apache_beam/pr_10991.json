{"pr_number": 10991, "pr_title": "[BEAM-3301] Refactor DoFn validation & allow specifying main inputs.", "pr_createdAt": "2020-02-27T20:50:38Z", "pr_url": "https://github.com/apache/beam/pull/10991", "timeline": [{"oid": "74edc3a6bf0e38f3d166287d4511027330efe772", "url": "https://github.com/apache/beam/commit/74edc3a6bf0e38f3d166287d4511027330efe772", "message": "[BEAM-3301] Refactor DoFn validation & allow specifying main inputs.\n\nThe current version of this validation is a bit permissive because it\ndoesn't require the number of main inputs to be specified. This change\nallows specifying the number of main inputs, while also preserving\nthe existing code path of not specifying it. Along with that change,\nI made some refactors to existing validation code to try to improve\nreadability and make it more organized.\n\nThis is filed under BEAM-3301 (SDF) because it is intended to enable\nvalidation for SDFs which is difficult without a known number of\nmain inputs.", "committedDate": "2020-02-27T20:48:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ2ODI1Nw==", "url": "https://github.com/apache/beam/pull/10991#discussion_r385468257", "bodyText": "With the name NewDoFnKv, it sounds like it's already assuming that a DoFn KV is being passed in. It's OK for there to be special purpose methods that only do one thing.\nAnother option to consider instead of having two (or N) methods, consider extending the current NewDoFn with a variadic an Option type.  (eg. opts ...Option), this lets existing callers keep things the same, but allow for expanding things in the future. Option should probably be either a function type, or an interface type with private methods, and the options are provided by other methods in the package. eg. graph.NewDoFn(fn, graph.HasKVInput(), graph.HasRestriction()). This is valuable if we think being able to expand things in the future, but also lets us mix and match more easily later on. This way we can keep the existing behavior when there are no options, but keep the documentation of all the various uses in one place on the NewDoFn method referring to the option returning methods.", "author": "lostluck", "createdAt": "2020-02-28T01:45:15Z", "path": "sdks/go/pkg/beam/core/graph/fn.go", "diffHunk": "@@ -209,21 +209,58 @@ func (f *DoFn) RestrictionT() *reflect.Type {\n // a KV or not based on the other signatures (unless we're more loose about which\n // sideinputs are present). Bind should respect that.\n \n+// Constants so we can avoid magic numbers in validation. Represent number of\n+// DoFn main inputs based on what kind of input the DoFn has.\n+const (\n+\tunknownInNum = -1 // Used when we don't know the number of main inputs.\n+\tsingleInNum  = 1\n+\tkvInNum      = 2\n+)\n+\n // NewDoFn constructs a DoFn from the given value, if possible.\n func NewDoFn(fn interface{}) (*DoFn, error) {\n \tret, err := NewFn(fn)\n \tif err != nil {\n \t\treturn nil, errors.WithContext(errors.Wrapf(err, \"invalid DoFn\"), \"constructing DoFn\")\n \t}\n-\treturn AsDoFn(ret)\n+\treturn AsDoFn(ret, unknownInNum)\n }\n \n-// AsDoFn converts a Fn to a DoFn, if possible.\n-func AsDoFn(fn *Fn) (*DoFn, error) {\n+// NewDoFnKv constructs a DoFn from the given value, if possible, with\n+// improved validation from knowing whether the DoFn's main input is a KV or\n+// single element.\n+func NewDoFnKv(fn interface{}, mainKv bool) (*DoFn, error) {", "originalCommit": "74edc3a6bf0e38f3d166287d4511027330efe772", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA4OTMxMw==", "url": "https://github.com/apache/beam/pull/10991#discussion_r388089313", "bodyText": "Done, went with the variadic options made of functions approach. If anyone else is reading this, based it off this article: https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis", "author": "youngoli", "createdAt": "2020-03-05T05:48:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ2ODI1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5MzYyMA==", "url": "https://github.com/apache/beam/pull/10991#discussion_r385893620", "bodyText": "Consider a switch instead.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tif numMainIn != unknownInNum &&\n          \n          \n            \n            \t\tnumMainIn != singleInNum &&\n          \n          \n            \n            \t\tnumMainIn != kvInNum {\n          \n          \n            \n            \t\terr := errors.Errorf(\"invalid number of main inputs given. \"+\n          \n          \n            \n            \t\t\t\"Got: %v, Want: One of the following: %v\",\n          \n          \n            \n            \t\t\tprocessElementName, []int{unknownInNum, singleInNum, kvInNum})\n          \n          \n            \n            \t\treturn nil, addContext(err, fn)\n          \n          \n            \n            \t}\n          \n          \n            \n            \tswitch numMainIn {\n          \n          \n            \n            \tcase unknownInNum, singleInNum, kvInNum: \t// Valid \n          \n          \n            \n            \tdefault: // Invalid\n          \n          \n            \n            \t\terr := errors.Errorf(\"invalid number of main inputs given. \"+\n          \n          \n            \n            \t\t\t\"Got: %v, Want: One of the following: %v\",\n          \n          \n            \n            \t\t\tprocessElementName, []int{unknownInNum, singleInNum, kvInNum})\n          \n          \n            \n            \t\treturn nil, addContext(err, fn)\n          \n          \n            \n            \t}", "author": "lostluck", "createdAt": "2020-02-28T19:55:22Z", "path": "sdks/go/pkg/beam/core/graph/fn.go", "diffHunk": "@@ -209,21 +209,58 @@ func (f *DoFn) RestrictionT() *reflect.Type {\n // a KV or not based on the other signatures (unless we're more loose about which\n // sideinputs are present). Bind should respect that.\n \n+// Constants so we can avoid magic numbers in validation. Represent number of\n+// DoFn main inputs based on what kind of input the DoFn has.\n+const (\n+\tunknownInNum = -1 // Used when we don't know the number of main inputs.\n+\tsingleInNum  = 1\n+\tkvInNum      = 2\n+)\n+\n // NewDoFn constructs a DoFn from the given value, if possible.\n func NewDoFn(fn interface{}) (*DoFn, error) {\n \tret, err := NewFn(fn)\n \tif err != nil {\n \t\treturn nil, errors.WithContext(errors.Wrapf(err, \"invalid DoFn\"), \"constructing DoFn\")\n \t}\n-\treturn AsDoFn(ret)\n+\treturn AsDoFn(ret, unknownInNum)\n }\n \n-// AsDoFn converts a Fn to a DoFn, if possible.\n-func AsDoFn(fn *Fn) (*DoFn, error) {\n+// NewDoFnKv constructs a DoFn from the given value, if possible, with\n+// improved validation from knowing whether the DoFn's main input is a KV or\n+// single element.\n+func NewDoFnKv(fn interface{}, mainKv bool) (*DoFn, error) {\n+\tret, err := NewFn(fn)\n+\tif err != nil {\n+\t\treturn nil, errors.WithContext(errors.Wrapf(err, \"invalid DoFn\"), \"constructing DoFn\")\n+\t}\n+\n+\tif mainKv {\n+\t\treturn AsDoFn(ret, kvInNum)\n+\t} else {\n+\t\treturn AsDoFn(ret, singleInNum)\n+\t}\n+}\n+\n+// AsDoFn converts a Fn to a DoFn, if possible. numMainIn specifies how many\n+// main inputs are expected in the DoFn's method signatures. Valid values are\n+// -1 (unknown), 1 (single elements), or 2 (KVs). If the value is unknown then\n+// validation is done by best effort and may miss some edge cases.\n+func AsDoFn(fn *Fn, numMainIn int) (*DoFn, error) {\n \taddContext := func(err error, fn *Fn) error {\n \t\treturn errors.WithContextf(err, \"graph.AsDoFn: for Fn named %v\", fn.Name())\n \t}\n \n+\t// Validate numMainIn. This check should match this method's comment.\n+\tif numMainIn != unknownInNum &&\n+\t\tnumMainIn != singleInNum &&\n+\t\tnumMainIn != kvInNum {\n+\t\terr := errors.Errorf(\"invalid number of main inputs given. \"+\n+\t\t\t\"Got: %v, Want: One of the following: %v\",\n+\t\t\tprocessElementName, []int{unknownInNum, singleInNum, kvInNum})\n+\t\treturn nil, addContext(err, fn)\n+\t}", "originalCommit": "74edc3a6bf0e38f3d166287d4511027330efe772", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA4OTQzMg==", "url": "https://github.com/apache/beam/pull/10991#discussion_r388089432", "bodyText": "I like that much better, done.", "author": "youngoli", "createdAt": "2020-03-05T05:49:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5MzYyMA=="}], "type": "inlineReview"}, {"oid": "fc131c2f2486fb8a5b31a12cd140f048c3e374d8", "url": "https://github.com/apache/beam/commit/fc131c2f2486fb8a5b31a12cd140f048c3e374d8", "message": "[BEAM-3301] Adjust NewDoFn interface to take variadic options.\n\nA bit of fixup to make NewDoFn a cleaner interface. Gets rid of\nNewDoFnKv and replaces that functionality with variadic options.", "committedDate": "2020-03-05T05:46:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODM4NjA0NQ==", "url": "https://github.com/apache/beam/pull/10991#discussion_r388386045", "bodyText": "I'm wary about exporting these constants.\nFor one, they're untyped constants, so they're functionally the numbers themselves.\nOtherwise the \"right\" go way to expose them so they have meaning would be to have an unexported type so users can't define their own, and then define the constants.\ntype mainInputs int32\n\nconst (\n  MainUnknown mainInputs = -1\n  MainSingle mainInputs = 1\n  MainKV mainInputs = 2\n)\n\nThen any functional option configuration method can accept them to have type safe, pre-validated input numbers.\nfunc NumInputs(mi mainInputs) Option {\n  return func(c *config) {\n     c.numMainIn = mi\n  }\n}\n\nThis then saves needing to have a validation error, since package users can't define their own mainInputs.\nAnother alternative is to do away with the exported constants altogether, keep the validation, but simply document that valid inputs are 1 and 2 for singletons and KVs respectively. Either is preferable to the current approach.\nLets not lose sight that the purpose here is to pass a hint down to make the DoFn parameters easier to analyse. Windows and EventTimes are propagated with the main input, but don't \"count\" since they are easily detectable by type.", "author": "lostluck", "createdAt": "2020-03-05T15:54:39Z", "path": "sdks/go/pkg/beam/core/graph/fn.go", "diffHunk": "@@ -209,21 +209,74 @@ func (f *DoFn) RestrictionT() *reflect.Type {\n // a KV or not based on the other signatures (unless we're more loose about which\n // sideinputs are present). Bind should respect that.\n \n+// The following constants prefixed with \"Main\" represent possible numbers of", "originalCommit": "fc131c2f2486fb8a5b31a12cd140f048c3e374d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYwODkyMw==", "url": "https://github.com/apache/beam/pull/10991#discussion_r388608923", "bodyText": "I definitely like those options better. Went with the unexported constant type, since it makes the code more self-documenting as opposed to raw numbers. Also removed the validation check on that parameter, like you suggested.", "author": "youngoli", "createdAt": "2020-03-05T22:40:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODM4NjA0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQyNDMyOQ==", "url": "https://github.com/apache/beam/pull/10991#discussion_r388424329", "bodyText": "Consider if it is necessary to have an unknown constant exported at all? Even in the unexported type version of this code, Unknown a side effect of not passing the NumMainInput hint, rather than something a user should explicitly set.", "author": "lostluck", "createdAt": "2020-03-05T16:51:07Z", "path": "sdks/go/pkg/beam/core/graph/fn.go", "diffHunk": "@@ -209,21 +209,74 @@ func (f *DoFn) RestrictionT() *reflect.Type {\n // a KV or not based on the other signatures (unless we're more loose about which\n // sideinputs are present). Bind should respect that.\n \n+// The following constants prefixed with \"Main\" represent possible numbers of\n+// DoFn main inputs for DoFn construction and validation. Any value not defined\n+// here is an invalid number of main inputs.\n+const (\n+\tMainUnknown = -1 // The number of main inputs is unknown for DoFn validation.", "originalCommit": "fc131c2f2486fb8a5b31a12cd140f048c3e374d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYwOTkxNA==", "url": "https://github.com/apache/beam/pull/10991#discussion_r388609914", "bodyText": "I'm leaving it exported only because AsDoFn is currently exported and takes one of these constants as an input. Making this unexported would make it impossible to call AsDoFn with the existing behavior (unknown num. of inputs).", "author": "youngoli", "createdAt": "2020-03-05T22:43:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQyNDMyOQ=="}], "type": "inlineReview"}, {"oid": "a8e5284228b007ee22009f411567e5297e490710", "url": "https://github.com/apache/beam/commit/a8e5284228b007ee22009f411567e5297e490710", "message": "[BEAM-3301] Fixup main inputs constants.\n\nAdding a type representing the constants, to prevent them from being\nmisused. This also makes the validation check on them obsolete.", "committedDate": "2020-03-05T22:38:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc2NjM0NA==", "url": "https://github.com/apache/beam/pull/10991#discussion_r391766344", "bodyText": "Not related to this PR but why?", "author": "lukecwik", "createdAt": "2020-03-12T17:07:53Z", "path": "sdks/go/pkg/beam/core/graph/fn.go", "diffHunk": "@@ -239,52 +279,50 @@ func AsDoFn(fn *Fn) (*DoFn, error) {\n \t\treturn nil, addContext(err, fn)\n \t}\n \n-\t// Start validating DoFn. First, check that ProcessElement has a main input.\n+\t// Validate ProcessElement has correct number of main inputs (as indicated by\n+\t// numMainIn), and that main inputs are before side inputs.\n \tprocessFn := fn.methods[processElementName]\n-\tpos, num, ok := processFn.Inputs()\n-\tif ok {\n-\t\tfirst := processFn.Param[pos].Kind\n-\t\tif first != funcx.FnValue {\n-\t\t\terr := errors.New(\"side input parameters must follow main input parameter\")\n-\t\t\terr = errors.SetTopLevelMsgf(err,\n-\t\t\t\t\"Method %v of DoFns should always have a main input before side inputs, \"+\n-\t\t\t\t\t\"but it has side inputs (as Iters or ReIters) first in DoFn %v.\",\n-\t\t\t\tprocessElementName, fn.Name())\n-\t\t\terr = errors.WithContextf(err, \"method %v\", processElementName)\n-\t\t\treturn nil, addContext(err, fn)\n-\t\t}\n+\tif err := validateMainInputs(fn, processFn, processElementName, numMainIn); err != nil {\n+\t\treturn nil, addContext(err, fn)\n+\t}\n+\n+\t// If numMainIn is unknown, we can try inferring it from the second input in ProcessElement.\n+\t// If there is none, or it's not a FnValue type, then we can safely infer that there's only\n+\t// one main input.\n+\tpos, num, _ := processFn.Inputs()\n+\tif numMainIn == MainUnknown && (num == 1 || processFn.Param[pos+1].Kind != funcx.FnValue) {\n+\t\tnumMainIn = MainSingle\n \t}\n \n \t// If the ProcessElement function includes side inputs or emit functions those must also be", "originalCommit": "a8e5284228b007ee22009f411567e5297e490710", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk1ODI2Ng==", "url": "https://github.com/apache/beam/pull/10991#discussion_r391958266", "bodyText": "It's part of the API for start/finishBundle. I don't remember why it's done that way though. lostluck@ might be able to answer why when he gets back.\nThere might be room to make the side inputs/emits in start/finishBundle optional, but I believe right now it's mandatory (if we don't catch and throw an error here, it'll just break later on in translation or execution or something).", "author": "youngoli", "createdAt": "2020-03-12T23:32:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc2NjM0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM4MjIwOQ==", "url": "https://github.com/apache/beam/pull/10991#discussion_r393382209", "bodyText": "At most relaxed we'd be able to either not require them at all if none are used, or isolate them by their types. All instances of a given side input or emit with the same type would need to be listed at once, since otherwise we have no way to distinguish them except by position.  Permitting Nothing to be set would be the most convenient, or permitting only the Side Inputs and not requireing the Emits.\nFor now though, it's better to be more strict now and relax later, since the inverse is impossible, and such variety is harder to maintain if unnecessary.", "author": "lostluck", "createdAt": "2020-03-17T00:29:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc2NjM0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc3MTcxOQ==", "url": "https://github.com/apache/beam/pull/10991#discussion_r391771719", "bodyText": "Wouldn't it make sense to infer the number of inputs before validateMainInputs?", "author": "lukecwik", "createdAt": "2020-03-12T17:16:43Z", "path": "sdks/go/pkg/beam/core/graph/fn.go", "diffHunk": "@@ -239,52 +279,50 @@ func AsDoFn(fn *Fn) (*DoFn, error) {\n \t\treturn nil, addContext(err, fn)\n \t}\n \n-\t// Start validating DoFn. First, check that ProcessElement has a main input.\n+\t// Validate ProcessElement has correct number of main inputs (as indicated by\n+\t// numMainIn), and that main inputs are before side inputs.\n \tprocessFn := fn.methods[processElementName]\n-\tpos, num, ok := processFn.Inputs()\n-\tif ok {\n-\t\tfirst := processFn.Param[pos].Kind\n-\t\tif first != funcx.FnValue {\n-\t\t\terr := errors.New(\"side input parameters must follow main input parameter\")\n-\t\t\terr = errors.SetTopLevelMsgf(err,\n-\t\t\t\t\"Method %v of DoFns should always have a main input before side inputs, \"+\n-\t\t\t\t\t\"but it has side inputs (as Iters or ReIters) first in DoFn %v.\",\n-\t\t\t\tprocessElementName, fn.Name())\n-\t\t\terr = errors.WithContextf(err, \"method %v\", processElementName)\n-\t\t\treturn nil, addContext(err, fn)\n-\t\t}\n+\tif err := validateMainInputs(fn, processFn, processElementName, numMainIn); err != nil {\n+\t\treturn nil, addContext(err, fn)\n+\t}\n+\n+\t// If numMainIn is unknown, we can try inferring it from the second input in ProcessElement.\n+\t// If there is none, or it's not a FnValue type, then we can safely infer that there's only\n+\t// one main input.\n+\tpos, num, _ := processFn.Inputs()\n+\tif numMainIn == MainUnknown && (num == 1 || processFn.Param[pos+1].Kind != funcx.FnValue) {", "originalCommit": "a8e5284228b007ee22009f411567e5297e490710", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk1NjkwNw==", "url": "https://github.com/apache/beam/pull/10991#discussion_r391956907", "bodyText": "validateMainInputs performs error checks we need to do before we can infer # of main inputs (stuff like making sure we have at least 1 input present). So moving this before validateMainInputs would just mean moving those error checks back above the inferring and nothing really changes.", "author": "youngoli", "createdAt": "2020-03-12T23:27:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc3MTcxOQ=="}], "type": "inlineReview"}]}