{"pr_number": 10885, "pr_title": "[BEAM-9085] Fix performance regression in SyntheticSource", "pr_createdAt": "2020-02-18T16:00:08Z", "pr_url": "https://github.com/apache/beam/pull/10885", "timeline": [{"oid": "6f36497ce8469cdcb23e2e62fe9006ccacf7b18b", "url": "https://github.com/apache/beam/commit/6f36497ce8469cdcb23e2e62fe9006ccacf7b18b", "message": "[BEAM-9085] Fix performance regression in SyntheticSource\n\nBeam was using `numpy.random.RandomState` during generation of Synthetic input, which, starting from NumPy 1.17, is considered as a legacy generator. This caused the slowdown on Python 3. The solution was using `random` module instead of Numpy.", "committedDate": "2020-02-18T14:54:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg0NTk1NQ==", "url": "https://github.com/apache/beam/pull/10885#discussion_r380845955", "bodyText": "Let's use range instead of xrange, and adjust the import accordingly. We try to use idiomatic py3 whenever possible in Beam.", "author": "tvalentyn", "createdAt": "2020-02-18T18:10:45Z", "path": "sdks/python/apache_beam/testing/synthetic_pipeline.py", "diffHunk": "@@ -415,19 +418,24 @@ def get_range_tracker(self, start_position, stop_position):\n       tracker = range_trackers.UnsplittableRangeTracker(tracker)\n     return tracker\n \n+  @staticmethod\n+  def random_bytes(length):\n+    \"\"\"Return random bytes.\"\"\"\n+    return b''.join(\n+        (struct.pack('B', random.getrandbits(8)) for _ in xrange(length)))", "originalCommit": "6f36497ce8469cdcb23e2e62fe9006ccacf7b18b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE2MDA4NQ==", "url": "https://github.com/apache/beam/pull/10885#discussion_r381160085", "bodyText": "Alright. I was a bit concerned about performance of range on Python 2, but the parameter is almost always small so the impact is negligible.", "author": "kamilwu", "createdAt": "2020-02-19T09:11:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg0NTk1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQzMTUzMg==", "url": "https://github.com/apache/beam/pull/10885#discussion_r381431532", "bodyText": "We can add from builtins import range to use py3 implementation of range on py2.", "author": "tvalentyn", "createdAt": "2020-02-19T17:33:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg0NTk1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg1NzM3MA==", "url": "https://github.com/apache/beam/pull/10885#discussion_r380857370", "bodyText": "How about we instantiate random.Random() instead of modifying the global state? This is important if we execute this generator concurrently. Not sure if we do.", "author": "tvalentyn", "createdAt": "2020-02-18T18:33:08Z", "path": "sdks/python/apache_beam/testing/synthetic_pipeline.py", "diffHunk": "@@ -415,19 +418,24 @@ def get_range_tracker(self, start_position, stop_position):\n       tracker = range_trackers.UnsplittableRangeTracker(tracker)\n     return tracker\n \n+  @staticmethod\n+  def random_bytes(length):\n+    \"\"\"Return random bytes.\"\"\"\n+    return b''.join(\n+        (struct.pack('B', random.getrandbits(8)) for _ in xrange(length)))\n+\n   def _gen_kv_pair(self, index):\n-    r = np.random.RandomState(index)\n-    rand = r.random_sample()\n+    random.seed(index)", "originalCommit": "6f36497ce8469cdcb23e2e62fe9006ccacf7b18b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI4NTY3NQ==", "url": "https://github.com/apache/beam/pull/10885#discussion_r381285675", "bodyText": "I'm pretty sure it's possible while having multiple range trackers and multiple workers.\nI wrote a fix and ran the benchmark. The performance is a bit worse:\nPython 2: 7.77728295326 (was 6.37386107445)\nPython 3: 6.888783617999998 (was 5.6981477510000005)\n\nHowever, we could create a cache for generators (instances of random.Random). Then we could create a generator for each range tracker, not for each index. This reduces the offset of instantiating multiple generators:\nPython 2: 6.42752218246\nPython 3: 5.789953311999998\n\nWDYT?", "author": "kamilwu", "createdAt": "2020-02-19T13:23:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDg1NzM3MA=="}], "type": "inlineReview"}, {"oid": "1ab835cf6edcb77bf5f40101d261d78f098af4c9", "url": "https://github.com/apache/beam/commit/1ab835cf6edcb77bf5f40101d261d78f098af4c9", "message": "FIX: use range instead of xrange", "committedDate": "2020-02-19T09:11:46Z", "type": "commit"}, {"oid": "6ce7e623360b3a8834d319a02b5f27e6a7df324a", "url": "https://github.com/apache/beam/commit/6ce7e623360b3a8834d319a02b5f27e6a7df324a", "message": "FIX: Instantiate unique random number generator for each range tracker", "committedDate": "2020-02-19T13:28:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ2OTU0Mg==", "url": "https://github.com/apache/beam/pull/10885#discussion_r381469542", "bodyText": "I don't see a difference in performance if we instantiate the generator in read, but don't use the cache. Do we need the cache?", "author": "tvalentyn", "createdAt": "2020-02-19T18:41:38Z", "path": "sdks/python/apache_beam/testing/synthetic_pipeline.py", "diffHunk": "@@ -418,29 +420,32 @@ def get_range_tracker(self, start_position, stop_position):\n     return tracker\n \n   @staticmethod\n-  def random_bytes(length):\n+  def random_bytes(length, generator):\n     \"\"\"Return random bytes.\"\"\"\n     return b''.join(\n-        (struct.pack('B', random.getrandbits(8)) for _ in range(length)))\n+        (struct.pack('B', generator.getrandbits(8)) for _ in range(length)))\n \n-  def _gen_kv_pair(self, index):\n-    random.seed(index)\n-    rand = random.random()\n+  def _gen_kv_pair(self, generator, index):\n+    generator.seed(index)\n+    rand = generator.random()\n \n     # Determines whether to generate hot key or not.\n     if rand < self._hot_key_fraction:\n       # Generate hot key.\n       # An integer is randomly selected from the range [0, numHotKeys-1]\n       # with equal probability.\n-      random.seed(index % self._num_hot_keys)\n-    return self.random_bytes(self._key_size), self.random_bytes(\n-      self._value_size)\n+      generator.seed(index % self._num_hot_keys)\n+    return self.random_bytes(self._key_size, generator), self.random_bytes(\n+      self._value_size, generator)\n \n   def read(self, range_tracker):\n     index = range_tracker.start_position()\n+    # Get an instance of pseudo-random number generator\n+    generator = self._generators[(", "originalCommit": "6ce7e623360b3a8834d319a02b5f27e6a7df324a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTkzNjcxMQ==", "url": "https://github.com/apache/beam/pull/10885#discussion_r381936711", "bodyText": "My bad, it seems the cache isn't really needed. It could be helpful if read was called many, many times with the same range tracker, but I don't think this is true. Thanks.", "author": "kamilwu", "createdAt": "2020-02-20T11:17:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ2OTU0Mg=="}], "type": "inlineReview"}, {"oid": "9723ffb67ea64cbf01751ff9b8a15b899a151787", "url": "https://github.com/apache/beam/commit/9723ffb67ea64cbf01751ff9b8a15b899a151787", "message": "FIX: Use py3 implementation of range on py2", "committedDate": "2020-02-20T09:38:17Z", "type": "commit"}, {"oid": "fcc1c286c30ad4df77042f1eb4b98697e8435e50", "url": "https://github.com/apache/beam/commit/fcc1c286c30ad4df77042f1eb4b98697e8435e50", "message": "FIX: Instantiate the generator inside `read` without caching", "committedDate": "2020-02-20T12:23:31Z", "type": "commit"}]}