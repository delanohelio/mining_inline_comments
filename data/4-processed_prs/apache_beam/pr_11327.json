{"pr_number": 11327, "pr_title": "[BEAM-9642] Add SDF execution units.", "pr_createdAt": "2020-04-06T22:27:40Z", "pr_url": "https://github.com/apache/beam/pull/11327", "timeline": [{"oid": "8741c0f47a5bf7e7663f929ebf86acf679e0f7d4", "url": "https://github.com/apache/beam/commit/8741c0f47a5bf7e7663f929ebf86acf679e0f7d4", "message": "[BEAM-9642] Add SDF execution units.\n\nAdds the three units needed to execute expanded SDF transforms. Note\nthat this is still missing a unit to execute unexpanded SDF transforms,\nand that these units are not currently created in graph translation,\nso this does not actually enable SDFs to be used just yet.", "committedDate": "2020-04-06T22:25:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA5NzcxMg==", "url": "https://github.com/apache/beam/pull/11327#discussion_r405097712", "bodyText": "consider not exporting this, as it's helper function for ProcessElement for the SDF components. Note that since they're in the same package, the unexported methods could be used.\nRegardless of if it's exported or not, please add a godoc comment why this needs to be separated out.", "author": "lostluck", "createdAt": "2020-04-07T20:38:58Z", "path": "sdks/go/pkg/beam/core/runtime/exec/pardo.go", "diffHunk": "@@ -120,11 +120,17 @@ func (n *ParDo) ProcessElement(ctx context.Context, elm *FullValue, values ...Re\n \tif n.status != Active {\n \t\treturn errors.Errorf(\"invalid status for pardo %v: %v, want Active\", n.UID, n.status)\n \t}\n+\n+\treturn n.ProcessMainInput(&MainInput{Key: *elm, Values: values})\n+}\n+\n+func (n *ParDo) ProcessMainInput(mainIn *MainInput) error {", "originalCommit": "8741c0f47a5bf7e7663f929ebf86acf679e0f7d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgyNzM3Mg==", "url": "https://github.com/apache/beam/pull/11327#discussion_r407827372", "bodyText": "Done.", "author": "youngoli", "createdAt": "2020-04-14T02:23:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA5NzcxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM5ODE4OQ==", "url": "https://github.com/apache/beam/pull/11327#discussion_r406398189", "bodyText": "Is it possible for SplitAndSizeRestrictions or PairWithRestriction to output to more than one other transform? Why have a slice?", "author": "lostluck", "createdAt": "2020-04-09T18:32:12Z", "path": "sdks/go/pkg/beam/core/runtime/exec/sdf.go", "diffHunk": "@@ -0,0 +1,297 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package exec\n+\n+import (\n+\t\"context\"\n+\t\"fmt\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph\"\n+\t\"path\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n+)\n+\n+// PairWithRestriction is an executor for the expanded SDF step of the same\n+// name. This is the first step of an expanded SDF. It pairs each main input\n+// element with a restriction via the SDF's associated sdf.RestrictionProvider.\n+// This step is followed by SplitAndSizeRestrictions.\n+type PairWithRestriction struct {\n+\tUID UnitID\n+\tFn  *graph.DoFn\n+\tOut []Node\n+\n+\tinv *cirInvoker\n+}\n+\n+// ID returns the UnitID for this unit.\n+func (n *PairWithRestriction) ID() UnitID {\n+\treturn n.UID\n+}\n+\n+// Up performs one-time setup for this executor.\n+func (n *PairWithRestriction) Up(ctx context.Context) error {\n+\tfn := (*graph.SplittableDoFn)(n.Fn).CreateInitialRestrictionFn()\n+\tvar err error\n+\tif n.inv, err = newCreateInitialRestrictionInvoker(fn); err != nil {\n+\t\treturn errors.WithContextf(err, \"PairWithRestriction transform with UID %v\", n.ID())\n+\t}\n+\treturn nil\n+}\n+\n+// StartBundle currently does nothing.\n+func (n *PairWithRestriction) StartBundle(ctx context.Context, id string, data DataContext) error {\n+\treturn n.Out[0].StartBundle(ctx, id, data)\n+}\n+\n+// ProcessElement expects elm to be the main input to the ParDo. See\n+// exec.FullValue for more details on the expected input.\n+//\n+// ProcessElement creates an initial restriction representing the entire input.\n+// The output is in the structure <elem, restriction>, where elem is the main\n+// input originally passed in (i.e. the parameter elm). Windows and Timestamp\n+// are copied to the outer *FullValue. They still remain within the original\n+// element as well, but will no longer be used.\n+//\n+// Output Diagram:\n+//\n+//   *FullValue {\n+//     Elm: *FullValue (original input)\n+//     Elm2: Restriction\n+//     Windows\n+//     Timestamps\n+//   }\n+func (n *PairWithRestriction) ProcessElement(ctx context.Context, elm *FullValue, values ...ReStream) error {\n+\trest := n.inv.Invoke(elm)\n+\toutput := FullValue{Elm: elm, Elm2: rest, Timestamp: elm.Timestamp, Windows: elm.Windows}\n+\n+\treturn n.Out[0].ProcessElement(ctx, &output, values...)\n+}\n+\n+// FinishBundle does some teardown for the end of the bundle.\n+func (n *PairWithRestriction) FinishBundle(ctx context.Context) error {\n+\tn.inv.Reset()\n+\treturn n.Out[0].FinishBundle(ctx)\n+}\n+\n+// Down currently does nothing.\n+func (n *PairWithRestriction) Down(ctx context.Context) error {\n+\treturn nil\n+}\n+\n+// String outputs a human-readable description of this transform.\n+func (n *PairWithRestriction) String() string {\n+\treturn fmt.Sprintf(\"SDF.PairWithRestriction[%v] Out:%v\", path.Base(n.Fn.Name()), IDs(n.Out...))\n+}\n+\n+// SplitAndSizeRestrictions is an executor for the expanded SDF step of the\n+// same name. It is the second step of the expanded SDF, occuring after\n+// CreateInitialRestriction. It performs initial splits on the initial restrictions\n+// and adds sizing information, producing one or more output elements per input\n+// element. This step is followed by ProcessSizedElementsAndRestrictions.\n+type SplitAndSizeRestrictions struct {\n+\tUID UnitID\n+\tFn  *graph.DoFn\n+\tOut []Node", "originalCommit": "8741c0f47a5bf7e7663f929ebf86acf679e0f7d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgyNzg3Mw==", "url": "https://github.com/apache/beam/pull/11327#discussion_r407827873", "bodyText": "This was me copying from the old implementation, which had all these nodes wrapping ParDos. No, these shouldn't be outputting to more than one transform, so I'll change this.", "author": "youngoli", "createdAt": "2020-04-14T02:25:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM5ODE4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQwMDEwNA==", "url": "https://github.com/apache/beam/pull/11327#discussion_r406400104", "bodyText": "The empty return isn't necessary and can be elided.", "author": "lostluck", "createdAt": "2020-04-09T18:35:33Z", "path": "sdks/go/pkg/beam/core/runtime/exec/sdf_invokers_test.go", "diffHunk": "@@ -273,7 +287,9 @@ func (fn *KvSdf) CreateTracker(rest Restriction) *RTracker {\n \treturn &RTracker{rest, 2}\n }\n \n-// ProcessElement is a no-op, it's only included to pass validation.\n-func (fn *KvSdf) ProcessElement(*RTracker, int, int) int {\n-\treturn 0\n+// ProcessElement emits two ints. The first is the first input (key) +\n+// RTracker.Rest.Val. The second is the second input (value) + RTracker.Val.\n+func (fn *KvSdf) ProcessElement(rt *RTracker, i1 int, i2 int, emit func(int, int)) {\n+\temit(i1+rt.Rest.Val, i2+rt.Val)\n+\treturn", "originalCommit": "8741c0f47a5bf7e7663f929ebf86acf679e0f7d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgyODk2MA==", "url": "https://github.com/apache/beam/pull/11327#discussion_r407828960", "bodyText": "Done.", "author": "youngoli", "createdAt": "2020-04-14T02:29:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQwMDEwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQwMjQ0Ng==", "url": "https://github.com/apache/beam/pull/11327#discussion_r406402446", "bodyText": "Why write a new one rather than re-use CaptureNode? https://github.com/apache/beam/blob/master/sdks/go/pkg/beam/core/runtime/exec/unit_test.go#L28", "author": "lostluck", "createdAt": "2020-04-09T18:39:33Z", "path": "sdks/go/pkg/beam/core/runtime/exec/sdf_test.go", "diffHunk": "@@ -0,0 +1,408 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package exec\n+\n+import (\n+\t\"context\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/window\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/typex\"\n+\t\"github.com/google/go-cmp/cmp\"\n+\t\"testing\"\n+)\n+\n+// testTimestamp is a constant used to check that timestamps are retained.\n+const testTimestamp = 15\n+\n+// testWindow is a constant used to check that windows are retained\n+var testWindows = []typex.Window{window.IntervalWindow{Start: 10, End: 20}}\n+\n+// TestSdfNodes verifies that the various SDF nodes fulfill each of their\n+// described contracts, that they each successfully invoke any SDF methods\n+// needed, and that they preserve timestamps and windows correctly.\n+func TestSdfNodes(t *testing.T) {\n+\t// Setup. The DoFns created below are defined in sdf_invokers_test.go and\n+\t// have testable behavior to confirm that they got correctly invoked.\n+\t// Without knowing the expected behavior of these DoFns, the desired outputs\n+\t// in the unit tests below will not make much sense.\n+\tdfn, err := graph.NewDoFn(&Sdf{}, graph.NumMainInputs(graph.MainSingle))\n+\tif err != nil {\n+\t\tt.Fatalf(\"invalid function: %v\", err)\n+\t}\n+\tkvdfn, err := graph.NewDoFn(&KvSdf{}, graph.NumMainInputs(graph.MainKv))\n+\tif err != nil {\n+\t\tt.Fatalf(\"invalid function: %v\", err)\n+\t}\n+\n+\t// Validate PairWithRestriction matches its contract and properly invokes\n+\t// SDF method CreateInitialRestriction.\n+\tt.Run(\"PairWithRestriction\", func(t *testing.T) {\n+\t\ttests := []struct {\n+\t\t\tname string\n+\t\t\tfn   *graph.DoFn\n+\t\t\tin   *FullValue\n+\t\t\twant *FullValue\n+\t\t}{\n+\t\t\t{\n+\t\t\t\tname: \"SingleElem\",\n+\t\t\t\tfn:   dfn,\n+\t\t\t\tin: &FullValue{\n+\t\t\t\t\tElm:       5,\n+\t\t\t\t\tElm2:      nil,\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t\twant: &FullValue{\n+\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\tElm:       5,\n+\t\t\t\t\t\tElm2:      nil,\n+\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t},\n+\t\t\t\t\tElm2:      Restriction{5},\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tname: \"KvElem\",\n+\t\t\t\tfn:   kvdfn,\n+\t\t\t\tin: &FullValue{\n+\t\t\t\t\tElm:       5,\n+\t\t\t\t\tElm2:      2,\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t\twant: &FullValue{\n+\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\tElm:       5,\n+\t\t\t\t\t\tElm2:      2,\n+\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t},\n+\t\t\t\t\tElm2:      Restriction{7},\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t}\n+\t\tfor _, test := range tests {\n+\t\t\ttest := test\n+\t\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\t\tctx := context.Background()\n+\t\t\t\tfake := &FakeNode{}\n+\t\t\t\tnode := PairWithRestriction{UID: 0, Fn: test.fn, Out: []Node{fake}}\n+\n+\t\t\t\tif err := node.Up(ctx); err != nil {\n+\t\t\t\t\tt.Fatalf(\"Up failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif err := node.StartBundle(ctx, \"bundle_id\", DataContext{}); err != nil {\n+\t\t\t\t\tt.Fatalf(\"StartBundle failed: %v\", err)\n+\t\t\t\t}\n+\n+\t\t\t\tif err := node.ProcessElement(ctx, test.in); err != nil {\n+\t\t\t\t\tt.Fatalf(\"ProcessElement failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tgot := fake.Vals[0]\n+\t\t\t\tif !cmp.Equal(got, test.want) {\n+\t\t\t\t\tt.Errorf(\"ProcessElement(%v) has incorrect output: got: %v, want: %v\",\n+\t\t\t\t\t\ttest.in, got, test.want)\n+\t\t\t\t}\n+\t\t\t\tif err := node.FinishBundle(ctx); err != nil {\n+\t\t\t\t\tt.Fatalf(\"FinishBundle failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif err := node.Down(ctx); err != nil {\n+\t\t\t\t\tt.Fatalf(\"Down failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t})\n+\t\t}\n+\t})\n+\n+\t// Validate SplitAndSizeRestrictions matches its contract and properly\n+\t// invokes SDF methods SplitRestriction and RestrictionSize.\n+\tt.Run(\"SplitAndSizeRestrictions\", func(t *testing.T) {\n+\t\ttests := []struct {\n+\t\t\tname string\n+\t\t\tfn   *graph.DoFn\n+\t\t\tin   *FullValue\n+\t\t\twant []*FullValue\n+\t\t}{\n+\t\t\t{\n+\t\t\t\tname: \"SingleElem\",\n+\t\t\t\tfn:   dfn,\n+\t\t\t\tin: &FullValue{\n+\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\tElm:       2,\n+\t\t\t\t\t\tElm2:      nil,\n+\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t},\n+\t\t\t\t\tElm2:      Restriction{5},\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t\twant: []*FullValue{\n+\t\t\t\t\t{\n+\t\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\t\t\tElm:       2,\n+\t\t\t\t\t\t\t\tElm2:      nil,\n+\t\t\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\tElm2: Restriction{7},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tElm2:      9.0,\n+\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t},\n+\t\t\t\t\t{\n+\t\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\t\t\tElm:       2,\n+\t\t\t\t\t\t\t\tElm2:      nil,\n+\t\t\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\tElm2: Restriction{8},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tElm2:      10.0,\n+\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tname: \"KvElem\",\n+\t\t\t\tfn:   kvdfn,\n+\t\t\t\tin: &FullValue{\n+\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\tElm:       2,\n+\t\t\t\t\t\tElm2:      5,\n+\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t},\n+\t\t\t\t\tElm2:      Restriction{3},\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t\twant: []*FullValue{\n+\t\t\t\t\t{\n+\t\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\t\t\tElm:       2,\n+\t\t\t\t\t\t\t\tElm2:      5,\n+\t\t\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\tElm2: Restriction{5},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tElm2:      12.0,\n+\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t},\n+\t\t\t\t\t{\n+\t\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\t\t\tElm:       2,\n+\t\t\t\t\t\t\t\tElm2:      5,\n+\t\t\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\tElm2: Restriction{8},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tElm2:      15.0,\n+\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t}\n+\t\tfor _, test := range tests {\n+\t\t\ttest := test\n+\t\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\t\tctx := context.Background()\n+\t\t\t\tfake := &FakeNode{}\n+\t\t\t\tnode := SplitAndSizeRestrictions{UID: 0, Fn: test.fn, Out: []Node{fake}}\n+\n+\t\t\t\tif err := node.Up(ctx); err != nil {\n+\t\t\t\t\tt.Fatalf(\"Up failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif err := node.StartBundle(ctx, \"bundle_id\", DataContext{}); err != nil {\n+\t\t\t\t\tt.Fatalf(\"StartBundle failed: %v\", err)\n+\t\t\t\t}\n+\n+\t\t\t\tif err := node.ProcessElement(ctx, test.in); err != nil {\n+\t\t\t\t\tt.Fatalf(\"ProcessElement failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tfor i, got := range fake.Vals {\n+\t\t\t\t\tif !cmp.Equal(got, test.want[i]) {\n+\t\t\t\t\t\tt.Errorf(\"ProcessElement(%v) has incorrect output %v: got: %v, want: %v\",\n+\t\t\t\t\t\t\ttest.in, i, got, test.want)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif err := node.FinishBundle(ctx); err != nil {\n+\t\t\t\t\tt.Fatalf(\"FinishBundle failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif err := node.Down(ctx); err != nil {\n+\t\t\t\t\tt.Fatalf(\"Down failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t})\n+\t\t}\n+\t})\n+\n+\t// Validate ProcessSizedElementsAndRestrictions matches its contract and\n+\t// properly invokes SDF methods CreateTracker and ProcessElement.\n+\tt.Run(\"ProcessSizedElementsAndRestrictions\", func(t *testing.T) {\n+\t\ttests := []struct {\n+\t\t\tname string\n+\t\t\tfn   *graph.DoFn\n+\t\t\tin   *FullValue\n+\t\t\twant *FullValue\n+\t\t}{\n+\t\t\t{\n+\t\t\t\tname: \"SingleElem\",\n+\t\t\t\tfn:   dfn,\n+\t\t\t\tin: &FullValue{\n+\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\t\tElm:       3,\n+\t\t\t\t\t\t\tElm2:      nil,\n+\t\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tElm2: Restriction{5},\n+\t\t\t\t\t},\n+\t\t\t\t\tElm2:      8.0,\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t\twant: &FullValue{\n+\t\t\t\t\tElm:       8,\n+\t\t\t\t\tElm2:      4,\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tname: \"KvElem\",\n+\t\t\t\tfn:   kvdfn,\n+\t\t\t\tin: &FullValue{\n+\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\t\tElm:       3,\n+\t\t\t\t\t\t\tElm2:      10,\n+\t\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tElm2: Restriction{5},\n+\t\t\t\t\t},\n+\t\t\t\t\tElm2:      18.0,\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t\twant: &FullValue{\n+\t\t\t\t\tElm:       8,\n+\t\t\t\t\tElm2:      12,\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t}\n+\t\tfor _, test := range tests {\n+\t\t\ttest := test\n+\t\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\t\tctx := context.Background()\n+\t\t\t\tfake := &FakeNode{}\n+\t\t\t\tn := &ParDo{UID: 0, Fn: test.fn, Out: []Node{fake}}\n+\t\t\t\tnode := ProcessSizedElementsAndRestrictions{PDo: n}\n+\n+\t\t\t\tif err := node.Up(ctx); err != nil {\n+\t\t\t\t\tt.Fatalf(\"Up failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif err := node.StartBundle(ctx, \"bundle_id\", DataContext{}); err != nil {\n+\t\t\t\t\tt.Fatalf(\"StartBundle failed: %v\", err)\n+\t\t\t\t}\n+\n+\t\t\t\tif err := node.ProcessElement(ctx, test.in); err != nil {\n+\t\t\t\t\tt.Fatalf(\"ProcessElement failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tgot := fake.Vals[0]\n+\t\t\t\tif !cmp.Equal(got, test.want) {\n+\t\t\t\t\tt.Errorf(\"ProcessElement(%v) has incorrect output: got: %v, want: %v\",\n+\t\t\t\t\t\ttest.in, got, test.want)\n+\t\t\t\t}\n+\t\t\t\tif err := node.FinishBundle(ctx); err != nil {\n+\t\t\t\t\tt.Fatalf(\"FinishBundle failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif err := node.Down(ctx); err != nil {\n+\t\t\t\t\tt.Fatalf(\"Down failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t})\n+\t\t}\n+\t})\n+}\n+\n+// TestSplitAndSizeRestrictions verifies that the SplitAndSizeRestrictions node\n+// both fulfills its contract and successfully invokes the accompanying SDF's\n+// SplitRestriction and RestrictionSize methods to do so.\n+func TestSplitAndSizeRestrictions(t *testing.T) {\n+}\n+\n+// TestProcessSizedElementsAndRestrictions verifies that the\n+// ProcessSizedElementsAndRestrictions node both fulfills its contract and\n+// successfully invokes the accompanying SDF's CreateTracker and ProcessElement\n+// methods to do so.\n+func TestProcessSizedElementsAndRestrictions(t *testing.T) {\n+}\n+\n+// FakeNode is used to capture the outputs of the node being tested by\n+// TestSdfNodes. FakeNode appends each element that it receives in its\n+// ProcessElement method to its Vals struct, which can then be read by the test.\n+type FakeNode struct {", "originalCommit": "8741c0f47a5bf7e7663f929ebf86acf679e0f7d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg0Mjc4MQ==", "url": "https://github.com/apache/beam/pull/11327#discussion_r407842781", "bodyText": "Didn't know that existed (or that whole file, really). Switched to it.", "author": "youngoli", "createdAt": "2020-04-14T03:20:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQwMjQ0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQwMzEwOQ==", "url": "https://github.com/apache/beam/pull/11327#discussion_r406403109", "bodyText": "Note, using the pointers in this case has the chance to break these tests if optimizations like FullValue allocation are added to these nodes. Better to copy the FullValue's fields by having plain FVs rather than *FV.", "author": "lostluck", "createdAt": "2020-04-09T18:40:49Z", "path": "sdks/go/pkg/beam/core/runtime/exec/sdf_test.go", "diffHunk": "@@ -0,0 +1,408 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package exec\n+\n+import (\n+\t\"context\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/window\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/typex\"\n+\t\"github.com/google/go-cmp/cmp\"\n+\t\"testing\"\n+)\n+\n+// testTimestamp is a constant used to check that timestamps are retained.\n+const testTimestamp = 15\n+\n+// testWindow is a constant used to check that windows are retained\n+var testWindows = []typex.Window{window.IntervalWindow{Start: 10, End: 20}}\n+\n+// TestSdfNodes verifies that the various SDF nodes fulfill each of their\n+// described contracts, that they each successfully invoke any SDF methods\n+// needed, and that they preserve timestamps and windows correctly.\n+func TestSdfNodes(t *testing.T) {\n+\t// Setup. The DoFns created below are defined in sdf_invokers_test.go and\n+\t// have testable behavior to confirm that they got correctly invoked.\n+\t// Without knowing the expected behavior of these DoFns, the desired outputs\n+\t// in the unit tests below will not make much sense.\n+\tdfn, err := graph.NewDoFn(&Sdf{}, graph.NumMainInputs(graph.MainSingle))\n+\tif err != nil {\n+\t\tt.Fatalf(\"invalid function: %v\", err)\n+\t}\n+\tkvdfn, err := graph.NewDoFn(&KvSdf{}, graph.NumMainInputs(graph.MainKv))\n+\tif err != nil {\n+\t\tt.Fatalf(\"invalid function: %v\", err)\n+\t}\n+\n+\t// Validate PairWithRestriction matches its contract and properly invokes\n+\t// SDF method CreateInitialRestriction.\n+\tt.Run(\"PairWithRestriction\", func(t *testing.T) {\n+\t\ttests := []struct {\n+\t\t\tname string\n+\t\t\tfn   *graph.DoFn\n+\t\t\tin   *FullValue\n+\t\t\twant *FullValue\n+\t\t}{\n+\t\t\t{\n+\t\t\t\tname: \"SingleElem\",\n+\t\t\t\tfn:   dfn,\n+\t\t\t\tin: &FullValue{\n+\t\t\t\t\tElm:       5,\n+\t\t\t\t\tElm2:      nil,\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t\twant: &FullValue{\n+\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\tElm:       5,\n+\t\t\t\t\t\tElm2:      nil,\n+\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t},\n+\t\t\t\t\tElm2:      Restriction{5},\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tname: \"KvElem\",\n+\t\t\t\tfn:   kvdfn,\n+\t\t\t\tin: &FullValue{\n+\t\t\t\t\tElm:       5,\n+\t\t\t\t\tElm2:      2,\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t\twant: &FullValue{\n+\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\tElm:       5,\n+\t\t\t\t\t\tElm2:      2,\n+\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t},\n+\t\t\t\t\tElm2:      Restriction{7},\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t}\n+\t\tfor _, test := range tests {\n+\t\t\ttest := test\n+\t\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\t\tctx := context.Background()\n+\t\t\t\tfake := &FakeNode{}\n+\t\t\t\tnode := PairWithRestriction{UID: 0, Fn: test.fn, Out: []Node{fake}}\n+\n+\t\t\t\tif err := node.Up(ctx); err != nil {\n+\t\t\t\t\tt.Fatalf(\"Up failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif err := node.StartBundle(ctx, \"bundle_id\", DataContext{}); err != nil {\n+\t\t\t\t\tt.Fatalf(\"StartBundle failed: %v\", err)\n+\t\t\t\t}\n+\n+\t\t\t\tif err := node.ProcessElement(ctx, test.in); err != nil {\n+\t\t\t\t\tt.Fatalf(\"ProcessElement failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tgot := fake.Vals[0]\n+\t\t\t\tif !cmp.Equal(got, test.want) {\n+\t\t\t\t\tt.Errorf(\"ProcessElement(%v) has incorrect output: got: %v, want: %v\",\n+\t\t\t\t\t\ttest.in, got, test.want)\n+\t\t\t\t}\n+\t\t\t\tif err := node.FinishBundle(ctx); err != nil {\n+\t\t\t\t\tt.Fatalf(\"FinishBundle failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif err := node.Down(ctx); err != nil {\n+\t\t\t\t\tt.Fatalf(\"Down failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t})\n+\t\t}\n+\t})\n+\n+\t// Validate SplitAndSizeRestrictions matches its contract and properly\n+\t// invokes SDF methods SplitRestriction and RestrictionSize.\n+\tt.Run(\"SplitAndSizeRestrictions\", func(t *testing.T) {\n+\t\ttests := []struct {\n+\t\t\tname string\n+\t\t\tfn   *graph.DoFn\n+\t\t\tin   *FullValue\n+\t\t\twant []*FullValue\n+\t\t}{\n+\t\t\t{\n+\t\t\t\tname: \"SingleElem\",\n+\t\t\t\tfn:   dfn,\n+\t\t\t\tin: &FullValue{\n+\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\tElm:       2,\n+\t\t\t\t\t\tElm2:      nil,\n+\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t},\n+\t\t\t\t\tElm2:      Restriction{5},\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t\twant: []*FullValue{\n+\t\t\t\t\t{\n+\t\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\t\t\tElm:       2,\n+\t\t\t\t\t\t\t\tElm2:      nil,\n+\t\t\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\tElm2: Restriction{7},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tElm2:      9.0,\n+\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t},\n+\t\t\t\t\t{\n+\t\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\t\t\tElm:       2,\n+\t\t\t\t\t\t\t\tElm2:      nil,\n+\t\t\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\tElm2: Restriction{8},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tElm2:      10.0,\n+\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tname: \"KvElem\",\n+\t\t\t\tfn:   kvdfn,\n+\t\t\t\tin: &FullValue{\n+\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\tElm:       2,\n+\t\t\t\t\t\tElm2:      5,\n+\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t},\n+\t\t\t\t\tElm2:      Restriction{3},\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t\twant: []*FullValue{\n+\t\t\t\t\t{\n+\t\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\t\t\tElm:       2,\n+\t\t\t\t\t\t\t\tElm2:      5,\n+\t\t\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\tElm2: Restriction{5},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tElm2:      12.0,\n+\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t},\n+\t\t\t\t\t{\n+\t\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\t\t\tElm:       2,\n+\t\t\t\t\t\t\t\tElm2:      5,\n+\t\t\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\tElm2: Restriction{8},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tElm2:      15.0,\n+\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t}\n+\t\tfor _, test := range tests {\n+\t\t\ttest := test\n+\t\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\t\tctx := context.Background()\n+\t\t\t\tfake := &FakeNode{}\n+\t\t\t\tnode := SplitAndSizeRestrictions{UID: 0, Fn: test.fn, Out: []Node{fake}}\n+\n+\t\t\t\tif err := node.Up(ctx); err != nil {\n+\t\t\t\t\tt.Fatalf(\"Up failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif err := node.StartBundle(ctx, \"bundle_id\", DataContext{}); err != nil {\n+\t\t\t\t\tt.Fatalf(\"StartBundle failed: %v\", err)\n+\t\t\t\t}\n+\n+\t\t\t\tif err := node.ProcessElement(ctx, test.in); err != nil {\n+\t\t\t\t\tt.Fatalf(\"ProcessElement failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tfor i, got := range fake.Vals {\n+\t\t\t\t\tif !cmp.Equal(got, test.want[i]) {\n+\t\t\t\t\t\tt.Errorf(\"ProcessElement(%v) has incorrect output %v: got: %v, want: %v\",\n+\t\t\t\t\t\t\ttest.in, i, got, test.want)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif err := node.FinishBundle(ctx); err != nil {\n+\t\t\t\t\tt.Fatalf(\"FinishBundle failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif err := node.Down(ctx); err != nil {\n+\t\t\t\t\tt.Fatalf(\"Down failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t})\n+\t\t}\n+\t})\n+\n+\t// Validate ProcessSizedElementsAndRestrictions matches its contract and\n+\t// properly invokes SDF methods CreateTracker and ProcessElement.\n+\tt.Run(\"ProcessSizedElementsAndRestrictions\", func(t *testing.T) {\n+\t\ttests := []struct {\n+\t\t\tname string\n+\t\t\tfn   *graph.DoFn\n+\t\t\tin   *FullValue\n+\t\t\twant *FullValue\n+\t\t}{\n+\t\t\t{\n+\t\t\t\tname: \"SingleElem\",\n+\t\t\t\tfn:   dfn,\n+\t\t\t\tin: &FullValue{\n+\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\t\tElm:       3,\n+\t\t\t\t\t\t\tElm2:      nil,\n+\t\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tElm2: Restriction{5},\n+\t\t\t\t\t},\n+\t\t\t\t\tElm2:      8.0,\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t\twant: &FullValue{\n+\t\t\t\t\tElm:       8,\n+\t\t\t\t\tElm2:      4,\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tname: \"KvElem\",\n+\t\t\t\tfn:   kvdfn,\n+\t\t\t\tin: &FullValue{\n+\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\t\tElm:       3,\n+\t\t\t\t\t\t\tElm2:      10,\n+\t\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tElm2: Restriction{5},\n+\t\t\t\t\t},\n+\t\t\t\t\tElm2:      18.0,\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t\twant: &FullValue{\n+\t\t\t\t\tElm:       8,\n+\t\t\t\t\tElm2:      12,\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t}\n+\t\tfor _, test := range tests {\n+\t\t\ttest := test\n+\t\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\t\tctx := context.Background()\n+\t\t\t\tfake := &FakeNode{}\n+\t\t\t\tn := &ParDo{UID: 0, Fn: test.fn, Out: []Node{fake}}\n+\t\t\t\tnode := ProcessSizedElementsAndRestrictions{PDo: n}\n+\n+\t\t\t\tif err := node.Up(ctx); err != nil {\n+\t\t\t\t\tt.Fatalf(\"Up failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif err := node.StartBundle(ctx, \"bundle_id\", DataContext{}); err != nil {\n+\t\t\t\t\tt.Fatalf(\"StartBundle failed: %v\", err)\n+\t\t\t\t}\n+\n+\t\t\t\tif err := node.ProcessElement(ctx, test.in); err != nil {\n+\t\t\t\t\tt.Fatalf(\"ProcessElement failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tgot := fake.Vals[0]\n+\t\t\t\tif !cmp.Equal(got, test.want) {\n+\t\t\t\t\tt.Errorf(\"ProcessElement(%v) has incorrect output: got: %v, want: %v\",\n+\t\t\t\t\t\ttest.in, got, test.want)\n+\t\t\t\t}\n+\t\t\t\tif err := node.FinishBundle(ctx); err != nil {\n+\t\t\t\t\tt.Fatalf(\"FinishBundle failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif err := node.Down(ctx); err != nil {\n+\t\t\t\t\tt.Fatalf(\"Down failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t})\n+\t\t}\n+\t})\n+}\n+\n+// TestSplitAndSizeRestrictions verifies that the SplitAndSizeRestrictions node\n+// both fulfills its contract and successfully invokes the accompanying SDF's\n+// SplitRestriction and RestrictionSize methods to do so.\n+func TestSplitAndSizeRestrictions(t *testing.T) {\n+}\n+\n+// TestProcessSizedElementsAndRestrictions verifies that the\n+// ProcessSizedElementsAndRestrictions node both fulfills its contract and\n+// successfully invokes the accompanying SDF's CreateTracker and ProcessElement\n+// methods to do so.\n+func TestProcessSizedElementsAndRestrictions(t *testing.T) {\n+}\n+\n+// FakeNode is used to capture the outputs of the node being tested by\n+// TestSdfNodes. FakeNode appends each element that it receives in its\n+// ProcessElement method to its Vals struct, which can then be read by the test.\n+type FakeNode struct {\n+\tVals []*FullValue", "originalCommit": "8741c0f47a5bf7e7663f929ebf86acf679e0f7d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg0Mjg4MA==", "url": "https://github.com/apache/beam/pull/11327#discussion_r407842880", "bodyText": "Noted for the future.", "author": "youngoli", "createdAt": "2020-04-14T03:21:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQwMzEwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQwNDEwNQ==", "url": "https://github.com/apache/beam/pull/11327#discussion_r406404105", "bodyText": "I forgotwe had cmp probably configured in the gogradle.lock file. Nice.\nhttps://github.com/apache/beam/blob/master/sdks/go/gogradle.lock#L223\nIn a different PR we could probably update the comparison helpers in fullvalue_test.go to use cmp options and Transformers instead which would make things much clearer.", "author": "lostluck", "createdAt": "2020-04-09T18:42:46Z", "path": "sdks/go/pkg/beam/core/runtime/exec/sdf_test.go", "diffHunk": "@@ -0,0 +1,408 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package exec\n+\n+import (\n+\t\"context\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/window\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/typex\"\n+\t\"github.com/google/go-cmp/cmp\"\n+\t\"testing\"\n+)\n+\n+// testTimestamp is a constant used to check that timestamps are retained.\n+const testTimestamp = 15\n+\n+// testWindow is a constant used to check that windows are retained\n+var testWindows = []typex.Window{window.IntervalWindow{Start: 10, End: 20}}\n+\n+// TestSdfNodes verifies that the various SDF nodes fulfill each of their\n+// described contracts, that they each successfully invoke any SDF methods\n+// needed, and that they preserve timestamps and windows correctly.\n+func TestSdfNodes(t *testing.T) {\n+\t// Setup. The DoFns created below are defined in sdf_invokers_test.go and\n+\t// have testable behavior to confirm that they got correctly invoked.\n+\t// Without knowing the expected behavior of these DoFns, the desired outputs\n+\t// in the unit tests below will not make much sense.\n+\tdfn, err := graph.NewDoFn(&Sdf{}, graph.NumMainInputs(graph.MainSingle))\n+\tif err != nil {\n+\t\tt.Fatalf(\"invalid function: %v\", err)\n+\t}\n+\tkvdfn, err := graph.NewDoFn(&KvSdf{}, graph.NumMainInputs(graph.MainKv))\n+\tif err != nil {\n+\t\tt.Fatalf(\"invalid function: %v\", err)\n+\t}\n+\n+\t// Validate PairWithRestriction matches its contract and properly invokes\n+\t// SDF method CreateInitialRestriction.\n+\tt.Run(\"PairWithRestriction\", func(t *testing.T) {\n+\t\ttests := []struct {\n+\t\t\tname string\n+\t\t\tfn   *graph.DoFn\n+\t\t\tin   *FullValue\n+\t\t\twant *FullValue\n+\t\t}{\n+\t\t\t{\n+\t\t\t\tname: \"SingleElem\",\n+\t\t\t\tfn:   dfn,\n+\t\t\t\tin: &FullValue{\n+\t\t\t\t\tElm:       5,\n+\t\t\t\t\tElm2:      nil,\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t\twant: &FullValue{\n+\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\tElm:       5,\n+\t\t\t\t\t\tElm2:      nil,\n+\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t},\n+\t\t\t\t\tElm2:      Restriction{5},\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tname: \"KvElem\",\n+\t\t\t\tfn:   kvdfn,\n+\t\t\t\tin: &FullValue{\n+\t\t\t\t\tElm:       5,\n+\t\t\t\t\tElm2:      2,\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t\twant: &FullValue{\n+\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\tElm:       5,\n+\t\t\t\t\t\tElm2:      2,\n+\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t},\n+\t\t\t\t\tElm2:      Restriction{7},\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t}\n+\t\tfor _, test := range tests {\n+\t\t\ttest := test\n+\t\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\t\tctx := context.Background()\n+\t\t\t\tfake := &FakeNode{}\n+\t\t\t\tnode := PairWithRestriction{UID: 0, Fn: test.fn, Out: []Node{fake}}\n+\n+\t\t\t\tif err := node.Up(ctx); err != nil {\n+\t\t\t\t\tt.Fatalf(\"Up failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif err := node.StartBundle(ctx, \"bundle_id\", DataContext{}); err != nil {\n+\t\t\t\t\tt.Fatalf(\"StartBundle failed: %v\", err)\n+\t\t\t\t}\n+\n+\t\t\t\tif err := node.ProcessElement(ctx, test.in); err != nil {\n+\t\t\t\t\tt.Fatalf(\"ProcessElement failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tgot := fake.Vals[0]\n+\t\t\t\tif !cmp.Equal(got, test.want) {", "originalCommit": "8741c0f47a5bf7e7663f929ebf86acf679e0f7d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzgyOTkxNg==", "url": "https://github.com/apache/beam/pull/11327#discussion_r407829916", "bodyText": "Oooh, that seems like a good idea. Made a bug for it: https://jira.apache.org/jira/browse/BEAM-9753", "author": "youngoli", "createdAt": "2020-04-14T02:33:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQwNDEwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQwNzgzNg==", "url": "https://github.com/apache/beam/pull/11327#discussion_r406407836", "bodyText": "There's a lot of duplicated code for these tests. Consider using FixedRoot, and the constructAndExecutePlan helper to reduce the duplication.\nWe may want to move the constructAndExecutePlan helper to unit_test.go (in another PR).", "author": "lostluck", "createdAt": "2020-04-09T18:49:23Z", "path": "sdks/go/pkg/beam/core/runtime/exec/sdf_test.go", "diffHunk": "@@ -0,0 +1,408 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package exec\n+\n+import (\n+\t\"context\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/window\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/typex\"\n+\t\"github.com/google/go-cmp/cmp\"\n+\t\"testing\"\n+)\n+\n+// testTimestamp is a constant used to check that timestamps are retained.\n+const testTimestamp = 15\n+\n+// testWindow is a constant used to check that windows are retained\n+var testWindows = []typex.Window{window.IntervalWindow{Start: 10, End: 20}}\n+\n+// TestSdfNodes verifies that the various SDF nodes fulfill each of their\n+// described contracts, that they each successfully invoke any SDF methods\n+// needed, and that they preserve timestamps and windows correctly.\n+func TestSdfNodes(t *testing.T) {\n+\t// Setup. The DoFns created below are defined in sdf_invokers_test.go and\n+\t// have testable behavior to confirm that they got correctly invoked.\n+\t// Without knowing the expected behavior of these DoFns, the desired outputs\n+\t// in the unit tests below will not make much sense.\n+\tdfn, err := graph.NewDoFn(&Sdf{}, graph.NumMainInputs(graph.MainSingle))\n+\tif err != nil {\n+\t\tt.Fatalf(\"invalid function: %v\", err)\n+\t}\n+\tkvdfn, err := graph.NewDoFn(&KvSdf{}, graph.NumMainInputs(graph.MainKv))\n+\tif err != nil {\n+\t\tt.Fatalf(\"invalid function: %v\", err)\n+\t}\n+\n+\t// Validate PairWithRestriction matches its contract and properly invokes\n+\t// SDF method CreateInitialRestriction.\n+\tt.Run(\"PairWithRestriction\", func(t *testing.T) {\n+\t\ttests := []struct {\n+\t\t\tname string\n+\t\t\tfn   *graph.DoFn\n+\t\t\tin   *FullValue\n+\t\t\twant *FullValue\n+\t\t}{\n+\t\t\t{\n+\t\t\t\tname: \"SingleElem\",\n+\t\t\t\tfn:   dfn,\n+\t\t\t\tin: &FullValue{\n+\t\t\t\t\tElm:       5,\n+\t\t\t\t\tElm2:      nil,\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t\twant: &FullValue{\n+\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\tElm:       5,\n+\t\t\t\t\t\tElm2:      nil,\n+\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t},\n+\t\t\t\t\tElm2:      Restriction{5},\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tname: \"KvElem\",\n+\t\t\t\tfn:   kvdfn,\n+\t\t\t\tin: &FullValue{\n+\t\t\t\t\tElm:       5,\n+\t\t\t\t\tElm2:      2,\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t\twant: &FullValue{\n+\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\tElm:       5,\n+\t\t\t\t\t\tElm2:      2,\n+\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t},\n+\t\t\t\t\tElm2:      Restriction{7},\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t}\n+\t\tfor _, test := range tests {\n+\t\t\ttest := test\n+\t\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\t\tctx := context.Background()\n+\t\t\t\tfake := &FakeNode{}\n+\t\t\t\tnode := PairWithRestriction{UID: 0, Fn: test.fn, Out: []Node{fake}}\n+\n+\t\t\t\tif err := node.Up(ctx); err != nil {\n+\t\t\t\t\tt.Fatalf(\"Up failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif err := node.StartBundle(ctx, \"bundle_id\", DataContext{}); err != nil {\n+\t\t\t\t\tt.Fatalf(\"StartBundle failed: %v\", err)\n+\t\t\t\t}\n+\n+\t\t\t\tif err := node.ProcessElement(ctx, test.in); err != nil {\n+\t\t\t\t\tt.Fatalf(\"ProcessElement failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tgot := fake.Vals[0]\n+\t\t\t\tif !cmp.Equal(got, test.want) {\n+\t\t\t\t\tt.Errorf(\"ProcessElement(%v) has incorrect output: got: %v, want: %v\",\n+\t\t\t\t\t\ttest.in, got, test.want)\n+\t\t\t\t}\n+\t\t\t\tif err := node.FinishBundle(ctx); err != nil {\n+\t\t\t\t\tt.Fatalf(\"FinishBundle failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif err := node.Down(ctx); err != nil {\n+\t\t\t\t\tt.Fatalf(\"Down failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t})\n+\t\t}\n+\t})\n+\n+\t// Validate SplitAndSizeRestrictions matches its contract and properly\n+\t// invokes SDF methods SplitRestriction and RestrictionSize.\n+\tt.Run(\"SplitAndSizeRestrictions\", func(t *testing.T) {\n+\t\ttests := []struct {\n+\t\t\tname string\n+\t\t\tfn   *graph.DoFn\n+\t\t\tin   *FullValue\n+\t\t\twant []*FullValue\n+\t\t}{\n+\t\t\t{\n+\t\t\t\tname: \"SingleElem\",\n+\t\t\t\tfn:   dfn,\n+\t\t\t\tin: &FullValue{\n+\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\tElm:       2,\n+\t\t\t\t\t\tElm2:      nil,\n+\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t},\n+\t\t\t\t\tElm2:      Restriction{5},\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t\twant: []*FullValue{\n+\t\t\t\t\t{\n+\t\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\t\t\tElm:       2,\n+\t\t\t\t\t\t\t\tElm2:      nil,\n+\t\t\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\tElm2: Restriction{7},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tElm2:      9.0,\n+\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t},\n+\t\t\t\t\t{\n+\t\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\t\t\tElm:       2,\n+\t\t\t\t\t\t\t\tElm2:      nil,\n+\t\t\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\tElm2: Restriction{8},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tElm2:      10.0,\n+\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tname: \"KvElem\",\n+\t\t\t\tfn:   kvdfn,\n+\t\t\t\tin: &FullValue{\n+\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\tElm:       2,\n+\t\t\t\t\t\tElm2:      5,\n+\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t},\n+\t\t\t\t\tElm2:      Restriction{3},\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t\twant: []*FullValue{\n+\t\t\t\t\t{\n+\t\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\t\t\tElm:       2,\n+\t\t\t\t\t\t\t\tElm2:      5,\n+\t\t\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\tElm2: Restriction{5},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tElm2:      12.0,\n+\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t},\n+\t\t\t\t\t{\n+\t\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\t\t\tElm:       2,\n+\t\t\t\t\t\t\t\tElm2:      5,\n+\t\t\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\tElm2: Restriction{8},\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tElm2:      15.0,\n+\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t},\n+\t\t}\n+\t\tfor _, test := range tests {\n+\t\t\ttest := test\n+\t\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\t\tctx := context.Background()\n+\t\t\t\tfake := &FakeNode{}\n+\t\t\t\tnode := SplitAndSizeRestrictions{UID: 0, Fn: test.fn, Out: []Node{fake}}\n+\n+\t\t\t\tif err := node.Up(ctx); err != nil {\n+\t\t\t\t\tt.Fatalf(\"Up failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif err := node.StartBundle(ctx, \"bundle_id\", DataContext{}); err != nil {\n+\t\t\t\t\tt.Fatalf(\"StartBundle failed: %v\", err)\n+\t\t\t\t}\n+\n+\t\t\t\tif err := node.ProcessElement(ctx, test.in); err != nil {\n+\t\t\t\t\tt.Fatalf(\"ProcessElement failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tfor i, got := range fake.Vals {\n+\t\t\t\t\tif !cmp.Equal(got, test.want[i]) {\n+\t\t\t\t\t\tt.Errorf(\"ProcessElement(%v) has incorrect output %v: got: %v, want: %v\",\n+\t\t\t\t\t\t\ttest.in, i, got, test.want)\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif err := node.FinishBundle(ctx); err != nil {\n+\t\t\t\t\tt.Fatalf(\"FinishBundle failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif err := node.Down(ctx); err != nil {\n+\t\t\t\t\tt.Fatalf(\"Down failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t})\n+\t\t}\n+\t})\n+\n+\t// Validate ProcessSizedElementsAndRestrictions matches its contract and\n+\t// properly invokes SDF methods CreateTracker and ProcessElement.\n+\tt.Run(\"ProcessSizedElementsAndRestrictions\", func(t *testing.T) {\n+\t\ttests := []struct {\n+\t\t\tname string\n+\t\t\tfn   *graph.DoFn\n+\t\t\tin   *FullValue\n+\t\t\twant *FullValue\n+\t\t}{\n+\t\t\t{\n+\t\t\t\tname: \"SingleElem\",\n+\t\t\t\tfn:   dfn,\n+\t\t\t\tin: &FullValue{\n+\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\t\tElm:       3,\n+\t\t\t\t\t\t\tElm2:      nil,\n+\t\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tElm2: Restriction{5},\n+\t\t\t\t\t},\n+\t\t\t\t\tElm2:      8.0,\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t\twant: &FullValue{\n+\t\t\t\t\tElm:       8,\n+\t\t\t\t\tElm2:      4,\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tname: \"KvElem\",\n+\t\t\t\tfn:   kvdfn,\n+\t\t\t\tin: &FullValue{\n+\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\tElm: &FullValue{\n+\t\t\t\t\t\t\tElm:       3,\n+\t\t\t\t\t\t\tElm2:      10,\n+\t\t\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t\tElm2: Restriction{5},\n+\t\t\t\t\t},\n+\t\t\t\t\tElm2:      18.0,\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t\twant: &FullValue{\n+\t\t\t\t\tElm:       8,\n+\t\t\t\t\tElm2:      12,\n+\t\t\t\t\tTimestamp: testTimestamp,\n+\t\t\t\t\tWindows:   testWindows,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t}\n+\t\tfor _, test := range tests {\n+\t\t\ttest := test\n+\t\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\t\tctx := context.Background()\n+\t\t\t\tfake := &FakeNode{}\n+\t\t\t\tn := &ParDo{UID: 0, Fn: test.fn, Out: []Node{fake}}\n+\t\t\t\tnode := ProcessSizedElementsAndRestrictions{PDo: n}\n+\n+\t\t\t\tif err := node.Up(ctx); err != nil {\n+\t\t\t\t\tt.Fatalf(\"Up failed: %v\", err)\n+\t\t\t\t}\n+\t\t\t\tif err := node.StartBundle(ctx, \"bundle_id\", DataContext{}); err != nil {\n+\t\t\t\t\tt.Fatalf(\"StartBundle failed: %v\", err)\n+\t\t\t\t}\n+\n+\t\t\t\tif err := node.ProcessElement(ctx, test.in); err != nil {", "originalCommit": "8741c0f47a5bf7e7663f929ebf86acf679e0f7d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg0MzE2NA==", "url": "https://github.com/apache/beam/pull/11327#discussion_r407843164", "bodyText": "Done.", "author": "youngoli", "createdAt": "2020-04-14T03:22:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQwNzgzNg=="}], "type": "inlineReview"}, {"oid": "98e09629e56daf6ae491e45a59ef091288f71860", "url": "https://github.com/apache/beam/commit/98e09629e56daf6ae491e45a59ef091288f71860", "message": "[BEAM-9642] fixup", "committedDate": "2020-04-14T03:09:04Z", "type": "commit"}, {"oid": "dc93889ebea89321705f5e2ec106f1757b417d47", "url": "https://github.com/apache/beam/commit/dc93889ebea89321705f5e2ec106f1757b417d47", "message": "[BEAM-9642] yet more fixup", "committedDate": "2020-04-14T03:19:43Z", "type": "commit"}]}