{"pr_number": 13048, "pr_title": "[BEAM-3736] Add CombineFn.setup and CombineFn.teardown to Python SDK", "pr_createdAt": "2020-10-08T11:25:49Z", "pr_url": "https://github.com/apache/beam/pull/13048", "timeline": [{"oid": "a0d436a14d7b5d1f9a0158a11e1ae204b5de8ce2", "url": "https://github.com/apache/beam/commit/a0d436a14d7b5d1f9a0158a11e1ae204b5de8ce2", "message": "[BEAM-3736] Add CombineFn.setup and CombineFn.teardown to Python SDK", "committedDate": "2020-10-08T11:32:37Z", "type": "forcePushed"}, {"oid": "44c1bd3509c81d9d4ce9e348575e39753b490cea", "url": "https://github.com/apache/beam/commit/44c1bd3509c81d9d4ce9e348575e39753b490cea", "message": "[BEAM-3736] Add CombineFn.setup and CombineFn.teardown to Python SDK", "committedDate": "2020-10-08T14:19:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAyOTU0MA==", "url": "https://github.com/apache/beam/pull/13048#discussion_r503029540", "bodyText": "This alludes that  setup method is called once per entire collection. Wouldn't it be called per batch? Aggregation may happen on multiple workers, and I imagine that in such case each worker will call setup/teardown methods. Should we switch step 1 and 2?", "author": "tvalentyn", "createdAt": "2020-10-12T04:13:24Z", "path": "sdks/python/apache_beam/transforms/core.py", "diffHunk": "@@ -875,18 +875,20 @@ class CombineFn(WithTypeHints, HasDisplayData, urns.RunnerApiFn):\n   input argument, which is an instance of CombineFnProcessContext). The\n   combining process proceeds as follows:\n \n-  1. Input values are partitioned into one or more batches.\n-  2. For each batch, the create_accumulator method is invoked to create a fresh\n+  1. The setup method is invoked.", "originalCommit": "44c1bd3509c81d9d4ce9e348575e39753b490cea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM1MDUzNg==", "url": "https://github.com/apache/beam/pull/13048#discussion_r503350536", "bodyText": "It probably should be like this:\n1. Input values are partitioned into one or more batches.\n2. For each batch, the setup method is invoked.\n3. For each batch, the create_accumulator method is invoked...", "author": "kamilwu", "createdAt": "2020-10-12T14:52:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAyOTU0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAzMDE3MA==", "url": "https://github.com/apache/beam/pull/13048#discussion_r503030170", "bodyText": "What is the reason for a shallow copy here?", "author": "tvalentyn", "createdAt": "2020-10-12T04:16:48Z", "path": "sdks/python/apache_beam/transforms/core.py", "diffHunk": "@@ -1970,10 +1985,14 @@ def add_input_types(transform):\n       return combined\n \n     if self.has_defaults:\n-      combine_fn = (\n-          self.fn if isinstance(self.fn, CombineFn) else\n-          CombineFn.from_callable(self.fn))\n-      default_value = combine_fn.apply([], *self.args, **self.kwargs)\n+      combine_fn = copy.copy(", "originalCommit": "44c1bd3509c81d9d4ce9e348575e39753b490cea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzMzMjcwOQ==", "url": "https://github.com/apache/beam/pull/13048#discussion_r503332709", "bodyText": "Better protection against potential side effects.\nIf using default values, CombineFn.apply is called at pipeline construction time. CombineFn.setup and CombineFn.teardown are called along with it. The same instance of CombineFn is then serialized and sent to runner. I think it would be better to perform initial CombineFn.apply on a copy, so that the state of the instance is not polluted.", "author": "kamilwu", "createdAt": "2020-10-12T14:25:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAzMDE3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4NTA3Mg==", "url": "https://github.com/apache/beam/pull/13048#discussion_r503585072", "bodyText": "I see. I wonder if calling setup/teardown on during pipeline submission may be undesireable in some cases.\nOne option to offer flexibility is to use introduce default_value() method in CombineFn, and move the setup/teardown call in that method, trying this out in: #13081.", "author": "tvalentyn", "createdAt": "2020-10-12T23:34:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAzMDE3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzkxNTczNQ==", "url": "https://github.com/apache/beam/pull/13048#discussion_r503915735", "bodyText": "Left some comments over there", "author": "kamilwu", "createdAt": "2020-10-13T12:38:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAzMDE3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAzMTcxNw==", "url": "https://github.com/apache/beam/pull/13048#discussion_r503031717", "bodyText": "Should we make  non-portable Dataflow runner detect usage of combiner initialization and alert the user that this functionality is unsupported?\ncc: @robertwb", "author": "tvalentyn", "createdAt": "2020-10-12T04:24:21Z", "path": "sdks/python/apache_beam/transforms/combinefn_lifecycle_test.py", "diffHunk": "@@ -0,0 +1,147 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"ValidatesRunner tests for CombineFn lifecycle and bundle methods.\"\"\"\n+\n+# pytype: skip-file\n+\n+import unittest\n+from weakref import WeakSet\n+\n+from nose.plugins.attrib import attr\n+\n+import apache_beam as beam\n+from apache_beam.options.pipeline_options import DebugOptions\n+from apache_beam.options.pipeline_options import StandardOptions\n+from apache_beam.runners.direct import direct_runner\n+from apache_beam.runners.portability import fn_api_runner\n+from apache_beam.testing.test_pipeline import TestPipeline\n+from apache_beam.testing.util import assert_that\n+from apache_beam.testing.util import equal_to\n+from apache_beam.transforms import trigger\n+from apache_beam.transforms import window\n+\n+\n+class CallSequenceEnforcingCombineFn(beam.CombineFn):\n+  instances = WeakSet()\n+\n+  def __init__(self):\n+    super(CallSequenceEnforcingCombineFn, self).__init__()\n+    self._setup_called = False\n+    self._accumulators_created = 0\n+    self._teardown_called = False\n+\n+  def setup(self):\n+    assert not self._setup_called, 'setup should not be called twice'\n+    assert not self._teardown_called, 'setup should be called before teardown'\n+    # Keep track of instances so that we can check if teardown is called\n+    # properly after pipeline execution.\n+    self.instances.add(self)\n+    self._setup_called = True\n+\n+  def create_accumulator(self):\n+    assert self._setup_called, 'setup should have been called'\n+    assert not self._teardown_called, 'teardown should not have been called'\n+    self._accumulators_created += 1\n+    return 0\n+\n+  def add_input(self, mutable_accumulator, element):\n+    assert self._setup_called, 'setup should have been called'\n+    assert self._accumulators_created > 0, \\\n+        'create_accumulator should have been called'\n+    assert not self._teardown_called, 'teardown should not have been called'\n+    mutable_accumulator += element\n+    return mutable_accumulator\n+\n+  def add_inputs(self, mutable_accumulator, elements):\n+    return self.add_input(mutable_accumulator, sum(elements))\n+\n+  def merge_accumulators(self, accumulators):\n+    assert self._setup_called, 'setup should have been called'\n+    assert not self._teardown_called, 'teardown should not have been called'\n+    return sum(accumulators)\n+\n+  def extract_output(self, accumulator):\n+    assert self._setup_called, 'setup should have been called'\n+    assert not self._teardown_called, 'teardown should not have been called'\n+    return accumulator\n+\n+  def teardown(self):\n+    assert self._setup_called, 'setup should have been called'\n+    assert not self._teardown_called, 'teardown should not be called twice'\n+    self._teardown_called = True\n+\n+\n+class BaseCombineFnLifecycleTest(unittest.TestCase):\n+  def start(self, pipeline, lift_combiners=True):\n+    with pipeline as p:\n+      pcoll = p | 'Start' >> beam.Create(range(5))\n+\n+      # Certain triggers, such as AfterCount, are incompatible with combiner\n+      # lifting. We can use that fact to prevent combiners from being lifted.\n+      if not lift_combiners:\n+        pcoll |= beam.WindowInto(\n+            window.GlobalWindows(),\n+            trigger=trigger.AfterCount(5),\n+            accumulation_mode=trigger.AccumulationMode.DISCARDING)\n+\n+      pcoll |= 'Do' >> beam.CombineGlobally(CallSequenceEnforcingCombineFn())\n+      assert_that(pcoll, equal_to([10]))\n+\n+    # Ensure that _teardown_called equals True for all CombineFns.\n+    for instance in CallSequenceEnforcingCombineFn.instances:\n+      self.assertTrue(instance._teardown_called)\n+\n+\n+@attr('ValidatesRunner')\n+class CombineFnLifecycleTest(BaseCombineFnLifecycleTest):\n+  def setUp(self):\n+    self.pipeline = TestPipeline(is_integration_test=True)\n+    options = self.pipeline.get_pipeline_options()\n+    standard_options = options.view_as(StandardOptions)\n+    experiments = options.view_as(DebugOptions).experiments or []\n+\n+    if 'DataflowRunner' in standard_options.runner and \\\n+       not standard_options.streaming and \\\n+       'beam_fn_api' not in experiments and 'use_runner_v2' not in experiments:\n+      self.skipTest(\n+          'Non-portable Dataflow batch worker does not support '", "originalCommit": "44c1bd3509c81d9d4ce9e348575e39753b490cea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzMzNjAzMg==", "url": "https://github.com/apache/beam/pull/13048#discussion_r503336032", "bodyText": "Yes, it's probably a good idea.\nShould we raise an exception and exit the program abnormally if user-provided setup and teardown are detected, or just inform the user that those methods won't be called?", "author": "kamilwu", "createdAt": "2020-10-12T14:30:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAzMTcxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4NTY5Ng==", "url": "https://github.com/apache/beam/pull/13048#discussion_r503585696", "bodyText": "On BEAM-3736 the recommendation was to reject the job. It is more problematic with Java SDK, since there are a lot of runner. AFAIK with Python SDK, Dataflow is the only non-portable runner (not including direct runner).", "author": "tvalentyn", "createdAt": "2020-10-12T23:36:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAzMTcxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzkxNDQyNA==", "url": "https://github.com/apache/beam/pull/13048#discussion_r503914424", "bodyText": "I've added a code that rejects the job and provides clear information why it's rejected.", "author": "kamilwu", "createdAt": "2020-10-13T12:36:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAzMTcxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAzMzU3Ng==", "url": "https://github.com/apache/beam/pull/13048#discussion_r503033576", "bodyText": "nit: s/disposed/disposed of", "author": "tvalentyn", "createdAt": "2020-10-12T04:33:26Z", "path": "sdks/python/apache_beam/transforms/core.py", "diffHunk": "@@ -895,6 +897,15 @@ class CombineFn(WithTypeHints, HasDisplayData, urns.RunnerApiFn):\n   def default_label(self):\n     return self.__class__.__name__\n \n+  def setup(self):\n+    \"\"\"Called to prepare an instance for combining.\n+\n+    This method can be useful if there is some state that needs to be loaded\n+    before executing any of the other methods. The resources can then be\n+    disposed in ``CombineFn.teardown``.", "originalCommit": "44c1bd3509c81d9d4ce9e348575e39753b490cea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzMzNzAzMg==", "url": "https://github.com/apache/beam/pull/13048#discussion_r503337032", "bodyText": "Thanks.", "author": "kamilwu", "createdAt": "2020-10-12T14:32:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzAzMzU3Ng=="}], "type": "inlineReview"}, {"oid": "b96bb6f9abb681583095e924a7102516564b48ae", "url": "https://github.com/apache/beam/commit/b96bb6f9abb681583095e924a7102516564b48ae", "message": "fix: update CombineFn's doc", "committedDate": "2020-10-13T12:26:55Z", "type": "forcePushed"}, {"oid": "7ac6339bd80c15cfe971ed2eafaa6c28dc6933bf", "url": "https://github.com/apache/beam/commit/7ac6339bd80c15cfe971ed2eafaa6c28dc6933bf", "message": "fix: update CombineFn's doc", "committedDate": "2020-10-13T12:40:10Z", "type": "forcePushed"}, {"oid": "fc80e43dcfb5f9de3fb55371a3bdf72612040c6c", "url": "https://github.com/apache/beam/commit/fc80e43dcfb5f9de3fb55371a3bdf72612040c6c", "message": "fix: update CombineFn's doc", "committedDate": "2020-10-16T10:54:44Z", "type": "forcePushed"}, {"oid": "74dd0040e0006480dee0c4c4739863a488b33c0c", "url": "https://github.com/apache/beam/commit/74dd0040e0006480dee0c4c4739863a488b33c0c", "message": "fix: call setup/teardown for CombiningValueRuntimeState", "committedDate": "2020-10-19T15:53:45Z", "type": "forcePushed"}, {"oid": "6dd53adaa4186d0d79d79071b4bb6dea46e645eb", "url": "https://github.com/apache/beam/commit/6dd53adaa4186d0d79d79071b4bb6dea46e645eb", "message": "fix: call setup/teardown for CombiningValueRuntimeState", "committedDate": "2020-10-20T10:56:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyMzUwNA==", "url": "https://github.com/apache/beam/pull/13048#discussion_r513623504", "bodyText": "nit: 'a state' -> 'the CombineFn's state'", "author": "yifanmai", "createdAt": "2020-10-28T17:17:19Z", "path": "CHANGES.md", "diffHunk": "@@ -62,6 +62,7 @@\n \n ## New Features / Improvements\n * Added support for avro payload format in Beam SQL Kafka Table ([BEAM-10885](https://issues.apache.org/jira/browse/BEAM-10885))\n+* Added CombineFn.setup and CombineFn.teardown to Python SDK. These methods let you initialize a state before any of the other methods of the CombineFn is executed and clean that state up later on. ([BEAM-3736](https://issues.apache.org/jira/browse/BEAM-3736))", "originalCommit": "6dd53adaa4186d0d79d79071b4bb6dea46e645eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyNDkxNg==", "url": "https://github.com/apache/beam/pull/13048#discussion_r513624916", "bodyText": "Question: Is there any plan to support this in non-portable Dataflow Runner, or will this be a V2 feature only?", "author": "yifanmai", "createdAt": "2020-10-28T17:19:25Z", "path": "sdks/python/apache_beam/runners/dataflow/dataflow_runner.py", "diffHunk": "@@ -411,6 +411,33 @@ def visit_transform(self, transform_node):\n \n     return FlattenInputVisitor()\n \n+  @staticmethod\n+  def combinefn_visitor():\n+    # Imported here to avoid circular dependencies.\n+    from apache_beam.pipeline import PipelineVisitor\n+    from apache_beam import core\n+\n+    class CombineFnVisitor(PipelineVisitor):\n+      \"\"\"Checks if `CombineFn` has non-default setup or teardown methods.\n+      If yes, raises `ValueError`.\n+      \"\"\"\n+      def visit_transform(self, applied_transform):\n+        transform = applied_transform.transform\n+        if isinstance(transform, core.ParDo) and isinstance(\n+            transform.fn, core.CombineValuesDoFn):\n+          if self._overrides_setup_or_teardown(transform.fn.combinefn):\n+            raise ValueError(\n+                'CombineFn.setup and CombineFn.teardown are '\n+                'not supported with non-portable Dataflow '\n+                'runner. Please use Dataflow Runner V2 instead.')", "originalCommit": "6dd53adaa4186d0d79d79071b4bb6dea46e645eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM5NTA1NA==", "url": "https://github.com/apache/beam/pull/13048#discussion_r514395054", "bodyText": "I think the question is for Dataflow team. From my perspective, I think there's no such need to support this in non-portable Dataflow, given that new batch pipelines will start using Dataflow Runner V2 in a month (December 4).", "author": "kamilwu", "createdAt": "2020-10-29T16:26:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyNDkxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzMjk4Ng==", "url": "https://github.com/apache/beam/pull/13048#discussion_r513632986", "bodyText": "nit: 'arythmetic' -> 'arithmetic'", "author": "yifanmai", "createdAt": "2020-10-28T17:30:16Z", "path": "sdks/python/apache_beam/transforms/combinefn_lifecycle_pipeline.py", "diffHunk": "@@ -0,0 +1,131 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+# pytype: skip-file\n+\n+from typing import Set\n+from typing import Tuple\n+\n+import apache_beam as beam\n+from apache_beam.options.pipeline_options import TypeOptions\n+from apache_beam.testing.util import assert_that\n+from apache_beam.testing.util import equal_to\n+from apache_beam.transforms import combiners\n+from apache_beam.transforms import trigger\n+from apache_beam.transforms import userstate\n+from apache_beam.transforms import window\n+from apache_beam.typehints import with_input_types\n+from apache_beam.typehints import with_output_types\n+\n+\n+@with_input_types(int)\n+@with_output_types(int)\n+class CallSequenceEnforcingCombineFn(beam.CombineFn):\n+  instances = set()  # type: Set[CallSequenceEnforcingCombineFn]\n+\n+  def __init__(self):\n+    super(CallSequenceEnforcingCombineFn, self).__init__()\n+    self._setup_called = False\n+    self._teardown_called = False\n+\n+  def setup(self, *args, **kwargs):\n+    assert not self._setup_called, 'setup should not be called twice'\n+    assert not self._teardown_called, 'setup should be called before teardown'\n+    # Keep track of instances so that we can check if teardown is called\n+    # properly after pipeline execution.\n+    self.instances.add(self)\n+    self._setup_called = True\n+\n+  def create_accumulator(self, *args, **kwargs):\n+    assert self._setup_called, 'setup should have been called'\n+    assert not self._teardown_called, 'teardown should not have been called'\n+    return 0\n+\n+  def add_input(self, mutable_accumulator, element, *args, **kwargs):\n+    assert self._setup_called, 'setup should have been called'\n+    assert not self._teardown_called, 'teardown should not have been called'\n+    mutable_accumulator += element\n+    return mutable_accumulator\n+\n+  def add_inputs(self, mutable_accumulator, elements, *args, **kwargs):\n+    return self.add_input(mutable_accumulator, sum(elements))\n+\n+  def merge_accumulators(self, accumulators, *args, **kwargs):\n+    assert self._setup_called, 'setup should have been called'\n+    assert not self._teardown_called, 'teardown should not have been called'\n+    return sum(accumulators)\n+\n+  def extract_output(self, accumulator, *args, **kwargs):\n+    assert self._setup_called, 'setup should have been called'\n+    assert not self._teardown_called, 'teardown should not have been called'\n+    return accumulator\n+\n+  def teardown(self, *args, **kwargs):\n+    assert self._setup_called, 'setup should have been called'\n+    assert not self._teardown_called, 'teardown should not be called twice'\n+    self._teardown_called = True\n+\n+\n+@with_input_types(Tuple[None, str])\n+@with_output_types(Tuple[int, str])\n+class IndexAssigningDoFn(beam.DoFn):\n+  state_param = beam.DoFn.StateParam(\n+      userstate.CombiningValueStateSpec(\n+          'index', beam.coders.VarIntCoder(), CallSequenceEnforcingCombineFn()))\n+\n+  def process(self, element, state=state_param):\n+    _, value = element\n+    current_index = state.read()\n+    yield current_index, value\n+    state.add(1)\n+\n+\n+def run_combine(pipeline, input_elements=5, lift_combiners=True):\n+  # Calculate the excepted result, which is the sum of an arythmetic sequence.", "originalCommit": "6dd53adaa4186d0d79d79071b4bb6dea46e645eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY1NDIzNw==", "url": "https://github.com/apache/beam/pull/13048#discussion_r513654237", "bodyText": "nit: this can be copy.deepcopy(self.fn) if... i.e. copy is only needed in the first branch", "author": "yifanmai", "createdAt": "2020-10-28T18:01:06Z", "path": "sdks/python/apache_beam/transforms/core.py", "diffHunk": "@@ -1975,10 +1990,14 @@ def add_input_types(transform):\n       return combined\n \n     if self.has_defaults:\n-      combine_fn = (\n-          self.fn if isinstance(self.fn, CombineFn) else\n-          CombineFn.from_callable(self.fn))\n-      default_value = combine_fn.apply([], *self.args, **self.kwargs)\n+      combine_fn = copy.deepcopy(\n+          self.fn if isinstance(self.fn, CombineFn) else CombineFn.", "originalCommit": "6dd53adaa4186d0d79d79071b4bb6dea46e645eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY2NjIwMA==", "url": "https://github.com/apache/beam/pull/13048#discussion_r513666200", "bodyText": "Question: What is the expected behavior if setup throws an exception? Should teardown still be called?", "author": "yifanmai", "createdAt": "2020-10-28T18:19:49Z", "path": "sdks/python/apache_beam/transforms/core.py", "diffHunk": "@@ -877,17 +877,19 @@ class CombineFn(WithTypeHints, HasDisplayData, urns.RunnerApiFn):\n   combining process proceeds as follows:\n \n   1. Input values are partitioned into one or more batches.\n-  2. For each batch, the create_accumulator method is invoked to create a fresh\n+  2. For each batch, the setup method is invoked.\n+  3. For each batch, the create_accumulator method is invoked to create a fresh\n      initial \"accumulator\" value representing the combination of zero values.\n-  3. For each input value in the batch, the add_input method is invoked to\n+  4. For each input value in the batch, the add_input method is invoked to\n      combine more values with the accumulator for that batch.\n-  4. The merge_accumulators method is invoked to combine accumulators from\n+  5. The merge_accumulators method is invoked to combine accumulators from\n      separate batches into a single combined output accumulator value, once all\n      of the accumulators have had all the input value in their batches added to\n      them. This operation is invoked repeatedly, until there is only one\n      accumulator value left.\n-  5. The extract_output operation is invoked on the final accumulator to get\n+  6. The extract_output operation is invoked on the final accumulator to get\n      the output value.\n+  7. The teardown method is invoked.", "originalCommit": "6dd53adaa4186d0d79d79071b4bb6dea46e645eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQwMjI3NQ==", "url": "https://github.com/apache/beam/pull/13048#discussion_r514402275", "bodyText": "CombineFn's teardown is similar to DoFn's teardown, which does not guarantee that the call will happen. We should expect the same from CombineFn's teardown.", "author": "kamilwu", "createdAt": "2020-10-29T16:35:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY2NjIwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ1MjUxMQ==", "url": "https://github.com/apache/beam/pull/13048#discussion_r514452511", "bodyText": "SGTM.", "author": "yifanmai", "createdAt": "2020-10-29T17:48:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY2NjIwMA=="}], "type": "inlineReview"}, {"oid": "31e5bc3985762e8b7ec7c0942531025a584a400f", "url": "https://github.com/apache/beam/commit/31e5bc3985762e8b7ec7c0942531025a584a400f", "message": "fix: review changes", "committedDate": "2020-10-29T16:36:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NTcxMg==", "url": "https://github.com/apache/beam/pull/13048#discussion_r516395712", "bodyText": "nit: prefer using () to line continuation token.", "author": "tvalentyn", "createdAt": "2020-11-03T02:21:29Z", "path": "sdks/python/apache_beam/transforms/core.py", "diffHunk": "@@ -1975,10 +1990,13 @@ def add_input_types(transform):\n       return combined\n \n     if self.has_defaults:\n-      combine_fn = (\n-          self.fn if isinstance(self.fn, CombineFn) else\n-          CombineFn.from_callable(self.fn))\n-      default_value = combine_fn.apply([], *self.args, **self.kwargs)\n+      combine_fn = copy.deepcopy(self.fn) if isinstance(self.fn, CombineFn) \\", "originalCommit": "31e5bc3985762e8b7ec7c0942531025a584a400f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NzMzMQ==", "url": "https://github.com/apache/beam/pull/13048#discussion_r516397331", "bodyText": "@robertwb do you see any concerns with adding a top level finalize method here?", "author": "tvalentyn", "createdAt": "2020-11-03T02:28:50Z", "path": "sdks/python/apache_beam/transforms/userstate.py", "diffHunk": "@@ -357,6 +357,10 @@ def prefetch(self):\n     # The default implementation here does nothing.\n     pass\n \n+  def finalize(self):", "originalCommit": "31e5bc3985762e8b7ec7c0942531025a584a400f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzUzNjc5OA==", "url": "https://github.com/apache/beam/pull/13048#discussion_r517536798", "bodyText": "This is fine .", "author": "robertwb", "createdAt": "2020-11-04T18:10:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5NzMzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM5ODE5NQ==", "url": "https://github.com/apache/beam/pull/13048#discussion_r516398195", "bodyText": "nit: prefer to use () instead of \\ .", "author": "tvalentyn", "createdAt": "2020-11-03T02:32:36Z", "path": "sdks/python/apache_beam/runners/dataflow/dataflow_runner.py", "diffHunk": "@@ -411,6 +411,33 @@ def visit_transform(self, transform_node):\n \n     return FlattenInputVisitor()\n \n+  @staticmethod\n+  def combinefn_visitor():\n+    # Imported here to avoid circular dependencies.\n+    from apache_beam.pipeline import PipelineVisitor\n+    from apache_beam import core\n+\n+    class CombineFnVisitor(PipelineVisitor):\n+      \"\"\"Checks if `CombineFn` has non-default setup or teardown methods.\n+      If yes, raises `ValueError`.\n+      \"\"\"\n+      def visit_transform(self, applied_transform):\n+        transform = applied_transform.transform\n+        if isinstance(transform, core.ParDo) and isinstance(\n+            transform.fn, core.CombineValuesDoFn):\n+          if self._overrides_setup_or_teardown(transform.fn.combinefn):\n+            raise ValueError(\n+                'CombineFn.setup and CombineFn.teardown are '\n+                'not supported with non-portable Dataflow '\n+                'runner. Please use Dataflow Runner V2 instead.')\n+\n+      @staticmethod\n+      def _overrides_setup_or_teardown(combinefn):\n+        return combinefn.__class__.setup is not core.CombineFn.setup or \\", "originalCommit": "31e5bc3985762e8b7ec7c0942531025a584a400f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e8113260214407e6ac71b59dcfc8e1dd43862f28", "url": "https://github.com/apache/beam/commit/e8113260214407e6ac71b59dcfc8e1dd43862f28", "message": "[BEAM-3736] Add CombineFn.setup and CombineFn.teardown to Python SDK", "committedDate": "2020-11-03T11:55:10Z", "type": "forcePushed"}, {"oid": "e3326d1fd235dd80f00c65489dd7e1b31cf87ce1", "url": "https://github.com/apache/beam/commit/e3326d1fd235dd80f00c65489dd7e1b31cf87ce1", "message": "[BEAM-3736] Add CombineFn.setup and CombineFn.teardown to Python SDK", "committedDate": "2020-11-03T14:26:48Z", "type": "commit"}, {"oid": "e3326d1fd235dd80f00c65489dd7e1b31cf87ce1", "url": "https://github.com/apache/beam/commit/e3326d1fd235dd80f00c65489dd7e1b31cf87ce1", "message": "[BEAM-3736] Add CombineFn.setup and CombineFn.teardown to Python SDK", "committedDate": "2020-11-03T14:26:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzczMTA3NA==", "url": "https://github.com/apache/beam/pull/13048#discussion_r517731074", "bodyText": "I think this would fail the Dataflow V1 check as well.\nI thought of possible improvement of the check bad0a52 (#13267) and this call would cause an issue.", "author": "tvalentyn", "createdAt": "2020-11-05T01:37:37Z", "path": "sdks/python/apache_beam/transforms/combiners.py", "diffHunk": "@@ -700,6 +700,9 @@ def __init__(self, n):\n     # helper instead.\n     self._top_combiner = TopCombineFn(n)\n \n+  def setup(self):\n+    self._top_combiner.setup()", "originalCommit": "e3326d1fd235dd80f00c65489dd7e1b31cf87ce1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}