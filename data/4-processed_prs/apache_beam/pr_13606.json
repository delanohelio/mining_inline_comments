{"pr_number": 13606, "pr_title": "[BEAM-11519] Adding PYPI_INSTALL_REQ role and SDK container support", "pr_createdAt": "2020-12-23T10:15:11Z", "pr_url": "https://github.com/apache/beam/pull/13606", "timeline": [{"oid": "020d175a59e009dc700a6792cbe9b8e5f97128dc", "url": "https://github.com/apache/beam/commit/020d175a59e009dc700a6792cbe9b8e5f97128dc", "message": "[BEAM-11519] Adding PYPI_INSTALL_REQ role and SDK container support", "committedDate": "2020-12-23T21:32:00Z", "type": "forcePushed"}, {"oid": "8da6a6c3b30a4d64a4f920021f98dbbfb16172d6", "url": "https://github.com/apache/beam/commit/8da6a6c3b30a4d64a4f920021f98dbbfb16172d6", "message": "[BEAM-11519] Adding PYPI_INSTALL_REQ role and SDK container support", "committedDate": "2021-01-09T04:18:15Z", "type": "commit"}, {"oid": "8da6a6c3b30a4d64a4f920021f98dbbfb16172d6", "url": "https://github.com/apache/beam/commit/8da6a6c3b30a4d64a4f920021f98dbbfb16172d6", "message": "[BEAM-11519] Adding PYPI_INSTALL_REQ role and SDK container support", "committedDate": "2021-01-09T04:18:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkzNDU1OA==", "url": "https://github.com/apache/beam/pull/13606#discussion_r556934558", "bodyText": "Please move this line to just above the generateId function. Go style doesn't require package variables to be declared at the top of the file.\nPlease also add a comment why we need a global counter variable.", "author": "lostluck", "createdAt": "2021-01-13T23:01:08Z", "path": "sdks/go/pkg/beam/artifact/materialize.go", "diffHunk": "@@ -39,27 +42,31 @@ import (\n \n // TODO(lostluck): 2018/05/28 Extract these from their enum descriptors in the pipeline_v1 proto\n const (\n+\tURNFileArtifact   = \"beam:artifact:type:file:v1\"\n+\tURNPypiInstallReq = \"beam:artifact:role:pypi_install_req:v1\"\n \tURNStagingTo      = \"beam:artifact:role:staging_to:v1\"\n \tNoArtifactsStaged = \"__no_artifacts_staged__\"\n )\n \n+var idCounter uint64", "originalCommit": "8da6a6c3b30a4d64a4f920021f98dbbfb16172d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc0MzkyNQ==", "url": "https://github.com/apache/beam/pull/13606#discussion_r557743925", "bodyText": "Done.", "author": "ihji", "createdAt": "2021-01-14T22:36:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkzNDU1OA=="}], "type": "inlineReview"}, {"oid": "7cb569183d96ed6461a3dca6d72980d98edcbede", "url": "https://github.com/apache/beam/commit/7cb569183d96ed6461a3dca6d72980d98edcbede", "message": "move idCounter variable and add comments", "committedDate": "2021-01-14T21:29:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQwOTI1NQ==", "url": "https://github.com/apache/beam/pull/13606#discussion_r560409255", "bodyText": "Let's spell out requirements here.", "author": "robertwb", "createdAt": "2021-01-19T18:55:15Z", "path": "model/pipeline/src/main/proto/beam_runner_api.proto", "diffHunk": "@@ -1342,7 +1342,11 @@ message StandardArtifacts {\n   enum Roles {\n     // A URN for staging-to role.\n     // payload: ArtifactStagingToRolePayload\n-    STAGING_TO  = 0 [(beam_urn) = \"beam:artifact:role:staging_to:v1\"];\n+    STAGING_TO        = 0 [(beam_urn) = \"beam:artifact:role:staging_to:v1\"];\n+\n+    // A URN for pypi-install-req role.\n+    // payload: None\n+    PYPI_INSTALL_REQ  = 1 [(beam_urn) = \"beam:artifact:role:pypi_install_req:v1\"];", "originalCommit": "7cb569183d96ed6461a3dca6d72980d98edcbede", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk5MjgwNA==", "url": "https://github.com/apache/beam/pull/13606#discussion_r562992804", "bodyText": "Done.", "author": "ihji", "createdAt": "2021-01-23T01:07:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQwOTI1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQxMTc0Ng==", "url": "https://github.com/apache/beam/pull/13606#discussion_r560411746", "bodyText": "Nit: I'd put this case, which is kind of like a default/everything else, last. Also, do we know this always works, or should we throw an error on unknown types?", "author": "robertwb", "createdAt": "2021-01-19T18:59:01Z", "path": "sdks/go/pkg/beam/artifact/materialize.go", "diffHunk": "@@ -69,41 +74,100 @@ func newMaterialize(ctx context.Context, endpoint string, dependencies []*pipepb\n \treturn newMaterializeWithClient(ctx, jobpb.NewArtifactRetrievalServiceClient(cc), dependencies, dest)\n }\n \n-func newMaterializeWithClient(ctx context.Context, client jobpb.ArtifactRetrievalServiceClient, dependencies []*pipepb.ArtifactInformation, dest string) ([]*jobpb.ArtifactMetadata, error) {\n+func newMaterializeWithClient(ctx context.Context, client jobpb.ArtifactRetrievalServiceClient, dependencies []*pipepb.ArtifactInformation, dest string) ([]*pipepb.ArtifactInformation, error) {\n \tresolution, err := client.ResolveArtifacts(ctx, &jobpb.ResolveArtifactsRequest{Artifacts: dependencies})\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\tvar md []*jobpb.ArtifactMetadata\n+\tvar artifacts []*pipepb.ArtifactInformation\n \tvar list []retrievable\n \tfor _, dep := range resolution.Replacements {\n \t\tpath, err := extractStagingToPath(dep)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n-\t\tmd = append(md, &jobpb.ArtifactMetadata{\n-\t\t\tName: path,\n+\t\tvar filePayload pipepb.ArtifactFilePayload\n+\t\tif dep.TypeUrn != URNFileArtifact {", "originalCommit": "7cb569183d96ed6461a3dca6d72980d98edcbede", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQxNDUzOA==", "url": "https://github.com/apache/beam/pull/13606#discussion_r560414538", "bodyText": "Actually, this might be clearer constructing filePayload unconditionally based on Path, and then iff TypeUrn is URNFileArtifact, additionally setting the Sha256 attribute, if any.", "author": "robertwb", "createdAt": "2021-01-19T19:03:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQxMTc0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk5Mjg1MQ==", "url": "https://github.com/apache/beam/pull/13606#discussion_r562992851", "bodyText": "Done.", "author": "ihji", "createdAt": "2021-01-23T01:07:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQxMTc0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQxNjI4Ng==", "url": "https://github.com/apache/beam/pull/13606#discussion_r560416286", "bodyText": "Guard this with artifact.TypeUrn is URNFileArtifact? And a final else that's an error?", "author": "robertwb", "createdAt": "2021-01-19T19:06:22Z", "path": "sdks/go/pkg/beam/artifact/materialize.go", "diffHunk": "@@ -69,41 +74,100 @@ func newMaterialize(ctx context.Context, endpoint string, dependencies []*pipepb\n \treturn newMaterializeWithClient(ctx, jobpb.NewArtifactRetrievalServiceClient(cc), dependencies, dest)\n }\n \n-func newMaterializeWithClient(ctx context.Context, client jobpb.ArtifactRetrievalServiceClient, dependencies []*pipepb.ArtifactInformation, dest string) ([]*jobpb.ArtifactMetadata, error) {\n+func newMaterializeWithClient(ctx context.Context, client jobpb.ArtifactRetrievalServiceClient, dependencies []*pipepb.ArtifactInformation, dest string) ([]*pipepb.ArtifactInformation, error) {\n \tresolution, err := client.ResolveArtifacts(ctx, &jobpb.ResolveArtifactsRequest{Artifacts: dependencies})\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\tvar md []*jobpb.ArtifactMetadata\n+\tvar artifacts []*pipepb.ArtifactInformation\n \tvar list []retrievable\n \tfor _, dep := range resolution.Replacements {\n \t\tpath, err := extractStagingToPath(dep)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n-\t\tmd = append(md, &jobpb.ArtifactMetadata{\n-\t\t\tName: path,\n+\t\tvar filePayload pipepb.ArtifactFilePayload\n+\t\tif dep.TypeUrn != URNFileArtifact {\n+\t\t\tfilePayload = pipepb.ArtifactFilePayload{\n+\t\t\t\tPath: path,\n+\t\t\t}\n+\t\t} else {\n+\t\t\ttypePayload := pipepb.ArtifactFilePayload{}\n+\t\t\tif err := proto.Unmarshal(dep.TypePayload, &typePayload); err != nil {\n+\t\t\t\treturn nil, errors.Wrap(err, \"failed to parse artifact file payload\")\n+\t\t\t}\n+\t\t\tfilePayload = pipepb.ArtifactFilePayload{\n+\t\t\t\tPath:   path,\n+\t\t\t\tSha256: typePayload.Sha256,\n+\t\t\t}\n+\t\t}\n+\t\tnewTypePayload, err := proto.Marshal(&filePayload)\n+\t\tif err != nil {\n+\t\t\treturn nil, errors.Wrap(err, \"failed to create artifact type payload\")\n+\t\t}\n+\t\tartifacts = append(artifacts, &pipepb.ArtifactInformation{\n+\t\t\tTypeUrn:     URNFileArtifact,\n+\t\t\tTypePayload: newTypePayload,\n+\t\t\tRoleUrn:     dep.RoleUrn,\n+\t\t\tRolePayload: dep.RolePayload,\n \t\t})\n \n+\t\trolePayload, err := proto.Marshal(&pipepb.ArtifactStagingToRolePayload{\n+\t\t\tStagedName: path,\n+\t\t})\n+\t\tif err != nil {\n+\t\t\treturn nil, errors.Wrap(err, \"failed to create artifact role payload\")\n+\t\t}\n \t\tlist = append(list, &artifact{\n \t\t\tclient: client,\n-\t\t\tdep:    dep,\n+\t\t\tdep: &pipepb.ArtifactInformation{\n+\t\t\t\tTypeUrn:     dep.TypeUrn,\n+\t\t\t\tTypePayload: dep.TypePayload,\n+\t\t\t\tRoleUrn:     URNStagingTo,\n+\t\t\t\tRolePayload: rolePayload,\n+\t\t\t},\n \t\t})\n \t}\n \n-\treturn md, MultiRetrieve(ctx, 10, list, dest)\n+\treturn artifacts, MultiRetrieve(ctx, 10, list, dest)\n+}\n+\n+// Used for generating unique IDs. We assign uniquely generated names to staged files without staging names.\n+var idCounter uint64\n+\n+func generateId() string {\n+\tid := atomic.AddUint64(&idCounter, 1)\n+\treturn strconv.FormatUint(id, 10)\n }\n \n func extractStagingToPath(artifact *pipepb.ArtifactInformation) (string, error) {\n-\tif artifact.RoleUrn != URNStagingTo {\n-\t\treturn \"\", errors.Errorf(\"Unsupported artifact role %s\", artifact.RoleUrn)\n+\tvar stagedName string\n+\tif artifact.RoleUrn == URNStagingTo {\n+\t\trole := pipepb.ArtifactStagingToRolePayload{}\n+\t\tif err := proto.Unmarshal(artifact.RolePayload, &role); err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t\tstagedName = role.StagedName\n+\t} else {", "originalCommit": "7cb569183d96ed6461a3dca6d72980d98edcbede", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk5MjkzOA==", "url": "https://github.com/apache/beam/pull/13606#discussion_r562992938", "bodyText": "Done. That looks better. Thanks.", "author": "ihji", "createdAt": "2021-01-23T01:07:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQxNjI4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQxNzY5MQ==", "url": "https://github.com/apache/beam/pull/13606#discussion_r560417691", "bodyText": "Do you know what the state is of getting rid of the legacy protocol altogether?", "author": "robertwb", "createdAt": "2021-01-19T19:08:48Z", "path": "sdks/go/pkg/beam/artifact/materialize.go", "diffHunk": "@@ -172,7 +236,7 @@ func writeChunks(stream jobpb.ArtifactRetrievalService_GetArtifactClient, w io.W\n \treturn nil\n }\n \n-func legacyMaterialize(ctx context.Context, endpoint string, rt string, dest string) ([]*jobpb.ArtifactMetadata, error) {\n+func legacyMaterialize(ctx context.Context, endpoint string, rt string, dest string) ([]*pipepb.ArtifactInformation, error) {", "originalCommit": "7cb569183d96ed6461a3dca6d72980d98edcbede", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk5NDg1NQ==", "url": "https://github.com/apache/beam/pull/13606#discussion_r562994855", "bodyText": "I think the artifact server for Dataflow still uses legacy protocol.", "author": "ihji", "createdAt": "2021-01-23T01:18:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQxNzY5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQ0ODIxMg==", "url": "https://github.com/apache/beam/pull/13606#discussion_r560448212", "bodyText": "Perhaps for compactness?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tvar filePayload pipepb.ArtifactFilePayload\n          \n          \n            \n            \t\tif dep.TypeUrn != URNFileArtifact {\n          \n          \n            \n            \t\t\tfilePayload = pipepb.ArtifactFilePayload{\n          \n          \n            \n            \t\t\t\tPath: path,\n          \n          \n            \n            \t\t\t}\n          \n          \n            \n            \t\t} else {\n          \n          \n            \n            \t\t\ttypePayload := pipepb.ArtifactFilePayload{}\n          \n          \n            \n            \t\t\tif err := proto.Unmarshal(dep.TypePayload, &typePayload); err != nil {\n          \n          \n            \n            \t\t\t\treturn nil, errors.Wrap(err, \"failed to parse artifact file payload\")\n          \n          \n            \n            \t\t\t}\n          \n          \n            \n            \t\t\tfilePayload = pipepb.ArtifactFilePayload{\n          \n          \n            \n            \t\t\t\tPath:   path,\n          \n          \n            \n            \t\t\t\tSha256: typePayload.Sha256,\n          \n          \n            \n            \t\t\t}\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \t\tfilePayload := pipepb.ArtifactFilePayload{\n          \n          \n            \n            \t\t\t\tPath: path,\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \t\tif dep.TypeUrn == URNFileArtifact {\n          \n          \n            \n            \t\t\ttypePayload := pipepb.ArtifactFilePayload{}\n          \n          \n            \n            \t\t\tif err := proto.Unmarshal(dep.TypePayload, &typePayload); err != nil {\n          \n          \n            \n            \t\t\t\treturn nil, errors.Wrap(err, \"failed to parse artifact file payload\")\n          \n          \n            \n            \t\t\t}\n          \n          \n            \n            \t\t\tfilePayload.Sha256 = typePayload.Sha256\n          \n          \n            \n            \t\t}\n          \n      \n    \n    \n  \n\nIf you'd like me go go full readability on you, WRT protos, it's the same either way whether you pre-declare as a pointer type or not. You do not need to dereference to access fields on a pointer to a struct, and escape analysis will determine whether to allocate values to the heap, regardless of if they are pointers or not. If a pointer value never escapes the stack, then it will be stack allocated.\nSo the following is identical.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tvar filePayload pipepb.ArtifactFilePayload\n          \n          \n            \n            \t\tif dep.TypeUrn != URNFileArtifact {\n          \n          \n            \n            \t\t\tfilePayload = pipepb.ArtifactFilePayload{\n          \n          \n            \n            \t\t\t\tPath: path,\n          \n          \n            \n            \t\t\t}\n          \n          \n            \n            \t\t} else {\n          \n          \n            \n            \t\t\ttypePayload := pipepb.ArtifactFilePayload{}\n          \n          \n            \n            \t\t\tif err := proto.Unmarshal(dep.TypePayload, &typePayload); err != nil {\n          \n          \n            \n            \t\t\t\treturn nil, errors.Wrap(err, \"failed to parse artifact file payload\")\n          \n          \n            \n            \t\t\t}\n          \n          \n            \n            \t\t\tfilePayload = pipepb.ArtifactFilePayload{\n          \n          \n            \n            \t\t\t\tPath:   path,\n          \n          \n            \n            \t\t\t\tSha256: typePayload.Sha256,\n          \n          \n            \n            \t\t\t}\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \t\tfilePayload := &pipepb.ArtifactFilePayload{\n          \n          \n            \n            \t\t\t\tPath: path,\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \t\tif dep.TypeUrn == URNFileArtifact {\n          \n          \n            \n            \t\t\ttypePayload := &pipepb.ArtifactFilePayload{}\n          \n          \n            \n            \t\t\tif err := proto.Unmarshal(dep.TypePayload, typePayload); err != nil {\n          \n          \n            \n            \t\t\t\treturn nil, errors.Wrap(err, \"failed to parse artifact file payload\")\n          \n          \n            \n            \t\t\t}\n          \n          \n            \n            \t\t\tfilePayload.Sha256 = typePayload.Sha256\n          \n          \n            \n            \t\t}\n          \n      \n    \n    \n  \n\n(though the remaining &s will need to be removed as appropriate.", "author": "lostluck", "createdAt": "2021-01-19T19:59:21Z", "path": "sdks/go/pkg/beam/artifact/materialize.go", "diffHunk": "@@ -69,41 +74,100 @@ func newMaterialize(ctx context.Context, endpoint string, dependencies []*pipepb\n \treturn newMaterializeWithClient(ctx, jobpb.NewArtifactRetrievalServiceClient(cc), dependencies, dest)\n }\n \n-func newMaterializeWithClient(ctx context.Context, client jobpb.ArtifactRetrievalServiceClient, dependencies []*pipepb.ArtifactInformation, dest string) ([]*jobpb.ArtifactMetadata, error) {\n+func newMaterializeWithClient(ctx context.Context, client jobpb.ArtifactRetrievalServiceClient, dependencies []*pipepb.ArtifactInformation, dest string) ([]*pipepb.ArtifactInformation, error) {\n \tresolution, err := client.ResolveArtifacts(ctx, &jobpb.ResolveArtifactsRequest{Artifacts: dependencies})\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\tvar md []*jobpb.ArtifactMetadata\n+\tvar artifacts []*pipepb.ArtifactInformation\n \tvar list []retrievable\n \tfor _, dep := range resolution.Replacements {\n \t\tpath, err := extractStagingToPath(dep)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n-\t\tmd = append(md, &jobpb.ArtifactMetadata{\n-\t\t\tName: path,\n+\t\tvar filePayload pipepb.ArtifactFilePayload\n+\t\tif dep.TypeUrn != URNFileArtifact {\n+\t\t\tfilePayload = pipepb.ArtifactFilePayload{\n+\t\t\t\tPath: path,\n+\t\t\t}\n+\t\t} else {\n+\t\t\ttypePayload := pipepb.ArtifactFilePayload{}\n+\t\t\tif err := proto.Unmarshal(dep.TypePayload, &typePayload); err != nil {\n+\t\t\t\treturn nil, errors.Wrap(err, \"failed to parse artifact file payload\")\n+\t\t\t}\n+\t\t\tfilePayload = pipepb.ArtifactFilePayload{\n+\t\t\t\tPath:   path,\n+\t\t\t\tSha256: typePayload.Sha256,\n+\t\t\t}\n+\t\t}", "originalCommit": "7cb569183d96ed6461a3dca6d72980d98edcbede", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk5NDk1NQ==", "url": "https://github.com/apache/beam/pull/13606#discussion_r562994955", "bodyText": "Done. Thanks for the readability review.", "author": "ihji", "createdAt": "2021-01-23T01:19:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQ0ODIxMg=="}], "type": "inlineReview"}, {"oid": "c2b7fbafb5020aa6b96fbc7cfcc70422facbd063", "url": "https://github.com/apache/beam/commit/c2b7fbafb5020aa6b96fbc7cfcc70422facbd063", "message": "simplify the branches, change _req to _requirement", "committedDate": "2021-01-23T00:55:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTg4NTI5Nw==", "url": "https://github.com/apache/beam/pull/13606#discussion_r569885297", "bodyText": "It's unclear here whether this is for requirements.txt files or actual tarballs that should be installed.\nCould we call this either PYTHON_PACKAGES or PIP_REQUIREMENTS_FILE?", "author": "robertwb", "createdAt": "2021-02-04T01:48:17Z", "path": "model/pipeline/src/main/proto/beam_runner_api.proto", "diffHunk": "@@ -1342,7 +1342,11 @@ message StandardArtifacts {\n   enum Roles {\n     // A URN for staging-to role.\n     // payload: ArtifactStagingToRolePayload\n-    STAGING_TO  = 0 [(beam_urn) = \"beam:artifact:role:staging_to:v1\"];\n+    STAGING_TO        = 0 [(beam_urn) = \"beam:artifact:role:staging_to:v1\"];\n+\n+    // A URN for pypi-install-requirement role.\n+    // payload: None\n+    PYPI_INSTALL_REQUIREMENT  = 1 [(beam_urn) = \"beam:artifact:role:pypi_install_requirement:v1\"];", "originalCommit": "c2b7fbafb5020aa6b96fbc7cfcc70422facbd063", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTkxNDA3Ng==", "url": "https://github.com/apache/beam/pull/13606#discussion_r569914076", "bodyText": "Use PIP_REQUIREMENTS_FILE instead of PYPI_INSTALL_REQUIREMENT", "author": "ihji", "createdAt": "2021-02-04T03:06:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTg4NTI5Nw=="}], "type": "inlineReview"}, {"oid": "715bcd0f06fe2a10c0765086553252a1b8d99648", "url": "https://github.com/apache/beam/commit/715bcd0f06fe2a10c0765086553252a1b8d99648", "message": "change urn for pip install requirements file", "committedDate": "2021-02-04T03:05:13Z", "type": "commit"}]}