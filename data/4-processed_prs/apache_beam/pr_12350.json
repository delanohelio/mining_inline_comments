{"pr_number": 12350, "pr_title": "[BEAM-10289] Dynamic splitting implementation.", "pr_createdAt": "2020-07-23T04:18:07Z", "pr_url": "https://github.com/apache/beam/pull/12350", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcyMTgyNg==", "url": "https://github.com/apache/beam/pull/12350#discussion_r459721826", "bodyText": "Consider inverting the if statement.  There's only 2 lines after this if statement, and 30 inside it. While it might mean the s.splitIdx assignment, and the SplitResult construction areduplicated, it will be easier to read the other way.", "author": "lostluck", "createdAt": "2020-07-23T20:53:52Z", "path": "sdks/go/pkg/beam/core/runtime/exec/datasource.go", "diffHunk": "@@ -302,31 +302,67 @@ func (n *DataSource) Split(splits []int64, frac float64, bufSize int64) (int64,\n \t}\n \n \tn.mu.Lock()\n+\tdefer n.mu.Unlock()\n+\n \tvar currProg float64 // Current element progress.\n-\tif n.index < 0 {     // Progress is at the end of the non-existant -1st element.\n+\tvar su SplittableUnit\n+\tif n.index < 0 { // Progress is at the end of the non-existant -1st element.\n \t\tcurrProg = 1.0\n-\t} else if n.rt == nil { // If this isn't sub-element splittable, estimate some progress.\n+\t} else if n.su == nil { // If this isn't sub-element splittable, estimate some progress.\n \t\tcurrProg = 0.5\n \t} else { // If this is sub-element splittable, get progress of the current element.\n-\t\trt := <-n.rt\n-\t\td, r := rt.GetProgress()\n-\t\tcurrProg = d / (d + r)\n-\t\tn.rt <- rt\n+\t\t// If splittable, hold this tracker for the rest of the function so the element\n+\t\t// doesn't finish processing during a split.\n+\t\tsu = <-n.su\n+\t\tif su == nil {\n+\t\t\treturn SplitResult{}, fmt.Errorf(\"failed to split: splittable unit was nil\")\n+\t\t}\n+\t\tdefer func() {\n+\t\t\tn.su <- su\n+\t\t}()\n+\t\tcurrProg = su.GetProgress()\n \t}\n \t// Size to split within is the minimum of bufSize or splitIdx so we avoid\n \t// including elements we already know won't be processed.\n \tif bufSize <= 0 || n.splitIdx < bufSize {\n \t\tbufSize = n.splitIdx\n \t}\n-\ts, _, err := splitHelper(n.index, bufSize, currProg, splits, frac, false)\n+\ts, f, err := splitHelper(n.index, bufSize, currProg, splits, frac, su != nil)\n \tif err != nil {\n-\t\tn.mu.Unlock()\n-\t\treturn 0, err\n+\t\treturn SplitResult{}, err\n+\t}\n+\tif f > 0.0 {", "originalCommit": "7baba5bf65a7afabdfb863321bc41d744e282d28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg0ODAwMQ==", "url": "https://github.com/apache/beam/pull/12350#discussion_r459848001", "bodyText": "Sounds good to me. Done.", "author": "youngoli", "createdAt": "2020-07-24T04:37:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcyMTgyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcyNzE3MA==", "url": "https://github.com/apache/beam/pull/12350#discussion_r459727170", "bodyText": "Constructing the encoders every split request is expensive, so we're best off creating those ahead of time, even if they aren't necessarily going to be used every time. Unlike on the main ProcessElement path, we can't just keep the encoders around in a function scope, so we'll have to just add it to the Source. But we can just construct them on demand at least, which is much cheaper than repeatedly constructing them.\nAt the very least, ideally we reuse them between the Primary and the Residual. It's likely just noise for the repeated constructions for Successful splits, but we might as well do half as much work.\nIn short, we should wait until we see this coder construction in a CPU profile before the heavier caching is applied, but we definitely should avoid the double work here.", "author": "lostluck", "createdAt": "2020-07-23T21:04:18Z", "path": "sdks/go/pkg/beam/core/runtime/exec/datasource.go", "diffHunk": "@@ -302,31 +302,67 @@ func (n *DataSource) Split(splits []int64, frac float64, bufSize int64) (int64,\n \t}\n \n \tn.mu.Lock()\n+\tdefer n.mu.Unlock()\n+\n \tvar currProg float64 // Current element progress.\n-\tif n.index < 0 {     // Progress is at the end of the non-existant -1st element.\n+\tvar su SplittableUnit\n+\tif n.index < 0 { // Progress is at the end of the non-existant -1st element.\n \t\tcurrProg = 1.0\n-\t} else if n.rt == nil { // If this isn't sub-element splittable, estimate some progress.\n+\t} else if n.su == nil { // If this isn't sub-element splittable, estimate some progress.\n \t\tcurrProg = 0.5\n \t} else { // If this is sub-element splittable, get progress of the current element.\n-\t\trt := <-n.rt\n-\t\td, r := rt.GetProgress()\n-\t\tcurrProg = d / (d + r)\n-\t\tn.rt <- rt\n+\t\t// If splittable, hold this tracker for the rest of the function so the element\n+\t\t// doesn't finish processing during a split.\n+\t\tsu = <-n.su\n+\t\tif su == nil {\n+\t\t\treturn SplitResult{}, fmt.Errorf(\"failed to split: splittable unit was nil\")\n+\t\t}\n+\t\tdefer func() {\n+\t\t\tn.su <- su\n+\t\t}()\n+\t\tcurrProg = su.GetProgress()\n \t}\n \t// Size to split within is the minimum of bufSize or splitIdx so we avoid\n \t// including elements we already know won't be processed.\n \tif bufSize <= 0 || n.splitIdx < bufSize {\n \t\tbufSize = n.splitIdx\n \t}\n-\ts, _, err := splitHelper(n.index, bufSize, currProg, splits, frac, false)\n+\ts, f, err := splitHelper(n.index, bufSize, currProg, splits, frac, su != nil)\n \tif err != nil {\n-\t\tn.mu.Unlock()\n-\t\treturn 0, err\n+\t\treturn SplitResult{}, err\n+\t}\n+\tif f > 0.0 {\n+\t\tfr := f / (1.0 - currProg)\n+\t\tp, r, err := su.Split(fr)\n+\t\tif err != nil {\n+\t\t\treturn SplitResult{}, err\n+\t\t}\n+\n+\t\tif p != nil && r != nil { // Successful split.\n+\t\t\tpEnc, err := encodeElm(p, n.Coder)\n+\t\t\tif err != nil {\n+\t\t\t\treturn SplitResult{}, err\n+\t\t\t}\n+\t\t\trEnc, err := encodeElm(r, n.Coder)", "originalCommit": "7baba5bf65a7afabdfb863321bc41d744e282d28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg1MDgwMQ==", "url": "https://github.com/apache/beam/pull/12350#discussion_r459850801", "bodyText": "Good point. Done.", "author": "youngoli", "createdAt": "2020-07-24T04:51:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcyNzE3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczNTkwNQ==", "url": "https://github.com/apache/beam/pull/12350#discussion_r459735905", "bodyText": "Copy Pasta?", "author": "lostluck", "createdAt": "2020-07-23T21:23:02Z", "path": "sdks/go/pkg/beam/core/runtime/exec/translate.go", "diffHunk": "@@ -418,7 +418,8 @@ func (b *builder) makeLink(from string, id linkID) (Node, error) {\n \t\t\t\t\t}\n \t\t\t\t\tu = n\n \t\t\t\t\tif urn == urnProcessSizedElementsAndRestrictions {\n-\t\t\t\t\t\tu = &ProcessSizedElementsAndRestrictions{PDo: n}\n+\t\t\t\t\t\ttransform.GetInputs()", "originalCommit": "7baba5bf65a7afabdfb863321bc41d744e282d28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg0MTQ3Mw==", "url": "https://github.com/apache/beam/pull/12350#discussion_r459841473", "bodyText": "Something like that. Definitely not supposed to be there. Removed.", "author": "youngoli", "createdAt": "2020-07-24T04:00:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczNTkwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczODk0Mw==", "url": "https://github.com/apache/beam/pull/12350#discussion_r459738943", "bodyText": "Here's another opportunity to invert the statement for clarity.\neg.\nif r == nil {\nreturn nil, nil, nil\n}\nrest of the function.", "author": "lostluck", "createdAt": "2020-07-23T21:29:42Z", "path": "sdks/go/pkg/beam/core/runtime/exec/sdf.go", "diffHunk": "@@ -325,6 +337,63 @@ func (n *ProcessSizedElementsAndRestrictions) String() string {\n \treturn fmt.Sprintf(\"SDF.ProcessSizedElementsAndRestrictions[%v] UID:%v Out:%v\", path.Base(n.PDo.Fn.Name()), n.PDo.ID(), IDs(n.PDo.Out...))\n }\n \n+type SplittableUnit interface {\n+\tSplit(fraction float64) (primary, residual *FullValue, err error)\n+\tGetProgress() float64\n+\tGetTransformId() string\n+\tGetMainInputId() string\n+}\n+\n+func (n *ProcessSizedElementsAndRestrictions) Split(f float64) (*FullValue, *FullValue, error) {\n+\tif n.rt == nil {\n+\t\terr := errors.New(\"Restriction tracker missing.\")\n+\t\treturn nil, nil, errors.WithContext(err, \"Attempting split in ProcessSizedElementsAndRestrictions\")\n+\t}\n+\tp, r, err := n.rt.TrySplit(f)\n+\tif err != nil {\n+\t\treturn nil, nil, errors.WithContext(err, \"Attempting split in ProcessSizedElementsAndRestrictions\")\n+\t}\n+\n+\tvar pfv, rfv *FullValue\n+\tif r != nil { // If r is nil then the split failed/returned an empty residual.", "originalCommit": "7baba5bf65a7afabdfb863321bc41d744e282d28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg1MTI2NA==", "url": "https://github.com/apache/beam/pull/12350#discussion_r459851264", "bodyText": "Agreed, done.", "author": "youngoli", "createdAt": "2020-07-24T04:53:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczODk0Mw=="}], "type": "inlineReview"}, {"oid": "24a05d9433fd90be3e5961650dfa3e6ecb9e4337", "url": "https://github.com/apache/beam/commit/24a05d9433fd90be3e5961650dfa3e6ecb9e4337", "message": "[BEAM-10289] Dynamic splitting full implementation.\n\nIncludes documentation and tests.", "committedDate": "2020-07-28T07:12:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ0NTc5OA==", "url": "https://github.com/apache/beam/pull/12350#discussion_r462445798", "bodyText": "Consider that reversal technique I mentioned, so the short case is what's indented and returns early, and the long case is unindented.\nif p == nil || r == nil  {\n\t       // Fallback to channel split, so split at next elm, not current.\n\t\tn.splitIdx = s + 1\n\t\treturn SplitResult{PI: s, RI: s + 1}, nil\n}  // no need for an else.\n// .. the original contents of the if block ...", "author": "lostluck", "createdAt": "2020-07-29T16:54:56Z", "path": "sdks/go/pkg/beam/core/runtime/exec/datasource.go", "diffHunk": "@@ -302,31 +308,76 @@ func (n *DataSource) Split(splits []int64, frac float64, bufSize int64) (int64,\n \t}\n \n \tn.mu.Lock()\n+\tdefer n.mu.Unlock()\n+\n \tvar currProg float64 // Current element progress.\n-\tif n.index < 0 {     // Progress is at the end of the non-existant -1st element.\n+\tvar su SplittableUnit\n+\tif n.index < 0 { // Progress is at the end of the non-existant -1st element.\n \t\tcurrProg = 1.0\n-\t} else if n.rt == nil { // If this isn't sub-element splittable, estimate some progress.\n+\t} else if n.su == nil { // If this isn't sub-element splittable, estimate some progress.\n \t\tcurrProg = 0.5\n \t} else { // If this is sub-element splittable, get progress of the current element.\n-\t\trt := <-n.rt\n-\t\td, r := rt.GetProgress()\n-\t\tcurrProg = d / (d + r)\n-\t\tn.rt <- rt\n+\t\t// If splittable, hold this tracker for the rest of the function so the element\n+\t\t// doesn't finish processing during a split.\n+\t\tsu = <-n.su\n+\t\tif su == nil {\n+\t\t\treturn SplitResult{}, fmt.Errorf(\"failed to split: splittable unit was nil\")\n+\t\t}\n+\t\tdefer func() {\n+\t\t\tn.su <- su\n+\t\t}()\n+\t\tcurrProg = su.GetProgress()\n \t}\n \t// Size to split within is the minimum of bufSize or splitIdx so we avoid\n \t// including elements we already know won't be processed.\n \tif bufSize <= 0 || n.splitIdx < bufSize {\n \t\tbufSize = n.splitIdx\n \t}\n-\ts, _, err := splitHelper(n.index, bufSize, currProg, splits, frac, false)\n+\ts, f, err := splitHelper(n.index, bufSize, currProg, splits, frac, su != nil)\n \tif err != nil {\n-\t\tn.mu.Unlock()\n-\t\treturn 0, err\n+\t\treturn SplitResult{}, err\n+\t}\n+\n+\t// No fraction returned, perform channel split.\n+\tif f < 0 {\n+\t\tn.splitIdx = s\n+\t\treturn SplitResult{PI: s - 1, RI: s}, nil\n+\t}\n+\t// Otherwise, perform a sub-element split.\n+\tfr := f / (1.0 - currProg)\n+\tp, r, err := su.Split(fr)\n+\tif err != nil {\n+\t\treturn SplitResult{}, err\n+\t}\n+\n+\tif p != nil && r != nil { // Successful split.", "originalCommit": "24a05d9433fd90be3e5961650dfa3e6ecb9e4337", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwNTU2Mg==", "url": "https://github.com/apache/beam/pull/12350#discussion_r463905562", "bodyText": "Fixed.", "author": "youngoli", "createdAt": "2020-08-01T01:48:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ0NTc5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ0OTY1NA==", "url": "https://github.com/apache/beam/pull/12350#discussion_r462449654", "bodyText": "Nit: Since the previous if ends with a t.Fatalf, and thus terminates the test it's not unreasonable to lift the splitRes assignment and avoid the else block and it's indentation.", "author": "lostluck", "createdAt": "2020-07-29T17:00:59Z", "path": "sdks/go/pkg/beam/core/runtime/exec/datasource_test.go", "diffHunk": "@@ -278,10 +279,15 @@ func TestDataSource_Split(t *testing.T) {\n \t\t\trunOnRoots(ctx, t, p, \"StartBundle\", func(root Root, ctx context.Context) error { return root.StartBundle(ctx, \"1\", dc) })\n \n \t\t\t// SDK never splits on 0, so check that every test.\n-\t\t\tif splitIdx, err := p.Split(SplitPoints{Splits: []int64{0, test.splitIdx}}); err != nil {\n+\t\t\tif splitRes, err := p.Split(SplitPoints{Splits: []int64{0, test.splitIdx}}); err != nil {\n \t\t\t\tt.Fatalf(\"error in Split: %v\", err)\n-\t\t\t} else if got, want := splitIdx, test.splitIdx; got != want {\n-\t\t\t\tt.Fatalf(\"error in Split: got splitIdx = %v, want %v \", got, want)\n+\t\t\t} else {", "originalCommit": "24a05d9433fd90be3e5961650dfa3e6ecb9e4337", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwNTU3MA==", "url": "https://github.com/apache/beam/pull/12350#discussion_r463905570", "bodyText": "Done.", "author": "youngoli", "createdAt": "2020-08-01T01:48:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ0OTY1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ0OTc0OQ==", "url": "https://github.com/apache/beam/pull/12350#discussion_r462449749", "bodyText": "Same comment here.", "author": "lostluck", "createdAt": "2020-07-29T17:01:10Z", "path": "sdks/go/pkg/beam/core/runtime/exec/datasource_test.go", "diffHunk": "@@ -342,10 +348,15 @@ func TestDataSource_Split(t *testing.T) {\n \t\t\t\t\t<-blockedCh\n \t\t\t\t\t// Validate that we do not split on the element we're blocking on index.\n \t\t\t\t\t// The first valid split is at test.splitIdx.\n-\t\t\t\t\tif splitIdx, err := source.Split([]int64{0, 1, 2, 3, 4, 5}, -1, 0); err != nil {\n+\t\t\t\t\tif splitRes, err := source.Split([]int64{0, 1, 2, 3, 4, 5}, -1, 0); err != nil {\n \t\t\t\t\t\tt.Errorf(\"error in Split: %v\", err)\n-\t\t\t\t\t} else if got, want := splitIdx, test.splitIdx; got != want {\n-\t\t\t\t\t\tt.Errorf(\"error in Split: got splitIdx = %v, want %v \", got, want)\n+\t\t\t\t\t} else {", "originalCommit": "24a05d9433fd90be3e5961650dfa3e6ecb9e4337", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwNTU3OA==", "url": "https://github.com/apache/beam/pull/12350#discussion_r463905578", "bodyText": "This one can't avoid the else block since the error case is t.Errorf instead of t.Fatalf.", "author": "youngoli", "createdAt": "2020-08-01T01:49:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ0OTc0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ0OTg0Mg==", "url": "https://github.com/apache/beam/pull/12350#discussion_r462449842", "bodyText": "And here.", "author": "lostluck", "createdAt": "2020-07-29T17:01:21Z", "path": "sdks/go/pkg/beam/core/runtime/exec/datasource_test.go", "diffHunk": "@@ -412,17 +423,120 @@ func TestDataSource_Split(t *testing.T) {\n \n \t\t// SDK never splits on 0, so check that every test.\n \t\tsp := SplitPoints{Splits: test.splitPts, Frac: test.frac, BufSize: test.bufSize}\n-\t\tif splitIdx, err := p.Split(sp); err != nil {\n+\t\tif splitRes, err := p.Split(sp); err != nil {\n \t\t\tt.Fatalf(\"error in Split: %v\", err)\n-\t\t} else if got, want := splitIdx, test.splitIdx; got != want {\n-\t\t\tt.Fatalf(\"error in Split: got splitIdx = %v, want %v \", got, want)\n+\t\t} else {", "originalCommit": "24a05d9433fd90be3e5961650dfa3e6ecb9e4337", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwNTU4OA==", "url": "https://github.com/apache/beam/pull/12350#discussion_r463905588", "bodyText": "Done.", "author": "youngoli", "createdAt": "2020-08-01T01:49:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQ0OTg0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwMzQ2Mg==", "url": "https://github.com/apache/beam/pull/12350#discussion_r463303462", "bodyText": "As discussed, it may be good to document how/why we thing this channel will work as a safe concurrency primitive WRT the process bundle goroutine and the split call goroutine, in particular at the start and end of a bundle.", "author": "lostluck", "createdAt": "2020-07-30T22:20:28Z", "path": "sdks/go/pkg/beam/core/runtime/exec/datasource.go", "diffHunk": "@@ -47,20 +47,21 @@ type DataSource struct {\n \tsplitIdx  int64\n \tstart     time.Time\n \n-\t// rt is non-nil if this DataSource feeds directly to a splittable unit,\n-\t// and receives the current restriction tracker being processed.\n-\trt chan sdf.RTracker\n+\t// su is non-nil if this DataSource feeds directly to a splittable unit,\n+\t// and receives that splittable unit when it is available for splitting.\n+\tsu chan SplittableUnit", "originalCommit": "24a05d9433fd90be3e5961650dfa3e6ecb9e4337", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzMjkwNA==", "url": "https://github.com/apache/beam/pull/12350#discussion_r463332904", "bodyText": "I see it is documented at ProcessSizedElements! Consider mentioning that here.", "author": "lostluck", "createdAt": "2020-07-30T23:52:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwMzQ2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwNTQ1Nw==", "url": "https://github.com/apache/beam/pull/12350#discussion_r463905457", "bodyText": "Improved this documentation for now, but this is part of concurrency code I might be refactoring to avoid all the blocking, so it might just be gone with the next commit I send.", "author": "youngoli", "createdAt": "2020-08-01T01:47:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwMzQ2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwOTc5Mg==", "url": "https://github.com/apache/beam/pull/12350#discussion_r463309792", "bodyText": "Do we need to keep the commented out parts around now?", "author": "lostluck", "createdAt": "2020-07-30T22:36:11Z", "path": "sdks/go/pkg/beam/core/runtime/exec/dynsplit_test.go", "diffHunk": "@@ -0,0 +1,464 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package exec\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"github.com/google/go-cmp/cmp/cmpopts\"\n+\t\"io\"\n+\t\"reflect\"\n+\t\"sync\"\n+\t\"testing\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/coder\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/mtime\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/window\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/typex\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/util/reflectx\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/io/rtrackers/offsetrange\"\n+\t\"github.com/google/go-cmp/cmp\"\n+)\n+\n+// TestDynamicSplit tests that a dynamic split of an in-progress SDF succeeds\n+// with valid input. It coordinates the two threads (processing and splitting)\n+// to test what happens if operations happen in various orders. The test then\n+// validates that the output of the SDF is correct according to the split.\n+func TestDynamicSplit(t *testing.T) {\n+\ttests := []struct {\n+\t\tname string\n+\t\t// driver is a function determining how the processing and splitting\n+\t\t// threads are created and coordinated.\n+\t\tdriver func(*Plan, DataContext, *splitTestSdf) (error, splitResult)\n+\t}{\n+\t\t{\n+\t\t\t// Complete a split before beginning processing.\n+\t\t\tname:   \"Simple\",\n+\t\t\tdriver: nonBlockingDriver,\n+\t\t},\n+\t\t{\n+\t\t\t// Try claiming while blocked on a split.\n+\t\t\tname:   \"BlockOnSplit\",\n+\t\t\tdriver: splitBlockingDriver,\n+\t\t},\n+\t\t{\n+\t\t\t// Try splitting while blocked on a claim.\n+\t\t\tname:   \"BlockOnClaim\",\n+\t\t\tdriver: claimBlockingDriver,\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\ttest := test\n+\t\tt.Run(test.name, func(t *testing.T) {\n+\t\t\t// Create pipeline.\n+\t\t\tsdf := newSplitTestSdf()\n+\t\t\tdfn, err := graph.NewDoFn(sdf, graph.NumMainInputs(graph.MainSingle))\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"invalid function: %v\", err)\n+\t\t\t}\n+\t\t\tcdr := createSplitTestInCoder()\n+\t\t\tplan, out := createSdfPlan(t, t.Name(), dfn, cdr)\n+\n+\t\t\t// Create thread to send element to pipeline.\n+\t\t\tpr, pw := io.Pipe()\n+\t\t\telm := createElm()\n+\t\t\tgo writeElm(elm, cdr, pw)\n+\t\t\tdc := DataContext{Data: &TestDataManager{R: pr}}\n+\n+\t\t\t// Call driver to coordinate processing & splitting threads.\n+\t\t\tprocRes, splitRes := test.driver(plan, dc, sdf)\n+\n+\t\t\t// Validate we get a valid split result, aside from split elements.\n+\t\t\tif splitRes.err != nil {\n+\t\t\t\tt.Fatalf(\"Plan.Split failed: %v\", splitRes.err)\n+\t\t\t}\n+\t\t\twantSplit := SplitResult{\n+\t\t\t\tPI:   -1,\n+\t\t\t\tRI:   1,\n+\t\t\t\tPS:   nil,\n+\t\t\t\tRS:   nil,\n+\t\t\t\tTId:  testTransformId,\n+\t\t\t\tInId: indexToInputId(0),\n+\t\t\t}\n+\t\t\tif diff := cmp.Diff(splitRes.split, wantSplit, cmpopts.IgnoreFields(SplitResult{}, \"PS\", \"RS\")); diff != \"\" {\n+\t\t\t\tt.Errorf(\"Incorrect split result (ignoring split elements): %v\", diff)\n+\t\t\t}\n+\n+\t\t\t// Validate split elements are encoded correctly by decoding them\n+\t\t\t// with the input coder to the path.\n+\t\t\t// TODO(BEAM-10579) Switch to using splittable unit's input coder\n+\t\t\t// once that is implemented.\n+\t\t\tp, err := decodeDynSplitElm(splitRes.split.PS, cdr)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"Failed decoding primary element split: %v\", err)\n+\t\t\t}\n+\t\t\t_, err = decodeDynSplitElm(splitRes.split.RS, cdr)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"Failed decoding residual element split: %v\", err)\n+\t\t\t}\n+\n+\t\t\t// Validate SDF output. Make sure each restriction matches the split result.\n+\t\t\tif err := procRes; err != nil {\n+\t\t\t\tt.Fatal(err)\n+\t\t\t}\n+\t\t\tpRest := p.Elm.(*FullValue).Elm2.(offsetrange.Restriction)\n+\t\t\tif got, want := len(out.Elements), int(pRest.End-pRest.Start); got != want {\n+\t\t\t\tt.Errorf(\"Unexpected number of elements: got: %v, want: %v\", got, want)\n+\t\t\t}\n+\t\t\tfor i, fv := range out.Elements {\n+\t\t\t\trest := fv.Elm.(offsetrange.Restriction)\n+\t\t\t\tif got, want := rest, pRest; !cmp.Equal(got, want) {\n+\t\t\t\t\tt.Errorf(\"Output element %v had incorrect restriction: got: %v, want: %v\", i, got, want)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+// nonBlockingDriver performs a split before starting processing, so no thread\n+// is forced to wait on a mutex.\n+func nonBlockingDriver(plan *Plan, dc DataContext, sdf *splitTestSdf) (procRes error, splitRes splitResult) {\n+\t// Begin processing pipeline.\n+\tprocResCh := make(chan error)\n+\tgo processPlan(plan, dc, procResCh)\n+\trt := <-sdf.rt // Tracker is created first, retrieve that.\n+\n+\t// Complete a split before unblocking processing.\n+\tsplitResCh := make(chan splitResult)\n+\tgo splitPlan(plan, splitResCh)\n+\t<-rt.split\n+\t<-rt.blockSplit\n+\tsplitRes = <-splitResCh\n+\n+\t// Unblock and finishing processing.\n+\t<-sdf.proc\n+\t<-rt.claim\n+\t<-rt.blockClaim\n+\t<-rt.endClaim\n+\tprocRes = <-procResCh\n+\n+\treturn procRes, splitRes\n+}\n+\n+// splitBlockingDriver blocks on a split request so that the SDF attempts to\n+// claim while the split is occurring.\n+func splitBlockingDriver(plan *Plan, dc DataContext, sdf *splitTestSdf) (procRes error, splitRes splitResult) {\n+\t// Begin processing pipeline.\n+\tprocResCh := make(chan error)\n+\tgo processPlan(plan, dc, procResCh)\n+\trt := <-sdf.rt // Tracker is created first, retrieve that.\n+\n+\t// Start a split, but block on it so it holds the mutex.\n+\tsplitResCh := make(chan splitResult)\n+\tgo splitPlan(plan, splitResCh)\n+\t<-rt.split\n+\n+\t// Start processing and start a claim, that'll be waiting for the mutex.\n+\t<-sdf.proc\n+\t<-rt.claim\n+\n+\t// Unblock and finish splitting and free the mutex.\n+\t<-rt.blockSplit\n+\tsplitRes = <-splitResCh\n+\n+\t// Unblock and finish claiming and processing.\n+\t<-rt.blockClaim\n+\t<-rt.endClaim\n+\tprocRes = <-procResCh\n+\n+\treturn procRes, splitRes\n+}\n+\n+// claimBlockingDriver blocks on a claim request so that the SDF attempts to\n+// split while the claim is occurring.\n+func claimBlockingDriver(plan *Plan, dc DataContext, sdf *splitTestSdf) (procRes error, splitRes splitResult) {\n+\t// Begin processing pipeline.\n+\tprocResCh := make(chan error)\n+\tgo processPlan(plan, dc, procResCh)\n+\trt := <-sdf.rt // Tracker is created first, retrieve that.\n+\n+\t// Start a claim, but block on it so it holds the mutex.\n+\t<-sdf.proc\n+\t<-rt.claim\n+\n+\t// Start a split that'll be waiting for the mutex.\n+\tsplitResCh := make(chan splitResult)\n+\tgo splitPlan(plan, splitResCh)\n+\t<-rt.split\n+\n+\t// Unblock the claim, freeing the mutex (but not finishing processing yet).\n+\t<-rt.blockClaim\n+\n+\t// Finish splitting, allowing processing to finish.\n+\t<-rt.blockSplit\n+\tsplitRes = <-splitResCh\n+\t<-rt.endClaim // Delay the claim end so we don't process too much before splitting.\n+\tprocRes = <-procResCh\n+\n+\treturn procRes, splitRes\n+}\n+\n+// createElm creates the element for our test pipeline.\n+func createElm() *FullValue {\n+\treturn &FullValue{\n+\t\tElm: &FullValue{\n+\t\t\tElm:  20,\n+\t\t\tElm2: offsetrange.Restriction{Start: 0, End: 20},\n+\t\t},\n+\t\tElm2: float64(20),\n+\t}\n+}\n+\n+// createSplitTestInCoder outputs the coder for inputs to our test pipeline,\n+// (in particular, the DataSource transform of the pipeline). For the specific\n+// element this is a coder for, see createElm.\n+func createSplitTestInCoder() *coder.Coder {\n+\trestT := reflect.TypeOf((*offsetrange.Restriction)(nil)).Elem()\n+\trestCdr := coder.LookupCustomCoder(restT)\n+\n+\tcdr := coder.NewW(\n+\t\tcoder.NewKV([]*coder.Coder{\n+\t\t\tcoder.NewKV([]*coder.Coder{\n+\t\t\t\tintCoder(reflectx.Int),\n+\t\t\t\t{Kind: coder.Custom, T: typex.New(restT), Custom: restCdr},\n+\t\t\t}),\n+\t\t\tcoder.NewDouble(),\n+\t\t}),\n+\t\tcoder.NewGlobalWindow())\n+\treturn cdr\n+}\n+\n+// createSdfPlan creates a plan containing the test pipeline, which is\n+// DataSource -> SDF.ProcessSizedElementsAndRestrictions -> CaptureNode.\n+func createSdfPlan(t *testing.T, name string, fn *graph.DoFn, cdr *coder.Coder) (*Plan, *CaptureNode) {\n+\tout := &CaptureNode{UID: 0}\n+\tn := &ParDo{UID: 1, Fn: fn, Out: []Node{out}}\n+\tsdf := &ProcessSizedElementsAndRestrictions{PDo: n, TfId: testTransformId}\n+\tds := &DataSource{\n+\t\tUID:   2,\n+\t\tSID:   StreamID{PtransformID: \"DataSource\"},\n+\t\tName:  \"name\",\n+\t\tCoder: cdr,\n+\t\tOut:   sdf,\n+\t}\n+\tunits := []Unit{ds, sdf, out}\n+\n+\tp, err := NewPlan(name+\"_plan\", units)\n+\tif err != nil {\n+\t\tt.Fatalf(\"NewPlan failed: %v\", err)\n+\t}\n+\treturn p, out\n+}\n+\n+// writeElm is meant to be the goroutine for feeding an element to the\n+// DataSourc of the test pipeline.\n+func writeElm(elm *FullValue, cdr *coder.Coder, pw *io.PipeWriter) {\n+\twc := MakeWindowEncoder(cdr.Window)\n+\tec := MakeElementEncoder(coder.SkipW(cdr))\n+\tif err := EncodeWindowedValueHeader(wc, window.SingleGlobalWindow, mtime.ZeroTimestamp, pw); err != nil {\n+\t\tpanic(\"err\")\n+\t}\n+\tif err := ec.Encode(elm, pw); err != nil {\n+\t\tpanic(\"err\")\n+\t}\n+\tif err := pw.Close(); err != nil {\n+\t\tpanic(\"err\")\n+\t}\n+}\n+\n+func decodeDynSplitElm(elm []byte, cdr *coder.Coder) (*FullValue, error) {\n+\twd := MakeWindowDecoder(cdr.Window)\n+\ted := MakeElementDecoder(coder.SkipW(cdr))\n+\tb := bytes.NewBuffer(elm)\n+\tw, t, err := DecodeWindowedValueHeader(wd, b)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\te, err := ed.Decode(b)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\te.Windows = w\n+\te.Timestamp = t\n+\treturn e, nil\n+}\n+\n+// processPlan is meant to be the goroutine representing the thread processing\n+// the SDF.\n+func processPlan(plan *Plan, dc DataContext, result chan error) {\n+\tif err := plan.Execute(context.Background(), plan.ID()+\"_execute\", dc); err != nil {\n+\t\tresult <- errors.Wrap(err, \"Plan.Execute failed\")\n+\t}\n+\tif err := plan.Down(context.Background()); err != nil {\n+\t\tresult <- errors.Wrap(err, \"Plan.Down failed\")\n+\t}\n+\tresult <- nil\n+}\n+\n+type splitResult struct {\n+\tsplit SplitResult\n+\terr   error\n+}\n+\n+// splitPlan is meant to be the goroutine representing the thread handling a\n+// split request for the SDF.\n+func splitPlan(plan *Plan, result chan splitResult) {\n+\t// Fake splitting code.\n+\t//p, r, err := rt.TrySplit(0.5)", "originalCommit": "24a05d9433fd90be3e5961650dfa3e6ecb9e4337", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwNTU5Ng==", "url": "https://github.com/apache/beam/pull/12350#discussion_r463905596", "bodyText": "Nope, just forgot to delete it.", "author": "youngoli", "createdAt": "2020-08-01T01:49:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMwOTc5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzMTM1Mg==", "url": "https://github.com/apache/beam/pull/12350#discussion_r463331352", "bodyText": "so the element", "author": "lostluck", "createdAt": "2020-07-30T23:46:57Z", "path": "sdks/go/pkg/beam/core/runtime/exec/sdf.go", "diffHunk": "@@ -215,14 +215,25 @@ func (n *SplitAndSizeRestrictions) String() string {\n // changes to support the SDF's method signatures and the expected structure\n // of the FullValue being received.\n type ProcessSizedElementsAndRestrictions struct {\n-\tPDo *ParDo\n-\n-\tinv *ctInvoker\n-\n-\t// Rt allows this unit to send out restriction trackers being processed.\n-\t// Receivers of the tracker do not own it, and must send it back through the\n-\t// same channel once finished with it.\n-\tRt chan sdf.RTracker\n+\tPDo     *ParDo\n+\tTfId    string // Transform ID. Needed for splitting.\n+\tctInv   *ctInvoker\n+\tsizeInv *rsInvoker\n+\n+\t// SU is a buffered channel for indicating when this unit is splittable.\n+\t// When this unit is processing an element, it sends a SplittableUnit\n+\t// interface through the channel. That interface can be received on other\n+\t// threads and used to perform splitting or other related operation.\n+\t//\n+\t// Receiving the SplittableUnit prevents the current element from finishing\n+\t// processing, so he element does not unexpectedly change during a split.", "originalCommit": "24a05d9433fd90be3e5961650dfa3e6ecb9e4337", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkwNTYwNA==", "url": "https://github.com/apache/beam/pull/12350#discussion_r463905604", "bodyText": "Fixed.", "author": "youngoli", "createdAt": "2020-08-01T01:49:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzMzMTM1Mg=="}], "type": "inlineReview"}, {"oid": "00fa0bc1c86882fe54e0f4620d0e190296fb78b9", "url": "https://github.com/apache/beam/commit/00fa0bc1c86882fe54e0f4620d0e190296fb78b9", "message": "[BEAM-10289] Avoiding blocking as much when splitting.", "committedDate": "2020-08-01T04:19:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU1MjYxMQ==", "url": "https://github.com/apache/beam/pull/12350#discussion_r464552611", "bodyText": "Please move this to the other beam imports below.", "author": "lostluck", "createdAt": "2020-08-03T17:22:31Z", "path": "sdks/go/pkg/beam/core/runtime/exec/datasource_test.go", "diffHunk": "@@ -18,6 +18,7 @@ package exec\n import (\n \t\"context\"\n \t\"fmt\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"", "originalCommit": "00fa0bc1c86882fe54e0f4620d0e190296fb78b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "be5e4194a73e64ca5d1dd01c12de515786b897ee", "url": "https://github.com/apache/beam/commit/be5e4194a73e64ca5d1dd01c12de515786b897ee", "message": "[BEAM-10289] Go Dynamic splitting full implementation.\n\nIncludes core behavior, documentation, and tests.", "committedDate": "2020-08-03T23:53:56Z", "type": "commit"}, {"oid": "f5c9f71f129f7123c1fd75a6bdb577ab8b8186a4", "url": "https://github.com/apache/beam/commit/f5c9f71f129f7123c1fd75a6bdb577ab8b8186a4", "message": "[BEAM-10289] Avoiding blocking when dynamic splitting in Go.\n\nAdds a timeout/default case when getting the splittable unit, a blocking\noperation. Also includes some fixup.", "committedDate": "2020-08-03T23:55:36Z", "type": "commit"}, {"oid": "f5c9f71f129f7123c1fd75a6bdb577ab8b8186a4", "url": "https://github.com/apache/beam/commit/f5c9f71f129f7123c1fd75a6bdb577ab8b8186a4", "message": "[BEAM-10289] Avoiding blocking when dynamic splitting in Go.\n\nAdds a timeout/default case when getting the splittable unit, a blocking\noperation. Also includes some fixup.", "committedDate": "2020-08-03T23:55:36Z", "type": "forcePushed"}]}