{"pr_number": 13629, "pr_title": "[BEAM-10925] Load SQL UDFs from jar.", "pr_createdAt": "2020-12-29T00:15:10Z", "pr_url": "https://github.com/apache/beam/pull/13629", "timeline": [{"oid": "71b7d8bb2f0f117b33072ef3aa3201980185b6e2", "url": "https://github.com/apache/beam/commit/71b7d8bb2f0f117b33072ef3aa3201980185b6e2", "message": "[BEAM-10925] Load SQL UDFs from jar.", "committedDate": "2020-12-29T00:13:21Z", "type": "commit"}, {"oid": "25b890379a492e01b4e48e90bf716fb51eb846bb", "url": "https://github.com/apache/beam/commit/25b890379a492e01b4e48e90bf716fb51eb846bb", "message": "Move JavaUdfLoader from zetasql -> sql.", "committedDate": "2020-12-29T02:53:24Z", "type": "commit"}, {"oid": "ee4d14a3271ec3b1d512d7f30c7430246ebdf582", "url": "https://github.com/apache/beam/commit/ee4d14a3271ec3b1d512d7f30c7430246ebdf582", "message": "Make JavaUdfDefinitions a subclass of JavaUdfLoader.\n\nSince JavaUdfLoader should be the only consumer anyway.", "committedDate": "2020-12-29T03:10:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU1OTg3Ng==", "url": "https://github.com/apache/beam/pull/13629#discussion_r549559876", "bodyText": "You've leaked the class loader here. setContextClassLoader should always be inside a try finally block that resets the class loader. For example: \n  \n    \n      beam/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamEnumerableConverter.java\n    \n    \n         Line 118\n      in\n      3bb232f\n    \n    \n    \n    \n\n        \n          \n           final ClassLoader originalClassLoader = Thread.currentThread().getContextClassLoader();", "author": "apilloud", "createdAt": "2020-12-29T04:01:37Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/JavaUdfLoader.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.sql.impl;\n+\n+import com.google.auto.value.AutoValue;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.file.ProviderNotFoundException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ServiceLoader;\n+import org.apache.beam.sdk.extensions.sql.udf.ScalarFn;\n+import org.apache.beam.sdk.extensions.sql.udf.UdfProvider;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.util.common.ReflectHelpers;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.commons.codec.digest.DigestUtils;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.io.ByteStreams;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Loads {@link UdfProvider} implementations from user-provided jars.\n+ *\n+ * <p>All UDFs are loaded and cached for each jar to mitigate IO costs.\n+ */\n+public class JavaUdfLoader {\n+  private static final Logger LOG = LoggerFactory.getLogger(JavaUdfLoader.class);\n+\n+  /**\n+   * Maps the external jar location to the functions the jar defines. Static so it can persist\n+   * across multiple SQL transforms.\n+   */\n+  private static final Map<String, FunctionDefinitions> cache = new HashMap<>();\n+\n+  private static final ClassLoader originalClassLoader = ReflectHelpers.findClassLoader();\n+\n+  /**\n+   * Load a user-defined scalar function from the specified jar.\n+   *\n+   * <p><strong>WARNING</strong>: The first time a jar is loaded, it is added to the thread's\n+   * context {@link ClassLoader} so that the jar can be staged by the runner.\n+   */\n+  public ScalarFn loadScalarFunction(List<String> functionPath, String jarPath) {\n+    String functionFullName = String.join(\".\", functionPath);\n+    try {\n+      FunctionDefinitions functionDefinitions = loadJar(jarPath);\n+      if (!functionDefinitions.scalarFunctions().containsKey(functionPath)) {\n+        throw new IllegalArgumentException(\n+            String.format(\n+                \"No implementation of scalar function %s found in %s.%n\"\n+                    + \" 1. Create a class implementing %s and annotate it with @AutoService(%s.class).%n\"\n+                    + \" 2. Add function %s to the class's userDefinedScalarFunctions implementation.\",\n+                functionFullName,\n+                jarPath,\n+                UdfProvider.class.getSimpleName(),\n+                UdfProvider.class.getSimpleName(),\n+                functionFullName));\n+      }\n+      return functionDefinitions.scalarFunctions().get(functionPath);\n+    } catch (IOException e) {\n+      throw new RuntimeException(\n+          String.format(\n+              \"Failed to load user-defined scalar function %s from %s\", functionFullName, jarPath),\n+          e);\n+    }\n+  }\n+\n+  /**\n+   * Creates a temporary local copy of the file at {@code inputPath}, and returns a handle to the\n+   * local copy.\n+   */\n+  private File downloadFile(String inputPath, String mimeType) throws IOException {\n+    Preconditions.checkArgument(!inputPath.isEmpty(), \"Path cannot be empty.\");\n+    ResourceId inputResource = FileSystems.matchNewResource(inputPath, false /* is directory */);\n+    try (ReadableByteChannel inputChannel = FileSystems.open(inputResource)) {\n+      File outputFile = File.createTempFile(\"sql-udf-\", inputResource.getFilename());\n+      ResourceId outputResource =\n+          FileSystems.matchNewResource(outputFile.getAbsolutePath(), false /* is directory */);\n+      try (WritableByteChannel outputChannel = FileSystems.create(outputResource, mimeType)) {\n+        ByteStreams.copy(inputChannel, outputChannel);\n+      }\n+      // Compute and log checksum.\n+      try (InputStream inputStream = new FileInputStream(outputFile)) {\n+        LOG.info(\n+            \"Copied {} to {} with md5 hash {}.\",\n+            inputPath,\n+            outputFile.getAbsolutePath(),\n+            DigestUtils.md5Hex(inputStream));\n+      }\n+      return outputFile;\n+    }\n+  }\n+\n+  private ClassLoader createAndSetClassLoader(String inputJarPath) throws IOException {\n+    File tmpJar = downloadFile(inputJarPath, \"application/java-archive\");\n+    // Set the thread's context class loader so that the jar can be staged by the runner.\n+    Thread.currentThread()\n+        .setContextClassLoader(", "originalCommit": "ee4d14a3271ec3b1d512d7f30c7430246ebdf582", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgwNjYxOA==", "url": "https://github.com/apache/beam/pull/13629#discussion_r549806618", "bodyText": "I intended to leave UDF provider jars on the class loader here, so that later, in the DF SQL launcher, we can use the class loader to detect which files need to be staged to the runner. \n  \n    \n      beam/runners/google-cloud-dataflow-java/src/main/java/org/apache/beam/runners/dataflow/options/DataflowPipelineWorkerPoolOptions.java\n    \n    \n         Line 200\n      in\n      ecedd3e\n    \n    \n    \n    \n\n        \n          \n           void setFilesToStage(List<String> value); \n        \n    \n  \n\n\nIf this way is unsafe for some reason, we will have to come up with a different way to pass jars from JavaUdfLoader into pipeline options. The only other ways I could think of are:\n\nPassing jars all the way up through the stack to SqlTransform, which will require changing SqlTransform and every other API surface in between.\nHandling jars (independently from SqlTransform construction) a second time in the SQL launcher. In other words, parse the query text again to extract the UDF jars, download the UDF jars a second time, and add them to filesToStage.", "author": "ibzib", "createdAt": "2020-12-29T18:34:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU1OTg3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwMjU5MQ==", "url": "https://github.com/apache/beam/pull/13629#discussion_r552102591", "bodyText": "Not resetting the ContextClassLoader after your method returns is unsafe. You need to find another way to communicate the classes upstream. Our current UDF loading happens in SqlTransform.expand(), seems like this should be called from there too. So option 1 should be trivial.", "author": "apilloud", "createdAt": "2021-01-05T18:06:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU1OTg3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjE0MzIxNg==", "url": "https://github.com/apache/beam/pull/13629#discussion_r552143216", "bodyText": "Sounds good. I will look into option 1 and probably implement it in a separate PR.", "author": "ibzib", "createdAt": "2021-01-05T19:23:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU1OTg3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI0MDAyOQ==", "url": "https://github.com/apache/beam/pull/13629#discussion_r552240029", "bodyText": "Option 1 would require several API changes:\n\nAdd UDF provider jars to BeamRelNode.\nEither change the signature of ZetaSQLPlannerImpl::rel (currently returns Calcite RelRoot) or give ZetaSQLPlannerImpl a mutable field to hold UDF provider jars.\nGive SqlTransform a mutable field to hold UDF provider jars.\n\nOf these, I'm most concerned with 3. Should PTransforms be mutable? I couldn't find anything in the Javadoc that explicitly warned against it, but mutability seems like something we should avoid if we can help it.", "author": "ibzib", "createdAt": "2021-01-05T22:35:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU1OTg3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI0NTM0MQ==", "url": "https://github.com/apache/beam/pull/13629#discussion_r552245341", "bodyText": "A third option: if we download jars to a specific, known local directory, we could just add that entire directory to filesToStage.", "author": "ibzib", "createdAt": "2021-01-05T22:48:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU1OTg3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MzM3NA==", "url": "https://github.com/apache/beam/pull/13629#discussion_r552943374", "bodyText": "You've lost all isolation of the JARs on the worker, filesToStage is in the default classpath. I think you need to plumb the jar path all the way down to BeamCalcRel, and that is the layer at which you'll need to stage the jar and load it on the worker.", "author": "apilloud", "createdAt": "2021-01-06T20:22:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU1OTg3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzY0MzgxMA==", "url": "https://github.com/apache/beam/pull/13629#discussion_r553643810", "bodyText": "IMO The third option is the one that is easy to implement and without obvious drawbacks.\nI think the third option says to specify a known directory on the launcher VM or local machine (so not on workers, thus does not affect jars isolation on workers). We might can control that directory by a pipeline option.", "author": "amaliujia", "createdAt": "2021-01-07T23:03:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU1OTg3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTMxMTUxMg==", "url": "https://github.com/apache/beam/pull/13629#discussion_r555311512", "bodyText": "All of the options I listed were to address the question: how should we pass jars from JavaUdfLoader to the filesToStage pipeline option. Andrew's concern is bigger and applies to all three options: putting all the UDF jars in filesToStage puts them all on the classpath for workers. UDF jars are only needed when compiling the generated code in CalcFn, so they should not be on the classpath except for that.", "author": "ibzib", "createdAt": "2021-01-11T20:15:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU1OTg3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTM3NDg2Ng==", "url": "https://github.com/apache/beam/pull/13629#discussion_r555374866", "bodyText": "As I recall we have discussed or at least mentioned such topic offline.\nFor Java SDK, user's UDF is put into the classpath without an isolation. It won't be a regression for SQL if we follow up the same rule.\nWe could do better for the SQL case as we know the user defined scalar function will be executed in CalcFn, but do we need to handle it at this moment? Is it a required thing to launch the first version of UDF? IMO because SQL will be aligned with Java's practice thus it is not required.\nA further thought on jar isolation, will solution for the isolation in CalcFn for user-defined scalar func too specific. Will it better to have a separate discussion to cover also UDAF and UDTVF thus we can achieve the isolation on all types of UDF by a same solution?", "author": "amaliujia", "createdAt": "2021-01-11T22:15:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU1OTg3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQ3NjUxNA==", "url": "https://github.com/apache/beam/pull/13629#discussion_r555476514", "bodyText": "For Java SDK, user's UDF is put into the classpath without an isolation. It won't be a regression for SQL if we follow up the same rule.\n\nOne difference is that in the Java SDK, the user is given direct control of the classpath via filesToStage. But when we construct a SQL pipeline for them, the user does not have direct control of the classpath. The API we show to users does not expose how their Java transforms are fused into a single pipeline, nor should it. So isolating the classpath for each CalcFn better matches the API and hides complexity from the user.\n\nA further thought on jar isolation, will solution for the isolation in CalcFn for user-defined scalar func too specific. Will it better to have a separate discussion to cover also UDAF and UDTVF thus we can achieve the isolation on all types of UDF by a same solution?\n\nThat's a good question. Isolating the CalcFn is a nice solution for scalar functions, but I'm not sure how we could isolate UDAF since CombineFn is more abstract than DoFn and aggregates aren't compiled separately like CalcFn.", "author": "ibzib", "createdAt": "2021-01-12T02:49:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU1OTg3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU2NDE1MQ==", "url": "https://github.com/apache/beam/pull/13629#discussion_r549564151", "bodyText": "This is probably unsafe to cache.", "author": "apilloud", "createdAt": "2020-12-29T04:31:44Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/JavaUdfLoader.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.sql.impl;\n+\n+import com.google.auto.value.AutoValue;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.file.ProviderNotFoundException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ServiceLoader;\n+import org.apache.beam.sdk.extensions.sql.udf.ScalarFn;\n+import org.apache.beam.sdk.extensions.sql.udf.UdfProvider;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.util.common.ReflectHelpers;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.commons.codec.digest.DigestUtils;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.io.ByteStreams;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Loads {@link UdfProvider} implementations from user-provided jars.\n+ *\n+ * <p>All UDFs are loaded and cached for each jar to mitigate IO costs.\n+ */\n+public class JavaUdfLoader {\n+  private static final Logger LOG = LoggerFactory.getLogger(JavaUdfLoader.class);\n+\n+  /**\n+   * Maps the external jar location to the functions the jar defines. Static so it can persist\n+   * across multiple SQL transforms.\n+   */\n+  private static final Map<String, FunctionDefinitions> cache = new HashMap<>();\n+\n+  private static final ClassLoader originalClassLoader = ReflectHelpers.findClassLoader();", "originalCommit": "ee4d14a3271ec3b1d512d7f30c7430246ebdf582", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgwNjY0OA==", "url": "https://github.com/apache/beam/pull/13629#discussion_r549806648", "bodyText": "Why?", "author": "ibzib", "createdAt": "2020-12-29T18:35:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU2NDE1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwNTY4OQ==", "url": "https://github.com/apache/beam/pull/13629#discussion_r552105689", "bodyText": "Users perform their own layering of class loaders. I've seen a tool that loads \"stable\" jars, such as released Beam Jars, into a root class loader that is reused across multiple pipelines, then loads the user code into a child class loader that is replaced for every pipeline. This could cause unexpected behavior as you'll probably end up caching the first child class loader to invoke this code.", "author": "apilloud", "createdAt": "2021-01-05T18:12:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU2NDE1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI0MzI0MA==", "url": "https://github.com/apache/beam/pull/13629#discussion_r552243240", "bodyText": "Got it. If we reset the class loader as discussed in the other thread, there will be no need for this cache.", "author": "ibzib", "createdAt": "2021-01-05T22:43:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU2NDE1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU2NDM2MQ==", "url": "https://github.com/apache/beam/pull/13629#discussion_r549564361", "bodyText": "I'm not sure this is safe as is. It will probably work for most cases, but I think you might want to key it on original class loader?", "author": "apilloud", "createdAt": "2020-12-29T04:33:25Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/JavaUdfLoader.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.sql.impl;\n+\n+import com.google.auto.value.AutoValue;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.file.ProviderNotFoundException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ServiceLoader;\n+import org.apache.beam.sdk.extensions.sql.udf.ScalarFn;\n+import org.apache.beam.sdk.extensions.sql.udf.UdfProvider;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.util.common.ReflectHelpers;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.commons.codec.digest.DigestUtils;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.io.ByteStreams;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Loads {@link UdfProvider} implementations from user-provided jars.\n+ *\n+ * <p>All UDFs are loaded and cached for each jar to mitigate IO costs.\n+ */\n+public class JavaUdfLoader {\n+  private static final Logger LOG = LoggerFactory.getLogger(JavaUdfLoader.class);\n+\n+  /**\n+   * Maps the external jar location to the functions the jar defines. Static so it can persist\n+   * across multiple SQL transforms.\n+   */\n+  private static final Map<String, FunctionDefinitions> cache = new HashMap<>();", "originalCommit": "ee4d14a3271ec3b1d512d7f30c7430246ebdf582", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgwNjY3MA==", "url": "https://github.com/apache/beam/pull/13629#discussion_r549806670", "bodyText": "Why?", "author": "ibzib", "createdAt": "2020-12-29T18:35:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU2NDM2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwNjExMA==", "url": "https://github.com/apache/beam/pull/13629#discussion_r552106110", "bodyText": "See my comment about users creating their own class loaders above.", "author": "apilloud", "createdAt": "2021-01-05T18:13:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU2NDM2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDE2ODU2NA==", "url": "https://github.com/apache/beam/pull/13629#discussion_r564168564", "bodyText": "I still can't imagine exactly how the user might break this by setting class loaders. I think we might just have to accept some level of risk here, since messing with the context class loader seems to be inherently kind of dangerous anyway.", "author": "ibzib", "createdAt": "2021-01-26T02:11:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU2NDM2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU3NTc1Mg==", "url": "https://github.com/apache/beam/pull/13629#discussion_r549575752", "bodyText": "I am a bit confused on what is List<String> functionPath (i.e. why it is a list?) Can you add a @param on java doc to explain this parameter?", "author": "amaliujia", "createdAt": "2020-12-29T05:43:12Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/JavaUdfLoader.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.sql.impl;\n+\n+import com.google.auto.value.AutoValue;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.file.ProviderNotFoundException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ServiceLoader;\n+import org.apache.beam.sdk.extensions.sql.udf.ScalarFn;\n+import org.apache.beam.sdk.extensions.sql.udf.UdfProvider;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.util.common.ReflectHelpers;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.commons.codec.digest.DigestUtils;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.io.ByteStreams;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Loads {@link UdfProvider} implementations from user-provided jars.\n+ *\n+ * <p>All UDFs are loaded and cached for each jar to mitigate IO costs.\n+ */\n+public class JavaUdfLoader {\n+  private static final Logger LOG = LoggerFactory.getLogger(JavaUdfLoader.class);\n+\n+  /**\n+   * Maps the external jar location to the functions the jar defines. Static so it can persist\n+   * across multiple SQL transforms.\n+   */\n+  private static final Map<String, FunctionDefinitions> cache = new HashMap<>();\n+\n+  private static final ClassLoader originalClassLoader = ReflectHelpers.findClassLoader();\n+\n+  /**\n+   * Load a user-defined scalar function from the specified jar.\n+   *\n+   * <p><strong>WARNING</strong>: The first time a jar is loaded, it is added to the thread's\n+   * context {@link ClassLoader} so that the jar can be staged by the runner.\n+   */\n+  public ScalarFn loadScalarFunction(List<String> functionPath, String jarPath) {", "originalCommit": "ee4d14a3271ec3b1d512d7f30c7430246ebdf582", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgwNzM5OQ==", "url": "https://github.com/apache/beam/pull/13629#discussion_r549807399", "bodyText": "It's a list because functions in ZetaSQL can be period-separated (e.g. foo.bar.baz would be represented as a list of {\"foo\", \"bar\", \"baz\"}). I could change this to take a single String instead, I have no strong preference either way.", "author": "ibzib", "createdAt": "2020-12-29T18:37:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU3NTc1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgyNTM1Mg==", "url": "https://github.com/apache/beam/pull/13629#discussion_r549825352", "bodyText": "I see. List is ok as it is what ZetaSQL allows.", "author": "amaliujia", "createdAt": "2020-12-29T19:43:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU3NTc1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU3NjI1MQ==", "url": "https://github.com/apache/beam/pull/13629#discussion_r549576251", "bodyText": "Will it better to add a randomization on temple file name?\nI am thinking a case that there are two create function statement that each one specify a jar which has the same path but different buckets, so there might be a same local file name in this case?", "author": "amaliujia", "createdAt": "2020-12-29T05:46:19Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/JavaUdfLoader.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.sql.impl;\n+\n+import com.google.auto.value.AutoValue;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.file.ProviderNotFoundException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ServiceLoader;\n+import org.apache.beam.sdk.extensions.sql.udf.ScalarFn;\n+import org.apache.beam.sdk.extensions.sql.udf.UdfProvider;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.util.common.ReflectHelpers;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.commons.codec.digest.DigestUtils;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.io.ByteStreams;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Loads {@link UdfProvider} implementations from user-provided jars.\n+ *\n+ * <p>All UDFs are loaded and cached for each jar to mitigate IO costs.\n+ */\n+public class JavaUdfLoader {\n+  private static final Logger LOG = LoggerFactory.getLogger(JavaUdfLoader.class);\n+\n+  /**\n+   * Maps the external jar location to the functions the jar defines. Static so it can persist\n+   * across multiple SQL transforms.\n+   */\n+  private static final Map<String, FunctionDefinitions> cache = new HashMap<>();\n+\n+  private static final ClassLoader originalClassLoader = ReflectHelpers.findClassLoader();\n+\n+  /**\n+   * Load a user-defined scalar function from the specified jar.\n+   *\n+   * <p><strong>WARNING</strong>: The first time a jar is loaded, it is added to the thread's\n+   * context {@link ClassLoader} so that the jar can be staged by the runner.\n+   */\n+  public ScalarFn loadScalarFunction(List<String> functionPath, String jarPath) {\n+    String functionFullName = String.join(\".\", functionPath);\n+    try {\n+      FunctionDefinitions functionDefinitions = loadJar(jarPath);\n+      if (!functionDefinitions.scalarFunctions().containsKey(functionPath)) {\n+        throw new IllegalArgumentException(\n+            String.format(\n+                \"No implementation of scalar function %s found in %s.%n\"\n+                    + \" 1. Create a class implementing %s and annotate it with @AutoService(%s.class).%n\"\n+                    + \" 2. Add function %s to the class's userDefinedScalarFunctions implementation.\",\n+                functionFullName,\n+                jarPath,\n+                UdfProvider.class.getSimpleName(),\n+                UdfProvider.class.getSimpleName(),\n+                functionFullName));\n+      }\n+      return functionDefinitions.scalarFunctions().get(functionPath);\n+    } catch (IOException e) {\n+      throw new RuntimeException(\n+          String.format(\n+              \"Failed to load user-defined scalar function %s from %s\", functionFullName, jarPath),\n+          e);\n+    }\n+  }\n+\n+  /**\n+   * Creates a temporary local copy of the file at {@code inputPath}, and returns a handle to the\n+   * local copy.\n+   */\n+  private File downloadFile(String inputPath, String mimeType) throws IOException {\n+    Preconditions.checkArgument(!inputPath.isEmpty(), \"Path cannot be empty.\");\n+    ResourceId inputResource = FileSystems.matchNewResource(inputPath, false /* is directory */);\n+    try (ReadableByteChannel inputChannel = FileSystems.open(inputResource)) {\n+      File outputFile = File.createTempFile(\"sql-udf-\", inputResource.getFilename());", "originalCommit": "ee4d14a3271ec3b1d512d7f30c7430246ebdf582", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgwNjcwMA==", "url": "https://github.com/apache/beam/pull/13629#discussion_r549806700", "bodyText": "File.createTempFile already produces a randomized name.", "author": "ibzib", "createdAt": "2020-12-29T18:35:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU3NjI1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyODAzMw==", "url": "https://github.com/apache/beam/pull/13629#discussion_r552928033", "bodyText": "This method duplicates functionality built into the JVM. It might be possible to just construct a URL directly? If not,  here is an example that grabs the path to the temp file from the builtin URL jar cache:\n((JarURLConnection)new URL(\"jar:https://repo1.maven.org/maven2/com/google/api/gax-grpc/1.60.0/gax-grpc-1.60.0-guavashaded.jar!/\").openConnection()).getJarFile().getName()\n(JarURLConnection also provides a getInputStream method if you still want to log a hash.)", "author": "apilloud", "createdAt": "2021-01-06T19:47:52Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/JavaUdfLoader.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.sql.impl;\n+\n+import com.google.auto.value.AutoValue;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.file.ProviderNotFoundException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ServiceLoader;\n+import org.apache.beam.sdk.extensions.sql.udf.ScalarFn;\n+import org.apache.beam.sdk.extensions.sql.udf.UdfProvider;\n+import org.apache.beam.sdk.io.FileSystems;\n+import org.apache.beam.sdk.io.fs.ResourceId;\n+import org.apache.beam.sdk.util.common.ReflectHelpers;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.commons.codec.digest.DigestUtils;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.io.ByteStreams;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Loads {@link UdfProvider} implementations from user-provided jars.\n+ *\n+ * <p>All UDFs are loaded and cached for each jar to mitigate IO costs.\n+ */\n+public class JavaUdfLoader {\n+  private static final Logger LOG = LoggerFactory.getLogger(JavaUdfLoader.class);\n+\n+  /**\n+   * Maps the external jar location to the functions the jar defines. Static so it can persist\n+   * across multiple SQL transforms.\n+   */\n+  private static final Map<String, FunctionDefinitions> cache = new HashMap<>();\n+\n+  private static final ClassLoader originalClassLoader = ReflectHelpers.findClassLoader();\n+\n+  /**\n+   * Load a user-defined scalar function from the specified jar.\n+   *\n+   * <p><strong>WARNING</strong>: The first time a jar is loaded, it is added to the thread's\n+   * context {@link ClassLoader} so that the jar can be staged by the runner.\n+   */\n+  public ScalarFn loadScalarFunction(List<String> functionPath, String jarPath) {\n+    String functionFullName = String.join(\".\", functionPath);\n+    try {\n+      FunctionDefinitions functionDefinitions = loadJar(jarPath);\n+      if (!functionDefinitions.scalarFunctions().containsKey(functionPath)) {\n+        throw new IllegalArgumentException(\n+            String.format(\n+                \"No implementation of scalar function %s found in %s.%n\"\n+                    + \" 1. Create a class implementing %s and annotate it with @AutoService(%s.class).%n\"\n+                    + \" 2. Add function %s to the class's userDefinedScalarFunctions implementation.\",\n+                functionFullName,\n+                jarPath,\n+                UdfProvider.class.getSimpleName(),\n+                UdfProvider.class.getSimpleName(),\n+                functionFullName));\n+      }\n+      return functionDefinitions.scalarFunctions().get(functionPath);\n+    } catch (IOException e) {\n+      throw new RuntimeException(\n+          String.format(\n+              \"Failed to load user-defined scalar function %s from %s\", functionFullName, jarPath),\n+          e);\n+    }\n+  }\n+\n+  /**\n+   * Creates a temporary local copy of the file at {@code inputPath}, and returns a handle to the\n+   * local copy.\n+   */\n+  private File downloadFile(String inputPath, String mimeType) throws IOException {", "originalCommit": "ee4d14a3271ec3b1d512d7f30c7430246ebdf582", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0Mzg2MA==", "url": "https://github.com/apache/beam/pull/13629#discussion_r552943860", "bodyText": "Thanks for the pointer. I'm not sure how GCS permissions work in this case, but it's worth a try.", "author": "ibzib", "createdAt": "2021-01-06T20:23:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyODAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0NjEzNQ==", "url": "https://github.com/apache/beam/pull/13629#discussion_r552946135", "bodyText": "You'll have to use the GCS client to make an authenticated read off of GCS, the current code might be useful for that.", "author": "apilloud", "createdAt": "2021-01-06T20:28:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyODAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDE1NzU2MQ==", "url": "https://github.com/apache/beam/pull/13629#discussion_r564157561", "bodyText": "@apilloud In order to use JarURLConnection we would have to write some code to transform a String (which is a Beam filesystem resource spec) into a jar URL. We could make the URL could point to either a local copy of the jar, or the original jar, which could be either local or remote.\n\nIf we make and point to a local copy, the code wouldn't look too much different than it does currently.\nIf we want to point to the original jar, our code would need to know how to convert a resource from any Beam filesystem into a URL. While that's possible, it would basically require adding a getUrl method to ResourceId and implementing it for every implementation of ResourceId.\n\ntl;dr I'm not sure the benefit of using JarURLConnection outweighs the amount of additional code we'd need to write and maintain, since the current implementation supports every Beam filesystem for free.", "author": "ibzib", "createdAt": "2021-01-26T01:38:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyODAzMw=="}], "type": "inlineReview"}, {"oid": "1fbf45c53824c94a1502f6cfa4f60299a4d1c030", "url": "https://github.com/apache/beam/commit/1fbf45c53824c94a1502f6cfa4f60299a4d1c030", "message": "Don't set context classloader.\n\nThe classloader will need to be set in CalcFn#compile. We will do that\nin a subsequent PR.\n\nAlso fixes nullability errors.", "committedDate": "2021-01-26T02:02:13Z", "type": "commit"}]}