{"pr_number": 13122, "pr_title": "[BEAM-9547] More complete indexing capabilities.", "pr_createdAt": "2020-10-15T00:27:32Z", "pr_url": "https://github.com/apache/beam/pull/13122", "timeline": [{"oid": "458e9f38d9d5a5eafc37dad62a10b5ea8123dd77", "url": "https://github.com/apache/beam/commit/458e9f38d9d5a5eafc37dad62a10b5ea8123dd77", "message": "[BEAM-9547] More complete indexing capabilities.", "committedDate": "2020-10-15T00:25:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc1NTU5OA==", "url": "https://github.com/apache/beam/pull/13122#discussion_r506755598", "bodyText": "You could use _is_null_slice and _is_integer_slice here for clarity.", "author": "TheNeuralBit", "createdAt": "2020-10-16T23:00:39Z", "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -32,9 +32,74 @@ def __array__(self, dtype=None):\n     raise frame_base.WontImplementError(\n         'Conversion to a non-deferred a numpy array.')\n \n+  get = frame_base.not_implemented_method('get')\n+\n \n @frame_base.DeferredFrame._register_for(pd.Series)\n class DeferredSeries(DeferredDataFrameOrSeries):\n+  def __getitem__(self, key):\n+    if _is_null_slice(key) or key is Ellipsis:\n+      return self\n+\n+    elif (isinstance(key, int) or _is_integer_slice(key)\n+          ) and self._expr.proxy().index._should_fallback_to_positional():\n+      raise frame_base.WontImplementError('order sensitive')\n+\n+    elif isinstance(key, slice) or callable(key):\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              # yapf: disable\n+              'getitem',\n+              lambda df: df[key],\n+              [self._expr],\n+              requires_partition_by=partitionings.Nothing(),\n+              preserves_partition_by=partitionings.Singleton()))\n+\n+    elif isinstance(key, DeferredSeries):\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              # yapf: disable\n+              'getitem',\n+              lambda df, indexer: df[indexer],\n+              [self._expr, key._expr],\n+              requires_partition_by=partitionings.Index(),\n+              preserves_partition_by=partitionings.Singleton()))\n+\n+    elif pd.core.series.is_iterator(key) or pd.core.common.is_bool_indexer(key):\n+      raise frame_base.WontImplementError('order sensitive')\n+\n+    else:\n+      # We could consider returning a deferred scalar, but that might\n+      # be more surprising than a clear error.\n+      raise frame_base.WontImplementError('non-deferred')\n+\n+    if isinstance(key, frame_base.DeferredBase):\n+      # Fail early if key is a DeferredBase as it interacts surprisingly with\n+      # key in self._expr.proxy().columns\n+      raise NotImplementedError(\n+          \"Indexing with a deferred frame is not yet supported. Consider \"\n+          \"using df.loc[...]\")\n+\n+    if isinstance(key, slice):\n+      types = set([type(key.start), type(key.stop), type(key.step)])\n+      if types == {type(None)}:\n+        # Empty slice is just a copy.\n+        return frame_base.DeferredFrame.wrap(self._expr)\n+      elif types in [{int}, {type(None), int}]:", "originalCommit": "458e9f38d9d5a5eafc37dad62a10b5ea8123dd77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkzMzM2NA==", "url": "https://github.com/apache/beam/pull/13122#discussion_r507933364", "bodyText": "Ah, yes, I meant to go back and change this. Thanks.", "author": "robertwb", "createdAt": "2020-10-19T17:37:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc1NTU5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc1OTEzMA==", "url": "https://github.com/apache/beam/pull/13122#discussion_r506759130", "bodyText": "Doesn't iloc only work for a null slice? I think we should just direct users to loc iff the proxy has an integer index. If it has a non-integer index we could tell the user they're going to have a bad time (maybe eventually it would link to some documentation about the dangers of integer-location based indexing in DataframeTransform).", "author": "TheNeuralBit", "createdAt": "2020-10-16T23:16:50Z", "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -32,9 +32,74 @@ def __array__(self, dtype=None):\n     raise frame_base.WontImplementError(\n         'Conversion to a non-deferred a numpy array.')\n \n+  get = frame_base.not_implemented_method('get')\n+\n \n @frame_base.DeferredFrame._register_for(pd.Series)\n class DeferredSeries(DeferredDataFrameOrSeries):\n+  def __getitem__(self, key):\n+    if _is_null_slice(key) or key is Ellipsis:\n+      return self\n+\n+    elif (isinstance(key, int) or _is_integer_slice(key)\n+          ) and self._expr.proxy().index._should_fallback_to_positional():\n+      raise frame_base.WontImplementError('order sensitive')\n+\n+    elif isinstance(key, slice) or callable(key):\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              # yapf: disable\n+              'getitem',\n+              lambda df: df[key],\n+              [self._expr],\n+              requires_partition_by=partitionings.Nothing(),\n+              preserves_partition_by=partitionings.Singleton()))\n+\n+    elif isinstance(key, DeferredSeries):\n+      return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+              # yapf: disable\n+              'getitem',\n+              lambda df, indexer: df[indexer],\n+              [self._expr, key._expr],\n+              requires_partition_by=partitionings.Index(),\n+              preserves_partition_by=partitionings.Singleton()))\n+\n+    elif pd.core.series.is_iterator(key) or pd.core.common.is_bool_indexer(key):\n+      raise frame_base.WontImplementError('order sensitive')\n+\n+    else:\n+      # We could consider returning a deferred scalar, but that might\n+      # be more surprising than a clear error.\n+      raise frame_base.WontImplementError('non-deferred')\n+\n+    if isinstance(key, frame_base.DeferredBase):\n+      # Fail early if key is a DeferredBase as it interacts surprisingly with\n+      # key in self._expr.proxy().columns\n+      raise NotImplementedError(\n+          \"Indexing with a deferred frame is not yet supported. Consider \"\n+          \"using df.loc[...]\")\n+\n+    if isinstance(key, slice):\n+      types = set([type(key.start), type(key.stop), type(key.step)])\n+      if types == {type(None)}:\n+        # Empty slice is just a copy.\n+        return frame_base.DeferredFrame.wrap(self._expr)\n+      elif types in [{int}, {type(None), int}]:\n+        # This depends on the contents of the index.\n+        raise frame_base.WontImplementError(\n+            'Use iloc or loc with integer slices.')", "originalCommit": "458e9f38d9d5a5eafc37dad62a10b5ea8123dd77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkzNTU4Mg==", "url": "https://github.com/apache/beam/pull/13122#discussion_r507935582", "bodyText": "Eventually we may make iloc work for integer indices, but if not they'll get a better error there. The problem with directing users to loc directly is that df.loc[ix] is not a drop in replacement for df[ix] here, in fact it can be quite different, and so we need to force people to think about what they're trying to do.", "author": "robertwb", "createdAt": "2020-10-19T17:40:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc1OTEzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc1OTk3Mw==", "url": "https://github.com/apache/beam/pull/13122#discussion_r506759973", "bodyText": "Should we have this logic in DeferredSeries.__getitem__ too?", "author": "TheNeuralBit", "createdAt": "2020-10-16T23:20:52Z", "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -453,17 +518,31 @@ def __getattr__(self, name):\n \n   def __getitem__(self, key):\n     # TODO: Replicate pd.DataFrame.__getitem__ logic\n-    if isinstance(key, frame_base.DeferredBase):\n+    if isinstance(key, DeferredSeries) and key._expr.proxy().dtype == bool:", "originalCommit": "458e9f38d9d5a5eafc37dad62a10b5ea8123dd77", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk0MjU4Nw==", "url": "https://github.com/apache/beam/pull/13122#discussion_r507942587", "bodyText": "Ah, yes, done.", "author": "robertwb", "createdAt": "2020-10-19T17:47:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc1OTk3Mw=="}], "type": "inlineReview"}, {"oid": "6c3ec4edb70cf11df5c2b3cee872c57ee52b9450", "url": "https://github.com/apache/beam/commit/6c3ec4edb70cf11df5c2b3cee872c57ee52b9450", "message": "reviewer comments, cleanup", "committedDate": "2020-10-19T18:03:32Z", "type": "commit"}, {"oid": "d4b7e77ad0d83c831a53dc511e4b548e73852949", "url": "https://github.com/apache/beam/commit/d4b7e77ad0d83c831a53dc511e4b548e73852949", "message": "Merge branch 'master' into dataframe-index", "committedDate": "2020-10-19T18:06:19Z", "type": "commit"}, {"oid": "544fee4baa61d01a9919e5980b0b28530b5aac36", "url": "https://github.com/apache/beam/commit/544fee4baa61d01a9919e5980b0b28530b5aac36", "message": "lint", "committedDate": "2020-10-19T19:47:26Z", "type": "commit"}, {"oid": "f99f33be6ac19d7039ed3b9666685621406f3d8d", "url": "https://github.com/apache/beam/commit/f99f33be6ac19d7039ed3b9666685621406f3d8d", "message": "yapf", "committedDate": "2020-10-20T18:01:11Z", "type": "commit"}, {"oid": "d633c2d45d7e68d0a0758428dc4db46ffad1456a", "url": "https://github.com/apache/beam/commit/d633c2d45d7e68d0a0758428dc4db46ffad1456a", "message": "Merge branch 'master' into dataframe-index", "committedDate": "2020-10-23T00:35:20Z", "type": "commit"}]}