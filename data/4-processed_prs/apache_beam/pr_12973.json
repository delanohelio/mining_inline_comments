{"pr_number": 12973, "pr_title": "[BEAM-10234] Create ApproximateDistinct using HLL Impl", "pr_createdAt": "2020-09-30T07:37:59Z", "pr_url": "https://github.com/apache/beam/pull/12973", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk2MzY5MQ==", "url": "https://github.com/apache/beam/pull/12973#discussion_r516963691", "bodyText": "Could you please update the comments above as well? It talks about HLL, maybe we should change the code snippet to ApproximateCountDistinct", "author": "robinyqiu", "createdAt": "2020-11-03T21:23:59Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/ApproximateUnique.java", "diffHunk": "@@ -56,7 +56,10 @@\n  *\n  * For more details about using {@code HllCount} and the {@code zetasketch} extension module, see\n  * https://s.apache.org/hll-in-beam#bookmark=id.v6chsij1ixo7.\n+ *\n+ * @deprecated use {@code ApproximateCountDistinct} which has moved to HLL implementation.", "originalCommit": "4f0c3171bf50ecfdac76b23e2d2251cd6df6633d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDA5MzIyNg==", "url": "https://github.com/apache/beam/pull/12973#discussion_r534093226", "bodyText": "Changed the comments. But not added snippets yet, would it be ok to just assume they will look at the new location?", "author": "rezarokni", "createdAt": "2020-12-02T11:24:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk2MzY5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAxNTg0Nw==", "url": "https://github.com/apache/beam/pull/12973#discussion_r538015847", "bodyText": "I am ok with that.", "author": "robinyqiu", "createdAt": "2020-12-08T03:57:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk2MzY5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk3MTAxMA==", "url": "https://github.com/apache/beam/pull/12973#discussion_r516971010", "bodyText": "Nit: the indentation of the code snippets below are off, making it a bit hard to read.", "author": "robinyqiu", "createdAt": "2020-11-03T21:39:53Z", "path": "sdks/java/extensions/zetasketch/src/main/java/org/apache/beam/sdk/extensions/zetasketch/ApproximateCountDistinct.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.zetasketch;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.List;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.extensions.zetasketch.HllCount.Init.Builder;\n+import org.apache.beam.sdk.transforms.Contextful;\n+import org.apache.beam.sdk.transforms.Contextful.Fn;\n+import org.apache.beam.sdk.transforms.MapElements;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ProcessFunction;\n+import org.apache.beam.sdk.transforms.display.DisplayData;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.TypeDescriptor;\n+import org.apache.beam.sdk.values.TypeDescriptors;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@code PTransform}s for estimating the number of distinct elements in a {@code PCollection}, or\n+ * the number of distinct values associated with each key in a {@code PCollection} of {@code KV}s.\n+ *\n+ * <p>We make use of the {@link HllCount} implementation for this transform. Please use {@link\n+ * HllCount} directly if you need access to the sketches.\n+ *\n+ * <p>If the object is not one of {@link Byte[]} {@link Integer} {@link Double} {@link String} make\n+ * use of {@link Globally#via} or {@link PerKey#via}\n+ *\n+ * <h3>Examples</h3>\n+ *\n+ * <h4>Example 1: Approximate Count of Longs {@code PCollection<Long>} and specify precision</h4>", "originalCommit": "4f0c3171bf50ecfdac76b23e2d2251cd6df6633d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDA5MzI4Ng==", "url": "https://github.com/apache/beam/pull/12973#discussion_r534093286", "bodyText": "Done.", "author": "rezarokni", "createdAt": "2020-12-02T11:24:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk3MTAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk3MjgyNw==", "url": "https://github.com/apache/beam/pull/12973#discussion_r516972827", "bodyText": "You mean longs?", "author": "robinyqiu", "createdAt": "2020-11-03T21:43:57Z", "path": "sdks/java/extensions/zetasketch/src/main/java/org/apache/beam/sdk/extensions/zetasketch/ApproximateCountDistinct.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.zetasketch;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.List;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.extensions.zetasketch.HllCount.Init.Builder;\n+import org.apache.beam.sdk.transforms.Contextful;\n+import org.apache.beam.sdk.transforms.Contextful.Fn;\n+import org.apache.beam.sdk.transforms.MapElements;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ProcessFunction;\n+import org.apache.beam.sdk.transforms.display.DisplayData;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.TypeDescriptor;\n+import org.apache.beam.sdk.values.TypeDescriptors;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@code PTransform}s for estimating the number of distinct elements in a {@code PCollection}, or\n+ * the number of distinct values associated with each key in a {@code PCollection} of {@code KV}s.\n+ *\n+ * <p>We make use of the {@link HllCount} implementation for this transform. Please use {@link\n+ * HllCount} directly if you need access to the sketches.\n+ *\n+ * <p>If the object is not one of {@link Byte[]} {@link Integer} {@link Double} {@link String} make\n+ * use of {@link Globally#via} or {@link PerKey#via}\n+ *\n+ * <h3>Examples</h3>\n+ *\n+ * <h4>Example 1: Approximate Count of Longs {@code PCollection<Long>} and specify precision</h4>\n+ *\n+ * <pre>{@Code\n+ *     p.apply(\"Int\", Create.of(ints)).apply(\"IntHLL\", ApproximateCountDistinct.globally()", "originalCommit": "4f0c3171bf50ecfdac76b23e2d2251cd6df6633d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDA5MzM0OQ==", "url": "https://github.com/apache/beam/pull/12973#discussion_r534093349", "bodyText": "Yes, corrected.", "author": "rezarokni", "createdAt": "2020-12-02T11:25:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk3MjgyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk3NTQzNw==", "url": "https://github.com/apache/beam/pull/12973#discussion_r516975437", "bodyText": "Duplicate line of code?", "author": "robinyqiu", "createdAt": "2020-11-03T21:49:30Z", "path": "sdks/java/extensions/zetasketch/src/main/java/org/apache/beam/sdk/extensions/zetasketch/ApproximateCountDistinct.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.zetasketch;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.List;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.extensions.zetasketch.HllCount.Init.Builder;\n+import org.apache.beam.sdk.transforms.Contextful;\n+import org.apache.beam.sdk.transforms.Contextful.Fn;\n+import org.apache.beam.sdk.transforms.MapElements;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ProcessFunction;\n+import org.apache.beam.sdk.transforms.display.DisplayData;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.TypeDescriptor;\n+import org.apache.beam.sdk.values.TypeDescriptors;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@code PTransform}s for estimating the number of distinct elements in a {@code PCollection}, or\n+ * the number of distinct values associated with each key in a {@code PCollection} of {@code KV}s.\n+ *\n+ * <p>We make use of the {@link HllCount} implementation for this transform. Please use {@link\n+ * HllCount} directly if you need access to the sketches.\n+ *\n+ * <p>If the object is not one of {@link Byte[]} {@link Integer} {@link Double} {@link String} make\n+ * use of {@link Globally#via} or {@link PerKey#via}\n+ *\n+ * <h3>Examples</h3>\n+ *\n+ * <h4>Example 1: Approximate Count of Longs {@code PCollection<Long>} and specify precision</h4>\n+ *\n+ * <pre>{@Code\n+ *     p.apply(\"Int\", Create.of(ints)).apply(\"IntHLL\", ApproximateCountDistinct.globally()\n+ *     .withPercision(PRECISION));\n+ *     }</pre>\n+ *\n+ * <h4>Example 2: Approximate Count of Key Value {@code PCollection<KV<Integer,Foo>>}</h4>\n+ *\n+ * <pre>{@code\n+ * PCollection<KV<Integer, Long>> result =\n+ * p.apply(\"Int\", Create.of(ints)).apply(\"LongHLL\", ApproximateCountDistinct.perKey());\n+ * }</pre>\n+ *\n+ * <h4>Example 3: Approximate Count of Key Value {@code PCollection<KV<Integer,Foo>>}</h4>\n+ *\n+ * <pre>{@code\n+ * PCollection<KV<Integer, Foo>> approxResultInteger =\n+ *          p.apply(\"Int\", Create.of(Foo))\n+ *          .apply(\"IntHLL\", ApproximateCountDistinct.<Integer, KV<Integer, Integer>>perKey()\n+ *          .via(x -> KV.of(x.getKey(), (long) x.hashCode())));\n+ * }</pre>\n+ */\n+@Experimental\n+public class ApproximateCountDistinct {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ApproximateCountDistinct.class);\n+\n+  private static final List<TypeDescriptor<?>> HLL_IMPLEMENTED_TYPES =\n+      ImmutableList.of(\n+          TypeDescriptors.strings(),\n+          TypeDescriptors.longs(),\n+          TypeDescriptors.integers(),\n+          new TypeDescriptor<byte[]>() {});\n+\n+  public static <T> Globally<T> globally() {\n+    return new AutoValue_ApproximateCountDistinct_Globally.Builder<T>()\n+        .setPrecision(HllCount.DEFAULT_PRECISION)\n+        .build();\n+  }\n+\n+  public static <K, V> PerKey<K, V> perKey() {\n+    return new AutoValue_ApproximateCountDistinct_PerKey.Builder<K, V>()\n+        .setPrecision(HllCount.DEFAULT_PRECISION)\n+        .build();\n+  }\n+\n+  /////////////////////////////////////////////////////////////////////////////\n+\n+  /**\n+   * {@code PTransform} for estimating the number of distinct elements in a {@code PCollection}.\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollection}\n+   */\n+  @AutoValue\n+  public abstract static class Globally<T> extends PTransform<PCollection<T>, PCollection<Long>> {\n+\n+    public abstract int getPrecision();\n+\n+    public abstract Builder<T> toBuilder();\n+\n+    @Nullable\n+    public abstract Contextful<Fn<T, Long>> getMapping();\n+\n+    @AutoValue.Builder\n+    public abstract static class Builder<T> {\n+\n+      public abstract Builder<T> setPrecision(int precision);\n+\n+      public abstract Builder<T> setMapping(Contextful<Fn<T, Long>> value);\n+\n+      public abstract Globally<T> build();\n+    }\n+\n+    public Globally<T> via(ProcessFunction<T, Long> fn) {\n+\n+      return toBuilder().setMapping(Contextful.<T, Long>fn(fn)).build();\n+    }\n+\n+    public <V> Globally<V> withPercision(Integer withPercision) {\n+      this.toBuilder().setPrecision(withPercision).build();", "originalCommit": "4f0c3171bf50ecfdac76b23e2d2251cd6df6633d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDA5MzQzMg==", "url": "https://github.com/apache/beam/pull/12973#discussion_r534093432", "bodyText": "Thanx.", "author": "rezarokni", "createdAt": "2020-12-02T11:25:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk3NTQzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk4NTgwMw==", "url": "https://github.com/apache/beam/pull/12973#discussion_r516985803", "bodyText": "This loc does not match description above", "author": "robinyqiu", "createdAt": "2020-11-03T22:12:21Z", "path": "sdks/java/extensions/zetasketch/src/main/java/org/apache/beam/sdk/extensions/zetasketch/ApproximateCountDistinct.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.zetasketch;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.List;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.extensions.zetasketch.HllCount.Init.Builder;\n+import org.apache.beam.sdk.transforms.Contextful;\n+import org.apache.beam.sdk.transforms.Contextful.Fn;\n+import org.apache.beam.sdk.transforms.MapElements;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ProcessFunction;\n+import org.apache.beam.sdk.transforms.display.DisplayData;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.TypeDescriptor;\n+import org.apache.beam.sdk.values.TypeDescriptors;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@code PTransform}s for estimating the number of distinct elements in a {@code PCollection}, or\n+ * the number of distinct values associated with each key in a {@code PCollection} of {@code KV}s.\n+ *\n+ * <p>We make use of the {@link HllCount} implementation for this transform. Please use {@link\n+ * HllCount} directly if you need access to the sketches.\n+ *\n+ * <p>If the object is not one of {@link Byte[]} {@link Integer} {@link Double} {@link String} make\n+ * use of {@link Globally#via} or {@link PerKey#via}\n+ *\n+ * <h3>Examples</h3>\n+ *\n+ * <h4>Example 1: Approximate Count of Longs {@code PCollection<Long>} and specify precision</h4>\n+ *\n+ * <pre>{@Code\n+ *     p.apply(\"Int\", Create.of(ints)).apply(\"IntHLL\", ApproximateCountDistinct.globally()\n+ *     .withPercision(PRECISION));\n+ *     }</pre>\n+ *\n+ * <h4>Example 2: Approximate Count of Key Value {@code PCollection<KV<Integer,Foo>>}</h4>\n+ *\n+ * <pre>{@code\n+ * PCollection<KV<Integer, Long>> result =\n+ * p.apply(\"Int\", Create.of(ints)).apply(\"LongHLL\", ApproximateCountDistinct.perKey());", "originalCommit": "4f0c3171bf50ecfdac76b23e2d2251cd6df6633d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDA5MzUyMQ==", "url": "https://github.com/apache/beam/pull/12973#discussion_r534093521", "bodyText": "Done.", "author": "rezarokni", "createdAt": "2020-12-02T11:25:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk4NTgwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk4NjE2Mw==", "url": "https://github.com/apache/beam/pull/12973#discussion_r516986163", "bodyText": "I think the function should be something like kv -> KV.of(kv.getKey(), kv.getValue().hashcode())?", "author": "robinyqiu", "createdAt": "2020-11-03T22:13:13Z", "path": "sdks/java/extensions/zetasketch/src/main/java/org/apache/beam/sdk/extensions/zetasketch/ApproximateCountDistinct.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.zetasketch;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.List;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.extensions.zetasketch.HllCount.Init.Builder;\n+import org.apache.beam.sdk.transforms.Contextful;\n+import org.apache.beam.sdk.transforms.Contextful.Fn;\n+import org.apache.beam.sdk.transforms.MapElements;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ProcessFunction;\n+import org.apache.beam.sdk.transforms.display.DisplayData;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.TypeDescriptor;\n+import org.apache.beam.sdk.values.TypeDescriptors;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@code PTransform}s for estimating the number of distinct elements in a {@code PCollection}, or\n+ * the number of distinct values associated with each key in a {@code PCollection} of {@code KV}s.\n+ *\n+ * <p>We make use of the {@link HllCount} implementation for this transform. Please use {@link\n+ * HllCount} directly if you need access to the sketches.\n+ *\n+ * <p>If the object is not one of {@link Byte[]} {@link Integer} {@link Double} {@link String} make\n+ * use of {@link Globally#via} or {@link PerKey#via}\n+ *\n+ * <h3>Examples</h3>\n+ *\n+ * <h4>Example 1: Approximate Count of Longs {@code PCollection<Long>} and specify precision</h4>\n+ *\n+ * <pre>{@Code\n+ *     p.apply(\"Int\", Create.of(ints)).apply(\"IntHLL\", ApproximateCountDistinct.globally()\n+ *     .withPercision(PRECISION));\n+ *     }</pre>\n+ *\n+ * <h4>Example 2: Approximate Count of Key Value {@code PCollection<KV<Integer,Foo>>}</h4>\n+ *\n+ * <pre>{@code\n+ * PCollection<KV<Integer, Long>> result =\n+ * p.apply(\"Int\", Create.of(ints)).apply(\"LongHLL\", ApproximateCountDistinct.perKey());\n+ * }</pre>\n+ *\n+ * <h4>Example 3: Approximate Count of Key Value {@code PCollection<KV<Integer,Foo>>}</h4>\n+ *\n+ * <pre>{@code\n+ * PCollection<KV<Integer, Foo>> approxResultInteger =\n+ *          p.apply(\"Int\", Create.of(Foo))\n+ *          .apply(\"IntHLL\", ApproximateCountDistinct.<Integer, KV<Integer, Integer>>perKey()\n+ *          .via(x -> KV.of(x.getKey(), (long) x.hashCode())));", "originalCommit": "4f0c3171bf50ecfdac76b23e2d2251cd6df6633d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk5NjUwMg==", "url": "https://github.com/apache/beam/pull/12973#discussion_r516996502", "bodyText": "I think the function here should be 'x -> x.hashCode()' without 'getValue'?", "author": "robinyqiu", "createdAt": "2020-11-03T22:37:45Z", "path": "sdks/java/extensions/zetasketch/src/test/java/org/apache/beam/sdk/extensions/zetasketch/ApproximateCountDistinctTest.java", "diffHunk": "@@ -0,0 +1,342 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.zetasketch;\n+\n+import com.google.zetasketch.HyperLogLogPlusPlus;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.apache.beam.sdk.testing.NeedsRunner;\n+import org.apache.beam.sdk.testing.PAssert;\n+import org.apache.beam.sdk.testing.TestPipeline;\n+import org.apache.beam.sdk.transforms.Create;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.TypeDescriptor;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+/** Tests for {@link ApproximateCountDistinct}. */\n+public class ApproximateCountDistinctTest {\n+\n+  @Rule public final transient TestPipeline p = TestPipeline.create();\n+\n+  // Integer\n+  private static final List<Integer> INTS1 = Arrays.asList(1, 2, 3, 3, 1, 4);\n+  private static final Long INTS1_ESTIMATE;\n+\n+  private static final int TEST_PRECISION = 20;\n+\n+  static {\n+    HyperLogLogPlusPlus<Integer> hll = new HyperLogLogPlusPlus.Builder().buildForIntegers();\n+    INTS1.forEach(hll::add);\n+    INTS1_ESTIMATE = hll.longResult();\n+  }\n+\n+  /** Test correct Builder is returned from Generic type. * */\n+  @Test\n+  public void testIntegerBuilder() {\n+\n+    PCollection<Integer> ints = p.apply(Create.of(1));\n+    HllCount.Init.Builder<Integer> builder =\n+        ApproximateCountDistinct.<Integer>builderForType(\n+            ints.getCoder().getEncodedTypeDescriptor());\n+    PCollection<Long> result = ints.apply(builder.globally()).apply(HllCount.Extract.globally());\n+    PAssert.that(result).containsInAnyOrder(1L);\n+    p.run();\n+  }\n+  /** Test correct Builder is returned from Generic type. * */\n+  @Test\n+  public void testStringBuilder() {\n+\n+    PCollection<String> strings = p.apply(Create.<String>of(\"43\"));\n+    HllCount.Init.Builder<String> builder =\n+        ApproximateCountDistinct.<String>builderForType(\n+            strings.getCoder().getEncodedTypeDescriptor());\n+    PCollection<Long> result = strings.apply(builder.globally()).apply(HllCount.Extract.globally());\n+    PAssert.that(result).containsInAnyOrder(1L);\n+    p.run();\n+  }\n+  /** Test correct Builder is returned from Generic type. * */\n+  @Test\n+  public void testLongBuilder() {\n+\n+    PCollection<Long> longs = p.apply(Create.<Long>of(1L));\n+    HllCount.Init.Builder<Long> builder =\n+        ApproximateCountDistinct.<Long>builderForType(longs.getCoder().getEncodedTypeDescriptor());\n+    PCollection<Long> result = longs.apply(builder.globally()).apply(HllCount.Extract.globally());\n+    PAssert.that(result).containsInAnyOrder(1L);\n+    p.run();\n+  }\n+  /** Test correct Builder is returned from Generic type. * */\n+  @Test\n+  public void testBytesBuilder() {\n+\n+    byte[] byteArray = new byte[] {'A'};\n+    PCollection<byte[]> bytes = p.apply(Create.of(byteArray));\n+    TypeDescriptor a = bytes.getCoder().getEncodedTypeDescriptor();\n+    HllCount.Init.Builder<byte[]> builder =\n+        ApproximateCountDistinct.<byte[]>builderForType(\n+            bytes.getCoder().getEncodedTypeDescriptor());\n+    PCollection<Long> result = bytes.apply(builder.globally()).apply(HllCount.Extract.globally());\n+    PAssert.that(result).containsInAnyOrder(1L);\n+    p.run();\n+  }\n+\n+  /** Test Integer Globally. */\n+  @Test\n+  @Category(NeedsRunner.class)\n+  public void testStandardTypesGlobalForInteger() {\n+    PCollection<Long> approxResultInteger =\n+        p.apply(\"Int\", Create.of(INTS1)).apply(\"IntHLL\", ApproximateCountDistinct.globally());\n+    PAssert.thatSingleton(approxResultInteger).isEqualTo(INTS1_ESTIMATE);\n+    p.run();\n+  }\n+\n+  /** Test Long Globally. */\n+  @Test\n+  @Category(NeedsRunner.class)\n+  public void testStandardTypesGlobalForLong() {\n+\n+    PCollection<Long> approxResultLong =\n+        p.apply(\"Long\", Create.of(INTS1.stream().map(Long::valueOf).collect(Collectors.toList())))\n+            .apply(\"LongHLL\", ApproximateCountDistinct.globally());\n+\n+    PAssert.thatSingleton(approxResultLong).isEqualTo(INTS1_ESTIMATE);\n+\n+    p.run();\n+  }\n+\n+  /** Test String Globally. */\n+  @Test\n+  @Category(NeedsRunner.class)\n+  public void testStandardTypesGlobalForStrings() {\n+    PCollection<Long> approxResultString =\n+        p.apply(\"Str\", Create.of(INTS1.stream().map(String::valueOf).collect(Collectors.toList())))\n+            .apply(\"StrHLL\", ApproximateCountDistinct.globally());\n+\n+    PAssert.thatSingleton(approxResultString).isEqualTo(INTS1_ESTIMATE);\n+\n+    p.run();\n+  }\n+\n+  /** Test Byte Globally. */\n+  @Test\n+  @Category(NeedsRunner.class)\n+  public void testStandardTypesGlobalForBytes() {\n+    PCollection<Long> approxResultByte =\n+        p.apply(\n+                \"BytesHLL\",\n+                Create.of(\n+                    INTS1.stream()\n+                        .map(x -> ByteBuffer.allocate(4).putInt(x).array())\n+                        .collect(Collectors.toList())))\n+            .apply(ApproximateCountDistinct.globally());\n+\n+    PAssert.thatSingleton(approxResultByte).isEqualTo(INTS1_ESTIMATE);\n+\n+    p.run();\n+  }\n+\n+  /** Test Integer Globally. */\n+  @Test\n+  @Category(NeedsRunner.class)\n+  public void testStandardTypesPerKeyForInteger() {\n+\n+    List<KV<Integer, Integer>> ints = new ArrayList<>();\n+\n+    for (int i = 0; i < 3; i++) {\n+      for (int k : INTS1) {\n+        ints.add(KV.of(i, k));\n+      }\n+    }\n+\n+    PCollection<KV<Integer, Long>> result =\n+        p.apply(\"Int\", Create.of(ints)).apply(\"IntHLL\", ApproximateCountDistinct.perKey());\n+\n+    PAssert.that(result)\n+        .containsInAnyOrder(\n+            ImmutableList.of(\n+                KV.of(0, INTS1_ESTIMATE), KV.of(1, INTS1_ESTIMATE), KV.of(2, INTS1_ESTIMATE)));\n+\n+    p.run();\n+  }\n+\n+  /** Test Long Globally. */\n+  @Test\n+  @Category(NeedsRunner.class)\n+  public void testStandardTypesPerKeyForLong() {\n+\n+    List<KV<Integer, Long>> longs = new ArrayList<>();\n+\n+    for (int i = 0; i < 3; i++) {\n+      for (int k : INTS1) {\n+        longs.add(KV.of(i, (long) k));\n+      }\n+    }\n+\n+    PCollection<KV<Integer, Long>> result =\n+        p.apply(\"Long\", Create.of(longs)).apply(\"LongHLL\", ApproximateCountDistinct.perKey());\n+\n+    PAssert.that(result)\n+        .containsInAnyOrder(\n+            ImmutableList.of(\n+                KV.of(0, INTS1_ESTIMATE), KV.of(1, INTS1_ESTIMATE), KV.of(2, INTS1_ESTIMATE)));\n+\n+    p.run();\n+  }\n+\n+  /** Test String Globally. */\n+  @Test\n+  @Category(NeedsRunner.class)\n+  public void testStandardTypesPerKeyForStrings() {\n+    List<KV<Integer, String>> strings = new ArrayList<>();\n+\n+    for (int i = 0; i < 3; i++) {\n+      for (int k : INTS1) {\n+        strings.add(KV.of(i, String.valueOf(k)));\n+      }\n+    }\n+\n+    PCollection<KV<Integer, Long>> result =\n+        p.apply(\"Str\", Create.of(strings)).apply(\"StrHLL\", ApproximateCountDistinct.perKey());\n+\n+    PAssert.that(result)\n+        .containsInAnyOrder(\n+            ImmutableList.of(\n+                KV.of(0, INTS1_ESTIMATE), KV.of(1, INTS1_ESTIMATE), KV.of(2, INTS1_ESTIMATE)));\n+\n+    p.run();\n+  }\n+\n+  /** Test Byte Globally. */\n+  @Test\n+  @Category(NeedsRunner.class)\n+  public void testStandardTypesPerKeyForBytes() {\n+\n+    List<KV<Integer, byte[]>> bytes = new ArrayList<>();\n+\n+    for (int i = 0; i < 3; i++) {\n+      for (int k : INTS1) {\n+        bytes.add(KV.of(i, ByteBuffer.allocate(4).putInt(k).array()));\n+      }\n+    }\n+\n+    PCollection<KV<Integer, Long>> result =\n+        p.apply(\"BytesHLL\", Create.of(bytes)).apply(ApproximateCountDistinct.perKey());\n+\n+    PAssert.that(result)\n+        .containsInAnyOrder(\n+            ImmutableList.of(\n+                KV.of(0, INTS1_ESTIMATE), KV.of(1, INTS1_ESTIMATE), KV.of(2, INTS1_ESTIMATE)));\n+\n+    p.run();\n+  }\n+\n+  /** Test a general object, we will make use of a KV as the object as it already has a coder. */\n+  @Test\n+  @Category(NeedsRunner.class)\n+  public void testObjectTypesGlobal() {\n+\n+    PCollection<Long> approxResultInteger =\n+        p.apply(\n+                \"Int\",\n+                Create.of(\n+                    INTS1.stream().map(x -> KV.of(x, KV.of(x, x))).collect(Collectors.toList())))\n+            .apply(\n+                \"IntHLL\",\n+                ApproximateCountDistinct.<KV<Integer, KV<Integer, Integer>>>globally()\n+                    .via((KV<Integer, KV<Integer, Integer>> x) -> (long) x.getValue().hashCode()));", "originalCommit": "4f0c3171bf50ecfdac76b23e2d2251cd6df6633d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDA5NDIyNA==", "url": "https://github.com/apache/beam/pull/12973#discussion_r534094224", "bodyText": "The value in this case is the KV<int,int> we are using a KV here as a convenient object , so we need the unique from the value which comes from KV<int,KV<int,int>>", "author": "rezarokni", "createdAt": "2020-12-02T11:26:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk5NjUwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAxODMyNQ==", "url": "https://github.com/apache/beam/pull/12973#discussion_r538018325", "bodyText": "I see. This tests will pass, but I find it a bit hard to understand. How about we use x -> x.getValue().getValue()? I find that simpler to understand. (e.g. KV<x, KV<x, x>> will be identified by x)", "author": "robinyqiu", "createdAt": "2020-12-08T04:05:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk5NjUwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2MzA2MA==", "url": "https://github.com/apache/beam/pull/12973#discussion_r547263060", "bodyText": "If we getValue().getValue() then we will get the value of the 2nd KV which is not going to be unique as KV<1,KV<2,3>> is not == to KV<1,KV<3,3>> . If KV is an issue I can create a new POJO just for this test. Using a KV within a KV is just an easy convenience.", "author": "rezarokni", "createdAt": "2020-12-22T12:57:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk5NjUwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMzNzkxNw==", "url": "https://github.com/apache/beam/pull/12973#discussion_r547337917", "bodyText": "PS as you have LGTM is it ok to merge as is , or do you need the test changed before ?", "author": "rezarokni", "createdAt": "2020-12-22T15:22:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk5NjUwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTA1MzIwNg==", "url": "https://github.com/apache/beam/pull/12973#discussion_r549053206", "bodyText": "@robinyqiu are you ok with this being merged without the change to the Test ? Thanx.", "author": "rezarokni", "createdAt": "2020-12-27T01:59:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk5NjUwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1ODgwNg==", "url": "https://github.com/apache/beam/pull/12973#discussion_r549458806", "bodyText": "I am ok with merging it as it is.", "author": "robinyqiu", "createdAt": "2020-12-28T19:18:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk5NjUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk5NjkxNA==", "url": "https://github.com/apache/beam/pull/12973#discussion_r516996914", "bodyText": "Same here. Shouldn't we use x -> KV.of(x.getKey(), x.getValue().hashCode()) here?", "author": "robinyqiu", "createdAt": "2020-11-03T22:38:53Z", "path": "sdks/java/extensions/zetasketch/src/test/java/org/apache/beam/sdk/extensions/zetasketch/ApproximateCountDistinctTest.java", "diffHunk": "@@ -0,0 +1,342 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.zetasketch;\n+\n+import com.google.zetasketch.HyperLogLogPlusPlus;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.apache.beam.sdk.testing.NeedsRunner;\n+import org.apache.beam.sdk.testing.PAssert;\n+import org.apache.beam.sdk.testing.TestPipeline;\n+import org.apache.beam.sdk.transforms.Create;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.TypeDescriptor;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+/** Tests for {@link ApproximateCountDistinct}. */\n+public class ApproximateCountDistinctTest {\n+\n+  @Rule public final transient TestPipeline p = TestPipeline.create();\n+\n+  // Integer\n+  private static final List<Integer> INTS1 = Arrays.asList(1, 2, 3, 3, 1, 4);\n+  private static final Long INTS1_ESTIMATE;\n+\n+  private static final int TEST_PRECISION = 20;\n+\n+  static {\n+    HyperLogLogPlusPlus<Integer> hll = new HyperLogLogPlusPlus.Builder().buildForIntegers();\n+    INTS1.forEach(hll::add);\n+    INTS1_ESTIMATE = hll.longResult();\n+  }\n+\n+  /** Test correct Builder is returned from Generic type. * */\n+  @Test\n+  public void testIntegerBuilder() {\n+\n+    PCollection<Integer> ints = p.apply(Create.of(1));\n+    HllCount.Init.Builder<Integer> builder =\n+        ApproximateCountDistinct.<Integer>builderForType(\n+            ints.getCoder().getEncodedTypeDescriptor());\n+    PCollection<Long> result = ints.apply(builder.globally()).apply(HllCount.Extract.globally());\n+    PAssert.that(result).containsInAnyOrder(1L);\n+    p.run();\n+  }\n+  /** Test correct Builder is returned from Generic type. * */\n+  @Test\n+  public void testStringBuilder() {\n+\n+    PCollection<String> strings = p.apply(Create.<String>of(\"43\"));\n+    HllCount.Init.Builder<String> builder =\n+        ApproximateCountDistinct.<String>builderForType(\n+            strings.getCoder().getEncodedTypeDescriptor());\n+    PCollection<Long> result = strings.apply(builder.globally()).apply(HllCount.Extract.globally());\n+    PAssert.that(result).containsInAnyOrder(1L);\n+    p.run();\n+  }\n+  /** Test correct Builder is returned from Generic type. * */\n+  @Test\n+  public void testLongBuilder() {\n+\n+    PCollection<Long> longs = p.apply(Create.<Long>of(1L));\n+    HllCount.Init.Builder<Long> builder =\n+        ApproximateCountDistinct.<Long>builderForType(longs.getCoder().getEncodedTypeDescriptor());\n+    PCollection<Long> result = longs.apply(builder.globally()).apply(HllCount.Extract.globally());\n+    PAssert.that(result).containsInAnyOrder(1L);\n+    p.run();\n+  }\n+  /** Test correct Builder is returned from Generic type. * */\n+  @Test\n+  public void testBytesBuilder() {\n+\n+    byte[] byteArray = new byte[] {'A'};\n+    PCollection<byte[]> bytes = p.apply(Create.of(byteArray));\n+    TypeDescriptor a = bytes.getCoder().getEncodedTypeDescriptor();\n+    HllCount.Init.Builder<byte[]> builder =\n+        ApproximateCountDistinct.<byte[]>builderForType(\n+            bytes.getCoder().getEncodedTypeDescriptor());\n+    PCollection<Long> result = bytes.apply(builder.globally()).apply(HllCount.Extract.globally());\n+    PAssert.that(result).containsInAnyOrder(1L);\n+    p.run();\n+  }\n+\n+  /** Test Integer Globally. */\n+  @Test\n+  @Category(NeedsRunner.class)\n+  public void testStandardTypesGlobalForInteger() {\n+    PCollection<Long> approxResultInteger =\n+        p.apply(\"Int\", Create.of(INTS1)).apply(\"IntHLL\", ApproximateCountDistinct.globally());\n+    PAssert.thatSingleton(approxResultInteger).isEqualTo(INTS1_ESTIMATE);\n+    p.run();\n+  }\n+\n+  /** Test Long Globally. */\n+  @Test\n+  @Category(NeedsRunner.class)\n+  public void testStandardTypesGlobalForLong() {\n+\n+    PCollection<Long> approxResultLong =\n+        p.apply(\"Long\", Create.of(INTS1.stream().map(Long::valueOf).collect(Collectors.toList())))\n+            .apply(\"LongHLL\", ApproximateCountDistinct.globally());\n+\n+    PAssert.thatSingleton(approxResultLong).isEqualTo(INTS1_ESTIMATE);\n+\n+    p.run();\n+  }\n+\n+  /** Test String Globally. */\n+  @Test\n+  @Category(NeedsRunner.class)\n+  public void testStandardTypesGlobalForStrings() {\n+    PCollection<Long> approxResultString =\n+        p.apply(\"Str\", Create.of(INTS1.stream().map(String::valueOf).collect(Collectors.toList())))\n+            .apply(\"StrHLL\", ApproximateCountDistinct.globally());\n+\n+    PAssert.thatSingleton(approxResultString).isEqualTo(INTS1_ESTIMATE);\n+\n+    p.run();\n+  }\n+\n+  /** Test Byte Globally. */\n+  @Test\n+  @Category(NeedsRunner.class)\n+  public void testStandardTypesGlobalForBytes() {\n+    PCollection<Long> approxResultByte =\n+        p.apply(\n+                \"BytesHLL\",\n+                Create.of(\n+                    INTS1.stream()\n+                        .map(x -> ByteBuffer.allocate(4).putInt(x).array())\n+                        .collect(Collectors.toList())))\n+            .apply(ApproximateCountDistinct.globally());\n+\n+    PAssert.thatSingleton(approxResultByte).isEqualTo(INTS1_ESTIMATE);\n+\n+    p.run();\n+  }\n+\n+  /** Test Integer Globally. */\n+  @Test\n+  @Category(NeedsRunner.class)\n+  public void testStandardTypesPerKeyForInteger() {\n+\n+    List<KV<Integer, Integer>> ints = new ArrayList<>();\n+\n+    for (int i = 0; i < 3; i++) {\n+      for (int k : INTS1) {\n+        ints.add(KV.of(i, k));\n+      }\n+    }\n+\n+    PCollection<KV<Integer, Long>> result =\n+        p.apply(\"Int\", Create.of(ints)).apply(\"IntHLL\", ApproximateCountDistinct.perKey());\n+\n+    PAssert.that(result)\n+        .containsInAnyOrder(\n+            ImmutableList.of(\n+                KV.of(0, INTS1_ESTIMATE), KV.of(1, INTS1_ESTIMATE), KV.of(2, INTS1_ESTIMATE)));\n+\n+    p.run();\n+  }\n+\n+  /** Test Long Globally. */\n+  @Test\n+  @Category(NeedsRunner.class)\n+  public void testStandardTypesPerKeyForLong() {\n+\n+    List<KV<Integer, Long>> longs = new ArrayList<>();\n+\n+    for (int i = 0; i < 3; i++) {\n+      for (int k : INTS1) {\n+        longs.add(KV.of(i, (long) k));\n+      }\n+    }\n+\n+    PCollection<KV<Integer, Long>> result =\n+        p.apply(\"Long\", Create.of(longs)).apply(\"LongHLL\", ApproximateCountDistinct.perKey());\n+\n+    PAssert.that(result)\n+        .containsInAnyOrder(\n+            ImmutableList.of(\n+                KV.of(0, INTS1_ESTIMATE), KV.of(1, INTS1_ESTIMATE), KV.of(2, INTS1_ESTIMATE)));\n+\n+    p.run();\n+  }\n+\n+  /** Test String Globally. */\n+  @Test\n+  @Category(NeedsRunner.class)\n+  public void testStandardTypesPerKeyForStrings() {\n+    List<KV<Integer, String>> strings = new ArrayList<>();\n+\n+    for (int i = 0; i < 3; i++) {\n+      for (int k : INTS1) {\n+        strings.add(KV.of(i, String.valueOf(k)));\n+      }\n+    }\n+\n+    PCollection<KV<Integer, Long>> result =\n+        p.apply(\"Str\", Create.of(strings)).apply(\"StrHLL\", ApproximateCountDistinct.perKey());\n+\n+    PAssert.that(result)\n+        .containsInAnyOrder(\n+            ImmutableList.of(\n+                KV.of(0, INTS1_ESTIMATE), KV.of(1, INTS1_ESTIMATE), KV.of(2, INTS1_ESTIMATE)));\n+\n+    p.run();\n+  }\n+\n+  /** Test Byte Globally. */\n+  @Test\n+  @Category(NeedsRunner.class)\n+  public void testStandardTypesPerKeyForBytes() {\n+\n+    List<KV<Integer, byte[]>> bytes = new ArrayList<>();\n+\n+    for (int i = 0; i < 3; i++) {\n+      for (int k : INTS1) {\n+        bytes.add(KV.of(i, ByteBuffer.allocate(4).putInt(k).array()));\n+      }\n+    }\n+\n+    PCollection<KV<Integer, Long>> result =\n+        p.apply(\"BytesHLL\", Create.of(bytes)).apply(ApproximateCountDistinct.perKey());\n+\n+    PAssert.that(result)\n+        .containsInAnyOrder(\n+            ImmutableList.of(\n+                KV.of(0, INTS1_ESTIMATE), KV.of(1, INTS1_ESTIMATE), KV.of(2, INTS1_ESTIMATE)));\n+\n+    p.run();\n+  }\n+\n+  /** Test a general object, we will make use of a KV as the object as it already has a coder. */\n+  @Test\n+  @Category(NeedsRunner.class)\n+  public void testObjectTypesGlobal() {\n+\n+    PCollection<Long> approxResultInteger =\n+        p.apply(\n+                \"Int\",\n+                Create.of(\n+                    INTS1.stream().map(x -> KV.of(x, KV.of(x, x))).collect(Collectors.toList())))\n+            .apply(\n+                \"IntHLL\",\n+                ApproximateCountDistinct.<KV<Integer, KV<Integer, Integer>>>globally()\n+                    .via((KV<Integer, KV<Integer, Integer>> x) -> (long) x.getValue().hashCode()));\n+\n+    PAssert.thatSingleton(approxResultInteger).isEqualTo(INTS1_ESTIMATE);\n+\n+    p.run();\n+  }\n+\n+  /** Test a general object, we will make use of a KV as the object as it already has a coder. */\n+  @Test\n+  @Category(NeedsRunner.class)\n+  public void testObjectTypesPerKey() {\n+\n+    List<KV<Integer, KV<Integer, Integer>>> ints = new ArrayList<>();\n+\n+    for (int i = 0; i < 3; i++) {\n+      for (int k : INTS1) {\n+        ints.add(KV.of(i, KV.of(i, k)));\n+      }\n+    }\n+\n+    PCollection<KV<Integer, Long>> approxResultInteger =\n+        p.apply(\"Int\", Create.of(ints))\n+            .apply(\n+                \"IntHLL\",\n+                ApproximateCountDistinct.<Integer, KV<Integer, Integer>>perKey()\n+                    .via(x -> KV.of(x.getKey(), (long) x.hashCode()))", "originalCommit": "4f0c3171bf50ecfdac76b23e2d2251cd6df6633d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "304518d11e3c796d20ab97b4b603676461c2a314", "url": "https://github.com/apache/beam/commit/304518d11e3c796d20ab97b4b603676461c2a314", "message": "Fixup", "committedDate": "2020-12-02T11:37:51Z", "type": "forcePushed"}, {"oid": "44ff0394b31d672d23137d043fa2766a050cc415", "url": "https://github.com/apache/beam/commit/44ff0394b31d672d23137d043fa2766a050cc415", "message": "[BEAM-10234] Create ApproximateDistinct using HLL Impl", "committedDate": "2020-12-22T11:59:41Z", "type": "forcePushed"}, {"oid": "f5ee39d8dbd7697f3ec4b55b1e894dc1bc2e97dd", "url": "https://github.com/apache/beam/commit/f5ee39d8dbd7697f3ec4b55b1e894dc1bc2e97dd", "message": "[BEAM-10234] Create ApproximateDistinct using HLL Impl", "committedDate": "2020-12-22T12:40:15Z", "type": "forcePushed"}, {"oid": "676ff55f81c6691840d59bc023499c6a04616c30", "url": "https://github.com/apache/beam/commit/676ff55f81c6691840d59bc023499c6a04616c30", "message": "[BEAM-10234] Create ApproximateDistinct using HLL Impl", "committedDate": "2020-12-27T01:56:59Z", "type": "forcePushed"}, {"oid": "4370926f9413a86f63280cca0438c807d6ec1b89", "url": "https://github.com/apache/beam/commit/4370926f9413a86f63280cca0438c807d6ec1b89", "message": "[BEAM-10234] Create ApproximateDistinct using HLL Impl", "committedDate": "2021-01-05T01:23:46Z", "type": "commit"}, {"oid": "4370926f9413a86f63280cca0438c807d6ec1b89", "url": "https://github.com/apache/beam/commit/4370926f9413a86f63280cca0438c807d6ec1b89", "message": "[BEAM-10234] Create ApproximateDistinct using HLL Impl", "committedDate": "2021-01-05T01:23:46Z", "type": "forcePushed"}]}