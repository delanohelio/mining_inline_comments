{"pr_number": 11791, "pr_title": "[BEAM-9935] Respect allowed split points and fraction in Go.", "pr_createdAt": "2020-05-22T02:58:11Z", "pr_url": "https://github.com/apache/beam/pull/11791", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM2MTE0NQ==", "url": "https://github.com/apache/beam/pull/11791#discussion_r429361145", "bodyText": "Consider https://golang.org/pkg/sort/#Ints", "author": "lostluck", "createdAt": "2020-05-22T17:08:14Z", "path": "sdks/go/pkg/beam/core/runtime/exec/datasource.go", "diffHunk": "@@ -266,33 +267,85 @@ func (n *DataSource) Progress() ProgressReportSnapshot {\n \treturn ProgressReportSnapshot{PID: n.outputPID, ID: n.SID.PtransformID, Name: n.Name, Count: c}\n }\n \n-// Split takes a sorted set of potential split indices, selects and actuates\n-// split on an appropriate split index, and returns the selected split index\n-// if successful. Returns an error when unable to split.\n+// Split takes a sorted set of potential split indices and a fraction of the\n+// remainder to split at, selects and actuates a split on an appropriate split\n+// index, and returns the selected split index if successful. Returns an error\n+// when unable to split.\n func (n *DataSource) Split(splits []int64, frac float64) (int64, error) {\n-\tif splits == nil {\n-\t\treturn 0, fmt.Errorf(\"failed to split: requested splits were empty\")\n-\t}\n \tif n == nil {\n \t\treturn 0, fmt.Errorf(\"failed to split at requested splits: {%v}, DataSource not initialized\", splits)\n \t}\n+\tif frac > 1.0 {\n+\t\tfrac = 1.0\n+\t} else if frac < 0.0 {\n+\t\tfrac = 0.0\n+\t}\n+\n \tn.mu.Lock()\n-\tc := n.index\n-\t// Find the smallest split index that we haven't yet processed, and set\n-\t// the promised split index to this value.\n-\tfor _, s := range splits {\n-\t\t// // Never split on the first element, or the current element.\n-\t\tif s > 0 && s > c && s <= n.splitIdx {\n-\t\t\tn.splitIdx = s\n-\t\t\tfs := n.splitIdx\n-\t\t\tn.mu.Unlock()\n-\t\t\treturn fs, nil\n-\t\t}\n+\ts, err := splitHelper(n.index, n.splitIdx, splits, frac)\n+\tif err != nil {\n+\t\tn.mu.Unlock()\n+\t\treturn 0, err\n \t}\n+\tn.splitIdx = s\n+\tfs := n.splitIdx\n \tn.mu.Unlock()\n-\t// If we can't find a suitable split index from the requested choices,\n-\t// return an error.\n-\treturn 0, fmt.Errorf(\"failed to split at requested splits: {%v}, DataSource at index: %v\", splits, c)\n+\treturn fs, nil\n+}\n+\n+// splitHelper is a helper function that finds a split point in a range.\n+// currIdx and splitIdx should match the DataSource's index and splitIdx fields,\n+// and represent the start and end of the splittable range respectively. splits\n+// is an optional slice of valid split indices, and if nil then all indices are\n+// considered valid split points. frac must be between [0, 1], and represents\n+// a fraction of the remaining work that the split point aims to be as close\n+// as possible to.\n+func splitHelper(currIdx, splitIdx int64, splits []int64, frac float64) (int64, error) {\n+\t// Get split index from fraction. Find the closest index to the fraction of\n+\t// the remainder.\n+\tvar start int64 = 0\n+\tif currIdx > start {\n+\t\tstart = currIdx\n+\t}\n+\t// This is the first valid split index, since we should never split at 0 or\n+\t// at the current element.\n+\tsafeStart := start + 1\n+\t// The remainder starts at our actual progress (i.e. start), but our final\n+\t// split index has to be >= our safeStart.\n+\tfracIdx := start + int64(math.Round(frac*float64(splitIdx-start)))\n+\tif fracIdx < safeStart {\n+\t\tfracIdx = safeStart\n+\t}\n+\tif splits == nil {\n+\t\t// All split points are valid so just split at fraction.\n+\t\treturn fracIdx, nil\n+\t} else {\n+\t\t// Find the closest unprocessed split point to our fraction.\n+\t\tsort.Slice(splits, func(i, j int) bool { return splits[i] < splits[j] })", "originalCommit": "ffb0c126da4605141650f5c5ec357a791301f8ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgyODk0MA==", "url": "https://github.com/apache/beam/pull/11791#discussion_r430828940", "bodyText": "I don't think that's safe because splits is []int64 instead of []int (that's why I went with sort.Slice instead). If I'm wrong about then I'll switch it.", "author": "youngoli", "createdAt": "2020-05-27T02:52:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM2MTE0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI3NzY4OA==", "url": "https://github.com/apache/beam/pull/11791#discussion_r431277688", "bodyText": "Whoops. Good point. Thanks!", "author": "lostluck", "createdAt": "2020-05-27T16:27:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM2MTE0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM2NDU2NA==", "url": "https://github.com/apache/beam/pull/11791#discussion_r429364564", "bodyText": "The split request in harness.go needs to be passing in the  \"estimated  input elements\" field from the proto that needs to be taken into account.\nhttps://github.com/apache/beam/blob/master/model/fn-execution/src/main/proto/beam_fn_api.proto#L386\nhttps://github.com/apache/beam/blob/master/sdks/go/pkg/beam/core/runtime/harness/harness.go#L313\nThe problem with just relying on the current split index is that it starts at INT64Max, which is generally going to be too high from all the elements, and runners will likely be confused. You might have seen this field in the python code passed around as  \"total_buffer_size\" or similar.\nThat said, other than that, this code looks like it's behaving correctly, since the \"remainder\" is would be the min of estimated_input_elements and Split.\nIt does mean that plan.Split needs an API change to accept the exec.SplitPoints struct instead of the individual values.", "author": "lostluck", "createdAt": "2020-05-22T17:16:28Z", "path": "sdks/go/pkg/beam/core/runtime/exec/datasource.go", "diffHunk": "@@ -266,33 +267,85 @@ func (n *DataSource) Progress() ProgressReportSnapshot {\n \treturn ProgressReportSnapshot{PID: n.outputPID, ID: n.SID.PtransformID, Name: n.Name, Count: c}\n }\n \n-// Split takes a sorted set of potential split indices, selects and actuates\n-// split on an appropriate split index, and returns the selected split index\n-// if successful. Returns an error when unable to split.\n+// Split takes a sorted set of potential split indices and a fraction of the\n+// remainder to split at, selects and actuates a split on an appropriate split\n+// index, and returns the selected split index if successful. Returns an error\n+// when unable to split.\n func (n *DataSource) Split(splits []int64, frac float64) (int64, error) {\n-\tif splits == nil {\n-\t\treturn 0, fmt.Errorf(\"failed to split: requested splits were empty\")\n-\t}\n \tif n == nil {\n \t\treturn 0, fmt.Errorf(\"failed to split at requested splits: {%v}, DataSource not initialized\", splits)\n \t}\n+\tif frac > 1.0 {\n+\t\tfrac = 1.0\n+\t} else if frac < 0.0 {\n+\t\tfrac = 0.0\n+\t}\n+\n \tn.mu.Lock()\n-\tc := n.index\n-\t// Find the smallest split index that we haven't yet processed, and set\n-\t// the promised split index to this value.\n-\tfor _, s := range splits {\n-\t\t// // Never split on the first element, or the current element.\n-\t\tif s > 0 && s > c && s <= n.splitIdx {\n-\t\t\tn.splitIdx = s\n-\t\t\tfs := n.splitIdx\n-\t\t\tn.mu.Unlock()\n-\t\t\treturn fs, nil\n-\t\t}\n+\ts, err := splitHelper(n.index, n.splitIdx, splits, frac)\n+\tif err != nil {\n+\t\tn.mu.Unlock()\n+\t\treturn 0, err\n \t}\n+\tn.splitIdx = s\n+\tfs := n.splitIdx\n \tn.mu.Unlock()\n-\t// If we can't find a suitable split index from the requested choices,\n-\t// return an error.\n-\treturn 0, fmt.Errorf(\"failed to split at requested splits: {%v}, DataSource at index: %v\", splits, c)\n+\treturn fs, nil\n+}\n+\n+// splitHelper is a helper function that finds a split point in a range.\n+// currIdx and splitIdx should match the DataSource's index and splitIdx fields,\n+// and represent the start and end of the splittable range respectively. splits\n+// is an optional slice of valid split indices, and if nil then all indices are\n+// considered valid split points. frac must be between [0, 1], and represents\n+// a fraction of the remaining work that the split point aims to be as close\n+// as possible to.\n+func splitHelper(currIdx, splitIdx int64, splits []int64, frac float64) (int64, error) {\n+\t// Get split index from fraction. Find the closest index to the fraction of\n+\t// the remainder.\n+\tvar start int64 = 0\n+\tif currIdx > start {\n+\t\tstart = currIdx\n+\t}\n+\t// This is the first valid split index, since we should never split at 0 or\n+\t// at the current element.\n+\tsafeStart := start + 1\n+\t// The remainder starts at our actual progress (i.e. start), but our final\n+\t// split index has to be >= our safeStart.\n+\tfracIdx := start + int64(math.Round(frac*float64(splitIdx-start)))\n+\tif fracIdx < safeStart {\n+\t\tfracIdx = safeStart\n+\t}\n+\tif splits == nil {", "originalCommit": "ffb0c126da4605141650f5c5ec357a791301f8ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNTkwNg==", "url": "https://github.com/apache/beam/pull/11791#discussion_r431615906", "bodyText": "Done. I missed that in the original. Added that behavior and a test for it.", "author": "youngoli", "createdAt": "2020-05-28T06:47:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM2NDU2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM2NTIxNw==", "url": "https://github.com/apache/beam/pull/11791#discussion_r429365217", "bodyText": "Also consider https://golang.org/pkg/sort/#Search  or even https://golang.org/pkg/sort/#SearchInts\nThough feel free to benchmark what you've got with an implementation that uses the sort package implementations.", "author": "lostluck", "createdAt": "2020-05-22T17:18:01Z", "path": "sdks/go/pkg/beam/core/runtime/exec/datasource.go", "diffHunk": "@@ -266,33 +267,85 @@ func (n *DataSource) Progress() ProgressReportSnapshot {\n \treturn ProgressReportSnapshot{PID: n.outputPID, ID: n.SID.PtransformID, Name: n.Name, Count: c}\n }\n \n-// Split takes a sorted set of potential split indices, selects and actuates\n-// split on an appropriate split index, and returns the selected split index\n-// if successful. Returns an error when unable to split.\n+// Split takes a sorted set of potential split indices and a fraction of the\n+// remainder to split at, selects and actuates a split on an appropriate split\n+// index, and returns the selected split index if successful. Returns an error\n+// when unable to split.\n func (n *DataSource) Split(splits []int64, frac float64) (int64, error) {\n-\tif splits == nil {\n-\t\treturn 0, fmt.Errorf(\"failed to split: requested splits were empty\")\n-\t}\n \tif n == nil {\n \t\treturn 0, fmt.Errorf(\"failed to split at requested splits: {%v}, DataSource not initialized\", splits)\n \t}\n+\tif frac > 1.0 {\n+\t\tfrac = 1.0\n+\t} else if frac < 0.0 {\n+\t\tfrac = 0.0\n+\t}\n+\n \tn.mu.Lock()\n-\tc := n.index\n-\t// Find the smallest split index that we haven't yet processed, and set\n-\t// the promised split index to this value.\n-\tfor _, s := range splits {\n-\t\t// // Never split on the first element, or the current element.\n-\t\tif s > 0 && s > c && s <= n.splitIdx {\n-\t\t\tn.splitIdx = s\n-\t\t\tfs := n.splitIdx\n-\t\t\tn.mu.Unlock()\n-\t\t\treturn fs, nil\n-\t\t}\n+\ts, err := splitHelper(n.index, n.splitIdx, splits, frac)\n+\tif err != nil {\n+\t\tn.mu.Unlock()\n+\t\treturn 0, err\n \t}\n+\tn.splitIdx = s\n+\tfs := n.splitIdx\n \tn.mu.Unlock()\n-\t// If we can't find a suitable split index from the requested choices,\n-\t// return an error.\n-\treturn 0, fmt.Errorf(\"failed to split at requested splits: {%v}, DataSource at index: %v\", splits, c)\n+\treturn fs, nil\n+}\n+\n+// splitHelper is a helper function that finds a split point in a range.\n+// currIdx and splitIdx should match the DataSource's index and splitIdx fields,\n+// and represent the start and end of the splittable range respectively. splits\n+// is an optional slice of valid split indices, and if nil then all indices are\n+// considered valid split points. frac must be between [0, 1], and represents\n+// a fraction of the remaining work that the split point aims to be as close\n+// as possible to.\n+func splitHelper(currIdx, splitIdx int64, splits []int64, frac float64) (int64, error) {\n+\t// Get split index from fraction. Find the closest index to the fraction of\n+\t// the remainder.\n+\tvar start int64 = 0\n+\tif currIdx > start {\n+\t\tstart = currIdx\n+\t}\n+\t// This is the first valid split index, since we should never split at 0 or\n+\t// at the current element.\n+\tsafeStart := start + 1\n+\t// The remainder starts at our actual progress (i.e. start), but our final\n+\t// split index has to be >= our safeStart.\n+\tfracIdx := start + int64(math.Round(frac*float64(splitIdx-start)))\n+\tif fracIdx < safeStart {\n+\t\tfracIdx = safeStart\n+\t}\n+\tif splits == nil {\n+\t\t// All split points are valid so just split at fraction.\n+\t\treturn fracIdx, nil\n+\t} else {\n+\t\t// Find the closest unprocessed split point to our fraction.\n+\t\tsort.Slice(splits, func(i, j int) bool { return splits[i] < splits[j] })\n+\t\tvar prevDiff int64 = math.MaxInt64\n+\t\tvar bestS int64 = -1\n+\t\tfor _, s := range splits {", "originalCommit": "ffb0c126da4605141650f5c5ec357a791301f8ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI3ODM3NA==", "url": "https://github.com/apache/beam/pull/11791#discussion_r431278374", "bodyText": "Per your comment above, I made a type mistake, and the suggestion is invalid. Thanks!", "author": "lostluck", "createdAt": "2020-05-27T16:28:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM2NTIxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNTMwOA==", "url": "https://github.com/apache/beam/pull/11791#discussion_r431615308", "bodyText": "Ack, although I think Search can probably be done even with int64. Might be worth benchmarking still.", "author": "youngoli", "createdAt": "2020-05-28T06:46:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM2NTIxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM2NTg0OQ==", "url": "https://github.com/apache/beam/pull/11791#discussion_r429365849", "bodyText": "Since the splits could be unbounded in size and get truncated by logging, consider changing the order to have the current index, and the current split point, and then the recommended splits.", "author": "lostluck", "createdAt": "2020-05-22T17:19:36Z", "path": "sdks/go/pkg/beam/core/runtime/exec/datasource.go", "diffHunk": "@@ -266,33 +267,85 @@ func (n *DataSource) Progress() ProgressReportSnapshot {\n \treturn ProgressReportSnapshot{PID: n.outputPID, ID: n.SID.PtransformID, Name: n.Name, Count: c}\n }\n \n-// Split takes a sorted set of potential split indices, selects and actuates\n-// split on an appropriate split index, and returns the selected split index\n-// if successful. Returns an error when unable to split.\n+// Split takes a sorted set of potential split indices and a fraction of the\n+// remainder to split at, selects and actuates a split on an appropriate split\n+// index, and returns the selected split index if successful. Returns an error\n+// when unable to split.\n func (n *DataSource) Split(splits []int64, frac float64) (int64, error) {\n-\tif splits == nil {\n-\t\treturn 0, fmt.Errorf(\"failed to split: requested splits were empty\")\n-\t}\n \tif n == nil {\n \t\treturn 0, fmt.Errorf(\"failed to split at requested splits: {%v}, DataSource not initialized\", splits)\n \t}\n+\tif frac > 1.0 {\n+\t\tfrac = 1.0\n+\t} else if frac < 0.0 {\n+\t\tfrac = 0.0\n+\t}\n+\n \tn.mu.Lock()\n-\tc := n.index\n-\t// Find the smallest split index that we haven't yet processed, and set\n-\t// the promised split index to this value.\n-\tfor _, s := range splits {\n-\t\t// // Never split on the first element, or the current element.\n-\t\tif s > 0 && s > c && s <= n.splitIdx {\n-\t\t\tn.splitIdx = s\n-\t\t\tfs := n.splitIdx\n-\t\t\tn.mu.Unlock()\n-\t\t\treturn fs, nil\n-\t\t}\n+\ts, err := splitHelper(n.index, n.splitIdx, splits, frac)\n+\tif err != nil {\n+\t\tn.mu.Unlock()\n+\t\treturn 0, err\n \t}\n+\tn.splitIdx = s\n+\tfs := n.splitIdx\n \tn.mu.Unlock()\n-\t// If we can't find a suitable split index from the requested choices,\n-\t// return an error.\n-\treturn 0, fmt.Errorf(\"failed to split at requested splits: {%v}, DataSource at index: %v\", splits, c)\n+\treturn fs, nil\n+}\n+\n+// splitHelper is a helper function that finds a split point in a range.\n+// currIdx and splitIdx should match the DataSource's index and splitIdx fields,\n+// and represent the start and end of the splittable range respectively. splits\n+// is an optional slice of valid split indices, and if nil then all indices are\n+// considered valid split points. frac must be between [0, 1], and represents\n+// a fraction of the remaining work that the split point aims to be as close\n+// as possible to.\n+func splitHelper(currIdx, splitIdx int64, splits []int64, frac float64) (int64, error) {\n+\t// Get split index from fraction. Find the closest index to the fraction of\n+\t// the remainder.\n+\tvar start int64 = 0\n+\tif currIdx > start {\n+\t\tstart = currIdx\n+\t}\n+\t// This is the first valid split index, since we should never split at 0 or\n+\t// at the current element.\n+\tsafeStart := start + 1\n+\t// The remainder starts at our actual progress (i.e. start), but our final\n+\t// split index has to be >= our safeStart.\n+\tfracIdx := start + int64(math.Round(frac*float64(splitIdx-start)))\n+\tif fracIdx < safeStart {\n+\t\tfracIdx = safeStart\n+\t}\n+\tif splits == nil {\n+\t\t// All split points are valid so just split at fraction.\n+\t\treturn fracIdx, nil\n+\t} else {\n+\t\t// Find the closest unprocessed split point to our fraction.\n+\t\tsort.Slice(splits, func(i, j int) bool { return splits[i] < splits[j] })\n+\t\tvar prevDiff int64 = math.MaxInt64\n+\t\tvar bestS int64 = -1\n+\t\tfor _, s := range splits {\n+\t\t\tif s >= safeStart && s <= splitIdx {\n+\t\t\t\tdiff := intAbs(fracIdx - s)\n+\t\t\t\tif diff <= prevDiff {\n+\t\t\t\t\tprevDiff = diff\n+\t\t\t\t\tbestS = s\n+\t\t\t\t} else {\n+\t\t\t\t\tbreak // Stop early if the difference starts increasing.\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif bestS != -1 {\n+\t\t\treturn bestS, nil\n+\t\t}\n+\t}\n+\treturn 0, fmt.Errorf(\"failed to split at requested splits: {%v}, DataSource at index: %v\", splits, currIdx)", "originalCommit": "ffb0c126da4605141650f5c5ec357a791301f8ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNTQyNg==", "url": "https://github.com/apache/beam/pull/11791#discussion_r431615426", "bodyText": "Done.", "author": "youngoli", "createdAt": "2020-05-28T06:46:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM2NTg0OQ=="}], "type": "inlineReview"}, {"oid": "a5e642aa01f867e8c84df4a813767355eee60af4", "url": "https://github.com/apache/beam/commit/a5e642aa01f867e8c84df4a813767355eee60af4", "message": "[BEAM-9935] Respect allowed split points and fraction in Go.\n\nAdds code to more closely align with the implementations of splitting in\nPython and Java. Note that not all cases are implemented. There is no\nmeasurement of sub-element progress yet, nor is there sub-element (SDF)\nsplitting yet.", "committedDate": "2020-05-28T21:21:04Z", "type": "commit"}, {"oid": "a5e642aa01f867e8c84df4a813767355eee60af4", "url": "https://github.com/apache/beam/commit/a5e642aa01f867e8c84df4a813767355eee60af4", "message": "[BEAM-9935] Respect allowed split points and fraction in Go.\n\nAdds code to more closely align with the implementations of splitting in\nPython and Java. Note that not all cases are implemented. There is no\nmeasurement of sub-element progress yet, nor is there sub-element (SDF)\nsplitting yet.", "committedDate": "2020-05-28T21:21:04Z", "type": "forcePushed"}]}