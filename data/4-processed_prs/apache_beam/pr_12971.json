{"pr_number": 12971, "pr_title": "[BEAM-10988] Partition dataframes according to size estimates.", "pr_createdAt": "2020-09-29T23:38:13Z", "pr_url": "https://github.com/apache/beam/pull/12971", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2MTk3Mg==", "url": "https://github.com/apache/beam/pull/12971#discussion_r501261972", "bodyText": "This is making the assumption that this stage's outputs are equal to the sum of the sizes of the inputs right? Could you document that here?", "author": "TheNeuralBit", "createdAt": "2020-10-07T19:36:04Z", "path": "sdks/python/apache_beam/dataframe/transforms.py", "diffHunk": "@@ -166,16 +173,40 @@ def expand(self, pcolls):\n           partitioned_pcoll = next(pcolls.values()).pipeline | beam.Create([{}])\n \n         elif self.stage.partitioning != partitionings.Nothing():\n+          # Partitioning required for these operations.\n+          # Compute the number of partitions to use based on estimated size.\n+          if self.stage.partitioning == partitionings.Singleton():\n+            # Always a single partition, don't waste time computing sizes.\n+            num_partitions = 1\n+          else:\n+            # Estimate the sizes from the outputs of a *previous* stage such\n+            # that using these estimates will not cause a fusion break.\n+            input_sizes = [\n+                estimate_size(input, same_stage_ok=False)\n+                for input in tabular_inputs\n+            ]\n+            if None in input_sizes:\n+              # We were unable to (cheaply) compute the size of one or more\n+              # inputs.\n+              num_partitions = DEFAULT_PARTITIONS\n+            else:\n+              num_partitions = beam.pvalue.AsSingleton(\n+                  input_sizes\n+                  | 'FlattenSizes' >> beam.Flatten()\n+                  | 'SumSizes' >> beam.CombineGlobally(sum)", "originalCommit": "e045d92089ebed25a96ba9a5f43cac1a33512231", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA5MDkzMg==", "url": "https://github.com/apache/beam/pull/12971#discussion_r502090932", "bodyText": "Not quite. We want the size of the inputs to partition the inputs; we don't care about the output size of this stage at all. Clarified in the comment above.\nNote also that these \"stages\" are not the same as fused executable \"stages.\" In particular, these \"stages\" contain a (Co)GBK along with some operations that proceed it.", "author": "robertwb", "createdAt": "2020-10-09T00:19:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2MTk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1NzUzMw==", "url": "https://github.com/apache/beam/pull/12971#discussion_r502557533", "bodyText": "The reason I mentioned the outputs of this stage is that it looks like the objective is for the output partition sizes to be equal to TARGET_PARTITION_SIZE iff the size of each output is equal to the sum of the sizes of the inputs. It looks like you do have a comment to that effect in estimate_sizes", "author": "TheNeuralBit", "createdAt": "2020-10-09T16:54:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2MTk3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3MDI5MA==", "url": "https://github.com/apache/beam/pull/12971#discussion_r501270290", "bodyText": "Did you do some benchmarks that motivated this?", "author": "TheNeuralBit", "createdAt": "2020-10-07T19:51:56Z", "path": "sdks/python/apache_beam/dataframe/transforms.py", "diffHunk": "@@ -321,17 +352,100 @@ def expr_to_pcoll(expr):\n       else:\n         return stage_to_result(expr_to_stage(expr))[expr._id]\n \n+    @memoize\n+    def estimate_size(expr, same_stage_ok):\n+      # Returns a pcollection of ints whose sum is the estimated size of the\n+      # given expression.\n+      pipeline = next(iter(inputs.values())).pipeline\n+      label = 'Size[%s, %s]' % (expr._id, same_stage_ok)\n+      if is_scalar(expr):\n+        return pipeline | label >> beam.Create([0])\n+      elif same_stage_ok:\n+        return expr_to_pcoll(expr) | label >> beam.Map(_total_memory_usage)\n+      elif expr in inputs:\n+        return None\n+      else:\n+        # This is the stage to avoid.\n+        expr_stage = expr_to_stage(expr)\n+        # If the stage doesn't start with a shuffle, it's not safe to fuse\n+        # the computation into its parent either.\n+        has_shuffle = expr_stage.partitioning != partitionings.Nothing()\n+        # We assume the size of an expression is the sum of the size of its\n+        # inputs, which may be off by quite a bit, but the goal is to get\n+        # within an order of magnitude or two.\n+        arg_sizes = []\n+        for arg in expr.args():\n+          if is_scalar(arg):\n+            continue\n+          elif arg in inputs:\n+            return None\n+          arg_size = estimate_size(\n+              arg,\n+              same_stage_ok=has_shuffle and expr_to_stage(arg) != expr_stage)\n+          if arg_size is None:\n+            return None\n+          arg_sizes.append(arg_size)\n+        return arg_sizes | label >> beam.Flatten(pipeline=pipeline)\n+\n     # Now we can compute and return the result.\n     return {k: expr_to_pcoll(expr) for k, expr in outputs.items()}\n \n \n+def _total_memory_usage(frame):\n+  assert isinstance(frame, (pd.core.generic.NDFrame, pd.Index))\n+  try:\n+    size = frame.memory_usage()\n+    if not isinstance(size, int):\n+      size = size.sum()\n+    return size\n+  except AttributeError:\n+    # Don't know, assume it's really big.\n+    float('inf')\n+\n+\n+class _ReBatch(beam.DoFn):\n+  \"\"\"Groups all the parts from various workers into the same dataframe.\n+\n+  Also groups across partitions, up to a given data size, to recover some\n+  efficiency in the face of over-partitioning.", "originalCommit": "e045d92089ebed25a96ba9a5f43cac1a33512231", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA5MTQ4MQ==", "url": "https://github.com/apache/beam/pull/12971#discussion_r502091481", "bodyText": "Mostly the observation that there were a plethora of tiny/empty dataframes when debugging, and the realization that this could be worse given the dynamic partitioning choices (which err on the side of overestimation).\nI also ran some simple benchmarks and determined that, for simple operations, things started to become linear in around the MB range.", "author": "robertwb", "createdAt": "2020-10-09T00:21:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3MDI5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3MDk2Ng==", "url": "https://github.com/apache/beam/pull/12971#discussion_r501270966", "bodyText": "Should this actually be TARGET_PARTITION_SIZE*num_partitions (I believe that's possible), since it's the data limit across every partition?", "author": "TheNeuralBit", "createdAt": "2020-10-07T19:53:13Z", "path": "sdks/python/apache_beam/dataframe/transforms.py", "diffHunk": "@@ -321,17 +352,100 @@ def expr_to_pcoll(expr):\n       else:\n         return stage_to_result(expr_to_stage(expr))[expr._id]\n \n+    @memoize\n+    def estimate_size(expr, same_stage_ok):\n+      # Returns a pcollection of ints whose sum is the estimated size of the\n+      # given expression.\n+      pipeline = next(iter(inputs.values())).pipeline\n+      label = 'Size[%s, %s]' % (expr._id, same_stage_ok)\n+      if is_scalar(expr):\n+        return pipeline | label >> beam.Create([0])\n+      elif same_stage_ok:\n+        return expr_to_pcoll(expr) | label >> beam.Map(_total_memory_usage)\n+      elif expr in inputs:\n+        return None\n+      else:\n+        # This is the stage to avoid.\n+        expr_stage = expr_to_stage(expr)\n+        # If the stage doesn't start with a shuffle, it's not safe to fuse\n+        # the computation into its parent either.\n+        has_shuffle = expr_stage.partitioning != partitionings.Nothing()\n+        # We assume the size of an expression is the sum of the size of its\n+        # inputs, which may be off by quite a bit, but the goal is to get\n+        # within an order of magnitude or two.\n+        arg_sizes = []\n+        for arg in expr.args():\n+          if is_scalar(arg):\n+            continue\n+          elif arg in inputs:\n+            return None\n+          arg_size = estimate_size(\n+              arg,\n+              same_stage_ok=has_shuffle and expr_to_stage(arg) != expr_stage)\n+          if arg_size is None:\n+            return None\n+          arg_sizes.append(arg_size)\n+        return arg_sizes | label >> beam.Flatten(pipeline=pipeline)\n+\n     # Now we can compute and return the result.\n     return {k: expr_to_pcoll(expr) for k, expr in outputs.items()}\n \n \n+def _total_memory_usage(frame):\n+  assert isinstance(frame, (pd.core.generic.NDFrame, pd.Index))\n+  try:\n+    size = frame.memory_usage()\n+    if not isinstance(size, int):\n+      size = size.sum()\n+    return size\n+  except AttributeError:\n+    # Don't know, assume it's really big.\n+    float('inf')\n+\n+\n+class _ReBatch(beam.DoFn):\n+  \"\"\"Groups all the parts from various workers into the same dataframe.\n+\n+  Also groups across partitions, up to a given data size, to recover some\n+  efficiency in the face of over-partitioning.\n+  \"\"\"\n+  def __init__(self, target_size=TARGET_PARTITION_SIZE):", "originalCommit": "e045d92089ebed25a96ba9a5f43cac1a33512231", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk3MDU4OA==", "url": "https://github.com/apache/beam/pull/12971#discussion_r501970588", "bodyText": "Discussed this offline. I was misunderstanding the code, I thought this was summing the memory usage across partition keys, but for tag, parts is actually aggregating across the tagged inputs. The partition keys are ignored (the _ on line 424), because they're no longer needed. At this point they've served their purpose of distributing data across workers, so its fine to merge across them.\nIt may make sense to set the target size to TARGET_PARTITION_SIZE*num_inputs, but I'm fine without it.", "author": "TheNeuralBit", "createdAt": "2020-10-08T19:44:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3MDk2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA5MjA4Ng==", "url": "https://github.com/apache/beam/pull/12971#discussion_r502092086", "bodyText": "Having thought about it, I'm going to leave it for now. The reason to have a bound is to bound the total amount of memory on a worker (and amount of compute to couple in downstream operations), and that makes sense to cap across inputs rather than per-input. We could revisit in the future.", "author": "robertwb", "createdAt": "2020-10-09T00:23:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3MDk2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3MzQzNw==", "url": "https://github.com/apache/beam/pull/12971#discussion_r501273437", "bodyText": "I'm curious if it's always beneficial to use pd.concat here. I was under the impression that it copies and re-arranges buffers into columns", "author": "TheNeuralBit", "createdAt": "2020-10-07T19:57:55Z", "path": "sdks/python/apache_beam/dataframe/transforms.py", "diffHunk": "@@ -321,17 +352,100 @@ def expr_to_pcoll(expr):\n       else:\n         return stage_to_result(expr_to_stage(expr))[expr._id]\n \n+    @memoize\n+    def estimate_size(expr, same_stage_ok):\n+      # Returns a pcollection of ints whose sum is the estimated size of the\n+      # given expression.\n+      pipeline = next(iter(inputs.values())).pipeline\n+      label = 'Size[%s, %s]' % (expr._id, same_stage_ok)\n+      if is_scalar(expr):\n+        return pipeline | label >> beam.Create([0])\n+      elif same_stage_ok:\n+        return expr_to_pcoll(expr) | label >> beam.Map(_total_memory_usage)\n+      elif expr in inputs:\n+        return None\n+      else:\n+        # This is the stage to avoid.\n+        expr_stage = expr_to_stage(expr)\n+        # If the stage doesn't start with a shuffle, it's not safe to fuse\n+        # the computation into its parent either.\n+        has_shuffle = expr_stage.partitioning != partitionings.Nothing()\n+        # We assume the size of an expression is the sum of the size of its\n+        # inputs, which may be off by quite a bit, but the goal is to get\n+        # within an order of magnitude or two.\n+        arg_sizes = []\n+        for arg in expr.args():\n+          if is_scalar(arg):\n+            continue\n+          elif arg in inputs:\n+            return None\n+          arg_size = estimate_size(\n+              arg,\n+              same_stage_ok=has_shuffle and expr_to_stage(arg) != expr_stage)\n+          if arg_size is None:\n+            return None\n+          arg_sizes.append(arg_size)\n+        return arg_sizes | label >> beam.Flatten(pipeline=pipeline)\n+\n     # Now we can compute and return the result.\n     return {k: expr_to_pcoll(expr) for k, expr in outputs.items()}\n \n \n+def _total_memory_usage(frame):\n+  assert isinstance(frame, (pd.core.generic.NDFrame, pd.Index))\n+  try:\n+    size = frame.memory_usage()\n+    if not isinstance(size, int):\n+      size = size.sum()\n+    return size\n+  except AttributeError:\n+    # Don't know, assume it's really big.\n+    float('inf')\n+\n+\n+class _ReBatch(beam.DoFn):\n+  \"\"\"Groups all the parts from various workers into the same dataframe.\n+\n+  Also groups across partitions, up to a given data size, to recover some\n+  efficiency in the face of over-partitioning.\n+  \"\"\"\n+  def __init__(self, target_size=TARGET_PARTITION_SIZE):\n+    self._target_size = target_size\n+\n+  def start_bundle(self):\n+    self._parts = collections.defaultdict(lambda: collections.defaultdict(list))\n+    self._running_size = 0\n+\n+  def process(\n+      self,\n+      element,\n+      window=beam.DoFn.WindowParam,\n+      timestamp=beam.DoFn.TimestampParam):\n+    _, tagged_parts = element\n+    for tag, parts in tagged_parts.items():\n+      for part in parts:\n+        self._running_size += _total_memory_usage(part)\n+      self._parts[window, timestamp][tag].extend(parts)\n+    if self._running_size >= self._target_size:\n+      self.finish_bundle()\n+\n+  def finish_bundle(self):\n+    for (window, timestamp), tagged_parts in self._parts.items():\n+      yield windowed_value.WindowedValue(\n+          {tag: pd.concat(parts)", "originalCommit": "e045d92089ebed25a96ba9a5f43cac1a33512231", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA5Mjk0MQ==", "url": "https://github.com/apache/beam/pull/12971#discussion_r502092941", "bodyText": "How beneficial it is depends on the size of the inputs. For tiny inputs, the cost of copying is easily absorbed in the overhead savings of future operations, but for large inputs it could dominate. It may make sense to try to tune TARGET_PARTITION_SIZE to find the right tradeoff.", "author": "robertwb", "createdAt": "2020-10-09T00:27:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3MzQzNw=="}], "type": "inlineReview"}, {"oid": "b231cfc21d58004f753427b99212d957f3ad7d3c", "url": "https://github.com/apache/beam/commit/b231cfc21d58004f753427b99212d957f3ad7d3c", "message": "[BEAM-10988] Partition dataframes according to size estimates.\n\nSizes are directly measured in preceeding stages and estimated from\nthere to avoid expensive fusion breaks due to using the global size\nas a side input.", "committedDate": "2020-10-09T00:32:44Z", "type": "commit"}, {"oid": "ec7c34495a778976883608bcd2a60663e4cf2d7b", "url": "https://github.com/apache/beam/commit/ec7c34495a778976883608bcd2a60663e4cf2d7b", "message": "[BEAM-10988] Batch dataframes across partitions on the same worker.\n\nThis greatly reduces the performance penalty of over-partitioning.", "committedDate": "2020-10-09T00:32:44Z", "type": "commit"}, {"oid": "ec7c34495a778976883608bcd2a60663e4cf2d7b", "url": "https://github.com/apache/beam/commit/ec7c34495a778976883608bcd2a60663e4cf2d7b", "message": "[BEAM-10988] Batch dataframes across partitions on the same worker.\n\nThis greatly reduces the performance penalty of over-partitioning.", "committedDate": "2020-10-09T00:32:44Z", "type": "forcePushed"}]}