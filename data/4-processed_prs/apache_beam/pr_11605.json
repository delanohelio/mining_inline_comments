{"pr_number": 11605, "pr_title": "[BEAM-9883] Refactor SDF test restrictions.", "pr_createdAt": "2020-05-04T21:11:48Z", "pr_url": "https://github.com/apache/beam/pull/11605", "timeline": [{"oid": "80d77c00509b8d64563b70fcaaae8eb05a644c4c", "url": "https://github.com/apache/beam/commit/80d77c00509b8d64563b70fcaaae8eb05a644c4c", "message": "[BEAM-9883] Refactor SDF test restrictions.\n\nRefactoring the restriction used for testing SDFs. Instead of having\nsome obtuse behavior that we can validate, it now just contains a bunch\nof flags we can flip to track that it was used in each method.", "committedDate": "2020-05-05T00:45:30Z", "type": "forcePushed"}, {"oid": "790549deaab203cd75789930ac23e9321ea04258", "url": "https://github.com/apache/beam/commit/790549deaab203cd75789930ac23e9321ea04258", "message": "[BEAM-9883] Refactor SDF test restrictions.\n\nRefactoring the restriction used for testing SDFs. Instead of having\nsome obtuse behavior that we can validate, it now just contains a bunch\nof flags we can flip to track that it was used in each method.", "committedDate": "2020-05-05T03:01:07Z", "type": "commit"}, {"oid": "790549deaab203cd75789930ac23e9321ea04258", "url": "https://github.com/apache/beam/commit/790549deaab203cd75789930ac23e9321ea04258", "message": "[BEAM-9883] Refactor SDF test restrictions.\n\nRefactoring the restriction used for testing SDFs. Instead of having\nsome obtuse behavior that we can validate, it now just contains a bunch\nof flags we can flip to track that it was used in each method.", "committedDate": "2020-05-05T03:01:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTczMTgyNg==", "url": "https://github.com/apache/beam/pull/11605#discussion_r421731826", "bodyText": "While this is a Test SDF, consider documenting explicitly that returning a restriction is an artifact of testing SDFs, and not how a correct SDF is written.", "author": "lostluck", "createdAt": "2020-05-07T19:10:28Z", "path": "sdks/go/pkg/beam/core/runtime/exec/sdf_invokers_test.go", "diffHunk": "@@ -210,86 +229,154 @@ func TestInvokes(t *testing.T) {\n \t})\n }\n \n-type Restriction struct {\n-\tVal int\n+// VetRestriction is a restriction used for validating that SDF methods get\n+// called with it. When using VetRestriction, the SDF methods it's used in\n+// should pass it as a pointer so the method can make changes to the restriction\n+// even if it doesn't output one directly (such as RestrictionSize).\n+//\n+type VetRestriction struct {\n+\t// An identifier to differentiate restrictions on the same elements. When\n+\t// split, a suffix in the form of \".#\" is appended to this ID.\n+\tID string\n+\n+\t// Key and Val just copy the last seen input element's key and value to\n+\t// confirm that the restriction saw the expected element.\n+\tKey, Val interface{}\n+\n+\t// These booleans should be flipped to true by the corresponding SDF methods\n+\t// to prove that the methods got called on the restriction.\n+\tCreateRest, SplitRest, RestSize, CreateTracker, ProcessElm bool\n }\n \n-// RTracker's methods can all be no-ops, we just need it to implement sdf.RTracker.\n-type RTracker struct {\n-\tRest Restriction\n-\tVal  int\n+// VetRTracker's methods can all be no-ops, we just need it to implement\n+// sdf.RTracker and allow validating that it was passed to ProcessElement.\n+type VetRTracker struct {\n+\tRest *VetRestriction\n }\n \n-func (rt *RTracker) TryClaim(interface{}) bool       { return false }\n-func (rt *RTracker) GetError() error                 { return nil }\n-func (rt *RTracker) GetProgress() (float64, float64) { return 0, 0 }\n-func (rt *RTracker) IsDone() bool                    { return true }\n-func (rt *RTracker) TrySplit(fraction float64) (interface{}, interface{}, error) {\n+func (rt *VetRTracker) TryClaim(interface{}) bool       { return false }\n+func (rt *VetRTracker) GetError() error                 { return nil }\n+func (rt *VetRTracker) GetProgress() (float64, float64) { return 0, 0 }\n+func (rt *VetRTracker) IsDone() bool                    { return true }\n+func (rt *VetRTracker) TrySplit(fraction float64) (interface{}, interface{}, error) {\n \treturn nil, nil, nil\n }\n \n-// In order to test that these methods get called properly, each one has an\n-// implementation that lets us confirm that each argument was passed properly.\n-\n-type Sdf struct {\n+// VetSdf runs an SDF In order to test that these methods get called properly,\n+// each method will flip the corresponding flag in the passed in VetRestriction,\n+// overwrite the restriction's Key and Val with the last seen input elements,\n+// and retain the other fields in the VetRestriction.\n+type VetSdf struct {\n }\n \n-// CreateInitialRestriction creates a restriction with the given value.\n-func (fn *Sdf) CreateInitialRestriction(i int) Restriction {\n-\treturn Restriction{i}\n+// CreateInitialRestriction creates a restriction with the given values and\n+// with the appropriate flags to track that this was called.\n+func (fn *VetSdf) CreateInitialRestriction(i int) *VetRestriction {\n+\treturn &VetRestriction{ID: \"Sdf\", Val: i, CreateRest: true}\n }\n \n-// SplitRestriction outputs two restrictions, the first containing the sum of i\n-// and rest.Val, the second containing the same value plus 1.\n-func (fn *Sdf) SplitRestriction(i int, rest Restriction) []Restriction {\n-\treturn []Restriction{{rest.Val + i}, {rest.Val + i + 1}}\n+// SplitRestriction outputs two identical restrictions, each being a copy of the\n+// initial one, but with the appropriate flags to track this was called. The\n+// split restrictions add a suffix of the form \".#\" to the ID.\n+func (fn *VetSdf) SplitRestriction(i int, rest *VetRestriction) []*VetRestriction {\n+\trest.SplitRest = true\n+\trest1 := &VetRestriction{\n+\t\tID:            rest.ID + \".1\",\n+\t\tVal:           i,\n+\t\tCreateRest:    rest.CreateRest,\n+\t\tSplitRest:     true,\n+\t\tRestSize:      rest.RestSize,\n+\t\tCreateTracker: rest.CreateTracker,\n+\t\tProcessElm:    rest.ProcessElm,\n+\t}\n+\trest2 := &VetRestriction{}\n+\t*rest2 = *rest1\n+\trest2.ID = rest.ID + \".2\"\n+\treturn []*VetRestriction{rest1, rest2}\n }\n \n-// RestrictionSize returns the sum of i and rest.Val as a float64.\n-func (fn *Sdf) RestrictionSize(i int, rest Restriction) float64 {\n-\treturn (float64)(i + rest.Val)\n+// RestrictionSize just returns i as the size, as well as flipping appropriate\n+// flags on the restriction to track that this was called.\n+func (fn *VetSdf) RestrictionSize(i int, rest *VetRestriction) float64 {\n+\trest.Key = nil\n+\trest.Val = i\n+\trest.RestSize = true\n+\treturn (float64)(i)\n }\n \n-// CreateTracker creates an RTracker containing the given restriction and a Val\n-// of 1.\n-func (fn *Sdf) CreateTracker(rest Restriction) *RTracker {\n-\treturn &RTracker{rest, 1}\n+// CreateTracker creates an RTracker containing the given restriction and flips\n+// the appropriate flags on the restriction to track that this was called.\n+func (fn *VetSdf) CreateTracker(rest *VetRestriction) *VetRTracker {\n+\trest.CreateTracker = true\n+\treturn &VetRTracker{rest}\n }\n \n-// ProcessElement emits a pair of ints. The first is the input +\n-// RTracker.Rest.Val. The second is the input + RTracker.Val.\n-func (fn *Sdf) ProcessElement(rt *RTracker, i int, emit func(int, int)) {\n-\temit(i+rt.Rest.Val, i+rt.Val)\n+// ProcessElement emits a copy of the restriction in the restriction tracker it\n+// received, with the appropriate flags flipped to track that this was called.\n+func (fn *VetSdf) ProcessElement(rt *VetRTracker, i int, emit func(VetRestriction)) {\n+\trest := *rt.Rest\n+\trest.Key = nil\n+\trest.Val = i\n+\trest.ProcessElm = true\n+\temit(rest)\n }\n \n-type KvSdf struct {\n+// VetKvSdf runs an SDF In order to test that these methods get called properly,\n+// each method will flip the corresponding flag in the passed in VetRestriction,\n+// overwrite the restriction's Key and Val with the last seen input elements,\n+// and retain the other fields in the VetRestriction.\n+type VetKvSdf struct {\n }\n \n-// CreateInitialRestriction creates a restriction with the sum of the given\n-// values.\n-func (fn *KvSdf) CreateInitialRestriction(i int, j int) Restriction {\n-\treturn Restriction{i + j}\n+// CreateInitialRestriction creates a restriction with the given values and\n+// with the appropriate flags to track that this was called.\n+func (fn *VetKvSdf) CreateInitialRestriction(i, j int) *VetRestriction {\n+\treturn &VetRestriction{ID: \"KvSdf\", Key: i, Val: j, CreateRest: true}\n }\n \n-// SplitRestriction outputs two restrictions, the first containing the sum of i\n-// and rest.Val, the second containing the sum of j and rest.Val.\n-func (fn *KvSdf) SplitRestriction(i int, j int, rest Restriction) []Restriction {\n-\treturn []Restriction{{rest.Val + i}, {rest.Val + j}}\n+// SplitRestriction outputs two identical restrictions, each being a copy of the\n+// initial one, but with the appropriate flags to track this was called. The\n+// split restrictions add a suffix of the form \".#\" to the ID.\n+func (fn *VetKvSdf) SplitRestriction(i, j int, rest *VetRestriction) []*VetRestriction {\n+\trest.SplitRest = true\n+\trest1 := &VetRestriction{\n+\t\tID:            rest.ID + \".1\",\n+\t\tKey:           i,\n+\t\tVal:           j,\n+\t\tCreateRest:    rest.CreateRest,\n+\t\tSplitRest:     true,\n+\t\tRestSize:      rest.RestSize,\n+\t\tCreateTracker: rest.CreateTracker,\n+\t\tProcessElm:    rest.ProcessElm,\n+\t}\n+\trest2 := &VetRestriction{}\n+\t*rest2 = *rest1\n+\trest2.ID = rest.ID + \".2\"\n+\treturn []*VetRestriction{rest1, rest2}\n }\n \n-// RestrictionSize returns the sum of i, j, and rest.Val as a float64.\n-func (fn *KvSdf) RestrictionSize(i int, j int, rest Restriction) float64 {\n-\treturn (float64)(i + j + rest.Val)\n+// RestrictionSize just returns the sum of i and j as the size, as well as\n+// flipping appropriate flags on the restriction to track that this was called.\n+func (fn *VetKvSdf) RestrictionSize(i, j int, rest *VetRestriction) float64 {\n+\trest.Key = i\n+\trest.Val = j\n+\trest.RestSize = true\n+\treturn (float64)(i + j)\n }\n \n-// CreateTracker creates an RTracker containing the given restriction and a Val\n-// of 2.\n-func (fn *KvSdf) CreateTracker(rest Restriction) *RTracker {\n-\treturn &RTracker{rest, 2}\n+// CreateTracker creates an RTracker containing the given restriction and flips\n+// the appropriate flags on the restriction to track that this was called.\n+func (fn *VetKvSdf) CreateTracker(rest *VetRestriction) *VetRTracker {\n+\trest.CreateTracker = true\n+\treturn &VetRTracker{rest}\n }\n \n-// ProcessElement emits two ints. The first is the first input (key) +\n-// RTracker.Rest.Val. The second is the second input (value) + RTracker.Val.\n-func (fn *KvSdf) ProcessElement(rt *RTracker, i1 int, i2 int, emit func(int, int)) {\n-\temit(i1+rt.Rest.Val, i2+rt.Val)\n+// ProcessElement emits a copy of the restriction in the restriction tracker it\n+// received, with the appropriate flags flipped to track that this was called.\n+func (fn *VetKvSdf) ProcessElement(rt *VetRTracker, i, j int, emit func(VetRestriction)) {", "originalCommit": "790549deaab203cd75789930ac23e9321ea04258", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg5MDM3OA==", "url": "https://github.com/apache/beam/pull/11605#discussion_r421890378", "bodyText": "Whoops. I thought I did somewhere, but I must've missed it when revising the comments. Done.", "author": "youngoli", "createdAt": "2020-05-08T01:46:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTczMTgyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTczMjI1OQ==", "url": "https://github.com/apache/beam/pull/11605#discussion_r421732259", "bodyText": "It's a little awkward to have both Value instances of a type and Pointer instances of a type. Usually one is using one or the other. This makes it harder in to understand the test expectations, which if things need to change, could cause harder to diagnose errors.\nSince you're using pointers to allow for the  \"was this specific instance processed?\" consider consolidating on the pointer types.", "author": "lostluck", "createdAt": "2020-05-07T19:11:16Z", "path": "sdks/go/pkg/beam/core/runtime/exec/sdf_invokers_test.go", "diffHunk": "@@ -210,86 +229,154 @@ func TestInvokes(t *testing.T) {\n \t})\n }\n \n-type Restriction struct {\n-\tVal int\n+// VetRestriction is a restriction used for validating that SDF methods get\n+// called with it. When using VetRestriction, the SDF methods it's used in\n+// should pass it as a pointer so the method can make changes to the restriction\n+// even if it doesn't output one directly (such as RestrictionSize).\n+//\n+type VetRestriction struct {\n+\t// An identifier to differentiate restrictions on the same elements. When\n+\t// split, a suffix in the form of \".#\" is appended to this ID.\n+\tID string\n+\n+\t// Key and Val just copy the last seen input element's key and value to\n+\t// confirm that the restriction saw the expected element.\n+\tKey, Val interface{}\n+\n+\t// These booleans should be flipped to true by the corresponding SDF methods\n+\t// to prove that the methods got called on the restriction.\n+\tCreateRest, SplitRest, RestSize, CreateTracker, ProcessElm bool\n }\n \n-// RTracker's methods can all be no-ops, we just need it to implement sdf.RTracker.\n-type RTracker struct {\n-\tRest Restriction\n-\tVal  int\n+// VetRTracker's methods can all be no-ops, we just need it to implement\n+// sdf.RTracker and allow validating that it was passed to ProcessElement.\n+type VetRTracker struct {\n+\tRest *VetRestriction\n }\n \n-func (rt *RTracker) TryClaim(interface{}) bool       { return false }\n-func (rt *RTracker) GetError() error                 { return nil }\n-func (rt *RTracker) GetProgress() (float64, float64) { return 0, 0 }\n-func (rt *RTracker) IsDone() bool                    { return true }\n-func (rt *RTracker) TrySplit(fraction float64) (interface{}, interface{}, error) {\n+func (rt *VetRTracker) TryClaim(interface{}) bool       { return false }\n+func (rt *VetRTracker) GetError() error                 { return nil }\n+func (rt *VetRTracker) GetProgress() (float64, float64) { return 0, 0 }\n+func (rt *VetRTracker) IsDone() bool                    { return true }\n+func (rt *VetRTracker) TrySplit(fraction float64) (interface{}, interface{}, error) {\n \treturn nil, nil, nil\n }\n \n-// In order to test that these methods get called properly, each one has an\n-// implementation that lets us confirm that each argument was passed properly.\n-\n-type Sdf struct {\n+// VetSdf runs an SDF In order to test that these methods get called properly,\n+// each method will flip the corresponding flag in the passed in VetRestriction,\n+// overwrite the restriction's Key and Val with the last seen input elements,\n+// and retain the other fields in the VetRestriction.\n+type VetSdf struct {\n }\n \n-// CreateInitialRestriction creates a restriction with the given value.\n-func (fn *Sdf) CreateInitialRestriction(i int) Restriction {\n-\treturn Restriction{i}\n+// CreateInitialRestriction creates a restriction with the given values and\n+// with the appropriate flags to track that this was called.\n+func (fn *VetSdf) CreateInitialRestriction(i int) *VetRestriction {\n+\treturn &VetRestriction{ID: \"Sdf\", Val: i, CreateRest: true}\n }\n \n-// SplitRestriction outputs two restrictions, the first containing the sum of i\n-// and rest.Val, the second containing the same value plus 1.\n-func (fn *Sdf) SplitRestriction(i int, rest Restriction) []Restriction {\n-\treturn []Restriction{{rest.Val + i}, {rest.Val + i + 1}}\n+// SplitRestriction outputs two identical restrictions, each being a copy of the\n+// initial one, but with the appropriate flags to track this was called. The\n+// split restrictions add a suffix of the form \".#\" to the ID.\n+func (fn *VetSdf) SplitRestriction(i int, rest *VetRestriction) []*VetRestriction {\n+\trest.SplitRest = true\n+\trest1 := &VetRestriction{\n+\t\tID:            rest.ID + \".1\",\n+\t\tVal:           i,\n+\t\tCreateRest:    rest.CreateRest,\n+\t\tSplitRest:     true,\n+\t\tRestSize:      rest.RestSize,\n+\t\tCreateTracker: rest.CreateTracker,\n+\t\tProcessElm:    rest.ProcessElm,\n+\t}\n+\trest2 := &VetRestriction{}\n+\t*rest2 = *rest1\n+\trest2.ID = rest.ID + \".2\"\n+\treturn []*VetRestriction{rest1, rest2}\n }\n \n-// RestrictionSize returns the sum of i and rest.Val as a float64.\n-func (fn *Sdf) RestrictionSize(i int, rest Restriction) float64 {\n-\treturn (float64)(i + rest.Val)\n+// RestrictionSize just returns i as the size, as well as flipping appropriate\n+// flags on the restriction to track that this was called.\n+func (fn *VetSdf) RestrictionSize(i int, rest *VetRestriction) float64 {\n+\trest.Key = nil\n+\trest.Val = i\n+\trest.RestSize = true\n+\treturn (float64)(i)\n }\n \n-// CreateTracker creates an RTracker containing the given restriction and a Val\n-// of 1.\n-func (fn *Sdf) CreateTracker(rest Restriction) *RTracker {\n-\treturn &RTracker{rest, 1}\n+// CreateTracker creates an RTracker containing the given restriction and flips\n+// the appropriate flags on the restriction to track that this was called.\n+func (fn *VetSdf) CreateTracker(rest *VetRestriction) *VetRTracker {\n+\trest.CreateTracker = true\n+\treturn &VetRTracker{rest}\n }\n \n-// ProcessElement emits a pair of ints. The first is the input +\n-// RTracker.Rest.Val. The second is the input + RTracker.Val.\n-func (fn *Sdf) ProcessElement(rt *RTracker, i int, emit func(int, int)) {\n-\temit(i+rt.Rest.Val, i+rt.Val)\n+// ProcessElement emits a copy of the restriction in the restriction tracker it\n+// received, with the appropriate flags flipped to track that this was called.\n+func (fn *VetSdf) ProcessElement(rt *VetRTracker, i int, emit func(VetRestriction)) {\n+\trest := *rt.Rest\n+\trest.Key = nil\n+\trest.Val = i\n+\trest.ProcessElm = true\n+\temit(rest)\n }\n \n-type KvSdf struct {\n+// VetKvSdf runs an SDF In order to test that these methods get called properly,\n+// each method will flip the corresponding flag in the passed in VetRestriction,\n+// overwrite the restriction's Key and Val with the last seen input elements,\n+// and retain the other fields in the VetRestriction.\n+type VetKvSdf struct {\n }\n \n-// CreateInitialRestriction creates a restriction with the sum of the given\n-// values.\n-func (fn *KvSdf) CreateInitialRestriction(i int, j int) Restriction {\n-\treturn Restriction{i + j}\n+// CreateInitialRestriction creates a restriction with the given values and\n+// with the appropriate flags to track that this was called.\n+func (fn *VetKvSdf) CreateInitialRestriction(i, j int) *VetRestriction {\n+\treturn &VetRestriction{ID: \"KvSdf\", Key: i, Val: j, CreateRest: true}\n }\n \n-// SplitRestriction outputs two restrictions, the first containing the sum of i\n-// and rest.Val, the second containing the sum of j and rest.Val.\n-func (fn *KvSdf) SplitRestriction(i int, j int, rest Restriction) []Restriction {\n-\treturn []Restriction{{rest.Val + i}, {rest.Val + j}}\n+// SplitRestriction outputs two identical restrictions, each being a copy of the\n+// initial one, but with the appropriate flags to track this was called. The\n+// split restrictions add a suffix of the form \".#\" to the ID.\n+func (fn *VetKvSdf) SplitRestriction(i, j int, rest *VetRestriction) []*VetRestriction {\n+\trest.SplitRest = true\n+\trest1 := &VetRestriction{\n+\t\tID:            rest.ID + \".1\",\n+\t\tKey:           i,\n+\t\tVal:           j,\n+\t\tCreateRest:    rest.CreateRest,\n+\t\tSplitRest:     true,\n+\t\tRestSize:      rest.RestSize,\n+\t\tCreateTracker: rest.CreateTracker,\n+\t\tProcessElm:    rest.ProcessElm,\n+\t}\n+\trest2 := &VetRestriction{}\n+\t*rest2 = *rest1\n+\trest2.ID = rest.ID + \".2\"\n+\treturn []*VetRestriction{rest1, rest2}\n }\n \n-// RestrictionSize returns the sum of i, j, and rest.Val as a float64.\n-func (fn *KvSdf) RestrictionSize(i int, j int, rest Restriction) float64 {\n-\treturn (float64)(i + j + rest.Val)\n+// RestrictionSize just returns the sum of i and j as the size, as well as\n+// flipping appropriate flags on the restriction to track that this was called.\n+func (fn *VetKvSdf) RestrictionSize(i, j int, rest *VetRestriction) float64 {\n+\trest.Key = i\n+\trest.Val = j\n+\trest.RestSize = true\n+\treturn (float64)(i + j)\n }\n \n-// CreateTracker creates an RTracker containing the given restriction and a Val\n-// of 2.\n-func (fn *KvSdf) CreateTracker(rest Restriction) *RTracker {\n-\treturn &RTracker{rest, 2}\n+// CreateTracker creates an RTracker containing the given restriction and flips\n+// the appropriate flags on the restriction to track that this was called.\n+func (fn *VetKvSdf) CreateTracker(rest *VetRestriction) *VetRTracker {\n+\trest.CreateTracker = true\n+\treturn &VetRTracker{rest}\n }\n \n-// ProcessElement emits two ints. The first is the first input (key) +\n-// RTracker.Rest.Val. The second is the second input (value) + RTracker.Val.\n-func (fn *KvSdf) ProcessElement(rt *RTracker, i1 int, i2 int, emit func(int, int)) {\n-\temit(i1+rt.Rest.Val, i2+rt.Val)\n+// ProcessElement emits a copy of the restriction in the restriction tracker it\n+// received, with the appropriate flags flipped to track that this was called.\n+func (fn *VetKvSdf) ProcessElement(rt *VetRTracker, i, j int, emit func(VetRestriction)) {", "originalCommit": "790549deaab203cd75789930ac23e9321ea04258", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg5MDQzNw==", "url": "https://github.com/apache/beam/pull/11605#discussion_r421890437", "bodyText": "Good point. I agree, consistency seems preferable here.", "author": "youngoli", "createdAt": "2020-05-08T01:46:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTczMjI1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc0MzIwMQ==", "url": "https://github.com/apache/beam/pull/11605#discussion_r421743201", "bodyText": "Consider having a copy() method on VetRestriction (on the value), which will make all these copy instances easier to read.", "author": "lostluck", "createdAt": "2020-05-07T19:31:26Z", "path": "sdks/go/pkg/beam/core/runtime/exec/sdf_invokers_test.go", "diffHunk": "@@ -210,86 +229,154 @@ func TestInvokes(t *testing.T) {\n \t})\n }\n \n-type Restriction struct {\n-\tVal int\n+// VetRestriction is a restriction used for validating that SDF methods get\n+// called with it. When using VetRestriction, the SDF methods it's used in\n+// should pass it as a pointer so the method can make changes to the restriction\n+// even if it doesn't output one directly (such as RestrictionSize).\n+//\n+type VetRestriction struct {\n+\t// An identifier to differentiate restrictions on the same elements. When\n+\t// split, a suffix in the form of \".#\" is appended to this ID.\n+\tID string\n+\n+\t// Key and Val just copy the last seen input element's key and value to\n+\t// confirm that the restriction saw the expected element.\n+\tKey, Val interface{}\n+\n+\t// These booleans should be flipped to true by the corresponding SDF methods\n+\t// to prove that the methods got called on the restriction.\n+\tCreateRest, SplitRest, RestSize, CreateTracker, ProcessElm bool\n }\n \n-// RTracker's methods can all be no-ops, we just need it to implement sdf.RTracker.\n-type RTracker struct {\n-\tRest Restriction\n-\tVal  int\n+// VetRTracker's methods can all be no-ops, we just need it to implement\n+// sdf.RTracker and allow validating that it was passed to ProcessElement.\n+type VetRTracker struct {\n+\tRest *VetRestriction\n }\n \n-func (rt *RTracker) TryClaim(interface{}) bool       { return false }\n-func (rt *RTracker) GetError() error                 { return nil }\n-func (rt *RTracker) GetProgress() (float64, float64) { return 0, 0 }\n-func (rt *RTracker) IsDone() bool                    { return true }\n-func (rt *RTracker) TrySplit(fraction float64) (interface{}, interface{}, error) {\n+func (rt *VetRTracker) TryClaim(interface{}) bool       { return false }\n+func (rt *VetRTracker) GetError() error                 { return nil }\n+func (rt *VetRTracker) GetProgress() (float64, float64) { return 0, 0 }\n+func (rt *VetRTracker) IsDone() bool                    { return true }\n+func (rt *VetRTracker) TrySplit(fraction float64) (interface{}, interface{}, error) {\n \treturn nil, nil, nil\n }\n \n-// In order to test that these methods get called properly, each one has an\n-// implementation that lets us confirm that each argument was passed properly.\n-\n-type Sdf struct {\n+// VetSdf runs an SDF In order to test that these methods get called properly,\n+// each method will flip the corresponding flag in the passed in VetRestriction,\n+// overwrite the restriction's Key and Val with the last seen input elements,\n+// and retain the other fields in the VetRestriction.\n+type VetSdf struct {\n }\n \n-// CreateInitialRestriction creates a restriction with the given value.\n-func (fn *Sdf) CreateInitialRestriction(i int) Restriction {\n-\treturn Restriction{i}\n+// CreateInitialRestriction creates a restriction with the given values and\n+// with the appropriate flags to track that this was called.\n+func (fn *VetSdf) CreateInitialRestriction(i int) *VetRestriction {\n+\treturn &VetRestriction{ID: \"Sdf\", Val: i, CreateRest: true}\n }\n \n-// SplitRestriction outputs two restrictions, the first containing the sum of i\n-// and rest.Val, the second containing the same value plus 1.\n-func (fn *Sdf) SplitRestriction(i int, rest Restriction) []Restriction {\n-\treturn []Restriction{{rest.Val + i}, {rest.Val + i + 1}}\n+// SplitRestriction outputs two identical restrictions, each being a copy of the\n+// initial one, but with the appropriate flags to track this was called. The\n+// split restrictions add a suffix of the form \".#\" to the ID.\n+func (fn *VetSdf) SplitRestriction(i int, rest *VetRestriction) []*VetRestriction {\n+\trest.SplitRest = true\n+\trest1 := &VetRestriction{\n+\t\tID:            rest.ID + \".1\",\n+\t\tVal:           i,\n+\t\tCreateRest:    rest.CreateRest,\n+\t\tSplitRest:     true,\n+\t\tRestSize:      rest.RestSize,\n+\t\tCreateTracker: rest.CreateTracker,\n+\t\tProcessElm:    rest.ProcessElm,\n+\t}\n+\trest2 := &VetRestriction{}\n+\t*rest2 = *rest1\n+\trest2.ID = rest.ID + \".2\"\n+\treturn []*VetRestriction{rest1, rest2}\n }\n \n-// RestrictionSize returns the sum of i and rest.Val as a float64.\n-func (fn *Sdf) RestrictionSize(i int, rest Restriction) float64 {\n-\treturn (float64)(i + rest.Val)\n+// RestrictionSize just returns i as the size, as well as flipping appropriate\n+// flags on the restriction to track that this was called.\n+func (fn *VetSdf) RestrictionSize(i int, rest *VetRestriction) float64 {\n+\trest.Key = nil\n+\trest.Val = i\n+\trest.RestSize = true\n+\treturn (float64)(i)\n }\n \n-// CreateTracker creates an RTracker containing the given restriction and a Val\n-// of 1.\n-func (fn *Sdf) CreateTracker(rest Restriction) *RTracker {\n-\treturn &RTracker{rest, 1}\n+// CreateTracker creates an RTracker containing the given restriction and flips\n+// the appropriate flags on the restriction to track that this was called.\n+func (fn *VetSdf) CreateTracker(rest *VetRestriction) *VetRTracker {\n+\trest.CreateTracker = true\n+\treturn &VetRTracker{rest}\n }\n \n-// ProcessElement emits a pair of ints. The first is the input +\n-// RTracker.Rest.Val. The second is the input + RTracker.Val.\n-func (fn *Sdf) ProcessElement(rt *RTracker, i int, emit func(int, int)) {\n-\temit(i+rt.Rest.Val, i+rt.Val)\n+// ProcessElement emits a copy of the restriction in the restriction tracker it\n+// received, with the appropriate flags flipped to track that this was called.\n+func (fn *VetSdf) ProcessElement(rt *VetRTracker, i int, emit func(VetRestriction)) {\n+\trest := *rt.Rest\n+\trest.Key = nil\n+\trest.Val = i\n+\trest.ProcessElm = true\n+\temit(rest)\n }\n \n-type KvSdf struct {\n+// VetKvSdf runs an SDF In order to test that these methods get called properly,\n+// each method will flip the corresponding flag in the passed in VetRestriction,\n+// overwrite the restriction's Key and Val with the last seen input elements,\n+// and retain the other fields in the VetRestriction.\n+type VetKvSdf struct {\n }\n \n-// CreateInitialRestriction creates a restriction with the sum of the given\n-// values.\n-func (fn *KvSdf) CreateInitialRestriction(i int, j int) Restriction {\n-\treturn Restriction{i + j}\n+// CreateInitialRestriction creates a restriction with the given values and\n+// with the appropriate flags to track that this was called.\n+func (fn *VetKvSdf) CreateInitialRestriction(i, j int) *VetRestriction {\n+\treturn &VetRestriction{ID: \"KvSdf\", Key: i, Val: j, CreateRest: true}\n }\n \n-// SplitRestriction outputs two restrictions, the first containing the sum of i\n-// and rest.Val, the second containing the sum of j and rest.Val.\n-func (fn *KvSdf) SplitRestriction(i int, j int, rest Restriction) []Restriction {\n-\treturn []Restriction{{rest.Val + i}, {rest.Val + j}}\n+// SplitRestriction outputs two identical restrictions, each being a copy of the\n+// initial one, but with the appropriate flags to track this was called. The\n+// split restrictions add a suffix of the form \".#\" to the ID.\n+func (fn *VetKvSdf) SplitRestriction(i, j int, rest *VetRestriction) []*VetRestriction {\n+\trest.SplitRest = true\n+\trest1 := &VetRestriction{\n+\t\tID:            rest.ID + \".1\",\n+\t\tKey:           i,\n+\t\tVal:           j,\n+\t\tCreateRest:    rest.CreateRest,\n+\t\tSplitRest:     true,\n+\t\tRestSize:      rest.RestSize,\n+\t\tCreateTracker: rest.CreateTracker,\n+\t\tProcessElm:    rest.ProcessElm,\n+\t}\n+\trest2 := &VetRestriction{}", "originalCommit": "790549deaab203cd75789930ac23e9321ea04258", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg5MDQ1MA==", "url": "https://github.com/apache/beam/pull/11605#discussion_r421890450", "bodyText": "Good idea, done.", "author": "youngoli", "createdAt": "2020-05-08T01:46:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc0MzIwMQ=="}], "type": "inlineReview"}, {"oid": "38a404386e3551454dc079d4b3e9a44f8f170ed0", "url": "https://github.com/apache/beam/commit/38a404386e3551454dc079d4b3e9a44f8f170ed0", "message": "fixup", "committedDate": "2020-05-08T01:45:47Z", "type": "commit"}]}