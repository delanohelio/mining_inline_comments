{"pr_number": 11182, "pr_title": "[BEAM-9650] Add PeriodicImpulse Transform and slowly changing side input documentation", "pr_createdAt": "2020-03-20T17:29:05Z", "pr_url": "https://github.com/apache/beam/pull/11182", "timeline": [{"oid": "734196747076cbcee7280a3327592a46d5f14b43", "url": "https://github.com/apache/beam/commit/734196747076cbcee7280a3327592a46d5f14b43", "message": "Add Heartbeat Transform", "committedDate": "2020-03-23T15:21:33Z", "type": "commit"}, {"oid": "734196747076cbcee7280a3327592a46d5f14b43", "url": "https://github.com/apache/beam/commit/734196747076cbcee7280a3327592a46d5f14b43", "message": "Add Heartbeat Transform", "committedDate": "2020-03-23T15:21:33Z", "type": "forcePushed"}, {"oid": "1f911e97570b50c7d56452581be23d3314750f7a", "url": "https://github.com/apache/beam/commit/1f911e97570b50c7d56452581be23d3314750f7a", "message": "Linter fixes", "committedDate": "2020-03-27T05:25:46Z", "type": "forcePushed"}, {"oid": "26727e36ad98be8021dd5530d88b2dfb0bf14c41", "url": "https://github.com/apache/beam/commit/26727e36ad98be8021dd5530d88b2dfb0bf14c41", "message": "Add example and documentation", "committedDate": "2020-03-27T07:27:42Z", "type": "forcePushed"}, {"oid": "5d7e7c20ee1ec362967c93d2a1d28d2dc23d7b5d", "url": "https://github.com/apache/beam/commit/5d7e7c20ee1ec362967c93d2a1d28d2dc23d7b5d", "message": "Add example and documentation", "committedDate": "2020-03-27T10:04:04Z", "type": "commit"}, {"oid": "5d7e7c20ee1ec362967c93d2a1d28d2dc23d7b5d", "url": "https://github.com/apache/beam/commit/5d7e7c20ee1ec362967c93d2a1d28d2dc23d7b5d", "message": "Add example and documentation", "committedDate": "2020-03-27T10:04:04Z", "type": "forcePushed"}, {"oid": "e639c9dab6021732d6b49d57f187f5a8bd25e5f7", "url": "https://github.com/apache/beam/commit/e639c9dab6021732d6b49d57f187f5a8bd25e5f7", "message": "Fix tests", "committedDate": "2020-03-27T10:55:48Z", "type": "commit"}, {"oid": "0f66a04388dd93879188230093067f1e06885cbf", "url": "https://github.com/apache/beam/commit/0f66a04388dd93879188230093067f1e06885cbf", "message": "Patch pydocs", "committedDate": "2020-03-27T20:07:37Z", "type": "commit"}, {"oid": "3e8db367b1142abf1e6934c155e3032f69e1a23c", "url": "https://github.com/apache/beam/commit/3e8db367b1142abf1e6934c155e3032f69e1a23c", "message": "remove unrelated test", "committedDate": "2020-03-27T20:45:52Z", "type": "commit"}, {"oid": "e6f198ec8354a58f335874f959759109d4019872", "url": "https://github.com/apache/beam/commit/e6f198ec8354a58f335874f959759109d4019872", "message": "Rename heartbeat to periodicsequence", "committedDate": "2020-03-27T22:53:23Z", "type": "commit"}, {"oid": "ff12c42b43738d5d054a87a8f8d6e63b2101d304", "url": "https://github.com/apache/beam/commit/ff12c42b43738d5d054a87a8f8d6e63b2101d304", "message": "linter", "committedDate": "2020-03-31T23:37:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg1NjI4Ng==", "url": "https://github.com/apache/beam/pull/11182#discussion_r401856286", "bodyText": "Can you add comments in this method?", "author": "pabloem", "createdAt": "2020-04-01T19:27:42Z", "path": "sdks/python/apache_beam/transforms/periodicsequence.py", "diffHunk": "@@ -0,0 +1,160 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from __future__ import absolute_import\n+\n+import time\n+\n+import apache_beam as beam\n+import apache_beam.runners.sdf_utils as sdf_utils\n+from apache_beam.io.restriction_trackers import OffsetRange\n+from apache_beam.io.restriction_trackers import OffsetRestrictionTracker\n+from apache_beam.transforms import core\n+from apache_beam.transforms import window\n+from apache_beam.transforms.ptransform import PTransform\n+from apache_beam.transforms.window import TimestampedValue\n+from apache_beam.utils import timestamp\n+from apache_beam.utils.timestamp import MAX_TIMESTAMP\n+from apache_beam.utils.timestamp import Timestamp\n+\n+\n+class ImpulseSeqGenRestrictionProvider(core.RestrictionProvider):\n+  def initial_restriction(self, element):\n+    start, end, interval = element\n+    return OffsetRange(start - interval, end)\n+\n+  def create_tracker(self, restriction):\n+    return ImpulseSeqGenRestrictionTracker(restriction)\n+\n+  def restriction_size(self, unused_element, restriction):\n+    return restriction.size()\n+\n+\n+class ImpulseSeqGenRestrictionTracker(OffsetRestrictionTracker):\n+  def try_split(self, fraction_of_remainder):\n+    if not self._checkpointed:\n+      if fraction_of_remainder != 0:\n+        return None\n+\n+      if self._current_position is None:\n+        cur = self._range.start\n+      else:\n+        cur = self._current_position\n+      split_point = cur\n+\n+      if split_point < self._range.stop:\n+        self._checkpointed = True\n+        self._range, residual_range = self._range.split_at(split_point)\n+        return self._range, residual_range\n+\n+  def cur_pos(self):\n+    return self._current_position\n+\n+  def try_claim(self, pos):\n+    if ((self._last_claim_attempt is None) or\n+        (pos > self._last_claim_attempt and pos == self._range.stop)):\n+      self._last_claim_attempt = pos\n+      return True\n+    else:\n+      return super(ImpulseSeqGenRestrictionTracker, self).try_claim(pos)\n+\n+\n+class ImpulseSeqGenDoFn(beam.DoFn):\n+  def process(", "originalCommit": "ff12c42b43738d5d054a87a8f8d6e63b2101d304", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg2NjA5NQ==", "url": "https://github.com/apache/beam/pull/11182#discussion_r401866095", "bodyText": "nit: would this be something like last_fired_element, and current_timestamp = time.time()?", "author": "pabloem", "createdAt": "2020-04-01T19:45:19Z", "path": "sdks/python/apache_beam/transforms/periodicsequence.py", "diffHunk": "@@ -0,0 +1,160 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from __future__ import absolute_import\n+\n+import time\n+\n+import apache_beam as beam\n+import apache_beam.runners.sdf_utils as sdf_utils\n+from apache_beam.io.restriction_trackers import OffsetRange\n+from apache_beam.io.restriction_trackers import OffsetRestrictionTracker\n+from apache_beam.transforms import core\n+from apache_beam.transforms import window\n+from apache_beam.transforms.ptransform import PTransform\n+from apache_beam.transforms.window import TimestampedValue\n+from apache_beam.utils import timestamp\n+from apache_beam.utils.timestamp import MAX_TIMESTAMP\n+from apache_beam.utils.timestamp import Timestamp\n+\n+\n+class ImpulseSeqGenRestrictionProvider(core.RestrictionProvider):\n+  def initial_restriction(self, element):\n+    start, end, interval = element\n+    return OffsetRange(start - interval, end)\n+\n+  def create_tracker(self, restriction):\n+    return ImpulseSeqGenRestrictionTracker(restriction)\n+\n+  def restriction_size(self, unused_element, restriction):\n+    return restriction.size()\n+\n+\n+class ImpulseSeqGenRestrictionTracker(OffsetRestrictionTracker):\n+  def try_split(self, fraction_of_remainder):\n+    if not self._checkpointed:\n+      if fraction_of_remainder != 0:\n+        return None\n+\n+      if self._current_position is None:\n+        cur = self._range.start\n+      else:\n+        cur = self._current_position\n+      split_point = cur\n+\n+      if split_point < self._range.stop:\n+        self._checkpointed = True\n+        self._range, residual_range = self._range.split_at(split_point)\n+        return self._range, residual_range\n+\n+  def cur_pos(self):\n+    return self._current_position\n+\n+  def try_claim(self, pos):\n+    if ((self._last_claim_attempt is None) or\n+        (pos > self._last_claim_attempt and pos == self._range.stop)):\n+      self._last_claim_attempt = pos\n+      return True\n+    else:\n+      return super(ImpulseSeqGenRestrictionTracker, self).try_claim(pos)\n+\n+\n+class ImpulseSeqGenDoFn(beam.DoFn):\n+  def process(\n+      self,\n+      element,\n+      restriction_tracker=beam.DoFn.RestrictionParam(\n+          ImpulseSeqGenRestrictionProvider())):\n+\n+    _, _, interval = element\n+\n+    assert isinstance(restriction_tracker, sdf_utils.RestrictionTrackerView)\n+\n+    t = time.time()\n+    cr = restriction_tracker.current_restriction()\n+    current_timestamp = cr.start", "originalCommit": "ff12c42b43738d5d054a87a8f8d6e63b2101d304", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg3Nzg5MA==", "url": "https://github.com/apache/beam/pull/11182#discussion_r401877890", "bodyText": "I feel silly but how long does this test take to run? 3 seconds? Fractions of a second?", "author": "pabloem", "createdAt": "2020-04-01T20:06:48Z", "path": "sdks/python/apache_beam/transforms/periodicsequence_test.py", "diffHunk": "@@ -0,0 +1,100 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Unit tests for the PTransform and descendants.\"\"\"\n+\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+from __future__ import division\n+from __future__ import print_function\n+\n+import os\n+import tempfile\n+import time\n+import unittest\n+from builtins import range\n+\n+import apache_beam as beam\n+from apache_beam.testing.test_pipeline import TestPipeline\n+from apache_beam.testing.util import assert_that\n+from apache_beam.testing.util import equal_to\n+from apache_beam.transforms.periodicsequence import PeriodicSequence\n+from apache_beam.transforms.periodicsequence import PeriodicImpulse\n+\n+# Disable frequent lint warning due to pipe operator for chaining transforms.\n+# pylint: disable=expression-not-assigned\n+\n+\n+class PeriodicSequenceTest(unittest.TestCase):\n+  # Enable nose tests running in parallel\n+\n+  def test_heartbeat_outputs_valid_sequence(self):", "originalCommit": "ff12c42b43738d5d054a87a8f8d6e63b2101d304", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjYyMzE4OA==", "url": "https://github.com/apache/beam/pull/11182#discussion_r402623188", "bodyText": "This one runs for 3 seconds unfortunately due to delays.\nTaking a second thought, we can set fractional duration/intervals and it should still work.", "author": "Ardagan", "createdAt": "2020-04-02T22:05:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg3Nzg5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg3ODQ4NA==", "url": "https://github.com/apache/beam/pull/11182#discussion_r401878484", "bodyText": "Correct naming of the transform", "author": "pabloem", "createdAt": "2020-04-01T20:07:56Z", "path": "website/src/documentation/patterns/side-inputs.md", "diffHunk": "@@ -45,4 +45,30 @@ For instance, the following code sample uses a `Map` to create a `DoFn`. The `Ma\n ```java\n {% github_sample /apache/beam/blob/master/examples/java/src/main/java/org/apache/beam/examples/snippets/Snippets.java tag:SideInputPatternSlowUpdateGlobalWindowSnip1\n %}\n-```\n\\ No newline at end of file\n+```\n+\n+\n+## Slowly updating side input using windowing\n+\n+You can read side input pcollection periodically into distinct windows.\n+Later, when you apply side input to your main input, windows will be matched automatically 1:1.\n+This way, you can guarantee side input consistency on the duration of the single window.\n+\n+To do this, you can utilize Heartbeat PTransform that will generate infinite sequence of elements", "originalCommit": "ff12c42b43738d5d054a87a8f8d6e63b2101d304", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg4NTQ2Ng==", "url": "https://github.com/apache/beam/pull/11182#discussion_r401885466", "bodyText": "If you defined your initial restriction as OffsetRange(start, end), could you avoid this extra call to try_claim?\nYou would just do if restriction_tracker.try_claim(current_timestamp): yield current_timestamp, and defer the remainder to current_timestamp+interval.\nI may be missing something - the logic is a little convoluted. LMK if I'm going off the wrong path.", "author": "pabloem", "createdAt": "2020-04-01T20:20:50Z", "path": "sdks/python/apache_beam/transforms/periodicsequence.py", "diffHunk": "@@ -0,0 +1,160 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from __future__ import absolute_import\n+\n+import time\n+\n+import apache_beam as beam\n+import apache_beam.runners.sdf_utils as sdf_utils\n+from apache_beam.io.restriction_trackers import OffsetRange\n+from apache_beam.io.restriction_trackers import OffsetRestrictionTracker\n+from apache_beam.transforms import core\n+from apache_beam.transforms import window\n+from apache_beam.transforms.ptransform import PTransform\n+from apache_beam.transforms.window import TimestampedValue\n+from apache_beam.utils import timestamp\n+from apache_beam.utils.timestamp import MAX_TIMESTAMP\n+from apache_beam.utils.timestamp import Timestamp\n+\n+\n+class ImpulseSeqGenRestrictionProvider(core.RestrictionProvider):\n+  def initial_restriction(self, element):\n+    start, end, interval = element\n+    return OffsetRange(start - interval, end)\n+\n+  def create_tracker(self, restriction):\n+    return ImpulseSeqGenRestrictionTracker(restriction)\n+\n+  def restriction_size(self, unused_element, restriction):\n+    return restriction.size()\n+\n+\n+class ImpulseSeqGenRestrictionTracker(OffsetRestrictionTracker):\n+  def try_split(self, fraction_of_remainder):\n+    if not self._checkpointed:\n+      if fraction_of_remainder != 0:\n+        return None\n+\n+      if self._current_position is None:\n+        cur = self._range.start\n+      else:\n+        cur = self._current_position\n+      split_point = cur\n+\n+      if split_point < self._range.stop:\n+        self._checkpointed = True\n+        self._range, residual_range = self._range.split_at(split_point)\n+        return self._range, residual_range\n+\n+  def cur_pos(self):\n+    return self._current_position\n+\n+  def try_claim(self, pos):\n+    if ((self._last_claim_attempt is None) or\n+        (pos > self._last_claim_attempt and pos == self._range.stop)):\n+      self._last_claim_attempt = pos\n+      return True\n+    else:\n+      return super(ImpulseSeqGenRestrictionTracker, self).try_claim(pos)\n+\n+\n+class ImpulseSeqGenDoFn(beam.DoFn):\n+  def process(\n+      self,\n+      element,\n+      restriction_tracker=beam.DoFn.RestrictionParam(\n+          ImpulseSeqGenRestrictionProvider())):\n+\n+    _, _, interval = element\n+\n+    assert isinstance(restriction_tracker, sdf_utils.RestrictionTrackerView)\n+\n+    t = time.time()\n+    cr = restriction_tracker.current_restriction()\n+    current_timestamp = cr.start\n+\n+    restriction_tracker.try_claim(current_timestamp)", "originalCommit": "ff12c42b43738d5d054a87a8f8d6e63b2101d304", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQyMDkwNA==", "url": "https://github.com/apache/beam/pull/11182#discussion_r404420904", "bodyText": "This guarantees that left part of deferring is treated as complete.", "author": "Ardagan", "createdAt": "2020-04-06T22:14:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg4NTQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA5MDc5NA==", "url": "https://github.com/apache/beam/pull/11182#discussion_r405090794", "bodyText": "fair enough!", "author": "pabloem", "createdAt": "2020-04-07T20:26:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg4NTQ2Ng=="}], "type": "inlineReview"}, {"oid": "734a30345f9641f9b1ff94cd5626732fdfc2e774", "url": "https://github.com/apache/beam/commit/734a30345f9641f9b1ff94cd5626732fdfc2e774", "message": "Patch tests", "committedDate": "2020-04-06T23:54:23Z", "type": "commit"}, {"oid": "734a30345f9641f9b1ff94cd5626732fdfc2e774", "url": "https://github.com/apache/beam/commit/734a30345f9641f9b1ff94cd5626732fdfc2e774", "message": "Patch tests", "committedDate": "2020-04-06T23:54:23Z", "type": "forcePushed"}, {"oid": "78daff48ac4049879dbd81ec654119291ef07f13", "url": "https://github.com/apache/beam/commit/78daff48ac4049879dbd81ec654119291ef07f13", "message": "address comments", "committedDate": "2020-04-07T16:17:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA4ODU1OQ==", "url": "https://github.com/apache/beam/pull/11182#discussion_r405088559", "bodyText": "Renaming to pcoll, as the input is an actual Pcollection, right?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              def expand(self, pbegin):\n          \n          \n            \n                return (\n          \n          \n            \n                    pbegin\n          \n          \n            \n              def expand(self, pcoll):\n          \n          \n            \n                return (\n          \n          \n            \n                    pcoll", "author": "pabloem", "createdAt": "2020-04-07T20:22:49Z", "path": "sdks/python/apache_beam/transforms/periodicsequence.py", "diffHunk": "@@ -0,0 +1,165 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from __future__ import absolute_import\n+\n+import time\n+\n+import apache_beam as beam\n+import apache_beam.runners.sdf_utils as sdf_utils\n+from apache_beam.io.restriction_trackers import OffsetRange\n+from apache_beam.io.restriction_trackers import OffsetRestrictionTracker\n+from apache_beam.transforms import core\n+from apache_beam.transforms import window\n+from apache_beam.transforms.ptransform import PTransform\n+from apache_beam.transforms.window import TimestampedValue\n+from apache_beam.utils import timestamp\n+from apache_beam.utils.timestamp import MAX_TIMESTAMP\n+from apache_beam.utils.timestamp import Timestamp\n+\n+\n+class ImpulseSeqGenRestrictionProvider(core.RestrictionProvider):\n+  def initial_restriction(self, element):\n+    start, end, interval = element\n+    return OffsetRange(start - interval, end)\n+\n+  def create_tracker(self, restriction):\n+    return ImpulseSeqGenRestrictionTracker(restriction)\n+\n+  def restriction_size(self, unused_element, restriction):\n+    return restriction.size()\n+\n+\n+class ImpulseSeqGenRestrictionTracker(OffsetRestrictionTracker):\n+  def try_split(self, fraction_of_remainder):\n+    if not self._checkpointed:\n+      if fraction_of_remainder != 0:\n+        return None\n+\n+      if self._current_position is None:\n+        cur = self._range.start\n+      else:\n+        cur = self._current_position\n+      split_point = cur\n+\n+      if split_point < self._range.stop:\n+        self._checkpointed = True\n+        self._range, residual_range = self._range.split_at(split_point)\n+        return self._range, residual_range\n+\n+  def cur_pos(self):\n+    return self._current_position\n+\n+  def try_claim(self, pos):\n+    if ((self._last_claim_attempt is None) or\n+        (pos > self._last_claim_attempt and pos == self._range.stop)):\n+      self._last_claim_attempt = pos\n+      return True\n+    else:\n+      return super(ImpulseSeqGenRestrictionTracker, self).try_claim(pos)\n+\n+\n+class ImpulseSeqGenDoFn(beam.DoFn):\n+  def process(\n+      self,\n+      element,\n+      restriction_tracker=beam.DoFn.RestrictionParam(\n+          ImpulseSeqGenRestrictionProvider())):\n+    '''\n+    PeriodicSequence transform receives tuple elements with three parts:\n+\n+    * first_timestamp = first timestamp to output element for.\n+    * last_timestamp = last timestamp/time to output element for.\n+    * fire_interval = how often to fire an element.\n+\n+    For each input element received, PeriodicSequence transform will start\n+    generating output elements in following pattern:\n+\n+    * if element timestamp is less than current runtime then output element.\n+    * if element timestamp is greater than current runtime, wait until next\n+      element timestamp.\n+\n+    PeriodicSequence can't guarantee that each element is output at exact time.\n+    PeriodicSequence guarantees that elements would not be output prior to given\n+    runtime timestamp.\n+\n+    :param element: (start_timestamp, end_timestamp, interval)\n+    :param restriction_tracker:\n+    :return: yields elements at processing real-time intervals with value of\n+      target output timestamp for the element.\n+    '''\n+    _, _, interval = element\n+\n+    assert isinstance(restriction_tracker, sdf_utils.RestrictionTrackerView)\n+\n+    t = time.time()\n+    cr = restriction_tracker.current_restriction()\n+    current_timestamp = cr.start\n+\n+    restriction_tracker.try_claim(current_timestamp)\n+    if current_timestamp <= t:\n+      if restriction_tracker.try_claim(current_timestamp + interval):\n+        current_timestamp += interval\n+        yield current_timestamp\n+\n+    if current_timestamp + interval >= cr.stop:\n+      restriction_tracker.try_claim(cr.stop)\n+    else:\n+      restriction_tracker.defer_remainder(\n+          timestamp.Timestamp(current_timestamp))\n+\n+\n+class PeriodicSequence(PTransform):\n+  \"\"\"\n+  See ImpulseSeqGenDoFn.\n+  \"\"\"\n+  def __init_(self):\n+    pass\n+\n+  def expand(self, pbegin):\n+    return (\n+        pbegin", "originalCommit": "78daff48ac4049879dbd81ec654119291ef07f13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA4OTMzOQ==", "url": "https://github.com/apache/beam/pull/11182#discussion_r405089339", "bodyText": "Sorry about the back and forth. I think the top-level PTransform (which users will rely on) - should have Pydocs, instead of referencing the DoFn.", "author": "pabloem", "createdAt": "2020-04-07T20:24:12Z", "path": "sdks/python/apache_beam/transforms/periodicsequence.py", "diffHunk": "@@ -0,0 +1,165 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from __future__ import absolute_import\n+\n+import time\n+\n+import apache_beam as beam\n+import apache_beam.runners.sdf_utils as sdf_utils\n+from apache_beam.io.restriction_trackers import OffsetRange\n+from apache_beam.io.restriction_trackers import OffsetRestrictionTracker\n+from apache_beam.transforms import core\n+from apache_beam.transforms import window\n+from apache_beam.transforms.ptransform import PTransform\n+from apache_beam.transforms.window import TimestampedValue\n+from apache_beam.utils import timestamp\n+from apache_beam.utils.timestamp import MAX_TIMESTAMP\n+from apache_beam.utils.timestamp import Timestamp\n+\n+\n+class ImpulseSeqGenRestrictionProvider(core.RestrictionProvider):\n+  def initial_restriction(self, element):\n+    start, end, interval = element\n+    return OffsetRange(start - interval, end)\n+\n+  def create_tracker(self, restriction):\n+    return ImpulseSeqGenRestrictionTracker(restriction)\n+\n+  def restriction_size(self, unused_element, restriction):\n+    return restriction.size()\n+\n+\n+class ImpulseSeqGenRestrictionTracker(OffsetRestrictionTracker):\n+  def try_split(self, fraction_of_remainder):\n+    if not self._checkpointed:\n+      if fraction_of_remainder != 0:\n+        return None\n+\n+      if self._current_position is None:\n+        cur = self._range.start\n+      else:\n+        cur = self._current_position\n+      split_point = cur\n+\n+      if split_point < self._range.stop:\n+        self._checkpointed = True\n+        self._range, residual_range = self._range.split_at(split_point)\n+        return self._range, residual_range\n+\n+  def cur_pos(self):\n+    return self._current_position\n+\n+  def try_claim(self, pos):\n+    if ((self._last_claim_attempt is None) or\n+        (pos > self._last_claim_attempt and pos == self._range.stop)):\n+      self._last_claim_attempt = pos\n+      return True\n+    else:\n+      return super(ImpulseSeqGenRestrictionTracker, self).try_claim(pos)\n+\n+\n+class ImpulseSeqGenDoFn(beam.DoFn):\n+  def process(\n+      self,\n+      element,\n+      restriction_tracker=beam.DoFn.RestrictionParam(\n+          ImpulseSeqGenRestrictionProvider())):\n+    '''\n+    PeriodicSequence transform receives tuple elements with three parts:\n+\n+    * first_timestamp = first timestamp to output element for.\n+    * last_timestamp = last timestamp/time to output element for.\n+    * fire_interval = how often to fire an element.\n+\n+    For each input element received, PeriodicSequence transform will start\n+    generating output elements in following pattern:\n+\n+    * if element timestamp is less than current runtime then output element.\n+    * if element timestamp is greater than current runtime, wait until next\n+      element timestamp.\n+\n+    PeriodicSequence can't guarantee that each element is output at exact time.\n+    PeriodicSequence guarantees that elements would not be output prior to given\n+    runtime timestamp.\n+\n+    :param element: (start_timestamp, end_timestamp, interval)\n+    :param restriction_tracker:\n+    :return: yields elements at processing real-time intervals with value of\n+      target output timestamp for the element.\n+    '''\n+    _, _, interval = element\n+\n+    assert isinstance(restriction_tracker, sdf_utils.RestrictionTrackerView)\n+\n+    t = time.time()\n+    cr = restriction_tracker.current_restriction()\n+    current_timestamp = cr.start\n+\n+    restriction_tracker.try_claim(current_timestamp)\n+    if current_timestamp <= t:\n+      if restriction_tracker.try_claim(current_timestamp + interval):\n+        current_timestamp += interval\n+        yield current_timestamp\n+\n+    if current_timestamp + interval >= cr.stop:\n+      restriction_tracker.try_claim(cr.stop)\n+    else:\n+      restriction_tracker.defer_remainder(\n+          timestamp.Timestamp(current_timestamp))\n+\n+\n+class PeriodicSequence(PTransform):\n+  \"\"\"\n+  See ImpulseSeqGenDoFn.", "originalCommit": "78daff48ac4049879dbd81ec654119291ef07f13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA4OTM5Mg==", "url": "https://github.com/apache/beam/pull/11182#discussion_r405089392", "bodyText": "Sorry about the back and forth. I think the top-level PTransform (which users will rely on) - should have Pydocs, instead of referencing the DoFn.", "author": "pabloem", "createdAt": "2020-04-07T20:24:18Z", "path": "sdks/python/apache_beam/transforms/periodicsequence.py", "diffHunk": "@@ -0,0 +1,165 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from __future__ import absolute_import\n+\n+import time\n+\n+import apache_beam as beam\n+import apache_beam.runners.sdf_utils as sdf_utils\n+from apache_beam.io.restriction_trackers import OffsetRange\n+from apache_beam.io.restriction_trackers import OffsetRestrictionTracker\n+from apache_beam.transforms import core\n+from apache_beam.transforms import window\n+from apache_beam.transforms.ptransform import PTransform\n+from apache_beam.transforms.window import TimestampedValue\n+from apache_beam.utils import timestamp\n+from apache_beam.utils.timestamp import MAX_TIMESTAMP\n+from apache_beam.utils.timestamp import Timestamp\n+\n+\n+class ImpulseSeqGenRestrictionProvider(core.RestrictionProvider):\n+  def initial_restriction(self, element):\n+    start, end, interval = element\n+    return OffsetRange(start - interval, end)\n+\n+  def create_tracker(self, restriction):\n+    return ImpulseSeqGenRestrictionTracker(restriction)\n+\n+  def restriction_size(self, unused_element, restriction):\n+    return restriction.size()\n+\n+\n+class ImpulseSeqGenRestrictionTracker(OffsetRestrictionTracker):\n+  def try_split(self, fraction_of_remainder):\n+    if not self._checkpointed:\n+      if fraction_of_remainder != 0:\n+        return None\n+\n+      if self._current_position is None:\n+        cur = self._range.start\n+      else:\n+        cur = self._current_position\n+      split_point = cur\n+\n+      if split_point < self._range.stop:\n+        self._checkpointed = True\n+        self._range, residual_range = self._range.split_at(split_point)\n+        return self._range, residual_range\n+\n+  def cur_pos(self):\n+    return self._current_position\n+\n+  def try_claim(self, pos):\n+    if ((self._last_claim_attempt is None) or\n+        (pos > self._last_claim_attempt and pos == self._range.stop)):\n+      self._last_claim_attempt = pos\n+      return True\n+    else:\n+      return super(ImpulseSeqGenRestrictionTracker, self).try_claim(pos)\n+\n+\n+class ImpulseSeqGenDoFn(beam.DoFn):\n+  def process(\n+      self,\n+      element,\n+      restriction_tracker=beam.DoFn.RestrictionParam(\n+          ImpulseSeqGenRestrictionProvider())):\n+    '''\n+    PeriodicSequence transform receives tuple elements with three parts:\n+\n+    * first_timestamp = first timestamp to output element for.\n+    * last_timestamp = last timestamp/time to output element for.\n+    * fire_interval = how often to fire an element.\n+\n+    For each input element received, PeriodicSequence transform will start\n+    generating output elements in following pattern:\n+\n+    * if element timestamp is less than current runtime then output element.\n+    * if element timestamp is greater than current runtime, wait until next\n+      element timestamp.\n+\n+    PeriodicSequence can't guarantee that each element is output at exact time.\n+    PeriodicSequence guarantees that elements would not be output prior to given\n+    runtime timestamp.\n+\n+    :param element: (start_timestamp, end_timestamp, interval)\n+    :param restriction_tracker:\n+    :return: yields elements at processing real-time intervals with value of\n+      target output timestamp for the element.\n+    '''\n+    _, _, interval = element\n+\n+    assert isinstance(restriction_tracker, sdf_utils.RestrictionTrackerView)\n+\n+    t = time.time()\n+    cr = restriction_tracker.current_restriction()\n+    current_timestamp = cr.start\n+\n+    restriction_tracker.try_claim(current_timestamp)\n+    if current_timestamp <= t:\n+      if restriction_tracker.try_claim(current_timestamp + interval):\n+        current_timestamp += interval\n+        yield current_timestamp\n+\n+    if current_timestamp + interval >= cr.stop:\n+      restriction_tracker.try_claim(cr.stop)\n+    else:\n+      restriction_tracker.defer_remainder(\n+          timestamp.Timestamp(current_timestamp))\n+\n+\n+class PeriodicSequence(PTransform):\n+  \"\"\"\n+  See ImpulseSeqGenDoFn.\n+  \"\"\"\n+  def __init_(self):\n+    pass\n+\n+  def expand(self, pbegin):\n+    return (\n+        pbegin\n+        | 'GenSequence' >> beam.ParDo(ImpulseSeqGenDoFn())\n+        | 'MapToTimestamped' >> beam.Map(lambda tt: TimestampedValue(tt, tt)))\n+\n+\n+class PeriodicImpulse(PTransform):\n+  \"\"\"\n+  See ImpulseSeqGenDoFn.", "originalCommit": "78daff48ac4049879dbd81ec654119291ef07f13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA5MDE4Mg==", "url": "https://github.com/apache/beam/pull/11182#discussion_r405090182", "bodyText": "Let's make the tests in this file run as fast as possible while still validating the transform", "author": "pabloem", "createdAt": "2020-04-07T20:25:38Z", "path": "sdks/python/apache_beam/transforms/periodicsequence_test.py", "diffHunk": "@@ -0,0 +1,98 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Unit tests for the PTransform and descendants.\"\"\"", "originalCommit": "78daff48ac4049879dbd81ec654119291ef07f13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA5MDY5NQ==", "url": "https://github.com/apache/beam/pull/11182#discussion_r405090695", "bodyText": "I feel that it may be best to get a tech writer review for this. @rosetn @soyrice can one of you validate this doc section?", "author": "pabloem", "createdAt": "2020-04-07T20:26:34Z", "path": "website/src/documentation/patterns/side-inputs.md", "diffHunk": "@@ -45,4 +45,30 @@ For instance, the following code sample uses a `Map` to create a `DoFn`. The `Ma\n ```java\n {% github_sample /apache/beam/blob/master/examples/java/src/main/java/org/apache/beam/examples/snippets/Snippets.java tag:SideInputPatternSlowUpdateGlobalWindowSnip1\n %}\n-```\n\\ No newline at end of file\n+```\n+\n+\n+## Slowly updating side input using windowing\n+\n+You can read side input pcollection periodically into distinct windows.\n+Later, when you apply side input to your main input, windows will be matched automatically 1:1.\n+This way, you can guarantee side input consistency on the duration of the single window.\n+\n+To do this, you can utilize PeriodicSequence PTransform that will generate infinite sequence\n+of elements with some real-time period:\n+\n+1. Use the PeriodicImpulse transform to genearate windowed periodic sequence.\n+\n+    a. MAX_TIMESTAMP can be replaced with some closer boundary if you want to stop generating elements at some point.\n+\n+1. Read data using Read operation triggered by arrival of PCollection element.\n+\n+1. Apply side input.\n+\n+```python\n+{% github_sample /apache/beam/blob/master/sdks/python/apache_beam/examples/snippets/snippets.py tag:SideInputSlowUpdateSnip1\n+%}", "originalCommit": "78daff48ac4049879dbd81ec654119291ef07f13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE5MTQyNA==", "url": "https://github.com/apache/beam/pull/11182#discussion_r408191424", "bodyText": "I have time today/tomorrow to review but I see that the PR was merged. I'll still leave some comments here. Can we revert/roll back, address the comments, and then merge again", "author": "soyrice", "createdAt": "2020-04-14T14:42:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA5MDY5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMzNzQxNA==", "url": "https://github.com/apache/beam/pull/11182#discussion_r408337414", "bodyText": "Addressed here: #11415", "author": "Ardagan", "createdAt": "2020-04-14T18:11:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA5MDY5NQ=="}], "type": "inlineReview"}, {"oid": "23aaaab2d6cc7b00df725fae264b163f13f0bdf3", "url": "https://github.com/apache/beam/commit/23aaaab2d6cc7b00df725fae264b163f13f0bdf3", "message": "Address more comments", "committedDate": "2020-04-08T19:12:26Z", "type": "forcePushed"}, {"oid": "ce9a9b4886eb4bef969421c7762d144dee3b6add", "url": "https://github.com/apache/beam/commit/ce9a9b4886eb4bef969421c7762d144dee3b6add", "message": "Address more comments", "committedDate": "2020-04-08T19:28:11Z", "type": "commit"}, {"oid": "ce9a9b4886eb4bef969421c7762d144dee3b6add", "url": "https://github.com/apache/beam/commit/ce9a9b4886eb4bef969421c7762d144dee3b6add", "message": "Address more comments", "committedDate": "2020-04-08T19:28:11Z", "type": "forcePushed"}, {"oid": "21c609679fa042bb6e3ab98df910b634574545fd", "url": "https://github.com/apache/beam/commit/21c609679fa042bb6e3ab98df910b634574545fd", "message": "Merge branch 'master' into SCDPy", "committedDate": "2020-04-14T02:08:39Z", "type": "commit"}, {"oid": "2817862dd36d7dc6a62216fce758046d4b603aac", "url": "https://github.com/apache/beam/commit/2817862dd36d7dc6a62216fce758046d4b603aac", "message": "lint", "committedDate": "2020-04-14T03:12:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE5Mjg5MQ==", "url": "https://github.com/apache/beam/pull/11182#discussion_r408192891", "bodyText": "I think this should either be \"You can read... from distinct windows\" or \"You can write... to distinct windows.\" I'm not sure what it means to \"read... into distinct windows\"", "author": "soyrice", "createdAt": "2020-04-14T14:43:49Z", "path": "website/src/documentation/patterns/side-inputs.md", "diffHunk": "@@ -45,4 +45,30 @@ For instance, the following code sample uses a `Map` to create a `DoFn`. The `Ma\n ```java\n {% github_sample /apache/beam/blob/master/examples/java/src/main/java/org/apache/beam/examples/snippets/Snippets.java tag:SideInputPatternSlowUpdateGlobalWindowSnip1\n %}\n-```\n\\ No newline at end of file\n+```\n+\n+\n+## Slowly updating side input using windowing\n+\n+You can read side input pcollection periodically into distinct windows.", "originalCommit": "2817862dd36d7dc6a62216fce758046d4b603aac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE5MzEzMA==", "url": "https://github.com/apache/beam/pull/11182#discussion_r408193130", "bodyText": "\"PCollection\" (capital P and C)", "author": "soyrice", "createdAt": "2020-04-14T14:44:08Z", "path": "website/src/documentation/patterns/side-inputs.md", "diffHunk": "@@ -45,4 +45,30 @@ For instance, the following code sample uses a `Map` to create a `DoFn`. The `Ma\n ```java\n {% github_sample /apache/beam/blob/master/examples/java/src/main/java/org/apache/beam/examples/snippets/Snippets.java tag:SideInputPatternSlowUpdateGlobalWindowSnip1\n %}\n-```\n\\ No newline at end of file\n+```\n+\n+\n+## Slowly updating side input using windowing\n+\n+You can read side input pcollection periodically into distinct windows.", "originalCommit": "2817862dd36d7dc6a62216fce758046d4b603aac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE5NTkzNA==", "url": "https://github.com/apache/beam/pull/11182#discussion_r408195934", "bodyText": "Missing \"the\" -> \"when you apply the side input to your main input\"\nPresent tense -> \"windows are automatically matched\"\nIt might be less ambiguously to say \"each side input window is matched to a main input window\" (or something like that), instead of \"windows will be matched automatically 1:1.\" I'm not sure it's clear what it means to be \"matched automatically 1:1.\"", "author": "soyrice", "createdAt": "2020-04-14T14:47:31Z", "path": "website/src/documentation/patterns/side-inputs.md", "diffHunk": "@@ -45,4 +45,30 @@ For instance, the following code sample uses a `Map` to create a `DoFn`. The `Ma\n ```java\n {% github_sample /apache/beam/blob/master/examples/java/src/main/java/org/apache/beam/examples/snippets/Snippets.java tag:SideInputPatternSlowUpdateGlobalWindowSnip1\n %}\n-```\n\\ No newline at end of file\n+```\n+\n+\n+## Slowly updating side input using windowing\n+\n+You can read side input pcollection periodically into distinct windows.\n+Later, when you apply side input to your main input, windows will be matched automatically 1:1.", "originalCommit": "2817862dd36d7dc6a62216fce758046d4b603aac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE5NjYzMg==", "url": "https://github.com/apache/beam/pull/11182#discussion_r408196632", "bodyText": "This might need additional context. What does the term \"side input consistency\" mean?", "author": "soyrice", "createdAt": "2020-04-14T14:48:24Z", "path": "website/src/documentation/patterns/side-inputs.md", "diffHunk": "@@ -45,4 +45,30 @@ For instance, the following code sample uses a `Map` to create a `DoFn`. The `Ma\n ```java\n {% github_sample /apache/beam/blob/master/examples/java/src/main/java/org/apache/beam/examples/snippets/Snippets.java tag:SideInputPatternSlowUpdateGlobalWindowSnip1\n %}\n-```\n\\ No newline at end of file\n+```\n+\n+\n+## Slowly updating side input using windowing\n+\n+You can read side input pcollection periodically into distinct windows.\n+Later, when you apply side input to your main input, windows will be matched automatically 1:1.\n+This way, you can guarantee side input consistency on the duration of the single window.", "originalCommit": "2817862dd36d7dc6a62216fce758046d4b603aac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE5ODI2MQ==", "url": "https://github.com/apache/beam/pull/11182#discussion_r408198261", "bodyText": "It's probably best to replace \"To do this\" with \"To do ABC\" - it'll help the reader figure out what \"this\" refers to. Otherwise, if the reader is just skimming the page and starts at this paragraph, they have to read the previous paragraph to figure out what the pronoun refers to.", "author": "soyrice", "createdAt": "2020-04-14T14:50:15Z", "path": "website/src/documentation/patterns/side-inputs.md", "diffHunk": "@@ -45,4 +45,30 @@ For instance, the following code sample uses a `Map` to create a `DoFn`. The `Ma\n ```java\n {% github_sample /apache/beam/blob/master/examples/java/src/main/java/org/apache/beam/examples/snippets/Snippets.java tag:SideInputPatternSlowUpdateGlobalWindowSnip1\n %}\n-```\n\\ No newline at end of file\n+```\n+\n+\n+## Slowly updating side input using windowing\n+\n+You can read side input pcollection periodically into distinct windows.\n+Later, when you apply side input to your main input, windows will be matched automatically 1:1.\n+This way, you can guarantee side input consistency on the duration of the single window.\n+\n+To do this, you can utilize PeriodicSequence PTransform that will generate infinite sequence", "originalCommit": "2817862dd36d7dc6a62216fce758046d4b603aac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE5ODY5NA==", "url": "https://github.com/apache/beam/pull/11182#discussion_r408198694", "bodyText": "MAX_TIMESTAMP is a parameter, right? If so, let's put it in code font. I think \"PeriodicImpulse\" in the list item above and \"Read\" (from \"Read operation) in the list item below should also be in code font. Putting \"Read\" in code font will help distinguish it from the word \"read,\" which is also in the sentence.\nWe can also simplify this sentence a bit: \"To stop generating elements, replace MAX_TIMESTAMP with some closer boundary\" or \"You can replace MAX_TIMESTAMP with...\" or something like that", "author": "soyrice", "createdAt": "2020-04-14T14:50:50Z", "path": "website/src/documentation/patterns/side-inputs.md", "diffHunk": "@@ -45,4 +45,30 @@ For instance, the following code sample uses a `Map` to create a `DoFn`. The `Ma\n ```java\n {% github_sample /apache/beam/blob/master/examples/java/src/main/java/org/apache/beam/examples/snippets/Snippets.java tag:SideInputPatternSlowUpdateGlobalWindowSnip1\n %}\n-```\n\\ No newline at end of file\n+```\n+\n+\n+## Slowly updating side input using windowing\n+\n+You can read side input pcollection periodically into distinct windows.\n+Later, when you apply side input to your main input, windows will be matched automatically 1:1.\n+This way, you can guarantee side input consistency on the duration of the single window.\n+\n+To do this, you can utilize PeriodicSequence PTransform that will generate infinite sequence\n+of elements with some real-time period:\n+\n+1. Use the PeriodicImpulse transform to generate windowed periodic sequence.\n+\n+    a. MAX_TIMESTAMP can be replaced with some closer boundary if you want to stop generating elements at some point.", "originalCommit": "2817862dd36d7dc6a62216fce758046d4b603aac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}