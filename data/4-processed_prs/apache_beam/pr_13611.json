{"pr_number": 13611, "pr_title": "[BEAM-9615] Custom Schema Coder Support", "pr_createdAt": "2020-12-23T22:32:42Z", "pr_url": "https://github.com/apache/beam/pull/13611", "timeline": [{"oid": "6c8c800d7994fc50314b54a691a3515fc8d71b89", "url": "https://github.com/apache/beam/commit/6c8c800d7994fc50314b54a691a3515fc8d71b89", "message": "[BEAM-9615] Custom Schema Coder Support", "committedDate": "2020-12-23T22:11:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMzNjU0Mw==", "url": "https://github.com/apache/beam/pull/13611#discussion_r548336543", "bodyText": "Nit: This seems like a good candidate for a reflectDecodeBytes helper function like the others above.", "author": "youngoli", "createdAt": "2020-12-24T00:59:52Z", "path": "sdks/go/pkg/beam/core/graph/coder/row_decoder.go", "diffHunk": "@@ -0,0 +1,275 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package coder\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\t\"reflect\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n+)\n+\n+// RowDecoderBuilder allows one to build Beam Schema row encoders for provided types.\n+type RowDecoderBuilder struct {\n+\tallFuncs   map[reflect.Type]decoderProvider\n+\tifaceFuncs []reflect.Type\n+}\n+\n+type decoderProvider = func(reflect.Type) (func(io.Reader) (interface{}, error), error)\n+\n+// Register accepts a provider to decode schema encoded values\n+// of that type.\n+//\n+// When decoding values, decoder functions produced by this builder will\n+// first check for exact type matches, then interfaces implemented by\n+// the type in recency order of registration, and then finally the\n+// default Beam Schema encoding behavior.\n+//\n+// TODO(BEAM-9615): Add final factory types. This interface is subject to change.\n+// Currently f must be a function  func(reflect.Type) (func(io.Reader) (interface{}, error), error)\n+func (b *RowDecoderBuilder) Register(rt reflect.Type, f interface{}) {\n+\tfd, ok := f.(decoderProvider)\n+\tif !ok {\n+\t\tpanic(fmt.Sprintf(\"%v isn't a supported decoder function type (passed with %T)\", f, rt))\n+\t}\n+\n+\tif rt.Kind() == reflect.Interface && rt.NumMethod() == 0 {\n+\t\tpanic(fmt.Sprintf(\"interface type %v must have methods\", rt))\n+\t}\n+\n+\tif b.allFuncs == nil {\n+\t\tb.allFuncs = make(map[reflect.Type]decoderProvider)\n+\t}\n+\tb.allFuncs[rt] = fd\n+\tif rt.Kind() == reflect.Interface {\n+\t\tb.ifaceFuncs = append(b.ifaceFuncs, rt)\n+\t}\n+}\n+\n+// Build constructs a Beam Schema coder for the given type, using any providers registered for\n+// itself or it's fields.\n+func (b *RowDecoderBuilder) Build(rt reflect.Type) (func(io.Reader) (interface{}, error), error) {\n+\tif err := rowTypeValidation(rt, true); err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn b.decoderForType(rt), nil\n+}\n+\n+// decoderForType returns a decoder function for the struct or pointer to struct type.\n+func (b *RowDecoderBuilder) decoderForType(t reflect.Type) func(io.Reader) (interface{}, error) {\n+\t// Check if there are any providers registered for this type, or that this type adheres to any interfaces.\n+\tif f := b.customFunc(t); f != nil {\n+\t\treturn f\n+\t}\n+\n+\tvar isPtr bool\n+\t// Pointers become the value type for decomposition.\n+\tif t.Kind() == reflect.Ptr {\n+\t\tisPtr = true\n+\t\tt = t.Elem()\n+\t}\n+\tdec := b.decoderForStructReflect(t)\n+\n+\tif isPtr {\n+\t\treturn func(r io.Reader) (interface{}, error) {\n+\t\t\trv := reflect.New(t)\n+\t\t\terr := dec(rv.Elem(), r)\n+\t\t\treturn rv.Interface(), err\n+\t\t}\n+\t}\n+\treturn func(r io.Reader) (interface{}, error) {\n+\t\trv := reflect.New(t)\n+\t\terr := dec(rv.Elem(), r)\n+\t\treturn rv.Elem().Interface(), err\n+\t}\n+}\n+\n+// decoderForStructReflect returns a reflection based decoder function for the\n+// given struct type.\n+func (b *RowDecoderBuilder) decoderForStructReflect(t reflect.Type) func(reflect.Value, io.Reader) error {\n+\tvar coder typeDecoderReflect\n+\tfor i := 0; i < t.NumField(); i++ {\n+\t\ti := i // avoid alias issues in the closures.\n+\t\tdec := b.decoderForSingleTypeReflect(t.Field(i).Type)\n+\t\tcoder.fields = append(coder.fields, func(rv reflect.Value, r io.Reader) error {\n+\t\t\treturn dec(rv.Field(i), r)\n+\t\t})\n+\t}\n+\treturn func(rv reflect.Value, r io.Reader) error {\n+\t\tnf, nils, err := ReadRowHeader(r)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif nf != len(coder.fields) {\n+\t\t\treturn errors.Errorf(\"schema[%v] changed: got %d fields, want %d fields\", \"TODO\", nf, len(coder.fields))\n+\t\t}\n+\t\tfor i, f := range coder.fields {\n+\t\t\tif IsFieldNil(nils, i) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif err := f(rv, r); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t}\n+\t\treturn nil\n+\t}\n+}\n+\n+func reflectDecodeBool(rv reflect.Value, r io.Reader) error {\n+\tv, err := DecodeBool(r)\n+\tif err != nil {\n+\t\treturn errors.Wrap(err, \"error decoding bool field\")\n+\t}\n+\trv.SetBool(v)\n+\treturn nil\n+}\n+\n+func reflectDecodeByte(rv reflect.Value, r io.Reader) error {\n+\tb, err := DecodeByte(r)\n+\tif err != nil {\n+\t\treturn errors.Wrap(err, \"error decoding single byte field\")\n+\t}\n+\trv.SetUint(uint64(b))\n+\treturn nil\n+}\n+\n+func reflectDecodeString(rv reflect.Value, r io.Reader) error {\n+\tv, err := DecodeStringUTF8(r)\n+\tif err != nil {\n+\t\treturn errors.Wrap(err, \"error decoding string field\")\n+\t}\n+\trv.SetString(v)\n+\treturn nil\n+}\n+\n+func reflectDecodeInt(rv reflect.Value, r io.Reader) error {\n+\tv, err := DecodeVarInt(r)\n+\tif err != nil {\n+\t\treturn errors.Wrap(err, \"error decoding varint field\")\n+\t}\n+\trv.SetInt(v)\n+\treturn nil\n+}\n+\n+func reflectDecodeFloat(rv reflect.Value, r io.Reader) error {\n+\tv, err := DecodeDouble(r)\n+\tif err != nil {\n+\t\treturn errors.Wrap(err, \"error decoding double field\")\n+\t}\n+\trv.SetFloat(v)\n+\treturn nil\n+}\n+\n+// customFunc returns nil if no custom func exists for this.\n+func (b *RowDecoderBuilder) customFunc(t reflect.Type) func(io.Reader) (interface{}, error) {\n+\tif fact, ok := b.allFuncs[t]; ok {\n+\t\tf, err := fact(t)\n+\n+\t\t// TODO handle errors?\n+\t\tif err != nil {\n+\t\t\treturn nil\n+\t\t}\n+\t\treturn f\n+\t}\n+\t// Check satisfaction of interface types in reverse registration order.\n+\tfor i := len(b.ifaceFuncs) - 1; i >= 0; i-- {\n+\t\tit := b.ifaceFuncs[i]\n+\t\tif ok := t.AssignableTo(it); ok {\n+\t\t\tif fact, ok := b.allFuncs[it]; ok {\n+\t\t\t\tf, err := fact(t)\n+\t\t\t\t// TODO handle errors?\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil\n+\t\t\t\t}\n+\t\t\t\treturn f\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// decoderForSingleTypeReflect returns a reflection based decoder function for the\n+// given type.\n+func (b *RowDecoderBuilder) decoderForSingleTypeReflect(t reflect.Type) func(reflect.Value, io.Reader) error {\n+\t// Check if there are any providers registered for this type, or that this type adheres to any interfaces.\n+\tif dec := b.customFunc(t); dec != nil {\n+\t\treturn func(v reflect.Value, r io.Reader) error {\n+\t\t\telm, err := dec(r)\n+\t\t\tif err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tv.Set(reflect.ValueOf(elm))\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\n+\tswitch t.Kind() {\n+\tcase reflect.Struct:\n+\t\treturn b.decoderForStructReflect(t)\n+\tcase reflect.Bool:\n+\t\treturn reflectDecodeBool\n+\tcase reflect.Uint8:\n+\t\treturn reflectDecodeByte\n+\tcase reflect.String:\n+\t\treturn reflectDecodeString\n+\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n+\t\treturn reflectDecodeInt\n+\tcase reflect.Float32, reflect.Float64:\n+\t\treturn reflectDecodeFloat\n+\tcase reflect.Ptr:\n+\t\tdecf := b.decoderForSingleTypeReflect(t.Elem())\n+\t\treturn func(rv reflect.Value, r io.Reader) error {\n+\t\t\tnv := reflect.New(t.Elem())\n+\t\t\trv.Set(nv)\n+\t\t\treturn decf(nv.Elem(), r)\n+\t\t}\n+\tcase reflect.Slice:\n+\t\t// Special case handling for byte slices.\n+\t\tif t.Elem().Kind() == reflect.Uint8 {\n+\t\t\treturn func(rv reflect.Value, r io.Reader) error {", "originalCommit": "6c8c800d7994fc50314b54a691a3515fc8d71b89", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMzODExOQ==", "url": "https://github.com/apache/beam/pull/13611#discussion_r548338119", "bodyText": "What's the purpose for allFuncs to contain decoderProvider instead of func(io.Reader) (interface{}, error) directly? Is it to allow for interface types? Like the decoderProvider for an interface type would return different decoders by being passed a concrete type?", "author": "youngoli", "createdAt": "2020-12-24T01:08:06Z", "path": "sdks/go/pkg/beam/core/graph/coder/row_decoder.go", "diffHunk": "@@ -0,0 +1,275 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package coder\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\t\"reflect\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n+)\n+\n+// RowDecoderBuilder allows one to build Beam Schema row encoders for provided types.\n+type RowDecoderBuilder struct {\n+\tallFuncs   map[reflect.Type]decoderProvider\n+\tifaceFuncs []reflect.Type\n+}\n+\n+type decoderProvider = func(reflect.Type) (func(io.Reader) (interface{}, error), error)", "originalCommit": "6c8c800d7994fc50314b54a691a3515fc8d71b89", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1Njg5MA==", "url": "https://github.com/apache/beam/pull/13611#discussion_r549456890", "bodyText": "Yes! Great questions.\nTwo reasons, interface types, and to generate independent coders.\nWe want to have the providers since we want the bundles to be independent and be able to create new instances for each one. We need to keep the factory function around, since we don't actually know what types are being used until construction time and these would need to be registered earlier than that.\nIndependant coders are valuable to avoid locking overhead, and re-doing work at per-element calls, which account for most costs.\nThe factory allows for interface types since we can register with an interface type, and then pass the type to the factory. We want this approach rather than registering 1 size fits all, to avoid forcing interface coders to have to make per-element decisions based on static type attributes.\nEg. With a fixed type, we know it's structure ahead of time, and could use simple coders only.\nWith a coder factory bound to an interface type, the factory is still given the concrete type used in some pipeline (like a specific protocol buffer), but the factory can generate the coder once, and use it for multiple elements. This avoids looking up coders per element from some global registry which could require locking, which would add overhead.\nFurther, we can bolster support for interfaces. Eg. A generic interface can be used as an element type, and then the factory can then do per element work if it so chooses, but at the cost of whatever overhead. But in this case we can avoid the per-element locking since we know the coder will be used only in single threaded contexts, so it can cache it's own coders. More expensive than statically structured coders, but it doesn't block the path either way.\nFinally, we're accepting interface{} in the register, for these since we may wish to expand the factory set up for optimizations that could avoid additional allocations.", "author": "lostluck", "createdAt": "2020-12-28T19:11:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMzODExOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODMzODcxNA==", "url": "https://github.com/apache/beam/pull/13611#discussion_r548338714", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tpanic(fmt.Sprintf(\"%v isn't a supported decoder function type (passed with %T)\", f, rt))\n          \n          \n            \n            \t\tpanic(fmt.Sprintf(\"%v isn't a supported encoder function type (passed with %T)\", f, rt))", "author": "youngoli", "createdAt": "2020-12-24T01:11:25Z", "path": "sdks/go/pkg/beam/core/graph/coder/row_encoder.go", "diffHunk": "@@ -0,0 +1,231 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package coder\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\t\"reflect\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n+)\n+\n+type encoderProvider = func(reflect.Type) (func(interface{}, io.Writer) error, error)\n+\n+// RowEncoderBuilder allows one to build Beam Schema row encoders for provided types.\n+type RowEncoderBuilder struct {\n+\tallFuncs   map[reflect.Type]encoderProvider\n+\tifaceFuncs []reflect.Type\n+}\n+\n+// Register accepts a provider for the given type to schema encode values of that type.\n+//\n+// When generating encoding functions, this builder will first check for exact type\n+// matches, then against interfaces with registered factories in recency order of\n+// registration, and then finally use the default Beam Schema encoding behavior.\n+//\n+// TODO(BEAM-9615): Add final factory types. This interface is subject to change.\n+// Currently f must be a function of the type func(reflect.Type) func(T, io.Writer) (error).\n+func (b *RowEncoderBuilder) Register(rt reflect.Type, f interface{}) {\n+\tfe, ok := f.(encoderProvider)\n+\tif !ok {\n+\t\tpanic(fmt.Sprintf(\"%v isn't a supported decoder function type (passed with %T)\", f, rt))", "originalCommit": "6c8c800d7994fc50314b54a691a3515fc8d71b89", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0ODIwMg==", "url": "https://github.com/apache/beam/pull/13611#discussion_r548348202", "bodyText": "This line reads like the parameter values shouldn't be a slice, but if I'm reading the code correctly it's supposed to mean that each element in values must be a single struct or pointer to struct. I recommend rephrasing it along these lines:\n\nValues must be either a struct, pointer to struct, or a slice where each element is a struct or pointer to struct.", "author": "youngoli", "createdAt": "2020-12-24T01:59:27Z", "path": "sdks/go/pkg/beam/core/graph/coder/testutil/testutil.go", "diffHunk": "@@ -0,0 +1,136 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package testutil contains helpers to test and validate custom Beam Schema coders.\n+package testutil\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"reflect\"\n+\t\"testing\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/coder\"\n+\t\"github.com/google/go-cmp/cmp\"\n+)\n+\n+// SchemaCoder helps validate custom schema coders.\n+type SchemaCoder struct {\n+\tencBldUT, encBldSchema coder.RowEncoderBuilder\n+\tdecBldUT, decBldSchema coder.RowDecoderBuilder\n+\n+\t// CmpOptions to pass into the round trip comparison\n+\tCmpOptions cmp.Options\n+}\n+\n+// Register adds additional custom types not under test to both the under test\n+// and default schema coders.\n+func (v *SchemaCoder) Register(rt reflect.Type, encF, decF interface{}) {\n+\tv.encBldUT.Register(rt, encF)\n+\tv.encBldSchema.Register(rt, encF)\n+\tv.decBldUT.Register(rt, decF)\n+\tv.decBldSchema.Register(rt, decF)\n+}\n+\n+// Validate is a test utility to validate custom schema coders generate\n+// beam schema encoded bytes.\n+//\n+// Validate accepts the reflect.Type to register, factory functions for encoding and decoding, an\n+// anonymous struct type equivalent to the encoded format produced and consumed by the factory produced functions\n+// and test values. Values must be a single struct or pointer to struct.", "originalCommit": "6c8c800d7994fc50314b54a691a3515fc8d71b89", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1Nzk0Mg==", "url": "https://github.com/apache/beam/pull/13611#discussion_r549457942", "bodyText": "Good call!", "author": "lostluck", "createdAt": "2020-12-28T19:15:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM0ODIwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM1MTExMg==", "url": "https://github.com/apache/beam/pull/13611#discussion_r548351112", "bodyText": "Does reading from the buffer (a few lines above with decSchema) remove those bytes from the buffer (or otherwise prevent those bytes from being cloned)? Because on first read it seems like roundTripBytes below will contain the element's bytes twice, the first copied from initialBytes, and the second from encSchema here.", "author": "youngoli", "createdAt": "2020-12-24T02:14:12Z", "path": "sdks/go/pkg/beam/core/graph/coder/testutil/testutil.go", "diffHunk": "@@ -0,0 +1,136 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package testutil contains helpers to test and validate custom Beam Schema coders.\n+package testutil\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"reflect\"\n+\t\"testing\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/coder\"\n+\t\"github.com/google/go-cmp/cmp\"\n+)\n+\n+// SchemaCoder helps validate custom schema coders.\n+type SchemaCoder struct {\n+\tencBldUT, encBldSchema coder.RowEncoderBuilder\n+\tdecBldUT, decBldSchema coder.RowDecoderBuilder\n+\n+\t// CmpOptions to pass into the round trip comparison\n+\tCmpOptions cmp.Options\n+}\n+\n+// Register adds additional custom types not under test to both the under test\n+// and default schema coders.\n+func (v *SchemaCoder) Register(rt reflect.Type, encF, decF interface{}) {\n+\tv.encBldUT.Register(rt, encF)\n+\tv.encBldSchema.Register(rt, encF)\n+\tv.decBldUT.Register(rt, decF)\n+\tv.decBldSchema.Register(rt, decF)\n+}\n+\n+// Validate is a test utility to validate custom schema coders generate\n+// beam schema encoded bytes.\n+//\n+// Validate accepts the reflect.Type to register, factory functions for encoding and decoding, an\n+// anonymous struct type equivalent to the encoded format produced and consumed by the factory produced functions\n+// and test values. Values must be a single struct or pointer to struct.\n+//\n+// TODO(lostluck): Improve documentation.\n+// TODO(lostluck): Abstract into a configurable struct, to handle\n+//\n+// Validate will register the under test factories and generate an encoder and decoder function.\n+// These functions will be re-used for all test values. This emulates coders being re-used for all\n+// elements within a bundle.\n+//\n+// Validate mutates the SchemaCoderValidator, so the SchemaCoderValidator may not be used more than once.\n+func (v *SchemaCoder) Validate(t *testing.T, rt reflect.Type, encF, decF, schema interface{}, values interface{}) {\n+\tt.Helper()\n+\ttestValues := reflect.ValueOf(values)\n+\t// Check whether we have a slice type or not.\n+\tif testValues.Type().Kind() != reflect.Slice {\n+\t\tvs := reflect.MakeSlice(reflect.SliceOf(testValues.Type()), 0, 1)\n+\t\ttestValues = reflect.Append(vs, testValues)\n+\t}\n+\tif testValues.Len() == 0 {\n+\t\tt.Fatalf(\"No test values provided for ValidateSchemaCoder(%v)\", rt)\n+\t}\n+\t// We now have non empty slice of test values!\n+\n+\tv.encBldUT.Register(rt, encF)\n+\tv.decBldUT.Register(rt, decF)\n+\n+\ttestRt := testValues.Type().Elem()\n+\tencUT, err := v.encBldUT.Build(testRt)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Unable to build encoder function with given factory: coder.RowEncoderBuilder.Build(%v) = %v, want nil error\", rt, err)\n+\t}\n+\tdecUT, err := v.decBldUT.Build(testRt)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Unable to build decoder function with given factory: coder.RowDecoderBuilder.Build(%v) = %v, want nil error\", rt, err)\n+\t}\n+\n+\tschemaRt := reflect.TypeOf(schema)\n+\tencSchema, err := v.encBldSchema.Build(schemaRt)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Unable to build encoder function for schema equivalent type: coder.RowEncoderBuilder.Build(%v) = %v, want nil error\", rt, err)\n+\t}\n+\tdecSchema, err := v.decBldSchema.Build(schemaRt)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Unable to build decoder function for schema equivalent type: coder.RowDecoderBuilder.Build(%v) = %v, want nil error\", rt, err)\n+\t}\n+\tfor i := 0; i < testValues.Len(); i++ {\n+\t\tt.Run(fmt.Sprintf(\"%v[%d]\", rt, i), func(t *testing.T) {\n+\t\t\tvar buf bytes.Buffer\n+\t\t\twant := testValues.Index(i).Interface()\n+\t\t\tif err := encUT(want, &buf); err != nil {\n+\t\t\t\tt.Fatalf(\"error calling Under Test encoder[%v](%v) = %v\", testRt, want, err)\n+\t\t\t}\n+\t\t\tinitialBytes := clone(buf.Bytes())\n+\n+\t\t\tbufSchema := bytes.NewBuffer(clone(initialBytes))\n+\n+\t\t\tschemaV, err := decSchema(bufSchema)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"error calling Equivalent Schema decoder[%v]() = %v\", schemaRt, err)\n+\t\t\t}\n+\t\t\terr = encSchema(schemaV, bufSchema)", "originalCommit": "6c8c800d7994fc50314b54a691a3515fc8d71b89", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM1MTQ4Mg==", "url": "https://github.com/apache/beam/pull/13611#discussion_r548351482", "bodyText": "Typo: Unfinished comment.", "author": "youngoli", "createdAt": "2020-12-24T02:16:02Z", "path": "sdks/go/pkg/beam/core/graph/coder/testutil/testutil_test.go", "diffHunk": "@@ -0,0 +1,126 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package testutil\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\t\"reflect\"\n+\t\"testing\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/coder\"\n+)\n+\n+type UserInterface interface {\n+\tmark()\n+}\n+\n+type UserType1 struct {\n+\tA string\n+\tB int\n+\tC string\n+}\n+\n+func (UserType1) mark() {}\n+\n+func ut1EncDropB(val interface{}, w io.Writer) error {\n+\tif err := coder.WriteSimpleRowHeader(2, w); err != nil {\n+\t\treturn err\n+\t}\n+\telm := val.(UserType1)\n+\tif err := coder.EncodeStringUTF8(elm.A, w); err != nil {\n+\t\treturn err\n+\t}\n+\tif err := coder.EncodeStringUTF8(elm.C, w); err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func ut1DecDropB(r io.Reader) (interface{}, error) {\n+\tif err := coder.ReadSimpleRowHeader(2, r); err != nil {\n+\t\treturn nil, err\n+\t}\n+\ta, err := coder.DecodeStringUTF8(r)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"decoding string field A: %w\", err)\n+\t}\n+\tc, err := coder.DecodeStringUTF8(r)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"decoding string field C: %v, %w\", c, err)\n+\t}\n+\treturn UserType1{\n+\t\tA: a,\n+\t\tB: 42,\n+\t\tC: c,\n+\t}, nil\n+}\n+\n+// TestValidateCoder_SingleValue checks that the validate coder fun will", "originalCommit": "6c8c800d7994fc50314b54a691a3515fc8d71b89", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM1MzIzMg==", "url": "https://github.com/apache/beam/pull/13611#discussion_r548353232", "bodyText": "Suggestion: You could probably add a test for the failure case though you'll need to do some refactoring on the Validate function. Basically just have an inner function that's the current implementation but doesn't use *testing.T and instead returns an error if something went wrong and make the current exported Validate function call that and do t.Fatalf if an error appears. With that refactor, you can add a test that calls the inner function with an element that doesn't have 42 for B, so you can validate that it fails when expected.", "author": "youngoli", "createdAt": "2020-12-24T02:24:44Z", "path": "sdks/go/pkg/beam/core/graph/coder/testutil/testutil_test.go", "diffHunk": "@@ -0,0 +1,126 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package testutil\n+\n+import (\n+\t\"fmt\"\n+\t\"io\"\n+\t\"reflect\"\n+\t\"testing\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/coder\"\n+)\n+\n+type UserInterface interface {\n+\tmark()\n+}\n+\n+type UserType1 struct {\n+\tA string\n+\tB int\n+\tC string\n+}\n+\n+func (UserType1) mark() {}\n+\n+func ut1EncDropB(val interface{}, w io.Writer) error {\n+\tif err := coder.WriteSimpleRowHeader(2, w); err != nil {\n+\t\treturn err\n+\t}\n+\telm := val.(UserType1)\n+\tif err := coder.EncodeStringUTF8(elm.A, w); err != nil {\n+\t\treturn err\n+\t}\n+\tif err := coder.EncodeStringUTF8(elm.C, w); err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+func ut1DecDropB(r io.Reader) (interface{}, error) {\n+\tif err := coder.ReadSimpleRowHeader(2, r); err != nil {\n+\t\treturn nil, err\n+\t}\n+\ta, err := coder.DecodeStringUTF8(r)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"decoding string field A: %w\", err)\n+\t}\n+\tc, err := coder.DecodeStringUTF8(r)\n+\tif err != nil {\n+\t\treturn nil, fmt.Errorf(\"decoding string field C: %v, %w\", c, err)\n+\t}\n+\treturn UserType1{\n+\t\tA: a,\n+\t\tB: 42,\n+\t\tC: c,\n+\t}, nil\n+}\n+\n+// TestValidateCoder_SingleValue checks that the validate coder fun will\n+func TestValidateCoder(t *testing.T) {\n+\t// Validates a custom UserType1 encoding, which drops encoding the \"B\" field,\n+\t// always setting it to a constant value.\n+\tt.Run(\"SingleValue\", func(t *testing.T) {\n+\t\t(&SchemaCoder{}).Validate(t, reflect.TypeOf((*UserType1)(nil)).Elem(),\n+\t\t\tfunc(reflect.Type) (func(interface{}, io.Writer) error, error) { return ut1EncDropB, nil },\n+\t\t\tfunc(reflect.Type) (func(io.Reader) (interface{}, error), error) { return ut1DecDropB, nil },\n+\t\t\tstruct{ A, C string }{},\n+\t\t\tUserType1{\n+\t\t\t\tA: \"cats\",\n+\t\t\t\tB: 42,\n+\t\t\t\tC: \"pjamas\",\n+\t\t\t},\n+\t\t)\n+\t})\n+\tt.Run(\"SliceOfValues\", func(t *testing.T) {\n+\t\t(&SchemaCoder{}).Validate(t, reflect.TypeOf((*UserType1)(nil)).Elem(),\n+\t\t\tfunc(reflect.Type) (func(interface{}, io.Writer) error, error) { return ut1EncDropB, nil },\n+\t\t\tfunc(reflect.Type) (func(io.Reader) (interface{}, error), error) { return ut1DecDropB, nil },\n+\t\t\tstruct{ A, C string }{},\n+\t\t\t[]UserType1{\n+\t\t\t\t{\n+\t\t\t\t\tA: \"cats\",\n+\t\t\t\t\tB: 42,\n+\t\t\t\t\tC: \"pjamas\",\n+\t\t\t\t}, {\n+\t\t\t\t\tA: \"dogs\",\n+\t\t\t\t\tB: 42,\n+\t\t\t\t\tC: \"breakfast\",\n+\t\t\t\t}, {\n+\t\t\t\t\tA: \"fish\",\n+\t\t\t\t\tB: 42,\n+\t\t\t\t\tC: \"plenty of\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t)\n+\t})\n+\tt.Run(\"InterfaceCoder\", func(t *testing.T) {\n+\t\t(&SchemaCoder{}).Validate(t, reflect.TypeOf((*UserInterface)(nil)).Elem(),\n+\t\t\tfunc(rt reflect.Type) (func(interface{}, io.Writer) error, error) {\n+\t\t\t\treturn ut1EncDropB, nil\n+\t\t\t},\n+\t\t\tfunc(rt reflect.Type) (func(io.Reader) (interface{}, error), error) {\n+\t\t\t\treturn ut1DecDropB, nil\n+\t\t\t},\n+\t\t\tstruct{ A, C string }{},\n+\t\t\tUserType1{\n+\t\t\t\tA: \"cats\",\n+\t\t\t\tB: 42,\n+\t\t\t\tC: \"pjamas\",\n+\t\t\t},\n+\t\t)\n+\t})\n+}", "originalCommit": "6c8c800d7994fc50314b54a691a3515fc8d71b89", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ2NDgwNw==", "url": "https://github.com/apache/beam/pull/13611#discussion_r549464807", "bodyText": "Fair, I could swap *testing.T with an interface with all the common methods I use.\nI can't do anything about the interior coder tests though. Part of the value of this set up is that the coder is tested multiple times with whatever different values are in test values, but they fail independently.\nI can check the pre-per value errors fail as expected though.\nI ran into the various error cases on my implementation of this so I'm not that worried. That's part of why I'm not 100% on the documentation+API just yet. This will be refined as I work through the proto provider.", "author": "lostluck", "createdAt": "2020-12-28T19:40:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM1MzIzMg=="}], "type": "inlineReview"}, {"oid": "72a92f7317ba6455fe7368426f600f900022af02", "url": "https://github.com/apache/beam/commit/72a92f7317ba6455fe7368426f600f900022af02", "message": "!fixup plumb custom errors, verify validator", "committedDate": "2020-12-28T21:51:54Z", "type": "commit"}, {"oid": "a1b2b2af69c7fa64a1b5090ce3100b769d196cf0", "url": "https://github.com/apache/beam/commit/a1b2b2af69c7fa64a1b5090ce3100b769d196cf0", "message": "!fixup remove %w verbs", "committedDate": "2020-12-28T22:12:48Z", "type": "commit"}, {"oid": "0370460ab735039a25577739facd878cc5669878", "url": "https://github.com/apache/beam/commit/0370460ab735039a25577739facd878cc5669878", "message": "!fixup remove %w verbs", "committedDate": "2020-12-28T22:13:50Z", "type": "commit"}]}