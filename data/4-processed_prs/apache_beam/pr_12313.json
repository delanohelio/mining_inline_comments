{"pr_number": 12313, "pr_title": "[BEAM-10551] Implement Navigation Functions FIRST_VALUE and LAST_VALUE", "pr_createdAt": "2020-07-20T03:19:51Z", "pr_url": "https://github.com/apache/beam/pull/12313", "timeline": [{"oid": "a9dce737c0159955316e67cdde5ed7cd784e49cc", "url": "https://github.com/apache/beam/commit/a9dce737c0159955316e67cdde5ed7cd784e49cc", "message": "Implement navigation functions\n\n- FIRST_VALUE\n- LAST_VALUE", "committedDate": "2020-07-20T03:11:11Z", "type": "commit"}, {"oid": "b7f5aa4ed59c5efd27a0e4ac5238257180f83b5f", "url": "https://github.com/apache/beam/commit/b7f5aa4ed59c5efd27a0e4ac5238257180f83b5f", "message": "fix style", "committedDate": "2020-07-20T03:57:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA5NDMyMw==", "url": "https://github.com/apache/beam/pull/12313#discussion_r457094323", "bodyText": "you can optimize this for loop by adding a break, because r.isPresent() will be always true after first r=ac.", "author": "amaliujia", "createdAt": "2020-07-20T06:29:59Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/transform/BeamBuiltinAnalyticFunctions.java", "diffHunk": "@@ -42,4 +44,77 @@\n     throw new UnsupportedOperationException(\n         String.format(\"Analytics Function [%s] is not supported\", functionName));\n   }\n+\n+  public static <T> Combine.CombineFn<T, ?, T> navigationFirstValue() {\n+    return new FirstValueCombineFn();\n+  }\n+\n+  public static <T> Combine.CombineFn<T, ?, T> navigationLastValue() {\n+    return new LastValueCombineFn();\n+  }\n+\n+  private static class FirstValueCombineFn<T> extends Combine.CombineFn<T, Optional<T>, T> {\n+    private FirstValueCombineFn() {}\n+\n+    @Override\n+    public Optional<T> createAccumulator() {\n+      return Optional.empty();\n+    }\n+\n+    @Override\n+    public Optional<T> addInput(Optional<T> accumulator, T input) {\n+      Optional<T> r = accumulator;\n+      if (!accumulator.isPresent()) {\n+        r = Optional.of(input);\n+      }\n+      return r;\n+    }\n+\n+    @Override\n+    public Optional<T> mergeAccumulators(Iterable<Optional<T>> accumulators) {\n+      Optional<T> r = Optional.empty();\n+      for (Optional<T> ac : accumulators) {\n+        if (!r.isPresent() && ac.isPresent()) {\n+          r = ac;", "originalCommit": "b7f5aa4ed59c5efd27a0e4ac5238257180f83b5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQwMjAxMQ==", "url": "https://github.com/apache/beam/pull/12313#discussion_r458402011", "bodyText": "Since, navigation functions rely on a sorted input and the addInput method actually should be called synchronously, the mergeAccumulators method never is invoked. So, I was wondering If I would rather remove this code and leave a mock implementation (let's say return null). What do you think?", "author": "jhnmora000", "createdAt": "2020-07-21T21:34:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA5NDMyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQzNDY3MQ==", "url": "https://github.com/apache/beam/pull/12313#discussion_r458434671", "bodyText": "Ah I see. Yes it's actually called sequentially on the sorted input.\nI think you can through an UnsupportedOperationException in  mergeAccumulators  since you will not call mergeAccumulators.\nAnd in the future if there is usage to call mergeAccumulators, the exception will be hit and people will know they need to implement it.", "author": "amaliujia", "createdAt": "2020-07-21T22:52:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA5NDMyMw=="}], "type": "inlineReview"}, {"oid": "7ea7a03c4f87f49148352b9f3e7a2c5df4cd2ff2", "url": "https://github.com/apache/beam/commit/7ea7a03c4f87f49148352b9f3e7a2c5df4cd2ff2", "message": "Remove unnecessary code.\n\nSince, navigation functions are executed sequentially\nthe mergeAccumulators implementation was replaced with\nan UnsupportedOperationException", "committedDate": "2020-07-22T02:07:03Z", "type": "commit"}]}