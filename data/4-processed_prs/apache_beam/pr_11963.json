{"pr_number": 11963, "pr_title": "Add relational GroupBy transform to Python.", "pr_createdAt": "2020-06-10T00:06:16Z", "pr_url": "https://github.com/apache/beam/pull/11963", "timeline": [{"oid": "fdc23d2cd9d14a4dcadc07c0b5b4da5bb9871fc1", "url": "https://github.com/apache/beam/commit/fdc23d2cd9d14a4dcadc07c0b5b4da5bb9871fc1", "message": "Add relational GroupBy transform to Python.", "committedDate": "2020-06-10T00:02:10Z", "type": "commit"}, {"oid": "8075568c1b6aa58b3915a8ba3536927e405a1789", "url": "https://github.com/apache/beam/commit/8075568c1b6aa58b3915a8ba3536927e405a1789", "message": "Python 2 fixes.", "committedDate": "2020-06-10T01:29:06Z", "type": "commit"}, {"oid": "c3c9a8b4252a70688f78cd5b2993a2d4af9b46ed", "url": "https://github.com/apache/beam/commit/c3c9a8b4252a70688f78cd5b2993a2d4af9b46ed", "message": "yapf", "committedDate": "2020-07-07T23:27:52Z", "type": "commit"}, {"oid": "b688262cd77c7fb0d63be99152b8ba51b5ad700b", "url": "https://github.com/apache/beam/commit/b688262cd77c7fb0d63be99152b8ba51b5ad700b", "message": "Avoid size-1 tuples.", "committedDate": "2020-07-08T00:00:14Z", "type": "commit"}, {"oid": "1291b588164e8d0043c73589b0af303d47e9faa9", "url": "https://github.com/apache/beam/commit/1291b588164e8d0043c73589b0af303d47e9faa9", "message": "Docs", "committedDate": "2020-07-08T00:49:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA1MjEyNw==", "url": "https://github.com/apache/beam/pull/11963#discussion_r453052127", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  beam.Map(lambda v: (expr(v), v)) | GroupByKey()\n          \n          \n            \n                  beam.Map(lambda v: (expr(v), v)) | beam.GroupByKey()", "author": "TheNeuralBit", "createdAt": "2020-07-10T20:01:15Z", "path": "sdks/python/apache_beam/transforms/core.py", "diffHunk": "@@ -2247,6 +2248,154 @@ def runner_api_requires_keyed_input(self):\n     return True\n \n \n+def _expr_to_callable(expr, pos):\n+  if isinstance(expr, str):\n+    return lambda x: getattr(x, expr)\n+  elif callable(expr):\n+    return expr\n+  else:\n+    raise TypeError(\n+        'Field expression %r at %s must be a callable or a string.' %\n+        (expr, pos))\n+\n+\n+class GroupBy(PTransform):\n+  \"\"\"Groups a PCollection by one or more expressions, used to derive the key.\n+\n+  `GroupBy(expr)` is roughly equivalent to\n+\n+      beam.Map(lambda v: (expr(v), v)) | GroupByKey()", "originalCommit": "1291b588164e8d0043c73589b0af303d47e9faa9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA1NTE5Nw==", "url": "https://github.com/apache/beam/pull/11963#discussion_r453055197", "bodyText": "Is this a fallback for when a Row uses types that we don't support in Python schemas?\nI worry about this since it makes it tricky for a user to tell when a PCollection can be used in an ExternalTransform that uses rows. Are there some specific types that we need to add coverage for?", "author": "TheNeuralBit", "createdAt": "2020-07-10T20:09:02Z", "path": "sdks/python/apache_beam/coders/row_coder.py", "diffHunk": "@@ -87,7 +87,10 @@ def from_runner_api_parameter(schema, components, unused_context):\n   @staticmethod\n   def from_type_hint(type_hint, registry):\n     if isinstance(type_hint, row_type.RowTypeConstraint):\n-      schema = named_fields_to_schema(type_hint._fields)\n+      try:\n+        schema = named_fields_to_schema(type_hint._fields)\n+      except ValueError:\n+        return typecoders.registry.get_coder(object)", "originalCommit": "1291b588164e8d0043c73589b0af303d47e9faa9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEzNzg5OA==", "url": "https://github.com/apache/beam/pull/11963#discussion_r453137898", "bodyText": "Well, it's also there to handle the case where we simply don't know what the type is. I'll see if I can re-work this to use named tuples (thanks for the idea about __reduce__).", "author": "robertwb", "createdAt": "2020-07-11T01:23:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA1NTE5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA1MDk1NQ==", "url": "https://github.com/apache/beam/pull/11963#discussion_r459050955", "bodyText": "Ah I see. I'd rather not have this escape hatch if we can avoid it, but I can imagine it would be frustrating for users who don't care about using Rows xlang if we just refuse to make a RowCoder for them. Perhaps we should make named_fields_to_schema wrap unknown type hints in a \"pythonsdk\" logical type that uses fast primitives coder. Then we can give a better error message if/when a xlang issue arises. If you just add a TODO here I can take that action.\nWhen running locally I noticed that this is only needed for your tests because we can't infer a type for sign=x // abs(x) if x else 0 and fallback to Any. Just curious - is it possible to fix the inference for that function? It seems like we should be able to.", "author": "TheNeuralBit", "createdAt": "2020-07-22T20:04:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA1NTE5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA1ODczNA==", "url": "https://github.com/apache/beam/pull/11963#discussion_r453058734", "bodyText": "I had this problem with the NamedTuple used in an external transform's output PCollection, I solved it there by making a custom __reduce__ function that rebuilds from the proto-encoded schema:\n\n  \n    \n      beam/sdks/python/apache_beam/typehints/schemas.py\n    \n    \n        Lines 210 to 225\n      in\n      80de476\n    \n    \n    \n    \n\n        \n          \n           type_name = 'BeamSchema_{}'.format(schema.id.replace('-', '_')) \n        \n\n        \n          \n           user_type = NamedTuple( \n        \n\n        \n          \n               type_name, \n        \n\n        \n          \n               [(field.name, typing_from_runner_api(field.type)) \n        \n\n        \n          \n                for field in schema.fields]) \n        \n\n        \n          \n            \n        \n\n        \n          \n           setattr(user_type, _BEAM_SCHEMA_ID, schema.id) \n        \n\n        \n          \n            \n        \n\n        \n          \n           # Define a reduce function, otherwise these types can't be pickled \n        \n\n        \n          \n           # (See BEAM-9574) \n        \n\n        \n          \n           def __reduce__(self): \n        \n\n        \n          \n             return ( \n        \n\n        \n          \n                 _hydrate_namedtuple_instance, \n        \n\n        \n          \n                 (schema.SerializeToString(), tuple(self))) \n        \n\n        \n          \n            \n        \n\n        \n          \n           setattr(user_type, '__reduce__', __reduce__) \n        \n    \n  \n\n\n(A TODO is fine as well, just wanted to point that out in case it's helpful)", "author": "TheNeuralBit", "createdAt": "2020-07-10T20:18:06Z", "path": "sdks/python/apache_beam/transforms/core.py", "diffHunk": "@@ -2247,6 +2248,154 @@ def runner_api_requires_keyed_input(self):\n     return True\n \n \n+def _expr_to_callable(expr, pos):\n+  if isinstance(expr, str):\n+    return lambda x: getattr(x, expr)\n+  elif callable(expr):\n+    return expr\n+  else:\n+    raise TypeError(\n+        'Field expression %r at %s must be a callable or a string.' %\n+        (expr, pos))\n+\n+\n+class GroupBy(PTransform):\n+  \"\"\"Groups a PCollection by one or more expressions, used to derive the key.\n+\n+  `GroupBy(expr)` is roughly equivalent to\n+\n+      beam.Map(lambda v: (expr(v), v)) | GroupByKey()\n+\n+  but provides several conviniences, e.g.\n+\n+      * Several arguments may be provided, as positional or keyword arguments,\n+        resulting in a tuple-like key. For example `GroupBy(a=expr1, b=expr2)`\n+        groups by a key with attributes `a` and `b` computed by applying\n+        `expr1` and `expr2` to each element.\n+\n+      * Strings can be used as a shorthand for accessing an attribute, e.g.\n+        `GroupBy('some_field')` is equivalent to\n+        `GroupBy(lambda v: getattr(v, 'some_field'))`.\n+\n+  The GroupBy operation can be made into an aggregating operation by invoking\n+  its `aggregate_field` method.\n+  \"\"\"\n+  def __init__(\n+      self,\n+      *fields,  # type: typing.Union[str, callable]\n+      **kwargs  # type: typing.Union[str, callable]\n+    ):\n+    if len(fields) == 1 and not kwargs:\n+      self._force_tuple_keys = False\n+      name = fields[0] if isinstance(fields[0], str) else 'key'\n+      key_fields = [(name, _expr_to_callable(fields[0], 0))]\n+    else:\n+      self._force_tuple_keys = True\n+      key_fields = []\n+      for ix, field in enumerate(fields):\n+        name = field if isinstance(field, str) else 'key%d' % ix\n+        key_fields.append((name, _expr_to_callable(field, ix)))\n+      for name, expr in kwargs.items():\n+        key_fields.append((name, _expr_to_callable(expr, name)))\n+    self._key_fields = key_fields\n+    # TODO(robertwb): Pickling of dynamic named tuples.\n+    # self._key_type = typing.NamedTuple(\n+    #     'Key', [name for name, _ in self._key_fields])", "originalCommit": "1291b588164e8d0043c73589b0af303d47e9faa9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA2MTI4Mw==", "url": "https://github.com/apache/beam/pull/11963#discussion_r453061283", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                # TODO(Py3): Use {**a, **b} syntax once Python 2 is gone.\n          \n          \n            \n                # TODO(BEAM-7372): Use {**a, **b} syntax once Python 2 is gone.", "author": "TheNeuralBit", "createdAt": "2020-07-10T20:25:03Z", "path": "sdks/python/apache_beam/transforms/core.py", "diffHunk": "@@ -2247,6 +2248,154 @@ def runner_api_requires_keyed_input(self):\n     return True\n \n \n+def _expr_to_callable(expr, pos):\n+  if isinstance(expr, str):\n+    return lambda x: getattr(x, expr)\n+  elif callable(expr):\n+    return expr\n+  else:\n+    raise TypeError(\n+        'Field expression %r at %s must be a callable or a string.' %\n+        (expr, pos))\n+\n+\n+class GroupBy(PTransform):\n+  \"\"\"Groups a PCollection by one or more expressions, used to derive the key.\n+\n+  `GroupBy(expr)` is roughly equivalent to\n+\n+      beam.Map(lambda v: (expr(v), v)) | GroupByKey()\n+\n+  but provides several conviniences, e.g.\n+\n+      * Several arguments may be provided, as positional or keyword arguments,\n+        resulting in a tuple-like key. For example `GroupBy(a=expr1, b=expr2)`\n+        groups by a key with attributes `a` and `b` computed by applying\n+        `expr1` and `expr2` to each element.\n+\n+      * Strings can be used as a shorthand for accessing an attribute, e.g.\n+        `GroupBy('some_field')` is equivalent to\n+        `GroupBy(lambda v: getattr(v, 'some_field'))`.\n+\n+  The GroupBy operation can be made into an aggregating operation by invoking\n+  its `aggregate_field` method.\n+  \"\"\"\n+  def __init__(\n+      self,\n+      *fields,  # type: typing.Union[str, callable]\n+      **kwargs  # type: typing.Union[str, callable]\n+    ):\n+    if len(fields) == 1 and not kwargs:\n+      self._force_tuple_keys = False\n+      name = fields[0] if isinstance(fields[0], str) else 'key'\n+      key_fields = [(name, _expr_to_callable(fields[0], 0))]\n+    else:\n+      self._force_tuple_keys = True\n+      key_fields = []\n+      for ix, field in enumerate(fields):\n+        name = field if isinstance(field, str) else 'key%d' % ix\n+        key_fields.append((name, _expr_to_callable(field, ix)))\n+      for name, expr in kwargs.items():\n+        key_fields.append((name, _expr_to_callable(expr, name)))\n+    self._key_fields = key_fields\n+    # TODO(robertwb): Pickling of dynamic named tuples.\n+    # self._key_type = typing.NamedTuple(\n+    #     'Key', [name for name, _ in self._key_fields])\n+    self._key_type = lambda *values: pvalue.Row(\n+        **{name: value\n+           for (name, _), value in zip(self._key_fields, values)})\n+\n+  def aggregate_field(\n+      self,\n+      field,  # type: typing.Union[str, callable]\n+      combine_fn,  # type: typing.Union[callable, CombineFn]\n+      dest,  # type: str\n+    ):\n+    \"\"\"Returns a grouping operation that also aggregates grouped values.\n+\n+    Args:\n+      field: indicates the field to be aggregated\n+      combine_fn: indicates the aggregation function to be used\n+      dest: indicates the name that will be used for the aggregate in the output\n+\n+    May be called repeatedly to aggregate multiple fields, e.g.\n+\n+        GroupBy('key')\n+            .aggregate_field('some_attr', sum, 'sum_attr')\n+            .aggregate_field(lambda v: ..., MeanCombineFn, 'mean')\n+    \"\"\"\n+    return _GroupAndAggregate(self, ()).aggregate_field(field, combine_fn, dest)\n+\n+  def force_tuple_keys(self, value=True):\n+    \"\"\"Forces the keys to always be tuple-like, even if there is only a single\n+    expression.\n+    \"\"\"\n+    res = copy.copy(self)\n+    res._force_tuple_keys = value\n+    return res\n+\n+  def _key_func(self):\n+    if not self._force_tuple_keys and len(self._key_fields) == 1:\n+      return self._key_fields[0][1]\n+    else:\n+      key_type = self._key_type\n+      key_exprs = [expr for _, expr in self._key_fields]\n+      return lambda element: key_type(*(expr(element) for expr in key_exprs))\n+\n+  def default_label(self):\n+    return 'GroupBy(%s)' % ', '.join(name for name, _ in self._key_fields)\n+\n+  def expand(self, pcoll):\n+    return pcoll | Map(lambda x: (self._key_func()(x), x)) | GroupByKey()\n+\n+\n+class _GroupAndAggregate(PTransform):\n+  def __init__(self, grouping, aggregations):\n+    self._grouping = grouping\n+    self._aggregations = aggregations\n+\n+  def aggregate_field(\n+      self,\n+      field,  # type: typing.Union[str, callable]\n+      combine_fn,  # type: typing.Union[callable, CombineFn]\n+      dest,  # type: str\n+      ):\n+    field = _expr_to_callable(field, 0)\n+    return _GroupAndAggregate(\n+        self._grouping, list(self._aggregations) + [(field, combine_fn, dest)])\n+\n+  def expand(self, pcoll):\n+    from apache_beam.transforms.combiners import TupleCombineFn\n+\n+    # TODO(Py3): Use {**a, **b} syntax once Python 2 is gone.", "originalCommit": "1291b588164e8d0043c73589b0af303d47e9faa9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA2MjcwMQ==", "url": "https://github.com/apache/beam/pull/11963#discussion_r453062701", "bodyText": "Will issubclass actually raise an AttributeError? Curious what causes this", "author": "TheNeuralBit", "createdAt": "2020-07-10T20:28:47Z", "path": "sdks/python/apache_beam/typehints/native_type_compatibility.py", "diffHunk": "@@ -85,7 +85,7 @@ def _safe_issubclass(derived, parent):\n   \"\"\"\n   try:\n     return issubclass(derived, parent)\n-  except TypeError:\n+  except (TypeError, AttributeError):", "originalCommit": "1291b588164e8d0043c73589b0af303d47e9faa9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEzNzg0Mg==", "url": "https://github.com/apache/beam/pull/11963#discussion_r453137842", "bodyText": "I'm pretty sure I did see this. (Maybe it was missing __mro__ or something?)", "author": "robertwb", "createdAt": "2020-07-11T01:23:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA2MjcwMQ=="}], "type": "inlineReview"}, {"oid": "4b12c53337e6da45deec67b4bb1915da5ebb26bd", "url": "https://github.com/apache/beam/commit/4b12c53337e6da45deec67b4bb1915da5ebb26bd", "message": "Update sdks/python/apache_beam/transforms/core.py\n\nCo-authored-by: Brian Hulette <hulettbh@gmail.com>", "committedDate": "2020-07-11T01:21:18Z", "type": "commit"}, {"oid": "3e903d3777f252e81113f9d606cb930d8226c2af", "url": "https://github.com/apache/beam/commit/3e903d3777f252e81113f9d606cb930d8226c2af", "message": "Produce named tuples rather than Rows.", "committedDate": "2020-07-13T17:23:25Z", "type": "commit"}, {"oid": "ce85297eeb7423a6e8d3dd72cdd4ba6f8a6bbee1", "url": "https://github.com/apache/beam/commit/ce85297eeb7423a6e8d3dd72cdd4ba6f8a6bbee1", "message": "lint", "committedDate": "2020-07-13T19:19:56Z", "type": "commit"}, {"oid": "0ce1a722e88d9d192488610096985eb10ebe3a34", "url": "https://github.com/apache/beam/commit/0ce1a722e88d9d192488610096985eb10ebe3a34", "message": "kwargs ordering", "committedDate": "2020-07-14T18:00:12Z", "type": "commit"}, {"oid": "71c758053be2695a1db66d8797c86042a148970f", "url": "https://github.com/apache/beam/commit/71c758053be2695a1db66d8797c86042a148970f", "message": "lint", "committedDate": "2020-07-14T21:01:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAzMTg5Nw==", "url": "https://github.com/apache/beam/pull/11963#discussion_r459031897", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              but provides several conviniences, e.g.\n          \n          \n            \n              but provides several conveniences, e.g.", "author": "TheNeuralBit", "createdAt": "2020-07-22T19:29:16Z", "path": "sdks/python/apache_beam/transforms/core.py", "diffHunk": "@@ -2247,6 +2249,166 @@ def runner_api_requires_keyed_input(self):\n     return True\n \n \n+def _expr_to_callable(expr, pos):\n+  if isinstance(expr, str):\n+    return lambda x: getattr(x, expr)\n+  elif callable(expr):\n+    return expr\n+  else:\n+    raise TypeError(\n+        'Field expression %r at %s must be a callable or a string.' %\n+        (expr, pos))\n+\n+\n+class GroupBy(PTransform):\n+  \"\"\"Groups a PCollection by one or more expressions, used to derive the key.\n+\n+  `GroupBy(expr)` is roughly equivalent to\n+\n+      beam.Map(lambda v: (expr(v), v)) | beam.GroupByKey()\n+\n+  but provides several conviniences, e.g.", "originalCommit": "71c758053be2695a1db66d8797c86042a148970f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f797820a9548f59d6664a272ab9115e0d444c21a", "url": "https://github.com/apache/beam/commit/f797820a9548f59d6664a272ab9115e0d444c21a", "message": "Update sdks/python/apache_beam/transforms/core.py\n\nCo-authored-by: Brian Hulette <hulettbh@gmail.com>", "committedDate": "2020-07-23T21:47:31Z", "type": "commit"}, {"oid": "51412591d74ac30db2bdc8eb8633c99cb964d917", "url": "https://github.com/apache/beam/commit/51412591d74ac30db2bdc8eb8633c99cb964d917", "message": "lint, todo", "committedDate": "2020-07-23T21:55:56Z", "type": "commit"}]}