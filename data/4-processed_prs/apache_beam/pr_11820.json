{"pr_number": 11820, "pr_title": "[BEAM-10093] ZetaSql Nexmark variant", "pr_createdAt": "2020-05-26T21:29:02Z", "pr_url": "https://github.com/apache/beam/pull/11820", "timeline": [{"oid": "4105390f1779de3a778a60c4408c430c81bf8c5c", "url": "https://github.com/apache/beam/commit/4105390f1779de3a778a60c4408c430c81bf8c5c", "message": "Split Nexmark QueryTest and SqlQueryTest for clarity", "committedDate": "2020-05-27T02:03:10Z", "type": "commit"}, {"oid": "ceffb998d96ba572d09d7674df41e65022391982", "url": "https://github.com/apache/beam/commit/ceffb998d96ba572d09d7674df41e65022391982", "message": "Add ZetaSQL Nexmark variant", "committedDate": "2020-05-27T02:03:10Z", "type": "forcePushed"}, {"oid": "40f7520dd7aa7b576f717f06c709ef87c24b595d", "url": "https://github.com/apache/beam/commit/40f7520dd7aa7b576f717f06c709ef87c24b595d", "message": "Add ZetaSQL Nexmark variant", "committedDate": "2020-05-27T17:39:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIyNjcyNA==", "url": "https://github.com/apache/beam/pull/11820#discussion_r434226724", "bodyText": "Looking at this class and the other SQL classes, it looks like the only difference between SQL and ZetaSQL the SQL string and withQueryPlannerClass. I believe we expect that to be the case for all these queries. Can we take advantage of that and not copy the classes for ZetaSQL?\n(There are lots of ways to implement, but it seems like it would be really easy to add a factory method for each SQL dialect to the existing classes.)", "author": "apilloud", "createdAt": "2020-06-02T23:20:58Z", "path": "sdks/java/testing/nexmark/src/main/java/org/apache/beam/sdk/nexmark/queries/zetasql/ZetaSqlQuery0.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.nexmark.queries.zetasql;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.extensions.sql.SqlTransform;\n+import org.apache.beam.sdk.extensions.sql.zetasql.ZetaSQLQueryPlanner;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.nexmark.model.Bid;\n+import org.apache.beam.sdk.nexmark.model.Event;\n+import org.apache.beam.sdk.nexmark.model.Event.Type;\n+import org.apache.beam.sdk.nexmark.model.sql.SelectEvent;\n+import org.apache.beam.sdk.nexmark.queries.NexmarkQueryTransform;\n+import org.apache.beam.sdk.nexmark.queries.NexmarkQueryUtil;\n+import org.apache.beam.sdk.schemas.transforms.Convert;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.Filter;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.Row;\n+\n+/**\n+ * Query 0: Pass events through unchanged.\n+ *\n+ * <p>This measures the overhead of the Beam ZetaSql implementation and test harness like conversion\n+ * from Java model classes to Beam records.\n+ *\n+ * <p>{@link Bid} events are used here at the moment, \u00e5s they are most numerous with default\n+ * configuration.\n+ */\n+public class ZetaSqlQuery0 extends NexmarkQueryTransform<Bid> {\n+\n+  public ZetaSqlQuery0() {\n+    super(\"ZetaSqlQuery0\");\n+  }\n+\n+  @Override\n+  public PCollection<Bid> expand(PCollection<Event> allEvents) {\n+    PCollection<Row> rows =\n+        allEvents\n+            .apply(Filter.by(NexmarkQueryUtil.IS_BID))\n+            .apply(getName() + \".SelectEvent\", new SelectEvent(Type.BID));\n+\n+    return rows.apply(getName() + \".Serialize\", logBytesMetric(rows.getCoder()))\n+        .setRowSchema(rows.getSchema())\n+        .apply(\n+            SqlTransform.query(\"SELECT * FROM PCOLLECTION\")\n+                .withQueryPlannerClass(ZetaSQLQueryPlanner.class))", "originalCommit": "40f7520dd7aa7b576f717f06c709ef87c24b595d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5NDA5Ng==", "url": "https://github.com/apache/beam/pull/11820#discussion_r435594096", "bodyText": "Yea fair enough. When I started, I did not know how much things would differ. It was suggested that the dialects would not really be compatible, but actually they are. I stopped short of a real refactor but I'll go ahead with something now that it is working.", "author": "kennknowles", "createdAt": "2020-06-04T22:48:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIyNjcyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5NzA0OQ==", "url": "https://github.com/apache/beam/pull/11820#discussion_r435597049", "bodyText": "In my mental model, there are n Nexmark queries with common setup and teardown, and then there are m suites that implement the queries, filling in the middle part. I do want to keep them slightly decoupled in case some of them need hackery. They turned out not to require tweaking, but I'm not super convinced that isn't coincidence.\nSo the refactor I have in mind is to provide the scaffolding for each query but still having a pure java, Calcite, and ZetaSQL suite of classes. The Calcite and ZetaSQL bits would share a lot and/or be one liners.", "author": "kennknowles", "createdAt": "2020-06-04T22:57:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIyNjcyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5ODcwNg==", "url": "https://github.com/apache/beam/pull/11820#discussion_r435598706", "bodyText": "That sounds good to me. Then we can overload the methods that need customization.", "author": "apilloud", "createdAt": "2020-06-04T23:02:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIyNjcyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYyMjc5Nw==", "url": "https://github.com/apache/beam/pull/11820#discussion_r435622797", "bodyText": "OK that was a total misadventure. Going to back to just totally coupling the SQL dialect suites.", "author": "kennknowles", "createdAt": "2020-06-05T00:07:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIyNjcyNA=="}], "type": "inlineReview"}, {"oid": "7d169d9454f22d175ad12e8dfc17922dc015b75f", "url": "https://github.com/apache/beam/commit/7d169d9454f22d175ad12e8dfc17922dc015b75f", "message": "Add ZetaSQL Nexmark variant", "committedDate": "2020-06-05T18:21:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE5MTY1Mg==", "url": "https://github.com/apache/beam/pull/11820#discussion_r436191652", "bodyText": "Checkstyle says no on the underscore. It looks to be failing in a few other places as well.", "author": "apilloud", "createdAt": "2020-06-05T22:27:14Z", "path": "sdks/java/testing/nexmark/src/test/java/org/apache/beam/sdk/nexmark/queries/sql/SqlBoundedSideInputJoinTest.java", "diffHunk": "@@ -48,166 +47,182 @@\n import org.junit.Before;\n import org.junit.Rule;\n import org.junit.Test;\n-import org.junit.experimental.categories.Category;\n+import org.junit.experimental.runners.Enclosed;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n \n /** Test the various NEXMark queries yield results coherent with their models. */\n-@RunWith(JUnit4.class)\n+@RunWith(Enclosed.class)\n public class SqlBoundedSideInputJoinTest {\n \n-  @Rule public TestPipeline p = TestPipeline.create();\n+  private abstract static class SqlBoundedSideInputJoinTestCases {\n \n-  @Before\n-  public void setupPipeline() {\n-    NexmarkUtils.setupPipeline(NexmarkUtils.CoderStrategy.HAND, p);\n-  }\n+    protected abstract SqlBoundedSideInputJoin getQuery(NexmarkConfiguration configuration);\n+\n+    @Rule public TestPipeline p = TestPipeline.create();\n+\n+    @Before\n+    public void setupPipeline() {\n+      NexmarkUtils.setupPipeline(NexmarkUtils.CoderStrategy.HAND, p);\n+    }\n \n-  /** Test {@code query} matches {@code model}. */\n-  private <T extends KnownSize> void queryMatchesModel(\n-      String name,\n-      NexmarkConfiguration config,\n-      NexmarkQueryTransform<T> query,\n-      NexmarkQueryModel<T> model,\n-      boolean streamingMode)\n-      throws Exception {\n-\n-    ResourceId sideInputResourceId =\n-        FileSystems.matchNewResource(\n-            String.format(\n-                \"%s/JoinToFiles-%s\", p.getOptions().getTempLocation(), new Random().nextInt()),\n-            false);\n-    config.sideInputUrl = sideInputResourceId.toString();\n-\n-    try {\n+    /** Test {@code query} matches {@code model}. */\n+    private <T extends KnownSize> void queryMatchesModel(\n+        String name,\n+        NexmarkConfiguration config,\n+        NexmarkQueryTransform<T> query,\n+        NexmarkQueryModel<T> model,\n+        boolean streamingMode)\n+        throws Exception {\n+\n+      ResourceId sideInputResourceId =\n+          FileSystems.matchNewResource(\n+              String.format(\n+                  \"%s/JoinToFiles-%s\", p.getOptions().getTempLocation(), new Random().nextInt()),\n+              false);\n+      config.sideInputUrl = sideInputResourceId.toString();\n+\n+      try {\n+        PCollection<KV<Long, String>> sideInput = NexmarkUtils.prepareSideInput(p, config);\n+        query.setSideInput(sideInput);\n+\n+        PCollection<Event> events =\n+            p.apply(\n+                name + \".Read\",\n+                streamingMode\n+                    ? NexmarkUtils.streamEventsSource(config)\n+                    : NexmarkUtils.batchEventsSource(config));\n+\n+        PCollection<TimestampedValue<T>> results =\n+            (PCollection<TimestampedValue<T>>) events.apply(new NexmarkQuery<>(config, query));\n+        PAssert.that(results).satisfies(model.assertionFor());\n+        PipelineResult result = p.run();\n+        result.waitUntilFinish();\n+      } finally {\n+        NexmarkUtils.cleanUpSideInput(config);\n+      }\n+    }\n+\n+    /**\n+     * A smoke test that the count of input bids and outputs are the same, to help diagnose\n+     * flakiness in more complex tests.\n+     */\n+    @Test\n+    public void inputOutputSameEvents() throws Exception {\n+      NexmarkConfiguration config = NexmarkConfiguration.DEFAULT.copy();\n+      config.sideInputType = NexmarkUtils.SideInputType.DIRECT;\n+      config.numEventGenerators = 1;\n+      config.numEvents = 5000;\n+      config.sideInputRowCount = 10;\n+      config.sideInputNumShards = 3;\n       PCollection<KV<Long, String>> sideInput = NexmarkUtils.prepareSideInput(p, config);\n-      query.setSideInput(sideInput);\n-\n-      PCollection<Event> events =\n-          p.apply(\n-              name + \".Read\",\n-              streamingMode\n-                  ? NexmarkUtils.streamEventsSource(config)\n-                  : NexmarkUtils.batchEventsSource(config));\n-\n-      PCollection<TimestampedValue<T>> results =\n-          (PCollection<TimestampedValue<T>>) events.apply(new NexmarkQuery<>(config, query));\n-      PAssert.that(results).satisfies(model.assertionFor());\n-      PipelineResult result = p.run();\n-      result.waitUntilFinish();\n-    } finally {\n-      NexmarkUtils.cleanUpSideInput(config);\n+\n+      try {\n+        PCollection<Event> input = p.apply(NexmarkUtils.batchEventsSource(config));\n+        PCollection<Bid> justBids = input.apply(NexmarkQueryUtil.JUST_BIDS);\n+        PCollection<Long> bidCount = justBids.apply(\"Count Bids\", Count.globally());\n+\n+        NexmarkQueryTransform<Bid> query = getQuery(config);\n+        query.setSideInput(sideInput);\n+\n+        PCollection<TimestampedValue<Bid>> output =\n+            (PCollection<TimestampedValue<Bid>>) input.apply(new NexmarkQuery(config, query));\n+        PCollection<Long> outputCount = output.apply(\"Count outputs\", Count.globally());\n+\n+        PAssert.that(PCollectionList.of(bidCount).and(outputCount).apply(Flatten.pCollections()))\n+            .satisfies(\n+                counts -> {\n+                  assertThat(Iterables.size(counts), equalTo(2));\n+                  assertThat(Iterables.get(counts, 0), greaterThan(0L));\n+                  assertThat(Iterables.get(counts, 0), equalTo(Iterables.get(counts, 1)));\n+                  return null;\n+                });\n+        p.run();\n+      } finally {\n+        NexmarkUtils.cleanUpSideInput(config);\n+      }\n     }\n-  }\n \n-  /**\n-   * A smoke test that the count of input bids and outputs are the same, to help diagnose flakiness\n-   * in more complex tests.\n-   */\n-  @Test\n-  @Category(NeedsRunner.class)\n-  public void inputOutputSameEvents() throws Exception {\n-    NexmarkConfiguration config = NexmarkConfiguration.DEFAULT.copy();\n-    config.sideInputType = NexmarkUtils.SideInputType.DIRECT;\n-    config.numEventGenerators = 1;\n-    config.numEvents = 5000;\n-    config.sideInputRowCount = 10;\n-    config.sideInputNumShards = 3;\n-    PCollection<KV<Long, String>> sideInput = NexmarkUtils.prepareSideInput(p, config);\n-\n-    try {\n-      PCollection<Event> input = p.apply(NexmarkUtils.batchEventsSource(config));\n-      PCollection<Bid> justBids = input.apply(NexmarkQueryUtil.JUST_BIDS);\n-      PCollection<Long> bidCount = justBids.apply(\"Count Bids\", Count.globally());\n-\n-      NexmarkQueryTransform<Bid> query = new SqlBoundedSideInputJoin(config);\n-      query.setSideInput(sideInput);\n-\n-      PCollection<TimestampedValue<Bid>> output =\n-          (PCollection<TimestampedValue<Bid>>) input.apply(new NexmarkQuery(config, query));\n-      PCollection<Long> outputCount = output.apply(\"Count outputs\", Count.globally());\n-\n-      PAssert.that(PCollectionList.of(bidCount).and(outputCount).apply(Flatten.pCollections()))\n-          .satisfies(\n-              counts -> {\n-                assertThat(Iterables.size(counts), equalTo(2));\n-                assertThat(Iterables.get(counts, 0), greaterThan(0L));\n-                assertThat(Iterables.get(counts, 0), equalTo(Iterables.get(counts, 1)));\n-                return null;\n-              });\n-      p.run();\n-    } finally {\n-      NexmarkUtils.cleanUpSideInput(config);\n+    @Test\n+    public void queryMatchesModelBatchDirect() throws Exception {\n+      NexmarkConfiguration config = NexmarkConfiguration.DEFAULT.copy();\n+      config.sideInputType = NexmarkUtils.SideInputType.DIRECT;\n+      config.numEventGenerators = 1;\n+      config.numEvents = 5000;\n+      config.sideInputRowCount = 10;\n+      config.sideInputNumShards = 3;\n+\n+      queryMatchesModel(\n+          \"SqlBoundedSideInputJoinTestBatch\",\n+          config,\n+          getQuery(config),\n+          new BoundedSideInputJoinModel(config),\n+          false);\n     }\n-  }\n \n-  @Test\n-  @Category(NeedsRunner.class)\n-  public void queryMatchesModelBatchDirect() throws Exception {\n-    NexmarkConfiguration config = NexmarkConfiguration.DEFAULT.copy();\n-    config.sideInputType = NexmarkUtils.SideInputType.DIRECT;\n-    config.numEventGenerators = 1;\n-    config.numEvents = 5000;\n-    config.sideInputRowCount = 10;\n-    config.sideInputNumShards = 3;\n-\n-    queryMatchesModel(\n-        \"SqlBoundedSideInputJoinTestBatch\",\n-        config,\n-        new SqlBoundedSideInputJoin(config),\n-        new BoundedSideInputJoinModel(config),\n-        false);\n-  }\n+    @Test\n+    public void queryMatchesModelStreamingDirect() throws Exception {\n+      NexmarkConfiguration config = NexmarkConfiguration.DEFAULT.copy();\n+      config.sideInputType = NexmarkUtils.SideInputType.DIRECT;\n+      config.numEventGenerators = 1;\n+      config.numEvents = 5000;\n+      config.sideInputRowCount = 10;\n+      config.sideInputNumShards = 3;\n+      queryMatchesModel(\n+          \"SqlBoundedSideInputJoinTestStreaming\",\n+          config,\n+          getQuery(config),\n+          new BoundedSideInputJoinModel(config),\n+          true);\n+    }\n+\n+    @Test\n+    public void queryMatchesModelBatchCsv() throws Exception {\n+      NexmarkConfiguration config = NexmarkConfiguration.DEFAULT.copy();\n+      config.sideInputType = NexmarkUtils.SideInputType.CSV;\n+      config.numEventGenerators = 1;\n+      config.numEvents = 5000;\n+      config.sideInputRowCount = 10;\n+      config.sideInputNumShards = 3;\n+\n+      queryMatchesModel(\n+          \"SqlBoundedSideInputJoinTestBatch\",\n+          config,\n+          getQuery(config),\n+          new BoundedSideInputJoinModel(config),\n+          false);\n+    }\n \n-  @Test\n-  @Category(NeedsRunner.class)\n-  public void queryMatchesModelStreamingDirect() throws Exception {\n-    NexmarkConfiguration config = NexmarkConfiguration.DEFAULT.copy();\n-    config.sideInputType = NexmarkUtils.SideInputType.DIRECT;\n-    config.numEventGenerators = 1;\n-    config.numEvents = 5000;\n-    config.sideInputRowCount = 10;\n-    config.sideInputNumShards = 3;\n-    queryMatchesModel(\n-        \"SqlBoundedSideInputJoinTestStreaming\",\n-        config,\n-        new SqlBoundedSideInputJoin(config),\n-        new BoundedSideInputJoinModel(config),\n-        true);\n+    @Test\n+    public void queryMatchesModelStreamingCsv() throws Exception {\n+      NexmarkConfiguration config = NexmarkConfiguration.DEFAULT.copy();\n+      config.sideInputType = NexmarkUtils.SideInputType.CSV;\n+      config.numEventGenerators = 1;\n+      config.numEvents = 5000;\n+      config.sideInputRowCount = 10;\n+      config.sideInputNumShards = 3;\n+      queryMatchesModel(\n+          \"SqlBoundedSideInputJoinTestStreaming\",\n+          config,\n+          getQuery(config),\n+          new BoundedSideInputJoinModel(config),\n+          true);\n+    }\n   }\n \n-  @Test\n-  @Category(NeedsRunner.class)\n-  public void queryMatchesModelBatchCsv() throws Exception {\n-    NexmarkConfiguration config = NexmarkConfiguration.DEFAULT.copy();\n-    config.sideInputType = NexmarkUtils.SideInputType.CSV;\n-    config.numEventGenerators = 1;\n-    config.numEvents = 5000;\n-    config.sideInputRowCount = 10;\n-    config.sideInputNumShards = 3;\n-\n-    queryMatchesModel(\n-        \"SqlBoundedSideInputJoinTestBatch\",\n-        config,\n-        new SqlBoundedSideInputJoin(config),\n-        new BoundedSideInputJoinModel(config),\n-        false);\n+  @RunWith(JUnit4.class)\n+  public static class SqlBoundedSideInputJoinTest_Calcite extends SqlBoundedSideInputJoinTestCases {", "originalCommit": "7d169d9454f22d175ad12e8dfc17922dc015b75f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "51fe401b259047dc393827dd02217418dec172f7", "url": "https://github.com/apache/beam/commit/51fe401b259047dc393827dd02217418dec172f7", "message": "Add ZetaSQL Nexmark variant", "committedDate": "2020-06-08T18:05:50Z", "type": "forcePushed"}, {"oid": "3fe2d7477f6ebfb9e60b46c1d8ca05587fc03107", "url": "https://github.com/apache/beam/commit/3fe2d7477f6ebfb9e60b46c1d8ca05587fc03107", "message": "Add ZetaSQL Nexmark variant", "committedDate": "2020-06-09T18:41:09Z", "type": "commit"}, {"oid": "3fe2d7477f6ebfb9e60b46c1d8ca05587fc03107", "url": "https://github.com/apache/beam/commit/3fe2d7477f6ebfb9e60b46c1d8ca05587fc03107", "message": "Add ZetaSQL Nexmark variant", "committedDate": "2020-06-09T18:41:09Z", "type": "forcePushed"}]}