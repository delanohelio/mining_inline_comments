{"pr_number": 12430, "pr_title": "[BEAM-10303] Scale progress with respect to windows observation.", "pr_createdAt": "2020-07-30T23:28:21Z", "pr_url": "https://github.com/apache/beam/pull/12430", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY3MzAxNA==", "url": "https://github.com/apache/beam/pull/12430#discussion_r464673014", "bodyText": "nit: here and below around line 558\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                  (HandlesSplits) Iterables.get(mainOutputConsumers, 0);\n          \n          \n            \n                                  (HandlesSplits) Iterables.getOnlyElement(mainOutputConsumers);", "author": "lukecwik", "createdAt": "2020-08-03T21:31:15Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -515,6 +515,9 @@\n               && Iterables.get(mainOutputConsumers, 0) instanceof HandlesSplits) {\n             mainInputConsumer =\n                 new SplittableFnDataReceiver() {\n+                  private final HandlesSplits splitDelegate =\n+                      (HandlesSplits) Iterables.get(mainOutputConsumers, 0);", "originalCommit": "261fbf42f36ba5929fe88c6d07504d2e96714638", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY4MTU1Mw==", "url": "https://github.com/apache/beam/pull/12430#discussion_r464681553", "bodyText": "Should we register this with addProgressRequestCallback so we generate monitoring infos?\nI'm not sure if truncate should be using the downstream progress as part of its calculation when reporting it as a monitoring info. I know that this differs from how we calculate the progress/split point for the SplittableFnDataReceiver since the singular fraction needs to take into account the downstream progress accurately.\nI was always envisioning that work completed/work remaining for the monitoring infos always represented the local knowledge of work and didn't take into account any downstream/upstream knowledge. We can avoid this issue if we merge this logic into the getProgress method around line 533.", "author": "lukecwik", "createdAt": "2020-08-03T21:52:17Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -1029,7 +1040,27 @@ public double getProgress() {\n   private Progress getProgress() {\n     synchronized (splitLock) {\n       if (currentTracker instanceof RestrictionTracker.HasProgress) {\n-        return ((HasProgress) currentTracker).getProgress();\n+        Progress progress = ((HasProgress) currentTracker).getProgress();\n+        double totalWork = progress.getWorkCompleted() + progress.getWorkRemaining();\n+        double completed =\n+            totalWork * currentWindowIterator.previousIndex() + progress.getWorkCompleted();\n+        double remaining =\n+            totalWork * (currentElement.getWindows().size() - currentWindowIterator.nextIndex())\n+                + progress.getWorkRemaining();\n+        return Progress.from(completed, remaining);\n+      }\n+    }\n+    return null;\n+  }\n+\n+  private Progress getProgressFromWindowObservingTruncate(double elementCompleted) {\n+    synchronized (splitLock) {\n+      if (currentWindowIterator != null) {", "originalCommit": "261fbf42f36ba5929fe88c6d07504d2e96714638", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIzNDE4MA==", "url": "https://github.com/apache/beam/pull/12430#discussion_r465234180", "bodyText": "I was hesitated to do so since I'm not sure whether the progress from Truncate is used anywhere unless it's used for runner side split decision. Then there is another question, should the progress from Truncate be used for split decision?", "author": "boyuanzz", "createdAt": "2020-08-04T18:05:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY4MTU1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMwNDg3MQ==", "url": "https://github.com/apache/beam/pull/12430#discussion_r465304871", "bodyText": "Thinking about this more, I do believe that the progress does need to be reported as a metric so a runner can choose a split fraction and also compute the amount of remaining work and/or completion time estimate. It looks like either:\n\nNeed to make work completed/remaining take into account downstream processing\nNeed to add a metric that represents work in progress so that a runner can compute the amount of work being done (without this we can't figure out how much the work remaining downstream is relative to an upstream node).\n\nI'm not a big fan of 1) since it means that this metric is intrinsically tied to the state of other transforms while in 2) we are adding something new.", "author": "lukecwik", "createdAt": "2020-08-04T20:16:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY4MTU1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4MTM0Mw==", "url": "https://github.com/apache/beam/pull/12430#discussion_r465381343", "bodyText": "I think the combination of Truncate observing windows and Process consuming elements makes progress/split quite complicated. It seems like a special case of handling split/progress for a non-root SDF.\nIf we treat the Truncate only as a special case, we can go with option1 and let the runner to decide how to make the split decision. In this case, it's natural for Truncate to report the progress combing with the downstream progress.\nFor option2, I'm not sure how a runner computes the work remaining based on the new metric.", "author": "boyuanzz", "createdAt": "2020-08-04T23:14:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY4MTU1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg1NTQyNQ==", "url": "https://github.com/apache/beam/pull/12430#discussion_r465855425", "bodyText": "Yes, truncate exposes some of the issues where a non root SDF makes things interesting.\nFor option2, if we assume that inprogress is included in remaining then:\ntotal = completed + remaining\nfraction_completed = (inprogress / remaining) * downstream_fraction_completed + completed / total\n\ndownstream_fraction_completed would be computed recursively and could also be computed effectively if there were multiple consumers with (completed_conumers + downstream_fraction_completed) / total_num_consumers", "author": "lukecwik", "createdAt": "2020-08-05T16:33:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY4MTU1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg5MTk2MQ==", "url": "https://github.com/apache/beam/pull/12430#discussion_r465891961", "bodyText": "Thanks for the formula. If we let the runner to do the computation, the runner needs to lookup the graph to figure out which progress is from downstream. I'm thinking about another option: we can add a progress signal for split specifically, which should be reported by the root node of the SDK graph. All computations you have mentioned can be done in the SDK side recursively. The runner side can decide whether to look into this signal by knowing whether there is an SDF(or SDFs) in the SDK graph.", "author": "boyuanzz", "createdAt": "2020-08-05T17:35:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY4MTU1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkwMjA2NQ==", "url": "https://github.com/apache/beam/pull/12430#discussion_r465902065", "bodyText": "Originally the idea was that we didn't want the SDK to have to perform these calculations and it is why each operator was going to report work_completed/work_remaining if it had them but it seems like accurate splitting by fraction needs to take it into account.\nUsing the graph to compute the progress shouldn't be any more/less difficult then the work that is being put into the SDK.\nIs there still value in reporting the work_completed/work_remaining metrics then?", "author": "lukecwik", "createdAt": "2020-08-05T17:53:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY4MTU1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4Mjk5MA==", "url": "https://github.com/apache/beam/pull/12430#discussion_r467182990", "bodyText": "I did forget something, it turns out that work_completed/work_remaining are lists of progresses so you can report one for each active element so it turns out that the protocol didn't forget about this inprogress issue.\nThis could change our suggestion of how to report progress for window observing things or we can go with the idea of pushing it up to the gRPC read still.", "author": "lukecwik", "createdAt": "2020-08-07T17:46:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY4MTU1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI2NjMzNg==", "url": "https://github.com/apache/beam/pull/12430#discussion_r467266336", "bodyText": "Are you saying that one transform can report the progress metric per element/window? For example, saying that the Truncate is on window1 and there are 3 windows in total, the downstream sdf progress is 0.5. Then the Truncate should report [(work_completed=1, work_remaining=0), (work_completed=1, work_remaining=0), (work_completed=0, work_remaining=1)] and the sdf should report [(work_completed=0.5, work_remaining=0.5)]? The the actual completed should be 1 + 1 * 0.5?", "author": "boyuanzz", "createdAt": "2020-08-07T20:59:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY4MTU1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI3MjM4Mg==", "url": "https://github.com/apache/beam/pull/12430#discussion_r467272382", "bodyText": "Yes, assuming you meant to say that truncate is on window2.", "author": "lukecwik", "createdAt": "2020-08-07T21:16:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY4MTU1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI5NjYyNQ==", "url": "https://github.com/apache/beam/pull/12430#discussion_r467296625", "bodyText": "I would prefer to let gRPC report element progress since it looks simpler, and also helps us to report less metrics. It's also more straight forward for each transform to compute element progress regarding to downstream progress.", "author": "boyuanzz", "createdAt": "2020-08-07T21:51:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY4MTU1Mw=="}], "type": "inlineReview"}, {"oid": "d7dda980b650e2636318715367c8d0d4aa94de17", "url": "https://github.com/apache/beam/commit/d7dda980b650e2636318715367c8d0d4aa94de17", "message": "Scale progress with respect to windows observation.", "committedDate": "2020-08-04T19:20:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE3NzEzOQ==", "url": "https://github.com/apache/beam/pull/12430#discussion_r467177139", "bodyText": "This should be the stop index since splitting limits the current window iterator so the progress will be wrong after a split happens.", "author": "lukecwik", "createdAt": "2020-08-07T17:34:54Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -1029,12 +1040,35 @@ public double getProgress() {\n   private Progress getProgress() {\n     synchronized (splitLock) {\n       if (currentTracker instanceof RestrictionTracker.HasProgress) {\n-        return ((HasProgress) currentTracker).getProgress();\n+        return scaleProgress(\n+            ((HasProgress) currentTracker).getProgress(),\n+            currentWindowIterator.previousIndex(),\n+            currentElement.getWindows().size());", "originalCommit": "d7dda980b650e2636318715367c8d0d4aa94de17", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM2NDQ4NA==", "url": "https://github.com/apache/beam/pull/12430#discussion_r467364484", "bodyText": "Added windowStopIndex.", "author": "boyuanzz", "createdAt": "2020-08-08T05:22:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE3NzEzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE3ODQxMg==", "url": "https://github.com/apache/beam/pull/12430#discussion_r467178412", "bodyText": "totalWork -> totalWorkPerWindow", "author": "lukecwik", "createdAt": "2020-08-07T17:37:40Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -1029,12 +1040,35 @@ public double getProgress() {\n   private Progress getProgress() {\n     synchronized (splitLock) {\n       if (currentTracker instanceof RestrictionTracker.HasProgress) {\n-        return ((HasProgress) currentTracker).getProgress();\n+        return scaleProgress(\n+            ((HasProgress) currentTracker).getProgress(),\n+            currentWindowIterator.previousIndex(),\n+            currentElement.getWindows().size());\n       }\n     }\n     return null;\n   }\n \n+  private Progress getProgressFromWindowObservingTruncate(double elementCompleted) {\n+    synchronized (splitLock) {\n+      if (currentWindowIterator != null) {\n+        return scaleProgress(\n+            Progress.from(elementCompleted, 1 - elementCompleted),\n+            currentWindowIterator.previousIndex(),\n+            currentElement.getWindows().size());\n+      }\n+    }\n+    return null;\n+  }\n+\n+  private Progress scaleProgress(Progress progress, int completedWindowIndex, int windowCount) {\n+    double totalWork = progress.getWorkCompleted() + progress.getWorkRemaining();", "originalCommit": "d7dda980b650e2636318715367c8d0d4aa94de17", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE3ODYzMA==", "url": "https://github.com/apache/beam/pull/12430#discussion_r467178630", "bodyText": "For the future:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private Progress scaleProgress(Progress progress, int completedWindowIndex, int windowCount) {\n          \n          \n            \n              private Progress scaleProgress(Progress progress, int currentWindowIndex, int stopWindowIndex) {\n          \n      \n    \n    \n  \n\nNote that it is important that it isn't the number of completed windows but the current window index otherwise the math doesn't work out.", "author": "lukecwik", "createdAt": "2020-08-07T17:38:04Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -1029,12 +1040,35 @@ public double getProgress() {\n   private Progress getProgress() {\n     synchronized (splitLock) {\n       if (currentTracker instanceof RestrictionTracker.HasProgress) {\n-        return ((HasProgress) currentTracker).getProgress();\n+        return scaleProgress(\n+            ((HasProgress) currentTracker).getProgress(),\n+            currentWindowIterator.previousIndex(),\n+            currentElement.getWindows().size());\n       }\n     }\n     return null;\n   }\n \n+  private Progress getProgressFromWindowObservingTruncate(double elementCompleted) {\n+    synchronized (splitLock) {\n+      if (currentWindowIterator != null) {\n+        return scaleProgress(\n+            Progress.from(elementCompleted, 1 - elementCompleted),\n+            currentWindowIterator.previousIndex(),\n+            currentElement.getWindows().size());\n+      }\n+    }\n+    return null;\n+  }\n+\n+  private Progress scaleProgress(Progress progress, int completedWindowIndex, int windowCount) {", "originalCommit": "d7dda980b650e2636318715367c8d0d4aa94de17", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDc3MjM0OA==", "url": "https://github.com/apache/beam/pull/12430#discussion_r470772348", "bodyText": "nit: make the method static", "author": "lukecwik", "createdAt": "2020-08-14T17:57:20Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/FnApiDoFnRunner.java", "diffHunk": "@@ -1029,12 +1048,36 @@ public double getProgress() {\n   private Progress getProgress() {\n     synchronized (splitLock) {\n       if (currentTracker instanceof RestrictionTracker.HasProgress) {\n-        return ((HasProgress) currentTracker).getProgress();\n+        return scaleProgress(\n+            ((HasProgress) currentTracker).getProgress(),\n+            currentWindowIterator.previousIndex(),\n+            windowStopIndex);\n+      }\n+    }\n+    return null;\n+  }\n+\n+  private Progress getProgressFromWindowObservingTruncate(double elementCompleted) {\n+    synchronized (splitLock) {\n+      if (currentWindow != null) {\n+        return scaleProgress(\n+            Progress.from(elementCompleted, 1 - elementCompleted),\n+            currentWindowIterator.previousIndex(),\n+            windowStopIndex);\n       }\n     }\n     return null;\n   }\n \n+  private Progress scaleProgress(Progress progress, int currentWindowIndex, int stopWindowIndex) {", "originalCommit": "dc839163a6d273addd7322d37bf157150409eafe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a76edaa9582ac433a5f28c3b409d139134f5a8e1", "url": "https://github.com/apache/beam/commit/a76edaa9582ac433a5f28c3b409d139134f5a8e1", "message": "Scale progress with respect to windows observation.", "committedDate": "2020-08-14T18:34:27Z", "type": "commit"}, {"oid": "a76edaa9582ac433a5f28c3b409d139134f5a8e1", "url": "https://github.com/apache/beam/commit/a76edaa9582ac433a5f28c3b409d139134f5a8e1", "message": "Scale progress with respect to windows observation.", "committedDate": "2020-08-14T18:34:27Z", "type": "forcePushed"}]}