{"pr_number": 12934, "pr_title": "[BEAM-10959] Store a fixed amount of known process bundle instructions to prevent failures due to concurrency within a runner.", "pr_createdAt": "2020-09-25T00:23:25Z", "pr_url": "https://github.com/apache/beam/pull/12934", "timeline": [{"oid": "a58c1a11fef00e2c306af4891a272de9e348f856", "url": "https://github.com/apache/beam/commit/a58c1a11fef00e2c306af4891a272de9e348f856", "message": "[BEAM-10959] Store a fixed amount of known process bundle instructions to prevent failures due to concurrency within a runner.", "committedDate": "2020-09-25T00:21:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY4MDQ5Mw==", "url": "https://github.com/apache/beam/pull/12934#discussion_r494680493", "bodyText": "this .get() was necessary to prevent a race condition where the pipeline could shutdown before finalization happened.", "author": "lukecwik", "createdAt": "2020-09-25T00:24:44Z", "path": "sdks/python/apache_beam/runners/portability/fn_api_runner/fn_runner.py", "diffHunk": "@@ -894,7 +897,10 @@ def process_bundle(self,\n       finalize_request = beam_fn_api_pb2.InstructionRequest(\n           finalize_bundle=beam_fn_api_pb2.FinalizeBundleRequest(\n               instruction_id=process_bundle_id))\n-      self._worker_handler.control_conn.push(finalize_request)\n+      finalize_response = self._worker_handler.control_conn.push(\n+          finalize_request).get()", "originalCommit": "a58c1a11fef00e2c306af4891a272de9e348f856", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE0ODcxNA==", "url": "https://github.com/apache/beam/pull/12934#discussion_r495148714", "bodyText": "This this bug is unrelated to SDF, right? Would this be erroneously reporting successful bundle processing, or is it a minor issue since the pipeline is being shut down?", "author": "udim", "createdAt": "2020-09-25T18:02:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY4MDQ5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY4MDYxOA==", "url": "https://github.com/apache/beam/pull/12934#discussion_r494680618", "bodyText": "This logic is now handled by the BundleProcessorCache", "author": "lukecwik", "createdAt": "2020-09-25T00:25:06Z", "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -286,22 +294,9 @@ def _request_process_bundle_progress(self, request):\n \n   def _request_process_bundle_action(self, request):\n     # type: (beam_fn_api_pb2.InstructionRequest) -> None\n-\n     def task():\n-      instruction_id = getattr(", "originalCommit": "a58c1a11fef00e2c306af4891a272de9e348f856", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "715f41743827f45e5ba6830c69b21abd91f7de33", "url": "https://github.com/apache/beam/commit/715f41743827f45e5ba6830c69b21abd91f7de33", "message": "fixup! Fix typo in typing information", "committedDate": "2020-09-25T14:00:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE0NTU3OA==", "url": "https://github.com/apache/beam/pull/12934#discussion_r495145578", "bodyText": "Seems that if we lock here we won't have to duplicate code", "author": "y1chi", "createdAt": "2020-09-25T17:55:51Z", "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -376,35 +385,76 @@ def get(self, instruction_id, bundle_descriptor_id):\n \n     Moves the ``BundleProcessor`` from the inactive to the active cache.\n     \"\"\"\n-    try:\n-      # pop() is threadsafe\n-      processor = self.cached_bundle_processors[bundle_descriptor_id].pop()\n-    except IndexError:\n-      processor = bundle_processor.BundleProcessor(\n-          self.fns[bundle_descriptor_id],\n-          self.state_handler_factory.create_state_handler(\n-              self.fns[bundle_descriptor_id].state_api_service_descriptor),\n-          self.data_channel_factory)\n-    self.active_bundle_processors[", "originalCommit": "a58c1a11fef00e2c306af4891a272de9e348f856", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5NTQ4NQ==", "url": "https://github.com/apache/beam/pull/12934#discussion_r495195485", "bodyText": "I'm not sure what change your suggesting.\nNote, it is important to not hold the lock while we instantiate the BundleProcessor or access self.fns", "author": "lukecwik", "createdAt": "2020-09-25T19:41:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE0NTU3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIwNTY0NQ==", "url": "https://github.com/apache/beam/pull/12934#discussion_r495205645", "bodyText": "isn't it the same if we do\n    try:\n      # pop() is threadsafe\n      processor = self.cached_bundle_processors[bundle_descriptor_id].pop()\n    except IndexError:\n      processor = bundle_processor.BundleProcessor(\n          self.fns[bundle_descriptor_id],\n          self.state_handler_factory.create_state_handler(\n              self.fns[bundle_descriptor_id].state_api_service_descriptor),\n          self.data_channel_factory)\n\n    with self._lock:\n      self.active_bundle_processors[\n        instruction_id] = bundle_descriptor_id, processor\n      try:\n        del self.known_not_running_instruction_ids[instruction_id]\n      except KeyError:\n        # The instruction may have not been pre-registered before execution\n        # since activate() may have never been invoked\n        pass\n    return processor", "author": "y1chi", "createdAt": "2020-09-25T20:04:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE0NTU3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIyMzEwMg==", "url": "https://github.com/apache/beam/pull/12934#discussion_r495223102", "bodyText": "The pop is thread safe but accessing self.cached_bundle_processors[bundle_descriptor_id] is not guaranteed to be so your right that some could be saved based upon your suggestion but it still requires a self.lock surrounding\nprocessor = self.cached_bundle_processors[bundle_descriptor_id].pop()\n\nwhich will lead to us acquiring the mutex twice for the case when there is a cached instance while the current imlementation only needs the mutex twice if we need to create the BundleProcessor.", "author": "lukecwik", "createdAt": "2020-09-25T20:47:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE0NTU3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE2NTAyNA==", "url": "https://github.com/apache/beam/pull/12934#discussion_r495165024", "bodyText": "Is it by design that we pop the items in LIFO order?", "author": "y1chi", "createdAt": "2020-09-25T18:35:27Z", "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -376,35 +385,76 @@ def get(self, instruction_id, bundle_descriptor_id):\n \n     Moves the ``BundleProcessor`` from the inactive to the active cache.\n     \"\"\"\n-    try:\n-      # pop() is threadsafe\n-      processor = self.cached_bundle_processors[bundle_descriptor_id].pop()\n-    except IndexError:\n-      processor = bundle_processor.BundleProcessor(\n-          self.fns[bundle_descriptor_id],\n-          self.state_handler_factory.create_state_handler(\n-              self.fns[bundle_descriptor_id].state_api_service_descriptor),\n-          self.data_channel_factory)\n-    self.active_bundle_processors[\n+    with self._lock:\n+      try:\n+        # pop() is threadsafe\n+        processor = self.cached_bundle_processors[bundle_descriptor_id].pop()\n+        self.active_bundle_processors[\n+          instruction_id] = bundle_descriptor_id, processor\n+        try:\n+          del self.known_not_running_instruction_ids[instruction_id]\n+        except KeyError:\n+          # The instruction may have not been pre-registered before execution\n+          # since activate() may have never been invoked\n+          pass\n+        return processor\n+      except IndexError:\n+        pass\n+\n+    # Make sure we instantiate the processor while not holding the lock.\n+    processor = bundle_processor.BundleProcessor(\n+        self.fns[bundle_descriptor_id],\n+        self.state_handler_factory.create_state_handler(\n+            self.fns[bundle_descriptor_id].state_api_service_descriptor),\n+        self.data_channel_factory)\n+    with self._lock:\n+      self.active_bundle_processors[\n         instruction_id] = bundle_descriptor_id, processor\n+      try:\n+        del self.known_not_running_instruction_ids[instruction_id]\n+      except KeyError:\n+        # The instruction may have not been pre-registered before execution\n+        # since activate() may have never been invoked\n+        pass\n     return processor\n \n   def lookup(self, instruction_id):\n     # type: (str) -> Optional[bundle_processor.BundleProcessor]\n \n     \"\"\"\n     Return the requested ``BundleProcessor`` from the cache.\n+\n+    Will return ``None`` if the BundleProcessor is known but not yet ready. Will\n+    raise an error if the ``instruction_id`` is not known or has been discarded.\n     \"\"\"\n-    return self.active_bundle_processors.get(instruction_id, (None, None))[-1]\n+    with self._lock:\n+      if instruction_id in self.failed_instruction_ids:\n+        raise RuntimeError(\n+            'Bundle processing associated with %s has failed. '\n+            'Check prior failing response for details.' % instruction_id)\n+      processor = self.active_bundle_processors.get(\n+          instruction_id, (None, None))[-1]\n+      if processor:\n+        return processor\n+      if instruction_id in self.known_not_running_instruction_ids:\n+        return None\n+      raise RuntimeError('Unknown process bundle id %s.' % instruction_id)\n \n   def discard(self, instruction_id):\n     # type: (str) -> None\n \n     \"\"\"\n-    Remove the ``BundleProcessor`` from the cache.\n+    Marks the instruction id as failed shutting down the ``BundleProcessor``.\n     \"\"\"\n-    self.active_bundle_processors[instruction_id][1].shutdown()\n-    del self.active_bundle_processors[instruction_id]\n+    with self._lock:\n+      self.failed_instruction_ids[instruction_id] = True\n+      while len(self.failed_instruction_ids) > MAX_FAILED_INSTRUCTIONS:\n+        self.failed_instruction_ids.popitem()", "originalCommit": "715f41743827f45e5ba6830c69b21abd91f7de33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE4NTc3NA==", "url": "https://github.com/apache/beam/pull/12934#discussion_r495185774", "bodyText": "Good catch, we probably want FIFO", "author": "udim", "createdAt": "2020-09-25T19:19:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE2NTAyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5NjIwOQ==", "url": "https://github.com/apache/beam/pull/12934#discussion_r495196209", "bodyText": "Fixed.", "author": "lukecwik", "createdAt": "2020-09-25T19:43:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE2NTAyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE3ODMyNg==", "url": "https://github.com/apache/beam/pull/12934#discussion_r495178326", "bodyText": "Not sure if any locking needs to be done in this method. Perhaps known_not_running_instruction_ids should be cleared?\nIt seems that this is called when no more requests will be processed (end of SdkHarness.run()), so this should be fine.", "author": "udim", "createdAt": "2020-09-25T19:03:28Z", "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -415,10 +465,19 @@ def release(self, instruction_id):\n     Resets the ``BundleProcessor`` and moves it from the active to the\n     inactive cache.\n     \"\"\"\n-    descriptor_id, processor = self.active_bundle_processors.pop(instruction_id)\n+    with self._lock:\n+      self.known_not_running_instruction_ids[instruction_id] = True\n+      while len(self.known_not_running_instruction_ids\n+                ) > MAX_KNOWN_NOT_RUNNING_INSTRUCTIONS:\n+        self.known_not_running_instruction_ids.popitem()\n+      descriptor_id, processor = (\n+          self.active_bundle_processors.pop(instruction_id))\n+\n+    # Make sure that we reset the processor while not holding the lock.\n     processor.reset()\n-    self.last_access_times[descriptor_id] = time.time()\n-    self.cached_bundle_processors[descriptor_id].append(processor)\n+    with self._lock:\n+      self.last_access_times[descriptor_id] = time.time()\n+      self.cached_bundle_processors[descriptor_id].append(processor)\n \n   def shutdown(self):\n     \"\"\"", "originalCommit": "715f41743827f45e5ba6830c69b21abd91f7de33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5NjQ2OQ==", "url": "https://github.com/apache/beam/pull/12934#discussion_r495196469", "bodyText": "From my understanding I also think it should be fine since it is on shutdown.", "author": "lukecwik", "createdAt": "2020-09-25T19:43:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE3ODMyNg=="}], "type": "inlineReview"}, {"oid": "28b604c898bd01193d3d9fe4c5c0b9ed3cba41fd", "url": "https://github.com/apache/beam/commit/28b604c898bd01193d3d9fe4c5c0b9ed3cba41fd", "message": "fixup! Address PR comments", "committedDate": "2020-09-25T19:46:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIwNTU2NQ==", "url": "https://github.com/apache/beam/pull/12934#discussion_r495205565", "bodyText": "Aren't all instruction ids unique for a given SDK harness/runner combo anyway? If this is the first time we've seen this instruction, why would the instruction be repeated?  I thought only the bundle descriptor ids were re-used?", "author": "lostluck", "createdAt": "2020-09-25T20:04:05Z", "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -376,35 +385,76 @@ def get(self, instruction_id, bundle_descriptor_id):\n \n     Moves the ``BundleProcessor`` from the inactive to the active cache.\n     \"\"\"\n-    try:\n-      # pop() is threadsafe\n-      processor = self.cached_bundle_processors[bundle_descriptor_id].pop()\n-    except IndexError:\n-      processor = bundle_processor.BundleProcessor(\n-          self.fns[bundle_descriptor_id],\n-          self.state_handler_factory.create_state_handler(\n-              self.fns[bundle_descriptor_id].state_api_service_descriptor),\n-          self.data_channel_factory)\n-    self.active_bundle_processors[\n+    with self._lock:\n+      try:\n+        # pop() is threadsafe\n+        processor = self.cached_bundle_processors[bundle_descriptor_id].pop()\n+        self.active_bundle_processors[\n+          instruction_id] = bundle_descriptor_id, processor\n+        try:\n+          del self.known_not_running_instruction_ids[instruction_id]", "originalCommit": "28b604c898bd01193d3d9fe4c5c0b9ed3cba41fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIxODY3NQ==", "url": "https://github.com/apache/beam/pull/12934#discussion_r495218675", "bodyText": "The instruction_id refers to the original ProcessBundleRequest instruction_id which is different then the current requests instruction_id found on request.instruction_id", "author": "lukecwik", "createdAt": "2020-09-25T20:36:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIwNTU2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIyOTUyNA==", "url": "https://github.com/apache/beam/pull/12934#discussion_r495229524", "bodyText": "Ack. Now that I understand the semantics as the value existing in both before and after processing this makes sense.", "author": "lostluck", "createdAt": "2020-09-25T21:04:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIwNTU2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIwNzU3Mg==", "url": "https://github.com/apache/beam/pull/12934#discussion_r495207572", "bodyText": "So, the correct response if something hasn't previously failed, and isn't running is an empty response for both Splits and Progress requests?\nThat's easy enough to fix. Go current fails, but it's very easy to swap that up.", "author": "lostluck", "createdAt": "2020-09-25T20:09:09Z", "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -543,15 +602,19 @@ def process_bundle_split(self,\n                            instruction_id  # type: str\n                           ):\n     # type: (...) -> beam_fn_api_pb2.InstructionResponse\n-    processor = self.bundle_processor_cache.lookup(request.instruction_id)\n-    if processor:\n-      return beam_fn_api_pb2.InstructionResponse(\n-          instruction_id=instruction_id,\n-          process_bundle_split=processor.try_split(request))\n-    else:\n+    try:\n+      processor = self.bundle_processor_cache.lookup(request.instruction_id)\n+    except RuntimeError:\n       return beam_fn_api_pb2.InstructionResponse(\n-          instruction_id=instruction_id,\n-          error='Instruction not running: %s' % instruction_id)\n+          instruction_id=instruction_id, error=traceback.format_exc())\n+    # Return an empty response if we aren't running. This can happen\n+    # if the ProcessBundleRequest has not started or already finished.\n+    process_bundle_split = (\n+        processor.try_split(request)\n+        if processor else beam_fn_api_pb2.ProcessBundleSplitResponse())", "originalCommit": "28b604c898bd01193d3d9fe4c5c0b9ed3cba41fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIwODYxNw==", "url": "https://github.com/apache/beam/pull/12934#discussion_r495208617", "bodyText": "Yes, but you should strive to return an error for unknown/failed instructions.\nThis PR also keeps a fixed number of completed/failed instructions in a LRU like object so that even after the bundle completes we can still return a useful answer before we start sending the I don't know answer.", "author": "lukecwik", "createdAt": "2020-09-25T20:11:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIwNzU3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIxNzE0Nw==", "url": "https://github.com/apache/beam/pull/12934#discussion_r495217147", "bodyText": "So to be clear, the semantics are required to be:\nReceive PB request for INST. -> Empty Splits & and Progress\nINST starts having results -> Return results.\nINST finishes -> EmptySplits and progress until \"expired\".\nAnd the \"I don't know\" is an error for  every other circumstance?\nIn the case where the bundle finishes, but requires Finalization, it INST should remain valid and Empties until finalization occurs.", "author": "lostluck", "createdAt": "2020-09-25T20:32:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIwNzU3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIxOTMxMg==", "url": "https://github.com/apache/beam/pull/12934#discussion_r495219312", "bodyText": "Filed https://issues.apache.org/jira/browse/BEAM-10976 for implementing Go SDK bundle finalization along with a reminder about this issue regarding the active status.", "author": "lostluck", "createdAt": "2020-09-25T20:37:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIwNzU3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIxOTU5MA==", "url": "https://github.com/apache/beam/pull/12934#discussion_r495219590", "bodyText": "You'll want to differentiate the failed case and once the Go SDK handles bundle finalization consider that as well (i.e. keep INST live until the finalize request comes or a user specified timeout happens)", "author": "lukecwik", "createdAt": "2020-09-25T20:38:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIwNzU3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM0ODIzOA==", "url": "https://github.com/apache/beam/pull/12934#discussion_r495348238", "bodyText": "The Go SDK already differentiates the failed case and re-forwards the cached error.", "author": "lostluck", "createdAt": "2020-09-26T00:45:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIwNzU3Mg=="}], "type": "inlineReview"}]}