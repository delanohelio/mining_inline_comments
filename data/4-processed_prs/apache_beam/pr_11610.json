{"pr_number": 11610, "pr_title": "[BEAM-9825] | Implement Intersect,Union,Except transforms", "pr_createdAt": "2020-05-05T08:33:35Z", "pr_url": "https://github.com/apache/beam/pull/11610", "timeline": [{"oid": "d7675d573d6bf2ec1db74fa4e1fc1ce1436c11f8", "url": "https://github.com/apache/beam/commit/d7675d573d6bf2ec1db74fa4e1fc1ce1436c11f8", "message": "[BEAM-9825] | Implement Intersect,Union,Except transforms", "committedDate": "2020-05-05T08:10:27Z", "type": "commit"}, {"oid": "c39fecc44c0309096d9767c788974cdc30e974d6", "url": "https://github.com/apache/beam/commit/c39fecc44c0309096d9767c788974cdc30e974d6", "message": "[BEAM-9825] | fix variable names", "committedDate": "2020-05-05T08:49:08Z", "type": "commit"}, {"oid": "21e83eac027f28eae007a66d031d79c06f32a07b", "url": "https://github.com/apache/beam/commit/21e83eac027f28eae007a66d031d79c06f32a07b", "message": "[BEAM-9825] | use SetFn transforms from BeamSQL code", "committedDate": "2020-05-05T12:16:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxMzcwOQ==", "url": "https://github.com/apache/beam/pull/11610#discussion_r420413709", "bodyText": "Is not Math.min(numberOfElementsinLeft, numberOfElementsinRight) sufficient?", "author": "robertwb", "createdAt": "2020-05-05T21:20:53Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the intersection with provided\n+   * {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection<T>}.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersect(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> intersect(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImpl<>(rightCollection, intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the intersection all with\n+   * provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection<T>}\n+   * (left) and n elements on in provided {@link PCollection<T>} (right): - it will output MIN(m -\n+   * n, 0) elements of left for all elements which are present in both left and right.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectAll(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> intersectAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? Math.min(numberOfElementsinLeft, numberOfElementsinRight) : 0L;", "originalCommit": "21e83eac027f28eae007a66d031d79c06f32a07b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU4NzYwOQ==", "url": "https://github.com/apache/beam/pull/11610#discussion_r420587609", "bodyText": "Thanks very valuable. I have fixed this.", "author": "darshanj", "createdAt": "2020-05-06T07:15:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxMzcwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxNTU4Mw==", "url": "https://github.com/apache/beam/pull/11610#discussion_r420415583", "bodyText": "Isn't this expression always sufficient?", "author": "robertwb", "createdAt": "2020-05-05T21:24:49Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the intersection with provided\n+   * {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection<T>}.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersect(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> intersect(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImpl<>(rightCollection, intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the intersection all with\n+   * provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection<T>}\n+   * (left) and n elements on in provided {@link PCollection<T>} (right): - it will output MIN(m -\n+   * n, 0) elements of left for all elements which are present in both left and right.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectAll(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> intersectAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? Math.min(numberOfElementsinLeft, numberOfElementsinRight) : 0L;\n+    return new SetImpl<>(rightCollection, intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the difference (except) with\n+   * provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} will all distinct elements that present in\n+   * pipeline is constructed {@link PCollection<T>} but not present in provided {@link\n+   * PCollection<T>}.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.except(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> except(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> numberOfElementsinLeft > 0 && numberOfElementsinRight == 0 ? 1L : 0L;\n+    return new SetImpl<>(rightCollection, exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the difference all (exceptAll)\n+   * with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection<T>}\n+   * (left) and n elements on in provided {@link PCollection<T>} (right): - it will output m\n+   * elements of left for all elements which are present in left but not in right. - it will output\n+   * MAX(m - n, 0) elements of left for all elements which are present in both left and right.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptAll(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> exceptAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> {\n+          if (numberOfElementsinLeft > 0 && numberOfElementsinRight == 0) {\n+            return numberOfElementsinLeft;\n+          } else if (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) {\n+            return Math.max(numberOfElementsinLeft - numberOfElementsinRight, 0L);", "originalCommit": "21e83eac027f28eae007a66d031d79c06f32a07b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU4NzY3Mw==", "url": "https://github.com/apache/beam/pull/11610#discussion_r420587673", "bodyText": "Thanks very valuable. I have fixed this.", "author": "darshanj", "createdAt": "2020-05-06T07:15:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxNTU4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxNTg4Nw==", "url": "https://github.com/apache/beam/pull/11610#discussion_r420415887", "bodyText": "For all of these, it'd be useful to document what the expected output is.", "author": "robertwb", "createdAt": "2020-05-05T21:25:27Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the intersection with provided\n+   * {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection<T>}.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersect(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> intersect(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImpl<>(rightCollection, intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the intersection all with\n+   * provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection<T>}\n+   * (left) and n elements on in provided {@link PCollection<T>} (right): - it will output MIN(m -\n+   * n, 0) elements of left for all elements which are present in both left and right.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectAll(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> intersectAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? Math.min(numberOfElementsinLeft, numberOfElementsinRight) : 0L;\n+    return new SetImpl<>(rightCollection, intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the difference (except) with\n+   * provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} will all distinct elements that present in\n+   * pipeline is constructed {@link PCollection<T>} but not present in provided {@link\n+   * PCollection<T>}.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.except(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> except(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> numberOfElementsinLeft > 0 && numberOfElementsinRight == 0 ? 1L : 0L;\n+    return new SetImpl<>(rightCollection, exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the difference all (exceptAll)\n+   * with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection<T>}\n+   * (left) and n elements on in provided {@link PCollection<T>} (right): - it will output m\n+   * elements of left for all elements which are present in left but not in right. - it will output\n+   * MAX(m - n, 0) elements of left for all elements which are present in both left and right.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptAll(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> exceptAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> {\n+          if (numberOfElementsinLeft > 0 && numberOfElementsinRight == 0) {\n+            return numberOfElementsinLeft;\n+          } else if (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) {\n+            return Math.max(numberOfElementsinLeft - numberOfElementsinRight, 0L);\n+          }\n+          return 0L;\n+        };\n+    return new SetImpl<>(rightCollection, exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the union with provided {@code\n+   * PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} will all distinct elements that present in\n+   * pipeline is constructed {@link PCollection<T>} and {@link PCollection<T>}.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.union(right));\n+   * }</pre>", "originalCommit": "21e83eac027f28eae007a66d031d79c06f32a07b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU4Nzc3MA==", "url": "https://github.com/apache/beam/pull/11610#discussion_r420587770", "bodyText": "Done.", "author": "darshanj", "createdAt": "2020-05-06T07:15:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxNTg4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxNjYwMw==", "url": "https://github.com/apache/beam/pull/11610#discussion_r420416603", "bodyText": "Isn't this just Flatten.pcollections? (Also, isn't that more efficient?)", "author": "robertwb", "createdAt": "2020-05-05T21:26:50Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the intersection with provided\n+   * {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection<T>}.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersect(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> intersect(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImpl<>(rightCollection, intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the intersection all with\n+   * provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection<T>}\n+   * (left) and n elements on in provided {@link PCollection<T>} (right): - it will output MIN(m -\n+   * n, 0) elements of left for all elements which are present in both left and right.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectAll(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> intersectAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? Math.min(numberOfElementsinLeft, numberOfElementsinRight) : 0L;\n+    return new SetImpl<>(rightCollection, intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the difference (except) with\n+   * provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} will all distinct elements that present in\n+   * pipeline is constructed {@link PCollection<T>} but not present in provided {@link\n+   * PCollection<T>}.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.except(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> except(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> numberOfElementsinLeft > 0 && numberOfElementsinRight == 0 ? 1L : 0L;\n+    return new SetImpl<>(rightCollection, exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the difference all (exceptAll)\n+   * with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection<T>}\n+   * (left) and n elements on in provided {@link PCollection<T>} (right): - it will output m\n+   * elements of left for all elements which are present in left but not in right. - it will output\n+   * MAX(m - n, 0) elements of left for all elements which are present in both left and right.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptAll(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> exceptAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> {\n+          if (numberOfElementsinLeft > 0 && numberOfElementsinRight == 0) {\n+            return numberOfElementsinLeft;\n+          } else if (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) {\n+            return Math.max(numberOfElementsinLeft - numberOfElementsinRight, 0L);\n+          }\n+          return 0L;\n+        };\n+    return new SetImpl<>(rightCollection, exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the union with provided {@code\n+   * PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} will all distinct elements that present in\n+   * pipeline is constructed {@link PCollection<T>} and {@link PCollection<T>}.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.union(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> union(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> unionFn = (numberOfElementsinLeft, numberOfElementsinRight) -> 1L;\n+    return new SetImpl<>(rightCollection, unionFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the unionAll with provided", "originalCommit": "21e83eac027f28eae007a66d031d79c06f32a07b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU4NzkwNw==", "url": "https://github.com/apache/beam/pull/11610#discussion_r420587907", "bodyText": "Thanks very valuable. I have fixed this.", "author": "darshanj", "createdAt": "2020-05-06T07:15:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxNjYwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxNzM4NA==", "url": "https://github.com/apache/beam/pull/11610#discussion_r420417384", "bodyText": "Though not as chain-able, a PTransform<PCollectionList<T>, PCollection<T>> feels more natural for many of these operations.", "author": "robertwb", "createdAt": "2020-05-05T21:28:29Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {", "originalCommit": "21e83eac027f28eae007a66d031d79c06f32a07b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU4OTI2MA==", "url": "https://github.com/apache/beam/pull/11610#discussion_r420589260", "bodyText": "I feel as you told it is not chain-able, keep it PTransform<PCollection<T>, PCollection<T>>. Most of the time which I encountered, you will have to use a different set operation followed by another operation. like union and then Intersect or so.", "author": "darshanj", "createdAt": "2020-05-06T07:19:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxNzM4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA4NzI2OA==", "url": "https://github.com/apache/beam/pull/11610#discussion_r421087268", "bodyText": "Depends on if we treat SET transforms as binary operation or a set operation. If it is binary, this PR's implementation makes sense (plus it is chain-able). If we consider it is set operation, then it should be PTransform<PCollectionList<T>, PCollection<T>> by the nature of a set.\nI personally lean to SET transforms here should work on set, like CoGroup. Also this PR is built on top of CoGroup already (which is PTransform<PCollectionList<T>, PCollection<T>).", "author": "amaliujia", "createdAt": "2020-05-06T20:57:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxNzM4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE4NTg2Ng==", "url": "https://github.com/apache/beam/pull/11610#discussion_r421185866", "bodyText": "Thanks. I understand the reasoning. My thinking was in lines similar like a Join implementation. As an end-user abstraction, isn't it would be more natural and straightforward to think left diff right which abstract that there is CoGrouping inside. This looks in my mind a natural usecase.\nOr will it be good idea to both variants PCollectionList<T> and PCollection<T> of API?", "author": "darshanj", "createdAt": "2020-05-07T01:27:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxNzM4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk0MDMyMQ==", "url": "https://github.com/apache/beam/pull/11610#discussion_r421940321", "bodyText": "Hi @amaliujia I tried to implement both APIs and it looks like following:\n\nBinary version: left.apply(\"strings\", SetFns.intersect(right))\nPCollectionList version: PCollectionList.of(set1).and(set1).and(set3).apply(\"stringsColls\", SetFns.intersect()) will return. (set1 intersection set2) intersection set3 results.\nPlease give your thoughts.", "author": "darshanj", "createdAt": "2020-05-08T05:06:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxNzM4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxODA4Nw==", "url": "https://github.com/apache/beam/pull/11610#discussion_r420418087", "bodyText": "I wonder if it's worth dropping at TODO here to lift combiners through the CoGBK.", "author": "robertwb", "createdAt": "2020-05-05T21:29:50Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the intersection with provided\n+   * {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection<T>}.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersect(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> intersect(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImpl<>(rightCollection, intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the intersection all with\n+   * provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection<T>}\n+   * (left) and n elements on in provided {@link PCollection<T>} (right): - it will output MIN(m -\n+   * n, 0) elements of left for all elements which are present in both left and right.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectAll(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> intersectAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? Math.min(numberOfElementsinLeft, numberOfElementsinRight) : 0L;\n+    return new SetImpl<>(rightCollection, intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the difference (except) with\n+   * provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} will all distinct elements that present in\n+   * pipeline is constructed {@link PCollection<T>} but not present in provided {@link\n+   * PCollection<T>}.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.except(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> except(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> numberOfElementsinLeft > 0 && numberOfElementsinRight == 0 ? 1L : 0L;\n+    return new SetImpl<>(rightCollection, exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the difference all (exceptAll)\n+   * with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection<T>}\n+   * (left) and n elements on in provided {@link PCollection<T>} (right): - it will output m\n+   * elements of left for all elements which are present in left but not in right. - it will output\n+   * MAX(m - n, 0) elements of left for all elements which are present in both left and right.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptAll(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> exceptAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> {\n+          if (numberOfElementsinLeft > 0 && numberOfElementsinRight == 0) {\n+            return numberOfElementsinLeft;\n+          } else if (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) {\n+            return Math.max(numberOfElementsinLeft - numberOfElementsinRight, 0L);\n+          }\n+          return 0L;\n+        };\n+    return new SetImpl<>(rightCollection, exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the union with provided {@code\n+   * PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} will all distinct elements that present in\n+   * pipeline is constructed {@link PCollection<T>} and {@link PCollection<T>}.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.union(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> union(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> unionFn = (numberOfElementsinLeft, numberOfElementsinRight) -> 1L;\n+    return new SetImpl<>(rightCollection, unionFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code SetFns.SetImpl<T>} transform that compute the unionAll with provided\n+   * {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection<T>} which will follow UNION_ALL semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection<T>}\n+   * (left) and n elements on in provided {@link PCollection<T>} (right): - it will output m\n+   * elements of left and m elements of right.\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.unionAll(right));\n+   * }</pre>\n+   */\n+  public static <T> SetImpl<T> unionAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    SerializableBiFunction<Long, Long, Long> unionFn = Long::sum;\n+    return new SetImpl<>(rightCollection, unionFn);\n+  }\n+\n+  private static <T> PCollection<T> performSetOperation(\n+      PCollection<T> leftCollection,\n+      PCollection<T> rightCollection,\n+      SerializableBiFunction<Long, Long, Long> fn) {\n+\n+    TupleTag<Void> leftCollectionTag = new TupleTag<>();\n+    TupleTag<Void> rightCollectionTag = new TupleTag<>();\n+\n+    MapElements<T, KV<T, Void>> elementToVoid =\n+        MapElements.via(\n+            new SimpleFunction<T, KV<T, Void>>() {\n+              @Override\n+              public KV<T, Void> apply(T element) {\n+                return KV.of(element, null);\n+              }\n+            });\n+\n+    PCollection<KV<T, Void>> left = leftCollection.apply(\"PrepareLeftKV\", elementToVoid);\n+    PCollection<KV<T, Void>> right = rightCollection.apply(\"PrepareRightKV\", elementToVoid);\n+\n+    PCollection<KV<T, CoGbkResult>> coGbkResults =\n+        KeyedPCollectionTuple.of(leftCollectionTag, left)\n+            .and(rightCollectionTag, right)\n+            .apply(CoGroupByKey.create());\n+\n+    return coGbkResults.apply(\n+        ParDo.of(\n+            new DoFn<KV<T, CoGbkResult>, T>() {\n+\n+              @ProcessElement\n+              public void processElement(ProcessContext c) {\n+                KV<T, CoGbkResult> elementGroups = c.element();\n+\n+                CoGbkResult value = elementGroups.getValue();", "originalCommit": "21e83eac027f28eae007a66d031d79c06f32a07b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDU5MDE3Nw==", "url": "https://github.com/apache/beam/pull/11610#discussion_r420590177", "bodyText": "Thanks. I have put a comment. can you clarify please? You mean use CoGbk.compose? If possible I would implement it instead of TODO if is not much of an effort.", "author": "darshanj", "createdAt": "2020-05-06T07:21:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxODA4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2NTIyNA==", "url": "https://github.com/apache/beam/pull/11610#discussion_r422465224", "bodyText": "@robertwb : Do we need this comment? I do not understand what is purpose of this TODO quiet well.", "author": "darshanj", "createdAt": "2020-05-09T07:43:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQxODA4Nw=="}], "type": "inlineReview"}, {"oid": "6d96c3db06686ef543b8551b728676db190ec03d", "url": "https://github.com/apache/beam/commit/6d96c3db06686ef543b8551b728676db190ec03d", "message": "[BEAM-9825] | fix style checks", "committedDate": "2020-05-06T05:42:07Z", "type": "commit"}, {"oid": "55d3fb12097fd76709b8a811dad4c8405c023008", "url": "https://github.com/apache/beam/commit/55d3fb12097fd76709b8a811dad4c8405c023008", "message": "[BEAM-9825] | simplify conditions, output in examples", "committedDate": "2020-05-06T07:04:28Z", "type": "commit"}, {"oid": "c4413b71a921016430893005b401d427d094f37e", "url": "https://github.com/apache/beam/commit/c4413b71a921016430893005b401d427d094f37e", "message": "[BEAM-9825] | use flatten.pcollections for unionall", "committedDate": "2020-05-06T07:23:08Z", "type": "commit"}, {"oid": "a41ad545c1b48762c24adde2cedfa7264d4229b6", "url": "https://github.com/apache/beam/commit/a41ad545c1b48762c24adde2cedfa7264d4229b6", "message": "[BEAM-9825] | rename union to unionDistinct", "committedDate": "2020-05-08T04:10:53Z", "type": "commit"}, {"oid": "56e0d63bfac4998258b6d4bc73abfd1dde435dd4", "url": "https://github.com/apache/beam/commit/56e0d63bfac4998258b6d4bc73abfd1dde435dd4", "message": "[BEAM-9825] | both apis -WIP", "committedDate": "2020-05-08T14:49:16Z", "type": "commit"}, {"oid": "be1d37c74d34fa01228f0bc791c2d42c634668c3", "url": "https://github.com/apache/beam/commit/be1d37c74d34fa01228f0bc791c2d42c634668c3", "message": "[BEAM-9825] | fix spotbugs", "committedDate": "2020-05-08T16:22:55Z", "type": "commit"}, {"oid": "7202a8387baeefd4def3052b27c219f75531d420", "url": "https://github.com/apache/beam/commit/7202a8387baeefd4def3052b27c219f75531d420", "message": "[BEAM-9825] | add comments", "committedDate": "2020-05-08T17:02:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNjMzMg==", "url": "https://github.com/apache/beam/pull/11610#discussion_r422406332", "bodyText": "It'd be better to implement the binary operations in terms of n-ary operations, so that one only need to so a single [Co]GBK. The operations are the same (e.g. union -> sum or 1, intersection = min or max(min(...), 1) for all/distinct variants respectively.", "author": "robertwb", "createdAt": "2020-05-08T22:36:19Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -187,83 +237,112 @@\n    *     left.apply(SetFns.unionAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"1\",\"2\",\"3\",\"4\",\"4\"\n    * }</pre>\n    */\n-  public static <T> SetUnionAllImpl<T> unionAll(PCollection<T> rightCollection) {\n+  public static <T> SetImpl<T> unionAll(PCollection<T> rightCollection) {\n     checkNotNull(rightCollection, \"rightCollection argument is null\");\n-\n-    return new SetUnionAllImpl<T>(rightCollection);\n+    return new SetImpl<>(rightCollection, unionAll());\n   }\n \n-  private static <T> PCollection<T> performSetOperation(\n-      PCollection<T> leftCollection,\n-      PCollection<T> rightCollection,\n-      SerializableBiFunction<Long, Long, Long> fn) {\n-\n-    TupleTag<Void> leftCollectionTag = new TupleTag<>();\n-    TupleTag<Void> rightCollectionTag = new TupleTag<>();\n-\n-    MapElements<T, KV<T, Void>> elementToVoid =\n-        MapElements.via(\n-            new SimpleFunction<T, KV<T, Void>>() {\n-              @Override\n-              public KV<T, Void> apply(T element) {\n-                return KV.of(element, null);\n-              }\n-            });\n-\n-    PCollection<KV<T, Void>> left = leftCollection.apply(\"PrepareLeftKV\", elementToVoid);\n-    PCollection<KV<T, Void>> right = rightCollection.apply(\"PrepareRightKV\", elementToVoid);\n-\n-    PCollection<KV<T, CoGbkResult>> coGbkResults =\n-        KeyedPCollectionTuple.of(leftCollectionTag, left)\n-            .and(rightCollectionTag, right)\n-            .apply(CoGroupByKey.create());\n-    // TODO: lift combiners through the CoGBK.\n-    return coGbkResults.apply(\n-        ParDo.of(\n-            new DoFn<KV<T, CoGbkResult>, T>() {\n-\n-              @ProcessElement\n-              public void processElement(ProcessContext c) {\n-                KV<T, CoGbkResult> elementGroups = c.element();\n-\n-                CoGbkResult value = elementGroups.getValue();\n-                long inFirstSize = Iterables.size(value.getAll(leftCollectionTag));\n-                long inSecondSize = Iterables.size(value.getAll(rightCollectionTag));\n-\n-                T element = elementGroups.getKey();\n-                for (long i = 0L; i < fn.apply(inFirstSize, inSecondSize); i++) {\n-                  c.output(element);\n-                }\n-              }\n-            }));\n+  public static <T> Flatten.PCollections<T> unionAll() {\n+    return Flatten.pCollections();\n   }\n \n   public static class SetImpl<T> extends PTransform<PCollection<T>, PCollection<T>> {\n-    private final PCollection<T> rightCollection;\n-    private final SerializableBiFunction<Long, Long, Long> fn;\n \n-    private SetImpl(PCollection<T> rightCollection, SerializableBiFunction<Long, Long, Long> fn) {\n-      this.rightCollection = rightCollection;\n-      this.fn = fn;\n+    private final transient PCollection<T> right;\n+    private final PTransform<PCollectionList<T>, PCollection<T>> listTransformFn;\n+\n+    private SetImpl(\n+        PCollection<T> rightCollection,\n+        PTransform<PCollectionList<T>, PCollection<T>> listTransformFn) {\n+      this.right = rightCollection;\n+      this.listTransformFn = listTransformFn;\n     }\n \n     @Override\n     public PCollection<T> expand(PCollection<T> leftCollection) {\n-      return performSetOperation(leftCollection, rightCollection, fn)\n-          .setCoder(leftCollection.getCoder());\n+      return PCollectionList.of(leftCollection).and(right).apply(listTransformFn);\n     }\n   }\n \n-  public static class SetUnionAllImpl<T> extends PTransform<PCollection<T>, PCollection<T>> {\n-    private final PCollection<T> rightCollection;\n+  public static class SetImplCollections<T> extends PTransform<PCollectionList<T>, PCollection<T>> {\n+\n+    private final transient SerializableBiFunction<Long, Long, Long> fn;\n+\n+    private SetImplCollections(SerializableBiFunction<Long, Long, Long> fn) {\n+      this.fn = fn;\n+    }\n+\n+    private static <T> PCollection<T> performSetOperationCollectionList(\n+            PCollectionList<T> inputs, SerializableBiFunction<Long, Long, Long> fn) {\n+      List<PCollection<T>> all = inputs.getAll();\n+      int size = all.size();\n+      if (size == 1) {\n+        return inputs.get(0); // Handle only one PCollection in list. Coder is already specified\n+      } else {\n+        PCollection<T> accum = inputs.get(0);\n+        List<PCollection<T>> tail = all.subList(1, size);\n \n-    private SetUnionAllImpl(PCollection<T> rightCollection) {\n-      this.rightCollection = rightCollection;\n+        for (PCollection<T> second : tail) {\n+          accum = performSetOperation(accum, second, fn);", "originalCommit": "56e0d63bfac4998258b6d4bc73abfd1dde435dd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2NDg5MA==", "url": "https://github.com/apache/beam/pull/11610#discussion_r422464890", "bodyText": "Thanks. Thats very good idea. I have done it.", "author": "darshanj", "createdAt": "2020-05-09T07:39:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNjMzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ2NTI5MA==", "url": "https://github.com/apache/beam/pull/11610#discussion_r422465290", "bodyText": "renamed all methods with explicit Distinct and All as suffix", "author": "darshanj", "createdAt": "2020-05-09T07:44:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNjMzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNjM4NA==", "url": "https://github.com/apache/beam/pull/11610#discussion_r422406384", "bodyText": "This is only true for the all variants, right?", "author": "robertwb", "createdAt": "2020-05-08T22:36:32Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -187,83 +237,112 @@\n    *     left.apply(SetFns.unionAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"1\",\"2\",\"3\",\"4\",\"4\"\n    * }</pre>\n    */\n-  public static <T> SetUnionAllImpl<T> unionAll(PCollection<T> rightCollection) {\n+  public static <T> SetImpl<T> unionAll(PCollection<T> rightCollection) {\n     checkNotNull(rightCollection, \"rightCollection argument is null\");\n-\n-    return new SetUnionAllImpl<T>(rightCollection);\n+    return new SetImpl<>(rightCollection, unionAll());\n   }\n \n-  private static <T> PCollection<T> performSetOperation(\n-      PCollection<T> leftCollection,\n-      PCollection<T> rightCollection,\n-      SerializableBiFunction<Long, Long, Long> fn) {\n-\n-    TupleTag<Void> leftCollectionTag = new TupleTag<>();\n-    TupleTag<Void> rightCollectionTag = new TupleTag<>();\n-\n-    MapElements<T, KV<T, Void>> elementToVoid =\n-        MapElements.via(\n-            new SimpleFunction<T, KV<T, Void>>() {\n-              @Override\n-              public KV<T, Void> apply(T element) {\n-                return KV.of(element, null);\n-              }\n-            });\n-\n-    PCollection<KV<T, Void>> left = leftCollection.apply(\"PrepareLeftKV\", elementToVoid);\n-    PCollection<KV<T, Void>> right = rightCollection.apply(\"PrepareRightKV\", elementToVoid);\n-\n-    PCollection<KV<T, CoGbkResult>> coGbkResults =\n-        KeyedPCollectionTuple.of(leftCollectionTag, left)\n-            .and(rightCollectionTag, right)\n-            .apply(CoGroupByKey.create());\n-    // TODO: lift combiners through the CoGBK.\n-    return coGbkResults.apply(\n-        ParDo.of(\n-            new DoFn<KV<T, CoGbkResult>, T>() {\n-\n-              @ProcessElement\n-              public void processElement(ProcessContext c) {\n-                KV<T, CoGbkResult> elementGroups = c.element();\n-\n-                CoGbkResult value = elementGroups.getValue();\n-                long inFirstSize = Iterables.size(value.getAll(leftCollectionTag));\n-                long inSecondSize = Iterables.size(value.getAll(rightCollectionTag));\n-\n-                T element = elementGroups.getKey();\n-                for (long i = 0L; i < fn.apply(inFirstSize, inSecondSize); i++) {\n-                  c.output(element);\n-                }\n-              }\n-            }));\n+  public static <T> Flatten.PCollections<T> unionAll() {\n+    return Flatten.pCollections();\n   }\n \n   public static class SetImpl<T> extends PTransform<PCollection<T>, PCollection<T>> {\n-    private final PCollection<T> rightCollection;\n-    private final SerializableBiFunction<Long, Long, Long> fn;\n \n-    private SetImpl(PCollection<T> rightCollection, SerializableBiFunction<Long, Long, Long> fn) {\n-      this.rightCollection = rightCollection;\n-      this.fn = fn;\n+    private final transient PCollection<T> right;\n+    private final PTransform<PCollectionList<T>, PCollection<T>> listTransformFn;\n+\n+    private SetImpl(\n+        PCollection<T> rightCollection,\n+        PTransform<PCollectionList<T>, PCollection<T>> listTransformFn) {\n+      this.right = rightCollection;\n+      this.listTransformFn = listTransformFn;\n     }\n \n     @Override\n     public PCollection<T> expand(PCollection<T> leftCollection) {\n-      return performSetOperation(leftCollection, rightCollection, fn)\n-          .setCoder(leftCollection.getCoder());\n+      return PCollectionList.of(leftCollection).and(right).apply(listTransformFn);\n     }\n   }\n \n-  public static class SetUnionAllImpl<T> extends PTransform<PCollection<T>, PCollection<T>> {\n-    private final PCollection<T> rightCollection;\n+  public static class SetImplCollections<T> extends PTransform<PCollectionList<T>, PCollection<T>> {\n+\n+    private final transient SerializableBiFunction<Long, Long, Long> fn;\n+\n+    private SetImplCollections(SerializableBiFunction<Long, Long, Long> fn) {\n+      this.fn = fn;\n+    }\n+\n+    private static <T> PCollection<T> performSetOperationCollectionList(\n+            PCollectionList<T> inputs, SerializableBiFunction<Long, Long, Long> fn) {\n+      List<PCollection<T>> all = inputs.getAll();\n+      int size = all.size();\n+      if (size == 1) {\n+        return inputs.get(0); // Handle only one PCollection in list. Coder is already specified", "originalCommit": "56e0d63bfac4998258b6d4bc73abfd1dde435dd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwNDgxOA==", "url": "https://github.com/apache/beam/pull/11610#discussion_r422504818", "bodyText": "I have removed this check now.", "author": "darshanj", "createdAt": "2020-05-09T14:54:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNjM4NA=="}], "type": "inlineReview"}, {"oid": "3f9ed6fcd6fa1d07199aa02cba941f75a46bf7d3", "url": "https://github.com/apache/beam/commit/3f9ed6fcd6fa1d07199aa02cba941f75a46bf7d3", "message": "[BEAM-9825] | use only one CBK,rename methods", "committedDate": "2020-05-09T07:37:38Z", "type": "commit"}, {"oid": "50042831557075d2287d033fba8ab0f94625a469", "url": "https://github.com/apache/beam/commit/50042831557075d2287d033fba8ab0f94625a469", "message": "[BEAM-9825] | inline method", "committedDate": "2020-05-09T07:45:50Z", "type": "commit"}, {"oid": "b0f23e450f94756ad3a4052ff675f8f9d212b033", "url": "https://github.com/apache/beam/commit/b0f23e450f94756ad3a4052ff675f8f9d212b033", "message": "[BEAM-9825] | added remaining tests", "committedDate": "2020-05-09T12:00:41Z", "type": "commit"}, {"oid": "1c608a0b2445f6656ae755f54ce517b365c3cda5", "url": "https://github.com/apache/beam/commit/1c608a0b2445f6656ae755f54ce517b365c3cda5", "message": "[BEAM-9825] | remove size check", "committedDate": "2020-05-09T14:53:35Z", "type": "commit"}, {"oid": "98951f47f43951286706ef22938b94376cf61065", "url": "https://github.com/apache/beam/commit/98951f47f43951286706ef22938b94376cf61065", "message": "[BEAM-9825] | corrected some comments", "committedDate": "2020-05-09T15:31:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQzMjEzNQ==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425432135", "bodyText": "We should mention in the comments that we rely on the deterministic encoding of the coder similar to how we do GroupByKey.\nAlso, this implementation assumes that there will only be a single firing of the trigger. If there are multiple then the results are likely undefined.", "author": "lukecwik", "createdAt": "2020-05-14T21:09:36Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,528 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {", "originalCommit": "98951f47f43951286706ef22938b94376cf61065", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUyOTUzNA==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425529534", "bodyText": "Added Comments for coders.\nRegarding triggers, I assume, multiple triggers should work if they are compatible.\nIt uses CGBK (internally uses flattens) , which checks if triggers compatible and windowFns are compatible. User will get results based on whatever data is triggered.\nMy understanding may be flawed. Please correct if you think that is not the case.\nI have added a comment for compatible triggers and same windowFns.", "author": "darshanj", "createdAt": "2020-05-15T02:19:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQzMjEzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0Nzk3OA==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425547978", "bodyText": "Your understanding is correct that users will get results based upon whatever data is fired because of the trigger but from a cursory reading of the docs, we mention doing intersect/distinct/... over PCollections and not trigger firings which could confuse a user into thinking that intersect/distinct will be over all elements in these PCollections.\nThis is why I believe it's important to insert a statement something like:\nTriggers with multiple firings may lead to nondeterministic results since the intersect/distinct/... is only computed over each individual firing.\n\nThis would go well with your current statement about having compatible triggers in all your methods.", "author": "lukecwik", "createdAt": "2020-05-15T03:36:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQzMjEzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1MDk0MA==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425550940", "bodyText": "Thanks. I was thinking to add \"If you have multiple triggers configured and fired, output of\nthis transform will be calculated on data which is in the respective trigger.\"", "author": "darshanj", "createdAt": "2020-05-15T03:49:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQzMjEzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY4OTg4NQ==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425689885", "bodyText": "Thanks.Done", "author": "darshanj", "createdAt": "2020-05-15T09:46:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQzMjEzNQ=="}], "type": "inlineReview"}, {"oid": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5", "url": "https://github.com/apache/beam/commit/b3b28ba1890b84c7b377f8686666c7e0a9aafdb5", "message": "[BEAM-9825] | some comments, added size > 0 check", "committedDate": "2020-05-15T02:19:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODE3Mw==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425548173", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Coder} that of {@code PCollection<T>}\n          \n          \n            \n               * Coder} as that of the input {@code PCollection<T>}.", "author": "lukecwik", "createdAt": "2020-05-15T03:37:23Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}", "originalCommit": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY4OTc5Nw==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425689797", "bodyText": "Thanks.Done", "author": "darshanj", "createdAt": "2020-05-15T09:46:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODE3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODMxOA==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425548318", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Coder} that of first in {@code PCollectionList<T>}\n          \n          \n            \n               * Coder} as that of the first {@code PCollection<T>} in {@code PCollectionList<T>}.", "author": "lukecwik", "createdAt": "2020-05-15T03:38:05Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectDistinct(right)); // results will be PCollection<String> containing: \"1\",\"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing intersection of collections done in order for all collections\n+   * in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * intersection of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in both pipeline is constructed and next {@link PCollection} in the list and applied to\n+   * all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}", "originalCommit": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY4OTcyOQ==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425689729", "bodyText": "Thanks.Done", "author": "darshanj", "createdAt": "2020-05-15T09:46:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODMxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODM0MQ==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425548341", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n          \n          \n            \n               * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing the", "author": "lukecwik", "createdAt": "2020-05-15T03:38:12Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectDistinct(right)); // results will be PCollection<String> containing: \"1\",\"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing intersection of collections done in order for all collections\n+   * in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing", "originalCommit": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY4OTYzMw==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425689633", "bodyText": "Thanks.Done", "author": "darshanj", "createdAt": "2020-05-15T09:46:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODM0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODU4Nw==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425548587", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Coder} that of first in {@code PCollectionList<T>}\n          \n          \n            \n               * Coder} as that of the first {@code PCollection<T>} in {@code PCollectionList<T>}.", "author": "lukecwik", "createdAt": "2020-05-15T03:39:34Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectDistinct(right)); // results will be PCollection<String> containing: \"1\",\"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing intersection of collections done in order for all collections\n+   * in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * intersection of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in both pipeline is constructed and next {@link PCollection} in the list and applied to\n+   * all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> first = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"3\", \"4\",\"4\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectDistinct()); // results will be PCollection<String> containing: \"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectDistinct() {\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImplCollections<>(intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTESECT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output MIN(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"3\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing intersection\n+   * all of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTERSECT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output MIN(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}", "originalCommit": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY4OTU2MQ==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425689561", "bodyText": "Thanks.Done", "author": "darshanj", "createdAt": "2020-05-15T09:46:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODU4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODY1Mw==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425548653", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Coder} that of first in {@code PCollectionList<T>}\n          \n          \n            \n               * Coder} as that of the first {@code PCollection<T>} in {@code PCollectionList<T>}.", "author": "lukecwik", "createdAt": "2020-05-15T03:39:54Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectDistinct(right)); // results will be PCollection<String> containing: \"1\",\"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing intersection of collections done in order for all collections\n+   * in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * intersection of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in both pipeline is constructed and next {@link PCollection} in the list and applied to\n+   * all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> first = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"3\", \"4\",\"4\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectDistinct()); // results will be PCollection<String> containing: \"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectDistinct() {\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImplCollections<>(intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTESECT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output MIN(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"3\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing intersection\n+   * all of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTERSECT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output MIN(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectAll()); // results will be PCollection<String> containing: \"1\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectAll() {\n+    return new SetImplCollections<>(Math::min);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * difference (except) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * pipeline is constructed but not present in provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptDistinct(right)); // results will be PCollection<String> containing: \"2\",\"5\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> exceptDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, exceptDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing difference (except) of collections done in order for all\n+   * collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * difference (except) of collections done in order for all collections in {@code\n+   * PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in pipeline is constructed but not present in next {@link PCollection} in the list and\n+   * applied to all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}", "originalCommit": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY4OTUwOA==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425689508", "bodyText": "Thanks.Done", "author": "darshanj", "createdAt": "2020-05-15T09:46:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODY1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODgzNw==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425548837", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Coder} that of {@code PCollection<T>}\n          \n          \n            \n               * Coder} as that of the input {@code PCollection<T>}.", "author": "lukecwik", "createdAt": "2020-05-15T03:40:41Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectDistinct(right)); // results will be PCollection<String> containing: \"1\",\"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing intersection of collections done in order for all collections\n+   * in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * intersection of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in both pipeline is constructed and next {@link PCollection} in the list and applied to\n+   * all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> first = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"3\", \"4\",\"4\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectDistinct()); // results will be PCollection<String> containing: \"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectDistinct() {\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImplCollections<>(intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTESECT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output MIN(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}", "originalCommit": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODg3Mw==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425548873", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Coder} that of {@code PCollection<T>}\n          \n          \n            \n               * Coder} as that of the input {@code PCollection<T>}.", "author": "lukecwik", "createdAt": "2020-05-15T03:40:53Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectDistinct(right)); // results will be PCollection<String> containing: \"1\",\"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing intersection of collections done in order for all collections\n+   * in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * intersection of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in both pipeline is constructed and next {@link PCollection} in the list and applied to\n+   * all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> first = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"3\", \"4\",\"4\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectDistinct()); // results will be PCollection<String> containing: \"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectDistinct() {\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImplCollections<>(intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTESECT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output MIN(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"3\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing intersection\n+   * all of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTERSECT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output MIN(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectAll()); // results will be PCollection<String> containing: \"1\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectAll() {\n+    return new SetImplCollections<>(Math::min);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * difference (except) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * pipeline is constructed but not present in provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}", "originalCommit": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODkxNQ==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425548915", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Coder} that of {@code PCollection<T>}\n          \n          \n            \n               * Coder} as that of the input {@code PCollection<T>}.", "author": "lukecwik", "createdAt": "2020-05-15T03:41:05Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectDistinct(right)); // results will be PCollection<String> containing: \"1\",\"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing intersection of collections done in order for all collections\n+   * in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * intersection of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in both pipeline is constructed and next {@link PCollection} in the list and applied to\n+   * all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> first = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"3\", \"4\",\"4\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectDistinct()); // results will be PCollection<String> containing: \"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectDistinct() {\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImplCollections<>(intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTESECT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output MIN(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"3\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing intersection\n+   * all of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTERSECT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output MIN(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectAll()); // results will be PCollection<String> containing: \"1\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectAll() {\n+    return new SetImplCollections<>(Math::min);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * difference (except) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * pipeline is constructed but not present in provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptDistinct(right)); // results will be PCollection<String> containing: \"2\",\"5\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> exceptDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, exceptDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing difference (except) of collections done in order for all\n+   * collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * difference (except) of collections done in order for all collections in {@code\n+   * PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in pipeline is constructed but not present in next {@link PCollection} in the list and\n+   * applied to all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"2\",\"2\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.exceptDistinct()); // results will be PCollection<String> containing: \"5\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> exceptDistinct() {\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            numberOfElementsinLeft > 0 && numberOfElementsinRight == 0 ? 1L : 0L;\n+    return new SetImplCollections<>(exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * difference all (exceptAll) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output m elements of left\n+   * for all elements which are present in left but not in right. - it will output MAX(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}", "originalCommit": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODk1Mw==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425548953", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Coder} that of {@code PCollection<T>}\n          \n          \n            \n               * Coder} as that of the input {@code PCollection<T>}.", "author": "lukecwik", "createdAt": "2020-05-15T03:41:18Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectDistinct(right)); // results will be PCollection<String> containing: \"1\",\"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing intersection of collections done in order for all collections\n+   * in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * intersection of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in both pipeline is constructed and next {@link PCollection} in the list and applied to\n+   * all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> first = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"3\", \"4\",\"4\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectDistinct()); // results will be PCollection<String> containing: \"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectDistinct() {\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImplCollections<>(intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTESECT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output MIN(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"3\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing intersection\n+   * all of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTERSECT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output MIN(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectAll()); // results will be PCollection<String> containing: \"1\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectAll() {\n+    return new SetImplCollections<>(Math::min);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * difference (except) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * pipeline is constructed but not present in provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptDistinct(right)); // results will be PCollection<String> containing: \"2\",\"5\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> exceptDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, exceptDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing difference (except) of collections done in order for all\n+   * collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * difference (except) of collections done in order for all collections in {@code\n+   * PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in pipeline is constructed but not present in next {@link PCollection} in the list and\n+   * applied to all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"2\",\"2\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.exceptDistinct()); // results will be PCollection<String> containing: \"5\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> exceptDistinct() {\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            numberOfElementsinLeft > 0 && numberOfElementsinRight == 0 ? 1L : 0L;\n+    return new SetImplCollections<>(exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * difference all (exceptAll) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output m elements of left\n+   * for all elements which are present in left but not in right. - it will output MAX(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"2\",\"3\",\"3\",\"5\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> exceptAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, exceptAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing difference all\n+   * (exceptAll) of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow EXCEPT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output m elements of left for all elements which are present in left but not in right. - it\n+   * will output MAX(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.exceptAll()); // results will be PCollection<String> containing: \"1\",\"2\",\"3\",\"3\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> exceptAll() {\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            Math.max(numberOfElementsinLeft - numberOfElementsinRight, 0L);\n+    return new SetImplCollections<>(exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * union with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * pipeline is constructed or present in provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}", "originalCommit": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0ODk4NQ==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425548985", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Coder} that of {@code PCollection<T>}\n          \n          \n            \n               * Coder} as that of the input {@code PCollection<T>}.", "author": "lukecwik", "createdAt": "2020-05-15T03:41:31Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectDistinct(right)); // results will be PCollection<String> containing: \"1\",\"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing intersection of collections done in order for all collections\n+   * in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * intersection of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in both pipeline is constructed and next {@link PCollection} in the list and applied to\n+   * all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> first = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"3\", \"4\",\"4\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectDistinct()); // results will be PCollection<String> containing: \"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectDistinct() {\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImplCollections<>(intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTESECT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output MIN(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"3\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing intersection\n+   * all of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTERSECT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output MIN(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectAll()); // results will be PCollection<String> containing: \"1\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectAll() {\n+    return new SetImplCollections<>(Math::min);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * difference (except) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * pipeline is constructed but not present in provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptDistinct(right)); // results will be PCollection<String> containing: \"2\",\"5\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> exceptDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, exceptDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing difference (except) of collections done in order for all\n+   * collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * difference (except) of collections done in order for all collections in {@code\n+   * PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in pipeline is constructed but not present in next {@link PCollection} in the list and\n+   * applied to all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"2\",\"2\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.exceptDistinct()); // results will be PCollection<String> containing: \"5\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> exceptDistinct() {\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            numberOfElementsinLeft > 0 && numberOfElementsinRight == 0 ? 1L : 0L;\n+    return new SetImplCollections<>(exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * difference all (exceptAll) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output m elements of left\n+   * for all elements which are present in left but not in right. - it will output MAX(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"2\",\"3\",\"3\",\"5\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> exceptAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, exceptAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing difference all\n+   * (exceptAll) of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow EXCEPT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output m elements of left for all elements which are present in left but not in right. - it\n+   * will output MAX(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.exceptAll()); // results will be PCollection<String> containing: \"1\",\"2\",\"3\",\"3\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> exceptAll() {\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            Math.max(numberOfElementsinLeft - numberOfElementsinRight, 0L);\n+    return new SetImplCollections<>(exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * union with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * pipeline is constructed or present in provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"2\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.unionDistinct(right)); // results will be PCollection<String> containing: \"1\",\"2\",\"3\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> unionDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, unionDistinct());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing union\n+   * of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in pipeline is constructed or present in next {@link PCollection} in the list and\n+   * applied to all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"2\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\"));\n+   *\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.unionDistinct()); // results will be PCollection<String> containing: \"1\",\"2\",\"3\",\"4\",\"5\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> unionDistinct() {\n+    SerializableBiFunction<Long, Long, Long> unionFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> 1L;\n+    return new SetImplCollections<>(unionFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * unionAll with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow UNION_ALL semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output m elements of left\n+   * and m elements of right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}", "originalCommit": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0OTI1NA==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425549254", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Coder} that of first in {@code PCollectionList<T>}\n          \n          \n            \n               * Coder} as that of the first {@code PCollection<T>} in {@code PCollectionList<T>}.", "author": "lukecwik", "createdAt": "2020-05-15T03:42:32Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectDistinct(right)); // results will be PCollection<String> containing: \"1\",\"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing intersection of collections done in order for all collections\n+   * in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * intersection of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in both pipeline is constructed and next {@link PCollection} in the list and applied to\n+   * all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> first = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"3\", \"4\",\"4\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectDistinct()); // results will be PCollection<String> containing: \"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectDistinct() {\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImplCollections<>(intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTESECT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output MIN(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"3\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing intersection\n+   * all of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTERSECT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output MIN(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectAll()); // results will be PCollection<String> containing: \"1\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectAll() {\n+    return new SetImplCollections<>(Math::min);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * difference (except) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * pipeline is constructed but not present in provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptDistinct(right)); // results will be PCollection<String> containing: \"2\",\"5\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> exceptDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, exceptDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing difference (except) of collections done in order for all\n+   * collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * difference (except) of collections done in order for all collections in {@code\n+   * PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in pipeline is constructed but not present in next {@link PCollection} in the list and\n+   * applied to all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"2\",\"2\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.exceptDistinct()); // results will be PCollection<String> containing: \"5\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> exceptDistinct() {\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            numberOfElementsinLeft > 0 && numberOfElementsinRight == 0 ? 1L : 0L;\n+    return new SetImplCollections<>(exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * difference all (exceptAll) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output m elements of left\n+   * for all elements which are present in left but not in right. - it will output MAX(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"2\",\"3\",\"3\",\"5\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> exceptAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, exceptAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing difference all\n+   * (exceptAll) of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow EXCEPT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output m elements of left for all elements which are present in left but not in right. - it\n+   * will output MAX(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}", "originalCommit": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0OTMxNg==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425549316", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Coder} that of first in {@code PCollectionList<T>}\n          \n          \n            \n               * Coder} as that of the first {@code PCollection<T>} in {@code PCollectionList<T>}.", "author": "lukecwik", "createdAt": "2020-05-15T03:42:44Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectDistinct(right)); // results will be PCollection<String> containing: \"1\",\"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing intersection of collections done in order for all collections\n+   * in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * intersection of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in both pipeline is constructed and next {@link PCollection} in the list and applied to\n+   * all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> first = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"3\", \"4\",\"4\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectDistinct()); // results will be PCollection<String> containing: \"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectDistinct() {\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImplCollections<>(intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTESECT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output MIN(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"3\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing intersection\n+   * all of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTERSECT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output MIN(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectAll()); // results will be PCollection<String> containing: \"1\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectAll() {\n+    return new SetImplCollections<>(Math::min);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * difference (except) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * pipeline is constructed but not present in provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptDistinct(right)); // results will be PCollection<String> containing: \"2\",\"5\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> exceptDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, exceptDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing difference (except) of collections done in order for all\n+   * collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * difference (except) of collections done in order for all collections in {@code\n+   * PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in pipeline is constructed but not present in next {@link PCollection} in the list and\n+   * applied to all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"2\",\"2\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.exceptDistinct()); // results will be PCollection<String> containing: \"5\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> exceptDistinct() {\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            numberOfElementsinLeft > 0 && numberOfElementsinRight == 0 ? 1L : 0L;\n+    return new SetImplCollections<>(exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * difference all (exceptAll) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output m elements of left\n+   * for all elements which are present in left but not in right. - it will output MAX(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"2\",\"3\",\"3\",\"5\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> exceptAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, exceptAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing difference all\n+   * (exceptAll) of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow EXCEPT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output m elements of left for all elements which are present in left but not in right. - it\n+   * will output MAX(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.exceptAll()); // results will be PCollection<String> containing: \"1\",\"2\",\"3\",\"3\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> exceptAll() {\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            Math.max(numberOfElementsinLeft - numberOfElementsinRight, 0L);\n+    return new SetImplCollections<>(exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * union with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * pipeline is constructed or present in provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"2\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.unionDistinct(right)); // results will be PCollection<String> containing: \"1\",\"2\",\"3\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> unionDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, unionDistinct());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing union\n+   * of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in pipeline is constructed or present in next {@link PCollection} in the list and\n+   * applied to all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}", "originalCommit": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU0OTQwNg==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425549406", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Coder} that of first in {@code PCollectionList<T>}\n          \n          \n            \n               * Coder} as that of the first {@code PCollection<T>} in {@code PCollectionList<T>}.", "author": "lukecwik", "createdAt": "2020-05-15T03:42:56Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectDistinct(right)); // results will be PCollection<String> containing: \"1\",\"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing intersection of collections done in order for all collections\n+   * in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * intersection of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in both pipeline is constructed and next {@link PCollection} in the list and applied to\n+   * all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> first = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"3\", \"4\",\"4\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectDistinct()); // results will be PCollection<String> containing: \"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectDistinct() {\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImplCollections<>(intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTESECT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output MIN(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"3\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing intersection\n+   * all of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTERSECT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output MIN(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectAll()); // results will be PCollection<String> containing: \"1\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectAll() {\n+    return new SetImplCollections<>(Math::min);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * difference (except) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * pipeline is constructed but not present in provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptDistinct(right)); // results will be PCollection<String> containing: \"2\",\"5\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> exceptDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, exceptDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing difference (except) of collections done in order for all\n+   * collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * difference (except) of collections done in order for all collections in {@code\n+   * PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in pipeline is constructed but not present in next {@link PCollection} in the list and\n+   * applied to all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"2\",\"2\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.exceptDistinct()); // results will be PCollection<String> containing: \"5\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> exceptDistinct() {\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            numberOfElementsinLeft > 0 && numberOfElementsinRight == 0 ? 1L : 0L;\n+    return new SetImplCollections<>(exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * difference all (exceptAll) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output m elements of left\n+   * for all elements which are present in left but not in right. - it will output MAX(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"2\",\"3\",\"3\",\"5\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> exceptAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, exceptAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing difference all\n+   * (exceptAll) of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow EXCEPT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output m elements of left for all elements which are present in left but not in right. - it\n+   * will output MAX(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.exceptAll()); // results will be PCollection<String> containing: \"1\",\"2\",\"3\",\"3\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> exceptAll() {\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            Math.max(numberOfElementsinLeft - numberOfElementsinRight, 0L);\n+    return new SetImplCollections<>(exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * union with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * pipeline is constructed or present in provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"2\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.unionDistinct(right)); // results will be PCollection<String> containing: \"1\",\"2\",\"3\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> unionDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, unionDistinct());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing union\n+   * of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in pipeline is constructed or present in next {@link PCollection} in the list and\n+   * applied to all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"2\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\"));\n+   *\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.unionDistinct()); // results will be PCollection<String> containing: \"1\",\"2\",\"3\",\"4\",\"5\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> unionDistinct() {\n+    SerializableBiFunction<Long, Long, Long> unionFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> 1L;\n+    return new SetImplCollections<>(unionFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * unionAll with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow UNION_ALL semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output m elements of left\n+   * and m elements of right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"2\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.unionAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"1\",\"2\",\"3\",\"4\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> unionAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, unionAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing unionAll of\n+   * collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow UNION_ALL semantics. Output\n+   * is calculated as follows: Given there are m elements on pipeline which is constructed {@link\n+   * PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will output\n+   * m elements of left and m elements of right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all inputs {@code\n+   * PCollection<T>} to be deterministic (see {@link Coder#verifyDeterministic()}). If the\n+   * collection {@code Coder} is not deterministic, an exception is thrown at pipeline construction\n+   * time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}", "originalCommit": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1MDc1MA==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425550750", "bodyText": "How about we rename the class to be Sets", "author": "lukecwik", "createdAt": "2020-05-15T03:48:59Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {", "originalCommit": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY4OTM5Nw==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425689397", "bodyText": "Thanks.Done", "author": "darshanj", "createdAt": "2020-05-15T09:45:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1MDc1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1MTUzNw==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425551537", "bodyText": "nit: spacing here and elsewhere in the examples.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"2\"));\n          \n          \n            \n               * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\"));\n          \n          \n            \n               * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n          \n          \n            \n               * PCollection<String> first = p.apply(Create.of(\"1\", \"1\", \"2\"));\n          \n          \n            \n               * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\", \"4\"));\n          \n          \n            \n               * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));", "author": "lukecwik", "createdAt": "2020-05-15T03:52:09Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectDistinct(right)); // results will be PCollection<String> containing: \"1\",\"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing intersection of collections done in order for all collections\n+   * in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * intersection of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in both pipeline is constructed and next {@link PCollection} in the list and applied to\n+   * all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> first = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"3\", \"4\",\"4\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectDistinct()); // results will be PCollection<String> containing: \"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectDistinct() {\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImplCollections<>(intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTESECT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output MIN(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"3\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing intersection\n+   * all of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTERSECT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output MIN(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectAll()); // results will be PCollection<String> containing: \"1\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectAll() {\n+    return new SetImplCollections<>(Math::min);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * difference (except) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * pipeline is constructed but not present in provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptDistinct(right)); // results will be PCollection<String> containing: \"2\",\"5\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> exceptDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, exceptDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing difference (except) of collections done in order for all\n+   * collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * difference (except) of collections done in order for all collections in {@code\n+   * PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in pipeline is constructed but not present in next {@link PCollection} in the list and\n+   * applied to all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"2\",\"2\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.exceptDistinct()); // results will be PCollection<String> containing: \"5\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> exceptDistinct() {\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            numberOfElementsinLeft > 0 && numberOfElementsinRight == 0 ? 1L : 0L;\n+    return new SetImplCollections<>(exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * difference all (exceptAll) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output m elements of left\n+   * for all elements which are present in left but not in right. - it will output MAX(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"2\",\"3\",\"3\",\"5\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> exceptAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, exceptAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing difference all\n+   * (exceptAll) of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow EXCEPT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output m elements of left for all elements which are present in left but not in right. - it\n+   * will output MAX(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.exceptAll()); // results will be PCollection<String> containing: \"1\",\"2\",\"3\",\"3\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> exceptAll() {\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            Math.max(numberOfElementsinLeft - numberOfElementsinRight, 0L);\n+    return new SetImplCollections<>(exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * union with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * pipeline is constructed or present in provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"2\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.unionDistinct(right)); // results will be PCollection<String> containing: \"1\",\"2\",\"3\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> unionDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, unionDistinct());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing union\n+   * of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in pipeline is constructed or present in next {@link PCollection} in the list and\n+   * applied to all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"2\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\"));\n+   *\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.unionDistinct()); // results will be PCollection<String> containing: \"1\",\"2\",\"3\",\"4\",\"5\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> unionDistinct() {\n+    SerializableBiFunction<Long, Long, Long> unionFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) -> 1L;\n+    return new SetImplCollections<>(unionFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * unionAll with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow UNION_ALL semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output m elements of left\n+   * and m elements of right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"2\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.unionAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"1\",\"2\",\"3\",\"4\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> unionAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, unionAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing unionAll of\n+   * collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow UNION_ALL semantics. Output\n+   * is calculated as follows: Given there are m elements on pipeline which is constructed {@link\n+   * PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will output\n+   * m elements of left and m elements of right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all inputs {@code\n+   * PCollection<T>} to be deterministic (see {@link Coder#verifyDeterministic()}). If the\n+   * collection {@code Coder} is not deterministic, an exception is thrown at pipeline construction\n+   * time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"2\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\"));\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));", "originalCommit": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY4OTMyNA==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425689324", "bodyText": "Thanks.Done", "author": "darshanj", "createdAt": "2020-05-15T09:45:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1MTUzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1NDkwMw==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425554903", "bodyText": "Since SetImpl and SetImplCollection are private classes, users won't be able to assign them to a local variable without converting it to a PTransform which most IDEs won't do for you automatically. Was this your intent?\nIn other transforms we have made these kinds of classes public but they are usually specific to what they do, so in this case we would have a UnionAll/Intersect/IntersectAll/Distinct/DistinctAll/... PTransform that was public that had whatever internal implementation you want. The alternative would be to return PTransform<PCollection, PCollection> which seems ok.", "author": "lukecwik", "createdAt": "2020-05-15T04:06:38Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * both pipeline is constructed and provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectDistinct(right)); // results will be PCollection<String> containing: \"1\",\"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing intersection of collections done in order for all collections\n+   * in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * intersection of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in both pipeline is constructed and next {@link PCollection} in the list and applied to\n+   * all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> first = p.apply(Create.of(\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"3\", \"4\",\"4\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectDistinct()); // results will be PCollection<String> containing: \"3\",\"4\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectDistinct() {\n+    SerializableBiFunction<Long, Long, Long> intersectFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            (numberOfElementsinLeft > 0 && numberOfElementsinRight > 0) ? 1L : 0L;\n+    return new SetImplCollections<>(intersectFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * intersection with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTESECT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output MIN(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.intersectAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"3\",\"4\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> intersectAll(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, intersectAll());\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics which takes a {@code\n+   * PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing intersection\n+   * all of collections done in order for all collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow INTERSECT_ALL semantics.\n+   * Output is calculated as follows: Given there are m elements on pipeline which is constructed\n+   * {@link PCollection} (left) and n elements on in provided {@link PCollection} (right): - it will\n+   * output MIN(m - n, 0) elements of left for all elements which are present in both left and\n+   * right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"5\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.intersectAll()); // results will be PCollection<String> containing: \"1\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> intersectAll() {\n+    return new SetImplCollections<>(Math::min);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET DISTINCT semantics to compute the\n+   * difference (except) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} will all distinct elements that present in\n+   * pipeline is constructed but not present in provided {@link PCollection}.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptDistinct(right)); // results will be PCollection<String> containing: \"2\",\"5\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> exceptDistinct(PCollection<T> rightCollection) {\n+    checkNotNull(rightCollection, \"rightCollection argument is null\");\n+    return new SetImpl<>(rightCollection, exceptDistinct());\n+  }\n+\n+  /**\n+   * Returns a {@code PTransform} that takes a {@code PCollectionList<PCollection<T>>} and returns a\n+   * {@code PCollection<T>} containing difference (except) of collections done in order for all\n+   * collections in {@code PCollectionList<T>}.\n+   *\n+   * <p>Returns a new {@code PTransform} transform that follows SET DISTINCT semantics which takes a\n+   * {@code PCollectionList<PCollection<T>>} and returns a {@code PCollection<T>} containing\n+   * difference (except) of collections done in order for all collections in {@code\n+   * PCollectionList<T>}.\n+   *\n+   * <p>The elements of the output {@link PCollection} will have all distinct elements that are\n+   * present in pipeline is constructed but not present in next {@link PCollection} in the list and\n+   * applied to all collections in order.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of first in {@code PCollectionList<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   * PCollection<String> first = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"4\", \"5\"));\n+   * PCollection<String> second = p.apply(Create.of(\"1\",\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> third = p.apply(Create.of(\"1\", \"2\",\"2\"));\n+   *\n+   * // Following example will perform (first intersect second) intersect third.\n+   * PCollection<String> results =\n+   *     PCollectionList.of(first).and(second).and(third)\n+   *     .apply(SetFns.exceptDistinct()); // results will be PCollection<String> containing: \"5\"\n+   *\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input {@code PCollectionList<T>} and output {@code\n+   *     PCollection<T>}s.\n+   */\n+  public static <T> SetImplCollections<T> exceptDistinct() {\n+    SerializableBiFunction<Long, Long, Long> exceptFn =\n+        (numberOfElementsinLeft, numberOfElementsinRight) ->\n+            numberOfElementsinLeft > 0 && numberOfElementsinRight == 0 ? 1L : 0L;\n+    return new SetImplCollections<>(exceptFn);\n+  }\n+\n+  /**\n+   * Returns a new {@code PTransform} transform that follows SET ALL semantics to compute the\n+   * difference all (exceptAll) with provided {@code PCollection<T>}.\n+   *\n+   * <p>The argument should not be modified after this is called.\n+   *\n+   * <p>The elements of the output {@link PCollection} which will follow EXCEPT_ALL Semantics as\n+   * follows: Given there are m elements on pipeline which is constructed {@link PCollection} (left)\n+   * and n elements on in provided {@link PCollection} (right): - it will output m elements of left\n+   * for all elements which are present in left but not in right. - it will output MAX(m - n, 0)\n+   * elements of left for all elements which are present in both left and right.\n+   *\n+   * <p>Note that this transform requires that the {@code Coder} of the all {@code PCollection<T>}\n+   * to be deterministic (see {@link Coder#verifyDeterministic()}). If the collection {@code Coder}\n+   * is not deterministic, an exception is thrown at pipeline construction time.\n+   *\n+   * <p>All inputs must have equal {@link WindowFn}s and compatible triggers (see {@link\n+   * Trigger#isCompatible(Trigger)}).\n+   *\n+   * <p>By default, the output {@code PCollection<T>} encodes its elements using the same {@code\n+   * Coder} that of {@code PCollection<T>}\n+   *\n+   * <pre>{@code\n+   * Pipeline p = ...;\n+   *\n+   * PCollection<String> left = p.apply(Create.of(\"1\",\"1\",\"1\", \"2\", \"3\", \"3\",\"3\",\"4\", \"5\"));\n+   * PCollection<String> right = p.apply(Create.of(\"1\", \"3\", \"4\",\"4\", \"6\"));\n+   *\n+   * PCollection<String> results =\n+   *     left.apply(SetFns.exceptAll(right)); // results will be PCollection<String> containing: \"1\",\"1\",\"2\",\"3\",\"3\",\"5\"\n+   * }</pre>\n+   *\n+   * @param <T> the type of the elements in the input and output {@code PCollection<T>}s.\n+   */\n+  public static <T> SetImpl<T> exceptAll(PCollection<T> rightCollection) {", "originalCommit": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY0MjQ0NA==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425642444", "bodyText": "Yes. It is to avoid mutation and create correct abstraction. As this Transform doesn't have any builder like pattern, does taking out a variable makes any sense?", "author": "darshanj", "createdAt": "2020-05-15T08:20:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1NDkwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU5NzQyNQ==", "url": "https://github.com/apache/beam/pull/11610#discussion_r426597425", "bodyText": "Added return value as respective PTransforms.", "author": "darshanj", "createdAt": "2020-05-18T12:44:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1NDkwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1NTQ5OA==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425555498", "bodyText": "Note, we already have a Distinct transform with some additional capabilities over what we have here but it currently requires users to flatten/merge their PCollections into a single PCollection already.\n@robertwb any suggestions on what to do here? (having very similar but duplicated functionality seems like bloat)", "author": "lukecwik", "createdAt": "2020-05-15T04:09:39Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {", "originalCommit": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY0NTM3Mg==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425645372", "bodyText": "Just thought to add my original intention was to have only binary operation. We can make this only 2 to nry transform. As we added pCollectionList api, we just allowed PcollectionList with size==1. It is never meant to behave as Distinct for one collection.", "author": "darshanj", "createdAt": "2020-05-15T08:26:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1NTQ5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY5MjE1NQ==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425692155", "bodyText": "I have removed to support PCollectionList with only one PCollection", "author": "darshanj", "createdAt": "2020-05-15T09:51:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1NTQ5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1NTYyMw==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425555623", "bodyText": "A simple class comment would help people reading the javadoc as to what kinds of transforms are contained in this class.", "author": "lukecwik", "createdAt": "2020-05-15T04:10:10Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/SetFns.java", "diffHunk": "@@ -0,0 +1,618 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.sdk.Pipeline;\n+import org.apache.beam.sdk.coders.Coder;\n+import org.apache.beam.sdk.transforms.join.CoGbkResult;\n+import org.apache.beam.sdk.transforms.join.CoGroupByKey;\n+import org.apache.beam.sdk.transforms.join.KeyedPCollectionTuple;\n+import org.apache.beam.sdk.transforms.windowing.Trigger;\n+import org.apache.beam.sdk.transforms.windowing.WindowFn;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.TupleTag;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Iterables;\n+\n+public class SetFns {", "originalCommit": "b3b28ba1890b84c7b377f8686666c7e0a9aafdb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY4OTIxMQ==", "url": "https://github.com/apache/beam/pull/11610#discussion_r425689211", "bodyText": "Thanks.Done", "author": "darshanj", "createdAt": "2020-05-15T09:45:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1NTYyMw=="}], "type": "inlineReview"}, {"oid": "910ba2f551abc8e12d48253230cfe9bd597173fc", "url": "https://github.com/apache/beam/commit/910ba2f551abc8e12d48253230cfe9bd597173fc", "message": "[BEAM-9825] | rename to sets, some comments, check size > 1", "committedDate": "2020-05-15T09:43:54Z", "type": "commit"}, {"oid": "9e68e81a7d58e59e4f7fbb051deb0b1efac41ce8", "url": "https://github.com/apache/beam/commit/9e68e81a7d58e59e4f7fbb051deb0b1efac41ce8", "message": "[BEAM-9825] | change return value to PTransform", "committedDate": "2020-05-18T12:35:37Z", "type": "commit"}]}