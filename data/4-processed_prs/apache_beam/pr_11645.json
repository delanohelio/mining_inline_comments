{"pr_number": 11645, "pr_title": "[BEAM-9642] Adding Go SDF fallback for unexpanded SDFs.", "pr_createdAt": "2020-05-08T23:29:44Z", "pr_url": "https://github.com/apache/beam/pull/11645", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY4MjgzNQ==", "url": "https://github.com/apache/beam/pull/11645#discussion_r422682835", "bodyText": "Consider just using the auto String() print to add as context instead of adding the extra words. eg. (err, \"%v\", n)", "author": "lostluck", "createdAt": "2020-05-10T18:39:28Z", "path": "sdks/go/pkg/beam/core/runtime/exec/sdf.go", "diffHunk": "@@ -313,3 +313,94 @@ func (n *ProcessSizedElementsAndRestrictions) Down(ctx context.Context) error {\n func (n *ProcessSizedElementsAndRestrictions) String() string {\n \treturn fmt.Sprintf(\"SDF.ProcessSizedElementsAndRestrictions[%v] Out:%v\", path.Base(n.PDo.Fn.Name()), IDs(n.PDo.Out...))\n }\n+\n+// SdfFallback is an executor used when an SDF isn't expanded into steps by the\n+// runner, indicating that the runner doesn't support splitting. It executes all\n+// the SDF steps together in one unit.\n+type SdfFallback struct {\n+\tPDo *ParDo\n+\n+\tinitRestInv *cirInvoker\n+\tsplitInv    *srInvoker\n+\ttrackerInv  *ctInvoker\n+}\n+\n+// ID just defers to the ParDo's ID method.\n+func (n *SdfFallback) ID() UnitID {\n+\treturn n.PDo.UID\n+}\n+\n+// Up performs some one-time setup and then defers to the ParDo's Up method.\n+func (n *SdfFallback) Up(ctx context.Context) error {\n+\tsdf := (*graph.SplittableDoFn)(n.PDo.Fn)\n+\taddContext := func(err error) error {\n+\t\treturn errors.WithContextf(err, \"SdfFallback transform with UID %v\", n.ID())", "originalCommit": "900549da8eb31a02646e3f192f653694fc49c203", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM5MjkwNQ==", "url": "https://github.com/apache/beam/pull/11645#discussion_r423392905", "bodyText": "Good idea. Actually went ahead and did that for all the errors in this file, since that seems better,", "author": "youngoli", "createdAt": "2020-05-12T00:22:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY4MjgzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY4Njc3OQ==", "url": "https://github.com/apache/beam/pull/11645#discussion_r422686779", "bodyText": "Editorial nits:\nWe can probably remove the \"just\".\nGiven \"defer\" is a keyword in Go, using defers might be misinterpreted. Consider replacing it with \"calls\"\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            // StartBundle just defers to the ParDo's StartBundle method.\n          \n          \n            \n            // StartBundle calls the ParDo's StartBundle method.", "author": "lostluck", "createdAt": "2020-05-10T19:13:22Z", "path": "sdks/go/pkg/beam/core/runtime/exec/sdf.go", "diffHunk": "@@ -313,3 +313,94 @@ func (n *ProcessSizedElementsAndRestrictions) Down(ctx context.Context) error {\n func (n *ProcessSizedElementsAndRestrictions) String() string {\n \treturn fmt.Sprintf(\"SDF.ProcessSizedElementsAndRestrictions[%v] Out:%v\", path.Base(n.PDo.Fn.Name()), IDs(n.PDo.Out...))\n }\n+\n+// SdfFallback is an executor used when an SDF isn't expanded into steps by the\n+// runner, indicating that the runner doesn't support splitting. It executes all\n+// the SDF steps together in one unit.\n+type SdfFallback struct {\n+\tPDo *ParDo\n+\n+\tinitRestInv *cirInvoker\n+\tsplitInv    *srInvoker\n+\ttrackerInv  *ctInvoker\n+}\n+\n+// ID just defers to the ParDo's ID method.\n+func (n *SdfFallback) ID() UnitID {\n+\treturn n.PDo.UID\n+}\n+\n+// Up performs some one-time setup and then defers to the ParDo's Up method.\n+func (n *SdfFallback) Up(ctx context.Context) error {\n+\tsdf := (*graph.SplittableDoFn)(n.PDo.Fn)\n+\taddContext := func(err error) error {\n+\t\treturn errors.WithContextf(err, \"SdfFallback transform with UID %v\", n.ID())\n+\t}\n+\tvar err error\n+\tif n.initRestInv, err = newCreateInitialRestrictionInvoker(sdf.CreateInitialRestrictionFn()); err != nil {\n+\t\treturn addContext(err)\n+\t}\n+\tif n.splitInv, err = newSplitRestrictionInvoker(sdf.SplitRestrictionFn()); err != nil {\n+\t\treturn addContext(err)\n+\t}\n+\tif n.trackerInv, err = newCreateTrackerInvoker(sdf.CreateTrackerFn()); err != nil {\n+\t\treturn addContext(err)\n+\t}\n+\treturn n.PDo.Up(ctx)\n+}\n+\n+// StartBundle just defers to the ParDo's StartBundle method.", "originalCommit": "900549da8eb31a02646e3f192f653694fc49c203", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM5Mzc2OA==", "url": "https://github.com/apache/beam/pull/11645#discussion_r423393768", "bodyText": "Done, for all the comments in this file.", "author": "youngoli", "createdAt": "2020-05-12T00:25:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY4Njc3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY4NzA0Nw==", "url": "https://github.com/apache/beam/pull/11645#discussion_r422687047", "bodyText": "Same comment here WRT context.", "author": "lostluck", "createdAt": "2020-05-10T19:15:31Z", "path": "sdks/go/pkg/beam/core/runtime/exec/sdf.go", "diffHunk": "@@ -313,3 +313,94 @@ func (n *ProcessSizedElementsAndRestrictions) Down(ctx context.Context) error {\n func (n *ProcessSizedElementsAndRestrictions) String() string {\n \treturn fmt.Sprintf(\"SDF.ProcessSizedElementsAndRestrictions[%v] Out:%v\", path.Base(n.PDo.Fn.Name()), IDs(n.PDo.Out...))\n }\n+\n+// SdfFallback is an executor used when an SDF isn't expanded into steps by the\n+// runner, indicating that the runner doesn't support splitting. It executes all\n+// the SDF steps together in one unit.\n+type SdfFallback struct {\n+\tPDo *ParDo\n+\n+\tinitRestInv *cirInvoker\n+\tsplitInv    *srInvoker\n+\ttrackerInv  *ctInvoker\n+}\n+\n+// ID just defers to the ParDo's ID method.\n+func (n *SdfFallback) ID() UnitID {\n+\treturn n.PDo.UID\n+}\n+\n+// Up performs some one-time setup and then defers to the ParDo's Up method.\n+func (n *SdfFallback) Up(ctx context.Context) error {\n+\tsdf := (*graph.SplittableDoFn)(n.PDo.Fn)\n+\taddContext := func(err error) error {\n+\t\treturn errors.WithContextf(err, \"SdfFallback transform with UID %v\", n.ID())\n+\t}\n+\tvar err error\n+\tif n.initRestInv, err = newCreateInitialRestrictionInvoker(sdf.CreateInitialRestrictionFn()); err != nil {\n+\t\treturn addContext(err)\n+\t}\n+\tif n.splitInv, err = newSplitRestrictionInvoker(sdf.SplitRestrictionFn()); err != nil {\n+\t\treturn addContext(err)\n+\t}\n+\tif n.trackerInv, err = newCreateTrackerInvoker(sdf.CreateTrackerFn()); err != nil {\n+\t\treturn addContext(err)\n+\t}\n+\treturn n.PDo.Up(ctx)\n+}\n+\n+// StartBundle just defers to the ParDo's StartBundle method.\n+func (n *SdfFallback) StartBundle(ctx context.Context, id string, data DataContext) error {\n+\treturn n.PDo.StartBundle(ctx, id, data)\n+}\n+\n+// ProcessElement performs all the work from the steps above in one transform.\n+// This means creating initial restrictions, performing initial splits on those\n+// restrictions, and then creating restriction trackers and processing each\n+// restriction with the underlying ParDo. This executor skips the sizing step\n+// because sizing information is unnecessary for unexpanded SDFs.\n+func (n *SdfFallback) ProcessElement(ctx context.Context, elm *FullValue, values ...ReStream) error {\n+\tif n.PDo.status != Active {\n+\t\treturn errors.Errorf(\"invalid status for ParDo %v: %v, want Active\", n.PDo.UID, n.PDo.status)\n+\t}\n+\n+\trest := n.initRestInv.Invoke(elm)\n+\tsplitRests := n.splitInv.Invoke(elm, rest)\n+\tif len(splitRests) == 0 {\n+\t\terr := errors.Errorf(\"initial splitting returned 0 restrictions.\")\n+\t\treturn errors.WithContextf(err, \"SdfFallback transform with UID %v\", n.ID())", "originalCommit": "900549da8eb31a02646e3f192f653694fc49c203", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM5MzgyNQ==", "url": "https://github.com/apache/beam/pull/11645#discussion_r423393825", "bodyText": "Done.", "author": "youngoli", "createdAt": "2020-05-12T00:25:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY4NzA0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY4NzIwMw==", "url": "https://github.com/apache/beam/pull/11645#discussion_r422687203", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            // FinishBundle does some teardown for the end of the bundle and then defers to\n          \n          \n            \n            // the ParDo's FinishBundle method.\n          \n          \n            \n            // FinishBundle resets the invokers and then calls the ParDo's FinishBundle method.", "author": "lostluck", "createdAt": "2020-05-10T19:16:41Z", "path": "sdks/go/pkg/beam/core/runtime/exec/sdf.go", "diffHunk": "@@ -313,3 +313,94 @@ func (n *ProcessSizedElementsAndRestrictions) Down(ctx context.Context) error {\n func (n *ProcessSizedElementsAndRestrictions) String() string {\n \treturn fmt.Sprintf(\"SDF.ProcessSizedElementsAndRestrictions[%v] Out:%v\", path.Base(n.PDo.Fn.Name()), IDs(n.PDo.Out...))\n }\n+\n+// SdfFallback is an executor used when an SDF isn't expanded into steps by the\n+// runner, indicating that the runner doesn't support splitting. It executes all\n+// the SDF steps together in one unit.\n+type SdfFallback struct {\n+\tPDo *ParDo\n+\n+\tinitRestInv *cirInvoker\n+\tsplitInv    *srInvoker\n+\ttrackerInv  *ctInvoker\n+}\n+\n+// ID just defers to the ParDo's ID method.\n+func (n *SdfFallback) ID() UnitID {\n+\treturn n.PDo.UID\n+}\n+\n+// Up performs some one-time setup and then defers to the ParDo's Up method.\n+func (n *SdfFallback) Up(ctx context.Context) error {\n+\tsdf := (*graph.SplittableDoFn)(n.PDo.Fn)\n+\taddContext := func(err error) error {\n+\t\treturn errors.WithContextf(err, \"SdfFallback transform with UID %v\", n.ID())\n+\t}\n+\tvar err error\n+\tif n.initRestInv, err = newCreateInitialRestrictionInvoker(sdf.CreateInitialRestrictionFn()); err != nil {\n+\t\treturn addContext(err)\n+\t}\n+\tif n.splitInv, err = newSplitRestrictionInvoker(sdf.SplitRestrictionFn()); err != nil {\n+\t\treturn addContext(err)\n+\t}\n+\tif n.trackerInv, err = newCreateTrackerInvoker(sdf.CreateTrackerFn()); err != nil {\n+\t\treturn addContext(err)\n+\t}\n+\treturn n.PDo.Up(ctx)\n+}\n+\n+// StartBundle just defers to the ParDo's StartBundle method.\n+func (n *SdfFallback) StartBundle(ctx context.Context, id string, data DataContext) error {\n+\treturn n.PDo.StartBundle(ctx, id, data)\n+}\n+\n+// ProcessElement performs all the work from the steps above in one transform.\n+// This means creating initial restrictions, performing initial splits on those\n+// restrictions, and then creating restriction trackers and processing each\n+// restriction with the underlying ParDo. This executor skips the sizing step\n+// because sizing information is unnecessary for unexpanded SDFs.\n+func (n *SdfFallback) ProcessElement(ctx context.Context, elm *FullValue, values ...ReStream) error {\n+\tif n.PDo.status != Active {\n+\t\treturn errors.Errorf(\"invalid status for ParDo %v: %v, want Active\", n.PDo.UID, n.PDo.status)\n+\t}\n+\n+\trest := n.initRestInv.Invoke(elm)\n+\tsplitRests := n.splitInv.Invoke(elm, rest)\n+\tif len(splitRests) == 0 {\n+\t\terr := errors.Errorf(\"initial splitting returned 0 restrictions.\")\n+\t\treturn errors.WithContextf(err, \"SdfFallback transform with UID %v\", n.ID())\n+\t}\n+\n+\tfor _, splitRest := range splitRests {\n+\t\trt := n.trackerInv.Invoke(splitRest)\n+\t\tmainIn := &MainInput{\n+\t\t\tKey:      *elm,\n+\t\t\tValues:   values,\n+\t\t\tRTracker: rt,\n+\t\t}\n+\t\tif err := n.PDo.processMainInput(mainIn); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n+// FinishBundle does some teardown for the end of the bundle and then defers to\n+// the ParDo's FinishBundle method.", "originalCommit": "900549da8eb31a02646e3f192f653694fc49c203", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM5NDQyOQ==", "url": "https://github.com/apache/beam/pull/11645#discussion_r423394429", "bodyText": "Done, for the other FinishBundle methods too.", "author": "youngoli", "createdAt": "2020-05-12T00:27:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY4NzIwMw=="}], "type": "inlineReview"}, {"oid": "8efc3be4627297a15727b29fbec04dbf470ef90f", "url": "https://github.com/apache/beam/commit/8efc3be4627297a15727b29fbec04dbf470ef90f", "message": "[BEAM-9642] Adding Go SDF fallback for unexpanded SDFs.\n\nThis allows the direct runner and other runners that don't know how to\nexpand SDFs to still have the SDK harness run them.", "committedDate": "2020-05-12T00:28:39Z", "type": "commit"}, {"oid": "8efc3be4627297a15727b29fbec04dbf470ef90f", "url": "https://github.com/apache/beam/commit/8efc3be4627297a15727b29fbec04dbf470ef90f", "message": "[BEAM-9642] Adding Go SDF fallback for unexpanded SDFs.\n\nThis allows the direct runner and other runners that don't know how to\nexpand SDFs to still have the SDK harness run them.", "committedDate": "2020-05-12T00:28:39Z", "type": "forcePushed"}]}