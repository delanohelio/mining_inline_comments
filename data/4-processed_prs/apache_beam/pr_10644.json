{"pr_number": 10644, "pr_title": "[BEAM-7427] Refactor JmsCheckpointMark to use SerializableCoder", "pr_createdAt": "2020-01-21T18:02:21Z", "pr_url": "https://github.com/apache/beam/pull/10644", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYxNjg3Mg==", "url": "https://github.com/apache/beam/pull/10644#discussion_r369616872", "bodyText": "This second test is not needed if you make UnboundedJmsSource#getCheckpointMarkCoder return the SerializableCoder. Also that is needed to get rid also of AvroCoder as part of these fixes.", "author": "iemejia", "createdAt": "2020-01-22T15:10:21Z", "path": "sdks/java/io/jms/src/test/java/org/apache/beam/sdk/io/jms/JmsIOTest.java", "diffHunk": "@@ -406,6 +408,26 @@ public void testCheckpointMarkSafety() throws Exception {\n     runner.join();\n   }\n \n+  /** Test the checkpoint mark default coder, which is actually AvroCoder. */\n+  @Test\n+  public void testCheckpointMarkDefaultCoder() throws Exception {\n+    JmsIO.JmsCheckpointMark jmsCheckpointMark = new JmsIO.JmsCheckpointMark();\n+    jmsCheckpointMark.add(new ActiveMQMessage());\n+    Coder coder = new JmsIO.UnboundedJmsSource(null).getCheckpointMarkCoder();\n+    CoderProperties.coderSerializable(coder);\n+    CoderProperties.coderDecodeEncodeEqual(coder, jmsCheckpointMark);\n+  }\n+\n+  @Test\n+  public void testCheckpointMarkSerializableCoder() throws Exception {\n+    JmsIO.JmsCheckpointMark jmsCheckpointMark = new JmsIO.JmsCheckpointMark();", "originalCommit": "1b7e4624ab1c5db7e62999caf9312669d797b757", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY2MzIxNg==", "url": "https://github.com/apache/beam/pull/10644#discussion_r369663216", "bodyText": "+1, I'm doing the change.", "author": "jbonofre", "createdAt": "2020-01-22T16:24:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYxNjg3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYxOTIzNg==", "url": "https://github.com/apache/beam/pull/10644#discussion_r369619236", "bodyText": "We need to add messages to the equals too.", "author": "iemejia", "createdAt": "2020-01-22T15:14:26Z", "path": "sdks/java/io/jms/src/main/java/org/apache/beam/sdk/io/jms/JmsIO.java", "diffHunk": "@@ -404,9 +408,96 @@ private JmsIO() {}\n     T mapMessage(Message message) throws Exception;\n   }\n \n+  /**\n+   * Checkpoint for an unbounded JMS source. Consists of the JMS messages waiting to be acknowledged\n+   * and oldest pending message timestamp.\n+   */\n+  @VisibleForTesting\n+  static class JmsCheckpointMark implements UnboundedSource.CheckpointMark, Serializable {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(JmsCheckpointMark.class);\n+\n+    @VisibleForTesting Instant oldestMessageTimestamp = Instant.now();\n+    @VisibleForTesting transient List<Message> messages = new ArrayList<>();\n+\n+    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n+\n+    public JmsCheckpointMark() {}\n+\n+    public void add(Message message) throws Exception {\n+      lock.writeLock().lock();\n+      try {\n+        Instant currentMessageTimestamp = new Instant(message.getJMSTimestamp());\n+        if (currentMessageTimestamp.isBefore(oldestMessageTimestamp)) {\n+          oldestMessageTimestamp = currentMessageTimestamp;\n+        }\n+        messages.add(message);\n+      } finally {\n+        lock.writeLock().unlock();\n+      }\n+    }\n+\n+    public Instant getOldestMessageTimestamp() {\n+      lock.readLock().lock();\n+      try {\n+        return this.oldestMessageTimestamp;\n+      } finally {\n+        lock.readLock().unlock();\n+      }\n+    }\n+\n+    /**\n+     * Acknowledge all outstanding message. Since we believe that messages will be delivered in\n+     * timestamp order, and acknowledged messages will not be retried, the newest message in this\n+     * batch is a good bound for future messages.\n+     */\n+    @Override\n+    public void finalizeCheckpoint() {\n+      lock.writeLock().lock();\n+      try {\n+        for (Message message : messages) {\n+          try {\n+            message.acknowledge();\n+            Instant currentMessageTimestamp = new Instant(message.getJMSTimestamp());\n+            if (currentMessageTimestamp.isAfter(oldestMessageTimestamp)) {\n+              oldestMessageTimestamp = currentMessageTimestamp;\n+            }\n+          } catch (Exception e) {\n+            LOG.error(\"Exception while finalizing message: {}\", e);\n+          }\n+        }\n+        messages.clear();\n+      } finally {\n+        lock.writeLock().unlock();\n+      }\n+    }\n+\n+    // set an empty list to messages when deserialize\n+    private void readObject(java.io.ObjectInputStream stream)\n+        throws IOException, ClassNotFoundException {\n+      stream.defaultReadObject();\n+      messages = new ArrayList<>();\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+      if (other instanceof JmsCheckpointMark) {\n+        JmsCheckpointMark that = (JmsCheckpointMark) other;\n+        return Objects.equals(this.oldestMessageTimestamp, that.oldestMessageTimestamp);", "originalCommit": "1b7e4624ab1c5db7e62999caf9312669d797b757", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY2MzA4NA==", "url": "https://github.com/apache/beam/pull/10644#discussion_r369663084", "bodyText": "Messages list is transient. Do we really need it in the equals ?", "author": "jbonofre", "createdAt": "2020-01-22T16:24:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYxOTIzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyMDQ2Ng==", "url": "https://github.com/apache/beam/pull/10644#discussion_r369620466", "bodyText": "A CheckpointMark is basically an object to save pending unprocessed state, in the case of JmsIO pending state are the messages. If we make the messages transient we are losing data. So we need to fix this to make the messages part of the serialized state of the object. However since Jms Messages are not Serializable probably what we need to store here are JmsRecords.", "author": "iemejia", "createdAt": "2020-01-22T15:16:19Z", "path": "sdks/java/io/jms/src/main/java/org/apache/beam/sdk/io/jms/JmsIO.java", "diffHunk": "@@ -404,9 +408,96 @@ private JmsIO() {}\n     T mapMessage(Message message) throws Exception;\n   }\n \n+  /**\n+   * Checkpoint for an unbounded JMS source. Consists of the JMS messages waiting to be acknowledged\n+   * and oldest pending message timestamp.\n+   */\n+  @VisibleForTesting\n+  static class JmsCheckpointMark implements UnboundedSource.CheckpointMark, Serializable {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(JmsCheckpointMark.class);\n+\n+    @VisibleForTesting Instant oldestMessageTimestamp = Instant.now();\n+    @VisibleForTesting transient List<Message> messages = new ArrayList<>();", "originalCommit": "1b7e4624ab1c5db7e62999caf9312669d797b757", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyMzg5NQ==", "url": "https://github.com/apache/beam/pull/10644#discussion_r369623895", "bodyText": "Possible issue after changing the pending state to be JmsRecords is the fact that the records need to recreate Messages to be able to ack on finalizeCheckpoint. Doing ack on the CheckpointMark is probably an error because you would need also the connection information, so better to move that logick out of the CheckpointMark.", "author": "iemejia", "createdAt": "2020-01-22T15:21:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyMDQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzMjIwNA==", "url": "https://github.com/apache/beam/pull/10644#discussion_r369632204", "bodyText": "Other extra bit is that JmsRecord equals and hashcode implementation do not take into account the same fields, this should be also addressed otherwise the equals contract might get broken.", "author": "iemejia", "createdAt": "2020-01-22T15:34:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyMDQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY2NDAzNA==", "url": "https://github.com/apache/beam/pull/10644#discussion_r369664034", "bodyText": "That's not possible, simply to execute the ack on messages. So, I'm using the same approach as in MqttIO. Just keep the oldest timestamp, and don't ack the messages. Then, the messages stay in the broker and will be consumed by another executor.", "author": "jbonofre", "createdAt": "2020-01-22T16:26:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyMDQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY2NTgzMA==", "url": "https://github.com/apache/beam/pull/10644#discussion_r369665830", "bodyText": "The finalize checkpoint should ack the message. A better impl is:\n\nuse auto_ack on session\nconvert Message as JmsRecord and store in the checkpoint mark\nthanks to that, the record will be serializable and we can transport it.\n\nI'm doing the change.", "author": "jbonofre", "createdAt": "2020-01-22T16:29:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyMDQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY4NTAyOA==", "url": "https://github.com/apache/beam/pull/10644#discussion_r369685028", "bodyText": "@jbonofre  Could this logic be implemented using JmsCheckpointMark.State class as it was before? Well, for this case, at least, we need to make State serialisable but it should not be a problem with conversion from Message to JmsRecord.", "author": "aromanenko-dev", "createdAt": "2020-01-22T17:01:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyMDQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5MDk3NA==", "url": "https://github.com/apache/beam/pull/10644#discussion_r369690974", "bodyText": "I'm also wondering if we can have potentially OOM here if the size of messages is large?", "author": "aromanenko-dev", "createdAt": "2020-01-22T17:12:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyMDQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTcwODU2OA==", "url": "https://github.com/apache/beam/pull/10644#discussion_r369708568", "bodyText": "We can limit the size of the messages list and call finalize checkpoint. State is useless IMHO, I would keep it in checkpoint mark as it's more straight forward to understand.", "author": "jbonofre", "createdAt": "2020-01-22T17:47:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyMDQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyNjE5Mw==", "url": "https://github.com/apache/beam/pull/10644#discussion_r369626193", "bodyText": "Better leave this as a separate class as it was, no? KafkaIO got splitted because it was almost unmanageable with so much code in one file, or is there a fundamental reason to do this?", "author": "iemejia", "createdAt": "2020-01-22T15:25:20Z", "path": "sdks/java/io/jms/src/main/java/org/apache/beam/sdk/io/jms/JmsCheckpointMark.java", "diffHunk": "@@ -1,184 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.beam.sdk.io.jms;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.concurrent.locks.ReentrantReadWriteLock;\n-import java.util.function.BiFunction;\n-import java.util.function.Supplier;\n-import javax.jms.Message;\n-import org.apache.beam.sdk.coders.AvroCoder;\n-import org.apache.beam.sdk.coders.DefaultCoder;\n-import org.apache.beam.sdk.io.UnboundedSource;\n-import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n-import org.joda.time.Instant;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * Checkpoint for an unbounded JmsIO.Read. Consists of JMS destination name, and the latest message\n- * ID consumed so far.\n- */\n-@DefaultCoder(AvroCoder.class)\n-public class JmsCheckpointMark implements UnboundedSource.CheckpointMark {", "originalCommit": "1b7e4624ab1c5db7e62999caf9312669d797b757", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY2NDYwOQ==", "url": "https://github.com/apache/beam/pull/10644#discussion_r369664609", "bodyText": "As the checkpoint mark is small, I used a inner class (like in MqttIO). But I can isolate it if you think it's better for maintenance.", "author": "jbonofre", "createdAt": "2020-01-22T16:27:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyNjE5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY4ODEzNQ==", "url": "https://github.com/apache/beam/pull/10644#discussion_r369688135", "bodyText": "I agree with @iemejia - it would be more convenient to have JmsCheckpointMark as a separate class (as it was before).", "author": "aromanenko-dev", "createdAt": "2020-01-22T17:07:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyNjE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5MDUwNA==", "url": "https://github.com/apache/beam/pull/10644#discussion_r369690504", "bodyText": "Is it fine that we don't fail here in case of exception? Can it cause a data loss?", "author": "aromanenko-dev", "createdAt": "2020-01-22T17:11:47Z", "path": "sdks/java/io/jms/src/main/java/org/apache/beam/sdk/io/jms/JmsIO.java", "diffHunk": "@@ -404,9 +408,96 @@ private JmsIO() {}\n     T mapMessage(Message message) throws Exception;\n   }\n \n+  /**\n+   * Checkpoint for an unbounded JMS source. Consists of the JMS messages waiting to be acknowledged\n+   * and oldest pending message timestamp.\n+   */\n+  @VisibleForTesting\n+  static class JmsCheckpointMark implements UnboundedSource.CheckpointMark, Serializable {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(JmsCheckpointMark.class);\n+\n+    @VisibleForTesting Instant oldestMessageTimestamp = Instant.now();\n+    @VisibleForTesting transient List<Message> messages = new ArrayList<>();\n+\n+    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n+\n+    public JmsCheckpointMark() {}\n+\n+    public void add(Message message) throws Exception {\n+      lock.writeLock().lock();\n+      try {\n+        Instant currentMessageTimestamp = new Instant(message.getJMSTimestamp());\n+        if (currentMessageTimestamp.isBefore(oldestMessageTimestamp)) {\n+          oldestMessageTimestamp = currentMessageTimestamp;\n+        }\n+        messages.add(message);\n+      } finally {\n+        lock.writeLock().unlock();\n+      }\n+    }\n+\n+    public Instant getOldestMessageTimestamp() {\n+      lock.readLock().lock();\n+      try {\n+        return this.oldestMessageTimestamp;\n+      } finally {\n+        lock.readLock().unlock();\n+      }\n+    }\n+\n+    /**\n+     * Acknowledge all outstanding message. Since we believe that messages will be delivered in\n+     * timestamp order, and acknowledged messages will not be retried, the newest message in this\n+     * batch is a good bound for future messages.\n+     */\n+    @Override\n+    public void finalizeCheckpoint() {\n+      lock.writeLock().lock();\n+      try {\n+        for (Message message : messages) {\n+          try {\n+            message.acknowledge();\n+            Instant currentMessageTimestamp = new Instant(message.getJMSTimestamp());\n+            if (currentMessageTimestamp.isAfter(oldestMessageTimestamp)) {\n+              oldestMessageTimestamp = currentMessageTimestamp;\n+            }\n+          } catch (Exception e) {\n+            LOG.error(\"Exception while finalizing message: {}\", e);", "originalCommit": "1b7e4624ab1c5db7e62999caf9312669d797b757", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk1MDk4NQ==", "url": "https://github.com/apache/beam/pull/10644#discussion_r369950985", "bodyText": "No, it's not a problem as the ack won't be sent.", "author": "jbonofre", "createdAt": "2020-01-23T06:35:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5MDUwNA=="}], "type": "inlineReview"}, {"oid": "1b7e4624ab1c5db7e62999caf9312669d797b757", "url": "https://github.com/apache/beam/commit/1b7e4624ab1c5db7e62999caf9312669d797b757", "message": "[BEAM-7427] Refactore JmsCheckpointMark to be usage via Coder", "committedDate": "2020-01-21T17:28:51Z", "type": "forcePushed"}, {"oid": "f5c9150a8cc9bbb663ca0f92cbc0ee1668b3d2fb", "url": "https://github.com/apache/beam/commit/f5c9150a8cc9bbb663ca0f92cbc0ee1668b3d2fb", "message": "[BEAM-7427] Update test and use serialization coder", "committedDate": "2020-01-23T06:34:06Z", "type": "forcePushed"}, {"oid": "0187bef0724af77c92a319a91077906892738012", "url": "https://github.com/apache/beam/commit/0187bef0724af77c92a319a91077906892738012", "message": "[BEAM-7427] Refactore JmsCheckpointMark to be usage via Coder", "committedDate": "2020-01-28T13:24:35Z", "type": "commit"}, {"oid": "0187bef0724af77c92a319a91077906892738012", "url": "https://github.com/apache/beam/commit/0187bef0724af77c92a319a91077906892738012", "message": "[BEAM-7427] Refactore JmsCheckpointMark to be usage via Coder", "committedDate": "2020-01-28T13:24:35Z", "type": "forcePushed"}]}