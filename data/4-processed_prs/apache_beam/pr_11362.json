{"pr_number": 11362, "pr_title": "[BEAM-9733] Always let ImpulseSourceFunction emit a final watermark", "pr_createdAt": "2020-04-09T10:34:55Z", "pr_url": "https://github.com/apache/beam/pull/11362", "timeline": [{"oid": "d1372bc8e234c0bbe977b6ae39eab3d8e41f8d5a", "url": "https://github.com/apache/beam/commit/d1372bc8e234c0bbe977b6ae39eab3d8e41f8d5a", "message": "[BEAM-9733] Make up for timers set while processing the bundle\n\nDue to the asynchronous nature of the bundle processing which includes access to\nstate and timers, the watermark can only be advanced after the current bundle\nfinishes. We have to make up for timers set during bundle processing which only\nallows us to advance the watermark to the lowest output timestamp of a given set\nof timers.", "committedDate": "2020-04-14T13:20:07Z", "type": "forcePushed"}, {"oid": "bcab609cba64631af6d350e0e2371f3e52ed3cff", "url": "https://github.com/apache/beam/commit/bcab609cba64631af6d350e0e2371f3e52ed3cff", "message": "[BEAM-9733] Make up for timers set while processing the bundle\n\nDue to the asynchronous nature of the bundle processing which includes access to\nstate and timers, the output watermark can only be advanced after the current\nbundle has finished. Furthermore, we have to take care to only advance it to the\nlowest newly set timer in the finished bundle. Otherwise we would be violating\nthe watermark contract.\n\nBesides the problem of advancing the output watermark too soon, the current\nmodel was also overly restrictive with handling the input watermark. The input\nwatermark would be pushed back until the end of the bundle. This is not\nnecessary as we can advance the input watermark freely during bundle processing\nwhich can trigger timers as soon as they become eligible for firing. Special\ncare has to be taken to handle cleanup timers which may already fire when we\nhaven't collected all the timers from the SDK Harness. In case we end up with\nnew timers for a window for which the cleanup timer scheduled a cleanup at the\nend of the bundle, we have to defer the cleanup and reschedule the cleanup\ntimer. Otherwise, we would lose all state for a timer.", "committedDate": "2020-04-17T12:18:27Z", "type": "forcePushed"}, {"oid": "7d5010bd1c6ddd6ed360949a1f809d6ff32fa89b", "url": "https://github.com/apache/beam/commit/7d5010bd1c6ddd6ed360949a1f809d6ff32fa89b", "message": "[BEAM-9733] Make up for timers set while processing the bundle\n\nDue to the asynchronous nature of the bundle processing which includes access to\nstate and timers, the output watermark can only be advanced after the current\nbundle has finished. Furthermore, we have to take care to only advance it to the\nlowest newly set timer in the finished bundle. Otherwise we would be violating\nthe watermark contract.\n\nBesides the problem of advancing the output watermark too soon, the current\nmodel was also overly restrictive with handling the input watermark. The input\nwatermark would be pushed back until the end of the bundle. This is not\nnecessary as we can advance the input watermark freely during bundle processing\nwhich can trigger timers as soon as they become eligible for firing. Special\ncare has to be taken to handle cleanup timers which may already fire when we\nhaven't collected all the timers from the SDK Harness. In case we end up with\nnew timers for a window for which the cleanup timer scheduled a cleanup at the\nend of the bundle, we have to defer the cleanup and reschedule the cleanup\ntimer. Otherwise, we would lose all state for a timer.", "committedDate": "2020-04-19T15:51:01Z", "type": "forcePushed"}, {"oid": "d416fd101d1385d84668026b2a47dcc5c6a39eab", "url": "https://github.com/apache/beam/commit/d416fd101d1385d84668026b2a47dcc5c6a39eab", "message": "[BEAM-9733] Always let ImpulseSourceFunction emit a final watermark\n\nThe Flink Runner's ImpulseSourceFunction does not emit a final watermark, unless\nthe `--shutdownSourcesOnFinalWatermark` flag has been specified (the flag is\nused in tests to shutdown the pipeline after reading all data). Most pipelines\nwill be long-running and thus do not specify the flag.\n\nNot sending out the final watermark causes GroupByKey to hold back the data of\nevent time windows until the pipeline is shut down (the final watermark is\nalways emitted on pipeline shutdown which is why using the above flag works).", "committedDate": "2020-04-19T18:32:16Z", "type": "commit"}, {"oid": "b1f566f5139262015f8d801e819a7bbb4d623d49", "url": "https://github.com/apache/beam/commit/b1f566f5139262015f8d801e819a7bbb4d623d49", "message": "[BEAM-9733] Make up for timers set while processing the bundle\n\nDue to the asynchronous nature of the bundle processing which includes access to\nstate and timers, the output watermark can only be advanced after the current\nbundle has finished. Furthermore, we have to take care to only advance it to the\nlowest newly set timer in the finished bundle. Otherwise we would be violating\nthe watermark contract.\n\nBesides the problem of advancing the output watermark too soon, the current\nmodel was also overly restrictive with handling the input watermark. The input\nwatermark would be pushed back until the end of the bundle. This is not\nnecessary as we can advance the input watermark freely during bundle processing\nwhich can trigger timers as soon as they become eligible for firing. Special\ncare has to be taken to handle cleanup timers which may already fire when we\nhaven't collected all the timers from the SDK Harness. In case we end up with\nnew timers for a window for which the cleanup timer scheduled a cleanup at the\nend of the bundle, we have to defer the cleanup and reschedule the cleanup\ntimer. Otherwise, we would lose all state for a timer.", "committedDate": "2020-04-19T19:27:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUyNDk4Mw==", "url": "https://github.com/apache/beam/pull/11362#discussion_r413524983", "bodyText": "Don't we have to emit pushed back data at this point (up to the side input watermark), even when it is not the final watermark?", "author": "tweise", "createdAt": "2020-04-23T05:44:03Z", "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/DoFnOperator.java", "diffHunk": "@@ -658,46 +671,69 @@ public void processWatermark1(Watermark mark) throws Exception {\n       emitAllPushedBackData();\n     }\n \n-    setCurrentInputWatermark(mark.getTimestamp());\n+    currentInputWatermark = mark.getTimestamp();\n \n-    if (keyCoder == null) {\n-      long potentialOutputWatermark = Math.min(getPushbackWatermarkHold(), currentInputWatermark);\n-      if (potentialOutputWatermark > currentOutputWatermark) {\n-        setCurrentOutputWatermark(potentialOutputWatermark);\n-        emitWatermark(currentOutputWatermark);\n-      }\n-    } else {\n-      // hold back by the pushed back values waiting for side inputs\n-      long pushedBackInputWatermark = Math.min(getPushbackWatermarkHold(), mark.getTimestamp());\n+    long inputWatermarkHold = applyInputWatermarkHold(getEffectiveInputWatermark());\n+    if (keyCoder != null) {\n+      timeServiceManager.advanceWatermark(new Watermark(inputWatermarkHold));\n+    }\n \n-      timeServiceManager.advanceWatermark(new Watermark(pushedBackInputWatermark));\n+    long potentialOutputWatermark =\n+        applyOutputWatermarkHold(\n+            currentOutputWatermark, computeOutputWatermark(inputWatermarkHold));\n+    maybeEmitWatermark(potentialOutputWatermark);\n+  }\n \n-      Instant watermarkHold = keyedStateInternals.watermarkHold();\n+  /**\n+   * Allows to apply a hold to the input watermark. By default, just passes the input watermark\n+   * through.\n+   */\n+  public long applyInputWatermarkHold(long inputWatermark) {\n+    return inputWatermark;\n+  }\n \n-      long combinedWatermarkHold = Math.min(watermarkHold.getMillis(), getPushbackWatermarkHold());\n-      combinedWatermarkHold =\n-          Math.min(combinedWatermarkHold, timerInternals.getMinOutputTimestampMs());\n-      long potentialOutputWatermark = Math.min(pushedBackInputWatermark, combinedWatermarkHold);\n+  /**\n+   * Allows to apply a hold to the output watermark before it is send out. By default, just passes\n+   * the potential output watermark through which will make it the new output watermark.\n+   *\n+   * @param currentOutputWatermark the current output watermark\n+   * @param potentialOutputWatermark The potential new output watermark which can be adjusted, if\n+   *     needed. The input watermark hold has already been applied.\n+   * @return The new output watermark which will be emitted.\n+   */\n+  public long applyOutputWatermarkHold(long currentOutputWatermark, long potentialOutputWatermark) {\n+    return potentialOutputWatermark;\n+  }\n \n-      if (potentialOutputWatermark > currentOutputWatermark) {\n-        setCurrentOutputWatermark(potentialOutputWatermark);\n-        emitWatermark(currentOutputWatermark);\n-      }\n+  private long computeOutputWatermark(long inputWatermarkHold) {\n+    final long potentialOutputWatermark;\n+    if (keyCoder == null) {\n+      potentialOutputWatermark = inputWatermarkHold;\n+    } else {\n+      Instant watermarkHold = keyedStateInternals.watermarkHold();\n+      long combinedWatermarkHold = Math.min(watermarkHold.getMillis(), inputWatermarkHold);\n+      potentialOutputWatermark =\n+          Math.min(combinedWatermarkHold, timerInternals.getMinOutputTimestampMs());\n     }\n+    return potentialOutputWatermark;\n   }\n \n-  private void emitWatermark(long watermark) {\n-    // Must invoke finishBatch before emit the +Inf watermark otherwise there are some late events.\n-    if (watermark >= BoundedWindow.TIMESTAMP_MAX_VALUE.getMillis()) {\n-      invokeFinishBundle();\n+  private void maybeEmitWatermark(long watermark) {\n+    if (watermark > currentOutputWatermark) {\n+      // Must invoke finishBatch before emit the +Inf watermark otherwise there are some late\n+      // events.\n+      if (watermark >= BoundedWindow.TIMESTAMP_MAX_VALUE.getMillis()) {\n+        invokeFinishBundle();\n+      }\n+      LOG.debug(\"Emitting watermark {}\", watermark);\n+      currentOutputWatermark = watermark;\n+      output.emitWatermark(new Watermark(watermark));\n     }\n-    output.emitWatermark(new Watermark(watermark));\n   }\n \n   @Override\n-  public void processWatermark2(Watermark mark) throws Exception {\n-\n-    setCurrentSideInputWatermark(mark.getTimestamp());\n+  public final void processWatermark2(Watermark mark) throws Exception {\n+    currentSideInputWatermark = mark.getTimestamp();", "originalCommit": "b1f566f5139262015f8d801e819a7bbb4d623d49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcxODcwNg==", "url": "https://github.com/apache/beam/pull/11362#discussion_r413718706", "bodyText": "Emitting ready-data side input data is handled when new side input data arrives (see processElement2). This is a safe-guard because no more side input data will arrive after the max watermark. Maybe side input processing could be optimized based on the watermark but I'd tackle this independently of the PR because the logic didn't change here.", "author": "mxm", "createdAt": "2020-04-23T10:58:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUyNDk4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NjYwMQ==", "url": "https://github.com/apache/beam/pull/11362#discussion_r413956601", "bodyText": "Yes, it is independent of this PR. The pre-existing side input related issue still exists. When no side input arrives, elements will never be emitted unless the final watermark occurs.", "author": "tweise", "createdAt": "2020-04-23T16:45:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUyNDk4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk4NDUxOA==", "url": "https://github.com/apache/beam/pull/11362#discussion_r413984518", "bodyText": "I agree, that is something we should address.", "author": "mxm", "createdAt": "2020-04-23T17:25:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUyNDk4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUzMzE0OA==", "url": "https://github.com/apache/beam/pull/11362#discussion_r413533148", "bodyText": "The comment is a bit misleading. How about: \"We are scheduling a timer for advancing the watermark, to not delay finishing the bundle and temporarily release the checkpoint lock. Otherwise, we could potentially loop when a timer keeps scheduling a timer for the same timestamp.\"", "author": "tweise", "createdAt": "2020-04-23T06:05:17Z", "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/wrappers/streaming/ExecutableStageDoFnOperator.java", "diffHunk": "@@ -544,30 +601,49 @@ public void processWatermark(Watermark mark) throws Exception {\n     // every watermark. So we have implemented 2) below.\n     //\n     if (sdkHarnessRunner.isBundleInProgress()) {\n-      if (mark.getTimestamp() >= BoundedWindow.TIMESTAMP_MAX_VALUE.getMillis()) {\n-        invokeFinishBundle();\n-        setPushedBackWatermark(Long.MAX_VALUE);\n+      if (minEventTimeTimerTimestampInLastBundle < Long.MAX_VALUE) {\n+        // We can safely advance the watermark to before the last bundle's minimum event timer\n+        // but not past the potential output watermark which includes holds to the input watermark.\n+        return Math.min(minEventTimeTimerTimestampInLastBundle - 1, potentialOutputWatermark);\n       } else {\n-        // It is not safe to advance the output watermark yet, so add a hold on the current\n-        // output watermark.\n-        backupWatermarkHold = Math.max(backupWatermarkHold, getPushbackWatermarkHold());\n-        setPushedBackWatermark(Math.min(currentOutputWatermark, backupWatermarkHold));\n-        super.setBundleFinishedCallback(\n-            () -> {\n-              try {\n-                LOG.debug(\"processing pushed back watermark: {}\", mark);\n-                // at this point the bundle is finished, allow the watermark to pass\n-                // we are restoring the previous hold in case it was already set for side inputs\n-                setPushedBackWatermark(backupWatermarkHold);\n-                super.processWatermark(mark);\n-              } catch (Exception e) {\n-                throw new RuntimeException(\n-                    \"Failed to process pushed back watermark after finished bundle.\", e);\n-              }\n-            });\n+        // We don't have any information yet, use the current output watermark for now.\n+        return currentOutputWatermark;\n+      }\n+    } else {\n+      // No bundle was started when we advanced the input watermark.\n+      // Thus, we can safely set a new output watermark.\n+      return potentialOutputWatermark;\n+    }\n+  }\n+\n+  private void preBundleStartCallback() {\n+    inputWatermarkBeforeBundleStart = getEffectiveInputWatermark();\n+  }\n+\n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n+  private void finishBundleCallback() {\n+    minEventTimeTimerTimestampInLastBundle = minEventTimeTimerTimestampInCurrentBundle;\n+    minEventTimeTimerTimestampInCurrentBundle = Long.MAX_VALUE;\n+    try {\n+      if (!closed\n+          && minEventTimeTimerTimestampInLastBundle < Long.MAX_VALUE\n+          && minEventTimeTimerTimestampInLastBundle <= getEffectiveInputWatermark()) {\n+        ProcessingTimeService processingTimeService = getProcessingTimeService();\n+        // We are scheduling a timer for advancing the watermark. Otherwise we\n+        // could potentially loop forever here when a timer keeps scheduling a timer\n+        // for the same timestamp. This in itself would not be an issue. However,", "originalCommit": "b1f566f5139262015f8d801e819a7bbb4d623d49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyMjU3Mw==", "url": "https://github.com/apache/beam/pull/11362#discussion_r413722573", "bodyText": "Sure. Changed.", "author": "mxm", "createdAt": "2020-04-23T11:04:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUzMzE0OA=="}], "type": "inlineReview"}, {"oid": "643945a8e44b33e216e58b1405076179617f7740", "url": "https://github.com/apache/beam/commit/643945a8e44b33e216e58b1405076179617f7740", "message": "[BEAM-9733] Make up for timers set while processing the bundle\n\nDue to the asynchronous nature of the bundle processing which includes access to\nstate and timers, the output watermark can only be advanced after the current\nbundle has finished. Furthermore, we have to take care to only advance it to the\nlowest newly set timer in the finished bundle. Otherwise we would be violating\nthe watermark contract.\n\nBesides the problem of advancing the output watermark too soon, the current\nmodel was also overly restrictive with handling the input watermark. The input\nwatermark would be pushed back until the end of the bundle. This is not\nnecessary as we can advance the input watermark freely during bundle processing\nwhich can trigger timers as soon as they become eligible for firing. Special\ncare has to be taken to handle cleanup timers which may already fire when we\nhaven't collected all the timers from the SDK Harness. In case we end up with\nnew timers for a window for which the cleanup timer scheduled a cleanup at the\nend of the bundle, we have to defer the cleanup and reschedule the cleanup\ntimer. Otherwise, we would lose all state for a timer.", "committedDate": "2020-04-23T11:06:29Z", "type": "commit"}, {"oid": "643945a8e44b33e216e58b1405076179617f7740", "url": "https://github.com/apache/beam/commit/643945a8e44b33e216e58b1405076179617f7740", "message": "[BEAM-9733] Make up for timers set while processing the bundle\n\nDue to the asynchronous nature of the bundle processing which includes access to\nstate and timers, the output watermark can only be advanced after the current\nbundle has finished. Furthermore, we have to take care to only advance it to the\nlowest newly set timer in the finished bundle. Otherwise we would be violating\nthe watermark contract.\n\nBesides the problem of advancing the output watermark too soon, the current\nmodel was also overly restrictive with handling the input watermark. The input\nwatermark would be pushed back until the end of the bundle. This is not\nnecessary as we can advance the input watermark freely during bundle processing\nwhich can trigger timers as soon as they become eligible for firing. Special\ncare has to be taken to handle cleanup timers which may already fire when we\nhaven't collected all the timers from the SDK Harness. In case we end up with\nnew timers for a window for which the cleanup timer scheduled a cleanup at the\nend of the bundle, we have to defer the cleanup and reschedule the cleanup\ntimer. Otherwise, we would lose all state for a timer.", "committedDate": "2020-04-23T11:06:29Z", "type": "forcePushed"}]}