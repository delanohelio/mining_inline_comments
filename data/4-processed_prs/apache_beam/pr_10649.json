{"pr_number": 10649, "pr_title": "[BEAM-8042] [ZetaSQL] Fix aggregate column reference", "pr_createdAt": "2020-01-21T23:37:10Z", "pr_url": "https://github.com/apache/beam/pull/10649", "timeline": [{"oid": "42a39cd8400c201e3254ac5d49bd5c63589df860", "url": "https://github.com/apache/beam/commit/42a39cd8400c201e3254ac5d49bd5c63589df860", "message": "Fix aggregates", "committedDate": "2020-01-21T23:39:15Z", "type": "commit"}, {"oid": "42a39cd8400c201e3254ac5d49bd5c63589df860", "url": "https://github.com/apache/beam/commit/42a39cd8400c201e3254ac5d49bd5c63589df860", "message": "Fix aggregates", "committedDate": "2020-01-21T23:39:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwMzcyMg==", "url": "https://github.com/apache/beam/pull/10649#discussion_r369303722", "bodyText": "Might want to use named parameters to not rely on hard-coded values.", "author": "11moon11", "createdAt": "2020-01-21T23:44:10Z", "path": "sdks/java/extensions/sql/zetasql/src/test/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSQLDialectSpecTest.java", "diffHunk": "@@ -1347,6 +1347,44 @@ public void testZetaSQLStructFieldAccessInTumble() {\n     pipeline.run().waitUntilFinish(Duration.standardMinutes(PIPELINE_EXECUTION_WAITTIME_MINUTES));\n   }\n \n+  @Test\n+  public void testAggregateWithAndWithoutColumnRefs() {\n+    ZetaSQLQueryPlanner zetaSQLQueryPlanner = new ZetaSQLQueryPlanner(config);\n+\n+    String sql =\n+        \"SELECT \\n\"\n+            + \"  id, \\n\"\n+            + \"  SUM(has_f1) as f1_count, \\n\"\n+            + \"  SUM(has_f2) as f2_count, \\n\"\n+            + \"  SUM(has_f3) as f3_count, \\n\"\n+            + \"  SUM(has_f4) as f4_count, \\n\"\n+            + \"  SUM(has_f5) as f5_count, \\n\"\n+            + \"  COUNT(*) as count, \\n\"\n+            + \"  SUM(has_f6) as f6_count  \\n\"\n+            + \"FROM (select 0 as id, 1 as has_f1, 2 as has_f2, 3 as has_f3, 4 as has_f4, 5 as has_f5, 6 as has_f6)\\n\"", "originalCommit": "42a39cd8400c201e3254ac5d49bd5c63589df860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU5NzQ2Ng==", "url": "https://github.com/apache/beam/pull/10649#discussion_r372597466", "bodyText": "Leaving as is for now.", "author": "11moon11", "createdAt": "2020-01-29T19:53:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwMzcyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwMzg1Nw==", "url": "https://github.com/apache/beam/pull/10649#discussion_r369303857", "bodyText": "Nit: you might can include a comment like \"this test is used to verify BEAM-8042\", which can provide some context for readers. But it's not required.", "author": "amaliujia", "createdAt": "2020-01-21T23:44:42Z", "path": "sdks/java/extensions/sql/zetasql/src/test/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSQLDialectSpecTest.java", "diffHunk": "@@ -1347,6 +1347,44 @@ public void testZetaSQLStructFieldAccessInTumble() {\n     pipeline.run().waitUntilFinish(Duration.standardMinutes(PIPELINE_EXECUTION_WAITTIME_MINUTES));\n   }\n \n+  @Test\n+  public void testAggregateWithAndWithoutColumnRefs() {", "originalCommit": "42a39cd8400c201e3254ac5d49bd5c63589df860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwNDI2OQ==", "url": "https://github.com/apache/beam/pull/10649#discussion_r369304269", "bodyText": "Great suggestions! Will add a message in a commit.", "author": "11moon11", "createdAt": "2020-01-21T23:46:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwMzg1Nw=="}], "type": "inlineReview"}, {"oid": "63b5e42b0398000c40e3276609fe3cafdfbe583a", "url": "https://github.com/apache/beam/commit/63b5e42b0398000c40e3276609fe3cafdfbe583a", "message": "Add comments", "committedDate": "2020-01-21T23:57:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY4NDIxMQ==", "url": "https://github.com/apache/beam/pull/10649#discussion_r369684211", "bodyText": "What happens if there is an aggregate function with more then a single argument, for instance, COUNTIF?", "author": "kanterov", "createdAt": "2020-01-22T17:00:14Z", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/AggregateScanConverter.java", "diffHunk": "@@ -88,8 +88,13 @@ public RelNode convert(ResolvedAggregateScan zetaNode, List<RelNode> inputs) {\n       // For aggregate calls, their input ref follow after GROUP BY input ref.\n       int columnRefoff = groupFieldsListSize;\n       for (ResolvedComputedColumn computedColumn : zetaNode.getAggregateList()) {\n-        aggregateCalls.add(convertAggCall(computedColumn, columnRefoff));\n-        columnRefoff++;\n+        AggregateCall aggCall = convertAggCall(computedColumn, columnRefoff);\n+        aggregateCalls.add(aggCall);\n+        if (!aggCall.getArgList().isEmpty()) {\n+          // Only increment column reference offset when aggregates use them (BEAM-8042).\n+          // Ex: COUNT(*) does not have arguments, while COUNT(`field`) does.\n+          columnRefoff++;", "originalCommit": "63b5e42b0398000c40e3276609fe3cafdfbe583a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTgwMjUxOA==", "url": "https://github.com/apache/beam/pull/10649#discussion_r369802518", "bodyText": "My understanding is that the boolean expression for COUNTIF aggregate will be computed in a precursory Project.\nAs of right now list of supported aggregate functions is limited to:\n\n  \n    \n      beam/sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/SqlStdOperatorMappingTable.java\n    \n    \n        Lines 181 to 189\n      in\n      659d84b\n    \n    \n    \n    \n\n        \n          \n           // built-in aggregate function \n        \n\n        \n          \n           .put(\"$count_star\", SqlStdOperatorTable.COUNT) \n        \n\n        \n          \n           // TODO: add support to all aggregate functions. \n        \n\n        \n          \n           .put(\"max\", SqlStdOperatorTable.MAX) \n        \n\n        \n          \n           .put(\"min\", SqlStdOperatorTable.MIN) \n        \n\n        \n          \n           .put(\"avg\", SqlStdOperatorTable.AVG) \n        \n\n        \n          \n           .put(\"sum\", SqlStdOperatorTable.SUM) \n        \n\n        \n          \n           // .put(\"any_value\", SqlStdOperatorTable.ANY_VALUE) \n        \n\n        \n          \n           .put(\"count\", SqlStdOperatorTable.COUNT)", "author": "11moon11", "createdAt": "2020-01-22T21:05:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY4NDIxMQ=="}], "type": "inlineReview"}]}