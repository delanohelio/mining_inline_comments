{"pr_number": 13154, "pr_title": "Implementing Python Bounded Source Reader DoFn", "pr_createdAt": "2020-10-20T21:06:35Z", "pr_url": "https://github.com/apache/beam/pull/13154", "timeline": [{"oid": "0ab8ea25a9bca227c4a2312c2c05063b7ab3a9f5", "url": "https://github.com/apache/beam/commit/0ab8ea25a9bca227c4a2312c2c05063b7ab3a9f5", "message": "Implementing Python Bounded Source Reader DoFn", "committedDate": "2020-10-20T21:52:13Z", "type": "commit"}, {"oid": "0ab8ea25a9bca227c4a2312c2c05063b7ab3a9f5", "url": "https://github.com/apache/beam/commit/0ab8ea25a9bca227c4a2312c2c05063b7ab3a9f5", "message": "Implementing Python Bounded Source Reader DoFn", "committedDate": "2020-10-20T21:52:13Z", "type": "forcePushed"}, {"oid": "c82f2d14dab6b28a00d60a00fe59d102b45b7dc4", "url": "https://github.com/apache/beam/commit/c82f2d14dab6b28a00d60a00fe59d102b45b7dc4", "message": "Adding annotations", "committedDate": "2020-10-22T20:17:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMjA3Ng==", "url": "https://github.com/apache/beam/pull/13154#discussion_r513112076", "bodyText": "It seems like the major difference between SDFBoundedSourceWrapper  and SDFBoundedSourceReader  is that SDFBoundedSourceWrapper takes the source as construction param where SDFBoundedSourceReader takes the source as input element. We could change the implementation of SDFBoundedSourceWrapper as well.", "author": "boyuanzz", "createdAt": "2020-10-28T00:36:51Z", "path": "sdks/python/apache_beam/io/iobase.py", "diffHunk": "@@ -1618,3 +1628,48 @@ def display_data(self):\n         'source': DisplayDataItem(self.source.__class__, label='Read Source'),\n         'source_dd': self.source\n     }\n+\n+\n+class SDFBoundedSourceReader(PTransform):", "originalCommit": "c82f2d14dab6b28a00d60a00fe59d102b45b7dc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY3MDk3Ng==", "url": "https://github.com/apache/beam/pull/13154#discussion_r513670976", "bodyText": "I've done this - but I've still allowed the source to come in via the constructor as well as as an input. The intention of doing this is to keep the display data for simple Read transforms where the source is known at construction time.", "author": "pabloem", "createdAt": "2020-10-28T18:27:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMjA3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc1ODgwNg==", "url": "https://github.com/apache/beam/pull/13154#discussion_r513758806", "bodyText": "I see. I thought we still keep _SDFBoundedSourceWrapper . Thanks for the clarification!", "author": "boyuanzz", "createdAt": "2020-10-28T21:03:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMjA3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc2NTI0Nw==", "url": "https://github.com/apache/beam/pull/13154#discussion_r513765247", "bodyText": "I'm thinking whether it would be better for SDFBoundedSourceReader  to take data_to_display as constructor instead of source directly if any. What do you think?", "author": "boyuanzz", "createdAt": "2020-10-28T21:15:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMjA3Ng=="}], "type": "inlineReview"}, {"oid": "7297e0a8e0e3f873afe490f83ec0e0eb3aba3ddf", "url": "https://github.com/apache/beam/commit/7297e0a8e0e3f873afe490f83ec0e0eb3aba3ddf", "message": "Wrapping BoundedSource out of a single implementation", "committedDate": "2020-10-28T18:26:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc1OTE5NQ==", "url": "https://github.com/apache/beam/pull/13154#discussion_r513759195", "bodyText": "We should be able to remote source here?", "author": "boyuanzz", "createdAt": "2020-10-28T21:04:23Z", "path": "sdks/python/apache_beam/io/iobase.py", "diffHunk": "@@ -1427,185 +1429,189 @@ def with_completed(self, completed):\n         fraction=self._fraction, remaining=self._remaining, completed=completed)\n \n \n-class _SDFBoundedSourceWrapper(ptransform.PTransform):\n-  \"\"\"A ``PTransform`` that uses SDF to read from a ``BoundedSource``.\n+class _SDFBoundedSourceRestriction(object):\n+  \"\"\" A restriction wraps SourceBundle and RangeTracker. \"\"\"\n+  def __init__(self, source_bundle, range_tracker=None):\n+    self._source_bundle = source_bundle\n+    self._range_tracker = range_tracker\n \n-  NOTE: This transform can only be used with beam_fn_api enabled.\n+  def __reduce__(self):\n+    # The instance of RangeTracker shouldn't be serialized.\n+    return (self.__class__, (self._source_bundle, ))\n+\n+  def range_tracker(self):\n+    if not self._range_tracker:\n+      self._range_tracker = self._source_bundle.source.get_range_tracker(\n+          self._source_bundle.start_position, self._source_bundle.stop_position)\n+    return self._range_tracker\n+\n+  def weight(self):\n+    return self._source_bundle.weight\n+\n+  def source(self):\n+    return self._source_bundle.source\n+\n+  def try_split(self, fraction_of_remainder):\n+    consumed_fraction = self.range_tracker().fraction_consumed()\n+    fraction = (\n+        consumed_fraction + (1 - consumed_fraction) * fraction_of_remainder)\n+    position = self.range_tracker().position_at_fraction(fraction)\n+    # Need to stash current stop_pos before splitting since\n+    # range_tracker.split will update its stop_pos if splits\n+    # successfully.\n+    stop_pos = self._source_bundle.stop_position\n+    split_result = self.range_tracker().try_split(position)\n+    if split_result:\n+      split_pos, split_fraction = split_result\n+      primary_weight = self._source_bundle.weight * split_fraction\n+      residual_weight = self._source_bundle.weight - primary_weight\n+      # Update self to primary weight and end position.\n+      self._source_bundle = SourceBundle(\n+          primary_weight,\n+          self._source_bundle.source,\n+          self._source_bundle.start_position,\n+          split_pos)\n+      return (\n+          self,\n+          _SDFBoundedSourceRestriction(\n+              SourceBundle(\n+                  residual_weight,\n+                  self._source_bundle.source,\n+                  split_pos,\n+                  stop_pos)))\n+\n+\n+class _SDFBoundedSourceRestrictionTracker(RestrictionTracker):\n+  \"\"\"An `iobase.RestrictionTracker` implementations for wrapping BoundedSource\n+  with SDF. The tracked restriction is a _SDFBoundedSourceRestriction, which\n+  wraps SourceBundle and RangeTracker.\n+\n+  Delegated RangeTracker guarantees synchronization safety.\n   \"\"\"\n-  class _SDFBoundedSourceRestriction(object):\n-    \"\"\" A restriction wraps SourceBundle and RangeTracker. \"\"\"\n-    def __init__(self, source_bundle, range_tracker=None):\n-      self._source_bundle = source_bundle\n-      self._range_tracker = range_tracker\n-\n-    def __reduce__(self):\n-      # The instance of RangeTracker shouldn't be serialized.\n-      return (self.__class__, (self._source_bundle, ))\n-\n-    def range_tracker(self):\n-      if not self._range_tracker:\n-        self._range_tracker = self._source_bundle.source.get_range_tracker(\n-            self._source_bundle.start_position,\n-            self._source_bundle.stop_position)\n-      return self._range_tracker\n-\n-    def weight(self):\n-      return self._source_bundle.weight\n-\n-    def source(self):\n-      return self._source_bundle.source\n-\n-    def try_split(self, fraction_of_remainder):\n-      consumed_fraction = self.range_tracker().fraction_consumed()\n-      fraction = (\n-          consumed_fraction + (1 - consumed_fraction) * fraction_of_remainder)\n-      position = self.range_tracker().position_at_fraction(fraction)\n-      # Need to stash current stop_pos before splitting since\n-      # range_tracker.split will update its stop_pos if splits\n-      # successfully.\n-      stop_pos = self._source_bundle.stop_position\n-      split_result = self.range_tracker().try_split(position)\n-      if split_result:\n-        split_pos, split_fraction = split_result\n-        primary_weight = self._source_bundle.weight * split_fraction\n-        residual_weight = self._source_bundle.weight - primary_weight\n-        # Update self to primary weight and end position.\n-        self._source_bundle = SourceBundle(\n-            primary_weight,\n-            self._source_bundle.source,\n-            self._source_bundle.start_position,\n-            split_pos)\n-        return (\n-            self,\n-            _SDFBoundedSourceWrapper._SDFBoundedSourceRestriction(\n-                SourceBundle(\n-                    residual_weight,\n-                    self._source_bundle.source,\n-                    split_pos,\n-                    stop_pos)))\n-\n-  class _SDFBoundedSourceRestrictionTracker(RestrictionTracker):\n-    \"\"\"An `iobase.RestrictionTracker` implementations for wrapping BoundedSource\n-    with SDF. The tracked restriction is a _SDFBoundedSourceRestriction, which\n-    wraps SourceBundle and RangeTracker.\n-\n-    Delegated RangeTracker guarantees synchronization safety.\n-    \"\"\"\n-    def __init__(self, restriction):\n-      if not isinstance(restriction,\n-                        _SDFBoundedSourceWrapper._SDFBoundedSourceRestriction):\n-        raise ValueError(\n-            'Initializing SDFBoundedSourceRestrictionTracker'\n-            ' requires a _SDFBoundedSourceRestriction')\n-      self.restriction = restriction\n-\n-    def current_progress(self):\n-      # type: () -> RestrictionProgress\n-      return RestrictionProgress(\n-          fraction=self.restriction.range_tracker().fraction_consumed())\n-\n-    def current_restriction(self):\n-      self.restriction.range_tracker()\n-      return self.restriction\n-\n-    def start_pos(self):\n-      return self.restriction.range_tracker().start_position()\n-\n-    def stop_pos(self):\n-      return self.restriction.range_tracker().stop_position()\n-\n-    def try_claim(self, position):\n-      return self.restriction.range_tracker().try_claim(position)\n-\n-    def try_split(self, fraction_of_remainder):\n-      return self.restriction.try_split(fraction_of_remainder)\n-\n-    def check_done(self):\n-      return self.restriction.range_tracker().fraction_consumed() >= 1.0\n-\n-    def is_bounded(self):\n-      return True\n-\n-  class _SDFBoundedSourceRestrictionProvider(core.RestrictionProvider):\n-    \"\"\"A `RestrictionProvider` that is used by SDF for `BoundedSource`.\"\"\"\n-    def __init__(self, source, desired_chunk_size=None):\n-      self._source = source\n-      self._desired_chunk_size = desired_chunk_size\n-\n-    def initial_restriction(self, element):\n-      # Get initial range_tracker from source\n-      range_tracker = self._source.get_range_tracker(None, None)\n-      return _SDFBoundedSourceWrapper._SDFBoundedSourceRestriction(\n-          SourceBundle(\n-              None,\n-              self._source,\n-              range_tracker.start_position(),\n-              range_tracker.stop_position()))\n-\n-    def create_tracker(self, restriction):\n-      return _SDFBoundedSourceWrapper._SDFBoundedSourceRestrictionTracker(\n-          restriction)\n-\n-    def split(self, element, restriction):\n-      if self._desired_chunk_size is None:\n-        try:\n-          estimated_size = self._source.estimate_size()\n-        except NotImplementedError:\n-          estimated_size = None\n-        self._desired_chunk_size = Read.get_desired_chunk_size(estimated_size)\n-\n-      # Invoke source.split to get initial splitting results.\n-      source_bundles = self._source.split(self._desired_chunk_size)\n-      for source_bundle in source_bundles:\n-        yield _SDFBoundedSourceWrapper._SDFBoundedSourceRestriction(\n-            source_bundle)\n-\n-    def restriction_size(self, element, restriction):\n-      return restriction.weight()\n-\n-    def restriction_coder(self):\n-      return coders.DillCoder()\n+  def __init__(self, restriction):\n+    if not isinstance(restriction, _SDFBoundedSourceRestriction):\n+      raise ValueError(\n+          'Initializing SDFBoundedSourceRestrictionTracker'\n+          ' requires a _SDFBoundedSourceRestriction')\n+    self.restriction = restriction\n \n-  def __init__(self, source):\n-    if not isinstance(source, BoundedSource):\n-      raise RuntimeError('SDFBoundedSourceWrapper can only wrap BoundedSource')\n-    super(_SDFBoundedSourceWrapper, self).__init__()\n+  def current_progress(self):\n+    # type: () -> RestrictionProgress\n+    return RestrictionProgress(\n+        fraction=self.restriction.range_tracker().fraction_consumed())\n+\n+  def current_restriction(self):\n+    self.restriction.range_tracker()\n+    return self.restriction\n+\n+  def start_pos(self):\n+    return self.restriction.range_tracker().start_position()\n+\n+  def stop_pos(self):\n+    return self.restriction.range_tracker().stop_position()\n+\n+  def try_claim(self, position):\n+    return self.restriction.range_tracker().try_claim(position)\n+\n+  def try_split(self, fraction_of_remainder):\n+    return self.restriction.try_split(fraction_of_remainder)\n+\n+  def check_done(self):\n+    return self.restriction.range_tracker().fraction_consumed() >= 1.0\n+\n+  def is_bounded(self):\n+    return True\n+\n+\n+class _SDFBoundedSourceRestrictionProvider(core.RestrictionProvider):\n+  \"\"\"\n+  A `RestrictionProvider` that is used by SDF for `BoundedSource`.\n+\n+  If source is provided, uses it for initializing restriction. Otherwise\n+  initializes restriction based on input element that is expected to be of\n+  BoundedSource type.\n+  \"\"\"\n+  def __init__(self, source: BoundedSource = None, desired_chunk_size=None):", "originalCommit": "7297e0a8e0e3f873afe490f83ec0e0eb3aba3ddf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "db7aafd23a307a3824c9bfd8a0d60363a6aca3bd", "url": "https://github.com/apache/beam/commit/db7aafd23a307a3824c9bfd8a0d60363a6aca3bd", "message": "Fixup", "committedDate": "2020-10-29T00:48:50Z", "type": "commit"}, {"oid": "d0a15099de62d1b7a9b08a8378f816e624b816ac", "url": "https://github.com/apache/beam/commit/d0a15099de62d1b7a9b08a8378f816e624b816ac", "message": "Fix formatter", "committedDate": "2020-10-29T03:37:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ0NjQwMA==", "url": "https://github.com/apache/beam/pull/13154#discussion_r514446400", "bodyText": "It seems like we also need to update pydoc here as well.", "author": "boyuanzz", "createdAt": "2020-10-29T17:39:28Z", "path": "sdks/python/apache_beam/io/iobase.py", "diffHunk": "@@ -1427,194 +1432,184 @@ def with_completed(self, completed):\n         fraction=self._fraction, remaining=self._remaining, completed=completed)\n \n \n-class _SDFBoundedSourceWrapper(ptransform.PTransform):\n-  \"\"\"A ``PTransform`` that uses SDF to read from a ``BoundedSource``.\n+class _SDFBoundedSourceRestriction(object):\n+  \"\"\" A restriction wraps SourceBundle and RangeTracker. \"\"\"\n+  def __init__(self, source_bundle, range_tracker=None):\n+    self._source_bundle = source_bundle\n+    self._range_tracker = range_tracker\n \n-  NOTE: This transform can only be used with beam_fn_api enabled.\n+  def __reduce__(self):\n+    # The instance of RangeTracker shouldn't be serialized.\n+    return (self.__class__, (self._source_bundle, ))\n+\n+  def range_tracker(self):\n+    if not self._range_tracker:\n+      self._range_tracker = self._source_bundle.source.get_range_tracker(\n+          self._source_bundle.start_position, self._source_bundle.stop_position)\n+    return self._range_tracker\n+\n+  def weight(self):\n+    return self._source_bundle.weight\n+\n+  def source(self):\n+    return self._source_bundle.source\n+\n+  def try_split(self, fraction_of_remainder):\n+    consumed_fraction = self.range_tracker().fraction_consumed()\n+    fraction = (\n+        consumed_fraction + (1 - consumed_fraction) * fraction_of_remainder)\n+    position = self.range_tracker().position_at_fraction(fraction)\n+    # Need to stash current stop_pos before splitting since\n+    # range_tracker.split will update its stop_pos if splits\n+    # successfully.\n+    stop_pos = self._source_bundle.stop_position\n+    split_result = self.range_tracker().try_split(position)\n+    if split_result:\n+      split_pos, split_fraction = split_result\n+      primary_weight = self._source_bundle.weight * split_fraction\n+      residual_weight = self._source_bundle.weight - primary_weight\n+      # Update self to primary weight and end position.\n+      self._source_bundle = SourceBundle(\n+          primary_weight,\n+          self._source_bundle.source,\n+          self._source_bundle.start_position,\n+          split_pos)\n+      return (\n+          self,\n+          _SDFBoundedSourceRestriction(\n+              SourceBundle(\n+                  residual_weight,\n+                  self._source_bundle.source,\n+                  split_pos,\n+                  stop_pos)))\n+\n+\n+class _SDFBoundedSourceRestrictionTracker(RestrictionTracker):\n+  \"\"\"An `iobase.RestrictionTracker` implementations for wrapping BoundedSource\n+  with SDF. The tracked restriction is a _SDFBoundedSourceRestriction, which\n+  wraps SourceBundle and RangeTracker.\n+\n+  Delegated RangeTracker guarantees synchronization safety.\n   \"\"\"\n-  class _SDFBoundedSourceRestriction(object):\n-    \"\"\" A restriction wraps SourceBundle and RangeTracker. \"\"\"\n-    def __init__(self, source_bundle, range_tracker=None):\n-      self._source_bundle = source_bundle\n-      self._range_tracker = range_tracker\n-\n-    def __reduce__(self):\n-      # The instance of RangeTracker shouldn't be serialized.\n-      return (self.__class__, (self._source_bundle, ))\n-\n-    def range_tracker(self):\n-      if not self._range_tracker:\n-        self._range_tracker = self._source_bundle.source.get_range_tracker(\n-            self._source_bundle.start_position,\n-            self._source_bundle.stop_position)\n-      return self._range_tracker\n-\n-    def weight(self):\n-      return self._source_bundle.weight\n-\n-    def source(self):\n-      return self._source_bundle.source\n-\n-    def try_split(self, fraction_of_remainder):\n-      consumed_fraction = self.range_tracker().fraction_consumed()\n-      fraction = (\n-          consumed_fraction + (1 - consumed_fraction) * fraction_of_remainder)\n-      position = self.range_tracker().position_at_fraction(fraction)\n-      # Need to stash current stop_pos before splitting since\n-      # range_tracker.split will update its stop_pos if splits\n-      # successfully.\n-      stop_pos = self._source_bundle.stop_position\n-      split_result = self.range_tracker().try_split(position)\n-      if split_result:\n-        split_pos, split_fraction = split_result\n-        primary_weight = self._source_bundle.weight * split_fraction\n-        residual_weight = self._source_bundle.weight - primary_weight\n-        # Update self to primary weight and end position.\n-        self._source_bundle = SourceBundle(\n-            primary_weight,\n-            self._source_bundle.source,\n-            self._source_bundle.start_position,\n-            split_pos)\n-        return (\n-            self,\n-            _SDFBoundedSourceWrapper._SDFBoundedSourceRestriction(\n-                SourceBundle(\n-                    residual_weight,\n-                    self._source_bundle.source,\n-                    split_pos,\n-                    stop_pos)))\n-\n-  class _SDFBoundedSourceRestrictionTracker(RestrictionTracker):\n-    \"\"\"An `iobase.RestrictionTracker` implementations for wrapping BoundedSource\n-    with SDF. The tracked restriction is a _SDFBoundedSourceRestriction, which\n-    wraps SourceBundle and RangeTracker.\n-\n-    Delegated RangeTracker guarantees synchronization safety.\n-    \"\"\"\n-    def __init__(self, restriction):\n-      if not isinstance(restriction,\n-                        _SDFBoundedSourceWrapper._SDFBoundedSourceRestriction):\n-        raise ValueError(\n-            'Initializing SDFBoundedSourceRestrictionTracker'\n-            ' requires a _SDFBoundedSourceRestriction')\n-      self.restriction = restriction\n-\n-    def current_progress(self):\n-      # type: () -> RestrictionProgress\n-      return RestrictionProgress(\n-          fraction=self.restriction.range_tracker().fraction_consumed())\n-\n-    def current_restriction(self):\n-      self.restriction.range_tracker()\n-      return self.restriction\n-\n-    def start_pos(self):\n-      return self.restriction.range_tracker().start_position()\n-\n-    def stop_pos(self):\n-      return self.restriction.range_tracker().stop_position()\n-\n-    def try_claim(self, position):\n-      return self.restriction.range_tracker().try_claim(position)\n-\n-    def try_split(self, fraction_of_remainder):\n-      return self.restriction.try_split(fraction_of_remainder)\n-\n-    def check_done(self):\n-      return self.restriction.range_tracker().fraction_consumed() >= 1.0\n-\n-    def is_bounded(self):\n-      return True\n-\n-  class _SDFBoundedSourceRestrictionProvider(core.RestrictionProvider):\n-    \"\"\"A `RestrictionProvider` that is used by SDF for `BoundedSource`.\"\"\"\n-    def __init__(self, source, desired_chunk_size=None):\n-      self._source = source\n-      self._desired_chunk_size = desired_chunk_size\n-\n-    def initial_restriction(self, element):\n-      # Get initial range_tracker from source\n-      range_tracker = self._source.get_range_tracker(None, None)\n-      return _SDFBoundedSourceWrapper._SDFBoundedSourceRestriction(\n-          SourceBundle(\n-              None,\n-              self._source,\n-              range_tracker.start_position(),\n-              range_tracker.stop_position()))\n-\n-    def create_tracker(self, restriction):\n-      return _SDFBoundedSourceWrapper._SDFBoundedSourceRestrictionTracker(\n-          restriction)\n-\n-    def split(self, element, restriction):\n-      if self._desired_chunk_size is None:\n-        try:\n-          estimated_size = self._source.estimate_size()\n-        except NotImplementedError:\n-          estimated_size = None\n-        self._desired_chunk_size = Read.get_desired_chunk_size(estimated_size)\n-\n-      # Invoke source.split to get initial splitting results.\n-      source_bundles = self._source.split(self._desired_chunk_size)\n-      for source_bundle in source_bundles:\n-        yield _SDFBoundedSourceWrapper._SDFBoundedSourceRestriction(\n-            source_bundle)\n-\n-    def restriction_size(self, element, restriction):\n-      return restriction.weight()\n-\n-    def restriction_coder(self):\n-      return coders.DillCoder()\n+  def __init__(self, restriction):\n+    if not isinstance(restriction, _SDFBoundedSourceRestriction):\n+      raise ValueError(\n+          'Initializing SDFBoundedSourceRestrictionTracker'\n+          ' requires a _SDFBoundedSourceRestriction')\n+    self.restriction = restriction\n \n-  def __init__(self, source):\n-    if not isinstance(source, BoundedSource):\n-      raise RuntimeError('SDFBoundedSourceWrapper can only wrap BoundedSource')\n-    super(_SDFBoundedSourceWrapper, self).__init__()\n-    self.source = source\n+  def current_progress(self):\n+    # type: () -> RestrictionProgress\n+    return RestrictionProgress(\n+        fraction=self.restriction.range_tracker().fraction_consumed())\n \n-  def _create_sdf_bounded_source_dofn(self):\n-    source = self.source\n+  def current_restriction(self):\n+    self.restriction.range_tracker()\n+    return self.restriction\n \n-    class SDFBoundedSourceDoFn(core.DoFn):\n-      def __init__(self, read_source):\n-        self.source = read_source\n+  def start_pos(self):\n+    return self.restriction.range_tracker().start_position()\n+\n+  def stop_pos(self):\n+    return self.restriction.range_tracker().stop_position()\n+\n+  def try_claim(self, position):\n+    return self.restriction.range_tracker().try_claim(position)\n \n-      def display_data(self):\n-        return {\n-            'source': DisplayDataItem(\n-                self.source.__class__, label='Read Source'),\n-            'source_dd': self.source\n-        }\n+  def try_split(self, fraction_of_remainder):\n+    return self.restriction.try_split(fraction_of_remainder)\n+\n+  def check_done(self):\n+    return self.restriction.range_tracker().fraction_consumed() >= 1.0\n+\n+  def is_bounded(self):\n+    return True\n+\n+\n+class _SDFBoundedSourceRestrictionProvider(core.RestrictionProvider):\n+  \"\"\"\n+  A `RestrictionProvider` that is used by SDF for `BoundedSource`.\n+\n+  If source is provided, uses it for initializing restriction. Otherwise", "originalCommit": "d0a15099de62d1b7a9b08a8378f816e624b816ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ1NzM4OQ==", "url": "https://github.com/apache/beam/pull/13154#discussion_r514457389", "bodyText": "The src cannot be None, right?", "author": "boyuanzz", "createdAt": "2020-10-29T17:56:10Z", "path": "sdks/python/apache_beam/io/iobase.py", "diffHunk": "@@ -1427,194 +1432,184 @@ def with_completed(self, completed):\n         fraction=self._fraction, remaining=self._remaining, completed=completed)\n \n \n-class _SDFBoundedSourceWrapper(ptransform.PTransform):\n-  \"\"\"A ``PTransform`` that uses SDF to read from a ``BoundedSource``.\n+class _SDFBoundedSourceRestriction(object):\n+  \"\"\" A restriction wraps SourceBundle and RangeTracker. \"\"\"\n+  def __init__(self, source_bundle, range_tracker=None):\n+    self._source_bundle = source_bundle\n+    self._range_tracker = range_tracker\n \n-  NOTE: This transform can only be used with beam_fn_api enabled.\n+  def __reduce__(self):\n+    # The instance of RangeTracker shouldn't be serialized.\n+    return (self.__class__, (self._source_bundle, ))\n+\n+  def range_tracker(self):\n+    if not self._range_tracker:\n+      self._range_tracker = self._source_bundle.source.get_range_tracker(\n+          self._source_bundle.start_position, self._source_bundle.stop_position)\n+    return self._range_tracker\n+\n+  def weight(self):\n+    return self._source_bundle.weight\n+\n+  def source(self):\n+    return self._source_bundle.source\n+\n+  def try_split(self, fraction_of_remainder):\n+    consumed_fraction = self.range_tracker().fraction_consumed()\n+    fraction = (\n+        consumed_fraction + (1 - consumed_fraction) * fraction_of_remainder)\n+    position = self.range_tracker().position_at_fraction(fraction)\n+    # Need to stash current stop_pos before splitting since\n+    # range_tracker.split will update its stop_pos if splits\n+    # successfully.\n+    stop_pos = self._source_bundle.stop_position\n+    split_result = self.range_tracker().try_split(position)\n+    if split_result:\n+      split_pos, split_fraction = split_result\n+      primary_weight = self._source_bundle.weight * split_fraction\n+      residual_weight = self._source_bundle.weight - primary_weight\n+      # Update self to primary weight and end position.\n+      self._source_bundle = SourceBundle(\n+          primary_weight,\n+          self._source_bundle.source,\n+          self._source_bundle.start_position,\n+          split_pos)\n+      return (\n+          self,\n+          _SDFBoundedSourceRestriction(\n+              SourceBundle(\n+                  residual_weight,\n+                  self._source_bundle.source,\n+                  split_pos,\n+                  stop_pos)))\n+\n+\n+class _SDFBoundedSourceRestrictionTracker(RestrictionTracker):\n+  \"\"\"An `iobase.RestrictionTracker` implementations for wrapping BoundedSource\n+  with SDF. The tracked restriction is a _SDFBoundedSourceRestriction, which\n+  wraps SourceBundle and RangeTracker.\n+\n+  Delegated RangeTracker guarantees synchronization safety.\n   \"\"\"\n-  class _SDFBoundedSourceRestriction(object):\n-    \"\"\" A restriction wraps SourceBundle and RangeTracker. \"\"\"\n-    def __init__(self, source_bundle, range_tracker=None):\n-      self._source_bundle = source_bundle\n-      self._range_tracker = range_tracker\n-\n-    def __reduce__(self):\n-      # The instance of RangeTracker shouldn't be serialized.\n-      return (self.__class__, (self._source_bundle, ))\n-\n-    def range_tracker(self):\n-      if not self._range_tracker:\n-        self._range_tracker = self._source_bundle.source.get_range_tracker(\n-            self._source_bundle.start_position,\n-            self._source_bundle.stop_position)\n-      return self._range_tracker\n-\n-    def weight(self):\n-      return self._source_bundle.weight\n-\n-    def source(self):\n-      return self._source_bundle.source\n-\n-    def try_split(self, fraction_of_remainder):\n-      consumed_fraction = self.range_tracker().fraction_consumed()\n-      fraction = (\n-          consumed_fraction + (1 - consumed_fraction) * fraction_of_remainder)\n-      position = self.range_tracker().position_at_fraction(fraction)\n-      # Need to stash current stop_pos before splitting since\n-      # range_tracker.split will update its stop_pos if splits\n-      # successfully.\n-      stop_pos = self._source_bundle.stop_position\n-      split_result = self.range_tracker().try_split(position)\n-      if split_result:\n-        split_pos, split_fraction = split_result\n-        primary_weight = self._source_bundle.weight * split_fraction\n-        residual_weight = self._source_bundle.weight - primary_weight\n-        # Update self to primary weight and end position.\n-        self._source_bundle = SourceBundle(\n-            primary_weight,\n-            self._source_bundle.source,\n-            self._source_bundle.start_position,\n-            split_pos)\n-        return (\n-            self,\n-            _SDFBoundedSourceWrapper._SDFBoundedSourceRestriction(\n-                SourceBundle(\n-                    residual_weight,\n-                    self._source_bundle.source,\n-                    split_pos,\n-                    stop_pos)))\n-\n-  class _SDFBoundedSourceRestrictionTracker(RestrictionTracker):\n-    \"\"\"An `iobase.RestrictionTracker` implementations for wrapping BoundedSource\n-    with SDF. The tracked restriction is a _SDFBoundedSourceRestriction, which\n-    wraps SourceBundle and RangeTracker.\n-\n-    Delegated RangeTracker guarantees synchronization safety.\n-    \"\"\"\n-    def __init__(self, restriction):\n-      if not isinstance(restriction,\n-                        _SDFBoundedSourceWrapper._SDFBoundedSourceRestriction):\n-        raise ValueError(\n-            'Initializing SDFBoundedSourceRestrictionTracker'\n-            ' requires a _SDFBoundedSourceRestriction')\n-      self.restriction = restriction\n-\n-    def current_progress(self):\n-      # type: () -> RestrictionProgress\n-      return RestrictionProgress(\n-          fraction=self.restriction.range_tracker().fraction_consumed())\n-\n-    def current_restriction(self):\n-      self.restriction.range_tracker()\n-      return self.restriction\n-\n-    def start_pos(self):\n-      return self.restriction.range_tracker().start_position()\n-\n-    def stop_pos(self):\n-      return self.restriction.range_tracker().stop_position()\n-\n-    def try_claim(self, position):\n-      return self.restriction.range_tracker().try_claim(position)\n-\n-    def try_split(self, fraction_of_remainder):\n-      return self.restriction.try_split(fraction_of_remainder)\n-\n-    def check_done(self):\n-      return self.restriction.range_tracker().fraction_consumed() >= 1.0\n-\n-    def is_bounded(self):\n-      return True\n-\n-  class _SDFBoundedSourceRestrictionProvider(core.RestrictionProvider):\n-    \"\"\"A `RestrictionProvider` that is used by SDF for `BoundedSource`.\"\"\"\n-    def __init__(self, source, desired_chunk_size=None):\n-      self._source = source\n-      self._desired_chunk_size = desired_chunk_size\n-\n-    def initial_restriction(self, element):\n-      # Get initial range_tracker from source\n-      range_tracker = self._source.get_range_tracker(None, None)\n-      return _SDFBoundedSourceWrapper._SDFBoundedSourceRestriction(\n-          SourceBundle(\n-              None,\n-              self._source,\n-              range_tracker.start_position(),\n-              range_tracker.stop_position()))\n-\n-    def create_tracker(self, restriction):\n-      return _SDFBoundedSourceWrapper._SDFBoundedSourceRestrictionTracker(\n-          restriction)\n-\n-    def split(self, element, restriction):\n-      if self._desired_chunk_size is None:\n-        try:\n-          estimated_size = self._source.estimate_size()\n-        except NotImplementedError:\n-          estimated_size = None\n-        self._desired_chunk_size = Read.get_desired_chunk_size(estimated_size)\n-\n-      # Invoke source.split to get initial splitting results.\n-      source_bundles = self._source.split(self._desired_chunk_size)\n-      for source_bundle in source_bundles:\n-        yield _SDFBoundedSourceWrapper._SDFBoundedSourceRestriction(\n-            source_bundle)\n-\n-    def restriction_size(self, element, restriction):\n-      return restriction.weight()\n-\n-    def restriction_coder(self):\n-      return coders.DillCoder()\n+  def __init__(self, restriction):\n+    if not isinstance(restriction, _SDFBoundedSourceRestriction):\n+      raise ValueError(\n+          'Initializing SDFBoundedSourceRestrictionTracker'\n+          ' requires a _SDFBoundedSourceRestriction')\n+    self.restriction = restriction\n \n-  def __init__(self, source):\n-    if not isinstance(source, BoundedSource):\n-      raise RuntimeError('SDFBoundedSourceWrapper can only wrap BoundedSource')\n-    super(_SDFBoundedSourceWrapper, self).__init__()\n-    self.source = source\n+  def current_progress(self):\n+    # type: () -> RestrictionProgress\n+    return RestrictionProgress(\n+        fraction=self.restriction.range_tracker().fraction_consumed())\n \n-  def _create_sdf_bounded_source_dofn(self):\n-    source = self.source\n+  def current_restriction(self):\n+    self.restriction.range_tracker()\n+    return self.restriction\n \n-    class SDFBoundedSourceDoFn(core.DoFn):\n-      def __init__(self, read_source):\n-        self.source = read_source\n+  def start_pos(self):\n+    return self.restriction.range_tracker().start_position()\n+\n+  def stop_pos(self):\n+    return self.restriction.range_tracker().stop_position()\n+\n+  def try_claim(self, position):\n+    return self.restriction.range_tracker().try_claim(position)\n \n-      def display_data(self):\n-        return {\n-            'source': DisplayDataItem(\n-                self.source.__class__, label='Read Source'),\n-            'source_dd': self.source\n-        }\n+  def try_split(self, fraction_of_remainder):\n+    return self.restriction.try_split(fraction_of_remainder)\n+\n+  def check_done(self):\n+    return self.restriction.range_tracker().fraction_consumed() >= 1.0\n+\n+  def is_bounded(self):\n+    return True\n+\n+\n+class _SDFBoundedSourceRestrictionProvider(core.RestrictionProvider):\n+  \"\"\"\n+  A `RestrictionProvider` that is used by SDF for `BoundedSource`.\n+\n+  If source is provided, uses it for initializing restriction. Otherwise\n+  initializes restriction based on input element that is expected to be of\n+  BoundedSource type.\n+  \"\"\"\n+  def __init__(self, desired_chunk_size=None):\n+    self._desired_chunk_size = desired_chunk_size\n+\n+  def _check_source(self, src):\n+    if src is not None and not isinstance(src, BoundedSource):", "originalCommit": "d0a15099de62d1b7a9b08a8378f816e624b816ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c16e3b355dc873abebc9d16f0b46280ed8e9dd28", "url": "https://github.com/apache/beam/commit/c16e3b355dc873abebc9d16f0b46280ed8e9dd28", "message": "fixup", "committedDate": "2020-10-29T18:31:38Z", "type": "commit"}, {"oid": "4934da1246b4f0e71f90376be8ab1d9dc41599dc", "url": "https://github.com/apache/beam/commit/4934da1246b4f0e71f90376be8ab1d9dc41599dc", "message": "fixup", "committedDate": "2020-11-03T19:50:28Z", "type": "commit"}, {"oid": "ac09ae07a026ed9c26249984e6a229ad74566459", "url": "https://github.com/apache/beam/commit/ac09ae07a026ed9c26249984e6a229ad74566459", "message": "fix formatting", "committedDate": "2020-11-03T20:35:40Z", "type": "commit"}, {"oid": "050cd4c4ac7d5bab49b5a041f924ed3f86864b6d", "url": "https://github.com/apache/beam/commit/050cd4c4ac7d5bab49b5a041f924ed3f86864b6d", "message": "fixup", "committedDate": "2020-11-03T21:52:16Z", "type": "commit"}]}