{"pr_number": 13005, "pr_title": "Add python schema inference docs", "pr_createdAt": "2020-10-02T22:27:16Z", "pr_url": "https://github.com/apache/beam/pull/13005", "timeline": [{"oid": "b370b4c457e91eaa031c6f8edbe8b4a196dd6461", "url": "https://github.com/apache/beam/commit/b370b4c457e91eaa031c6f8edbe8b4a196dd6461", "message": "Add python schema inference docs", "committedDate": "2020-10-02T22:26:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4NjMzMA==", "url": "https://github.com/apache/beam/pull/13005#discussion_r499786330", "bodyText": "Is it worth calling out Select as well?", "author": "robertwb", "createdAt": "2020-10-05T18:20:06Z", "path": "website/www/site/content/en/documentation/programming-guide.md", "diffHunk": "@@ -2546,10 +2611,68 @@ public abstract class TransactionValue {\n }\n {{< /highlight >}}\n \n+{{< paragraph class=\"language-java\" >}}\n This is all that\u2019s needed to generate a simple AutoValue class, and the above `@DefaultSchema` annotation tells Beam to\n infer a schema from it. This also allows AutoValue elements to be used inside of `PCollection`s.\n+{{< /paragraph >}}\n \n+{{< paragraph class=\"language-java\" >}}\n `@SchemaFieldName` and `@SchemaIgnore` can be used to alter the schema inferred.\n+{{< /paragraph >}}\n+\n+{{< paragraph class=\"language-py\" >}}\n+Beam has a few different mechanisms for inferring schemas from Python code.\n+{{< /paragraph >}}\n+\n+{{< paragraph class=\"language-py\" >}}\n+**NamedTuple classes**\n+{{< /paragraph >}}\n+\n+{{< paragraph class=\"language-py\" >}}\n+A [NamedTuple](https://docs.python.org/3/library/typing.html#typing.NamedTuple)\n+class is a Python class that wraps a `tuple`, assigning a name to each element\n+and restricting it to a particular type. Beam will automatically infer the\n+schema for PCollections with `NamedTuple` output types. For example:\n+{{< /paragraph >}}\n+\n+{{< highlight py >}}\n+class Transaction(typing.NamedTuple):\n+  bank: str\n+  purchase_amount: float\n+\n+pc = input | beam.Map(lambda ...).with_output_types(Transaction)\n+{{< /highlight >}}\n+\n+\n+{{< paragraph class=\"language-py\" >}}\n+**beam.Row**\n+{{< /paragraph >}}\n+\n+{{< paragraph class=\"language-py\" >}}\n+It's also possible to create ad-hoc schema declarations with a simple lambda\n+that returns instances of `beam.Row`:\n+{{< /paragraph >}}\n+\n+{{< highlight py >}}\n+input_pc = ... # {\"bank\": ..., \"purchase_amount\": ...}\n+output_pc = input_pc | beam.Map(lambda item: beam.Row(bank=item[\"bank\"],\n+                                                      purchase_amount=item[\"purchase_amount\"])\n+{{< /highlight >}}\n+\n+{{< paragraph class=\"language-py\" >}}\n+Note that this declaration doesn't include any specific information about the\n+types of the `bank` and `purchase_amount` fields. Beam will attempt to infer\n+type information, if it's unable to it will fall back to the generic type\n+`Any`. Sometimes this is not ideal, you can use casts to make sure Beam\n+correctly infers types with `beam.Row`:\n+{{< /paragraph >}}\n+\n+{{< highlight py >}}\n+input_pc = ... # {\"bank\": ..., \"purchase_amount\": ...}\n+output_pc = input_pc | beam.Map(lambda item: beam.Row(bank=str(item[\"bank\"]),\n+                                                      purchase_amount=float(item[\"purchase_amount\"]))\n+{{< /highlight >}}\n+", "originalCommit": "b370b4c457e91eaa031c6f8edbe8b4a196dd6461", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM3MjE1MQ==", "url": "https://github.com/apache/beam/pull/13005#discussion_r501372151", "bodyText": "Good idea! I'll add it in a separate PR and we can merge it once Select is available in 2.25.0", "author": "TheNeuralBit", "createdAt": "2020-10-07T23:46:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4NjMzMA=="}], "type": "inlineReview"}]}