{"pr_number": 11763, "pr_title": "[BEAM-9978] Adding functionality and tests to Go offset range tracker.", "pr_createdAt": "2020-05-20T19:08:50Z", "pr_url": "https://github.com/apache/beam/pull/11763", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNTc3OA==", "url": "https://github.com/apache/beam/pull/11763#discussion_r428305778", "bodyText": "Stylistically, I'd move this inline into the if instread of putting into the variable.", "author": "lostluck", "createdAt": "2020-05-20T21:02:55Z", "path": "sdks/go/pkg/beam/io/rtrackers/offsetrange/offsetrange_test.go", "diffHunk": "@@ -0,0 +1,212 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package offsetrange\n+\n+import (\n+\t\"fmt\"\n+\t\"github.com/google/go-cmp/cmp\"\n+\t\"testing\"\n+)\n+\n+// TestRestriction_EvenSplits tests various splits and checks that they all\n+// follow the contract for EvenSplits. This means that all restrictions are\n+// evenly split, that each restriction has at least one element, and that each\n+// element is present in the split restrictions.\n+func TestRestriction_EvenSplits(t *testing.T) {\n+\ttests := []struct {\n+\t\trest Restriction\n+\t\tnum  int64\n+\t}{\n+\t\t{rest: Restriction{Start: 0, End: 21}, num: 4},\n+\t\t{rest: Restriction{Start: 21, End: 42}, num: 4},\n+\t\t{rest: Restriction{Start: 0, End: 5}, num: 10},\n+\t\t{rest: Restriction{Start: 0, End: 21}, num: -1},\n+\t}\n+\tfor _, test := range tests {\n+\t\ttest := test\n+\t\tt.Run(fmt.Sprintf(\"(rest[%v, %v], splits = %v)\",\n+\t\t\ttest.rest.Start, test.rest.End, test.num), func(t *testing.T) {\n+\t\t\tr := test.rest\n+\n+\t\t\t// Get the minimum size that a split restriction can be. Max size\n+\t\t\t// should be min + 1. This way we can check the size of each split.\n+\t\t\tnum := test.num\n+\t\t\tif num <= 1 {\n+\t\t\t\tnum = 1\n+\t\t\t}\n+\t\t\tmin := (r.End - r.Start) / num\n+\n+\t\t\tsplits := r.EvenSplits(test.num)\n+\t\t\tprevEnd := r.Start\n+\t\t\tfor _, split := range splits {\n+\t\t\t\tsize := split.End - split.Start\n+\t\t\t\t// Check: Each restriction has at least 1 element.\n+\t\t\t\tif size == 0 {\n+\t\t\t\t\tt.Errorf(\"split restriction [%v, %v] is empty, size must be greater than 0.\",\n+\t\t\t\t\t\tsplit.Start, split.End)\n+\t\t\t\t}\n+\t\t\t\t// Check: Restrictions are evenly split.\n+\t\t\t\tif size != min && size != min+1 {\n+\t\t\t\t\tt.Errorf(\"split restriction [%v, %v] has unexpected size. got: %v, want: %v or %v\",\n+\t\t\t\t\t\tsplit.Start, split.End, size, min, min+1)\n+\t\t\t\t}\n+\t\t\t\t// Check: All elements are still in a split restrictions. This\n+\t\t\t\t// logic assumes that the splits are returned in order which\n+\t\t\t\t// isn't guaranteed by EvenSplits, but this check is way easier\n+\t\t\t\t// with the assumption.\n+\t\t\t\tif split.Start != prevEnd {\n+\t\t\t\t\tt.Errorf(\"restriction range [%v, %v] missing after splits.\",\n+\t\t\t\t\t\tprevEnd, split.Start)\n+\t\t\t\t} else {\n+\t\t\t\t\tprevEnd = split.End\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif prevEnd != r.End {\n+\t\t\t\tt.Errorf(\"restriction range [%v, %v] missing after splits.\",\n+\t\t\t\t\tprevEnd, r.End)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+// TestTracker_TryClaim validates both success and failure cases for TryClaim.\n+func TestTracker_TryClaim(t *testing.T) {\n+\t// Test that TryClaim works as expected when called correctly.\n+\tt.Run(\"Correctness\", func(t *testing.T) {\n+\t\ttests := []struct {\n+\t\t\trest   Restriction\n+\t\t\tclaims []int64\n+\t\t}{\n+\t\t\t{rest: Restriction{Start: 0, End: 3}, claims: []int64{0, 1, 2, 3}},\n+\t\t\t{rest: Restriction{Start: 10, End: 40}, claims: []int64{15, 20, 50}},\n+\t\t\t{rest: Restriction{Start: 0, End: 3}, claims: []int64{4}},\n+\t\t}\n+\t\tfor _, test := range tests {\n+\t\t\ttest := test\n+\t\t\tt.Run(fmt.Sprintf(\"(rest[%v, %v], claims = %v)\",\n+\t\t\t\ttest.rest.Start, test.rest.End, test.claims), func(t *testing.T) {\n+\t\t\t\trt := NewTracker(test.rest)\n+\t\t\t\tfor _, pos := range test.claims {\n+\t\t\t\t\tok := rt.TryClaim(pos)", "originalCommit": "af92f3adc2024eb8f4421d0223602e23236add9b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAyNTg5NQ==", "url": "https://github.com/apache/beam/pull/11763#discussion_r429025895", "bodyText": "Done.", "author": "youngoli", "createdAt": "2020-05-22T03:35:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNTc3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMxMDIwNg==", "url": "https://github.com/apache/beam/pull/11763#discussion_r428310206", "bodyText": "Same comment here.", "author": "lostluck", "createdAt": "2020-05-20T21:12:32Z", "path": "sdks/go/pkg/beam/io/rtrackers/offsetrange/offsetrange_test.go", "diffHunk": "@@ -0,0 +1,212 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package offsetrange\n+\n+import (\n+\t\"fmt\"\n+\t\"github.com/google/go-cmp/cmp\"\n+\t\"testing\"\n+)\n+\n+// TestRestriction_EvenSplits tests various splits and checks that they all\n+// follow the contract for EvenSplits. This means that all restrictions are\n+// evenly split, that each restriction has at least one element, and that each\n+// element is present in the split restrictions.\n+func TestRestriction_EvenSplits(t *testing.T) {\n+\ttests := []struct {\n+\t\trest Restriction\n+\t\tnum  int64\n+\t}{\n+\t\t{rest: Restriction{Start: 0, End: 21}, num: 4},\n+\t\t{rest: Restriction{Start: 21, End: 42}, num: 4},\n+\t\t{rest: Restriction{Start: 0, End: 5}, num: 10},\n+\t\t{rest: Restriction{Start: 0, End: 21}, num: -1},\n+\t}\n+\tfor _, test := range tests {\n+\t\ttest := test\n+\t\tt.Run(fmt.Sprintf(\"(rest[%v, %v], splits = %v)\",\n+\t\t\ttest.rest.Start, test.rest.End, test.num), func(t *testing.T) {\n+\t\t\tr := test.rest\n+\n+\t\t\t// Get the minimum size that a split restriction can be. Max size\n+\t\t\t// should be min + 1. This way we can check the size of each split.\n+\t\t\tnum := test.num\n+\t\t\tif num <= 1 {\n+\t\t\t\tnum = 1\n+\t\t\t}\n+\t\t\tmin := (r.End - r.Start) / num\n+\n+\t\t\tsplits := r.EvenSplits(test.num)\n+\t\t\tprevEnd := r.Start\n+\t\t\tfor _, split := range splits {\n+\t\t\t\tsize := split.End - split.Start\n+\t\t\t\t// Check: Each restriction has at least 1 element.\n+\t\t\t\tif size == 0 {\n+\t\t\t\t\tt.Errorf(\"split restriction [%v, %v] is empty, size must be greater than 0.\",\n+\t\t\t\t\t\tsplit.Start, split.End)\n+\t\t\t\t}\n+\t\t\t\t// Check: Restrictions are evenly split.\n+\t\t\t\tif size != min && size != min+1 {\n+\t\t\t\t\tt.Errorf(\"split restriction [%v, %v] has unexpected size. got: %v, want: %v or %v\",\n+\t\t\t\t\t\tsplit.Start, split.End, size, min, min+1)\n+\t\t\t\t}\n+\t\t\t\t// Check: All elements are still in a split restrictions. This\n+\t\t\t\t// logic assumes that the splits are returned in order which\n+\t\t\t\t// isn't guaranteed by EvenSplits, but this check is way easier\n+\t\t\t\t// with the assumption.\n+\t\t\t\tif split.Start != prevEnd {\n+\t\t\t\t\tt.Errorf(\"restriction range [%v, %v] missing after splits.\",\n+\t\t\t\t\t\tprevEnd, split.Start)\n+\t\t\t\t} else {\n+\t\t\t\t\tprevEnd = split.End\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif prevEnd != r.End {\n+\t\t\t\tt.Errorf(\"restriction range [%v, %v] missing after splits.\",\n+\t\t\t\t\tprevEnd, r.End)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+// TestTracker_TryClaim validates both success and failure cases for TryClaim.\n+func TestTracker_TryClaim(t *testing.T) {\n+\t// Test that TryClaim works as expected when called correctly.\n+\tt.Run(\"Correctness\", func(t *testing.T) {\n+\t\ttests := []struct {\n+\t\t\trest   Restriction\n+\t\t\tclaims []int64\n+\t\t}{\n+\t\t\t{rest: Restriction{Start: 0, End: 3}, claims: []int64{0, 1, 2, 3}},\n+\t\t\t{rest: Restriction{Start: 10, End: 40}, claims: []int64{15, 20, 50}},\n+\t\t\t{rest: Restriction{Start: 0, End: 3}, claims: []int64{4}},\n+\t\t}\n+\t\tfor _, test := range tests {\n+\t\t\ttest := test\n+\t\t\tt.Run(fmt.Sprintf(\"(rest[%v, %v], claims = %v)\",\n+\t\t\t\ttest.rest.Start, test.rest.End, test.claims), func(t *testing.T) {\n+\t\t\t\trt := NewTracker(test.rest)\n+\t\t\t\tfor _, pos := range test.claims {\n+\t\t\t\t\tok := rt.TryClaim(pos)\n+\t\t\t\t\t// If TryClaim returns false, check if there was an error.\n+\t\t\t\t\tif !ok && !rt.IsDone() {\n+\t\t\t\t\t\tt.Fatalf(\"tracker claiming %v failed, error: %v\", pos, rt.GetError())\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t})\n+\t\t}\n+\t})\n+\n+\t// Test that each invalid error case actually results in an error.\n+\tt.Run(\"Errors\", func(t *testing.T) {\n+\t\ttests := []struct {\n+\t\t\trest   Restriction\n+\t\t\tclaims []int64\n+\t\t}{\n+\t\t\t// Claiming backwards.\n+\t\t\t{rest: Restriction{Start: 0, End: 3}, claims: []int64{0, 2, 1}},\n+\t\t\t// Claiming before start of restriction.\n+\t\t\t{rest: Restriction{Start: 10, End: 40}, claims: []int64{8}},\n+\t\t\t// Claiming after tracker signalled to stop.\n+\t\t\t{rest: Restriction{Start: 0, End: 3}, claims: []int64{4, 5}},\n+\t\t}\n+\t\tfor _, test := range tests {\n+\t\t\ttest := test\n+\t\t\tt.Run(fmt.Sprintf(\"(rest[%v, %v], claims = %v)\",\n+\t\t\t\ttest.rest.Start, test.rest.End, test.claims), func(t *testing.T) {\n+\t\t\t\trt := NewTracker(test.rest)\n+\t\t\t\tfor _, pos := range test.claims {\n+\t\t\t\t\tok := rt.TryClaim(pos)\n+\t\t\t\t\t// Finish successfully if we got an error.\n+\t\t\t\t\tif !ok && !rt.IsDone() && rt.GetError() != nil {\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tt.Fatal(\"tracker did not fail on invalid claim\")\n+\t\t\t})\n+\t\t}\n+\t})\n+}\n+\n+// TestTracker_TrySplit tests that TrySplit follows its contract, meaning that\n+// splits don't lose any elements, split fractions are clamped to 0 or 1, and\n+// that TrySplit always splits at the nearest integer greater than the given\n+// fraction.\n+func TestTracker_TrySplit(t *testing.T) {\n+\ttests := []struct {\n+\t\trest     Restriction\n+\t\tclaimed  int64\n+\t\tfraction float64\n+\t\tsplitPt  int64 // Index where we want the split to happen.\n+\t}{\n+\t\t{\n+\t\t\trest:     Restriction{Start: 0, End: 1},\n+\t\t\tclaimed:  0,\n+\t\t\tfraction: 0.5,\n+\t\t\tsplitPt:  1,\n+\t\t},\n+\t\t{\n+\t\t\trest:     Restriction{Start: 0, End: 5},\n+\t\t\tclaimed:  0,\n+\t\t\tfraction: 0.5,\n+\t\t\tsplitPt:  3,\n+\t\t},\n+\t\t{\n+\t\t\trest:     Restriction{Start: 0, End: 10},\n+\t\t\tclaimed:  5,\n+\t\t\tfraction: 0.5,\n+\t\t\tsplitPt:  8,\n+\t\t},\n+\t\t{\n+\t\t\trest:     Restriction{Start: 0, End: 10},\n+\t\t\tclaimed:  5,\n+\t\t\tfraction: -0.5,\n+\t\t\tsplitPt:  5,\n+\t\t},\n+\t\t{\n+\t\t\trest:     Restriction{Start: 0, End: 10},\n+\t\t\tclaimed:  5,\n+\t\t\tfraction: 1.5,\n+\t\t\tsplitPt:  10,\n+\t\t},\n+\t}\n+\tfor _, test := range tests {\n+\t\ttest := test\n+\t\tt.Run(fmt.Sprintf(\"(split at %v of [%v, %v])\",\n+\t\t\ttest.fraction, test.claimed, test.rest.End), func(t *testing.T) {\n+\t\t\trt := NewTracker(test.rest)\n+\t\t\tok := rt.TryClaim(test.claimed)\n+\t\t\tif !ok {", "originalCommit": "af92f3adc2024eb8f4421d0223602e23236add9b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAyNTkwNw==", "url": "https://github.com/apache/beam/pull/11763#discussion_r429025907", "bodyText": "Done.", "author": "youngoli", "createdAt": "2020-05-22T03:36:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMxMDIwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMxMTEyOA==", "url": "https://github.com/apache/beam/pull/11763#discussion_r428311128", "bodyText": "Is the splitPt here the \"last element that should be processed\" or \"the first element that shouldn't be processed?\"\nSaid another way, is the index represented by splitPt part of the Primary or part of the Residual?", "author": "lostluck", "createdAt": "2020-05-20T21:14:32Z", "path": "sdks/go/pkg/beam/io/rtrackers/offsetrange/offsetrange_test.go", "diffHunk": "@@ -0,0 +1,212 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package offsetrange\n+\n+import (\n+\t\"fmt\"\n+\t\"github.com/google/go-cmp/cmp\"\n+\t\"testing\"\n+)\n+\n+// TestRestriction_EvenSplits tests various splits and checks that they all\n+// follow the contract for EvenSplits. This means that all restrictions are\n+// evenly split, that each restriction has at least one element, and that each\n+// element is present in the split restrictions.\n+func TestRestriction_EvenSplits(t *testing.T) {\n+\ttests := []struct {\n+\t\trest Restriction\n+\t\tnum  int64\n+\t}{\n+\t\t{rest: Restriction{Start: 0, End: 21}, num: 4},\n+\t\t{rest: Restriction{Start: 21, End: 42}, num: 4},\n+\t\t{rest: Restriction{Start: 0, End: 5}, num: 10},\n+\t\t{rest: Restriction{Start: 0, End: 21}, num: -1},\n+\t}\n+\tfor _, test := range tests {\n+\t\ttest := test\n+\t\tt.Run(fmt.Sprintf(\"(rest[%v, %v], splits = %v)\",\n+\t\t\ttest.rest.Start, test.rest.End, test.num), func(t *testing.T) {\n+\t\t\tr := test.rest\n+\n+\t\t\t// Get the minimum size that a split restriction can be. Max size\n+\t\t\t// should be min + 1. This way we can check the size of each split.\n+\t\t\tnum := test.num\n+\t\t\tif num <= 1 {\n+\t\t\t\tnum = 1\n+\t\t\t}\n+\t\t\tmin := (r.End - r.Start) / num\n+\n+\t\t\tsplits := r.EvenSplits(test.num)\n+\t\t\tprevEnd := r.Start\n+\t\t\tfor _, split := range splits {\n+\t\t\t\tsize := split.End - split.Start\n+\t\t\t\t// Check: Each restriction has at least 1 element.\n+\t\t\t\tif size == 0 {\n+\t\t\t\t\tt.Errorf(\"split restriction [%v, %v] is empty, size must be greater than 0.\",\n+\t\t\t\t\t\tsplit.Start, split.End)\n+\t\t\t\t}\n+\t\t\t\t// Check: Restrictions are evenly split.\n+\t\t\t\tif size != min && size != min+1 {\n+\t\t\t\t\tt.Errorf(\"split restriction [%v, %v] has unexpected size. got: %v, want: %v or %v\",\n+\t\t\t\t\t\tsplit.Start, split.End, size, min, min+1)\n+\t\t\t\t}\n+\t\t\t\t// Check: All elements are still in a split restrictions. This\n+\t\t\t\t// logic assumes that the splits are returned in order which\n+\t\t\t\t// isn't guaranteed by EvenSplits, but this check is way easier\n+\t\t\t\t// with the assumption.\n+\t\t\t\tif split.Start != prevEnd {\n+\t\t\t\t\tt.Errorf(\"restriction range [%v, %v] missing after splits.\",\n+\t\t\t\t\t\tprevEnd, split.Start)\n+\t\t\t\t} else {\n+\t\t\t\t\tprevEnd = split.End\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif prevEnd != r.End {\n+\t\t\t\tt.Errorf(\"restriction range [%v, %v] missing after splits.\",\n+\t\t\t\t\tprevEnd, r.End)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+// TestTracker_TryClaim validates both success and failure cases for TryClaim.\n+func TestTracker_TryClaim(t *testing.T) {\n+\t// Test that TryClaim works as expected when called correctly.\n+\tt.Run(\"Correctness\", func(t *testing.T) {\n+\t\ttests := []struct {\n+\t\t\trest   Restriction\n+\t\t\tclaims []int64\n+\t\t}{\n+\t\t\t{rest: Restriction{Start: 0, End: 3}, claims: []int64{0, 1, 2, 3}},\n+\t\t\t{rest: Restriction{Start: 10, End: 40}, claims: []int64{15, 20, 50}},\n+\t\t\t{rest: Restriction{Start: 0, End: 3}, claims: []int64{4}},\n+\t\t}\n+\t\tfor _, test := range tests {\n+\t\t\ttest := test\n+\t\t\tt.Run(fmt.Sprintf(\"(rest[%v, %v], claims = %v)\",\n+\t\t\t\ttest.rest.Start, test.rest.End, test.claims), func(t *testing.T) {\n+\t\t\t\trt := NewTracker(test.rest)\n+\t\t\t\tfor _, pos := range test.claims {\n+\t\t\t\t\tok := rt.TryClaim(pos)\n+\t\t\t\t\t// If TryClaim returns false, check if there was an error.\n+\t\t\t\t\tif !ok && !rt.IsDone() {\n+\t\t\t\t\t\tt.Fatalf(\"tracker claiming %v failed, error: %v\", pos, rt.GetError())\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t})\n+\t\t}\n+\t})\n+\n+\t// Test that each invalid error case actually results in an error.\n+\tt.Run(\"Errors\", func(t *testing.T) {\n+\t\ttests := []struct {\n+\t\t\trest   Restriction\n+\t\t\tclaims []int64\n+\t\t}{\n+\t\t\t// Claiming backwards.\n+\t\t\t{rest: Restriction{Start: 0, End: 3}, claims: []int64{0, 2, 1}},\n+\t\t\t// Claiming before start of restriction.\n+\t\t\t{rest: Restriction{Start: 10, End: 40}, claims: []int64{8}},\n+\t\t\t// Claiming after tracker signalled to stop.\n+\t\t\t{rest: Restriction{Start: 0, End: 3}, claims: []int64{4, 5}},\n+\t\t}\n+\t\tfor _, test := range tests {\n+\t\t\ttest := test\n+\t\t\tt.Run(fmt.Sprintf(\"(rest[%v, %v], claims = %v)\",\n+\t\t\t\ttest.rest.Start, test.rest.End, test.claims), func(t *testing.T) {\n+\t\t\t\trt := NewTracker(test.rest)\n+\t\t\t\tfor _, pos := range test.claims {\n+\t\t\t\t\tok := rt.TryClaim(pos)\n+\t\t\t\t\t// Finish successfully if we got an error.\n+\t\t\t\t\tif !ok && !rt.IsDone() && rt.GetError() != nil {\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tt.Fatal(\"tracker did not fail on invalid claim\")\n+\t\t\t})\n+\t\t}\n+\t})\n+}\n+\n+// TestTracker_TrySplit tests that TrySplit follows its contract, meaning that\n+// splits don't lose any elements, split fractions are clamped to 0 or 1, and\n+// that TrySplit always splits at the nearest integer greater than the given\n+// fraction.\n+func TestTracker_TrySplit(t *testing.T) {\n+\ttests := []struct {\n+\t\trest     Restriction\n+\t\tclaimed  int64\n+\t\tfraction float64\n+\t\tsplitPt  int64 // Index where we want the split to happen.", "originalCommit": "af92f3adc2024eb8f4421d0223602e23236add9b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMxMzExOA==", "url": "https://github.com/apache/beam/pull/11763#discussion_r428313118", "bodyText": "Reading into the test further, it looks like \"last element of primary\" which I'm pretty sure is the correct thing, so this just means the comment should be updated to reflect that.", "author": "lostluck", "createdAt": "2020-05-20T21:18:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMxMTEyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTAyNjA3OQ==", "url": "https://github.com/apache/beam/pull/11763#discussion_r429026079", "bodyText": "The range is actually half-closed range, so that split is the \"first element that shouldn't be processed\" of the primary, and the \"first element to process\" in the residual. But agreed, specified in the comment.", "author": "youngoli", "createdAt": "2020-05-22T03:36:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMxMTEyOA=="}], "type": "inlineReview"}, {"oid": "1095db056dbd9095c35effbff07cbcd90dc87c54", "url": "https://github.com/apache/beam/commit/1095db056dbd9095c35effbff07cbcd90dc87c54", "message": "[BEAM-9978] Adding functionality and tests to Go offset range tracker.\n\nPretty simple. Moves some commonly desired behaviors out of the SDF\ncode and into the offset range tracker/restriction code + adds tests.", "committedDate": "2020-05-22T03:35:39Z", "type": "commit"}, {"oid": "1095db056dbd9095c35effbff07cbcd90dc87c54", "url": "https://github.com/apache/beam/commit/1095db056dbd9095c35effbff07cbcd90dc87c54", "message": "[BEAM-9978] Adding functionality and tests to Go offset range tracker.\n\nPretty simple. Moves some commonly desired behaviors out of the SDF\ncode and into the offset range tracker/restriction code + adds tests.", "committedDate": "2020-05-22T03:35:39Z", "type": "forcePushed"}]}