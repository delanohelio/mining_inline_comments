{"pr_number": 13317, "pr_title": "[BEAM-11254] New documentation on multi-language pipelines", "pr_createdAt": "2020-11-12T13:35:36Z", "pr_url": "https://github.com/apache/beam/pull/13317", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ2MTE3MQ==", "url": "https://github.com/apache/beam/pull/13317#discussion_r522461171", "bodyText": "Now that we only support Python 3 we might consider using the more concise NamedTuple class syntax, and str:\nclass ReadFromKafkaSchema(typing.NamedTuple):\n  consumer_config: typing.Mapping[str, str]\n  topics: typing.List[str]\n  # Other properties omitted for clarity.", "author": "TheNeuralBit", "createdAt": "2020-11-12T22:14:10Z", "path": "website/www/site/content/en/documentation/programming-guide.md", "diffHunk": "@@ -5431,4 +5431,282 @@ use case.\n \n {{< highlight py >}}\n {{< code_sample \"sdks/python/apache_beam/examples/snippets/snippets.py\" BundleFinalize >}}\n-{{< /highlight >}}\n\\ No newline at end of file\n+{{< /highlight >}}\n+\n+## 13. Multi-language pipelines {#mulit-language-pipelines}\n+\n+Beam allows you to combine transforms written in any supported SDK language (currently, Java and Python) and use them in one multi-language pipeline. This capability makes it easy to provide new functionality simultaneously in different Apache Beam SDKs through a single cross-language transform. For example, the Apache Kafka connector and SQL transform from the Java SDK can be used in Python streaming pipelines. \n+\n+Pipelines that use transforms from more than one SDK-language are known as multi-language pipelines.\n+\n+### 13.1. Creating cross-language transforms {#create-x-lang-transforms}\n+\n+To make transforms written in one language available to pipelines written in another language, an expansion service for that transform is used to create and inject the appropriate language-specific pipeline fragments into your pipeline. \n+\n+In the following example, a Python pipeline written the Apache Beam SDK for Python starts up a local Java expansion service on your computer to create and inject the appropriate Java pipeline fragments for executing the Java Kafka cross-language transform into your Python pipeline. The SDK then downloads and stages the necessary Java dependencies needed to execute these transforms.\n+\n+![Diagram of multi-language pipeline execution flow.](/images/multi-language-pipelines-diagram.svg)\n+\n+At runtime, the Beam runner will execute both Python and Java transforms to execute your pipeline.\n+\n+In this section, we will use [KafkaIO.Read](https://beam.apache.org/releases/javadoc/current/org/apache/beam/sdk/io/kafka/KafkaIO.Read.html) to illustrate how to create a cross-language transform for Java and a test example for Python.\n+\n+#### 13.1.1. Creating cross-language Java transforms\n+\n+To make your Apache Beam Java SDK transform portable across SDK languages, you must implement two interfaces: [ExternalTransformBuilder](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/ExternalTransformBuilder.java) and [ExternalTransformRegistrar](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/expansion/ExternalTransformRegistrar.java). The `ExternalTransformBuilder` interface constructs the cross-language transform using configuration values passed in from the pipeline and the `ExternalTransformRegistrar` interface registers the cross-language transform for use with the expansion service.\n+\n+**Implementing the interfaces**\n+\n+1. Define a Builder class for your transform that implements the `ExternalTransformBuilder` interface and overrides the `buildExternal` method that will be used to build your transform object. Initial configuration values for your transform should be defined in the `buildExternal` method. In most cases, it is convenient to make the Java transform builder class implement `ExternalTransformBuilder`.\n+\n+    > **Note:** `ExternalTransformBuilder` requires you to define a configuration object (a simple POJO) to capture a set of parameters sent by external SDKs to initiate the Java transform. Usually these parameters directly map to constructor parameters of the Java transform.\n+\n+    {{< highlight >}}\n+@AutoValue.Builder\n+abstract static class Builder<K, V>\n+  implements ExternalTransformBuilder<External.Configuration, PBegin, PCollection<KV<K, V>>> {\n+  abstract Builder<K, V> setConsumerConfig(Map<String, Object> config);\n+\n+  abstract Builder<K, V> setTopics(List<String> topics);\n+\n+  /** Remaining property declarations omitted for clarity. */\n+\n+  abstract Read<K, V> build();\n+\n+  @Override\n+  public PTransform<PBegin, PCollection<KV<K, V>>> buildExternal(\n+      External.Configuration config) {\n+    ImmutableList.Builder<String> listBuilder = ImmutableList.builder();\n+    for (String topic : config.topics) {\n+      listBuilder.add(topic);\n+    }\n+    setTopics(listBuilder.build());\n+\n+    /** Remaining property defaults omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+2. Register the transform as an external cross-language transform by defining a class that implements `ExternalTransformRegistrar`. You must annotate your class with the `AutoService` annotation to ensure that your transform is registered and instantiated properly by the expansion service.\n+3. In your registrar class, define a Uniform Resource Name (URN) for your transform. The URN must be a unique string that identifies your transform with the expansion service.\n+4. From within your registrar class, define a configuration class for the parameters used during the initialization of your transform by the external SDK.\n+\n+    The following example from the KafkaIO transform shows how to implement steps two through four:\n+\n+    {{< highlight >}}\n+@AutoService(ExternalTransformRegistrar.class)\n+public static class External implements ExternalTransformRegistrar {\n+\n+  public static final String URN = \"beam:external:java:kafka:read:v1\";\n+\n+  @Override\n+  public Map<String, Class<? extends ExternalTransformBuilder<?, ?, ?>>> knownBuilders() {\n+    return ImmutableMap.of(\n+        URN,\n+        (Class<? extends ExternalTransformBuilder<?, ?, ?>>)\n+            (Class<?>) AutoValue_KafkaIO_Read.Builder.class);\n+  }\n+\n+  /** Parameters class to expose the Read transform to an external SDK. */\n+  public static class Configuration {\n+    private Map<String, String> consumerConfig;\n+      private List<String> topics;\n+      \n+\n+      public void setConsumerConfig(Map<String, String> consumerConfig) {\n+        this.consumerConfig = consumerConfig;\n+      }\n+\n+      public void setTopics(List<String> topics) {\n+        this.topics = topics;\n+      }\n+\n+    /** Remaining properties omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+\n+After you have implemented the `ExternalTransformBuilder` and `ExternalTransformRegistrar` interfaces, your transform can be registered and created successfully by the default Java expansion service.\n+\n+**Using the expansion service**\n+\n+Java has a default expansion service included and available in the Apache Beam Java SDK. You can write your own expansion service, but that is generally not needed, so it is not covered in this section.\n+\n+Perform the following steps to start up a Java expansion service directly:\n+\n+{{< highlight >}}\n+// Path to a JAR file that contains the transform to expand, cross-language specific utilities (builder, registrar, etc.), and dependencies.\n+$ export EXPANSION_SERVICE_JAR=<My_expansion_service_JAR>  \n+\n+$ export PORT_FOR_EXPANSION_SERVICE=12345\n+\n+$ jar -jar $EXPANSION_SERVICE_JAR $PORT_FOR_EXPANSION_SERVICE\n+{{< /highlight >}}\n+\n+When creating SDK-specific wrappers for your transform, SDKs may provide utilities that are readily available for easily starting up an expansion service. For example, the Python SDK provides the [BeamJarExpansionService](https://github.com/apache/beam/blob/e6db419c97532f416c8e94d91b22b9688ca837a0/sdks/python/apache_beam/transforms/external.py#L522) utility for starting up a Java expansion service using a JAR file.\n+\n+**Including dependencies**\n+\n+If your transform requires external libraries, you can include them by adding them to the classpath of the expansion service. After they are included in the classpath, they will be staged when your transform is expanded by the expansion service.\n+\n+**Writing SDK-specific wrappers**\n+\n+Your cross-language Java transform can be called through the lower-level `ExternalTransform` class in a multi-language pipeline (as described in the next section); however, if possible, you should create a SDK-specific wrapper written in the programming language of the pipeline (such as Python) to access the transform instead. This higher-level abstraction will make it easier for pipeline authors to use your transform. \n+\n+To create an SDK wrapper for use in a Python pipeline, do the following:\n+\n+1. Create a Python module for your cross-language transform.\n+2. In the module, build the payload that should be used to initiate the cross-language transform expansion request using one of the available [PayloadBuilder](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py) classes.\n+\n+    The parameter names and types of the payload should map to parameter names and types of the configuration POJO provided to the Java `ExternalTransformBuilder`. Parameter types are mapped across SDKs using a [Beam schema](https://github.com/apache/beam/blob/master/model/pipeline/src/main/proto/schema.proto). Parameter names are mapped by simply converting Python underscore-separated variable names to camel-case (Java standard).\n+\n+    In the following example, kafka.py uses `NamedTupleBasedPayloadBuilder` to build the payload. The parameters map to the Java [KafkaIO.External.Configuration](https://github.com/apache/beam/blob/master/sdks/java/io/kafka/src/main/java/org/apache/beam/sdk/io/kafka/KafkaIO.java) config object.\n+\n+    {{< highlight >}}\n+ReadFromKafkaSchema = typing.NamedTuple(\n+  'ReadFromKafkaSchema',\n+  [\n+      ('consumer_config', typing.Mapping[unicode, unicode]),\n+      ('topics', typing.List[unicode])\n+      # Other properties omitted for clarity.\n+  ])", "originalCommit": "5f373448e52b782dd3c0f5d4626db1a63289b4aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU3Njc3OQ==", "url": "https://github.com/apache/beam/pull/13317#discussion_r522576779", "bodyText": "Makes sense.", "author": "chamikaramj", "createdAt": "2020-11-13T02:46:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ2MTE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI2NTg1NQ==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523265855", "bodyText": "Done.", "author": "davidwrede", "createdAt": "2020-11-13T22:27:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ2MTE3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMzOTA5Nw==", "url": "https://github.com/apache/beam/pull/13317#discussion_r522339097", "bodyText": "Probably mention somewhere that examples were inspired by the Kafka transform.", "author": "chamikaramj", "createdAt": "2020-11-12T18:53:00Z", "path": "website/www/site/content/en/documentation/programming-guide.md", "diffHunk": "@@ -5431,4 +5431,282 @@ use case.\n \n {{< highlight py >}}\n {{< code_sample \"sdks/python/apache_beam/examples/snippets/snippets.py\" BundleFinalize >}}\n-{{< /highlight >}}\n\\ No newline at end of file\n+{{< /highlight >}}\n+\n+## 13. Multi-language pipelines {#mulit-language-pipelines}\n+\n+Beam allows you to combine transforms written in any supported SDK language (currently, Java and Python) and use them in one multi-language pipeline. This capability makes it easy to provide new functionality simultaneously in different Apache Beam SDKs through a single cross-language transform. For example, the Apache Kafka connector and SQL transform from the Java SDK can be used in Python streaming pipelines. \n+\n+Pipelines that use transforms from more than one SDK-language are known as multi-language pipelines.\n+\n+### 13.1. Creating cross-language transforms {#create-x-lang-transforms}\n+\n+To make transforms written in one language available to pipelines written in another language, an expansion service for that transform is used to create and inject the appropriate language-specific pipeline fragments into your pipeline. \n+\n+In the following example, a Python pipeline written the Apache Beam SDK for Python starts up a local Java expansion service on your computer to create and inject the appropriate Java pipeline fragments for executing the Java Kafka cross-language transform into your Python pipeline. The SDK then downloads and stages the necessary Java dependencies needed to execute these transforms.\n+\n+![Diagram of multi-language pipeline execution flow.](/images/multi-language-pipelines-diagram.svg)\n+\n+At runtime, the Beam runner will execute both Python and Java transforms to execute your pipeline.\n+\n+In this section, we will use [KafkaIO.Read](https://beam.apache.org/releases/javadoc/current/org/apache/beam/sdk/io/kafka/KafkaIO.Read.html) to illustrate how to create a cross-language transform for Java and a test example for Python.\n+\n+#### 13.1.1. Creating cross-language Java transforms\n+\n+To make your Apache Beam Java SDK transform portable across SDK languages, you must implement two interfaces: [ExternalTransformBuilder](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/ExternalTransformBuilder.java) and [ExternalTransformRegistrar](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/expansion/ExternalTransformRegistrar.java). The `ExternalTransformBuilder` interface constructs the cross-language transform using configuration values passed in from the pipeline and the `ExternalTransformRegistrar` interface registers the cross-language transform for use with the expansion service.\n+\n+**Implementing the interfaces**\n+\n+1. Define a Builder class for your transform that implements the `ExternalTransformBuilder` interface and overrides the `buildExternal` method that will be used to build your transform object. Initial configuration values for your transform should be defined in the `buildExternal` method. In most cases, it is convenient to make the Java transform builder class implement `ExternalTransformBuilder`.\n+\n+    > **Note:** `ExternalTransformBuilder` requires you to define a configuration object (a simple POJO) to capture a set of parameters sent by external SDKs to initiate the Java transform. Usually these parameters directly map to constructor parameters of the Java transform.\n+\n+    {{< highlight >}}\n+@AutoValue.Builder\n+abstract static class Builder<K, V>\n+  implements ExternalTransformBuilder<External.Configuration, PBegin, PCollection<KV<K, V>>> {\n+  abstract Builder<K, V> setConsumerConfig(Map<String, Object> config);\n+\n+  abstract Builder<K, V> setTopics(List<String> topics);", "originalCommit": "5f373448e52b782dd3c0f5d4626db1a63289b4aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI0MzEwMA==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523243100", "bodyText": "I noted this in line 5452.", "author": "davidwrede", "createdAt": "2020-11-13T21:31:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMzOTA5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU2MTY3Ng==", "url": "https://github.com/apache/beam/pull/13317#discussion_r522561676", "bodyText": "Please add following links for Kafka and SQL.\nhttps://github.com/apache/beam/blob/master/sdks/python/apache_beam/io/kafka.py\nhttps://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/sql.py", "author": "chamikaramj", "createdAt": "2020-11-13T02:03:37Z", "path": "website/www/site/content/en/documentation/programming-guide.md", "diffHunk": "@@ -5431,4 +5431,282 @@ use case.\n \n {{< highlight py >}}\n {{< code_sample \"sdks/python/apache_beam/examples/snippets/snippets.py\" BundleFinalize >}}\n-{{< /highlight >}}\n\\ No newline at end of file\n+{{< /highlight >}}\n+\n+## 13. Multi-language pipelines {#mulit-language-pipelines}\n+\n+Beam allows you to combine transforms written in any supported SDK language (currently, Java and Python) and use them in one multi-language pipeline. This capability makes it easy to provide new functionality simultaneously in different Apache Beam SDKs through a single cross-language transform. For example, the Apache Kafka connector and SQL transform from the Java SDK can be used in Python streaming pipelines. ", "originalCommit": "5f373448e52b782dd3c0f5d4626db1a63289b4aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI2NTU3NQ==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523265575", "bodyText": "Done.", "author": "davidwrede", "createdAt": "2020-11-13T22:26:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU2MTY3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU2Mzk0Ng==", "url": "https://github.com/apache/beam/pull/13317#discussion_r522563946", "bodyText": "Emphasize the first introduction of the term \"multi-language pipelines\" ?", "author": "chamikaramj", "createdAt": "2020-11-13T02:08:29Z", "path": "website/www/site/content/en/documentation/programming-guide.md", "diffHunk": "@@ -5431,4 +5431,282 @@ use case.\n \n {{< highlight py >}}\n {{< code_sample \"sdks/python/apache_beam/examples/snippets/snippets.py\" BundleFinalize >}}\n-{{< /highlight >}}\n\\ No newline at end of file\n+{{< /highlight >}}\n+\n+## 13. Multi-language pipelines {#mulit-language-pipelines}\n+\n+Beam allows you to combine transforms written in any supported SDK language (currently, Java and Python) and use them in one multi-language pipeline. This capability makes it easy to provide new functionality simultaneously in different Apache Beam SDKs through a single cross-language transform. For example, the Apache Kafka connector and SQL transform from the Java SDK can be used in Python streaming pipelines. \n+\n+Pipelines that use transforms from more than one SDK-language are known as multi-language pipelines.", "originalCommit": "5f373448e52b782dd3c0f5d4626db1a63289b4aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI1NjY0NA==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523256644", "bodyText": "Done.", "author": "davidwrede", "createdAt": "2020-11-13T22:00:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU2Mzk0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU2NDMzOQ==", "url": "https://github.com/apache/beam/pull/13317#discussion_r522564339", "bodyText": "Emphasize the first introduction of the term \"expansion service\" ?", "author": "chamikaramj", "createdAt": "2020-11-13T02:08:58Z", "path": "website/www/site/content/en/documentation/programming-guide.md", "diffHunk": "@@ -5431,4 +5431,282 @@ use case.\n \n {{< highlight py >}}\n {{< code_sample \"sdks/python/apache_beam/examples/snippets/snippets.py\" BundleFinalize >}}\n-{{< /highlight >}}\n\\ No newline at end of file\n+{{< /highlight >}}\n+\n+## 13. Multi-language pipelines {#mulit-language-pipelines}\n+\n+Beam allows you to combine transforms written in any supported SDK language (currently, Java and Python) and use them in one multi-language pipeline. This capability makes it easy to provide new functionality simultaneously in different Apache Beam SDKs through a single cross-language transform. For example, the Apache Kafka connector and SQL transform from the Java SDK can be used in Python streaming pipelines. \n+\n+Pipelines that use transforms from more than one SDK-language are known as multi-language pipelines.\n+\n+### 13.1. Creating cross-language transforms {#create-x-lang-transforms}\n+\n+To make transforms written in one language available to pipelines written in another language, an expansion service for that transform is used to create and inject the appropriate language-specific pipeline fragments into your pipeline. ", "originalCommit": "5f373448e52b782dd3c0f5d4626db1a63289b4aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI1NjcxOQ==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523256719", "bodyText": "Done.", "author": "davidwrede", "createdAt": "2020-11-13T22:00:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU2NDMzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU3MzcxMw==", "url": "https://github.com/apache/beam/pull/13317#discussion_r522573713", "bodyText": "Is this link stable ?", "author": "chamikaramj", "createdAt": "2020-11-13T02:34:32Z", "path": "website/www/site/content/en/documentation/programming-guide.md", "diffHunk": "@@ -5431,4 +5431,282 @@ use case.\n \n {{< highlight py >}}\n {{< code_sample \"sdks/python/apache_beam/examples/snippets/snippets.py\" BundleFinalize >}}\n-{{< /highlight >}}\n\\ No newline at end of file\n+{{< /highlight >}}\n+\n+## 13. Multi-language pipelines {#mulit-language-pipelines}\n+\n+Beam allows you to combine transforms written in any supported SDK language (currently, Java and Python) and use them in one multi-language pipeline. This capability makes it easy to provide new functionality simultaneously in different Apache Beam SDKs through a single cross-language transform. For example, the Apache Kafka connector and SQL transform from the Java SDK can be used in Python streaming pipelines. \n+\n+Pipelines that use transforms from more than one SDK-language are known as multi-language pipelines.\n+\n+### 13.1. Creating cross-language transforms {#create-x-lang-transforms}\n+\n+To make transforms written in one language available to pipelines written in another language, an expansion service for that transform is used to create and inject the appropriate language-specific pipeline fragments into your pipeline. \n+\n+In the following example, a Python pipeline written the Apache Beam SDK for Python starts up a local Java expansion service on your computer to create and inject the appropriate Java pipeline fragments for executing the Java Kafka cross-language transform into your Python pipeline. The SDK then downloads and stages the necessary Java dependencies needed to execute these transforms.\n+\n+![Diagram of multi-language pipeline execution flow.](/images/multi-language-pipelines-diagram.svg)\n+\n+At runtime, the Beam runner will execute both Python and Java transforms to execute your pipeline.\n+\n+In this section, we will use [KafkaIO.Read](https://beam.apache.org/releases/javadoc/current/org/apache/beam/sdk/io/kafka/KafkaIO.Read.html) to illustrate how to create a cross-language transform for Java and a test example for Python.\n+\n+#### 13.1.1. Creating cross-language Java transforms\n+\n+To make your Apache Beam Java SDK transform portable across SDK languages, you must implement two interfaces: [ExternalTransformBuilder](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/ExternalTransformBuilder.java) and [ExternalTransformRegistrar](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/expansion/ExternalTransformRegistrar.java). The `ExternalTransformBuilder` interface constructs the cross-language transform using configuration values passed in from the pipeline and the `ExternalTransformRegistrar` interface registers the cross-language transform for use with the expansion service.\n+\n+**Implementing the interfaces**\n+\n+1. Define a Builder class for your transform that implements the `ExternalTransformBuilder` interface and overrides the `buildExternal` method that will be used to build your transform object. Initial configuration values for your transform should be defined in the `buildExternal` method. In most cases, it is convenient to make the Java transform builder class implement `ExternalTransformBuilder`.\n+\n+    > **Note:** `ExternalTransformBuilder` requires you to define a configuration object (a simple POJO) to capture a set of parameters sent by external SDKs to initiate the Java transform. Usually these parameters directly map to constructor parameters of the Java transform.\n+\n+    {{< highlight >}}\n+@AutoValue.Builder\n+abstract static class Builder<K, V>\n+  implements ExternalTransformBuilder<External.Configuration, PBegin, PCollection<KV<K, V>>> {\n+  abstract Builder<K, V> setConsumerConfig(Map<String, Object> config);\n+\n+  abstract Builder<K, V> setTopics(List<String> topics);\n+\n+  /** Remaining property declarations omitted for clarity. */\n+\n+  abstract Read<K, V> build();\n+\n+  @Override\n+  public PTransform<PBegin, PCollection<KV<K, V>>> buildExternal(\n+      External.Configuration config) {\n+    ImmutableList.Builder<String> listBuilder = ImmutableList.builder();\n+    for (String topic : config.topics) {\n+      listBuilder.add(topic);\n+    }\n+    setTopics(listBuilder.build());\n+\n+    /** Remaining property defaults omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+2. Register the transform as an external cross-language transform by defining a class that implements `ExternalTransformRegistrar`. You must annotate your class with the `AutoService` annotation to ensure that your transform is registered and instantiated properly by the expansion service.\n+3. In your registrar class, define a Uniform Resource Name (URN) for your transform. The URN must be a unique string that identifies your transform with the expansion service.\n+4. From within your registrar class, define a configuration class for the parameters used during the initialization of your transform by the external SDK.\n+\n+    The following example from the KafkaIO transform shows how to implement steps two through four:\n+\n+    {{< highlight >}}\n+@AutoService(ExternalTransformRegistrar.class)\n+public static class External implements ExternalTransformRegistrar {\n+\n+  public static final String URN = \"beam:external:java:kafka:read:v1\";\n+\n+  @Override\n+  public Map<String, Class<? extends ExternalTransformBuilder<?, ?, ?>>> knownBuilders() {\n+    return ImmutableMap.of(\n+        URN,\n+        (Class<? extends ExternalTransformBuilder<?, ?, ?>>)\n+            (Class<?>) AutoValue_KafkaIO_Read.Builder.class);\n+  }\n+\n+  /** Parameters class to expose the Read transform to an external SDK. */\n+  public static class Configuration {\n+    private Map<String, String> consumerConfig;\n+      private List<String> topics;\n+      \n+\n+      public void setConsumerConfig(Map<String, String> consumerConfig) {\n+        this.consumerConfig = consumerConfig;\n+      }\n+\n+      public void setTopics(List<String> topics) {\n+        this.topics = topics;\n+      }\n+\n+    /** Remaining properties omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+\n+After you have implemented the `ExternalTransformBuilder` and `ExternalTransformRegistrar` interfaces, your transform can be registered and created successfully by the default Java expansion service.\n+\n+**Using the expansion service**\n+\n+Java has a default expansion service included and available in the Apache Beam Java SDK. You can write your own expansion service, but that is generally not needed, so it is not covered in this section.\n+\n+Perform the following steps to start up a Java expansion service directly:\n+\n+{{< highlight >}}\n+// Path to a JAR file that contains the transform to expand, cross-language specific utilities (builder, registrar, etc.), and dependencies.\n+$ export EXPANSION_SERVICE_JAR=<My_expansion_service_JAR>  \n+\n+$ export PORT_FOR_EXPANSION_SERVICE=12345\n+\n+$ jar -jar $EXPANSION_SERVICE_JAR $PORT_FOR_EXPANSION_SERVICE\n+{{< /highlight >}}\n+\n+When creating SDK-specific wrappers for your transform, SDKs may provide utilities that are readily available for easily starting up an expansion service. For example, the Python SDK provides the [BeamJarExpansionService](https://github.com/apache/beam/blob/e6db419c97532f416c8e94d91b22b9688ca837a0/sdks/python/apache_beam/transforms/external.py#L522) utility for starting up a Java expansion service using a JAR file.", "originalCommit": "5f373448e52b782dd3c0f5d4626db1a63289b4aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI0ODgxNA==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523248814", "bodyText": "Fixed by referring to HEAD version of the file and not linking to specific line in the source file.", "author": "davidwrede", "createdAt": "2020-11-13T21:45:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU3MzcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU3NjQ3OQ==", "url": "https://github.com/apache/beam/pull/13317#discussion_r522576479", "bodyText": "Link to https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py\n(or to actual class if we can find a stable link).", "author": "chamikaramj", "createdAt": "2020-11-13T02:45:01Z", "path": "website/www/site/content/en/documentation/programming-guide.md", "diffHunk": "@@ -5431,4 +5431,282 @@ use case.\n \n {{< highlight py >}}\n {{< code_sample \"sdks/python/apache_beam/examples/snippets/snippets.py\" BundleFinalize >}}\n-{{< /highlight >}}\n\\ No newline at end of file\n+{{< /highlight >}}\n+\n+## 13. Multi-language pipelines {#mulit-language-pipelines}\n+\n+Beam allows you to combine transforms written in any supported SDK language (currently, Java and Python) and use them in one multi-language pipeline. This capability makes it easy to provide new functionality simultaneously in different Apache Beam SDKs through a single cross-language transform. For example, the Apache Kafka connector and SQL transform from the Java SDK can be used in Python streaming pipelines. \n+\n+Pipelines that use transforms from more than one SDK-language are known as multi-language pipelines.\n+\n+### 13.1. Creating cross-language transforms {#create-x-lang-transforms}\n+\n+To make transforms written in one language available to pipelines written in another language, an expansion service for that transform is used to create and inject the appropriate language-specific pipeline fragments into your pipeline. \n+\n+In the following example, a Python pipeline written the Apache Beam SDK for Python starts up a local Java expansion service on your computer to create and inject the appropriate Java pipeline fragments for executing the Java Kafka cross-language transform into your Python pipeline. The SDK then downloads and stages the necessary Java dependencies needed to execute these transforms.\n+\n+![Diagram of multi-language pipeline execution flow.](/images/multi-language-pipelines-diagram.svg)\n+\n+At runtime, the Beam runner will execute both Python and Java transforms to execute your pipeline.\n+\n+In this section, we will use [KafkaIO.Read](https://beam.apache.org/releases/javadoc/current/org/apache/beam/sdk/io/kafka/KafkaIO.Read.html) to illustrate how to create a cross-language transform for Java and a test example for Python.\n+\n+#### 13.1.1. Creating cross-language Java transforms\n+\n+To make your Apache Beam Java SDK transform portable across SDK languages, you must implement two interfaces: [ExternalTransformBuilder](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/ExternalTransformBuilder.java) and [ExternalTransformRegistrar](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/expansion/ExternalTransformRegistrar.java). The `ExternalTransformBuilder` interface constructs the cross-language transform using configuration values passed in from the pipeline and the `ExternalTransformRegistrar` interface registers the cross-language transform for use with the expansion service.\n+\n+**Implementing the interfaces**\n+\n+1. Define a Builder class for your transform that implements the `ExternalTransformBuilder` interface and overrides the `buildExternal` method that will be used to build your transform object. Initial configuration values for your transform should be defined in the `buildExternal` method. In most cases, it is convenient to make the Java transform builder class implement `ExternalTransformBuilder`.\n+\n+    > **Note:** `ExternalTransformBuilder` requires you to define a configuration object (a simple POJO) to capture a set of parameters sent by external SDKs to initiate the Java transform. Usually these parameters directly map to constructor parameters of the Java transform.\n+\n+    {{< highlight >}}\n+@AutoValue.Builder\n+abstract static class Builder<K, V>\n+  implements ExternalTransformBuilder<External.Configuration, PBegin, PCollection<KV<K, V>>> {\n+  abstract Builder<K, V> setConsumerConfig(Map<String, Object> config);\n+\n+  abstract Builder<K, V> setTopics(List<String> topics);\n+\n+  /** Remaining property declarations omitted for clarity. */\n+\n+  abstract Read<K, V> build();\n+\n+  @Override\n+  public PTransform<PBegin, PCollection<KV<K, V>>> buildExternal(\n+      External.Configuration config) {\n+    ImmutableList.Builder<String> listBuilder = ImmutableList.builder();\n+    for (String topic : config.topics) {\n+      listBuilder.add(topic);\n+    }\n+    setTopics(listBuilder.build());\n+\n+    /** Remaining property defaults omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+2. Register the transform as an external cross-language transform by defining a class that implements `ExternalTransformRegistrar`. You must annotate your class with the `AutoService` annotation to ensure that your transform is registered and instantiated properly by the expansion service.\n+3. In your registrar class, define a Uniform Resource Name (URN) for your transform. The URN must be a unique string that identifies your transform with the expansion service.\n+4. From within your registrar class, define a configuration class for the parameters used during the initialization of your transform by the external SDK.\n+\n+    The following example from the KafkaIO transform shows how to implement steps two through four:\n+\n+    {{< highlight >}}\n+@AutoService(ExternalTransformRegistrar.class)\n+public static class External implements ExternalTransformRegistrar {\n+\n+  public static final String URN = \"beam:external:java:kafka:read:v1\";\n+\n+  @Override\n+  public Map<String, Class<? extends ExternalTransformBuilder<?, ?, ?>>> knownBuilders() {\n+    return ImmutableMap.of(\n+        URN,\n+        (Class<? extends ExternalTransformBuilder<?, ?, ?>>)\n+            (Class<?>) AutoValue_KafkaIO_Read.Builder.class);\n+  }\n+\n+  /** Parameters class to expose the Read transform to an external SDK. */\n+  public static class Configuration {\n+    private Map<String, String> consumerConfig;\n+      private List<String> topics;\n+      \n+\n+      public void setConsumerConfig(Map<String, String> consumerConfig) {\n+        this.consumerConfig = consumerConfig;\n+      }\n+\n+      public void setTopics(List<String> topics) {\n+        this.topics = topics;\n+      }\n+\n+    /** Remaining properties omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+\n+After you have implemented the `ExternalTransformBuilder` and `ExternalTransformRegistrar` interfaces, your transform can be registered and created successfully by the default Java expansion service.\n+\n+**Using the expansion service**\n+\n+Java has a default expansion service included and available in the Apache Beam Java SDK. You can write your own expansion service, but that is generally not needed, so it is not covered in this section.\n+\n+Perform the following steps to start up a Java expansion service directly:\n+\n+{{< highlight >}}\n+// Path to a JAR file that contains the transform to expand, cross-language specific utilities (builder, registrar, etc.), and dependencies.\n+$ export EXPANSION_SERVICE_JAR=<My_expansion_service_JAR>  \n+\n+$ export PORT_FOR_EXPANSION_SERVICE=12345\n+\n+$ jar -jar $EXPANSION_SERVICE_JAR $PORT_FOR_EXPANSION_SERVICE\n+{{< /highlight >}}\n+\n+When creating SDK-specific wrappers for your transform, SDKs may provide utilities that are readily available for easily starting up an expansion service. For example, the Python SDK provides the [BeamJarExpansionService](https://github.com/apache/beam/blob/e6db419c97532f416c8e94d91b22b9688ca837a0/sdks/python/apache_beam/transforms/external.py#L522) utility for starting up a Java expansion service using a JAR file.\n+\n+**Including dependencies**\n+\n+If your transform requires external libraries, you can include them by adding them to the classpath of the expansion service. After they are included in the classpath, they will be staged when your transform is expanded by the expansion service.\n+\n+**Writing SDK-specific wrappers**\n+\n+Your cross-language Java transform can be called through the lower-level `ExternalTransform` class in a multi-language pipeline (as described in the next section); however, if possible, you should create a SDK-specific wrapper written in the programming language of the pipeline (such as Python) to access the transform instead. This higher-level abstraction will make it easier for pipeline authors to use your transform. ", "originalCommit": "5f373448e52b782dd3c0f5d4626db1a63289b4aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI0OTIyMg==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523249222", "bodyText": "Done", "author": "davidwrede", "createdAt": "2020-11-13T21:46:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU3NjQ3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU3ODAxNw==", "url": "https://github.com/apache/beam/pull/13317#discussion_r522578017", "bodyText": "Mention that the parameters mentioned here map to instance variables of the 'Configuration' Java class defined above.", "author": "chamikaramj", "createdAt": "2020-11-13T02:50:43Z", "path": "website/www/site/content/en/documentation/programming-guide.md", "diffHunk": "@@ -5431,4 +5431,282 @@ use case.\n \n {{< highlight py >}}\n {{< code_sample \"sdks/python/apache_beam/examples/snippets/snippets.py\" BundleFinalize >}}\n-{{< /highlight >}}\n\\ No newline at end of file\n+{{< /highlight >}}\n+\n+## 13. Multi-language pipelines {#mulit-language-pipelines}\n+\n+Beam allows you to combine transforms written in any supported SDK language (currently, Java and Python) and use them in one multi-language pipeline. This capability makes it easy to provide new functionality simultaneously in different Apache Beam SDKs through a single cross-language transform. For example, the Apache Kafka connector and SQL transform from the Java SDK can be used in Python streaming pipelines. \n+\n+Pipelines that use transforms from more than one SDK-language are known as multi-language pipelines.\n+\n+### 13.1. Creating cross-language transforms {#create-x-lang-transforms}\n+\n+To make transforms written in one language available to pipelines written in another language, an expansion service for that transform is used to create and inject the appropriate language-specific pipeline fragments into your pipeline. \n+\n+In the following example, a Python pipeline written the Apache Beam SDK for Python starts up a local Java expansion service on your computer to create and inject the appropriate Java pipeline fragments for executing the Java Kafka cross-language transform into your Python pipeline. The SDK then downloads and stages the necessary Java dependencies needed to execute these transforms.\n+\n+![Diagram of multi-language pipeline execution flow.](/images/multi-language-pipelines-diagram.svg)\n+\n+At runtime, the Beam runner will execute both Python and Java transforms to execute your pipeline.\n+\n+In this section, we will use [KafkaIO.Read](https://beam.apache.org/releases/javadoc/current/org/apache/beam/sdk/io/kafka/KafkaIO.Read.html) to illustrate how to create a cross-language transform for Java and a test example for Python.\n+\n+#### 13.1.1. Creating cross-language Java transforms\n+\n+To make your Apache Beam Java SDK transform portable across SDK languages, you must implement two interfaces: [ExternalTransformBuilder](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/ExternalTransformBuilder.java) and [ExternalTransformRegistrar](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/expansion/ExternalTransformRegistrar.java). The `ExternalTransformBuilder` interface constructs the cross-language transform using configuration values passed in from the pipeline and the `ExternalTransformRegistrar` interface registers the cross-language transform for use with the expansion service.\n+\n+**Implementing the interfaces**\n+\n+1. Define a Builder class for your transform that implements the `ExternalTransformBuilder` interface and overrides the `buildExternal` method that will be used to build your transform object. Initial configuration values for your transform should be defined in the `buildExternal` method. In most cases, it is convenient to make the Java transform builder class implement `ExternalTransformBuilder`.\n+\n+    > **Note:** `ExternalTransformBuilder` requires you to define a configuration object (a simple POJO) to capture a set of parameters sent by external SDKs to initiate the Java transform. Usually these parameters directly map to constructor parameters of the Java transform.\n+\n+    {{< highlight >}}\n+@AutoValue.Builder\n+abstract static class Builder<K, V>\n+  implements ExternalTransformBuilder<External.Configuration, PBegin, PCollection<KV<K, V>>> {\n+  abstract Builder<K, V> setConsumerConfig(Map<String, Object> config);\n+\n+  abstract Builder<K, V> setTopics(List<String> topics);\n+\n+  /** Remaining property declarations omitted for clarity. */\n+\n+  abstract Read<K, V> build();\n+\n+  @Override\n+  public PTransform<PBegin, PCollection<KV<K, V>>> buildExternal(\n+      External.Configuration config) {\n+    ImmutableList.Builder<String> listBuilder = ImmutableList.builder();\n+    for (String topic : config.topics) {\n+      listBuilder.add(topic);\n+    }\n+    setTopics(listBuilder.build());\n+\n+    /** Remaining property defaults omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+2. Register the transform as an external cross-language transform by defining a class that implements `ExternalTransformRegistrar`. You must annotate your class with the `AutoService` annotation to ensure that your transform is registered and instantiated properly by the expansion service.\n+3. In your registrar class, define a Uniform Resource Name (URN) for your transform. The URN must be a unique string that identifies your transform with the expansion service.\n+4. From within your registrar class, define a configuration class for the parameters used during the initialization of your transform by the external SDK.\n+\n+    The following example from the KafkaIO transform shows how to implement steps two through four:\n+\n+    {{< highlight >}}\n+@AutoService(ExternalTransformRegistrar.class)\n+public static class External implements ExternalTransformRegistrar {\n+\n+  public static final String URN = \"beam:external:java:kafka:read:v1\";\n+\n+  @Override\n+  public Map<String, Class<? extends ExternalTransformBuilder<?, ?, ?>>> knownBuilders() {\n+    return ImmutableMap.of(\n+        URN,\n+        (Class<? extends ExternalTransformBuilder<?, ?, ?>>)\n+            (Class<?>) AutoValue_KafkaIO_Read.Builder.class);\n+  }\n+\n+  /** Parameters class to expose the Read transform to an external SDK. */\n+  public static class Configuration {\n+    private Map<String, String> consumerConfig;\n+      private List<String> topics;\n+      \n+\n+      public void setConsumerConfig(Map<String, String> consumerConfig) {\n+        this.consumerConfig = consumerConfig;\n+      }\n+\n+      public void setTopics(List<String> topics) {\n+        this.topics = topics;\n+      }\n+\n+    /** Remaining properties omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+\n+After you have implemented the `ExternalTransformBuilder` and `ExternalTransformRegistrar` interfaces, your transform can be registered and created successfully by the default Java expansion service.\n+\n+**Using the expansion service**\n+\n+Java has a default expansion service included and available in the Apache Beam Java SDK. You can write your own expansion service, but that is generally not needed, so it is not covered in this section.\n+\n+Perform the following steps to start up a Java expansion service directly:\n+\n+{{< highlight >}}\n+// Path to a JAR file that contains the transform to expand, cross-language specific utilities (builder, registrar, etc.), and dependencies.\n+$ export EXPANSION_SERVICE_JAR=<My_expansion_service_JAR>  \n+\n+$ export PORT_FOR_EXPANSION_SERVICE=12345\n+\n+$ jar -jar $EXPANSION_SERVICE_JAR $PORT_FOR_EXPANSION_SERVICE\n+{{< /highlight >}}\n+\n+When creating SDK-specific wrappers for your transform, SDKs may provide utilities that are readily available for easily starting up an expansion service. For example, the Python SDK provides the [BeamJarExpansionService](https://github.com/apache/beam/blob/e6db419c97532f416c8e94d91b22b9688ca837a0/sdks/python/apache_beam/transforms/external.py#L522) utility for starting up a Java expansion service using a JAR file.\n+\n+**Including dependencies**\n+\n+If your transform requires external libraries, you can include them by adding them to the classpath of the expansion service. After they are included in the classpath, they will be staged when your transform is expanded by the expansion service.\n+\n+**Writing SDK-specific wrappers**\n+\n+Your cross-language Java transform can be called through the lower-level `ExternalTransform` class in a multi-language pipeline (as described in the next section); however, if possible, you should create a SDK-specific wrapper written in the programming language of the pipeline (such as Python) to access the transform instead. This higher-level abstraction will make it easier for pipeline authors to use your transform. \n+\n+To create an SDK wrapper for use in a Python pipeline, do the following:\n+\n+1. Create a Python module for your cross-language transform.\n+2. In the module, build the payload that should be used to initiate the cross-language transform expansion request using one of the available [PayloadBuilder](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py) classes.\n+\n+    The parameter names and types of the payload should map to parameter names and types of the configuration POJO provided to the Java `ExternalTransformBuilder`. Parameter types are mapped across SDKs using a [Beam schema](https://github.com/apache/beam/blob/master/model/pipeline/src/main/proto/schema.proto). Parameter names are mapped by simply converting Python underscore-separated variable names to camel-case (Java standard).\n+\n+    In the following example, kafka.py uses `NamedTupleBasedPayloadBuilder` to build the payload. The parameters map to the Java [KafkaIO.External.Configuration](https://github.com/apache/beam/blob/master/sdks/java/io/kafka/src/main/java/org/apache/beam/sdk/io/kafka/KafkaIO.java) config object.\n+\n+    {{< highlight >}}\n+ReadFromKafkaSchema = typing.NamedTuple(\n+  'ReadFromKafkaSchema',\n+  [\n+      ('consumer_config', typing.Mapping[unicode, unicode]),", "originalCommit": "5f373448e52b782dd3c0f5d4626db1a63289b4aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI1MDEyNw==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523250127", "bodyText": "Done", "author": "davidwrede", "createdAt": "2020-11-13T21:49:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU3ODAxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU3OTM2MA==", "url": "https://github.com/apache/beam/pull/13317#discussion_r522579360", "bodyText": "BeamJarExpansionService can only be used for wrappers defined in Beam. So may be expand to following to clarify.\n\"Start an expansion service unless one is specified by the pipeline creator.\nBeam Python SDK provides a utility, BeamJarExpansionService, for easily starting up an expansion service based on a jars released with Beam. To use this, do the following:\"", "author": "chamikaramj", "createdAt": "2020-11-13T02:55:48Z", "path": "website/www/site/content/en/documentation/programming-guide.md", "diffHunk": "@@ -5431,4 +5431,282 @@ use case.\n \n {{< highlight py >}}\n {{< code_sample \"sdks/python/apache_beam/examples/snippets/snippets.py\" BundleFinalize >}}\n-{{< /highlight >}}\n\\ No newline at end of file\n+{{< /highlight >}}\n+\n+## 13. Multi-language pipelines {#mulit-language-pipelines}\n+\n+Beam allows you to combine transforms written in any supported SDK language (currently, Java and Python) and use them in one multi-language pipeline. This capability makes it easy to provide new functionality simultaneously in different Apache Beam SDKs through a single cross-language transform. For example, the Apache Kafka connector and SQL transform from the Java SDK can be used in Python streaming pipelines. \n+\n+Pipelines that use transforms from more than one SDK-language are known as multi-language pipelines.\n+\n+### 13.1. Creating cross-language transforms {#create-x-lang-transforms}\n+\n+To make transforms written in one language available to pipelines written in another language, an expansion service for that transform is used to create and inject the appropriate language-specific pipeline fragments into your pipeline. \n+\n+In the following example, a Python pipeline written the Apache Beam SDK for Python starts up a local Java expansion service on your computer to create and inject the appropriate Java pipeline fragments for executing the Java Kafka cross-language transform into your Python pipeline. The SDK then downloads and stages the necessary Java dependencies needed to execute these transforms.\n+\n+![Diagram of multi-language pipeline execution flow.](/images/multi-language-pipelines-diagram.svg)\n+\n+At runtime, the Beam runner will execute both Python and Java transforms to execute your pipeline.\n+\n+In this section, we will use [KafkaIO.Read](https://beam.apache.org/releases/javadoc/current/org/apache/beam/sdk/io/kafka/KafkaIO.Read.html) to illustrate how to create a cross-language transform for Java and a test example for Python.\n+\n+#### 13.1.1. Creating cross-language Java transforms\n+\n+To make your Apache Beam Java SDK transform portable across SDK languages, you must implement two interfaces: [ExternalTransformBuilder](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/ExternalTransformBuilder.java) and [ExternalTransformRegistrar](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/expansion/ExternalTransformRegistrar.java). The `ExternalTransformBuilder` interface constructs the cross-language transform using configuration values passed in from the pipeline and the `ExternalTransformRegistrar` interface registers the cross-language transform for use with the expansion service.\n+\n+**Implementing the interfaces**\n+\n+1. Define a Builder class for your transform that implements the `ExternalTransformBuilder` interface and overrides the `buildExternal` method that will be used to build your transform object. Initial configuration values for your transform should be defined in the `buildExternal` method. In most cases, it is convenient to make the Java transform builder class implement `ExternalTransformBuilder`.\n+\n+    > **Note:** `ExternalTransformBuilder` requires you to define a configuration object (a simple POJO) to capture a set of parameters sent by external SDKs to initiate the Java transform. Usually these parameters directly map to constructor parameters of the Java transform.\n+\n+    {{< highlight >}}\n+@AutoValue.Builder\n+abstract static class Builder<K, V>\n+  implements ExternalTransformBuilder<External.Configuration, PBegin, PCollection<KV<K, V>>> {\n+  abstract Builder<K, V> setConsumerConfig(Map<String, Object> config);\n+\n+  abstract Builder<K, V> setTopics(List<String> topics);\n+\n+  /** Remaining property declarations omitted for clarity. */\n+\n+  abstract Read<K, V> build();\n+\n+  @Override\n+  public PTransform<PBegin, PCollection<KV<K, V>>> buildExternal(\n+      External.Configuration config) {\n+    ImmutableList.Builder<String> listBuilder = ImmutableList.builder();\n+    for (String topic : config.topics) {\n+      listBuilder.add(topic);\n+    }\n+    setTopics(listBuilder.build());\n+\n+    /** Remaining property defaults omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+2. Register the transform as an external cross-language transform by defining a class that implements `ExternalTransformRegistrar`. You must annotate your class with the `AutoService` annotation to ensure that your transform is registered and instantiated properly by the expansion service.\n+3. In your registrar class, define a Uniform Resource Name (URN) for your transform. The URN must be a unique string that identifies your transform with the expansion service.\n+4. From within your registrar class, define a configuration class for the parameters used during the initialization of your transform by the external SDK.\n+\n+    The following example from the KafkaIO transform shows how to implement steps two through four:\n+\n+    {{< highlight >}}\n+@AutoService(ExternalTransformRegistrar.class)\n+public static class External implements ExternalTransformRegistrar {\n+\n+  public static final String URN = \"beam:external:java:kafka:read:v1\";\n+\n+  @Override\n+  public Map<String, Class<? extends ExternalTransformBuilder<?, ?, ?>>> knownBuilders() {\n+    return ImmutableMap.of(\n+        URN,\n+        (Class<? extends ExternalTransformBuilder<?, ?, ?>>)\n+            (Class<?>) AutoValue_KafkaIO_Read.Builder.class);\n+  }\n+\n+  /** Parameters class to expose the Read transform to an external SDK. */\n+  public static class Configuration {\n+    private Map<String, String> consumerConfig;\n+      private List<String> topics;\n+      \n+\n+      public void setConsumerConfig(Map<String, String> consumerConfig) {\n+        this.consumerConfig = consumerConfig;\n+      }\n+\n+      public void setTopics(List<String> topics) {\n+        this.topics = topics;\n+      }\n+\n+    /** Remaining properties omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+\n+After you have implemented the `ExternalTransformBuilder` and `ExternalTransformRegistrar` interfaces, your transform can be registered and created successfully by the default Java expansion service.\n+\n+**Using the expansion service**\n+\n+Java has a default expansion service included and available in the Apache Beam Java SDK. You can write your own expansion service, but that is generally not needed, so it is not covered in this section.\n+\n+Perform the following steps to start up a Java expansion service directly:\n+\n+{{< highlight >}}\n+// Path to a JAR file that contains the transform to expand, cross-language specific utilities (builder, registrar, etc.), and dependencies.\n+$ export EXPANSION_SERVICE_JAR=<My_expansion_service_JAR>  \n+\n+$ export PORT_FOR_EXPANSION_SERVICE=12345\n+\n+$ jar -jar $EXPANSION_SERVICE_JAR $PORT_FOR_EXPANSION_SERVICE\n+{{< /highlight >}}\n+\n+When creating SDK-specific wrappers for your transform, SDKs may provide utilities that are readily available for easily starting up an expansion service. For example, the Python SDK provides the [BeamJarExpansionService](https://github.com/apache/beam/blob/e6db419c97532f416c8e94d91b22b9688ca837a0/sdks/python/apache_beam/transforms/external.py#L522) utility for starting up a Java expansion service using a JAR file.\n+\n+**Including dependencies**\n+\n+If your transform requires external libraries, you can include them by adding them to the classpath of the expansion service. After they are included in the classpath, they will be staged when your transform is expanded by the expansion service.\n+\n+**Writing SDK-specific wrappers**\n+\n+Your cross-language Java transform can be called through the lower-level `ExternalTransform` class in a multi-language pipeline (as described in the next section); however, if possible, you should create a SDK-specific wrapper written in the programming language of the pipeline (such as Python) to access the transform instead. This higher-level abstraction will make it easier for pipeline authors to use your transform. \n+\n+To create an SDK wrapper for use in a Python pipeline, do the following:\n+\n+1. Create a Python module for your cross-language transform.\n+2. In the module, build the payload that should be used to initiate the cross-language transform expansion request using one of the available [PayloadBuilder](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py) classes.\n+\n+    The parameter names and types of the payload should map to parameter names and types of the configuration POJO provided to the Java `ExternalTransformBuilder`. Parameter types are mapped across SDKs using a [Beam schema](https://github.com/apache/beam/blob/master/model/pipeline/src/main/proto/schema.proto). Parameter names are mapped by simply converting Python underscore-separated variable names to camel-case (Java standard).\n+\n+    In the following example, kafka.py uses `NamedTupleBasedPayloadBuilder` to build the payload. The parameters map to the Java [KafkaIO.External.Configuration](https://github.com/apache/beam/blob/master/sdks/java/io/kafka/src/main/java/org/apache/beam/sdk/io/kafka/KafkaIO.java) config object.\n+\n+    {{< highlight >}}\n+ReadFromKafkaSchema = typing.NamedTuple(\n+  'ReadFromKafkaSchema',\n+  [\n+      ('consumer_config', typing.Mapping[unicode, unicode]),\n+      ('topics', typing.List[unicode])\n+      # Other properties omitted for clarity.\n+  ])\n+payload = NamedTupleBasedPayloadBuilder(ReadFromKafkaSchema(...))\n+    {{< /highlight >}}\n+3. Start an expansion service unless one is specified by the pipeline creator. To use the `BeamJarExpansionService` utility from the Beam SDK, do the following:", "originalCommit": "5f373448e52b782dd3c0f5d4626db1a63289b4aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI1MjQ1MQ==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523252451", "bodyText": "Done", "author": "davidwrede", "createdAt": "2020-11-13T21:54:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU3OTM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU4MDgzMg==", "url": "https://github.com/apache/beam/pull/13317#discussion_r522580832", "bodyText": "I think we should call this something other than the \"wrapper class\" since we use that term for language wrappers defined to use cross-language transforms in other SDKs. How about \"Python module\" ?", "author": "chamikaramj", "createdAt": "2020-11-13T03:01:02Z", "path": "website/www/site/content/en/documentation/programming-guide.md", "diffHunk": "@@ -5431,4 +5431,282 @@ use case.\n \n {{< highlight py >}}\n {{< code_sample \"sdks/python/apache_beam/examples/snippets/snippets.py\" BundleFinalize >}}\n-{{< /highlight >}}\n\\ No newline at end of file\n+{{< /highlight >}}\n+\n+## 13. Multi-language pipelines {#mulit-language-pipelines}\n+\n+Beam allows you to combine transforms written in any supported SDK language (currently, Java and Python) and use them in one multi-language pipeline. This capability makes it easy to provide new functionality simultaneously in different Apache Beam SDKs through a single cross-language transform. For example, the Apache Kafka connector and SQL transform from the Java SDK can be used in Python streaming pipelines. \n+\n+Pipelines that use transforms from more than one SDK-language are known as multi-language pipelines.\n+\n+### 13.1. Creating cross-language transforms {#create-x-lang-transforms}\n+\n+To make transforms written in one language available to pipelines written in another language, an expansion service for that transform is used to create and inject the appropriate language-specific pipeline fragments into your pipeline. \n+\n+In the following example, a Python pipeline written the Apache Beam SDK for Python starts up a local Java expansion service on your computer to create and inject the appropriate Java pipeline fragments for executing the Java Kafka cross-language transform into your Python pipeline. The SDK then downloads and stages the necessary Java dependencies needed to execute these transforms.\n+\n+![Diagram of multi-language pipeline execution flow.](/images/multi-language-pipelines-diagram.svg)\n+\n+At runtime, the Beam runner will execute both Python and Java transforms to execute your pipeline.\n+\n+In this section, we will use [KafkaIO.Read](https://beam.apache.org/releases/javadoc/current/org/apache/beam/sdk/io/kafka/KafkaIO.Read.html) to illustrate how to create a cross-language transform for Java and a test example for Python.\n+\n+#### 13.1.1. Creating cross-language Java transforms\n+\n+To make your Apache Beam Java SDK transform portable across SDK languages, you must implement two interfaces: [ExternalTransformBuilder](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/ExternalTransformBuilder.java) and [ExternalTransformRegistrar](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/expansion/ExternalTransformRegistrar.java). The `ExternalTransformBuilder` interface constructs the cross-language transform using configuration values passed in from the pipeline and the `ExternalTransformRegistrar` interface registers the cross-language transform for use with the expansion service.\n+\n+**Implementing the interfaces**\n+\n+1. Define a Builder class for your transform that implements the `ExternalTransformBuilder` interface and overrides the `buildExternal` method that will be used to build your transform object. Initial configuration values for your transform should be defined in the `buildExternal` method. In most cases, it is convenient to make the Java transform builder class implement `ExternalTransformBuilder`.\n+\n+    > **Note:** `ExternalTransformBuilder` requires you to define a configuration object (a simple POJO) to capture a set of parameters sent by external SDKs to initiate the Java transform. Usually these parameters directly map to constructor parameters of the Java transform.\n+\n+    {{< highlight >}}\n+@AutoValue.Builder\n+abstract static class Builder<K, V>\n+  implements ExternalTransformBuilder<External.Configuration, PBegin, PCollection<KV<K, V>>> {\n+  abstract Builder<K, V> setConsumerConfig(Map<String, Object> config);\n+\n+  abstract Builder<K, V> setTopics(List<String> topics);\n+\n+  /** Remaining property declarations omitted for clarity. */\n+\n+  abstract Read<K, V> build();\n+\n+  @Override\n+  public PTransform<PBegin, PCollection<KV<K, V>>> buildExternal(\n+      External.Configuration config) {\n+    ImmutableList.Builder<String> listBuilder = ImmutableList.builder();\n+    for (String topic : config.topics) {\n+      listBuilder.add(topic);\n+    }\n+    setTopics(listBuilder.build());\n+\n+    /** Remaining property defaults omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+2. Register the transform as an external cross-language transform by defining a class that implements `ExternalTransformRegistrar`. You must annotate your class with the `AutoService` annotation to ensure that your transform is registered and instantiated properly by the expansion service.\n+3. In your registrar class, define a Uniform Resource Name (URN) for your transform. The URN must be a unique string that identifies your transform with the expansion service.\n+4. From within your registrar class, define a configuration class for the parameters used during the initialization of your transform by the external SDK.\n+\n+    The following example from the KafkaIO transform shows how to implement steps two through four:\n+\n+    {{< highlight >}}\n+@AutoService(ExternalTransformRegistrar.class)\n+public static class External implements ExternalTransformRegistrar {\n+\n+  public static final String URN = \"beam:external:java:kafka:read:v1\";\n+\n+  @Override\n+  public Map<String, Class<? extends ExternalTransformBuilder<?, ?, ?>>> knownBuilders() {\n+    return ImmutableMap.of(\n+        URN,\n+        (Class<? extends ExternalTransformBuilder<?, ?, ?>>)\n+            (Class<?>) AutoValue_KafkaIO_Read.Builder.class);\n+  }\n+\n+  /** Parameters class to expose the Read transform to an external SDK. */\n+  public static class Configuration {\n+    private Map<String, String> consumerConfig;\n+      private List<String> topics;\n+      \n+\n+      public void setConsumerConfig(Map<String, String> consumerConfig) {\n+        this.consumerConfig = consumerConfig;\n+      }\n+\n+      public void setTopics(List<String> topics) {\n+        this.topics = topics;\n+      }\n+\n+    /** Remaining properties omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+\n+After you have implemented the `ExternalTransformBuilder` and `ExternalTransformRegistrar` interfaces, your transform can be registered and created successfully by the default Java expansion service.\n+\n+**Using the expansion service**\n+\n+Java has a default expansion service included and available in the Apache Beam Java SDK. You can write your own expansion service, but that is generally not needed, so it is not covered in this section.\n+\n+Perform the following steps to start up a Java expansion service directly:\n+\n+{{< highlight >}}\n+// Path to a JAR file that contains the transform to expand, cross-language specific utilities (builder, registrar, etc.), and dependencies.\n+$ export EXPANSION_SERVICE_JAR=<My_expansion_service_JAR>  \n+\n+$ export PORT_FOR_EXPANSION_SERVICE=12345\n+\n+$ jar -jar $EXPANSION_SERVICE_JAR $PORT_FOR_EXPANSION_SERVICE\n+{{< /highlight >}}\n+\n+When creating SDK-specific wrappers for your transform, SDKs may provide utilities that are readily available for easily starting up an expansion service. For example, the Python SDK provides the [BeamJarExpansionService](https://github.com/apache/beam/blob/e6db419c97532f416c8e94d91b22b9688ca837a0/sdks/python/apache_beam/transforms/external.py#L522) utility for starting up a Java expansion service using a JAR file.\n+\n+**Including dependencies**\n+\n+If your transform requires external libraries, you can include them by adding them to the classpath of the expansion service. After they are included in the classpath, they will be staged when your transform is expanded by the expansion service.\n+\n+**Writing SDK-specific wrappers**\n+\n+Your cross-language Java transform can be called through the lower-level `ExternalTransform` class in a multi-language pipeline (as described in the next section); however, if possible, you should create a SDK-specific wrapper written in the programming language of the pipeline (such as Python) to access the transform instead. This higher-level abstraction will make it easier for pipeline authors to use your transform. \n+\n+To create an SDK wrapper for use in a Python pipeline, do the following:\n+\n+1. Create a Python module for your cross-language transform.\n+2. In the module, build the payload that should be used to initiate the cross-language transform expansion request using one of the available [PayloadBuilder](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py) classes.\n+\n+    The parameter names and types of the payload should map to parameter names and types of the configuration POJO provided to the Java `ExternalTransformBuilder`. Parameter types are mapped across SDKs using a [Beam schema](https://github.com/apache/beam/blob/master/model/pipeline/src/main/proto/schema.proto). Parameter names are mapped by simply converting Python underscore-separated variable names to camel-case (Java standard).\n+\n+    In the following example, kafka.py uses `NamedTupleBasedPayloadBuilder` to build the payload. The parameters map to the Java [KafkaIO.External.Configuration](https://github.com/apache/beam/blob/master/sdks/java/io/kafka/src/main/java/org/apache/beam/sdk/io/kafka/KafkaIO.java) config object.\n+\n+    {{< highlight >}}\n+ReadFromKafkaSchema = typing.NamedTuple(\n+  'ReadFromKafkaSchema',\n+  [\n+      ('consumer_config', typing.Mapping[unicode, unicode]),\n+      ('topics', typing.List[unicode])\n+      # Other properties omitted for clarity.\n+  ])\n+payload = NamedTupleBasedPayloadBuilder(ReadFromKafkaSchema(...))\n+    {{< /highlight >}}\n+3. Start an expansion service unless one is specified by the pipeline creator. To use the `BeamJarExpansionService` utility from the Beam SDK, do the following:\n+\n+    1. Add a Gradle target to Beam that can be used to build a shaded expansion service JAR for the target Java transform. This target should produce a Beam JAR that contains all dependencies needed for expanding the Java transform and the JAR should be released with Beam.\n+    2. In your Python module, instantiate `BeamJarExpansionService` with the Gradle target.\n+\n+        {{< highlight >}}\n+    expansion_service = BeamJarExpansionService('sdks:java:io:expansion-service:shadowJar')\n+        {{< /highlight >}}\n+4. Add a Python wrapper transform class that extends [ExternalTransform](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py). Pass the payload and expansion service defined above as parameters to the constructor of the `ExternalTransform` parent class.\n+\n+#### 13.1.2. Creating cross-language Python transforms\n+\n+To make your Python transform usable with different SDK languages, you must create a wrapper class that registers an existing Python transform as a cross-language transform for use with the Python expansion service and calls into that existing transform to perform its intended operation.\n+\n+**Defining the wrapper class**", "originalCommit": "5f373448e52b782dd3c0f5d4626db1a63289b4aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI1NDI3Mw==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523254273", "bodyText": "Yup, sounds good.", "author": "davidwrede", "createdAt": "2020-11-13T21:56:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU4MDgzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU4NTgwOA==", "url": "https://github.com/apache/beam/pull/13317#discussion_r522585808", "bodyText": "Add a link to https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py", "author": "chamikaramj", "createdAt": "2020-11-13T03:08:44Z", "path": "website/www/site/content/en/documentation/programming-guide.md", "diffHunk": "@@ -5431,4 +5431,282 @@ use case.\n \n {{< highlight py >}}\n {{< code_sample \"sdks/python/apache_beam/examples/snippets/snippets.py\" BundleFinalize >}}\n-{{< /highlight >}}\n\\ No newline at end of file\n+{{< /highlight >}}\n+\n+## 13. Multi-language pipelines {#mulit-language-pipelines}\n+\n+Beam allows you to combine transforms written in any supported SDK language (currently, Java and Python) and use them in one multi-language pipeline. This capability makes it easy to provide new functionality simultaneously in different Apache Beam SDKs through a single cross-language transform. For example, the Apache Kafka connector and SQL transform from the Java SDK can be used in Python streaming pipelines. \n+\n+Pipelines that use transforms from more than one SDK-language are known as multi-language pipelines.\n+\n+### 13.1. Creating cross-language transforms {#create-x-lang-transforms}\n+\n+To make transforms written in one language available to pipelines written in another language, an expansion service for that transform is used to create and inject the appropriate language-specific pipeline fragments into your pipeline. \n+\n+In the following example, a Python pipeline written the Apache Beam SDK for Python starts up a local Java expansion service on your computer to create and inject the appropriate Java pipeline fragments for executing the Java Kafka cross-language transform into your Python pipeline. The SDK then downloads and stages the necessary Java dependencies needed to execute these transforms.\n+\n+![Diagram of multi-language pipeline execution flow.](/images/multi-language-pipelines-diagram.svg)\n+\n+At runtime, the Beam runner will execute both Python and Java transforms to execute your pipeline.\n+\n+In this section, we will use [KafkaIO.Read](https://beam.apache.org/releases/javadoc/current/org/apache/beam/sdk/io/kafka/KafkaIO.Read.html) to illustrate how to create a cross-language transform for Java and a test example for Python.\n+\n+#### 13.1.1. Creating cross-language Java transforms\n+\n+To make your Apache Beam Java SDK transform portable across SDK languages, you must implement two interfaces: [ExternalTransformBuilder](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/ExternalTransformBuilder.java) and [ExternalTransformRegistrar](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/expansion/ExternalTransformRegistrar.java). The `ExternalTransformBuilder` interface constructs the cross-language transform using configuration values passed in from the pipeline and the `ExternalTransformRegistrar` interface registers the cross-language transform for use with the expansion service.\n+\n+**Implementing the interfaces**\n+\n+1. Define a Builder class for your transform that implements the `ExternalTransformBuilder` interface and overrides the `buildExternal` method that will be used to build your transform object. Initial configuration values for your transform should be defined in the `buildExternal` method. In most cases, it is convenient to make the Java transform builder class implement `ExternalTransformBuilder`.\n+\n+    > **Note:** `ExternalTransformBuilder` requires you to define a configuration object (a simple POJO) to capture a set of parameters sent by external SDKs to initiate the Java transform. Usually these parameters directly map to constructor parameters of the Java transform.\n+\n+    {{< highlight >}}\n+@AutoValue.Builder\n+abstract static class Builder<K, V>\n+  implements ExternalTransformBuilder<External.Configuration, PBegin, PCollection<KV<K, V>>> {\n+  abstract Builder<K, V> setConsumerConfig(Map<String, Object> config);\n+\n+  abstract Builder<K, V> setTopics(List<String> topics);\n+\n+  /** Remaining property declarations omitted for clarity. */\n+\n+  abstract Read<K, V> build();\n+\n+  @Override\n+  public PTransform<PBegin, PCollection<KV<K, V>>> buildExternal(\n+      External.Configuration config) {\n+    ImmutableList.Builder<String> listBuilder = ImmutableList.builder();\n+    for (String topic : config.topics) {\n+      listBuilder.add(topic);\n+    }\n+    setTopics(listBuilder.build());\n+\n+    /** Remaining property defaults omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+2. Register the transform as an external cross-language transform by defining a class that implements `ExternalTransformRegistrar`. You must annotate your class with the `AutoService` annotation to ensure that your transform is registered and instantiated properly by the expansion service.\n+3. In your registrar class, define a Uniform Resource Name (URN) for your transform. The URN must be a unique string that identifies your transform with the expansion service.\n+4. From within your registrar class, define a configuration class for the parameters used during the initialization of your transform by the external SDK.\n+\n+    The following example from the KafkaIO transform shows how to implement steps two through four:\n+\n+    {{< highlight >}}\n+@AutoService(ExternalTransformRegistrar.class)\n+public static class External implements ExternalTransformRegistrar {\n+\n+  public static final String URN = \"beam:external:java:kafka:read:v1\";\n+\n+  @Override\n+  public Map<String, Class<? extends ExternalTransformBuilder<?, ?, ?>>> knownBuilders() {\n+    return ImmutableMap.of(\n+        URN,\n+        (Class<? extends ExternalTransformBuilder<?, ?, ?>>)\n+            (Class<?>) AutoValue_KafkaIO_Read.Builder.class);\n+  }\n+\n+  /** Parameters class to expose the Read transform to an external SDK. */\n+  public static class Configuration {\n+    private Map<String, String> consumerConfig;\n+      private List<String> topics;\n+      \n+\n+      public void setConsumerConfig(Map<String, String> consumerConfig) {\n+        this.consumerConfig = consumerConfig;\n+      }\n+\n+      public void setTopics(List<String> topics) {\n+        this.topics = topics;\n+      }\n+\n+    /** Remaining properties omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+\n+After you have implemented the `ExternalTransformBuilder` and `ExternalTransformRegistrar` interfaces, your transform can be registered and created successfully by the default Java expansion service.\n+\n+**Using the expansion service**\n+\n+Java has a default expansion service included and available in the Apache Beam Java SDK. You can write your own expansion service, but that is generally not needed, so it is not covered in this section.\n+\n+Perform the following steps to start up a Java expansion service directly:\n+\n+{{< highlight >}}\n+// Path to a JAR file that contains the transform to expand, cross-language specific utilities (builder, registrar, etc.), and dependencies.\n+$ export EXPANSION_SERVICE_JAR=<My_expansion_service_JAR>  \n+\n+$ export PORT_FOR_EXPANSION_SERVICE=12345\n+\n+$ jar -jar $EXPANSION_SERVICE_JAR $PORT_FOR_EXPANSION_SERVICE\n+{{< /highlight >}}\n+\n+When creating SDK-specific wrappers for your transform, SDKs may provide utilities that are readily available for easily starting up an expansion service. For example, the Python SDK provides the [BeamJarExpansionService](https://github.com/apache/beam/blob/e6db419c97532f416c8e94d91b22b9688ca837a0/sdks/python/apache_beam/transforms/external.py#L522) utility for starting up a Java expansion service using a JAR file.\n+\n+**Including dependencies**\n+\n+If your transform requires external libraries, you can include them by adding them to the classpath of the expansion service. After they are included in the classpath, they will be staged when your transform is expanded by the expansion service.\n+\n+**Writing SDK-specific wrappers**\n+\n+Your cross-language Java transform can be called through the lower-level `ExternalTransform` class in a multi-language pipeline (as described in the next section); however, if possible, you should create a SDK-specific wrapper written in the programming language of the pipeline (such as Python) to access the transform instead. This higher-level abstraction will make it easier for pipeline authors to use your transform. \n+\n+To create an SDK wrapper for use in a Python pipeline, do the following:\n+\n+1. Create a Python module for your cross-language transform.\n+2. In the module, build the payload that should be used to initiate the cross-language transform expansion request using one of the available [PayloadBuilder](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py) classes.\n+\n+    The parameter names and types of the payload should map to parameter names and types of the configuration POJO provided to the Java `ExternalTransformBuilder`. Parameter types are mapped across SDKs using a [Beam schema](https://github.com/apache/beam/blob/master/model/pipeline/src/main/proto/schema.proto). Parameter names are mapped by simply converting Python underscore-separated variable names to camel-case (Java standard).\n+\n+    In the following example, kafka.py uses `NamedTupleBasedPayloadBuilder` to build the payload. The parameters map to the Java [KafkaIO.External.Configuration](https://github.com/apache/beam/blob/master/sdks/java/io/kafka/src/main/java/org/apache/beam/sdk/io/kafka/KafkaIO.java) config object.\n+\n+    {{< highlight >}}\n+ReadFromKafkaSchema = typing.NamedTuple(\n+  'ReadFromKafkaSchema',\n+  [\n+      ('consumer_config', typing.Mapping[unicode, unicode]),\n+      ('topics', typing.List[unicode])\n+      # Other properties omitted for clarity.\n+  ])\n+payload = NamedTupleBasedPayloadBuilder(ReadFromKafkaSchema(...))\n+    {{< /highlight >}}\n+3. Start an expansion service unless one is specified by the pipeline creator. To use the `BeamJarExpansionService` utility from the Beam SDK, do the following:\n+\n+    1. Add a Gradle target to Beam that can be used to build a shaded expansion service JAR for the target Java transform. This target should produce a Beam JAR that contains all dependencies needed for expanding the Java transform and the JAR should be released with Beam.\n+    2. In your Python module, instantiate `BeamJarExpansionService` with the Gradle target.\n+\n+        {{< highlight >}}\n+    expansion_service = BeamJarExpansionService('sdks:java:io:expansion-service:shadowJar')\n+        {{< /highlight >}}\n+4. Add a Python wrapper transform class that extends [ExternalTransform](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py). Pass the payload and expansion service defined above as parameters to the constructor of the `ExternalTransform` parent class.\n+\n+#### 13.1.2. Creating cross-language Python transforms\n+\n+To make your Python transform usable with different SDK languages, you must create a wrapper class that registers an existing Python transform as a cross-language transform for use with the Python expansion service and calls into that existing transform to perform its intended operation.\n+\n+**Defining the wrapper class**\n+\n+1. Define a Uniform Resource Name (URN) for your transform. The URN must be a unique string that identifies your transform with the expansion service.\n+\n+    {{< highlight >}}\n+TEST_COMPK_URN = \"beam:transforms:xlang:test:compk\"\n+    {{< /highlight >}}\n+2. For an existing Python transform, create a new wrapper class to register the URN with the Python expansion service.\n+\n+    {{< highlight >}}\n+@ptransform.PTransform.register_urn(TEST_COMPK_URN, None)\n+class CombinePerKeyTransform(ptransform.PTransform):\n+    {{< /highlight >}}\n+3. From within the class, define an expand method that takes an input PCollection, runs the Python transform, and then returns the output PCollection.\n+\n+    {{< highlight >}}\n+def expand(self, pcoll):\n+    return pcoll \\\n+        | beam.CombinePerKey(sum).with_output_types(\n+              typing.Tuple[unicode, int])\n+    {{< /highlight >}}\n+4. As with other Python transforms, define a `to_runner_api_parameter` method that returns the URN.\n+\n+    {{< highlight >}}\n+def to_runner_api_parameter(self, unused_context):\n+    return TEST_COMPK_URN, None\n+    {{< /highlight >}}\n+5. Define a static `from_runner_api_parameter` method that returns an instantiation of the cross-language Python transform.\n+\n+    {{< highlight >}}\n+@staticmethod\n+def from_runner_api_parameter(\n+      unused_ptransform, unused_parameter, unused_context):\n+    return CombinePerKeyTransform()\n+    {{< /highlight >}}\n+\n+**Using the expansion service**\n+\n+Python has a default expansion service included and available in the Apache Beam SDK. You are free to write your own expansion service, but that is generally not needed, so it is not covered in this section.\n+\n+Perform the following steps to start up the default Python expansion service directly:\n+\n+1. Create a virtual environment and [install the Apache Beam SDK](https://beam.apache.org/get-started/quickstart-py/).\n+2. Start the Python SDK\u2019s expansion service with a specified port.\n+\n+    {{< highlight >}}\n+$ export PORT_FOR_EXPANSION_SERVICE=12345\n+$ python -m apache_beam.runners.portability.expansion_service -p $PORT_FOR_EXPANSION_SERVICE\n+    {{< /highlight >}}\n+\n+**Including dependencies**\n+\n+If your transform requires external libraries, make sure those dependencies are already specified in a custom container for SDK harness. Core Apache Beam dependencies are already included.\n+\n+### 13.2. Using cross-language transforms {#use-x-lang-transforms}\n+\n+Depending on the SDK language of the pipeline, you can use a high-level SDK-wrapper class, or a low-level transform class to access a cross-language transform. \n+\n+#### 13.2.1. Using cross-language transforms in a Java pipeline\n+\n+Currently, to access cross-language transforms from the Java SDK, you have to use the lower-level [External](https://github.com/apache/beam/blob/master/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/External.java) class.\n+\n+**Using the External class**\n+\n+1. Make sure you have any runtime environment dependencies (like JRE) installed on your local machine (either directly on the local machine or available through a container). See the expansion service section for more details.\n+\n+    > **Note:** When including Python transforms from within a Java pipeline, all python dependencies have to be baked into the SDK harness container.\n+2. Start up the expansion service for the SDK that is in the language of the transform you're trying to consume, if not available. \n+\n+    Make sure the transform you are trying to use is available and can be used by the expansion service.\n+3. Include [External.of(...)](https://github.com/apache/beam/blob/master/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/External.java) when instantiating your pipeline. Reference the URN, payload, and expansion service. For examples, see the [cross-language transform test suite](https://github.com/apache/beam/blob/master/runners/core-construction-java/src/test/java/org/apache/beam/runners/core/construction/ValidateRunnerXlangTest.java).\n+4. After the job has been submitted to the Beam runner, shutdown the expansion service by terminating the expansion service process.\n+\n+#### 13.2.2 Using cross-language transforms in a Python pipeline\n+\n+If a Python-specific wrapper for a cross-language transform is available, use that; otherwise, you have to use the lower-level `ExternalTransform` class to access the transform.", "originalCommit": "5f373448e52b782dd3c0f5d4626db1a63289b4aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI1NTA1MQ==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523255051", "bodyText": "Done.", "author": "davidwrede", "createdAt": "2020-11-13T21:56:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU4NTgwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI4Mzg3Mg==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523283872", "bodyText": "Often an expansion services vends several transforms.", "author": "robertwb", "createdAt": "2020-11-13T23:29:26Z", "path": "website/www/site/content/en/documentation/programming-guide.md", "diffHunk": "@@ -5431,4 +5431,280 @@ use case.\n \n {{< highlight py >}}\n {{< code_sample \"sdks/python/apache_beam/examples/snippets/snippets.py\" BundleFinalize >}}\n-{{< /highlight >}}\n\\ No newline at end of file\n+{{< /highlight >}}\n+\n+## 13. Multi-language pipelines {#mulit-language-pipelines}\n+\n+Beam allows you to combine transforms written in any supported SDK language (currently, Java and Python) and use them in one multi-language pipeline. This capability makes it easy to provide new functionality simultaneously in different Apache Beam SDKs through a single cross-language transform. For example, the [Apache Kafka connector](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/io/kafka.py) and [SQL transform](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/sql.py) from the Java SDK can be used in Python streaming pipelines.\n+\n+Pipelines that use transforms from more than one SDK-language are known as *multi-language pipelines*.\n+\n+### 13.1. Creating cross-language transforms {#create-x-lang-transforms}\n+\n+To make transforms written in one language available to pipelines written in another language, an *expansion service* for that transform is used to create and inject the appropriate language-specific pipeline fragments into your pipeline.", "originalCommit": "f2fb2a1604c620a1a3d753400fe0f3444c5ec821", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI5OTI0NA==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523299244", "bodyText": "Added clarification.", "author": "davidwrede", "createdAt": "2020-11-14T00:28:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI4Mzg3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI4NDk3OQ==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523284979", "bodyText": "Is the double cast needed? Perhaps it would be simpler to add the type parameters to ImmutableMap.of, i.e. ImmutableMap.of<String, Class<? extends ExternalTransformBuilder<?, ?, ?>>>(...).", "author": "robertwb", "createdAt": "2020-11-13T23:33:43Z", "path": "website/www/site/content/en/documentation/programming-guide.md", "diffHunk": "@@ -5431,4 +5431,280 @@ use case.\n \n {{< highlight py >}}\n {{< code_sample \"sdks/python/apache_beam/examples/snippets/snippets.py\" BundleFinalize >}}\n-{{< /highlight >}}\n\\ No newline at end of file\n+{{< /highlight >}}\n+\n+## 13. Multi-language pipelines {#mulit-language-pipelines}\n+\n+Beam allows you to combine transforms written in any supported SDK language (currently, Java and Python) and use them in one multi-language pipeline. This capability makes it easy to provide new functionality simultaneously in different Apache Beam SDKs through a single cross-language transform. For example, the [Apache Kafka connector](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/io/kafka.py) and [SQL transform](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/sql.py) from the Java SDK can be used in Python streaming pipelines.\n+\n+Pipelines that use transforms from more than one SDK-language are known as *multi-language pipelines*.\n+\n+### 13.1. Creating cross-language transforms {#create-x-lang-transforms}\n+\n+To make transforms written in one language available to pipelines written in another language, an *expansion service* for that transform is used to create and inject the appropriate language-specific pipeline fragments into your pipeline.\n+\n+In the following example, a Python pipeline written the Apache Beam SDK for Python starts up a local Java expansion service on your computer to create and inject the appropriate Java pipeline fragments for executing the Java Kafka cross-language transform into your Python pipeline. The SDK then downloads and stages the necessary Java dependencies needed to execute these transforms.\n+\n+![Diagram of multi-language pipeline execution flow.](/images/multi-language-pipelines-diagram.svg)\n+\n+At runtime, the Beam runner will execute both Python and Java transforms to execute your pipeline.\n+\n+In this section, we will use [KafkaIO.Read](https://beam.apache.org/releases/javadoc/current/org/apache/beam/sdk/io/kafka/KafkaIO.Read.html) to illustrate how to create a cross-language transform for Java and a test example for Python.\n+\n+#### 13.1.1. Creating cross-language Java transforms\n+\n+To make your Apache Beam Java SDK transform portable across SDK languages, you must implement two interfaces: [ExternalTransformBuilder](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/ExternalTransformBuilder.java) and [ExternalTransformRegistrar](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/expansion/ExternalTransformRegistrar.java). The `ExternalTransformBuilder` interface constructs the cross-language transform using configuration values passed in from the pipeline and the `ExternalTransformRegistrar` interface registers the cross-language transform for use with the expansion service.\n+\n+**Implementing the interfaces**\n+\n+1. Define a Builder class for your transform that implements the `ExternalTransformBuilder` interface and overrides the `buildExternal` method that will be used to build your transform object. Initial configuration values for your transform should be defined in the `buildExternal` method. In most cases, it is convenient to make the Java transform builder class implement `ExternalTransformBuilder`.\n+\n+    > **Note:** `ExternalTransformBuilder` requires you to define a configuration object (a simple POJO) to capture a set of parameters sent by external SDKs to initiate the Java transform. Usually these parameters directly map to constructor parameters of the Java transform.\n+\n+    {{< highlight >}}\n+@AutoValue.Builder\n+abstract static class Builder<K, V>\n+  implements ExternalTransformBuilder<External.Configuration, PBegin, PCollection<KV<K, V>>> {\n+  abstract Builder<K, V> setConsumerConfig(Map<String, Object> config);\n+\n+  abstract Builder<K, V> setTopics(List<String> topics);\n+\n+  /** Remaining property declarations omitted for clarity. */\n+\n+  abstract Read<K, V> build();\n+\n+  @Override\n+  public PTransform<PBegin, PCollection<KV<K, V>>> buildExternal(\n+      External.Configuration config) {\n+    ImmutableList.Builder<String> listBuilder = ImmutableList.builder();\n+    for (String topic : config.topics) {\n+      listBuilder.add(topic);\n+    }\n+    setTopics(listBuilder.build());\n+\n+    /** Remaining property defaults omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+2. Register the transform as an external cross-language transform by defining a class that implements `ExternalTransformRegistrar`. You must annotate your class with the `AutoService` annotation to ensure that your transform is registered and instantiated properly by the expansion service.\n+3. In your registrar class, define a Uniform Resource Name (URN) for your transform. The URN must be a unique string that identifies your transform with the expansion service.\n+4. From within your registrar class, define a configuration class for the parameters used during the initialization of your transform by the external SDK.\n+\n+    The following example from the KafkaIO transform shows how to implement steps two through four:\n+\n+    {{< highlight >}}\n+@AutoService(ExternalTransformRegistrar.class)\n+public static class External implements ExternalTransformRegistrar {\n+\n+  public static final String URN = \"beam:external:java:kafka:read:v1\";\n+\n+  @Override\n+  public Map<String, Class<? extends ExternalTransformBuilder<?, ?, ?>>> knownBuilders() {\n+    return ImmutableMap.of(\n+        URN,\n+        (Class<? extends ExternalTransformBuilder<?, ?, ?>>)", "originalCommit": "f2fb2a1604c620a1a3d753400fe0f3444c5ec821", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1NzA5NA==", "url": "https://github.com/apache/beam/pull/13317#discussion_r525557094", "bodyText": "Hmm, I tried the suggestion and it doesn't seem to be working. Note that this snippet is from actual class: https://github.com/apache/beam/blob/master/sdks/java/io/kafka/src/main/java/org/apache/beam/sdk/io/kafka/KafkaIO.java#L632", "author": "chamikaramj", "createdAt": "2020-11-17T22:07:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI4NDk3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk1Mjc5OA==", "url": "https://github.com/apache/beam/pull/13317#discussion_r527952798", "bodyText": "OK, it's a bit ugly we can leave it as is for now.", "author": "robertwb", "createdAt": "2020-11-20T20:27:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI4NDk3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI4NTExMQ==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523285111", "bodyText": "Remove extra newline.", "author": "robertwb", "createdAt": "2020-11-13T23:34:17Z", "path": "website/www/site/content/en/documentation/programming-guide.md", "diffHunk": "@@ -5431,4 +5431,280 @@ use case.\n \n {{< highlight py >}}\n {{< code_sample \"sdks/python/apache_beam/examples/snippets/snippets.py\" BundleFinalize >}}\n-{{< /highlight >}}\n\\ No newline at end of file\n+{{< /highlight >}}\n+\n+## 13. Multi-language pipelines {#mulit-language-pipelines}\n+\n+Beam allows you to combine transforms written in any supported SDK language (currently, Java and Python) and use them in one multi-language pipeline. This capability makes it easy to provide new functionality simultaneously in different Apache Beam SDKs through a single cross-language transform. For example, the [Apache Kafka connector](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/io/kafka.py) and [SQL transform](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/sql.py) from the Java SDK can be used in Python streaming pipelines.\n+\n+Pipelines that use transforms from more than one SDK-language are known as *multi-language pipelines*.\n+\n+### 13.1. Creating cross-language transforms {#create-x-lang-transforms}\n+\n+To make transforms written in one language available to pipelines written in another language, an *expansion service* for that transform is used to create and inject the appropriate language-specific pipeline fragments into your pipeline.\n+\n+In the following example, a Python pipeline written the Apache Beam SDK for Python starts up a local Java expansion service on your computer to create and inject the appropriate Java pipeline fragments for executing the Java Kafka cross-language transform into your Python pipeline. The SDK then downloads and stages the necessary Java dependencies needed to execute these transforms.\n+\n+![Diagram of multi-language pipeline execution flow.](/images/multi-language-pipelines-diagram.svg)\n+\n+At runtime, the Beam runner will execute both Python and Java transforms to execute your pipeline.\n+\n+In this section, we will use [KafkaIO.Read](https://beam.apache.org/releases/javadoc/current/org/apache/beam/sdk/io/kafka/KafkaIO.Read.html) to illustrate how to create a cross-language transform for Java and a test example for Python.\n+\n+#### 13.1.1. Creating cross-language Java transforms\n+\n+To make your Apache Beam Java SDK transform portable across SDK languages, you must implement two interfaces: [ExternalTransformBuilder](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/ExternalTransformBuilder.java) and [ExternalTransformRegistrar](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/expansion/ExternalTransformRegistrar.java). The `ExternalTransformBuilder` interface constructs the cross-language transform using configuration values passed in from the pipeline and the `ExternalTransformRegistrar` interface registers the cross-language transform for use with the expansion service.\n+\n+**Implementing the interfaces**\n+\n+1. Define a Builder class for your transform that implements the `ExternalTransformBuilder` interface and overrides the `buildExternal` method that will be used to build your transform object. Initial configuration values for your transform should be defined in the `buildExternal` method. In most cases, it is convenient to make the Java transform builder class implement `ExternalTransformBuilder`.\n+\n+    > **Note:** `ExternalTransformBuilder` requires you to define a configuration object (a simple POJO) to capture a set of parameters sent by external SDKs to initiate the Java transform. Usually these parameters directly map to constructor parameters of the Java transform.\n+\n+    {{< highlight >}}\n+@AutoValue.Builder\n+abstract static class Builder<K, V>\n+  implements ExternalTransformBuilder<External.Configuration, PBegin, PCollection<KV<K, V>>> {\n+  abstract Builder<K, V> setConsumerConfig(Map<String, Object> config);\n+\n+  abstract Builder<K, V> setTopics(List<String> topics);\n+\n+  /** Remaining property declarations omitted for clarity. */\n+\n+  abstract Read<K, V> build();\n+\n+  @Override\n+  public PTransform<PBegin, PCollection<KV<K, V>>> buildExternal(\n+      External.Configuration config) {\n+    ImmutableList.Builder<String> listBuilder = ImmutableList.builder();\n+    for (String topic : config.topics) {\n+      listBuilder.add(topic);\n+    }\n+    setTopics(listBuilder.build());\n+\n+    /** Remaining property defaults omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+2. Register the transform as an external cross-language transform by defining a class that implements `ExternalTransformRegistrar`. You must annotate your class with the `AutoService` annotation to ensure that your transform is registered and instantiated properly by the expansion service.\n+3. In your registrar class, define a Uniform Resource Name (URN) for your transform. The URN must be a unique string that identifies your transform with the expansion service.\n+4. From within your registrar class, define a configuration class for the parameters used during the initialization of your transform by the external SDK.\n+\n+    The following example from the KafkaIO transform shows how to implement steps two through four:\n+\n+    {{< highlight >}}\n+@AutoService(ExternalTransformRegistrar.class)\n+public static class External implements ExternalTransformRegistrar {\n+\n+  public static final String URN = \"beam:external:java:kafka:read:v1\";\n+\n+  @Override\n+  public Map<String, Class<? extends ExternalTransformBuilder<?, ?, ?>>> knownBuilders() {\n+    return ImmutableMap.of(\n+        URN,\n+        (Class<? extends ExternalTransformBuilder<?, ?, ?>>)\n+            (Class<?>) AutoValue_KafkaIO_Read.Builder.class);\n+  }\n+\n+  /** Parameters class to expose the Read transform to an external SDK. */\n+  public static class Configuration {\n+    private Map<String, String> consumerConfig;\n+      private List<String> topics;\n+", "originalCommit": "f2fb2a1604c620a1a3d753400fe0f3444c5ec821", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI5ODkzNg==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523298936", "bodyText": "Done", "author": "davidwrede", "createdAt": "2020-11-14T00:26:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI4NTExMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI4NTIzOA==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523285238", "bodyText": "Align whitespace.", "author": "robertwb", "createdAt": "2020-11-13T23:34:40Z", "path": "website/www/site/content/en/documentation/programming-guide.md", "diffHunk": "@@ -5431,4 +5431,280 @@ use case.\n \n {{< highlight py >}}\n {{< code_sample \"sdks/python/apache_beam/examples/snippets/snippets.py\" BundleFinalize >}}\n-{{< /highlight >}}\n\\ No newline at end of file\n+{{< /highlight >}}\n+\n+## 13. Multi-language pipelines {#mulit-language-pipelines}\n+\n+Beam allows you to combine transforms written in any supported SDK language (currently, Java and Python) and use them in one multi-language pipeline. This capability makes it easy to provide new functionality simultaneously in different Apache Beam SDKs through a single cross-language transform. For example, the [Apache Kafka connector](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/io/kafka.py) and [SQL transform](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/sql.py) from the Java SDK can be used in Python streaming pipelines.\n+\n+Pipelines that use transforms from more than one SDK-language are known as *multi-language pipelines*.\n+\n+### 13.1. Creating cross-language transforms {#create-x-lang-transforms}\n+\n+To make transforms written in one language available to pipelines written in another language, an *expansion service* for that transform is used to create and inject the appropriate language-specific pipeline fragments into your pipeline.\n+\n+In the following example, a Python pipeline written the Apache Beam SDK for Python starts up a local Java expansion service on your computer to create and inject the appropriate Java pipeline fragments for executing the Java Kafka cross-language transform into your Python pipeline. The SDK then downloads and stages the necessary Java dependencies needed to execute these transforms.\n+\n+![Diagram of multi-language pipeline execution flow.](/images/multi-language-pipelines-diagram.svg)\n+\n+At runtime, the Beam runner will execute both Python and Java transforms to execute your pipeline.\n+\n+In this section, we will use [KafkaIO.Read](https://beam.apache.org/releases/javadoc/current/org/apache/beam/sdk/io/kafka/KafkaIO.Read.html) to illustrate how to create a cross-language transform for Java and a test example for Python.\n+\n+#### 13.1.1. Creating cross-language Java transforms\n+\n+To make your Apache Beam Java SDK transform portable across SDK languages, you must implement two interfaces: [ExternalTransformBuilder](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/ExternalTransformBuilder.java) and [ExternalTransformRegistrar](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/expansion/ExternalTransformRegistrar.java). The `ExternalTransformBuilder` interface constructs the cross-language transform using configuration values passed in from the pipeline and the `ExternalTransformRegistrar` interface registers the cross-language transform for use with the expansion service.\n+\n+**Implementing the interfaces**\n+\n+1. Define a Builder class for your transform that implements the `ExternalTransformBuilder` interface and overrides the `buildExternal` method that will be used to build your transform object. Initial configuration values for your transform should be defined in the `buildExternal` method. In most cases, it is convenient to make the Java transform builder class implement `ExternalTransformBuilder`.\n+\n+    > **Note:** `ExternalTransformBuilder` requires you to define a configuration object (a simple POJO) to capture a set of parameters sent by external SDKs to initiate the Java transform. Usually these parameters directly map to constructor parameters of the Java transform.\n+\n+    {{< highlight >}}\n+@AutoValue.Builder\n+abstract static class Builder<K, V>\n+  implements ExternalTransformBuilder<External.Configuration, PBegin, PCollection<KV<K, V>>> {\n+  abstract Builder<K, V> setConsumerConfig(Map<String, Object> config);\n+\n+  abstract Builder<K, V> setTopics(List<String> topics);\n+\n+  /** Remaining property declarations omitted for clarity. */\n+\n+  abstract Read<K, V> build();\n+\n+  @Override\n+  public PTransform<PBegin, PCollection<KV<K, V>>> buildExternal(\n+      External.Configuration config) {\n+    ImmutableList.Builder<String> listBuilder = ImmutableList.builder();\n+    for (String topic : config.topics) {\n+      listBuilder.add(topic);\n+    }\n+    setTopics(listBuilder.build());\n+\n+    /** Remaining property defaults omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+2. Register the transform as an external cross-language transform by defining a class that implements `ExternalTransformRegistrar`. You must annotate your class with the `AutoService` annotation to ensure that your transform is registered and instantiated properly by the expansion service.\n+3. In your registrar class, define a Uniform Resource Name (URN) for your transform. The URN must be a unique string that identifies your transform with the expansion service.\n+4. From within your registrar class, define a configuration class for the parameters used during the initialization of your transform by the external SDK.\n+\n+    The following example from the KafkaIO transform shows how to implement steps two through four:\n+\n+    {{< highlight >}}\n+@AutoService(ExternalTransformRegistrar.class)\n+public static class External implements ExternalTransformRegistrar {\n+\n+  public static final String URN = \"beam:external:java:kafka:read:v1\";\n+\n+  @Override\n+  public Map<String, Class<? extends ExternalTransformBuilder<?, ?, ?>>> knownBuilders() {\n+    return ImmutableMap.of(\n+        URN,\n+        (Class<? extends ExternalTransformBuilder<?, ?, ?>>)\n+            (Class<?>) AutoValue_KafkaIO_Read.Builder.class);\n+  }\n+\n+  /** Parameters class to expose the Read transform to an external SDK. */\n+  public static class Configuration {\n+    private Map<String, String> consumerConfig;\n+      private List<String> topics;", "originalCommit": "f2fb2a1604c620a1a3d753400fe0f3444c5ec821", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI5OTM5MQ==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523299391", "bodyText": "Done.", "author": "davidwrede", "createdAt": "2020-11-14T00:29:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI4NTIzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI4NzEwNA==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523287104", "bodyText": "Why not setTopics(config.topics) or, if a copy is needed, setTopics(ImmutableList.copyOf(config.topics))\n(FWIW, the motivation to have a separate Builder and Configuration object that seem to largely play the same role is a bit unclear here--it'd be good to clarify that.)", "author": "robertwb", "createdAt": "2020-11-13T23:42:09Z", "path": "website/www/site/content/en/documentation/programming-guide.md", "diffHunk": "@@ -5431,4 +5431,280 @@ use case.\n \n {{< highlight py >}}\n {{< code_sample \"sdks/python/apache_beam/examples/snippets/snippets.py\" BundleFinalize >}}\n-{{< /highlight >}}\n\\ No newline at end of file\n+{{< /highlight >}}\n+\n+## 13. Multi-language pipelines {#mulit-language-pipelines}\n+\n+Beam allows you to combine transforms written in any supported SDK language (currently, Java and Python) and use them in one multi-language pipeline. This capability makes it easy to provide new functionality simultaneously in different Apache Beam SDKs through a single cross-language transform. For example, the [Apache Kafka connector](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/io/kafka.py) and [SQL transform](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/sql.py) from the Java SDK can be used in Python streaming pipelines.\n+\n+Pipelines that use transforms from more than one SDK-language are known as *multi-language pipelines*.\n+\n+### 13.1. Creating cross-language transforms {#create-x-lang-transforms}\n+\n+To make transforms written in one language available to pipelines written in another language, an *expansion service* for that transform is used to create and inject the appropriate language-specific pipeline fragments into your pipeline.\n+\n+In the following example, a Python pipeline written the Apache Beam SDK for Python starts up a local Java expansion service on your computer to create and inject the appropriate Java pipeline fragments for executing the Java Kafka cross-language transform into your Python pipeline. The SDK then downloads and stages the necessary Java dependencies needed to execute these transforms.\n+\n+![Diagram of multi-language pipeline execution flow.](/images/multi-language-pipelines-diagram.svg)\n+\n+At runtime, the Beam runner will execute both Python and Java transforms to execute your pipeline.\n+\n+In this section, we will use [KafkaIO.Read](https://beam.apache.org/releases/javadoc/current/org/apache/beam/sdk/io/kafka/KafkaIO.Read.html) to illustrate how to create a cross-language transform for Java and a test example for Python.\n+\n+#### 13.1.1. Creating cross-language Java transforms\n+\n+To make your Apache Beam Java SDK transform portable across SDK languages, you must implement two interfaces: [ExternalTransformBuilder](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/ExternalTransformBuilder.java) and [ExternalTransformRegistrar](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/expansion/ExternalTransformRegistrar.java). The `ExternalTransformBuilder` interface constructs the cross-language transform using configuration values passed in from the pipeline and the `ExternalTransformRegistrar` interface registers the cross-language transform for use with the expansion service.\n+\n+**Implementing the interfaces**\n+\n+1. Define a Builder class for your transform that implements the `ExternalTransformBuilder` interface and overrides the `buildExternal` method that will be used to build your transform object. Initial configuration values for your transform should be defined in the `buildExternal` method. In most cases, it is convenient to make the Java transform builder class implement `ExternalTransformBuilder`.\n+\n+    > **Note:** `ExternalTransformBuilder` requires you to define a configuration object (a simple POJO) to capture a set of parameters sent by external SDKs to initiate the Java transform. Usually these parameters directly map to constructor parameters of the Java transform.\n+\n+    {{< highlight >}}\n+@AutoValue.Builder\n+abstract static class Builder<K, V>\n+  implements ExternalTransformBuilder<External.Configuration, PBegin, PCollection<KV<K, V>>> {\n+  abstract Builder<K, V> setConsumerConfig(Map<String, Object> config);\n+\n+  abstract Builder<K, V> setTopics(List<String> topics);\n+\n+  /** Remaining property declarations omitted for clarity. */\n+\n+  abstract Read<K, V> build();\n+\n+  @Override\n+  public PTransform<PBegin, PCollection<KV<K, V>>> buildExternal(\n+      External.Configuration config) {\n+    ImmutableList.Builder<String> listBuilder = ImmutableList.builder();\n+    for (String topic : config.topics) {\n+      listBuilder.add(topic);\n+    }\n+    setTopics(listBuilder.build());", "originalCommit": "f2fb2a1604c620a1a3d753400fe0f3444c5ec821", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU4MTM2Ng==", "url": "https://github.com/apache/beam/pull/13317#discussion_r525581366", "bodyText": "Done.", "author": "chamikaramj", "createdAt": "2020-11-17T22:58:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI4NzEwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI4NzM3Nw==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523287377", "bodyText": "Don't bother defining/exporting variables for things you'll never use again. I think it'd be cleaner to simply write\n$ jar -jar /path/to/expansion_service.jar [port]", "author": "robertwb", "createdAt": "2020-11-13T23:43:26Z", "path": "website/www/site/content/en/documentation/programming-guide.md", "diffHunk": "@@ -5431,4 +5431,280 @@ use case.\n \n {{< highlight py >}}\n {{< code_sample \"sdks/python/apache_beam/examples/snippets/snippets.py\" BundleFinalize >}}\n-{{< /highlight >}}\n\\ No newline at end of file\n+{{< /highlight >}}\n+\n+## 13. Multi-language pipelines {#mulit-language-pipelines}\n+\n+Beam allows you to combine transforms written in any supported SDK language (currently, Java and Python) and use them in one multi-language pipeline. This capability makes it easy to provide new functionality simultaneously in different Apache Beam SDKs through a single cross-language transform. For example, the [Apache Kafka connector](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/io/kafka.py) and [SQL transform](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/sql.py) from the Java SDK can be used in Python streaming pipelines.\n+\n+Pipelines that use transforms from more than one SDK-language are known as *multi-language pipelines*.\n+\n+### 13.1. Creating cross-language transforms {#create-x-lang-transforms}\n+\n+To make transforms written in one language available to pipelines written in another language, an *expansion service* for that transform is used to create and inject the appropriate language-specific pipeline fragments into your pipeline.\n+\n+In the following example, a Python pipeline written the Apache Beam SDK for Python starts up a local Java expansion service on your computer to create and inject the appropriate Java pipeline fragments for executing the Java Kafka cross-language transform into your Python pipeline. The SDK then downloads and stages the necessary Java dependencies needed to execute these transforms.\n+\n+![Diagram of multi-language pipeline execution flow.](/images/multi-language-pipelines-diagram.svg)\n+\n+At runtime, the Beam runner will execute both Python and Java transforms to execute your pipeline.\n+\n+In this section, we will use [KafkaIO.Read](https://beam.apache.org/releases/javadoc/current/org/apache/beam/sdk/io/kafka/KafkaIO.Read.html) to illustrate how to create a cross-language transform for Java and a test example for Python.\n+\n+#### 13.1.1. Creating cross-language Java transforms\n+\n+To make your Apache Beam Java SDK transform portable across SDK languages, you must implement two interfaces: [ExternalTransformBuilder](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/ExternalTransformBuilder.java) and [ExternalTransformRegistrar](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/expansion/ExternalTransformRegistrar.java). The `ExternalTransformBuilder` interface constructs the cross-language transform using configuration values passed in from the pipeline and the `ExternalTransformRegistrar` interface registers the cross-language transform for use with the expansion service.\n+\n+**Implementing the interfaces**\n+\n+1. Define a Builder class for your transform that implements the `ExternalTransformBuilder` interface and overrides the `buildExternal` method that will be used to build your transform object. Initial configuration values for your transform should be defined in the `buildExternal` method. In most cases, it is convenient to make the Java transform builder class implement `ExternalTransformBuilder`.\n+\n+    > **Note:** `ExternalTransformBuilder` requires you to define a configuration object (a simple POJO) to capture a set of parameters sent by external SDKs to initiate the Java transform. Usually these parameters directly map to constructor parameters of the Java transform.\n+\n+    {{< highlight >}}\n+@AutoValue.Builder\n+abstract static class Builder<K, V>\n+  implements ExternalTransformBuilder<External.Configuration, PBegin, PCollection<KV<K, V>>> {\n+  abstract Builder<K, V> setConsumerConfig(Map<String, Object> config);\n+\n+  abstract Builder<K, V> setTopics(List<String> topics);\n+\n+  /** Remaining property declarations omitted for clarity. */\n+\n+  abstract Read<K, V> build();\n+\n+  @Override\n+  public PTransform<PBegin, PCollection<KV<K, V>>> buildExternal(\n+      External.Configuration config) {\n+    ImmutableList.Builder<String> listBuilder = ImmutableList.builder();\n+    for (String topic : config.topics) {\n+      listBuilder.add(topic);\n+    }\n+    setTopics(listBuilder.build());\n+\n+    /** Remaining property defaults omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+2. Register the transform as an external cross-language transform by defining a class that implements `ExternalTransformRegistrar`. You must annotate your class with the `AutoService` annotation to ensure that your transform is registered and instantiated properly by the expansion service.\n+3. In your registrar class, define a Uniform Resource Name (URN) for your transform. The URN must be a unique string that identifies your transform with the expansion service.\n+4. From within your registrar class, define a configuration class for the parameters used during the initialization of your transform by the external SDK.\n+\n+    The following example from the KafkaIO transform shows how to implement steps two through four:\n+\n+    {{< highlight >}}\n+@AutoService(ExternalTransformRegistrar.class)\n+public static class External implements ExternalTransformRegistrar {\n+\n+  public static final String URN = \"beam:external:java:kafka:read:v1\";\n+\n+  @Override\n+  public Map<String, Class<? extends ExternalTransformBuilder<?, ?, ?>>> knownBuilders() {\n+    return ImmutableMap.of(\n+        URN,\n+        (Class<? extends ExternalTransformBuilder<?, ?, ?>>)\n+            (Class<?>) AutoValue_KafkaIO_Read.Builder.class);\n+  }\n+\n+  /** Parameters class to expose the Read transform to an external SDK. */\n+  public static class Configuration {\n+    private Map<String, String> consumerConfig;\n+      private List<String> topics;\n+\n+\n+      public void setConsumerConfig(Map<String, String> consumerConfig) {\n+        this.consumerConfig = consumerConfig;\n+      }\n+\n+      public void setTopics(List<String> topics) {\n+        this.topics = topics;\n+      }\n+\n+    /** Remaining properties omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+\n+After you have implemented the `ExternalTransformBuilder` and `ExternalTransformRegistrar` interfaces, your transform can be registered and created successfully by the default Java expansion service.\n+\n+**Using the expansion service**\n+\n+Java has a default expansion service included and available in the Apache Beam Java SDK. You can write your own expansion service, but that is generally not needed, so it is not covered in this section.\n+\n+Perform the following steps to start up a Java expansion service directly:\n+\n+{{< highlight >}}\n+// Path to a JAR file that contains the transform to expand, cross-language specific utilities (builder, registrar, etc.), and dependencies.\n+$ export EXPANSION_SERVICE_JAR=<My_expansion_service_JAR>", "originalCommit": "f2fb2a1604c620a1a3d753400fe0f3444c5ec821", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI4NzcwNg==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523287706", "bodyText": "I would add a step above to build a jar with both your transform and the expansion service. (Technically, your expansion service just needs to be in the classpath...)", "author": "robertwb", "createdAt": "2020-11-13T23:44:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI4NzM3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI4ODAxOQ==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523288019", "bodyText": "I would add a note that this expansion service is now ready to serve up transforms on the specified port, with a link to actually using the service (which completes the picture, but is much lower down).", "author": "robertwb", "createdAt": "2020-11-13T23:46:14Z", "path": "website/www/site/content/en/documentation/programming-guide.md", "diffHunk": "@@ -5431,4 +5431,280 @@ use case.\n \n {{< highlight py >}}\n {{< code_sample \"sdks/python/apache_beam/examples/snippets/snippets.py\" BundleFinalize >}}\n-{{< /highlight >}}\n\\ No newline at end of file\n+{{< /highlight >}}\n+\n+## 13. Multi-language pipelines {#mulit-language-pipelines}\n+\n+Beam allows you to combine transforms written in any supported SDK language (currently, Java and Python) and use them in one multi-language pipeline. This capability makes it easy to provide new functionality simultaneously in different Apache Beam SDKs through a single cross-language transform. For example, the [Apache Kafka connector](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/io/kafka.py) and [SQL transform](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/sql.py) from the Java SDK can be used in Python streaming pipelines.\n+\n+Pipelines that use transforms from more than one SDK-language are known as *multi-language pipelines*.\n+\n+### 13.1. Creating cross-language transforms {#create-x-lang-transforms}\n+\n+To make transforms written in one language available to pipelines written in another language, an *expansion service* for that transform is used to create and inject the appropriate language-specific pipeline fragments into your pipeline.\n+\n+In the following example, a Python pipeline written the Apache Beam SDK for Python starts up a local Java expansion service on your computer to create and inject the appropriate Java pipeline fragments for executing the Java Kafka cross-language transform into your Python pipeline. The SDK then downloads and stages the necessary Java dependencies needed to execute these transforms.\n+\n+![Diagram of multi-language pipeline execution flow.](/images/multi-language-pipelines-diagram.svg)\n+\n+At runtime, the Beam runner will execute both Python and Java transforms to execute your pipeline.\n+\n+In this section, we will use [KafkaIO.Read](https://beam.apache.org/releases/javadoc/current/org/apache/beam/sdk/io/kafka/KafkaIO.Read.html) to illustrate how to create a cross-language transform for Java and a test example for Python.\n+\n+#### 13.1.1. Creating cross-language Java transforms\n+\n+To make your Apache Beam Java SDK transform portable across SDK languages, you must implement two interfaces: [ExternalTransformBuilder](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/ExternalTransformBuilder.java) and [ExternalTransformRegistrar](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/expansion/ExternalTransformRegistrar.java). The `ExternalTransformBuilder` interface constructs the cross-language transform using configuration values passed in from the pipeline and the `ExternalTransformRegistrar` interface registers the cross-language transform for use with the expansion service.\n+\n+**Implementing the interfaces**\n+\n+1. Define a Builder class for your transform that implements the `ExternalTransformBuilder` interface and overrides the `buildExternal` method that will be used to build your transform object. Initial configuration values for your transform should be defined in the `buildExternal` method. In most cases, it is convenient to make the Java transform builder class implement `ExternalTransformBuilder`.\n+\n+    > **Note:** `ExternalTransformBuilder` requires you to define a configuration object (a simple POJO) to capture a set of parameters sent by external SDKs to initiate the Java transform. Usually these parameters directly map to constructor parameters of the Java transform.\n+\n+    {{< highlight >}}\n+@AutoValue.Builder\n+abstract static class Builder<K, V>\n+  implements ExternalTransformBuilder<External.Configuration, PBegin, PCollection<KV<K, V>>> {\n+  abstract Builder<K, V> setConsumerConfig(Map<String, Object> config);\n+\n+  abstract Builder<K, V> setTopics(List<String> topics);\n+\n+  /** Remaining property declarations omitted for clarity. */\n+\n+  abstract Read<K, V> build();\n+\n+  @Override\n+  public PTransform<PBegin, PCollection<KV<K, V>>> buildExternal(\n+      External.Configuration config) {\n+    ImmutableList.Builder<String> listBuilder = ImmutableList.builder();\n+    for (String topic : config.topics) {\n+      listBuilder.add(topic);\n+    }\n+    setTopics(listBuilder.build());\n+\n+    /** Remaining property defaults omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+2. Register the transform as an external cross-language transform by defining a class that implements `ExternalTransformRegistrar`. You must annotate your class with the `AutoService` annotation to ensure that your transform is registered and instantiated properly by the expansion service.\n+3. In your registrar class, define a Uniform Resource Name (URN) for your transform. The URN must be a unique string that identifies your transform with the expansion service.\n+4. From within your registrar class, define a configuration class for the parameters used during the initialization of your transform by the external SDK.\n+\n+    The following example from the KafkaIO transform shows how to implement steps two through four:\n+\n+    {{< highlight >}}\n+@AutoService(ExternalTransformRegistrar.class)\n+public static class External implements ExternalTransformRegistrar {\n+\n+  public static final String URN = \"beam:external:java:kafka:read:v1\";\n+\n+  @Override\n+  public Map<String, Class<? extends ExternalTransformBuilder<?, ?, ?>>> knownBuilders() {\n+    return ImmutableMap.of(\n+        URN,\n+        (Class<? extends ExternalTransformBuilder<?, ?, ?>>)\n+            (Class<?>) AutoValue_KafkaIO_Read.Builder.class);\n+  }\n+\n+  /** Parameters class to expose the Read transform to an external SDK. */\n+  public static class Configuration {\n+    private Map<String, String> consumerConfig;\n+      private List<String> topics;\n+\n+\n+      public void setConsumerConfig(Map<String, String> consumerConfig) {\n+        this.consumerConfig = consumerConfig;\n+      }\n+\n+      public void setTopics(List<String> topics) {\n+        this.topics = topics;\n+      }\n+\n+    /** Remaining properties omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+\n+After you have implemented the `ExternalTransformBuilder` and `ExternalTransformRegistrar` interfaces, your transform can be registered and created successfully by the default Java expansion service.\n+\n+**Using the expansion service**\n+\n+Java has a default expansion service included and available in the Apache Beam Java SDK. You can write your own expansion service, but that is generally not needed, so it is not covered in this section.\n+\n+Perform the following steps to start up a Java expansion service directly:\n+\n+{{< highlight >}}\n+// Path to a JAR file that contains the transform to expand, cross-language specific utilities (builder, registrar, etc.), and dependencies.\n+$ export EXPANSION_SERVICE_JAR=<My_expansion_service_JAR>\n+\n+$ export PORT_FOR_EXPANSION_SERVICE=12345\n+\n+$ jar -jar $EXPANSION_SERVICE_JAR $PORT_FOR_EXPANSION_SERVICE\n+{{< /highlight >}}\n+", "originalCommit": "f2fb2a1604c620a1a3d753400fe0f3444c5ec821", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU2Mjk4NA==", "url": "https://github.com/apache/beam/pull/13317#discussion_r525562984", "bodyText": "Done.", "author": "chamikaramj", "createdAt": "2020-11-17T22:19:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI4ODAxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI4ODUyMQ==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523288521", "bodyText": "Using makes it sound like you're the caller, not the callee. I would label this \"starting the expansion service\" or similar.", "author": "robertwb", "createdAt": "2020-11-13T23:48:30Z", "path": "website/www/site/content/en/documentation/programming-guide.md", "diffHunk": "@@ -5431,4 +5431,280 @@ use case.\n \n {{< highlight py >}}\n {{< code_sample \"sdks/python/apache_beam/examples/snippets/snippets.py\" BundleFinalize >}}\n-{{< /highlight >}}\n\\ No newline at end of file\n+{{< /highlight >}}\n+\n+## 13. Multi-language pipelines {#mulit-language-pipelines}\n+\n+Beam allows you to combine transforms written in any supported SDK language (currently, Java and Python) and use them in one multi-language pipeline. This capability makes it easy to provide new functionality simultaneously in different Apache Beam SDKs through a single cross-language transform. For example, the [Apache Kafka connector](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/io/kafka.py) and [SQL transform](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/sql.py) from the Java SDK can be used in Python streaming pipelines.\n+\n+Pipelines that use transforms from more than one SDK-language are known as *multi-language pipelines*.\n+\n+### 13.1. Creating cross-language transforms {#create-x-lang-transforms}\n+\n+To make transforms written in one language available to pipelines written in another language, an *expansion service* for that transform is used to create and inject the appropriate language-specific pipeline fragments into your pipeline.\n+\n+In the following example, a Python pipeline written the Apache Beam SDK for Python starts up a local Java expansion service on your computer to create and inject the appropriate Java pipeline fragments for executing the Java Kafka cross-language transform into your Python pipeline. The SDK then downloads and stages the necessary Java dependencies needed to execute these transforms.\n+\n+![Diagram of multi-language pipeline execution flow.](/images/multi-language-pipelines-diagram.svg)\n+\n+At runtime, the Beam runner will execute both Python and Java transforms to execute your pipeline.\n+\n+In this section, we will use [KafkaIO.Read](https://beam.apache.org/releases/javadoc/current/org/apache/beam/sdk/io/kafka/KafkaIO.Read.html) to illustrate how to create a cross-language transform for Java and a test example for Python.\n+\n+#### 13.1.1. Creating cross-language Java transforms\n+\n+To make your Apache Beam Java SDK transform portable across SDK languages, you must implement two interfaces: [ExternalTransformBuilder](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/ExternalTransformBuilder.java) and [ExternalTransformRegistrar](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/expansion/ExternalTransformRegistrar.java). The `ExternalTransformBuilder` interface constructs the cross-language transform using configuration values passed in from the pipeline and the `ExternalTransformRegistrar` interface registers the cross-language transform for use with the expansion service.\n+\n+**Implementing the interfaces**\n+\n+1. Define a Builder class for your transform that implements the `ExternalTransformBuilder` interface and overrides the `buildExternal` method that will be used to build your transform object. Initial configuration values for your transform should be defined in the `buildExternal` method. In most cases, it is convenient to make the Java transform builder class implement `ExternalTransformBuilder`.\n+\n+    > **Note:** `ExternalTransformBuilder` requires you to define a configuration object (a simple POJO) to capture a set of parameters sent by external SDKs to initiate the Java transform. Usually these parameters directly map to constructor parameters of the Java transform.\n+\n+    {{< highlight >}}\n+@AutoValue.Builder\n+abstract static class Builder<K, V>\n+  implements ExternalTransformBuilder<External.Configuration, PBegin, PCollection<KV<K, V>>> {\n+  abstract Builder<K, V> setConsumerConfig(Map<String, Object> config);\n+\n+  abstract Builder<K, V> setTopics(List<String> topics);\n+\n+  /** Remaining property declarations omitted for clarity. */\n+\n+  abstract Read<K, V> build();\n+\n+  @Override\n+  public PTransform<PBegin, PCollection<KV<K, V>>> buildExternal(\n+      External.Configuration config) {\n+    ImmutableList.Builder<String> listBuilder = ImmutableList.builder();\n+    for (String topic : config.topics) {\n+      listBuilder.add(topic);\n+    }\n+    setTopics(listBuilder.build());\n+\n+    /** Remaining property defaults omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+2. Register the transform as an external cross-language transform by defining a class that implements `ExternalTransformRegistrar`. You must annotate your class with the `AutoService` annotation to ensure that your transform is registered and instantiated properly by the expansion service.\n+3. In your registrar class, define a Uniform Resource Name (URN) for your transform. The URN must be a unique string that identifies your transform with the expansion service.\n+4. From within your registrar class, define a configuration class for the parameters used during the initialization of your transform by the external SDK.\n+\n+    The following example from the KafkaIO transform shows how to implement steps two through four:\n+\n+    {{< highlight >}}\n+@AutoService(ExternalTransformRegistrar.class)\n+public static class External implements ExternalTransformRegistrar {\n+\n+  public static final String URN = \"beam:external:java:kafka:read:v1\";\n+\n+  @Override\n+  public Map<String, Class<? extends ExternalTransformBuilder<?, ?, ?>>> knownBuilders() {\n+    return ImmutableMap.of(\n+        URN,\n+        (Class<? extends ExternalTransformBuilder<?, ?, ?>>)\n+            (Class<?>) AutoValue_KafkaIO_Read.Builder.class);\n+  }\n+\n+  /** Parameters class to expose the Read transform to an external SDK. */\n+  public static class Configuration {\n+    private Map<String, String> consumerConfig;\n+      private List<String> topics;\n+\n+\n+      public void setConsumerConfig(Map<String, String> consumerConfig) {\n+        this.consumerConfig = consumerConfig;\n+      }\n+\n+      public void setTopics(List<String> topics) {\n+        this.topics = topics;\n+      }\n+\n+    /** Remaining properties omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+\n+After you have implemented the `ExternalTransformBuilder` and `ExternalTransformRegistrar` interfaces, your transform can be registered and created successfully by the default Java expansion service.\n+\n+**Using the expansion service**\n+\n+Java has a default expansion service included and available in the Apache Beam Java SDK. You can write your own expansion service, but that is generally not needed, so it is not covered in this section.\n+\n+Perform the following steps to start up a Java expansion service directly:\n+\n+{{< highlight >}}\n+// Path to a JAR file that contains the transform to expand, cross-language specific utilities (builder, registrar, etc.), and dependencies.\n+$ export EXPANSION_SERVICE_JAR=<My_expansion_service_JAR>\n+\n+$ export PORT_FOR_EXPANSION_SERVICE=12345\n+\n+$ jar -jar $EXPANSION_SERVICE_JAR $PORT_FOR_EXPANSION_SERVICE\n+{{< /highlight >}}\n+\n+When creating SDK-specific wrappers for your transform, SDKs may provide utilities that are readily available for easily starting up an expansion service. For example, the Python SDK provides the [BeamJarExpansionService](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py) utility for starting up a Java expansion service using a JAR file.\n+\n+**Including dependencies**\n+\n+If your transform requires external libraries, you can include them by adding them to the classpath of the expansion service. After they are included in the classpath, they will be staged when your transform is expanded by the expansion service.\n+\n+**Writing SDK-specific wrappers**\n+\n+Your cross-language Java transform can be called through the lower-level [ExternalTransform](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py) class in a multi-language pipeline (as described in the next section); however, if possible, you should create a SDK-specific wrapper written in the programming language of the pipeline (such as Python) to access the transform instead. This higher-level abstraction will make it easier for pipeline authors to use your transform.\n+\n+To create an SDK wrapper for use in a Python pipeline, do the following:\n+\n+1. Create a Python module for your cross-language transform.\n+2. In the module, build the payload that should be used to initiate the cross-language transform expansion request using one of the available [PayloadBuilder](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py) classes.\n+\n+    The parameter names and types of the payload should map to parameter names and types of the configuration POJO provided to the Java `ExternalTransformBuilder`. Parameter types are mapped across SDKs using a [Beam schema](https://github.com/apache/beam/blob/master/model/pipeline/src/main/proto/schema.proto). Parameter names are mapped by simply converting Python underscore-separated variable names to camel-case (Java standard).\n+\n+    In the following example, [kafka.py](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/io/kafka.py) uses `NamedTupleBasedPayloadBuilder` to build the payload. The parameters map to the Java [KafkaIO.External.Configuration](https://github.com/apache/beam/blob/master/sdks/java/io/kafka/src/main/java/org/apache/beam/sdk/io/kafka/KafkaIO.java) config object defined previously in the **Implementing the interfaces** section.\n+\n+    {{< highlight >}}\n+class ReadFromKafkaSchema(typing.NamedTuple):\n+      consumer_config: typing.Mapping[str, str]\n+      topics: typing.List[str]\n+      # Other properties omitted for clarity.\n+\n+payload = NamedTupleBasedPayloadBuilder(ReadFromKafkaSchema(...))\n+    {{< /highlight >}}\n+3. Start an expansion service unless one is specified by the pipeline creator. The Apache Beam Python SDK provides a utility, `BeamJarExpansionService`, for easily starting an expansion service based on a JAR released with Beam. To use this, do the following:\n+\n+    1. Add a Gradle target to Beam that can be used to build a shaded expansion service JAR for the target Java transform. This target should produce a Beam JAR that contains all dependencies needed for expanding the Java transform and the JAR should be released with Beam.\n+    2. In your Python module, instantiate `BeamJarExpansionService` with the Gradle target.\n+\n+        {{< highlight >}}\n+    expansion_service = BeamJarExpansionService('sdks:java:io:expansion-service:shadowJar')\n+        {{< /highlight >}}\n+4. Add a Python wrapper transform class that extends [ExternalTransform](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py). Pass the payload and expansion service defined above as parameters to the constructor of the `ExternalTransform` parent class.\n+\n+#### 13.1.2. Creating cross-language Python transforms\n+\n+To make your Python transform usable with different SDK languages, you must create a Python module that registers an existing Python transform as a cross-language transform for use with the Python expansion service and calls into that existing transform to perform its intended operation.\n+\n+**Defining the Python module**\n+\n+1. Define a Uniform Resource Name (URN) for your transform. The URN must be a unique string that identifies your transform with the expansion service.\n+\n+    {{< highlight >}}\n+TEST_COMPK_URN = \"beam:transforms:xlang:test:compk\"\n+    {{< /highlight >}}\n+2. For an existing Python transform, create a new class to register the URN with the Python expansion service.\n+\n+    {{< highlight >}}\n+@ptransform.PTransform.register_urn(TEST_COMPK_URN, None)\n+class CombinePerKeyTransform(ptransform.PTransform):\n+    {{< /highlight >}}\n+3. From within the class, define an expand method that takes an input PCollection, runs the Python transform, and then returns the output PCollection.\n+\n+    {{< highlight >}}\n+def expand(self, pcoll):\n+    return pcoll \\\n+        | beam.CombinePerKey(sum).with_output_types(\n+              typing.Tuple[unicode, int])\n+    {{< /highlight >}}\n+4. As with other Python transforms, define a `to_runner_api_parameter` method that returns the URN.\n+\n+    {{< highlight >}}\n+def to_runner_api_parameter(self, unused_context):\n+    return TEST_COMPK_URN, None\n+    {{< /highlight >}}\n+5. Define a static `from_runner_api_parameter` method that returns an instantiation of the cross-language Python transform.\n+\n+    {{< highlight >}}\n+@staticmethod\n+def from_runner_api_parameter(\n+      unused_ptransform, unused_parameter, unused_context):\n+    return CombinePerKeyTransform()\n+    {{< /highlight >}}\n+\n+**Using the expansion service**", "originalCommit": "f2fb2a1604c620a1a3d753400fe0f3444c5ec821", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzMwMjAxNw==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523302017", "bodyText": "Done.", "author": "davidwrede", "createdAt": "2020-11-14T00:42:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI4ODUyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI4ODg3MA==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523288870", "bodyText": "I think this would fit better after the \"Using cross-language transforms\" section.", "author": "robertwb", "createdAt": "2020-11-13T23:49:54Z", "path": "website/www/site/content/en/documentation/programming-guide.md", "diffHunk": "@@ -5431,4 +5431,280 @@ use case.\n \n {{< highlight py >}}\n {{< code_sample \"sdks/python/apache_beam/examples/snippets/snippets.py\" BundleFinalize >}}\n-{{< /highlight >}}\n\\ No newline at end of file\n+{{< /highlight >}}\n+\n+## 13. Multi-language pipelines {#mulit-language-pipelines}\n+\n+Beam allows you to combine transforms written in any supported SDK language (currently, Java and Python) and use them in one multi-language pipeline. This capability makes it easy to provide new functionality simultaneously in different Apache Beam SDKs through a single cross-language transform. For example, the [Apache Kafka connector](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/io/kafka.py) and [SQL transform](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/sql.py) from the Java SDK can be used in Python streaming pipelines.\n+\n+Pipelines that use transforms from more than one SDK-language are known as *multi-language pipelines*.\n+\n+### 13.1. Creating cross-language transforms {#create-x-lang-transforms}\n+\n+To make transforms written in one language available to pipelines written in another language, an *expansion service* for that transform is used to create and inject the appropriate language-specific pipeline fragments into your pipeline.\n+\n+In the following example, a Python pipeline written the Apache Beam SDK for Python starts up a local Java expansion service on your computer to create and inject the appropriate Java pipeline fragments for executing the Java Kafka cross-language transform into your Python pipeline. The SDK then downloads and stages the necessary Java dependencies needed to execute these transforms.\n+\n+![Diagram of multi-language pipeline execution flow.](/images/multi-language-pipelines-diagram.svg)\n+\n+At runtime, the Beam runner will execute both Python and Java transforms to execute your pipeline.\n+\n+In this section, we will use [KafkaIO.Read](https://beam.apache.org/releases/javadoc/current/org/apache/beam/sdk/io/kafka/KafkaIO.Read.html) to illustrate how to create a cross-language transform for Java and a test example for Python.\n+\n+#### 13.1.1. Creating cross-language Java transforms\n+\n+To make your Apache Beam Java SDK transform portable across SDK languages, you must implement two interfaces: [ExternalTransformBuilder](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/ExternalTransformBuilder.java) and [ExternalTransformRegistrar](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/expansion/ExternalTransformRegistrar.java). The `ExternalTransformBuilder` interface constructs the cross-language transform using configuration values passed in from the pipeline and the `ExternalTransformRegistrar` interface registers the cross-language transform for use with the expansion service.\n+\n+**Implementing the interfaces**\n+\n+1. Define a Builder class for your transform that implements the `ExternalTransformBuilder` interface and overrides the `buildExternal` method that will be used to build your transform object. Initial configuration values for your transform should be defined in the `buildExternal` method. In most cases, it is convenient to make the Java transform builder class implement `ExternalTransformBuilder`.\n+\n+    > **Note:** `ExternalTransformBuilder` requires you to define a configuration object (a simple POJO) to capture a set of parameters sent by external SDKs to initiate the Java transform. Usually these parameters directly map to constructor parameters of the Java transform.\n+\n+    {{< highlight >}}\n+@AutoValue.Builder\n+abstract static class Builder<K, V>\n+  implements ExternalTransformBuilder<External.Configuration, PBegin, PCollection<KV<K, V>>> {\n+  abstract Builder<K, V> setConsumerConfig(Map<String, Object> config);\n+\n+  abstract Builder<K, V> setTopics(List<String> topics);\n+\n+  /** Remaining property declarations omitted for clarity. */\n+\n+  abstract Read<K, V> build();\n+\n+  @Override\n+  public PTransform<PBegin, PCollection<KV<K, V>>> buildExternal(\n+      External.Configuration config) {\n+    ImmutableList.Builder<String> listBuilder = ImmutableList.builder();\n+    for (String topic : config.topics) {\n+      listBuilder.add(topic);\n+    }\n+    setTopics(listBuilder.build());\n+\n+    /** Remaining property defaults omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+2. Register the transform as an external cross-language transform by defining a class that implements `ExternalTransformRegistrar`. You must annotate your class with the `AutoService` annotation to ensure that your transform is registered and instantiated properly by the expansion service.\n+3. In your registrar class, define a Uniform Resource Name (URN) for your transform. The URN must be a unique string that identifies your transform with the expansion service.\n+4. From within your registrar class, define a configuration class for the parameters used during the initialization of your transform by the external SDK.\n+\n+    The following example from the KafkaIO transform shows how to implement steps two through four:\n+\n+    {{< highlight >}}\n+@AutoService(ExternalTransformRegistrar.class)\n+public static class External implements ExternalTransformRegistrar {\n+\n+  public static final String URN = \"beam:external:java:kafka:read:v1\";\n+\n+  @Override\n+  public Map<String, Class<? extends ExternalTransformBuilder<?, ?, ?>>> knownBuilders() {\n+    return ImmutableMap.of(\n+        URN,\n+        (Class<? extends ExternalTransformBuilder<?, ?, ?>>)\n+            (Class<?>) AutoValue_KafkaIO_Read.Builder.class);\n+  }\n+\n+  /** Parameters class to expose the Read transform to an external SDK. */\n+  public static class Configuration {\n+    private Map<String, String> consumerConfig;\n+      private List<String> topics;\n+\n+\n+      public void setConsumerConfig(Map<String, String> consumerConfig) {\n+        this.consumerConfig = consumerConfig;\n+      }\n+\n+      public void setTopics(List<String> topics) {\n+        this.topics = topics;\n+      }\n+\n+    /** Remaining properties omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+\n+After you have implemented the `ExternalTransformBuilder` and `ExternalTransformRegistrar` interfaces, your transform can be registered and created successfully by the default Java expansion service.\n+\n+**Using the expansion service**\n+\n+Java has a default expansion service included and available in the Apache Beam Java SDK. You can write your own expansion service, but that is generally not needed, so it is not covered in this section.\n+\n+Perform the following steps to start up a Java expansion service directly:\n+\n+{{< highlight >}}\n+// Path to a JAR file that contains the transform to expand, cross-language specific utilities (builder, registrar, etc.), and dependencies.\n+$ export EXPANSION_SERVICE_JAR=<My_expansion_service_JAR>\n+\n+$ export PORT_FOR_EXPANSION_SERVICE=12345\n+\n+$ jar -jar $EXPANSION_SERVICE_JAR $PORT_FOR_EXPANSION_SERVICE\n+{{< /highlight >}}\n+\n+When creating SDK-specific wrappers for your transform, SDKs may provide utilities that are readily available for easily starting up an expansion service. For example, the Python SDK provides the [BeamJarExpansionService](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py) utility for starting up a Java expansion service using a JAR file.\n+\n+**Including dependencies**\n+\n+If your transform requires external libraries, you can include them by adding them to the classpath of the expansion service. After they are included in the classpath, they will be staged when your transform is expanded by the expansion service.\n+\n+**Writing SDK-specific wrappers**", "originalCommit": "f2fb2a1604c620a1a3d753400fe0f3444c5ec821", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3NDc1NA==", "url": "https://github.com/apache/beam/pull/13317#discussion_r525574754", "bodyText": "We have it there as well. See \"Using an SDK wrapper\". Primary audience of this sub-section are transforms authors. So information here is more on writing wrappers.  There's some overlap but I think this is fine.", "author": "chamikaramj", "createdAt": "2020-11-17T22:44:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI4ODg3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI4OTE1OQ==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523289159", "bodyText": "transform(s).\nRelated transforms should probably be in the same module.", "author": "robertwb", "createdAt": "2020-11-13T23:51:16Z", "path": "website/www/site/content/en/documentation/programming-guide.md", "diffHunk": "@@ -5431,4 +5431,280 @@ use case.\n \n {{< highlight py >}}\n {{< code_sample \"sdks/python/apache_beam/examples/snippets/snippets.py\" BundleFinalize >}}\n-{{< /highlight >}}\n\\ No newline at end of file\n+{{< /highlight >}}\n+\n+## 13. Multi-language pipelines {#mulit-language-pipelines}\n+\n+Beam allows you to combine transforms written in any supported SDK language (currently, Java and Python) and use them in one multi-language pipeline. This capability makes it easy to provide new functionality simultaneously in different Apache Beam SDKs through a single cross-language transform. For example, the [Apache Kafka connector](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/io/kafka.py) and [SQL transform](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/sql.py) from the Java SDK can be used in Python streaming pipelines.\n+\n+Pipelines that use transforms from more than one SDK-language are known as *multi-language pipelines*.\n+\n+### 13.1. Creating cross-language transforms {#create-x-lang-transforms}\n+\n+To make transforms written in one language available to pipelines written in another language, an *expansion service* for that transform is used to create and inject the appropriate language-specific pipeline fragments into your pipeline.\n+\n+In the following example, a Python pipeline written the Apache Beam SDK for Python starts up a local Java expansion service on your computer to create and inject the appropriate Java pipeline fragments for executing the Java Kafka cross-language transform into your Python pipeline. The SDK then downloads and stages the necessary Java dependencies needed to execute these transforms.\n+\n+![Diagram of multi-language pipeline execution flow.](/images/multi-language-pipelines-diagram.svg)\n+\n+At runtime, the Beam runner will execute both Python and Java transforms to execute your pipeline.\n+\n+In this section, we will use [KafkaIO.Read](https://beam.apache.org/releases/javadoc/current/org/apache/beam/sdk/io/kafka/KafkaIO.Read.html) to illustrate how to create a cross-language transform for Java and a test example for Python.\n+\n+#### 13.1.1. Creating cross-language Java transforms\n+\n+To make your Apache Beam Java SDK transform portable across SDK languages, you must implement two interfaces: [ExternalTransformBuilder](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/ExternalTransformBuilder.java) and [ExternalTransformRegistrar](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/expansion/ExternalTransformRegistrar.java). The `ExternalTransformBuilder` interface constructs the cross-language transform using configuration values passed in from the pipeline and the `ExternalTransformRegistrar` interface registers the cross-language transform for use with the expansion service.\n+\n+**Implementing the interfaces**\n+\n+1. Define a Builder class for your transform that implements the `ExternalTransformBuilder` interface and overrides the `buildExternal` method that will be used to build your transform object. Initial configuration values for your transform should be defined in the `buildExternal` method. In most cases, it is convenient to make the Java transform builder class implement `ExternalTransformBuilder`.\n+\n+    > **Note:** `ExternalTransformBuilder` requires you to define a configuration object (a simple POJO) to capture a set of parameters sent by external SDKs to initiate the Java transform. Usually these parameters directly map to constructor parameters of the Java transform.\n+\n+    {{< highlight >}}\n+@AutoValue.Builder\n+abstract static class Builder<K, V>\n+  implements ExternalTransformBuilder<External.Configuration, PBegin, PCollection<KV<K, V>>> {\n+  abstract Builder<K, V> setConsumerConfig(Map<String, Object> config);\n+\n+  abstract Builder<K, V> setTopics(List<String> topics);\n+\n+  /** Remaining property declarations omitted for clarity. */\n+\n+  abstract Read<K, V> build();\n+\n+  @Override\n+  public PTransform<PBegin, PCollection<KV<K, V>>> buildExternal(\n+      External.Configuration config) {\n+    ImmutableList.Builder<String> listBuilder = ImmutableList.builder();\n+    for (String topic : config.topics) {\n+      listBuilder.add(topic);\n+    }\n+    setTopics(listBuilder.build());\n+\n+    /** Remaining property defaults omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+2. Register the transform as an external cross-language transform by defining a class that implements `ExternalTransformRegistrar`. You must annotate your class with the `AutoService` annotation to ensure that your transform is registered and instantiated properly by the expansion service.\n+3. In your registrar class, define a Uniform Resource Name (URN) for your transform. The URN must be a unique string that identifies your transform with the expansion service.\n+4. From within your registrar class, define a configuration class for the parameters used during the initialization of your transform by the external SDK.\n+\n+    The following example from the KafkaIO transform shows how to implement steps two through four:\n+\n+    {{< highlight >}}\n+@AutoService(ExternalTransformRegistrar.class)\n+public static class External implements ExternalTransformRegistrar {\n+\n+  public static final String URN = \"beam:external:java:kafka:read:v1\";\n+\n+  @Override\n+  public Map<String, Class<? extends ExternalTransformBuilder<?, ?, ?>>> knownBuilders() {\n+    return ImmutableMap.of(\n+        URN,\n+        (Class<? extends ExternalTransformBuilder<?, ?, ?>>)\n+            (Class<?>) AutoValue_KafkaIO_Read.Builder.class);\n+  }\n+\n+  /** Parameters class to expose the Read transform to an external SDK. */\n+  public static class Configuration {\n+    private Map<String, String> consumerConfig;\n+      private List<String> topics;\n+\n+\n+      public void setConsumerConfig(Map<String, String> consumerConfig) {\n+        this.consumerConfig = consumerConfig;\n+      }\n+\n+      public void setTopics(List<String> topics) {\n+        this.topics = topics;\n+      }\n+\n+    /** Remaining properties omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+\n+After you have implemented the `ExternalTransformBuilder` and `ExternalTransformRegistrar` interfaces, your transform can be registered and created successfully by the default Java expansion service.\n+\n+**Using the expansion service**\n+\n+Java has a default expansion service included and available in the Apache Beam Java SDK. You can write your own expansion service, but that is generally not needed, so it is not covered in this section.\n+\n+Perform the following steps to start up a Java expansion service directly:\n+\n+{{< highlight >}}\n+// Path to a JAR file that contains the transform to expand, cross-language specific utilities (builder, registrar, etc.), and dependencies.\n+$ export EXPANSION_SERVICE_JAR=<My_expansion_service_JAR>\n+\n+$ export PORT_FOR_EXPANSION_SERVICE=12345\n+\n+$ jar -jar $EXPANSION_SERVICE_JAR $PORT_FOR_EXPANSION_SERVICE\n+{{< /highlight >}}\n+\n+When creating SDK-specific wrappers for your transform, SDKs may provide utilities that are readily available for easily starting up an expansion service. For example, the Python SDK provides the [BeamJarExpansionService](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py) utility for starting up a Java expansion service using a JAR file.\n+\n+**Including dependencies**\n+\n+If your transform requires external libraries, you can include them by adding them to the classpath of the expansion service. After they are included in the classpath, they will be staged when your transform is expanded by the expansion service.\n+\n+**Writing SDK-specific wrappers**\n+\n+Your cross-language Java transform can be called through the lower-level [ExternalTransform](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py) class in a multi-language pipeline (as described in the next section); however, if possible, you should create a SDK-specific wrapper written in the programming language of the pipeline (such as Python) to access the transform instead. This higher-level abstraction will make it easier for pipeline authors to use your transform.\n+\n+To create an SDK wrapper for use in a Python pipeline, do the following:\n+\n+1. Create a Python module for your cross-language transform.", "originalCommit": "f2fb2a1604c620a1a3d753400fe0f3444c5ec821", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzMwMTkxNg==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523301916", "bodyText": "Done.", "author": "davidwrede", "createdAt": "2020-11-14T00:41:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI4OTE1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI5MjQ0NQ==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523292445", "bodyText": "Here there is a different path depending on whether the external transform is in Beam or not. If it is not, the path to the jar must be specified. This path could be a local path, but it's also allowed to give an arbitrary URL (if you want to publish it as a fat jar for others to use) or pointer to a maven release artifact (see beam.util. JavaJarServer.subprocess_server. path_to_maven_jar).\nFor expansion services shipped with Beam, we provide even more convenience methods, as described below.", "author": "robertwb", "createdAt": "2020-11-13T23:56:16Z", "path": "website/www/site/content/en/documentation/programming-guide.md", "diffHunk": "@@ -5431,4 +5431,280 @@ use case.\n \n {{< highlight py >}}\n {{< code_sample \"sdks/python/apache_beam/examples/snippets/snippets.py\" BundleFinalize >}}\n-{{< /highlight >}}\n\\ No newline at end of file\n+{{< /highlight >}}\n+\n+## 13. Multi-language pipelines {#mulit-language-pipelines}\n+\n+Beam allows you to combine transforms written in any supported SDK language (currently, Java and Python) and use them in one multi-language pipeline. This capability makes it easy to provide new functionality simultaneously in different Apache Beam SDKs through a single cross-language transform. For example, the [Apache Kafka connector](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/io/kafka.py) and [SQL transform](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/sql.py) from the Java SDK can be used in Python streaming pipelines.\n+\n+Pipelines that use transforms from more than one SDK-language are known as *multi-language pipelines*.\n+\n+### 13.1. Creating cross-language transforms {#create-x-lang-transforms}\n+\n+To make transforms written in one language available to pipelines written in another language, an *expansion service* for that transform is used to create and inject the appropriate language-specific pipeline fragments into your pipeline.\n+\n+In the following example, a Python pipeline written the Apache Beam SDK for Python starts up a local Java expansion service on your computer to create and inject the appropriate Java pipeline fragments for executing the Java Kafka cross-language transform into your Python pipeline. The SDK then downloads and stages the necessary Java dependencies needed to execute these transforms.\n+\n+![Diagram of multi-language pipeline execution flow.](/images/multi-language-pipelines-diagram.svg)\n+\n+At runtime, the Beam runner will execute both Python and Java transforms to execute your pipeline.\n+\n+In this section, we will use [KafkaIO.Read](https://beam.apache.org/releases/javadoc/current/org/apache/beam/sdk/io/kafka/KafkaIO.Read.html) to illustrate how to create a cross-language transform for Java and a test example for Python.\n+\n+#### 13.1.1. Creating cross-language Java transforms\n+\n+To make your Apache Beam Java SDK transform portable across SDK languages, you must implement two interfaces: [ExternalTransformBuilder](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/ExternalTransformBuilder.java) and [ExternalTransformRegistrar](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/expansion/ExternalTransformRegistrar.java). The `ExternalTransformBuilder` interface constructs the cross-language transform using configuration values passed in from the pipeline and the `ExternalTransformRegistrar` interface registers the cross-language transform for use with the expansion service.\n+\n+**Implementing the interfaces**\n+\n+1. Define a Builder class for your transform that implements the `ExternalTransformBuilder` interface and overrides the `buildExternal` method that will be used to build your transform object. Initial configuration values for your transform should be defined in the `buildExternal` method. In most cases, it is convenient to make the Java transform builder class implement `ExternalTransformBuilder`.\n+\n+    > **Note:** `ExternalTransformBuilder` requires you to define a configuration object (a simple POJO) to capture a set of parameters sent by external SDKs to initiate the Java transform. Usually these parameters directly map to constructor parameters of the Java transform.\n+\n+    {{< highlight >}}\n+@AutoValue.Builder\n+abstract static class Builder<K, V>\n+  implements ExternalTransformBuilder<External.Configuration, PBegin, PCollection<KV<K, V>>> {\n+  abstract Builder<K, V> setConsumerConfig(Map<String, Object> config);\n+\n+  abstract Builder<K, V> setTopics(List<String> topics);\n+\n+  /** Remaining property declarations omitted for clarity. */\n+\n+  abstract Read<K, V> build();\n+\n+  @Override\n+  public PTransform<PBegin, PCollection<KV<K, V>>> buildExternal(\n+      External.Configuration config) {\n+    ImmutableList.Builder<String> listBuilder = ImmutableList.builder();\n+    for (String topic : config.topics) {\n+      listBuilder.add(topic);\n+    }\n+    setTopics(listBuilder.build());\n+\n+    /** Remaining property defaults omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+2. Register the transform as an external cross-language transform by defining a class that implements `ExternalTransformRegistrar`. You must annotate your class with the `AutoService` annotation to ensure that your transform is registered and instantiated properly by the expansion service.\n+3. In your registrar class, define a Uniform Resource Name (URN) for your transform. The URN must be a unique string that identifies your transform with the expansion service.\n+4. From within your registrar class, define a configuration class for the parameters used during the initialization of your transform by the external SDK.\n+\n+    The following example from the KafkaIO transform shows how to implement steps two through four:\n+\n+    {{< highlight >}}\n+@AutoService(ExternalTransformRegistrar.class)\n+public static class External implements ExternalTransformRegistrar {\n+\n+  public static final String URN = \"beam:external:java:kafka:read:v1\";\n+\n+  @Override\n+  public Map<String, Class<? extends ExternalTransformBuilder<?, ?, ?>>> knownBuilders() {\n+    return ImmutableMap.of(\n+        URN,\n+        (Class<? extends ExternalTransformBuilder<?, ?, ?>>)\n+            (Class<?>) AutoValue_KafkaIO_Read.Builder.class);\n+  }\n+\n+  /** Parameters class to expose the Read transform to an external SDK. */\n+  public static class Configuration {\n+    private Map<String, String> consumerConfig;\n+      private List<String> topics;\n+\n+\n+      public void setConsumerConfig(Map<String, String> consumerConfig) {\n+        this.consumerConfig = consumerConfig;\n+      }\n+\n+      public void setTopics(List<String> topics) {\n+        this.topics = topics;\n+      }\n+\n+    /** Remaining properties omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+\n+After you have implemented the `ExternalTransformBuilder` and `ExternalTransformRegistrar` interfaces, your transform can be registered and created successfully by the default Java expansion service.\n+\n+**Using the expansion service**\n+\n+Java has a default expansion service included and available in the Apache Beam Java SDK. You can write your own expansion service, but that is generally not needed, so it is not covered in this section.\n+\n+Perform the following steps to start up a Java expansion service directly:\n+\n+{{< highlight >}}\n+// Path to a JAR file that contains the transform to expand, cross-language specific utilities (builder, registrar, etc.), and dependencies.\n+$ export EXPANSION_SERVICE_JAR=<My_expansion_service_JAR>\n+\n+$ export PORT_FOR_EXPANSION_SERVICE=12345\n+\n+$ jar -jar $EXPANSION_SERVICE_JAR $PORT_FOR_EXPANSION_SERVICE\n+{{< /highlight >}}\n+\n+When creating SDK-specific wrappers for your transform, SDKs may provide utilities that are readily available for easily starting up an expansion service. For example, the Python SDK provides the [BeamJarExpansionService](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py) utility for starting up a Java expansion service using a JAR file.\n+\n+**Including dependencies**\n+\n+If your transform requires external libraries, you can include them by adding them to the classpath of the expansion service. After they are included in the classpath, they will be staged when your transform is expanded by the expansion service.\n+\n+**Writing SDK-specific wrappers**\n+\n+Your cross-language Java transform can be called through the lower-level [ExternalTransform](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py) class in a multi-language pipeline (as described in the next section); however, if possible, you should create a SDK-specific wrapper written in the programming language of the pipeline (such as Python) to access the transform instead. This higher-level abstraction will make it easier for pipeline authors to use your transform.\n+\n+To create an SDK wrapper for use in a Python pipeline, do the following:\n+\n+1. Create a Python module for your cross-language transform.\n+2. In the module, build the payload that should be used to initiate the cross-language transform expansion request using one of the available [PayloadBuilder](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py) classes.\n+\n+    The parameter names and types of the payload should map to parameter names and types of the configuration POJO provided to the Java `ExternalTransformBuilder`. Parameter types are mapped across SDKs using a [Beam schema](https://github.com/apache/beam/blob/master/model/pipeline/src/main/proto/schema.proto). Parameter names are mapped by simply converting Python underscore-separated variable names to camel-case (Java standard).\n+\n+    In the following example, [kafka.py](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/io/kafka.py) uses `NamedTupleBasedPayloadBuilder` to build the payload. The parameters map to the Java [KafkaIO.External.Configuration](https://github.com/apache/beam/blob/master/sdks/java/io/kafka/src/main/java/org/apache/beam/sdk/io/kafka/KafkaIO.java) config object defined previously in the **Implementing the interfaces** section.\n+\n+    {{< highlight >}}\n+class ReadFromKafkaSchema(typing.NamedTuple):\n+      consumer_config: typing.Mapping[str, str]\n+      topics: typing.List[str]\n+      # Other properties omitted for clarity.\n+\n+payload = NamedTupleBasedPayloadBuilder(ReadFromKafkaSchema(...))\n+    {{< /highlight >}}\n+3. Start an expansion service unless one is specified by the pipeline creator. The Apache Beam Python SDK provides a utility, `BeamJarExpansionService`, for easily starting an expansion service based on a JAR released with Beam. To use this, do the following:", "originalCommit": "f2fb2a1604c620a1a3d753400fe0f3444c5ec821", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTgxODE3Mw==", "url": "https://github.com/apache/beam/pull/13317#discussion_r525818173", "bodyText": "Updated to include information about both JavaJarExpansionService and BeamJarExpansionService.", "author": "chamikaramj", "createdAt": "2020-11-18T05:09:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI5MjQ0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI5MjcwNQ==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523292705", "bodyText": "I'd say \"Starting\" rather than \"Using.\"", "author": "robertwb", "createdAt": "2020-11-13T23:57:34Z", "path": "website/www/site/content/en/documentation/programming-guide.md", "diffHunk": "@@ -5431,4 +5431,280 @@ use case.\n \n {{< highlight py >}}\n {{< code_sample \"sdks/python/apache_beam/examples/snippets/snippets.py\" BundleFinalize >}}\n-{{< /highlight >}}\n\\ No newline at end of file\n+{{< /highlight >}}\n+\n+## 13. Multi-language pipelines {#mulit-language-pipelines}\n+\n+Beam allows you to combine transforms written in any supported SDK language (currently, Java and Python) and use them in one multi-language pipeline. This capability makes it easy to provide new functionality simultaneously in different Apache Beam SDKs through a single cross-language transform. For example, the [Apache Kafka connector](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/io/kafka.py) and [SQL transform](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/sql.py) from the Java SDK can be used in Python streaming pipelines.\n+\n+Pipelines that use transforms from more than one SDK-language are known as *multi-language pipelines*.\n+\n+### 13.1. Creating cross-language transforms {#create-x-lang-transforms}\n+\n+To make transforms written in one language available to pipelines written in another language, an *expansion service* for that transform is used to create and inject the appropriate language-specific pipeline fragments into your pipeline.\n+\n+In the following example, a Python pipeline written the Apache Beam SDK for Python starts up a local Java expansion service on your computer to create and inject the appropriate Java pipeline fragments for executing the Java Kafka cross-language transform into your Python pipeline. The SDK then downloads and stages the necessary Java dependencies needed to execute these transforms.\n+\n+![Diagram of multi-language pipeline execution flow.](/images/multi-language-pipelines-diagram.svg)\n+\n+At runtime, the Beam runner will execute both Python and Java transforms to execute your pipeline.\n+\n+In this section, we will use [KafkaIO.Read](https://beam.apache.org/releases/javadoc/current/org/apache/beam/sdk/io/kafka/KafkaIO.Read.html) to illustrate how to create a cross-language transform for Java and a test example for Python.\n+\n+#### 13.1.1. Creating cross-language Java transforms\n+\n+To make your Apache Beam Java SDK transform portable across SDK languages, you must implement two interfaces: [ExternalTransformBuilder](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/ExternalTransformBuilder.java) and [ExternalTransformRegistrar](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/expansion/ExternalTransformRegistrar.java). The `ExternalTransformBuilder` interface constructs the cross-language transform using configuration values passed in from the pipeline and the `ExternalTransformRegistrar` interface registers the cross-language transform for use with the expansion service.\n+\n+**Implementing the interfaces**\n+\n+1. Define a Builder class for your transform that implements the `ExternalTransformBuilder` interface and overrides the `buildExternal` method that will be used to build your transform object. Initial configuration values for your transform should be defined in the `buildExternal` method. In most cases, it is convenient to make the Java transform builder class implement `ExternalTransformBuilder`.\n+\n+    > **Note:** `ExternalTransformBuilder` requires you to define a configuration object (a simple POJO) to capture a set of parameters sent by external SDKs to initiate the Java transform. Usually these parameters directly map to constructor parameters of the Java transform.\n+\n+    {{< highlight >}}\n+@AutoValue.Builder\n+abstract static class Builder<K, V>\n+  implements ExternalTransformBuilder<External.Configuration, PBegin, PCollection<KV<K, V>>> {\n+  abstract Builder<K, V> setConsumerConfig(Map<String, Object> config);\n+\n+  abstract Builder<K, V> setTopics(List<String> topics);\n+\n+  /** Remaining property declarations omitted for clarity. */\n+\n+  abstract Read<K, V> build();\n+\n+  @Override\n+  public PTransform<PBegin, PCollection<KV<K, V>>> buildExternal(\n+      External.Configuration config) {\n+    ImmutableList.Builder<String> listBuilder = ImmutableList.builder();\n+    for (String topic : config.topics) {\n+      listBuilder.add(topic);\n+    }\n+    setTopics(listBuilder.build());\n+\n+    /** Remaining property defaults omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+2. Register the transform as an external cross-language transform by defining a class that implements `ExternalTransformRegistrar`. You must annotate your class with the `AutoService` annotation to ensure that your transform is registered and instantiated properly by the expansion service.\n+3. In your registrar class, define a Uniform Resource Name (URN) for your transform. The URN must be a unique string that identifies your transform with the expansion service.\n+4. From within your registrar class, define a configuration class for the parameters used during the initialization of your transform by the external SDK.\n+\n+    The following example from the KafkaIO transform shows how to implement steps two through four:\n+\n+    {{< highlight >}}\n+@AutoService(ExternalTransformRegistrar.class)\n+public static class External implements ExternalTransformRegistrar {\n+\n+  public static final String URN = \"beam:external:java:kafka:read:v1\";\n+\n+  @Override\n+  public Map<String, Class<? extends ExternalTransformBuilder<?, ?, ?>>> knownBuilders() {\n+    return ImmutableMap.of(\n+        URN,\n+        (Class<? extends ExternalTransformBuilder<?, ?, ?>>)\n+            (Class<?>) AutoValue_KafkaIO_Read.Builder.class);\n+  }\n+\n+  /** Parameters class to expose the Read transform to an external SDK. */\n+  public static class Configuration {\n+    private Map<String, String> consumerConfig;\n+      private List<String> topics;\n+\n+\n+      public void setConsumerConfig(Map<String, String> consumerConfig) {\n+        this.consumerConfig = consumerConfig;\n+      }\n+\n+      public void setTopics(List<String> topics) {\n+        this.topics = topics;\n+      }\n+\n+    /** Remaining properties omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+\n+After you have implemented the `ExternalTransformBuilder` and `ExternalTransformRegistrar` interfaces, your transform can be registered and created successfully by the default Java expansion service.\n+\n+**Using the expansion service**", "originalCommit": "f2fb2a1604c620a1a3d753400fe0f3444c5ec821", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI5OTU4NA==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523299584", "bodyText": "Good point. Done.", "author": "davidwrede", "createdAt": "2020-11-14T00:29:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI5MjcwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI5MjgyOQ==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523292829", "bodyText": "Maybe call out that an expansion service can serve multiple transforms (and in general will serve everything that is registered).", "author": "robertwb", "createdAt": "2020-11-13T23:58:15Z", "path": "website/www/site/content/en/documentation/programming-guide.md", "diffHunk": "@@ -5431,4 +5431,280 @@ use case.\n \n {{< highlight py >}}\n {{< code_sample \"sdks/python/apache_beam/examples/snippets/snippets.py\" BundleFinalize >}}\n-{{< /highlight >}}\n\\ No newline at end of file\n+{{< /highlight >}}\n+\n+## 13. Multi-language pipelines {#mulit-language-pipelines}\n+\n+Beam allows you to combine transforms written in any supported SDK language (currently, Java and Python) and use them in one multi-language pipeline. This capability makes it easy to provide new functionality simultaneously in different Apache Beam SDKs through a single cross-language transform. For example, the [Apache Kafka connector](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/io/kafka.py) and [SQL transform](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/sql.py) from the Java SDK can be used in Python streaming pipelines.\n+\n+Pipelines that use transforms from more than one SDK-language are known as *multi-language pipelines*.\n+\n+### 13.1. Creating cross-language transforms {#create-x-lang-transforms}\n+\n+To make transforms written in one language available to pipelines written in another language, an *expansion service* for that transform is used to create and inject the appropriate language-specific pipeline fragments into your pipeline.\n+\n+In the following example, a Python pipeline written the Apache Beam SDK for Python starts up a local Java expansion service on your computer to create and inject the appropriate Java pipeline fragments for executing the Java Kafka cross-language transform into your Python pipeline. The SDK then downloads and stages the necessary Java dependencies needed to execute these transforms.\n+\n+![Diagram of multi-language pipeline execution flow.](/images/multi-language-pipelines-diagram.svg)\n+\n+At runtime, the Beam runner will execute both Python and Java transforms to execute your pipeline.\n+\n+In this section, we will use [KafkaIO.Read](https://beam.apache.org/releases/javadoc/current/org/apache/beam/sdk/io/kafka/KafkaIO.Read.html) to illustrate how to create a cross-language transform for Java and a test example for Python.\n+\n+#### 13.1.1. Creating cross-language Java transforms\n+\n+To make your Apache Beam Java SDK transform portable across SDK languages, you must implement two interfaces: [ExternalTransformBuilder](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/ExternalTransformBuilder.java) and [ExternalTransformRegistrar](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/expansion/ExternalTransformRegistrar.java). The `ExternalTransformBuilder` interface constructs the cross-language transform using configuration values passed in from the pipeline and the `ExternalTransformRegistrar` interface registers the cross-language transform for use with the expansion service.\n+\n+**Implementing the interfaces**\n+\n+1. Define a Builder class for your transform that implements the `ExternalTransformBuilder` interface and overrides the `buildExternal` method that will be used to build your transform object. Initial configuration values for your transform should be defined in the `buildExternal` method. In most cases, it is convenient to make the Java transform builder class implement `ExternalTransformBuilder`.\n+\n+    > **Note:** `ExternalTransformBuilder` requires you to define a configuration object (a simple POJO) to capture a set of parameters sent by external SDKs to initiate the Java transform. Usually these parameters directly map to constructor parameters of the Java transform.\n+\n+    {{< highlight >}}\n+@AutoValue.Builder\n+abstract static class Builder<K, V>\n+  implements ExternalTransformBuilder<External.Configuration, PBegin, PCollection<KV<K, V>>> {\n+  abstract Builder<K, V> setConsumerConfig(Map<String, Object> config);\n+\n+  abstract Builder<K, V> setTopics(List<String> topics);\n+\n+  /** Remaining property declarations omitted for clarity. */\n+\n+  abstract Read<K, V> build();\n+\n+  @Override\n+  public PTransform<PBegin, PCollection<KV<K, V>>> buildExternal(\n+      External.Configuration config) {\n+    ImmutableList.Builder<String> listBuilder = ImmutableList.builder();\n+    for (String topic : config.topics) {\n+      listBuilder.add(topic);\n+    }\n+    setTopics(listBuilder.build());\n+\n+    /** Remaining property defaults omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+2. Register the transform as an external cross-language transform by defining a class that implements `ExternalTransformRegistrar`. You must annotate your class with the `AutoService` annotation to ensure that your transform is registered and instantiated properly by the expansion service.\n+3. In your registrar class, define a Uniform Resource Name (URN) for your transform. The URN must be a unique string that identifies your transform with the expansion service.\n+4. From within your registrar class, define a configuration class for the parameters used during the initialization of your transform by the external SDK.\n+\n+    The following example from the KafkaIO transform shows how to implement steps two through four:\n+\n+    {{< highlight >}}\n+@AutoService(ExternalTransformRegistrar.class)\n+public static class External implements ExternalTransformRegistrar {\n+\n+  public static final String URN = \"beam:external:java:kafka:read:v1\";\n+\n+  @Override\n+  public Map<String, Class<? extends ExternalTransformBuilder<?, ?, ?>>> knownBuilders() {\n+    return ImmutableMap.of(\n+        URN,\n+        (Class<? extends ExternalTransformBuilder<?, ?, ?>>)\n+            (Class<?>) AutoValue_KafkaIO_Read.Builder.class);\n+  }\n+\n+  /** Parameters class to expose the Read transform to an external SDK. */\n+  public static class Configuration {\n+    private Map<String, String> consumerConfig;\n+      private List<String> topics;\n+\n+\n+      public void setConsumerConfig(Map<String, String> consumerConfig) {\n+        this.consumerConfig = consumerConfig;\n+      }\n+\n+      public void setTopics(List<String> topics) {\n+        this.topics = topics;\n+      }\n+\n+    /** Remaining properties omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+\n+After you have implemented the `ExternalTransformBuilder` and `ExternalTransformRegistrar` interfaces, your transform can be registered and created successfully by the default Java expansion service.\n+\n+**Using the expansion service**\n+\n+Java has a default expansion service included and available in the Apache Beam Java SDK. You can write your own expansion service, but that is generally not needed, so it is not covered in this section.", "originalCommit": "f2fb2a1604c620a1a3d753400fe0f3444c5ec821", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzMwMDQwOA==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523300408", "bodyText": "Done.", "author": "davidwrede", "createdAt": "2020-11-14T00:34:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI5MjgyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI5MzE5Mw==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523293193", "bodyText": "Note that this will only serve those transforms living in modules that have been imported...", "author": "robertwb", "createdAt": "2020-11-13T23:59:55Z", "path": "website/www/site/content/en/documentation/programming-guide.md", "diffHunk": "@@ -5431,4 +5431,280 @@ use case.\n \n {{< highlight py >}}\n {{< code_sample \"sdks/python/apache_beam/examples/snippets/snippets.py\" BundleFinalize >}}\n-{{< /highlight >}}\n\\ No newline at end of file\n+{{< /highlight >}}\n+\n+## 13. Multi-language pipelines {#mulit-language-pipelines}\n+\n+Beam allows you to combine transforms written in any supported SDK language (currently, Java and Python) and use them in one multi-language pipeline. This capability makes it easy to provide new functionality simultaneously in different Apache Beam SDKs through a single cross-language transform. For example, the [Apache Kafka connector](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/io/kafka.py) and [SQL transform](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/sql.py) from the Java SDK can be used in Python streaming pipelines.\n+\n+Pipelines that use transforms from more than one SDK-language are known as *multi-language pipelines*.\n+\n+### 13.1. Creating cross-language transforms {#create-x-lang-transforms}\n+\n+To make transforms written in one language available to pipelines written in another language, an *expansion service* for that transform is used to create and inject the appropriate language-specific pipeline fragments into your pipeline.\n+\n+In the following example, a Python pipeline written the Apache Beam SDK for Python starts up a local Java expansion service on your computer to create and inject the appropriate Java pipeline fragments for executing the Java Kafka cross-language transform into your Python pipeline. The SDK then downloads and stages the necessary Java dependencies needed to execute these transforms.\n+\n+![Diagram of multi-language pipeline execution flow.](/images/multi-language-pipelines-diagram.svg)\n+\n+At runtime, the Beam runner will execute both Python and Java transforms to execute your pipeline.\n+\n+In this section, we will use [KafkaIO.Read](https://beam.apache.org/releases/javadoc/current/org/apache/beam/sdk/io/kafka/KafkaIO.Read.html) to illustrate how to create a cross-language transform for Java and a test example for Python.\n+\n+#### 13.1.1. Creating cross-language Java transforms\n+\n+To make your Apache Beam Java SDK transform portable across SDK languages, you must implement two interfaces: [ExternalTransformBuilder](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/ExternalTransformBuilder.java) and [ExternalTransformRegistrar](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/expansion/ExternalTransformRegistrar.java). The `ExternalTransformBuilder` interface constructs the cross-language transform using configuration values passed in from the pipeline and the `ExternalTransformRegistrar` interface registers the cross-language transform for use with the expansion service.\n+\n+**Implementing the interfaces**\n+\n+1. Define a Builder class for your transform that implements the `ExternalTransformBuilder` interface and overrides the `buildExternal` method that will be used to build your transform object. Initial configuration values for your transform should be defined in the `buildExternal` method. In most cases, it is convenient to make the Java transform builder class implement `ExternalTransformBuilder`.\n+\n+    > **Note:** `ExternalTransformBuilder` requires you to define a configuration object (a simple POJO) to capture a set of parameters sent by external SDKs to initiate the Java transform. Usually these parameters directly map to constructor parameters of the Java transform.\n+\n+    {{< highlight >}}\n+@AutoValue.Builder\n+abstract static class Builder<K, V>\n+  implements ExternalTransformBuilder<External.Configuration, PBegin, PCollection<KV<K, V>>> {\n+  abstract Builder<K, V> setConsumerConfig(Map<String, Object> config);\n+\n+  abstract Builder<K, V> setTopics(List<String> topics);\n+\n+  /** Remaining property declarations omitted for clarity. */\n+\n+  abstract Read<K, V> build();\n+\n+  @Override\n+  public PTransform<PBegin, PCollection<KV<K, V>>> buildExternal(\n+      External.Configuration config) {\n+    ImmutableList.Builder<String> listBuilder = ImmutableList.builder();\n+    for (String topic : config.topics) {\n+      listBuilder.add(topic);\n+    }\n+    setTopics(listBuilder.build());\n+\n+    /** Remaining property defaults omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+2. Register the transform as an external cross-language transform by defining a class that implements `ExternalTransformRegistrar`. You must annotate your class with the `AutoService` annotation to ensure that your transform is registered and instantiated properly by the expansion service.\n+3. In your registrar class, define a Uniform Resource Name (URN) for your transform. The URN must be a unique string that identifies your transform with the expansion service.\n+4. From within your registrar class, define a configuration class for the parameters used during the initialization of your transform by the external SDK.\n+\n+    The following example from the KafkaIO transform shows how to implement steps two through four:\n+\n+    {{< highlight >}}\n+@AutoService(ExternalTransformRegistrar.class)\n+public static class External implements ExternalTransformRegistrar {\n+\n+  public static final String URN = \"beam:external:java:kafka:read:v1\";\n+\n+  @Override\n+  public Map<String, Class<? extends ExternalTransformBuilder<?, ?, ?>>> knownBuilders() {\n+    return ImmutableMap.of(\n+        URN,\n+        (Class<? extends ExternalTransformBuilder<?, ?, ?>>)\n+            (Class<?>) AutoValue_KafkaIO_Read.Builder.class);\n+  }\n+\n+  /** Parameters class to expose the Read transform to an external SDK. */\n+  public static class Configuration {\n+    private Map<String, String> consumerConfig;\n+      private List<String> topics;\n+\n+\n+      public void setConsumerConfig(Map<String, String> consumerConfig) {\n+        this.consumerConfig = consumerConfig;\n+      }\n+\n+      public void setTopics(List<String> topics) {\n+        this.topics = topics;\n+      }\n+\n+    /** Remaining properties omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+\n+After you have implemented the `ExternalTransformBuilder` and `ExternalTransformRegistrar` interfaces, your transform can be registered and created successfully by the default Java expansion service.\n+\n+**Using the expansion service**\n+\n+Java has a default expansion service included and available in the Apache Beam Java SDK. You can write your own expansion service, but that is generally not needed, so it is not covered in this section.\n+\n+Perform the following steps to start up a Java expansion service directly:\n+\n+{{< highlight >}}\n+// Path to a JAR file that contains the transform to expand, cross-language specific utilities (builder, registrar, etc.), and dependencies.\n+$ export EXPANSION_SERVICE_JAR=<My_expansion_service_JAR>\n+\n+$ export PORT_FOR_EXPANSION_SERVICE=12345\n+\n+$ jar -jar $EXPANSION_SERVICE_JAR $PORT_FOR_EXPANSION_SERVICE\n+{{< /highlight >}}\n+\n+When creating SDK-specific wrappers for your transform, SDKs may provide utilities that are readily available for easily starting up an expansion service. For example, the Python SDK provides the [BeamJarExpansionService](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py) utility for starting up a Java expansion service using a JAR file.\n+\n+**Including dependencies**\n+\n+If your transform requires external libraries, you can include them by adding them to the classpath of the expansion service. After they are included in the classpath, they will be staged when your transform is expanded by the expansion service.\n+\n+**Writing SDK-specific wrappers**\n+\n+Your cross-language Java transform can be called through the lower-level [ExternalTransform](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py) class in a multi-language pipeline (as described in the next section); however, if possible, you should create a SDK-specific wrapper written in the programming language of the pipeline (such as Python) to access the transform instead. This higher-level abstraction will make it easier for pipeline authors to use your transform.\n+\n+To create an SDK wrapper for use in a Python pipeline, do the following:\n+\n+1. Create a Python module for your cross-language transform.\n+2. In the module, build the payload that should be used to initiate the cross-language transform expansion request using one of the available [PayloadBuilder](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py) classes.\n+\n+    The parameter names and types of the payload should map to parameter names and types of the configuration POJO provided to the Java `ExternalTransformBuilder`. Parameter types are mapped across SDKs using a [Beam schema](https://github.com/apache/beam/blob/master/model/pipeline/src/main/proto/schema.proto). Parameter names are mapped by simply converting Python underscore-separated variable names to camel-case (Java standard).\n+\n+    In the following example, [kafka.py](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/io/kafka.py) uses `NamedTupleBasedPayloadBuilder` to build the payload. The parameters map to the Java [KafkaIO.External.Configuration](https://github.com/apache/beam/blob/master/sdks/java/io/kafka/src/main/java/org/apache/beam/sdk/io/kafka/KafkaIO.java) config object defined previously in the **Implementing the interfaces** section.\n+\n+    {{< highlight >}}\n+class ReadFromKafkaSchema(typing.NamedTuple):\n+      consumer_config: typing.Mapping[str, str]\n+      topics: typing.List[str]\n+      # Other properties omitted for clarity.\n+\n+payload = NamedTupleBasedPayloadBuilder(ReadFromKafkaSchema(...))\n+    {{< /highlight >}}\n+3. Start an expansion service unless one is specified by the pipeline creator. The Apache Beam Python SDK provides a utility, `BeamJarExpansionService`, for easily starting an expansion service based on a JAR released with Beam. To use this, do the following:\n+\n+    1. Add a Gradle target to Beam that can be used to build a shaded expansion service JAR for the target Java transform. This target should produce a Beam JAR that contains all dependencies needed for expanding the Java transform and the JAR should be released with Beam.\n+    2. In your Python module, instantiate `BeamJarExpansionService` with the Gradle target.\n+\n+        {{< highlight >}}\n+    expansion_service = BeamJarExpansionService('sdks:java:io:expansion-service:shadowJar')\n+        {{< /highlight >}}\n+4. Add a Python wrapper transform class that extends [ExternalTransform](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py). Pass the payload and expansion service defined above as parameters to the constructor of the `ExternalTransform` parent class.\n+\n+#### 13.1.2. Creating cross-language Python transforms\n+\n+To make your Python transform usable with different SDK languages, you must create a Python module that registers an existing Python transform as a cross-language transform for use with the Python expansion service and calls into that existing transform to perform its intended operation.\n+\n+**Defining the Python module**\n+\n+1. Define a Uniform Resource Name (URN) for your transform. The URN must be a unique string that identifies your transform with the expansion service.\n+\n+    {{< highlight >}}\n+TEST_COMPK_URN = \"beam:transforms:xlang:test:compk\"\n+    {{< /highlight >}}\n+2. For an existing Python transform, create a new class to register the URN with the Python expansion service.\n+\n+    {{< highlight >}}\n+@ptransform.PTransform.register_urn(TEST_COMPK_URN, None)\n+class CombinePerKeyTransform(ptransform.PTransform):\n+    {{< /highlight >}}\n+3. From within the class, define an expand method that takes an input PCollection, runs the Python transform, and then returns the output PCollection.\n+\n+    {{< highlight >}}\n+def expand(self, pcoll):\n+    return pcoll \\\n+        | beam.CombinePerKey(sum).with_output_types(\n+              typing.Tuple[unicode, int])\n+    {{< /highlight >}}\n+4. As with other Python transforms, define a `to_runner_api_parameter` method that returns the URN.\n+\n+    {{< highlight >}}\n+def to_runner_api_parameter(self, unused_context):\n+    return TEST_COMPK_URN, None\n+    {{< /highlight >}}\n+5. Define a static `from_runner_api_parameter` method that returns an instantiation of the cross-language Python transform.\n+\n+    {{< highlight >}}\n+@staticmethod\n+def from_runner_api_parameter(\n+      unused_ptransform, unused_parameter, unused_context):\n+    return CombinePerKeyTransform()\n+    {{< /highlight >}}\n+\n+**Using the expansion service**\n+\n+Python has a default expansion service included and available in the Apache Beam SDK. You are free to write your own expansion service, but that is generally not needed, so it is not covered in this section.\n+\n+Perform the following steps to start up the default Python expansion service directly:\n+\n+1. Create a virtual environment and [install the Apache Beam SDK](https://beam.apache.org/get-started/quickstart-py/).\n+2. Start the Python SDK\u2019s expansion service with a specified port.\n+\n+    {{< highlight >}}\n+$ export PORT_FOR_EXPANSION_SERVICE=12345\n+$ python -m apache_beam.runners.portability.expansion_service -p $PORT_FOR_EXPANSION_SERVICE", "originalCommit": "f2fb2a1604c620a1a3d753400fe0f3444c5ec821", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU2NDgzNQ==", "url": "https://github.com/apache/beam/pull/13317#discussion_r525564835", "bodyText": "Added a point to import modules.", "author": "chamikaramj", "createdAt": "2020-11-17T22:23:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI5MzE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI5MzcxMg==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523293712", "bodyText": "How do you specify the custom container?", "author": "robertwb", "createdAt": "2020-11-14T00:02:16Z", "path": "website/www/site/content/en/documentation/programming-guide.md", "diffHunk": "@@ -5431,4 +5431,280 @@ use case.\n \n {{< highlight py >}}\n {{< code_sample \"sdks/python/apache_beam/examples/snippets/snippets.py\" BundleFinalize >}}\n-{{< /highlight >}}\n\\ No newline at end of file\n+{{< /highlight >}}\n+\n+## 13. Multi-language pipelines {#mulit-language-pipelines}\n+\n+Beam allows you to combine transforms written in any supported SDK language (currently, Java and Python) and use them in one multi-language pipeline. This capability makes it easy to provide new functionality simultaneously in different Apache Beam SDKs through a single cross-language transform. For example, the [Apache Kafka connector](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/io/kafka.py) and [SQL transform](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/sql.py) from the Java SDK can be used in Python streaming pipelines.\n+\n+Pipelines that use transforms from more than one SDK-language are known as *multi-language pipelines*.\n+\n+### 13.1. Creating cross-language transforms {#create-x-lang-transforms}\n+\n+To make transforms written in one language available to pipelines written in another language, an *expansion service* for that transform is used to create and inject the appropriate language-specific pipeline fragments into your pipeline.\n+\n+In the following example, a Python pipeline written the Apache Beam SDK for Python starts up a local Java expansion service on your computer to create and inject the appropriate Java pipeline fragments for executing the Java Kafka cross-language transform into your Python pipeline. The SDK then downloads and stages the necessary Java dependencies needed to execute these transforms.\n+\n+![Diagram of multi-language pipeline execution flow.](/images/multi-language-pipelines-diagram.svg)\n+\n+At runtime, the Beam runner will execute both Python and Java transforms to execute your pipeline.\n+\n+In this section, we will use [KafkaIO.Read](https://beam.apache.org/releases/javadoc/current/org/apache/beam/sdk/io/kafka/KafkaIO.Read.html) to illustrate how to create a cross-language transform for Java and a test example for Python.\n+\n+#### 13.1.1. Creating cross-language Java transforms\n+\n+To make your Apache Beam Java SDK transform portable across SDK languages, you must implement two interfaces: [ExternalTransformBuilder](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/ExternalTransformBuilder.java) and [ExternalTransformRegistrar](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/expansion/ExternalTransformRegistrar.java). The `ExternalTransformBuilder` interface constructs the cross-language transform using configuration values passed in from the pipeline and the `ExternalTransformRegistrar` interface registers the cross-language transform for use with the expansion service.\n+\n+**Implementing the interfaces**\n+\n+1. Define a Builder class for your transform that implements the `ExternalTransformBuilder` interface and overrides the `buildExternal` method that will be used to build your transform object. Initial configuration values for your transform should be defined in the `buildExternal` method. In most cases, it is convenient to make the Java transform builder class implement `ExternalTransformBuilder`.\n+\n+    > **Note:** `ExternalTransformBuilder` requires you to define a configuration object (a simple POJO) to capture a set of parameters sent by external SDKs to initiate the Java transform. Usually these parameters directly map to constructor parameters of the Java transform.\n+\n+    {{< highlight >}}\n+@AutoValue.Builder\n+abstract static class Builder<K, V>\n+  implements ExternalTransformBuilder<External.Configuration, PBegin, PCollection<KV<K, V>>> {\n+  abstract Builder<K, V> setConsumerConfig(Map<String, Object> config);\n+\n+  abstract Builder<K, V> setTopics(List<String> topics);\n+\n+  /** Remaining property declarations omitted for clarity. */\n+\n+  abstract Read<K, V> build();\n+\n+  @Override\n+  public PTransform<PBegin, PCollection<KV<K, V>>> buildExternal(\n+      External.Configuration config) {\n+    ImmutableList.Builder<String> listBuilder = ImmutableList.builder();\n+    for (String topic : config.topics) {\n+      listBuilder.add(topic);\n+    }\n+    setTopics(listBuilder.build());\n+\n+    /** Remaining property defaults omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+2. Register the transform as an external cross-language transform by defining a class that implements `ExternalTransformRegistrar`. You must annotate your class with the `AutoService` annotation to ensure that your transform is registered and instantiated properly by the expansion service.\n+3. In your registrar class, define a Uniform Resource Name (URN) for your transform. The URN must be a unique string that identifies your transform with the expansion service.\n+4. From within your registrar class, define a configuration class for the parameters used during the initialization of your transform by the external SDK.\n+\n+    The following example from the KafkaIO transform shows how to implement steps two through four:\n+\n+    {{< highlight >}}\n+@AutoService(ExternalTransformRegistrar.class)\n+public static class External implements ExternalTransformRegistrar {\n+\n+  public static final String URN = \"beam:external:java:kafka:read:v1\";\n+\n+  @Override\n+  public Map<String, Class<? extends ExternalTransformBuilder<?, ?, ?>>> knownBuilders() {\n+    return ImmutableMap.of(\n+        URN,\n+        (Class<? extends ExternalTransformBuilder<?, ?, ?>>)\n+            (Class<?>) AutoValue_KafkaIO_Read.Builder.class);\n+  }\n+\n+  /** Parameters class to expose the Read transform to an external SDK. */\n+  public static class Configuration {\n+    private Map<String, String> consumerConfig;\n+      private List<String> topics;\n+\n+\n+      public void setConsumerConfig(Map<String, String> consumerConfig) {\n+        this.consumerConfig = consumerConfig;\n+      }\n+\n+      public void setTopics(List<String> topics) {\n+        this.topics = topics;\n+      }\n+\n+    /** Remaining properties omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+\n+After you have implemented the `ExternalTransformBuilder` and `ExternalTransformRegistrar` interfaces, your transform can be registered and created successfully by the default Java expansion service.\n+\n+**Using the expansion service**\n+\n+Java has a default expansion service included and available in the Apache Beam Java SDK. You can write your own expansion service, but that is generally not needed, so it is not covered in this section.\n+\n+Perform the following steps to start up a Java expansion service directly:\n+\n+{{< highlight >}}\n+// Path to a JAR file that contains the transform to expand, cross-language specific utilities (builder, registrar, etc.), and dependencies.\n+$ export EXPANSION_SERVICE_JAR=<My_expansion_service_JAR>\n+\n+$ export PORT_FOR_EXPANSION_SERVICE=12345\n+\n+$ jar -jar $EXPANSION_SERVICE_JAR $PORT_FOR_EXPANSION_SERVICE\n+{{< /highlight >}}\n+\n+When creating SDK-specific wrappers for your transform, SDKs may provide utilities that are readily available for easily starting up an expansion service. For example, the Python SDK provides the [BeamJarExpansionService](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py) utility for starting up a Java expansion service using a JAR file.\n+\n+**Including dependencies**\n+\n+If your transform requires external libraries, you can include them by adding them to the classpath of the expansion service. After they are included in the classpath, they will be staged when your transform is expanded by the expansion service.\n+\n+**Writing SDK-specific wrappers**\n+\n+Your cross-language Java transform can be called through the lower-level [ExternalTransform](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py) class in a multi-language pipeline (as described in the next section); however, if possible, you should create a SDK-specific wrapper written in the programming language of the pipeline (such as Python) to access the transform instead. This higher-level abstraction will make it easier for pipeline authors to use your transform.\n+\n+To create an SDK wrapper for use in a Python pipeline, do the following:\n+\n+1. Create a Python module for your cross-language transform.\n+2. In the module, build the payload that should be used to initiate the cross-language transform expansion request using one of the available [PayloadBuilder](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py) classes.\n+\n+    The parameter names and types of the payload should map to parameter names and types of the configuration POJO provided to the Java `ExternalTransformBuilder`. Parameter types are mapped across SDKs using a [Beam schema](https://github.com/apache/beam/blob/master/model/pipeline/src/main/proto/schema.proto). Parameter names are mapped by simply converting Python underscore-separated variable names to camel-case (Java standard).\n+\n+    In the following example, [kafka.py](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/io/kafka.py) uses `NamedTupleBasedPayloadBuilder` to build the payload. The parameters map to the Java [KafkaIO.External.Configuration](https://github.com/apache/beam/blob/master/sdks/java/io/kafka/src/main/java/org/apache/beam/sdk/io/kafka/KafkaIO.java) config object defined previously in the **Implementing the interfaces** section.\n+\n+    {{< highlight >}}\n+class ReadFromKafkaSchema(typing.NamedTuple):\n+      consumer_config: typing.Mapping[str, str]\n+      topics: typing.List[str]\n+      # Other properties omitted for clarity.\n+\n+payload = NamedTupleBasedPayloadBuilder(ReadFromKafkaSchema(...))\n+    {{< /highlight >}}\n+3. Start an expansion service unless one is specified by the pipeline creator. The Apache Beam Python SDK provides a utility, `BeamJarExpansionService`, for easily starting an expansion service based on a JAR released with Beam. To use this, do the following:\n+\n+    1. Add a Gradle target to Beam that can be used to build a shaded expansion service JAR for the target Java transform. This target should produce a Beam JAR that contains all dependencies needed for expanding the Java transform and the JAR should be released with Beam.\n+    2. In your Python module, instantiate `BeamJarExpansionService` with the Gradle target.\n+\n+        {{< highlight >}}\n+    expansion_service = BeamJarExpansionService('sdks:java:io:expansion-service:shadowJar')\n+        {{< /highlight >}}\n+4. Add a Python wrapper transform class that extends [ExternalTransform](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py). Pass the payload and expansion service defined above as parameters to the constructor of the `ExternalTransform` parent class.\n+\n+#### 13.1.2. Creating cross-language Python transforms\n+\n+To make your Python transform usable with different SDK languages, you must create a Python module that registers an existing Python transform as a cross-language transform for use with the Python expansion service and calls into that existing transform to perform its intended operation.\n+\n+**Defining the Python module**\n+\n+1. Define a Uniform Resource Name (URN) for your transform. The URN must be a unique string that identifies your transform with the expansion service.\n+\n+    {{< highlight >}}\n+TEST_COMPK_URN = \"beam:transforms:xlang:test:compk\"\n+    {{< /highlight >}}\n+2. For an existing Python transform, create a new class to register the URN with the Python expansion service.\n+\n+    {{< highlight >}}\n+@ptransform.PTransform.register_urn(TEST_COMPK_URN, None)\n+class CombinePerKeyTransform(ptransform.PTransform):\n+    {{< /highlight >}}\n+3. From within the class, define an expand method that takes an input PCollection, runs the Python transform, and then returns the output PCollection.\n+\n+    {{< highlight >}}\n+def expand(self, pcoll):\n+    return pcoll \\\n+        | beam.CombinePerKey(sum).with_output_types(\n+              typing.Tuple[unicode, int])\n+    {{< /highlight >}}\n+4. As with other Python transforms, define a `to_runner_api_parameter` method that returns the URN.\n+\n+    {{< highlight >}}\n+def to_runner_api_parameter(self, unused_context):\n+    return TEST_COMPK_URN, None\n+    {{< /highlight >}}\n+5. Define a static `from_runner_api_parameter` method that returns an instantiation of the cross-language Python transform.\n+\n+    {{< highlight >}}\n+@staticmethod\n+def from_runner_api_parameter(\n+      unused_ptransform, unused_parameter, unused_context):\n+    return CombinePerKeyTransform()\n+    {{< /highlight >}}\n+\n+**Using the expansion service**\n+\n+Python has a default expansion service included and available in the Apache Beam SDK. You are free to write your own expansion service, but that is generally not needed, so it is not covered in this section.\n+\n+Perform the following steps to start up the default Python expansion service directly:\n+\n+1. Create a virtual environment and [install the Apache Beam SDK](https://beam.apache.org/get-started/quickstart-py/).\n+2. Start the Python SDK\u2019s expansion service with a specified port.\n+\n+    {{< highlight >}}\n+$ export PORT_FOR_EXPANSION_SERVICE=12345\n+$ python -m apache_beam.runners.portability.expansion_service -p $PORT_FOR_EXPANSION_SERVICE\n+    {{< /highlight >}}\n+\n+**Including dependencies**\n+\n+If your transform requires external libraries, make sure those dependencies are already specified in a custom container for SDK harness. Core Apache Beam dependencies are already included.", "originalCommit": "f2fb2a1604c620a1a3d753400fe0f3444c5ec821", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU2NzEwOA==", "url": "https://github.com/apache/beam/pull/13317#discussion_r525567108", "bodyText": "I don't think we have fully implemented dependencies support for Python external transforms yet so we are limited to dependencies available with core Beam SDK Harness. Updated text to reflect this.", "author": "chamikaramj", "createdAt": "2020-11-17T22:28:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI5MzcxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI5Mzk5Mw==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523293993", "bodyText": "Consistently capitalize Python.", "author": "robertwb", "createdAt": "2020-11-14T00:03:47Z", "path": "website/www/site/content/en/documentation/programming-guide.md", "diffHunk": "@@ -5431,4 +5431,280 @@ use case.\n \n {{< highlight py >}}\n {{< code_sample \"sdks/python/apache_beam/examples/snippets/snippets.py\" BundleFinalize >}}\n-{{< /highlight >}}\n\\ No newline at end of file\n+{{< /highlight >}}\n+\n+## 13. Multi-language pipelines {#mulit-language-pipelines}\n+\n+Beam allows you to combine transforms written in any supported SDK language (currently, Java and Python) and use them in one multi-language pipeline. This capability makes it easy to provide new functionality simultaneously in different Apache Beam SDKs through a single cross-language transform. For example, the [Apache Kafka connector](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/io/kafka.py) and [SQL transform](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/sql.py) from the Java SDK can be used in Python streaming pipelines.\n+\n+Pipelines that use transforms from more than one SDK-language are known as *multi-language pipelines*.\n+\n+### 13.1. Creating cross-language transforms {#create-x-lang-transforms}\n+\n+To make transforms written in one language available to pipelines written in another language, an *expansion service* for that transform is used to create and inject the appropriate language-specific pipeline fragments into your pipeline.\n+\n+In the following example, a Python pipeline written the Apache Beam SDK for Python starts up a local Java expansion service on your computer to create and inject the appropriate Java pipeline fragments for executing the Java Kafka cross-language transform into your Python pipeline. The SDK then downloads and stages the necessary Java dependencies needed to execute these transforms.\n+\n+![Diagram of multi-language pipeline execution flow.](/images/multi-language-pipelines-diagram.svg)\n+\n+At runtime, the Beam runner will execute both Python and Java transforms to execute your pipeline.\n+\n+In this section, we will use [KafkaIO.Read](https://beam.apache.org/releases/javadoc/current/org/apache/beam/sdk/io/kafka/KafkaIO.Read.html) to illustrate how to create a cross-language transform for Java and a test example for Python.\n+\n+#### 13.1.1. Creating cross-language Java transforms\n+\n+To make your Apache Beam Java SDK transform portable across SDK languages, you must implement two interfaces: [ExternalTransformBuilder](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/ExternalTransformBuilder.java) and [ExternalTransformRegistrar](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/expansion/ExternalTransformRegistrar.java). The `ExternalTransformBuilder` interface constructs the cross-language transform using configuration values passed in from the pipeline and the `ExternalTransformRegistrar` interface registers the cross-language transform for use with the expansion service.\n+\n+**Implementing the interfaces**\n+\n+1. Define a Builder class for your transform that implements the `ExternalTransformBuilder` interface and overrides the `buildExternal` method that will be used to build your transform object. Initial configuration values for your transform should be defined in the `buildExternal` method. In most cases, it is convenient to make the Java transform builder class implement `ExternalTransformBuilder`.\n+\n+    > **Note:** `ExternalTransformBuilder` requires you to define a configuration object (a simple POJO) to capture a set of parameters sent by external SDKs to initiate the Java transform. Usually these parameters directly map to constructor parameters of the Java transform.\n+\n+    {{< highlight >}}\n+@AutoValue.Builder\n+abstract static class Builder<K, V>\n+  implements ExternalTransformBuilder<External.Configuration, PBegin, PCollection<KV<K, V>>> {\n+  abstract Builder<K, V> setConsumerConfig(Map<String, Object> config);\n+\n+  abstract Builder<K, V> setTopics(List<String> topics);\n+\n+  /** Remaining property declarations omitted for clarity. */\n+\n+  abstract Read<K, V> build();\n+\n+  @Override\n+  public PTransform<PBegin, PCollection<KV<K, V>>> buildExternal(\n+      External.Configuration config) {\n+    ImmutableList.Builder<String> listBuilder = ImmutableList.builder();\n+    for (String topic : config.topics) {\n+      listBuilder.add(topic);\n+    }\n+    setTopics(listBuilder.build());\n+\n+    /** Remaining property defaults omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+2. Register the transform as an external cross-language transform by defining a class that implements `ExternalTransformRegistrar`. You must annotate your class with the `AutoService` annotation to ensure that your transform is registered and instantiated properly by the expansion service.\n+3. In your registrar class, define a Uniform Resource Name (URN) for your transform. The URN must be a unique string that identifies your transform with the expansion service.\n+4. From within your registrar class, define a configuration class for the parameters used during the initialization of your transform by the external SDK.\n+\n+    The following example from the KafkaIO transform shows how to implement steps two through four:\n+\n+    {{< highlight >}}\n+@AutoService(ExternalTransformRegistrar.class)\n+public static class External implements ExternalTransformRegistrar {\n+\n+  public static final String URN = \"beam:external:java:kafka:read:v1\";\n+\n+  @Override\n+  public Map<String, Class<? extends ExternalTransformBuilder<?, ?, ?>>> knownBuilders() {\n+    return ImmutableMap.of(\n+        URN,\n+        (Class<? extends ExternalTransformBuilder<?, ?, ?>>)\n+            (Class<?>) AutoValue_KafkaIO_Read.Builder.class);\n+  }\n+\n+  /** Parameters class to expose the Read transform to an external SDK. */\n+  public static class Configuration {\n+    private Map<String, String> consumerConfig;\n+      private List<String> topics;\n+\n+\n+      public void setConsumerConfig(Map<String, String> consumerConfig) {\n+        this.consumerConfig = consumerConfig;\n+      }\n+\n+      public void setTopics(List<String> topics) {\n+        this.topics = topics;\n+      }\n+\n+    /** Remaining properties omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+\n+After you have implemented the `ExternalTransformBuilder` and `ExternalTransformRegistrar` interfaces, your transform can be registered and created successfully by the default Java expansion service.\n+\n+**Using the expansion service**\n+\n+Java has a default expansion service included and available in the Apache Beam Java SDK. You can write your own expansion service, but that is generally not needed, so it is not covered in this section.\n+\n+Perform the following steps to start up a Java expansion service directly:\n+\n+{{< highlight >}}\n+// Path to a JAR file that contains the transform to expand, cross-language specific utilities (builder, registrar, etc.), and dependencies.\n+$ export EXPANSION_SERVICE_JAR=<My_expansion_service_JAR>\n+\n+$ export PORT_FOR_EXPANSION_SERVICE=12345\n+\n+$ jar -jar $EXPANSION_SERVICE_JAR $PORT_FOR_EXPANSION_SERVICE\n+{{< /highlight >}}\n+\n+When creating SDK-specific wrappers for your transform, SDKs may provide utilities that are readily available for easily starting up an expansion service. For example, the Python SDK provides the [BeamJarExpansionService](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py) utility for starting up a Java expansion service using a JAR file.\n+\n+**Including dependencies**\n+\n+If your transform requires external libraries, you can include them by adding them to the classpath of the expansion service. After they are included in the classpath, they will be staged when your transform is expanded by the expansion service.\n+\n+**Writing SDK-specific wrappers**\n+\n+Your cross-language Java transform can be called through the lower-level [ExternalTransform](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py) class in a multi-language pipeline (as described in the next section); however, if possible, you should create a SDK-specific wrapper written in the programming language of the pipeline (such as Python) to access the transform instead. This higher-level abstraction will make it easier for pipeline authors to use your transform.\n+\n+To create an SDK wrapper for use in a Python pipeline, do the following:\n+\n+1. Create a Python module for your cross-language transform.\n+2. In the module, build the payload that should be used to initiate the cross-language transform expansion request using one of the available [PayloadBuilder](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py) classes.\n+\n+    The parameter names and types of the payload should map to parameter names and types of the configuration POJO provided to the Java `ExternalTransformBuilder`. Parameter types are mapped across SDKs using a [Beam schema](https://github.com/apache/beam/blob/master/model/pipeline/src/main/proto/schema.proto). Parameter names are mapped by simply converting Python underscore-separated variable names to camel-case (Java standard).\n+\n+    In the following example, [kafka.py](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/io/kafka.py) uses `NamedTupleBasedPayloadBuilder` to build the payload. The parameters map to the Java [KafkaIO.External.Configuration](https://github.com/apache/beam/blob/master/sdks/java/io/kafka/src/main/java/org/apache/beam/sdk/io/kafka/KafkaIO.java) config object defined previously in the **Implementing the interfaces** section.\n+\n+    {{< highlight >}}\n+class ReadFromKafkaSchema(typing.NamedTuple):\n+      consumer_config: typing.Mapping[str, str]\n+      topics: typing.List[str]\n+      # Other properties omitted for clarity.\n+\n+payload = NamedTupleBasedPayloadBuilder(ReadFromKafkaSchema(...))\n+    {{< /highlight >}}\n+3. Start an expansion service unless one is specified by the pipeline creator. The Apache Beam Python SDK provides a utility, `BeamJarExpansionService`, for easily starting an expansion service based on a JAR released with Beam. To use this, do the following:\n+\n+    1. Add a Gradle target to Beam that can be used to build a shaded expansion service JAR for the target Java transform. This target should produce a Beam JAR that contains all dependencies needed for expanding the Java transform and the JAR should be released with Beam.\n+    2. In your Python module, instantiate `BeamJarExpansionService` with the Gradle target.\n+\n+        {{< highlight >}}\n+    expansion_service = BeamJarExpansionService('sdks:java:io:expansion-service:shadowJar')\n+        {{< /highlight >}}\n+4. Add a Python wrapper transform class that extends [ExternalTransform](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py). Pass the payload and expansion service defined above as parameters to the constructor of the `ExternalTransform` parent class.\n+\n+#### 13.1.2. Creating cross-language Python transforms\n+\n+To make your Python transform usable with different SDK languages, you must create a Python module that registers an existing Python transform as a cross-language transform for use with the Python expansion service and calls into that existing transform to perform its intended operation.\n+\n+**Defining the Python module**\n+\n+1. Define a Uniform Resource Name (URN) for your transform. The URN must be a unique string that identifies your transform with the expansion service.\n+\n+    {{< highlight >}}\n+TEST_COMPK_URN = \"beam:transforms:xlang:test:compk\"\n+    {{< /highlight >}}\n+2. For an existing Python transform, create a new class to register the URN with the Python expansion service.\n+\n+    {{< highlight >}}\n+@ptransform.PTransform.register_urn(TEST_COMPK_URN, None)\n+class CombinePerKeyTransform(ptransform.PTransform):\n+    {{< /highlight >}}\n+3. From within the class, define an expand method that takes an input PCollection, runs the Python transform, and then returns the output PCollection.\n+\n+    {{< highlight >}}\n+def expand(self, pcoll):\n+    return pcoll \\\n+        | beam.CombinePerKey(sum).with_output_types(\n+              typing.Tuple[unicode, int])\n+    {{< /highlight >}}\n+4. As with other Python transforms, define a `to_runner_api_parameter` method that returns the URN.\n+\n+    {{< highlight >}}\n+def to_runner_api_parameter(self, unused_context):\n+    return TEST_COMPK_URN, None\n+    {{< /highlight >}}\n+5. Define a static `from_runner_api_parameter` method that returns an instantiation of the cross-language Python transform.\n+\n+    {{< highlight >}}\n+@staticmethod\n+def from_runner_api_parameter(\n+      unused_ptransform, unused_parameter, unused_context):\n+    return CombinePerKeyTransform()\n+    {{< /highlight >}}\n+\n+**Using the expansion service**\n+\n+Python has a default expansion service included and available in the Apache Beam SDK. You are free to write your own expansion service, but that is generally not needed, so it is not covered in this section.\n+\n+Perform the following steps to start up the default Python expansion service directly:\n+\n+1. Create a virtual environment and [install the Apache Beam SDK](https://beam.apache.org/get-started/quickstart-py/).\n+2. Start the Python SDK\u2019s expansion service with a specified port.\n+\n+    {{< highlight >}}\n+$ export PORT_FOR_EXPANSION_SERVICE=12345\n+$ python -m apache_beam.runners.portability.expansion_service -p $PORT_FOR_EXPANSION_SERVICE\n+    {{< /highlight >}}\n+\n+**Including dependencies**\n+\n+If your transform requires external libraries, make sure those dependencies are already specified in a custom container for SDK harness. Core Apache Beam dependencies are already included.\n+\n+### 13.2. Using cross-language transforms {#use-x-lang-transforms}\n+\n+Depending on the SDK language of the pipeline, you can use a high-level SDK-wrapper class, or a low-level transform class to access a cross-language transform.\n+\n+#### 13.2.1. Using cross-language transforms in a Java pipeline\n+\n+Currently, to access cross-language transforms from the Java SDK, you have to use the lower-level [External](https://github.com/apache/beam/blob/master/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/External.java) class.\n+\n+**Using the External class**\n+\n+1. Make sure you have any runtime environment dependencies (like JRE) installed on your local machine (either directly on the local machine or available through a container). See the expansion service section for more details.\n+\n+    > **Note:** When including Python transforms from within a Java pipeline, all python dependencies have to be baked into the SDK harness container.", "originalCommit": "f2fb2a1604c620a1a3d753400fe0f3444c5ec821", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzMwMjI1NA==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523302254", "bodyText": "Done.", "author": "davidwrede", "createdAt": "2020-11-14T00:43:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI5Mzk5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI5NDI2Ng==", "url": "https://github.com/apache/beam/pull/13317#discussion_r523294266", "bodyText": "self.expansion_service?", "author": "robertwb", "createdAt": "2020-11-14T00:04:49Z", "path": "website/www/site/content/en/documentation/programming-guide.md", "diffHunk": "@@ -5431,4 +5431,280 @@ use case.\n \n {{< highlight py >}}\n {{< code_sample \"sdks/python/apache_beam/examples/snippets/snippets.py\" BundleFinalize >}}\n-{{< /highlight >}}\n\\ No newline at end of file\n+{{< /highlight >}}\n+\n+## 13. Multi-language pipelines {#mulit-language-pipelines}\n+\n+Beam allows you to combine transforms written in any supported SDK language (currently, Java and Python) and use them in one multi-language pipeline. This capability makes it easy to provide new functionality simultaneously in different Apache Beam SDKs through a single cross-language transform. For example, the [Apache Kafka connector](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/io/kafka.py) and [SQL transform](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/sql.py) from the Java SDK can be used in Python streaming pipelines.\n+\n+Pipelines that use transforms from more than one SDK-language are known as *multi-language pipelines*.\n+\n+### 13.1. Creating cross-language transforms {#create-x-lang-transforms}\n+\n+To make transforms written in one language available to pipelines written in another language, an *expansion service* for that transform is used to create and inject the appropriate language-specific pipeline fragments into your pipeline.\n+\n+In the following example, a Python pipeline written the Apache Beam SDK for Python starts up a local Java expansion service on your computer to create and inject the appropriate Java pipeline fragments for executing the Java Kafka cross-language transform into your Python pipeline. The SDK then downloads and stages the necessary Java dependencies needed to execute these transforms.\n+\n+![Diagram of multi-language pipeline execution flow.](/images/multi-language-pipelines-diagram.svg)\n+\n+At runtime, the Beam runner will execute both Python and Java transforms to execute your pipeline.\n+\n+In this section, we will use [KafkaIO.Read](https://beam.apache.org/releases/javadoc/current/org/apache/beam/sdk/io/kafka/KafkaIO.Read.html) to illustrate how to create a cross-language transform for Java and a test example for Python.\n+\n+#### 13.1.1. Creating cross-language Java transforms\n+\n+To make your Apache Beam Java SDK transform portable across SDK languages, you must implement two interfaces: [ExternalTransformBuilder](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/ExternalTransformBuilder.java) and [ExternalTransformRegistrar](https://github.com/apache/beam/blob/master/sdks/java/core/src/main/java/org/apache/beam/sdk/expansion/ExternalTransformRegistrar.java). The `ExternalTransformBuilder` interface constructs the cross-language transform using configuration values passed in from the pipeline and the `ExternalTransformRegistrar` interface registers the cross-language transform for use with the expansion service.\n+\n+**Implementing the interfaces**\n+\n+1. Define a Builder class for your transform that implements the `ExternalTransformBuilder` interface and overrides the `buildExternal` method that will be used to build your transform object. Initial configuration values for your transform should be defined in the `buildExternal` method. In most cases, it is convenient to make the Java transform builder class implement `ExternalTransformBuilder`.\n+\n+    > **Note:** `ExternalTransformBuilder` requires you to define a configuration object (a simple POJO) to capture a set of parameters sent by external SDKs to initiate the Java transform. Usually these parameters directly map to constructor parameters of the Java transform.\n+\n+    {{< highlight >}}\n+@AutoValue.Builder\n+abstract static class Builder<K, V>\n+  implements ExternalTransformBuilder<External.Configuration, PBegin, PCollection<KV<K, V>>> {\n+  abstract Builder<K, V> setConsumerConfig(Map<String, Object> config);\n+\n+  abstract Builder<K, V> setTopics(List<String> topics);\n+\n+  /** Remaining property declarations omitted for clarity. */\n+\n+  abstract Read<K, V> build();\n+\n+  @Override\n+  public PTransform<PBegin, PCollection<KV<K, V>>> buildExternal(\n+      External.Configuration config) {\n+    ImmutableList.Builder<String> listBuilder = ImmutableList.builder();\n+    for (String topic : config.topics) {\n+      listBuilder.add(topic);\n+    }\n+    setTopics(listBuilder.build());\n+\n+    /** Remaining property defaults omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+2. Register the transform as an external cross-language transform by defining a class that implements `ExternalTransformRegistrar`. You must annotate your class with the `AutoService` annotation to ensure that your transform is registered and instantiated properly by the expansion service.\n+3. In your registrar class, define a Uniform Resource Name (URN) for your transform. The URN must be a unique string that identifies your transform with the expansion service.\n+4. From within your registrar class, define a configuration class for the parameters used during the initialization of your transform by the external SDK.\n+\n+    The following example from the KafkaIO transform shows how to implement steps two through four:\n+\n+    {{< highlight >}}\n+@AutoService(ExternalTransformRegistrar.class)\n+public static class External implements ExternalTransformRegistrar {\n+\n+  public static final String URN = \"beam:external:java:kafka:read:v1\";\n+\n+  @Override\n+  public Map<String, Class<? extends ExternalTransformBuilder<?, ?, ?>>> knownBuilders() {\n+    return ImmutableMap.of(\n+        URN,\n+        (Class<? extends ExternalTransformBuilder<?, ?, ?>>)\n+            (Class<?>) AutoValue_KafkaIO_Read.Builder.class);\n+  }\n+\n+  /** Parameters class to expose the Read transform to an external SDK. */\n+  public static class Configuration {\n+    private Map<String, String> consumerConfig;\n+      private List<String> topics;\n+\n+\n+      public void setConsumerConfig(Map<String, String> consumerConfig) {\n+        this.consumerConfig = consumerConfig;\n+      }\n+\n+      public void setTopics(List<String> topics) {\n+        this.topics = topics;\n+      }\n+\n+    /** Remaining properties omitted for clarity. */\n+  }\n+}\n+    {{< /highlight >}}\n+\n+After you have implemented the `ExternalTransformBuilder` and `ExternalTransformRegistrar` interfaces, your transform can be registered and created successfully by the default Java expansion service.\n+\n+**Using the expansion service**\n+\n+Java has a default expansion service included and available in the Apache Beam Java SDK. You can write your own expansion service, but that is generally not needed, so it is not covered in this section.\n+\n+Perform the following steps to start up a Java expansion service directly:\n+\n+{{< highlight >}}\n+// Path to a JAR file that contains the transform to expand, cross-language specific utilities (builder, registrar, etc.), and dependencies.\n+$ export EXPANSION_SERVICE_JAR=<My_expansion_service_JAR>\n+\n+$ export PORT_FOR_EXPANSION_SERVICE=12345\n+\n+$ jar -jar $EXPANSION_SERVICE_JAR $PORT_FOR_EXPANSION_SERVICE\n+{{< /highlight >}}\n+\n+When creating SDK-specific wrappers for your transform, SDKs may provide utilities that are readily available for easily starting up an expansion service. For example, the Python SDK provides the [BeamJarExpansionService](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py) utility for starting up a Java expansion service using a JAR file.\n+\n+**Including dependencies**\n+\n+If your transform requires external libraries, you can include them by adding them to the classpath of the expansion service. After they are included in the classpath, they will be staged when your transform is expanded by the expansion service.\n+\n+**Writing SDK-specific wrappers**\n+\n+Your cross-language Java transform can be called through the lower-level [ExternalTransform](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py) class in a multi-language pipeline (as described in the next section); however, if possible, you should create a SDK-specific wrapper written in the programming language of the pipeline (such as Python) to access the transform instead. This higher-level abstraction will make it easier for pipeline authors to use your transform.\n+\n+To create an SDK wrapper for use in a Python pipeline, do the following:\n+\n+1. Create a Python module for your cross-language transform.\n+2. In the module, build the payload that should be used to initiate the cross-language transform expansion request using one of the available [PayloadBuilder](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py) classes.\n+\n+    The parameter names and types of the payload should map to parameter names and types of the configuration POJO provided to the Java `ExternalTransformBuilder`. Parameter types are mapped across SDKs using a [Beam schema](https://github.com/apache/beam/blob/master/model/pipeline/src/main/proto/schema.proto). Parameter names are mapped by simply converting Python underscore-separated variable names to camel-case (Java standard).\n+\n+    In the following example, [kafka.py](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/io/kafka.py) uses `NamedTupleBasedPayloadBuilder` to build the payload. The parameters map to the Java [KafkaIO.External.Configuration](https://github.com/apache/beam/blob/master/sdks/java/io/kafka/src/main/java/org/apache/beam/sdk/io/kafka/KafkaIO.java) config object defined previously in the **Implementing the interfaces** section.\n+\n+    {{< highlight >}}\n+class ReadFromKafkaSchema(typing.NamedTuple):\n+      consumer_config: typing.Mapping[str, str]\n+      topics: typing.List[str]\n+      # Other properties omitted for clarity.\n+\n+payload = NamedTupleBasedPayloadBuilder(ReadFromKafkaSchema(...))\n+    {{< /highlight >}}\n+3. Start an expansion service unless one is specified by the pipeline creator. The Apache Beam Python SDK provides a utility, `BeamJarExpansionService`, for easily starting an expansion service based on a JAR released with Beam. To use this, do the following:\n+\n+    1. Add a Gradle target to Beam that can be used to build a shaded expansion service JAR for the target Java transform. This target should produce a Beam JAR that contains all dependencies needed for expanding the Java transform and the JAR should be released with Beam.\n+    2. In your Python module, instantiate `BeamJarExpansionService` with the Gradle target.\n+\n+        {{< highlight >}}\n+    expansion_service = BeamJarExpansionService('sdks:java:io:expansion-service:shadowJar')\n+        {{< /highlight >}}\n+4. Add a Python wrapper transform class that extends [ExternalTransform](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py). Pass the payload and expansion service defined above as parameters to the constructor of the `ExternalTransform` parent class.\n+\n+#### 13.1.2. Creating cross-language Python transforms\n+\n+To make your Python transform usable with different SDK languages, you must create a Python module that registers an existing Python transform as a cross-language transform for use with the Python expansion service and calls into that existing transform to perform its intended operation.\n+\n+**Defining the Python module**\n+\n+1. Define a Uniform Resource Name (URN) for your transform. The URN must be a unique string that identifies your transform with the expansion service.\n+\n+    {{< highlight >}}\n+TEST_COMPK_URN = \"beam:transforms:xlang:test:compk\"\n+    {{< /highlight >}}\n+2. For an existing Python transform, create a new class to register the URN with the Python expansion service.\n+\n+    {{< highlight >}}\n+@ptransform.PTransform.register_urn(TEST_COMPK_URN, None)\n+class CombinePerKeyTransform(ptransform.PTransform):\n+    {{< /highlight >}}\n+3. From within the class, define an expand method that takes an input PCollection, runs the Python transform, and then returns the output PCollection.\n+\n+    {{< highlight >}}\n+def expand(self, pcoll):\n+    return pcoll \\\n+        | beam.CombinePerKey(sum).with_output_types(\n+              typing.Tuple[unicode, int])\n+    {{< /highlight >}}\n+4. As with other Python transforms, define a `to_runner_api_parameter` method that returns the URN.\n+\n+    {{< highlight >}}\n+def to_runner_api_parameter(self, unused_context):\n+    return TEST_COMPK_URN, None\n+    {{< /highlight >}}\n+5. Define a static `from_runner_api_parameter` method that returns an instantiation of the cross-language Python transform.\n+\n+    {{< highlight >}}\n+@staticmethod\n+def from_runner_api_parameter(\n+      unused_ptransform, unused_parameter, unused_context):\n+    return CombinePerKeyTransform()\n+    {{< /highlight >}}\n+\n+**Using the expansion service**\n+\n+Python has a default expansion service included and available in the Apache Beam SDK. You are free to write your own expansion service, but that is generally not needed, so it is not covered in this section.\n+\n+Perform the following steps to start up the default Python expansion service directly:\n+\n+1. Create a virtual environment and [install the Apache Beam SDK](https://beam.apache.org/get-started/quickstart-py/).\n+2. Start the Python SDK\u2019s expansion service with a specified port.\n+\n+    {{< highlight >}}\n+$ export PORT_FOR_EXPANSION_SERVICE=12345\n+$ python -m apache_beam.runners.portability.expansion_service -p $PORT_FOR_EXPANSION_SERVICE\n+    {{< /highlight >}}\n+\n+**Including dependencies**\n+\n+If your transform requires external libraries, make sure those dependencies are already specified in a custom container for SDK harness. Core Apache Beam dependencies are already included.\n+\n+### 13.2. Using cross-language transforms {#use-x-lang-transforms}\n+\n+Depending on the SDK language of the pipeline, you can use a high-level SDK-wrapper class, or a low-level transform class to access a cross-language transform.\n+\n+#### 13.2.1. Using cross-language transforms in a Java pipeline\n+\n+Currently, to access cross-language transforms from the Java SDK, you have to use the lower-level [External](https://github.com/apache/beam/blob/master/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/External.java) class.\n+\n+**Using the External class**\n+\n+1. Make sure you have any runtime environment dependencies (like JRE) installed on your local machine (either directly on the local machine or available through a container). See the expansion service section for more details.\n+\n+    > **Note:** When including Python transforms from within a Java pipeline, all python dependencies have to be baked into the SDK harness container.\n+2. Start up the expansion service for the SDK that is in the language of the transform you're trying to consume, if not available.\n+\n+    Make sure the transform you are trying to use is available and can be used by the expansion service.\n+3. Include [External.of(...)](https://github.com/apache/beam/blob/master/runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/External.java) when instantiating your pipeline. Reference the URN, payload, and expansion service. For examples, see the [cross-language transform test suite](https://github.com/apache/beam/blob/master/runners/core-construction-java/src/test/java/org/apache/beam/runners/core/construction/ValidateRunnerXlangTest.java).\n+4. After the job has been submitted to the Beam runner, shutdown the expansion service by terminating the expansion service process.\n+\n+#### 13.2.2 Using cross-language transforms in a Python pipeline\n+\n+If a Python-specific wrapper for a cross-language transform is available, use that; otherwise, you have to use the lower-level [ExternalTransform](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py) class to access the transform.\n+\n+**Using an SDK wrapper**\n+\n+To use a cross-language transform through an SDK wrapper, import the module for the SDK wrapper and call it from your pipeline as shown in the example:\n+\n+  {{< highlight >}}\n+from apache_beam.io.kafka import ReadFromKafka\n+\n+kafka_records = (\n+        pipeline\n+        | 'ReadFromKafka' >> ReadFromKafka(\n+            consumer_config={\n+                'bootstrap.servers': self.bootstrap_servers,\n+                'auto.offset.reset': 'earliest'\n+            },\n+            topics=[self.topic],\n+            max_num_records=max_num_records,\n+            expansion_service=self.expansion_service))\n+  {{< /highlight >}}\n+\n+**Using the ExternalTransform class**\n+\n+When an SDK-specific wrapper isn't available, you will have to access the cross-language transform through the `ExternalTransform` class.\n+\n+1. Make sure you have any runtime environment dependencies (like JRE) installed on your local machine. See the expansion service section for more details.\n+2. Start up the expansion service for the SDK that is in the language of the transform you're trying to consume, if not available.\n+\n+    Make sure the transform you're trying to use is available and can be used by the expansion service. For Java, make sure the builder and registrar for the transform are available in the classpath of the expansion service.\n+3. Include `ExternalTransform` when instantiating your pipeline. Reference the URN, Payload, and expansion service. You can use one of the available [PayloadBuilder](https://github.com/apache/beam/blob/master/sdks/python/apache_beam/transforms/external.py) classes to build the payload for `ExternalTransform`.\n+\n+    {{< highlight >}}\n+with pipeline as p:\n+    res = (\n+        p\n+        | beam.Create(['a', 'b']).with_output_types(unicode)\n+        | beam.ExternalTransform(\n+            TEST_PREFIX_URN,\n+            ImplicitSchemaPayloadBuilder({'data': u'0'}),\n+            self.expansion_service))", "originalCommit": "f2fb2a1604c620a1a3d753400fe0f3444c5ec821", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3Mjk4Ng==", "url": "https://github.com/apache/beam/pull/13317#discussion_r525572986", "bodyText": "Updated.", "author": "chamikaramj", "createdAt": "2020-11-17T22:40:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI5NDI2Ng=="}], "type": "inlineReview"}, {"oid": "229ccbbf47d3009e428a60ef9e50007622847f4d", "url": "https://github.com/apache/beam/commit/229ccbbf47d3009e428a60ef9e50007622847f4d", "message": "New documentation on multi-language pipelines", "committedDate": "2020-11-20T00:00:53Z", "type": "commit"}, {"oid": "6c6c161aa722d84851c110ed8caea30478d758b4", "url": "https://github.com/apache/beam/commit/6c6c161aa722d84851c110ed8caea30478d758b4", "message": "Incorporated TR feedback", "committedDate": "2020-11-20T00:01:00Z", "type": "commit"}, {"oid": "dafa9e6277c87ea142cdd1bc9313fd49d63a61d6", "url": "https://github.com/apache/beam/commit/dafa9e6277c87ea142cdd1bc9313fd49d63a61d6", "message": "Fixed whitespace lint test failure", "committedDate": "2020-11-20T00:01:00Z", "type": "commit"}, {"oid": "761de8369a9da5ba8c144c19d0d9c1723c137bb1", "url": "https://github.com/apache/beam/commit/761de8369a9da5ba8c144c19d0d9c1723c137bb1", "message": "Add license info to SVG", "committedDate": "2020-11-20T00:01:00Z", "type": "commit"}, {"oid": "8c926fa91a6196b7e32159d95edcb7b6e111bb85", "url": "https://github.com/apache/beam/commit/8c926fa91a6196b7e32159d95edcb7b6e111bb85", "message": "Addressed some of the new feedback", "committedDate": "2020-11-20T00:01:00Z", "type": "commit"}, {"oid": "a208491ff4f9ea36d8b50d2f0077035a5b578f9c", "url": "https://github.com/apache/beam/commit/a208491ff4f9ea36d8b50d2f0077035a5b578f9c", "message": "Addresses reviewer comments", "committedDate": "2020-11-20T00:01:00Z", "type": "commit"}, {"oid": "a208491ff4f9ea36d8b50d2f0077035a5b578f9c", "url": "https://github.com/apache/beam/commit/a208491ff4f9ea36d8b50d2f0077035a5b578f9c", "message": "Addresses reviewer comments", "committedDate": "2020-11-20T00:01:00Z", "type": "forcePushed"}]}