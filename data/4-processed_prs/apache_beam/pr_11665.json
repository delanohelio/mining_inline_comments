{"pr_number": 11665, "pr_title": "[BEAM-9951] Creating a synthetic source for the Go SDK.", "pr_createdAt": "2020-05-11T18:48:56Z", "pr_url": "https://github.com/apache/beam/pull/11665", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2OTM3NA==", "url": "https://github.com/apache/beam/pull/11665#discussion_r424069374", "bodyText": "Oh wow. I feel bad for missing this on my initial review. Good catch!", "author": "lostluck", "createdAt": "2020-05-12T22:26:44Z", "path": "sdks/go/examples/stringsplit/stringsplit.go", "diffHunk": "@@ -112,15 +112,15 @@ func (fn *StringSplitFn) CreateTracker(rest offsetrange.Restriction) *offsetrang\n //\n // Example: If BufSize is 100, then a restriction of 75 to 325 should emit the\n // following substrings: [100, 200], [200, 300], [300, 400]\n-func (fn *StringSplitFn) ProcessElement(rt *offsetrange.Tracker, elem string, emit func(string)) {\n-\tlog.Debugf(context.Background(), \"StringSplit ProcessElement: Tracker = %v\", rt)\n+func (fn *StringSplitFn) ProcessElement(ctx context.Context, rt *offsetrange.Tracker, elem string, emit func(string)) {\n+\tlog.Debugf(ctx, \"StringSplit ProcessElement: Tracker = %v\", rt)\n \ti := rt.Rest.Start\n \tif rem := i % fn.BufSize; rem != 0 {\n \t\ti += fn.BufSize - rem // Skip to next multiple of BufSize.\n \t}\n \tstrEnd := int64(len(elem))\n \n-\tfor ok := rt.TryClaim(i); ok == true; ok = rt.TryClaim(i) {\n+\tfor rt.TryClaim(i) == true {", "originalCommit": "318a0979fe1b2583f6586f62c3c45dfb78d4dd25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEyMzE4OQ==", "url": "https://github.com/apache/beam/pull/11665#discussion_r424123189", "bodyText": "No worries. I can't exactly judge, seeing as I'm the one who wrote the code.", "author": "youngoli", "createdAt": "2020-05-13T01:30:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2OTM3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc5ODcxOA==", "url": "https://github.com/apache/beam/pull/11665#discussion_r424798718", "bodyText": "It takes two. :P", "author": "lostluck", "createdAt": "2020-05-14T00:05:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2OTM3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2OTk0NA==", "url": "https://github.com/apache/beam/pull/11665#discussion_r424069944", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            // tests are not concerned with the correctness of the elements themselves, but\n          \n          \n            \n            // tests is not concerned with the correctness of the elements themselves, but\n          \n      \n    \n    \n  \n\nNit: The subject of the sentences is \"the category of tests\" not \"tests\" so the singular \"is\"  is appropriate.", "author": "lostluck", "createdAt": "2020-05-12T22:28:10Z", "path": "sdks/go/pkg/beam/io/synthetic/source.go", "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package synthetic contains transforms for creating synthetic pipelines.\n+// Synthetic pipelines are pipelines that simulate the behavior of possible\n+// pipelines in order to test performance, splitting, liquid sharding, and\n+// various other infrastructure used for running pipelines. This category of\n+// tests are not concerned with the correctness of the elements themselves, but", "originalCommit": "318a0979fe1b2583f6586f62c3c45dfb78d4dd25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEyMzQyMQ==", "url": "https://github.com/apache/beam/pull/11665#discussion_r424123421", "bodyText": "Done.", "author": "youngoli", "createdAt": "2020-05-13T01:31:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA2OTk0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3MTY0MQ==", "url": "https://github.com/apache/beam/pull/11665#discussion_r424071641", "bodyText": "Here and below, this should be sourceFn.", "author": "lostluck", "createdAt": "2020-05-12T22:32:57Z", "path": "sdks/go/pkg/beam/io/synthetic/source.go", "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package synthetic contains transforms for creating synthetic pipelines.\n+// Synthetic pipelines are pipelines that simulate the behavior of possible\n+// pipelines in order to test performance, splitting, liquid sharding, and\n+// various other infrastructure used for running pipelines. This category of\n+// tests are not concerned with the correctness of the elements themselves, but\n+// need to simulate transforms that output many elements throughout varying\n+// pipeline shapes.\n+package synthetic\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/io/rtrackers/offsetrange\"\n+\t\"math/rand\"\n+\t\"time\"\n+)\n+\n+// Source creates a synthetic source transform that emits randomly\n+// generated KV<[]byte, []byte> elements.\n+//\n+// This transform accepts a PCollection of SourceConfig, where each SourceConfig\n+// determines the synthetic source's behavior for that element.\n+//\n+// This transform outputs a PCollection of randomly generated\n+// KV<byte[], byte[]> elements.\n+func Source(s beam.Scope, col beam.PCollection) beam.PCollection {\n+\ts = s.Scope(\"synthetic.Source\")\n+\n+\treturn beam.ParDo(s, sourceFn{}, col)\n+}\n+\n+// syntheticSourceFn is a splittable DoFn implementing behavior for synthetic", "originalCommit": "318a0979fe1b2583f6586f62c3c45dfb78d4dd25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEzMTI4NA==", "url": "https://github.com/apache/beam/pull/11665#discussion_r424131284", "bodyText": "Done. I did a lot of renaming here.", "author": "youngoli", "createdAt": "2020-05-13T02:01:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3MTY0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3MjczNA==", "url": "https://github.com/apache/beam/pull/11665#discussion_r424072734", "bodyText": "I guess this should be Source()", "author": "lostluck", "createdAt": "2020-05-12T22:35:58Z", "path": "sdks/go/pkg/beam/io/synthetic/source.go", "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package synthetic contains transforms for creating synthetic pipelines.\n+// Synthetic pipelines are pipelines that simulate the behavior of possible\n+// pipelines in order to test performance, splitting, liquid sharding, and\n+// various other infrastructure used for running pipelines. This category of\n+// tests are not concerned with the correctness of the elements themselves, but\n+// need to simulate transforms that output many elements throughout varying\n+// pipeline shapes.\n+package synthetic\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/io/rtrackers/offsetrange\"\n+\t\"math/rand\"\n+\t\"time\"\n+)\n+\n+// Source creates a synthetic source transform that emits randomly\n+// generated KV<[]byte, []byte> elements.\n+//\n+// This transform accepts a PCollection of SourceConfig, where each SourceConfig\n+// determines the synthetic source's behavior for that element.\n+//\n+// This transform outputs a PCollection of randomly generated\n+// KV<byte[], byte[]> elements.\n+func Source(s beam.Scope, col beam.PCollection) beam.PCollection {\n+\ts = s.Scope(\"synthetic.Source\")\n+\n+\treturn beam.ParDo(s, sourceFn{}, col)\n+}\n+\n+// syntheticSourceFn is a splittable DoFn implementing behavior for synthetic\n+// sources. For usage information, see `SyntheticSource`.", "originalCommit": "318a0979fe1b2583f6586f62c3c45dfb78d4dd25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEzMTI5OA==", "url": "https://github.com/apache/beam/pull/11665#discussion_r424131298", "bodyText": "Yep, done.", "author": "youngoli", "createdAt": "2020-05-13T02:01:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3MjczNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3NDY2NQ==", "url": "https://github.com/apache/beam/pull/11665#discussion_r424074665", "bodyText": "&sourceFn{}\nIt's important to run the code too :)", "author": "lostluck", "createdAt": "2020-05-12T22:41:25Z", "path": "sdks/go/pkg/beam/io/synthetic/source.go", "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package synthetic contains transforms for creating synthetic pipelines.\n+// Synthetic pipelines are pipelines that simulate the behavior of possible\n+// pipelines in order to test performance, splitting, liquid sharding, and\n+// various other infrastructure used for running pipelines. This category of\n+// tests are not concerned with the correctness of the elements themselves, but\n+// need to simulate transforms that output many elements throughout varying\n+// pipeline shapes.\n+package synthetic\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/io/rtrackers/offsetrange\"\n+\t\"math/rand\"\n+\t\"time\"\n+)\n+\n+// Source creates a synthetic source transform that emits randomly\n+// generated KV<[]byte, []byte> elements.\n+//\n+// This transform accepts a PCollection of SourceConfig, where each SourceConfig\n+// determines the synthetic source's behavior for that element.\n+//\n+// This transform outputs a PCollection of randomly generated\n+// KV<byte[], byte[]> elements.\n+func Source(s beam.Scope, col beam.PCollection) beam.PCollection {\n+\ts = s.Scope(\"synthetic.Source\")\n+\n+\treturn beam.ParDo(s, sourceFn{}, col)", "originalCommit": "318a0979fe1b2583f6586f62c3c45dfb78d4dd25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEzMTA4Ng==", "url": "https://github.com/apache/beam/pull/11665#discussion_r424131086", "bodyText": "Darn, the one untested method. Done.", "author": "youngoli", "createdAt": "2020-05-13T02:01:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3NDY2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3NTk5Mg==", "url": "https://github.com/apache/beam/pull/11665#discussion_r424075992", "bodyText": "WRT the builder question, forexample, here's where one could have a variadic ...Options parameter if most options are largely independant. Alternatively, having a synthetic.Options{} struct which has the various configurations is also appropriate.\nA options struct is simple, but if the default values can be mistaken for something the user wants, or worse, they aren't naturally useful, this can hurt things.", "author": "lostluck", "createdAt": "2020-05-12T22:45:09Z", "path": "sdks/go/pkg/beam/io/synthetic/source.go", "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package synthetic contains transforms for creating synthetic pipelines.\n+// Synthetic pipelines are pipelines that simulate the behavior of possible\n+// pipelines in order to test performance, splitting, liquid sharding, and\n+// various other infrastructure used for running pipelines. This category of\n+// tests are not concerned with the correctness of the elements themselves, but\n+// need to simulate transforms that output many elements throughout varying\n+// pipeline shapes.\n+package synthetic\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/io/rtrackers/offsetrange\"\n+\t\"math/rand\"\n+\t\"time\"\n+)\n+\n+// Source creates a synthetic source transform that emits randomly\n+// generated KV<[]byte, []byte> elements.\n+//\n+// This transform accepts a PCollection of SourceConfig, where each SourceConfig\n+// determines the synthetic source's behavior for that element.\n+//\n+// This transform outputs a PCollection of randomly generated\n+// KV<byte[], byte[]> elements.\n+func Source(s beam.Scope, col beam.PCollection) beam.PCollection {", "originalCommit": "318a0979fe1b2583f6586f62c3c45dfb78d4dd25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEzMjY4MA==", "url": "https://github.com/apache/beam/pull/11665#discussion_r424132680", "bodyText": "I'm actually leaning towards the variadic options as I'm writing this. I can just make a NewConfig() method that takes options like that and outputs the default values for fields. See my comment above WRT musing about whether default values are useful here or not.", "author": "youngoli", "createdAt": "2020-05-13T02:07:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3NTk5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3NjY2MA==", "url": "https://github.com/apache/beam/pull/11665#discussion_r424076660", "bodyText": "Consider doing this in a Setup() instead, since new Random Sources are moderately expensive, and could skew the expense per Bundle.", "author": "lostluck", "createdAt": "2020-05-12T22:46:58Z", "path": "sdks/go/pkg/beam/io/synthetic/source.go", "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package synthetic contains transforms for creating synthetic pipelines.\n+// Synthetic pipelines are pipelines that simulate the behavior of possible\n+// pipelines in order to test performance, splitting, liquid sharding, and\n+// various other infrastructure used for running pipelines. This category of\n+// tests are not concerned with the correctness of the elements themselves, but\n+// need to simulate transforms that output many elements throughout varying\n+// pipeline shapes.\n+package synthetic\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/io/rtrackers/offsetrange\"\n+\t\"math/rand\"\n+\t\"time\"\n+)\n+\n+// Source creates a synthetic source transform that emits randomly\n+// generated KV<[]byte, []byte> elements.\n+//\n+// This transform accepts a PCollection of SourceConfig, where each SourceConfig\n+// determines the synthetic source's behavior for that element.\n+//\n+// This transform outputs a PCollection of randomly generated\n+// KV<byte[], byte[]> elements.\n+func Source(s beam.Scope, col beam.PCollection) beam.PCollection {\n+\ts = s.Scope(\"synthetic.Source\")\n+\n+\treturn beam.ParDo(s, sourceFn{}, col)\n+}\n+\n+// syntheticSourceFn is a splittable DoFn implementing behavior for synthetic\n+// sources. For usage information, see `SyntheticSource`.\n+//\n+// The syntheticSourceFn is expected to receive elements of type sourceConfig\n+// and follow that config to determine its behavior when splitting and emitting\n+// elements.\n+type sourceFn struct {\n+\trng *rand.Rand\n+}\n+\n+// CreateInitialRestriction creates an offset range restriction representing\n+// the number of elements to emit.\n+func (fn *sourceFn) CreateInitialRestriction(config SourceConfig) offsetrange.Restriction {\n+\treturn offsetrange.Restriction{\n+\t\tStart: 0,\n+\t\tEnd:   int64(config.NumElements),\n+\t}\n+}\n+\n+// SplitRestriction splits restrictions equally according to the number of\n+// initial splits specified in SourceConfig. Each restriction output by this\n+// method will contain at least one element, so the number of splits will not\n+// exceed the number of elements.\n+func (fn *sourceFn) SplitRestriction(config SourceConfig, rest offsetrange.Restriction) (splits []offsetrange.Restriction) {\n+\tif config.InitialSplits <= 1 {\n+\t\t// Don't split, just return original restriction.\n+\t\tsplits = append(splits, rest)\n+\t\treturn splits\n+\t}\n+\n+\tnum := int64(config.InitialSplits)\n+\toffset := rest.Start\n+\tsize := rest.End - rest.Start\n+\tfor i := int64(0); i < num; i++ {\n+\t\tsplit := offsetrange.Restriction{\n+\t\t\tStart: offset + (i * size / num),\n+\t\t\tEnd:   offset + ((i + 1) * size / num),\n+\t\t}\n+\t\t// Skip restrictions that end up empty.\n+\t\tif split.End-split.Start <= 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tsplits = append(splits, split)\n+\t}\n+\treturn splits\n+}\n+\n+// RestrictionSize outputs the size of the restriction as the number of elements\n+// that restriction will output.\n+func (fn *sourceFn) RestrictionSize(config SourceConfig, rest offsetrange.Restriction) float64 {\n+\treturn float64(rest.End - rest.Start)\n+}\n+\n+// CreateTracker just creates an offset range restriction tracker for the\n+// restriction.\n+func (fn *sourceFn) CreateTracker(rest offsetrange.Restriction) *offsetrange.Tracker {\n+\treturn offsetrange.NewTracker(rest)\n+}\n+\n+// StartBundle sets up the random number generator.\n+func (fn *sourceFn) StartBundle() {\n+\tfn.rng = rand.New(rand.NewSource(time.Now().UnixNano()))", "originalCommit": "318a0979fe1b2583f6586f62c3c45dfb78d4dd25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0MDkwNg==", "url": "https://github.com/apache/beam/pull/11665#discussion_r424140906", "bodyText": "Done.", "author": "youngoli", "createdAt": "2020-05-13T02:39:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3NjY2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3ODUwMg==", "url": "https://github.com/apache/beam/pull/11665#discussion_r424078502", "bodyText": "We may want to consider moving implementations like this onto methods of offsetrange.Restriction\nUsers can always write their own, but making it trivial for users to use the restriction in a few ways probably doesn't hurt, and simplifies testing those implementations.", "author": "lostluck", "createdAt": "2020-05-12T22:52:03Z", "path": "sdks/go/pkg/beam/io/synthetic/source.go", "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package synthetic contains transforms for creating synthetic pipelines.\n+// Synthetic pipelines are pipelines that simulate the behavior of possible\n+// pipelines in order to test performance, splitting, liquid sharding, and\n+// various other infrastructure used for running pipelines. This category of\n+// tests are not concerned with the correctness of the elements themselves, but\n+// need to simulate transforms that output many elements throughout varying\n+// pipeline shapes.\n+package synthetic\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/io/rtrackers/offsetrange\"\n+\t\"math/rand\"\n+\t\"time\"\n+)\n+\n+// Source creates a synthetic source transform that emits randomly\n+// generated KV<[]byte, []byte> elements.\n+//\n+// This transform accepts a PCollection of SourceConfig, where each SourceConfig\n+// determines the synthetic source's behavior for that element.\n+//\n+// This transform outputs a PCollection of randomly generated\n+// KV<byte[], byte[]> elements.\n+func Source(s beam.Scope, col beam.PCollection) beam.PCollection {\n+\ts = s.Scope(\"synthetic.Source\")\n+\n+\treturn beam.ParDo(s, sourceFn{}, col)\n+}\n+\n+// syntheticSourceFn is a splittable DoFn implementing behavior for synthetic\n+// sources. For usage information, see `SyntheticSource`.\n+//\n+// The syntheticSourceFn is expected to receive elements of type sourceConfig\n+// and follow that config to determine its behavior when splitting and emitting\n+// elements.\n+type sourceFn struct {\n+\trng *rand.Rand\n+}\n+\n+// CreateInitialRestriction creates an offset range restriction representing\n+// the number of elements to emit.\n+func (fn *sourceFn) CreateInitialRestriction(config SourceConfig) offsetrange.Restriction {\n+\treturn offsetrange.Restriction{\n+\t\tStart: 0,\n+\t\tEnd:   int64(config.NumElements),\n+\t}\n+}\n+\n+// SplitRestriction splits restrictions equally according to the number of\n+// initial splits specified in SourceConfig. Each restriction output by this\n+// method will contain at least one element, so the number of splits will not\n+// exceed the number of elements.\n+func (fn *sourceFn) SplitRestriction(config SourceConfig, rest offsetrange.Restriction) (splits []offsetrange.Restriction) {\n+\tif config.InitialSplits <= 1 {\n+\t\t// Don't split, just return original restriction.\n+\t\tsplits = append(splits, rest)\n+\t\treturn splits\n+\t}\n+\n+\tnum := int64(config.InitialSplits)", "originalCommit": "318a0979fe1b2583f6586f62c3c45dfb78d4dd25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEzMzQ1OQ==", "url": "https://github.com/apache/beam/pull/11665#discussion_r424133459", "bodyText": "Good point, I should've thought of that. I don't really wanna do that in this PR though because I want to write some tests for the method as well, which has just made me realize that the offsetrange package as a whole probably needs tests. So I'll just leave a TODO for that and make a new PR for it.", "author": "youngoli", "createdAt": "2020-05-13T02:10:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3ODUwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgwMDIyNA==", "url": "https://github.com/apache/beam/pull/11665#discussion_r424800224", "bodyText": "+1 for a TODO for this PR. Thanks!", "author": "lostluck", "createdAt": "2020-05-14T00:10:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3ODUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3ODk3OQ==", "url": "https://github.com/apache/beam/pull/11665#discussion_r424078979", "bodyText": "Same comment here about methods. Not necessary todo in this PR.", "author": "lostluck", "createdAt": "2020-05-12T22:53:22Z", "path": "sdks/go/pkg/beam/io/synthetic/source.go", "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package synthetic contains transforms for creating synthetic pipelines.\n+// Synthetic pipelines are pipelines that simulate the behavior of possible\n+// pipelines in order to test performance, splitting, liquid sharding, and\n+// various other infrastructure used for running pipelines. This category of\n+// tests are not concerned with the correctness of the elements themselves, but\n+// need to simulate transforms that output many elements throughout varying\n+// pipeline shapes.\n+package synthetic\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/io/rtrackers/offsetrange\"\n+\t\"math/rand\"\n+\t\"time\"\n+)\n+\n+// Source creates a synthetic source transform that emits randomly\n+// generated KV<[]byte, []byte> elements.\n+//\n+// This transform accepts a PCollection of SourceConfig, where each SourceConfig\n+// determines the synthetic source's behavior for that element.\n+//\n+// This transform outputs a PCollection of randomly generated\n+// KV<byte[], byte[]> elements.\n+func Source(s beam.Scope, col beam.PCollection) beam.PCollection {\n+\ts = s.Scope(\"synthetic.Source\")\n+\n+\treturn beam.ParDo(s, sourceFn{}, col)\n+}\n+\n+// syntheticSourceFn is a splittable DoFn implementing behavior for synthetic\n+// sources. For usage information, see `SyntheticSource`.\n+//\n+// The syntheticSourceFn is expected to receive elements of type sourceConfig\n+// and follow that config to determine its behavior when splitting and emitting\n+// elements.\n+type sourceFn struct {\n+\trng *rand.Rand\n+}\n+\n+// CreateInitialRestriction creates an offset range restriction representing\n+// the number of elements to emit.\n+func (fn *sourceFn) CreateInitialRestriction(config SourceConfig) offsetrange.Restriction {\n+\treturn offsetrange.Restriction{\n+\t\tStart: 0,\n+\t\tEnd:   int64(config.NumElements),\n+\t}\n+}\n+\n+// SplitRestriction splits restrictions equally according to the number of\n+// initial splits specified in SourceConfig. Each restriction output by this\n+// method will contain at least one element, so the number of splits will not\n+// exceed the number of elements.\n+func (fn *sourceFn) SplitRestriction(config SourceConfig, rest offsetrange.Restriction) (splits []offsetrange.Restriction) {\n+\tif config.InitialSplits <= 1 {\n+\t\t// Don't split, just return original restriction.\n+\t\tsplits = append(splits, rest)\n+\t\treturn splits\n+\t}\n+\n+\tnum := int64(config.InitialSplits)\n+\toffset := rest.Start\n+\tsize := rest.End - rest.Start\n+\tfor i := int64(0); i < num; i++ {\n+\t\tsplit := offsetrange.Restriction{\n+\t\t\tStart: offset + (i * size / num),\n+\t\t\tEnd:   offset + ((i + 1) * size / num),\n+\t\t}\n+\t\t// Skip restrictions that end up empty.\n+\t\tif split.End-split.Start <= 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tsplits = append(splits, split)\n+\t}\n+\treturn splits\n+}\n+\n+// RestrictionSize outputs the size of the restriction as the number of elements\n+// that restriction will output.\n+func (fn *sourceFn) RestrictionSize(config SourceConfig, rest offsetrange.Restriction) float64 {\n+\treturn float64(rest.End - rest.Start)", "originalCommit": "318a0979fe1b2583f6586f62c3c45dfb78d4dd25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEzOTg5NA==", "url": "https://github.com/apache/beam/pull/11665#discussion_r424139894", "bodyText": "Ack. Added a TODO.", "author": "youngoli", "createdAt": "2020-05-13T02:35:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3ODk3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3OTkwOQ==", "url": "https://github.com/apache/beam/pull/11665#discussion_r424079909", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            // form of KV<[]byte, []byte>,\n          \n          \n            \n            // form of KV<[]byte, []byte>.", "author": "lostluck", "createdAt": "2020-05-12T22:56:12Z", "path": "sdks/go/pkg/beam/io/synthetic/source.go", "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package synthetic contains transforms for creating synthetic pipelines.\n+// Synthetic pipelines are pipelines that simulate the behavior of possible\n+// pipelines in order to test performance, splitting, liquid sharding, and\n+// various other infrastructure used for running pipelines. This category of\n+// tests are not concerned with the correctness of the elements themselves, but\n+// need to simulate transforms that output many elements throughout varying\n+// pipeline shapes.\n+package synthetic\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/io/rtrackers/offsetrange\"\n+\t\"math/rand\"\n+\t\"time\"\n+)\n+\n+// Source creates a synthetic source transform that emits randomly\n+// generated KV<[]byte, []byte> elements.\n+//\n+// This transform accepts a PCollection of SourceConfig, where each SourceConfig\n+// determines the synthetic source's behavior for that element.\n+//\n+// This transform outputs a PCollection of randomly generated\n+// KV<byte[], byte[]> elements.\n+func Source(s beam.Scope, col beam.PCollection) beam.PCollection {\n+\ts = s.Scope(\"synthetic.Source\")\n+\n+\treturn beam.ParDo(s, sourceFn{}, col)\n+}\n+\n+// syntheticSourceFn is a splittable DoFn implementing behavior for synthetic\n+// sources. For usage information, see `SyntheticSource`.\n+//\n+// The syntheticSourceFn is expected to receive elements of type sourceConfig\n+// and follow that config to determine its behavior when splitting and emitting\n+// elements.\n+type sourceFn struct {\n+\trng *rand.Rand\n+}\n+\n+// CreateInitialRestriction creates an offset range restriction representing\n+// the number of elements to emit.\n+func (fn *sourceFn) CreateInitialRestriction(config SourceConfig) offsetrange.Restriction {\n+\treturn offsetrange.Restriction{\n+\t\tStart: 0,\n+\t\tEnd:   int64(config.NumElements),\n+\t}\n+}\n+\n+// SplitRestriction splits restrictions equally according to the number of\n+// initial splits specified in SourceConfig. Each restriction output by this\n+// method will contain at least one element, so the number of splits will not\n+// exceed the number of elements.\n+func (fn *sourceFn) SplitRestriction(config SourceConfig, rest offsetrange.Restriction) (splits []offsetrange.Restriction) {\n+\tif config.InitialSplits <= 1 {\n+\t\t// Don't split, just return original restriction.\n+\t\tsplits = append(splits, rest)\n+\t\treturn splits\n+\t}\n+\n+\tnum := int64(config.InitialSplits)\n+\toffset := rest.Start\n+\tsize := rest.End - rest.Start\n+\tfor i := int64(0); i < num; i++ {\n+\t\tsplit := offsetrange.Restriction{\n+\t\t\tStart: offset + (i * size / num),\n+\t\t\tEnd:   offset + ((i + 1) * size / num),\n+\t\t}\n+\t\t// Skip restrictions that end up empty.\n+\t\tif split.End-split.Start <= 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tsplits = append(splits, split)\n+\t}\n+\treturn splits\n+}\n+\n+// RestrictionSize outputs the size of the restriction as the number of elements\n+// that restriction will output.\n+func (fn *sourceFn) RestrictionSize(config SourceConfig, rest offsetrange.Restriction) float64 {\n+\treturn float64(rest.End - rest.Start)\n+}\n+\n+// CreateTracker just creates an offset range restriction tracker for the\n+// restriction.\n+func (fn *sourceFn) CreateTracker(rest offsetrange.Restriction) *offsetrange.Tracker {\n+\treturn offsetrange.NewTracker(rest)\n+}\n+\n+// StartBundle sets up the random number generator.\n+func (fn *sourceFn) StartBundle() {\n+\tfn.rng = rand.New(rand.NewSource(time.Now().UnixNano()))\n+}\n+\n+// ProcessElement creates a number of random elements based on the restriction\n+// tracker received. Each element is a random byte slice key and value, in the\n+// form of KV<[]byte, []byte>,", "originalCommit": "318a0979fe1b2583f6586f62c3c45dfb78d4dd25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0MTIwMA==", "url": "https://github.com/apache/beam/pull/11665#discussion_r424141200", "bodyText": "Done.", "author": "youngoli", "createdAt": "2020-05-13T02:40:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA3OTkwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4MTMwMA==", "url": "https://github.com/apache/beam/pull/11665#discussion_r424081300", "bodyText": "Should this be 1? Is a 0 config valuable?", "author": "lostluck", "createdAt": "2020-05-12T22:59:53Z", "path": "sdks/go/pkg/beam/io/synthetic/source.go", "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package synthetic contains transforms for creating synthetic pipelines.\n+// Synthetic pipelines are pipelines that simulate the behavior of possible\n+// pipelines in order to test performance, splitting, liquid sharding, and\n+// various other infrastructure used for running pipelines. This category of\n+// tests are not concerned with the correctness of the elements themselves, but\n+// need to simulate transforms that output many elements throughout varying\n+// pipeline shapes.\n+package synthetic\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/io/rtrackers/offsetrange\"\n+\t\"math/rand\"\n+\t\"time\"\n+)\n+\n+// Source creates a synthetic source transform that emits randomly\n+// generated KV<[]byte, []byte> elements.\n+//\n+// This transform accepts a PCollection of SourceConfig, where each SourceConfig\n+// determines the synthetic source's behavior for that element.\n+//\n+// This transform outputs a PCollection of randomly generated\n+// KV<byte[], byte[]> elements.\n+func Source(s beam.Scope, col beam.PCollection) beam.PCollection {\n+\ts = s.Scope(\"synthetic.Source\")\n+\n+\treturn beam.ParDo(s, sourceFn{}, col)\n+}\n+\n+// syntheticSourceFn is a splittable DoFn implementing behavior for synthetic\n+// sources. For usage information, see `SyntheticSource`.\n+//\n+// The syntheticSourceFn is expected to receive elements of type sourceConfig\n+// and follow that config to determine its behavior when splitting and emitting\n+// elements.\n+type sourceFn struct {\n+\trng *rand.Rand\n+}\n+\n+// CreateInitialRestriction creates an offset range restriction representing\n+// the number of elements to emit.\n+func (fn *sourceFn) CreateInitialRestriction(config SourceConfig) offsetrange.Restriction {\n+\treturn offsetrange.Restriction{\n+\t\tStart: 0,\n+\t\tEnd:   int64(config.NumElements),\n+\t}\n+}\n+\n+// SplitRestriction splits restrictions equally according to the number of\n+// initial splits specified in SourceConfig. Each restriction output by this\n+// method will contain at least one element, so the number of splits will not\n+// exceed the number of elements.\n+func (fn *sourceFn) SplitRestriction(config SourceConfig, rest offsetrange.Restriction) (splits []offsetrange.Restriction) {\n+\tif config.InitialSplits <= 1 {\n+\t\t// Don't split, just return original restriction.\n+\t\tsplits = append(splits, rest)\n+\t\treturn splits\n+\t}\n+\n+\tnum := int64(config.InitialSplits)\n+\toffset := rest.Start\n+\tsize := rest.End - rest.Start\n+\tfor i := int64(0); i < num; i++ {\n+\t\tsplit := offsetrange.Restriction{\n+\t\t\tStart: offset + (i * size / num),\n+\t\t\tEnd:   offset + ((i + 1) * size / num),\n+\t\t}\n+\t\t// Skip restrictions that end up empty.\n+\t\tif split.End-split.Start <= 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tsplits = append(splits, split)\n+\t}\n+\treturn splits\n+}\n+\n+// RestrictionSize outputs the size of the restriction as the number of elements\n+// that restriction will output.\n+func (fn *sourceFn) RestrictionSize(config SourceConfig, rest offsetrange.Restriction) float64 {\n+\treturn float64(rest.End - rest.Start)\n+}\n+\n+// CreateTracker just creates an offset range restriction tracker for the\n+// restriction.\n+func (fn *sourceFn) CreateTracker(rest offsetrange.Restriction) *offsetrange.Tracker {\n+\treturn offsetrange.NewTracker(rest)\n+}\n+\n+// StartBundle sets up the random number generator.\n+func (fn *sourceFn) StartBundle() {\n+\tfn.rng = rand.New(rand.NewSource(time.Now().UnixNano()))\n+}\n+\n+// ProcessElement creates a number of random elements based on the restriction\n+// tracker received. Each element is a random byte slice key and value, in the\n+// form of KV<[]byte, []byte>,\n+func (fn *sourceFn) ProcessElement(rt *offsetrange.Tracker, config SourceConfig, emit func([]byte, []byte)) error {\n+\tfor i := rt.Rest.Start; rt.TryClaim(i) == true; i++ {\n+\t\tkey := make([]byte, 8)\n+\t\tval := make([]byte, 8)\n+\t\tif _, err := fn.rng.Read(key); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif _, err := fn.rng.Read(val); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\temit(key, val)\n+\t}\n+\treturn nil\n+}\n+\n+// DefaultSourceConfig creates a SourceConfig with intended defaults for its\n+// fields. SourceConfigs should be initialized with this method.\n+func DefaultSourceConfig() SourceConfig {\n+\treturn SourceConfig{\n+\t\tNumElements:   0, // Number of elements for the synthetic source to produce.", "originalCommit": "318a0979fe1b2583f6586f62c3c45dfb78d4dd25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0MjcyNA==", "url": "https://github.com/apache/beam/pull/11665#discussion_r424142724", "bodyText": "Yeah it should probably be 1, done.", "author": "youngoli", "createdAt": "2020-05-13T02:47:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4MTMwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4MzM2MA==", "url": "https://github.com/apache/beam/pull/11665#discussion_r424083360", "bodyText": "The comments on the fields here seem to  be redundant to the ones on the definition struct fields.\nConsider switching them with the whys for those default values.\nThere's an idiom in go to \"make the zero value useful\". In this case the zero value is SourceConfig{}. WRT the implementation, this is identical to what's being provided by the DefaultSourceConfig() method since InitialSplits is \"default 1\" anyway.\nI do like the declaration that DefaultSourceConfig() is recommended for how to configure initially since it'll set th defaults, especially when new fields are being added, so behavior doesn't unnecessarily change when the new feature is added.", "author": "lostluck", "createdAt": "2020-05-12T23:06:01Z", "path": "sdks/go/pkg/beam/io/synthetic/source.go", "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package synthetic contains transforms for creating synthetic pipelines.\n+// Synthetic pipelines are pipelines that simulate the behavior of possible\n+// pipelines in order to test performance, splitting, liquid sharding, and\n+// various other infrastructure used for running pipelines. This category of\n+// tests are not concerned with the correctness of the elements themselves, but\n+// need to simulate transforms that output many elements throughout varying\n+// pipeline shapes.\n+package synthetic\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/io/rtrackers/offsetrange\"\n+\t\"math/rand\"\n+\t\"time\"\n+)\n+\n+// Source creates a synthetic source transform that emits randomly\n+// generated KV<[]byte, []byte> elements.\n+//\n+// This transform accepts a PCollection of SourceConfig, where each SourceConfig\n+// determines the synthetic source's behavior for that element.\n+//\n+// This transform outputs a PCollection of randomly generated\n+// KV<byte[], byte[]> elements.\n+func Source(s beam.Scope, col beam.PCollection) beam.PCollection {\n+\ts = s.Scope(\"synthetic.Source\")\n+\n+\treturn beam.ParDo(s, sourceFn{}, col)\n+}\n+\n+// syntheticSourceFn is a splittable DoFn implementing behavior for synthetic\n+// sources. For usage information, see `SyntheticSource`.\n+//\n+// The syntheticSourceFn is expected to receive elements of type sourceConfig\n+// and follow that config to determine its behavior when splitting and emitting\n+// elements.\n+type sourceFn struct {\n+\trng *rand.Rand\n+}\n+\n+// CreateInitialRestriction creates an offset range restriction representing\n+// the number of elements to emit.\n+func (fn *sourceFn) CreateInitialRestriction(config SourceConfig) offsetrange.Restriction {\n+\treturn offsetrange.Restriction{\n+\t\tStart: 0,\n+\t\tEnd:   int64(config.NumElements),\n+\t}\n+}\n+\n+// SplitRestriction splits restrictions equally according to the number of\n+// initial splits specified in SourceConfig. Each restriction output by this\n+// method will contain at least one element, so the number of splits will not\n+// exceed the number of elements.\n+func (fn *sourceFn) SplitRestriction(config SourceConfig, rest offsetrange.Restriction) (splits []offsetrange.Restriction) {\n+\tif config.InitialSplits <= 1 {\n+\t\t// Don't split, just return original restriction.\n+\t\tsplits = append(splits, rest)\n+\t\treturn splits\n+\t}\n+\n+\tnum := int64(config.InitialSplits)\n+\toffset := rest.Start\n+\tsize := rest.End - rest.Start\n+\tfor i := int64(0); i < num; i++ {\n+\t\tsplit := offsetrange.Restriction{\n+\t\t\tStart: offset + (i * size / num),\n+\t\t\tEnd:   offset + ((i + 1) * size / num),\n+\t\t}\n+\t\t// Skip restrictions that end up empty.\n+\t\tif split.End-split.Start <= 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tsplits = append(splits, split)\n+\t}\n+\treturn splits\n+}\n+\n+// RestrictionSize outputs the size of the restriction as the number of elements\n+// that restriction will output.\n+func (fn *sourceFn) RestrictionSize(config SourceConfig, rest offsetrange.Restriction) float64 {\n+\treturn float64(rest.End - rest.Start)\n+}\n+\n+// CreateTracker just creates an offset range restriction tracker for the\n+// restriction.\n+func (fn *sourceFn) CreateTracker(rest offsetrange.Restriction) *offsetrange.Tracker {\n+\treturn offsetrange.NewTracker(rest)\n+}\n+\n+// StartBundle sets up the random number generator.\n+func (fn *sourceFn) StartBundle() {\n+\tfn.rng = rand.New(rand.NewSource(time.Now().UnixNano()))\n+}\n+\n+// ProcessElement creates a number of random elements based on the restriction\n+// tracker received. Each element is a random byte slice key and value, in the\n+// form of KV<[]byte, []byte>,\n+func (fn *sourceFn) ProcessElement(rt *offsetrange.Tracker, config SourceConfig, emit func([]byte, []byte)) error {\n+\tfor i := rt.Rest.Start; rt.TryClaim(i) == true; i++ {\n+\t\tkey := make([]byte, 8)\n+\t\tval := make([]byte, 8)\n+\t\tif _, err := fn.rng.Read(key); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif _, err := fn.rng.Read(val); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\temit(key, val)\n+\t}\n+\treturn nil\n+}\n+\n+// DefaultSourceConfig creates a SourceConfig with intended defaults for its\n+// fields. SourceConfigs should be initialized with this method.\n+func DefaultSourceConfig() SourceConfig {\n+\treturn SourceConfig{\n+\t\tNumElements:   0, // Number of elements for the synthetic source to produce.", "originalCommit": "318a0979fe1b2583f6586f62c3c45dfb78d4dd25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0Mzg5MQ==", "url": "https://github.com/apache/beam/pull/11665#discussion_r424143891", "bodyText": "Agreed. I think I added these first when commenting stuff and didn't erase them when I added the more descriptive comments. Done.", "author": "youngoli", "createdAt": "2020-05-13T02:51:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4MzM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NjY3MQ==", "url": "https://github.com/apache/beam/pull/11665#discussion_r424086671", "bodyText": "Is that how the Python impelmentation works? Neat!", "author": "lostluck", "createdAt": "2020-05-12T23:16:07Z", "path": "sdks/go/pkg/beam/io/synthetic/source.go", "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package synthetic contains transforms for creating synthetic pipelines.\n+// Synthetic pipelines are pipelines that simulate the behavior of possible\n+// pipelines in order to test performance, splitting, liquid sharding, and\n+// various other infrastructure used for running pipelines. This category of\n+// tests are not concerned with the correctness of the elements themselves, but\n+// need to simulate transforms that output many elements throughout varying\n+// pipeline shapes.\n+package synthetic\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/io/rtrackers/offsetrange\"\n+\t\"math/rand\"\n+\t\"time\"\n+)\n+\n+// Source creates a synthetic source transform that emits randomly\n+// generated KV<[]byte, []byte> elements.\n+//\n+// This transform accepts a PCollection of SourceConfig, where each SourceConfig", "originalCommit": "318a0979fe1b2583f6586f62c3c45dfb78d4dd25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEyMzgyOA==", "url": "https://github.com/apache/beam/pull/11665#discussion_r424123828", "bodyText": "Yep! Link if you wanna check it out: https://github.com/apache/beam/blob/master/sdks/python/apache_beam/testing/synthetic_pipeline.py#L550", "author": "youngoli", "createdAt": "2020-05-13T01:32:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NjY3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5MDI3NA==", "url": "https://github.com/apache/beam/pull/11665#discussion_r424090274", "bodyText": "You may want to consider a small pipeline example snippet that feeds into this using beam.Create and DefaultSourceConfig() or similar, if only to hint folks towards DefaultSourceConfig.\nWRT Builders, I agree that a Builder api for SourceConfigs would be valuable in this case, even if they just return new instances of a SourceConfig. It would be more concise than requiring a new line per field change.\nsynthetic.DefaultSourceConfig().SetNumElements(###).SetInitialSplits(###)\nvs the \"natural\" Go inclination of:\nsynthetic.SourceConfig{NumElements: ###, InitialSplits: ###}\nwhich is a dozen or so characters shorter.\nThe only downside of the latter is introducing new fields that must have a nonzero default to work properly. Do any of the configurations in Java and Python have that property?", "author": "lostluck", "createdAt": "2020-05-12T23:27:44Z", "path": "sdks/go/pkg/beam/io/synthetic/source.go", "diffHunk": "@@ -0,0 +1,151 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+// Package synthetic contains transforms for creating synthetic pipelines.\n+// Synthetic pipelines are pipelines that simulate the behavior of possible\n+// pipelines in order to test performance, splitting, liquid sharding, and\n+// various other infrastructure used for running pipelines. This category of\n+// tests are not concerned with the correctness of the elements themselves, but\n+// need to simulate transforms that output many elements throughout varying\n+// pipeline shapes.\n+package synthetic\n+\n+import (\n+\t\"github.com/apache/beam/sdks/go/pkg/beam\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/io/rtrackers/offsetrange\"\n+\t\"math/rand\"\n+\t\"time\"\n+)\n+\n+// Source creates a synthetic source transform that emits randomly\n+// generated KV<[]byte, []byte> elements.\n+//\n+// This transform accepts a PCollection of SourceConfig, where each SourceConfig\n+// determines the synthetic source's behavior for that element.", "originalCommit": "318a0979fe1b2583f6586f62c3c45dfb78d4dd25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDEyOTQyMw==", "url": "https://github.com/apache/beam/pull/11665#discussion_r424129423", "bodyText": "Hmm. My first instinct was to say yes, a good number of the fields wouldn't work with zero values, like the tuples that have \"string\" fields as makeshift enums, or the various sizes. But thinking about it, we already handle the case where the split restriction is zero by deciding that no restriction can be empty and defaulting it to a size of 1. There's no reason that for those other fields we couldn't also just default to something if the zero value is present.\nThe only fields then that don't seem to work are ones where 0 is a valid but unlikely option. I think the only obvious case of that to me is the output_records_per_input_record in Python. You wouldn't usually set it to 0 (i.e. have the step output no elements at all), but that's how sinks are represented so you'd need to do it in that case.\nTo be fair though, I'm also not a huge fan of having default values be spread around the code inside error-catching statements, so I'm still leaning towards a builder pattern, or a config variadic parameter approach (like I used here: \n  \n    \n      beam/sdks/go/pkg/beam/core/graph/fn.go\n    \n    \n         Line 301\n      in\n      076dccd\n    \n    \n    \n    \n\n        \n          \n           func NewDoFn(fn interface{}, options ...func(*config)) (*DoFn, error) { \n        \n    \n  \n\n).", "author": "youngoli", "createdAt": "2020-05-13T01:54:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5MDI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0NjE5Nw==", "url": "https://github.com/apache/beam/pull/11665#discussion_r424146197", "bodyText": "Also, added the example.", "author": "youngoli", "createdAt": "2020-05-13T03:00:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5MDI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIyNDcwMw==", "url": "https://github.com/apache/beam/pull/11665#discussion_r425224703", "bodyText": "output_records_per_input_record is problematic, but doesn't apply to SourceConfig I would think... (SrcCfg?) That seems like a perDoFn configuration.\nUnless that's the \"NumElements\" you were mentioning?", "author": "lostluck", "createdAt": "2020-05-14T15:25:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5MDI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ1MzUwOQ==", "url": "https://github.com/apache/beam/pull/11665#discussion_r425453509", "bodyText": "No, it applies to the synthetic steps, so it would be in an upcoming StepConfig, but that would probably still have a similar interface.", "author": "youngoli", "createdAt": "2020-05-14T21:55:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5MDI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTUwMjk4NQ==", "url": "https://github.com/apache/beam/pull/11665#discussion_r425502985", "bodyText": "I think I'm coming to the position that it might be overengineering to protect users, since the risky fields are known with the first version.\nIt's probably better to simply panic/error out with a clear message at some early stage if it's configured incorrectly, if graceful behavior isn't possible, and it's not typically the value that needs to be set (eg. NumElements or OutputsPerInput).\nRegardless, this is a good exercise to consider, whatever you choose to do.", "author": "lostluck", "createdAt": "2020-05-15T00:33:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5MDI3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgwMzAzNQ==", "url": "https://github.com/apache/beam/pull/11665#discussion_r424803035", "bodyText": "Given the verbosity, it's likely users will end up writing this as.\n//    cfgs := beam.CreateList(s, []synthetic.SourceConfig{{NumElements:1000}, {NumElements:5000: InitialSplits:2}})\n//    src := synthetic.Source(s, cfgs)\n\nBut ones that enjoy breaking code might run into breaks when we add fields with:\n cfgs := beam.CreateList(s, []synthetic.SourceConfig{{1000, 1}, {5000,2}})\n src := synthetic.Source(s, cfgs)\n\n... which is why one should always name one's fields when using struct literals.", "author": "lostluck", "createdAt": "2020-05-14T00:20:43Z", "path": "sdks/go/pkg/beam/io/synthetic/source.go", "diffHunk": "@@ -33,22 +33,30 @@ import (\n // generated KV<[]byte, []byte> elements.\n //\n // This transform accepts a PCollection of SourceConfig, where each SourceConfig\n-// determines the synthetic source's behavior for that element.\n+// determines the synthetic source's behavior for that element and outputs the\n+// randomly generated elements.\n //\n-// This transform outputs a PCollection of randomly generated\n-// KV<byte[], byte[]> elements.\n+// SourceConfigs are recommended to be created via the DefaultSourceConfig and\n+// then sent to a beam.Create transform once modified. Example:\n+//\n+//    cfg1 := synthetic.DefaultSourceConfig()\n+//    cfg1.NumElements = 1000\n+//    cfg2 := synthetic.DefaultSourceConfig()", "originalCommit": "6a4794d091e737be276624b86e4e9c24f7ca256d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ4MTcwMw==", "url": "https://github.com/apache/beam/pull/11665#discussion_r425481703", "bodyText": "Yeah I was thinking the same thing. I guess it technically works that way right now because the code catches the 0 initial splits case and clamps it to 1, but I'm still not a huge fan of allowing it to be used as a value like that. Hence, why I used that \"proper\" example.\nWhile working on the step PR I've been thinking that the most appealing approach to me right now is using a builder so you can do DefaultSourceConfig().NumElements(1000).Build() and have Build catch any invalid values. It's a little over-engineered for what we have now, but I prefer over-engineered default values that at least have a user-friendly API over implicitly changing 0 values to the defaults we actually want (\"0 initial splits? That's invalid so I'll just set it to 1 for you.\")", "author": "youngoli", "createdAt": "2020-05-14T23:18:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgwMzAzNQ=="}], "type": "inlineReview"}, {"oid": "176e1f093e2457d4e7f0e092bf509d9873518c22", "url": "https://github.com/apache/beam/commit/176e1f093e2457d4e7f0e092bf509d9873518c22", "message": "[BEAM-9951] Creating a synthetic source for the Go SDK.\n\nThis is just a starting point, and there's a lot more that can be added\non to this class, but this'll do for now. As part of this change, I\ngeneralized the offset range tracker code so it could also be used in\nthe synthetic source.", "committedDate": "2020-05-15T21:18:58Z", "type": "commit"}, {"oid": "176e1f093e2457d4e7f0e092bf509d9873518c22", "url": "https://github.com/apache/beam/commit/176e1f093e2457d4e7f0e092bf509d9873518c22", "message": "[BEAM-9951] Creating a synthetic source for the Go SDK.\n\nThis is just a starting point, and there's a lot more that can be added\non to this class, but this'll do for now. As part of this change, I\ngeneralized the offset range tracker code so it could also be used in\nthe synthetic source.", "committedDate": "2020-05-15T21:18:58Z", "type": "forcePushed"}]}