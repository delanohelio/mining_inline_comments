{"pr_number": 10990, "pr_title": "[BEAM-9569] disable coder inference for rows", "pr_createdAt": "2020-02-27T18:32:54Z", "pr_url": "https://github.com/apache/beam/pull/10990", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMwMzUwOQ==", "url": "https://github.com/apache/beam/pull/10990#discussion_r385303509", "bodyText": "This is the base class, so shouldn't be calling it \"intersect\". Incidentally I don't think having a base class adds much value here, so inlining or inverting would be a-ok.", "author": "kennknowles", "createdAt": "2020-02-27T18:50:39Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamSetOperatorRelBase.java", "diffHunk": "@@ -65,6 +66,16 @@ public BeamSetOperatorRelBase(BeamRelNode beamRelNode, OpType opType, boolean al\n         inputs);\n     PCollection<Row> leftRows = inputs.get(0);\n     PCollection<Row> rightRows = inputs.get(1);\n+    Schema leftSchema = leftRows.getSchema();\n+    Schema rightSchema = rightRows.getSchema();\n+    if (!leftSchema.typesEqual(rightSchema)) {\n+      throw new IllegalArgumentException(\n+          \"Can't intersect two tables with different schemas.\"", "originalCommit": "0761a9a61e761b8b7a3389d231bb2608ca3cf0ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMwNDk0NA==", "url": "https://github.com/apache/beam/pull/10990#discussion_r385304944", "bodyText": "This optimization seems to have nothing to do with disabling coder inference. Please split into separate commit so git history shows it.", "author": "kennknowles", "createdAt": "2020-02-27T18:53:16Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/transform/BeamSetOperatorsTransforms.java", "diffHunk": "@@ -38,61 +35,62 @@\n   }\n \n   /** Filter function used for Set operators. */\n-  public static class SetOperatorFilteringDoFn extends DoFn<KV<Row, CoGbkResult>, Row> {\n-    private TupleTag<Row> leftTag;\n-    private TupleTag<Row> rightTag;\n-    private BeamSetOperatorRelBase.OpType opType;\n+  public static class SetOperatorFilteringDoFn extends DoFn<Row, Row> {\n+    private final String leftTag;\n+    private final String rightTag;\n+    private final String numRowsField;\n+    private final BeamSetOperatorRelBase.OpType opType;\n     // ALL?\n-    private boolean all;\n+    private final boolean all;\n \n     public SetOperatorFilteringDoFn(\n-        TupleTag<Row> leftTag,\n-        TupleTag<Row> rightTag,\n+        String leftTag,\n+        String rightTag,\n+        String numRowsField,\n         BeamSetOperatorRelBase.OpType opType,\n         boolean all) {\n       this.leftTag = leftTag;\n       this.rightTag = rightTag;\n+      this.numRowsField = numRowsField;\n       this.opType = opType;\n       this.all = all;\n     }\n \n     @ProcessElement\n-    public void processElement(ProcessContext ctx) {\n-      CoGbkResult coGbkResult = ctx.element().getValue();\n-      Iterable<Row> leftRows = coGbkResult.getAll(leftTag);\n-      Iterable<Row> rightRows = coGbkResult.getAll(rightTag);\n+    public void processElement(@Element Row element, OutputReceiver<Row> o) {\n+      Row key = element.getRow(\"key\");\n+      long numLeftRows = 0;\n+      long numRightRows = 0;\n+      if (!Iterables.isEmpty(element.<Row>getIterable(leftTag))) {\n+        numLeftRows =\n+            Iterables.getOnlyElement(element.<Row>getIterable(leftTag)).getInt64(numRowsField);\n+      }\n+      if (!Iterables.isEmpty(element.<Row>getIterable(rightTag))) {\n+        numRightRows =\n+            Iterables.getOnlyElement(element.<Row>getIterable(rightTag)).getInt64(numRowsField);\n+      }\n+\n       switch (opType) {\n         case UNION:\n           if (all) {\n-            // output both left & right\n-            Iterator<Row> iter = leftRows.iterator();\n-            while (iter.hasNext()) {\n-              ctx.output(iter.next());\n-            }\n-            iter = rightRows.iterator();\n-            while (iter.hasNext()) {\n-              ctx.output(iter.next());\n+            for (int i = 0; i < numLeftRows + numRightRows; i++) {\n+              o.output(key);", "originalCommit": "0761a9a61e761b8b7a3389d231bb2608ca3cf0ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7cc1c2fea9c7595f3e92b947f4beb56634f031d4", "url": "https://github.com/apache/beam/commit/7cc1c2fea9c7595f3e92b947f4beb56634f031d4", "message": "disable coder inference for rows", "committedDate": "2020-03-13T00:43:48Z", "type": "commit"}, {"oid": "388ba3688095f5a980f25426136329772074edcd", "url": "https://github.com/apache/beam/commit/388ba3688095f5a980f25426136329772074edcd", "message": "revert optimization", "committedDate": "2020-03-13T00:43:48Z", "type": "commit"}, {"oid": "388ba3688095f5a980f25426136329772074edcd", "url": "https://github.com/apache/beam/commit/388ba3688095f5a980f25426136329772074edcd", "message": "revert optimization", "committedDate": "2020-03-13T00:43:48Z", "type": "forcePushed"}, {"oid": "b505d1d88d024185f16dced7da9654bdd6640830", "url": "https://github.com/apache/beam/commit/b505d1d88d024185f16dced7da9654bdd6640830", "message": "fix bad import", "committedDate": "2020-03-23T07:15:12Z", "type": "commit"}]}