{"pr_number": 11653, "pr_title": "[BEAM-9935] Respect allowed split points in Python.", "pr_createdAt": "2020-05-09T10:26:24Z", "pr_url": "https://github.com/apache/beam/pull/11653", "timeline": [{"oid": "3dad2e502e547381b6309271551051ac52b94687", "url": "https://github.com/apache/beam/commit/3dad2e502e547381b6309271551051ac52b94687", "message": "[BEAM-9935] Respect allowed split points in Python.", "committedDate": "2020-05-09T10:25:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3MjY5Mg==", "url": "https://github.com/apache/beam/pull/11653#discussion_r423172692", "bodyText": "allowed_split_points definition is too vague in the case of multiple active elements and we need to scope it down to mean the set of allowed first_residual_element indices.", "author": "lukecwik", "createdAt": "2020-05-11T16:41:49Z", "path": "sdks/python/apache_beam/runners/worker/bundle_processor.py", "diffHunk": "@@ -237,30 +235,71 @@ def try_split(self, fraction_of_remainder, total_buffer_size):\n           current_element_progress = (\n               current_element_progress_object.fraction_completed)\n       # Now figure out where to split.\n-      # The units here (except for keep_of_element_remainder) are all in\n-      # terms of number of (possibly fractional) elements.\n-      remainder = total_buffer_size - self.index - current_element_progress\n-      keep = remainder * fraction_of_remainder\n-      if current_element_progress < 1:\n-        keep_of_element_remainder = keep / (1 - current_element_progress)\n-        # If it's less than what's left of the current element,\n-        # try splitting at the current element.\n-        if keep_of_element_remainder < 1:\n-          split = self.receivers[0].try_split(\n-              keep_of_element_remainder\n-          )  # type: Optional[Tuple[operations.SdfSplitResultsPrimary, operations.SdfSplitResultsResidual]]\n-          if split:\n-            element_primary, element_residual = split\n-            self.stop = self.index + 1\n-            return self.index - 1, element_primary, element_residual, self.stop\n-      # Otherwise, split at the closest element boundary.\n-      # pylint: disable=round-builtin\n-      stop_index = (\n-          self.index + max(1, int(round(current_element_progress + keep))))\n-      if stop_index < self.stop:\n-        self.stop = stop_index\n-        return self.stop - 1, None, None, self.stop\n-    return None\n+      split = self._compute_split(\n+          self.index,\n+          current_element_progress,\n+          self.stop,\n+          fraction_of_remainder,\n+          total_buffer_size,\n+          allowed_split_points,\n+          self.receivers[0].try_split)\n+      if split:\n+        self.stop = split[-1]\n+      return split\n+\n+  @staticmethod\n+  def _compute_split(\n+      index,\n+      current_element_progress,\n+      stop,\n+      fraction_of_remainder,\n+      total_buffer_size,\n+      allowed_split_points=(),\n+      try_split=lambda fraction: None):\n+    def is_valid_split_point(index):\n+      return not allowed_split_points or index in allowed_split_points\n+\n+    if total_buffer_size < index + 1:\n+      total_buffer_size = index + 1\n+    elif total_buffer_size > stop:\n+      total_buffer_size = stop\n+    # The units here (except for keep_of_element_remainder) are all in\n+    # terms of number of (possibly fractional) elements.\n+    remainder = total_buffer_size - index - current_element_progress\n+    keep = remainder * fraction_of_remainder\n+    if current_element_progress < 1:\n+      keep_of_element_remainder = keep / (1 - current_element_progress)\n+      # If it's less than what's left of the current element,\n+      # try splitting at the current element.\n+      if (keep_of_element_remainder < 1 and is_valid_split_point(index) and", "originalCommit": "3dad2e502e547381b6309271551051ac52b94687", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIxMDk1NQ==", "url": "https://github.com/apache/beam/pull/11653#discussion_r423210955", "bodyText": "Agreed. I've added clarification to the proto.", "author": "robertwb", "createdAt": "2020-05-11T17:44:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3MjY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3OTAyNg==", "url": "https://github.com/apache/beam/pull/11653#discussion_r423179026", "bodyText": "We should make it an error to have duplicate split points in allowed_split_points.", "author": "lukecwik", "createdAt": "2020-05-11T16:52:01Z", "path": "sdks/python/apache_beam/runners/worker/bundle_processor.py", "diffHunk": "@@ -237,30 +235,71 @@ def try_split(self, fraction_of_remainder, total_buffer_size):\n           current_element_progress = (\n               current_element_progress_object.fraction_completed)\n       # Now figure out where to split.\n-      # The units here (except for keep_of_element_remainder) are all in\n-      # terms of number of (possibly fractional) elements.\n-      remainder = total_buffer_size - self.index - current_element_progress\n-      keep = remainder * fraction_of_remainder\n-      if current_element_progress < 1:\n-        keep_of_element_remainder = keep / (1 - current_element_progress)\n-        # If it's less than what's left of the current element,\n-        # try splitting at the current element.\n-        if keep_of_element_remainder < 1:\n-          split = self.receivers[0].try_split(\n-              keep_of_element_remainder\n-          )  # type: Optional[Tuple[operations.SdfSplitResultsPrimary, operations.SdfSplitResultsResidual]]\n-          if split:\n-            element_primary, element_residual = split\n-            self.stop = self.index + 1\n-            return self.index - 1, element_primary, element_residual, self.stop\n-      # Otherwise, split at the closest element boundary.\n-      # pylint: disable=round-builtin\n-      stop_index = (\n-          self.index + max(1, int(round(current_element_progress + keep))))\n-      if stop_index < self.stop:\n-        self.stop = stop_index\n-        return self.stop - 1, None, None, self.stop\n-    return None\n+      split = self._compute_split(\n+          self.index,\n+          current_element_progress,\n+          self.stop,\n+          fraction_of_remainder,\n+          total_buffer_size,\n+          allowed_split_points,\n+          self.receivers[0].try_split)\n+      if split:\n+        self.stop = split[-1]\n+      return split\n+\n+  @staticmethod\n+  def _compute_split(\n+      index,\n+      current_element_progress,\n+      stop,\n+      fraction_of_remainder,\n+      total_buffer_size,\n+      allowed_split_points=(),\n+      try_split=lambda fraction: None):\n+    def is_valid_split_point(index):\n+      return not allowed_split_points or index in allowed_split_points\n+\n+    if total_buffer_size < index + 1:\n+      total_buffer_size = index + 1\n+    elif total_buffer_size > stop:\n+      total_buffer_size = stop\n+    # The units here (except for keep_of_element_remainder) are all in\n+    # terms of number of (possibly fractional) elements.\n+    remainder = total_buffer_size - index - current_element_progress\n+    keep = remainder * fraction_of_remainder\n+    if current_element_progress < 1:\n+      keep_of_element_remainder = keep / (1 - current_element_progress)\n+      # If it's less than what's left of the current element,\n+      # try splitting at the current element.\n+      if (keep_of_element_remainder < 1 and is_valid_split_point(index) and\n+          is_valid_split_point(index + 1)):\n+        split = try_split(\n+            keep_of_element_remainder\n+        )  # type: Optional[Tuple[operations.SdfSplitResultsPrimary, operations.SdfSplitResultsResidual]]\n+        if split:\n+          element_primary, element_residual = split\n+          return index - 1, element_primary, element_residual, index + 1\n+    # Otherwise, split at the closest element boundary.\n+    # pylint: disable=round-builtin\n+    stop_index = index + max(1, int(round(current_element_progress + keep)))\n+    if allowed_split_points and stop_index not in allowed_split_points:\n+      allowed_split_points = sorted(allowed_split_points)", "originalCommit": "3dad2e502e547381b6309271551051ac52b94687", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIxMTYxMw==", "url": "https://github.com/apache/beam/pull/11653#discussion_r423211613", "bodyText": "I agree that there's never a reason to have duplicates, but that wouldn't impact this code here (and I don't think should result in failure).", "author": "robertwb", "createdAt": "2020-05-11T17:45:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3OTAyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4MjE5MA==", "url": "https://github.com/apache/beam/pull/11653#discussion_r423182190", "bodyText": "I think you should comment that your choosing the closer of the two points here.", "author": "lukecwik", "createdAt": "2020-05-11T16:56:52Z", "path": "sdks/python/apache_beam/runners/worker/bundle_processor.py", "diffHunk": "@@ -237,30 +235,71 @@ def try_split(self, fraction_of_remainder, total_buffer_size):\n           current_element_progress = (\n               current_element_progress_object.fraction_completed)\n       # Now figure out where to split.\n-      # The units here (except for keep_of_element_remainder) are all in\n-      # terms of number of (possibly fractional) elements.\n-      remainder = total_buffer_size - self.index - current_element_progress\n-      keep = remainder * fraction_of_remainder\n-      if current_element_progress < 1:\n-        keep_of_element_remainder = keep / (1 - current_element_progress)\n-        # If it's less than what's left of the current element,\n-        # try splitting at the current element.\n-        if keep_of_element_remainder < 1:\n-          split = self.receivers[0].try_split(\n-              keep_of_element_remainder\n-          )  # type: Optional[Tuple[operations.SdfSplitResultsPrimary, operations.SdfSplitResultsResidual]]\n-          if split:\n-            element_primary, element_residual = split\n-            self.stop = self.index + 1\n-            return self.index - 1, element_primary, element_residual, self.stop\n-      # Otherwise, split at the closest element boundary.\n-      # pylint: disable=round-builtin\n-      stop_index = (\n-          self.index + max(1, int(round(current_element_progress + keep))))\n-      if stop_index < self.stop:\n-        self.stop = stop_index\n-        return self.stop - 1, None, None, self.stop\n-    return None\n+      split = self._compute_split(\n+          self.index,\n+          current_element_progress,\n+          self.stop,\n+          fraction_of_remainder,\n+          total_buffer_size,\n+          allowed_split_points,\n+          self.receivers[0].try_split)\n+      if split:\n+        self.stop = split[-1]\n+      return split\n+\n+  @staticmethod\n+  def _compute_split(\n+      index,\n+      current_element_progress,\n+      stop,\n+      fraction_of_remainder,\n+      total_buffer_size,\n+      allowed_split_points=(),\n+      try_split=lambda fraction: None):\n+    def is_valid_split_point(index):\n+      return not allowed_split_points or index in allowed_split_points\n+\n+    if total_buffer_size < index + 1:\n+      total_buffer_size = index + 1\n+    elif total_buffer_size > stop:\n+      total_buffer_size = stop\n+    # The units here (except for keep_of_element_remainder) are all in\n+    # terms of number of (possibly fractional) elements.\n+    remainder = total_buffer_size - index - current_element_progress\n+    keep = remainder * fraction_of_remainder\n+    if current_element_progress < 1:\n+      keep_of_element_remainder = keep / (1 - current_element_progress)\n+      # If it's less than what's left of the current element,\n+      # try splitting at the current element.\n+      if (keep_of_element_remainder < 1 and is_valid_split_point(index) and\n+          is_valid_split_point(index + 1)):\n+        split = try_split(\n+            keep_of_element_remainder\n+        )  # type: Optional[Tuple[operations.SdfSplitResultsPrimary, operations.SdfSplitResultsResidual]]\n+        if split:\n+          element_primary, element_residual = split\n+          return index - 1, element_primary, element_residual, index + 1\n+    # Otherwise, split at the closest element boundary.\n+    # pylint: disable=round-builtin\n+    stop_index = index + max(1, int(round(current_element_progress + keep)))\n+    if allowed_split_points and stop_index not in allowed_split_points:\n+      allowed_split_points = sorted(allowed_split_points)\n+      closest = bisect.bisect(allowed_split_points, stop_index)\n+      if closest == 0:\n+        stop_index = allowed_split_points[0]\n+      elif closest == len(allowed_split_points):\n+        stop_index = allowed_split_points[-1]\n+      else:\n+        prev = allowed_split_points[closest - 1]\n+        next = allowed_split_points[closest]\n+        if index < prev and stop_index - prev < next - stop_index:", "originalCommit": "3dad2e502e547381b6309271551051ac52b94687", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIxMTg0Nw==", "url": "https://github.com/apache/beam/pull/11653#discussion_r423211847", "bodyText": "Done.", "author": "robertwb", "createdAt": "2020-05-11T17:46:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4MjE5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4Mjg5Mg==", "url": "https://github.com/apache/beam/pull/11653#discussion_r423182892", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              def test_split_with_element_progres(self):\n          \n          \n            \n              def test_split_with_element_progress(self):", "author": "lukecwik", "createdAt": "2020-05-11T16:57:55Z", "path": "sdks/python/apache_beam/runners/worker/bundle_processor_test.py", "diffHunk": "@@ -0,0 +1,118 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Unit tests for bundle processing.\"\"\"\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+\n+import unittest\n+\n+from apache_beam.runners.worker.bundle_processor import DataInputOperation\n+\n+\n+def simple_split(first_residual_index):\n+  return first_residual_index - 1, None, None, first_residual_index\n+\n+\n+def element_split(frac, index):\n+  return (\n+      index - 1,\n+      'Primary(%0.1f)' % frac,\n+      'Residual(%0.1f)' % (1 - frac),\n+      index + 1)\n+\n+\n+class SplitTest(unittest.TestCase):\n+  def split(\n+      self,\n+      index,\n+      current_element_progress,\n+      fraction_of_remainder,\n+      buffer_size,\n+      allowed=(),\n+      sdf=False):\n+    return DataInputOperation._compute_split(\n+        index,\n+        current_element_progress,\n+        float('inf'),\n+        fraction_of_remainder,\n+        buffer_size,\n+        allowed_split_points=allowed,\n+        try_split=lambda frac: element_split(frac, 0)[1:3] if sdf else None)\n+\n+  def sdf_split(self, *args, **kwargs):\n+    return self.split(*args, sdf=True, **kwargs)\n+\n+  def test_simple_split(self):\n+    self.assertEqual(self.split(0, 0, 0, 16), simple_split(1))\n+    self.assertEqual(self.split(0, 0, 0.24, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.25, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.26, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.5, 16), simple_split(8))\n+    self.assertEqual(self.split(2, 0, 0.5, 16), simple_split(9))\n+    self.assertEqual(self.split(6, 0, 0.5, 16), simple_split(11))\n+\n+  def test_split_with_element_progres(self):", "originalCommit": "3dad2e502e547381b6309271551051ac52b94687", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIxMjE4OA==", "url": "https://github.com/apache/beam/pull/11653#discussion_r423212188", "bodyText": "Done.", "author": "robertwb", "createdAt": "2020-05-11T17:47:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4Mjg5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4NTQ0NQ==", "url": "https://github.com/apache/beam/pull/11653#discussion_r423185445", "bodyText": "It would be good to either add comments or break out the tests to separate methods to describe the different scenarios such as round to closest.", "author": "lukecwik", "createdAt": "2020-05-11T17:01:54Z", "path": "sdks/python/apache_beam/runners/worker/bundle_processor_test.py", "diffHunk": "@@ -0,0 +1,118 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Unit tests for bundle processing.\"\"\"\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+\n+import unittest\n+\n+from apache_beam.runners.worker.bundle_processor import DataInputOperation\n+\n+\n+def simple_split(first_residual_index):\n+  return first_residual_index - 1, None, None, first_residual_index\n+\n+\n+def element_split(frac, index):\n+  return (\n+      index - 1,\n+      'Primary(%0.1f)' % frac,\n+      'Residual(%0.1f)' % (1 - frac),\n+      index + 1)\n+\n+\n+class SplitTest(unittest.TestCase):\n+  def split(\n+      self,\n+      index,\n+      current_element_progress,\n+      fraction_of_remainder,\n+      buffer_size,\n+      allowed=(),\n+      sdf=False):\n+    return DataInputOperation._compute_split(\n+        index,\n+        current_element_progress,\n+        float('inf'),\n+        fraction_of_remainder,\n+        buffer_size,\n+        allowed_split_points=allowed,\n+        try_split=lambda frac: element_split(frac, 0)[1:3] if sdf else None)\n+\n+  def sdf_split(self, *args, **kwargs):\n+    return self.split(*args, sdf=True, **kwargs)\n+\n+  def test_simple_split(self):\n+    self.assertEqual(self.split(0, 0, 0, 16), simple_split(1))\n+    self.assertEqual(self.split(0, 0, 0.24, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.25, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.26, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.5, 16), simple_split(8))\n+    self.assertEqual(self.split(2, 0, 0.5, 16), simple_split(9))\n+    self.assertEqual(self.split(6, 0, 0.5, 16), simple_split(11))\n+\n+  def test_split_with_element_progres(self):\n+    self.assertEqual(self.split(0, 0.5, 0.25, 4), simple_split(1))\n+    self.assertEqual(self.split(0, 0.9, 0.25, 4), simple_split(2))\n+    self.assertEqual(self.split(1, 0.0, 0.25, 4), simple_split(2))\n+    self.assertEqual(self.split(1, 0.1, 0.25, 4), simple_split(2))\n+\n+  def test_split_with_element_allowed_splits(self):\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(2, 3, 4, 5)), simple_split(4))\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(2, 3, 5)), simple_split(5))\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(2, 3, 6)), simple_split(3))\n+\n+    self.assertEqual(", "originalCommit": "3dad2e502e547381b6309271551051ac52b94687", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIyMTM0NA==", "url": "https://github.com/apache/beam/pull/11653#discussion_r423221344", "bodyText": "I kept them in the same methods, because it's easier to understand the values relative to the prior examples.", "author": "robertwb", "createdAt": "2020-05-11T18:03:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4NTQ0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4NjAxOA==", "url": "https://github.com/apache/beam/pull/11653#discussion_r423186018", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                self.assertEqual(\n          \n          \n            \n                    self.sdf_split(0, 0, 0.12, 4), (-1, 'Primary(0.5)', 'Residual(0.5)', 1))\n          \n          \n            \n                self.assertEqual(\n          \n          \n            \n                    self.sdf_split(0, 0, 0.125, 4), (-1, 'Primary(0.5)', 'Residual(0.5)', 1))", "author": "lukecwik", "createdAt": "2020-05-11T17:02:49Z", "path": "sdks/python/apache_beam/runners/worker/bundle_processor_test.py", "diffHunk": "@@ -0,0 +1,118 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+\"\"\"Unit tests for bundle processing.\"\"\"\n+# pytype: skip-file\n+\n+from __future__ import absolute_import\n+\n+import unittest\n+\n+from apache_beam.runners.worker.bundle_processor import DataInputOperation\n+\n+\n+def simple_split(first_residual_index):\n+  return first_residual_index - 1, None, None, first_residual_index\n+\n+\n+def element_split(frac, index):\n+  return (\n+      index - 1,\n+      'Primary(%0.1f)' % frac,\n+      'Residual(%0.1f)' % (1 - frac),\n+      index + 1)\n+\n+\n+class SplitTest(unittest.TestCase):\n+  def split(\n+      self,\n+      index,\n+      current_element_progress,\n+      fraction_of_remainder,\n+      buffer_size,\n+      allowed=(),\n+      sdf=False):\n+    return DataInputOperation._compute_split(\n+        index,\n+        current_element_progress,\n+        float('inf'),\n+        fraction_of_remainder,\n+        buffer_size,\n+        allowed_split_points=allowed,\n+        try_split=lambda frac: element_split(frac, 0)[1:3] if sdf else None)\n+\n+  def sdf_split(self, *args, **kwargs):\n+    return self.split(*args, sdf=True, **kwargs)\n+\n+  def test_simple_split(self):\n+    self.assertEqual(self.split(0, 0, 0, 16), simple_split(1))\n+    self.assertEqual(self.split(0, 0, 0.24, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.25, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.26, 16), simple_split(4))\n+    self.assertEqual(self.split(0, 0, 0.5, 16), simple_split(8))\n+    self.assertEqual(self.split(2, 0, 0.5, 16), simple_split(9))\n+    self.assertEqual(self.split(6, 0, 0.5, 16), simple_split(11))\n+\n+  def test_split_with_element_progres(self):\n+    self.assertEqual(self.split(0, 0.5, 0.25, 4), simple_split(1))\n+    self.assertEqual(self.split(0, 0.9, 0.25, 4), simple_split(2))\n+    self.assertEqual(self.split(1, 0.0, 0.25, 4), simple_split(2))\n+    self.assertEqual(self.split(1, 0.1, 0.25, 4), simple_split(2))\n+\n+  def test_split_with_element_allowed_splits(self):\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(2, 3, 4, 5)), simple_split(4))\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(2, 3, 5)), simple_split(5))\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(2, 3, 6)), simple_split(3))\n+\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(5, 6, 7)), simple_split(5))\n+    self.assertEqual(\n+        self.split(0, 0, 0.25, 16, allowed=(1, 2, 3)), simple_split(3))\n+\n+    self.assertEqual(self.split(5, 0, 0.25, 16, allowed=(1, 2, 3)), None)\n+\n+  def test_sdf_split(self):\n+    self.assertEqual(self.sdf_split(0, 0, 0.51, 4), simple_split(2))\n+    self.assertEqual(self.sdf_split(0, 0, 0.49, 4), simple_split(2))\n+    self.assertEqual(self.sdf_split(0, 0, 0.26, 4), simple_split(1))\n+    self.assertEqual(self.sdf_split(0, 0, 0.25, 4), simple_split(1))\n+    self.assertEqual(\n+        self.sdf_split(0, 0, 0.20, 4), (-1, 'Primary(0.8)', 'Residual(0.2)', 1))\n+    self.assertEqual(\n+        self.sdf_split(0, 0, 0.12, 4), (-1, 'Primary(0.5)', 'Residual(0.5)', 1))", "originalCommit": "3dad2e502e547381b6309271551051ac52b94687", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIxMjg1Mg==", "url": "https://github.com/apache/beam/pull/11653#discussion_r423212852", "bodyText": "I had this originally, but it bumped the formatting, and .12 was close enough. I can change this back.", "author": "robertwb", "createdAt": "2020-05-11T17:48:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4NjAxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI1MDkyMg==", "url": "https://github.com/apache/beam/pull/11653#discussion_r423250922", "bodyText": "I found it confusing that the rounding dropped the fractional part when I was running through the scenarios.", "author": "lukecwik", "createdAt": "2020-05-11T18:56:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4NjAxOA=="}], "type": "inlineReview"}, {"oid": "773854cd6a7e2429f5c5e704f875aef89233879b", "url": "https://github.com/apache/beam/commit/773854cd6a7e2429f5c5e704f875aef89233879b", "message": "More comments.", "committedDate": "2020-05-11T18:02:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI1NTg3Mw==", "url": "https://github.com/apache/beam/pull/11653#discussion_r423255873", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // preceded an allowed split point.\n          \n          \n            \n                // precede an allowed split point.", "author": "lukecwik", "createdAt": "2020-05-11T19:05:08Z", "path": "model/fn-execution/src/main/proto/beam_fn_api.proto", "diffHunk": "@@ -375,6 +375,9 @@ message ProcessBundleSplitRequest {\n \n     // A set of allowed element indices where the SDK may split. When this is\n     // empty, there are no constraints on where to split.\n+    // Specifically, the first_residual_element of a split result must be an\n+    // allowed split point, and the last_primary_element must immediately\n+    // preceded an allowed split point.", "originalCommit": "773854cd6a7e2429f5c5e704f875aef89233879b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM0MjczNw==", "url": "https://github.com/apache/beam/pull/11653#discussion_r423342737", "bodyText": "Is total_buffer_size the current outstanding buffer of data? Eg. The elements sent to the SDK, but as yet unprocessed?", "author": "lostluck", "createdAt": "2020-05-11T21:55:15Z", "path": "sdks/python/apache_beam/runners/worker/bundle_processor.py", "diffHunk": "@@ -237,30 +235,72 @@ def try_split(self, fraction_of_remainder, total_buffer_size):\n           current_element_progress = (\n               current_element_progress_object.fraction_completed)\n       # Now figure out where to split.\n-      # The units here (except for keep_of_element_remainder) are all in\n-      # terms of number of (possibly fractional) elements.\n-      remainder = total_buffer_size - self.index - current_element_progress\n-      keep = remainder * fraction_of_remainder\n-      if current_element_progress < 1:\n-        keep_of_element_remainder = keep / (1 - current_element_progress)\n-        # If it's less than what's left of the current element,\n-        # try splitting at the current element.\n-        if keep_of_element_remainder < 1:\n-          split = self.receivers[0].try_split(\n-              keep_of_element_remainder\n-          )  # type: Optional[Tuple[operations.SdfSplitResultsPrimary, operations.SdfSplitResultsResidual]]\n-          if split:\n-            element_primary, element_residual = split\n-            self.stop = self.index + 1\n-            return self.index - 1, element_primary, element_residual, self.stop\n-      # Otherwise, split at the closest element boundary.\n-      # pylint: disable=round-builtin\n-      stop_index = (\n-          self.index + max(1, int(round(current_element_progress + keep))))\n-      if stop_index < self.stop:\n-        self.stop = stop_index\n-        return self.stop - 1, None, None, self.stop\n-    return None\n+      split = self._compute_split(\n+          self.index,\n+          current_element_progress,\n+          self.stop,\n+          fraction_of_remainder,\n+          total_buffer_size,\n+          allowed_split_points,\n+          self.receivers[0].try_split)\n+      if split:\n+        self.stop = split[-1]\n+      return split\n+\n+  @staticmethod\n+  def _compute_split(\n+      index,\n+      current_element_progress,\n+      stop,\n+      fraction_of_remainder,\n+      total_buffer_size,", "originalCommit": "773854cd6a7e2429f5c5e704f875aef89233879b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQxOTQ0OQ==", "url": "https://github.com/apache/beam/pull/11653#discussion_r423419449", "bodyText": "I believe it should be the total number of input element: \n  \n    \n      beam/model/fn-execution/src/main/proto/beam_fn_api.proto\n    \n    \n        Lines 383 to 386\n      in\n      cad0333\n    \n    \n    \n    \n\n        \n          \n           // (Required for GrpcRead operations) Number of total elements expected \n        \n\n        \n          \n           // to be sent to this GrpcRead operation, required to correctly account \n        \n\n        \n          \n           // for unreceived data when determining where to split. \n        \n\n        \n          \n           int64 estimated_input_elements = 2;", "author": "boyuanzz", "createdAt": "2020-05-12T02:00:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM0MjczNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkxNDc4OA==", "url": "https://github.com/apache/beam/pull/11653#discussion_r423914788", "bodyText": "It's the number of known input elements. What really matters is it's the size that fraction of remainder should be computed relative to.", "author": "robertwb", "createdAt": "2020-05-12T17:38:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM0MjczNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDczNTc0Nw==", "url": "https://github.com/apache/beam/pull/11653#discussion_r424735747", "bodyText": "The part I missed was that this is provided by the runner as part of the DesiredSplit, rather than something computed by the SDK itself. I didn't see that change. This all makes sense. Thanks!", "author": "lostluck", "createdAt": "2020-05-13T21:15:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM0MjczNw=="}], "type": "inlineReview"}]}