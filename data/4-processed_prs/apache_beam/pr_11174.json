{"pr_number": 11174, "pr_title": "[BEAM-7923] Pop failed transform when error is raised", "pr_createdAt": "2020-03-19T23:19:04Z", "pr_url": "https://github.com/apache/beam/pull/11174", "timeline": [{"oid": "3469e5dca131a5cd8f53f7174c4ae0310f71c097", "url": "https://github.com/apache/beam/commit/3469e5dca131a5cd8f53f7174c4ae0310f71c097", "message": "[BEAM-7923] Pop failed transform in CombineGlobally\n\n1. The problem: when the CombineGlobally raises the ValueError, it\nbreaks out the process of transform `apply` where the current transform\nhas been pushed into a transform stack, to be expanded and then popped out in the end.\nWithout the popping out, the pipeline will hold a current transform that\nis referring the failed CombineGlobally transform and never changes,\nmeaning the pipeline will not accept any new transforms after.\n2. It did not affect non-interactive usages because when the pipeline\nconstruction runs into an error, the user has to restart the whole\nprogram and nothing has been executed at the point the error is raised,\nso no side-effects.\n3. It did leave the pipeline in a dead state when the user constructs\npipelines in an interactive environment.\n4. The pop before raising the error allows the transform stack to\nrecover from the failed state.", "committedDate": "2020-03-19T23:16:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4MjI5Mw==", "url": "https://github.com/apache/beam/pull/11174#discussion_r395882293", "bodyText": "This is not the right place to pop this (internal) stack. Instead, we should popping from the stack in a finally clause of a try block that pushes to the stack. (Alternatively, we could manage the stack with a Python context, but that might be overkill.)", "author": "robertwb", "createdAt": "2020-03-20T20:47:16Z", "path": "sdks/python/apache_beam/transforms/core.py", "diffHunk": "@@ -1811,6 +1811,8 @@ def add_input_types(transform):\n       return view\n     else:\n       if pcoll.windowing.windowfn != GlobalWindows():\n+        # Remove the broken transform when running into value error.\n+        pcoll.pipeline.transforms_stack.pop()", "originalCommit": "3469e5dca131a5cd8f53f7174c4ae0310f71c097", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4MzE5Ng==", "url": "https://github.com/apache/beam/pull/11174#discussion_r395883196", "bodyText": "E.g. put this https://github.com/apache/beam/blob/release-2.19.0/sdks/python/apache_beam/pipeline.py#L330 in a finally clause of a try block that starts where it's pushed.", "author": "robertwb", "createdAt": "2020-03-20T20:49:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4MjI5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg5MDAyNg==", "url": "https://github.com/apache/beam/pull/11174#discussion_r395890026", "bodyText": "Yes, agree with it! I'll make the change.", "author": "KevinGG", "createdAt": "2020-03-20T21:07:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4MjI5Mw=="}], "type": "inlineReview"}, {"oid": "d3f8e4b23f7aaccdcd18e9799e1ebe61a9956b8e", "url": "https://github.com/apache/beam/commit/d3f8e4b23f7aaccdcd18e9799e1ebe61a9956b8e", "message": "Apply try-append-finally-pop logic to both transform apply and replace.", "committedDate": "2020-03-20T21:22:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkzMzYwNA==", "url": "https://github.com/apache/beam/pull/11174#discussion_r395933604", "bodyText": "This is a python newbie question. Does list.append() ever throw an exception? If so, should we move this out of the try block so that we don't pop() if list.append() fails?", "author": "davidyan74", "createdAt": "2020-03-20T23:41:39Z", "path": "sdks/python/apache_beam/pipeline.py", "diffHunk": "@@ -307,58 +307,61 @@ def _replace_if_needed(self, original_transform_node):\n           elif len(inputs) == 0:\n             input_node = pvalue.PBegin(self.pipeline)\n \n-          # We have to add the new AppliedTransform to the stack before expand()\n-          # and pop it out later to make sure that parts get added correctly.\n-          self.pipeline.transforms_stack.append(replacement_transform_node)\n-\n-          # Keeping the same label for the replaced node but recursively\n-          # removing labels of child transforms of original transform since they\n-          # will be replaced during the expand below. This is needed in case\n-          # the replacement contains children that have labels that conflicts\n-          # with labels of the children of the original.\n-          self.pipeline._remove_labels_recursively(original_transform_node)\n-\n-          new_output = replacement_transform.expand(input_node)\n-          assert isinstance(\n-              new_output, (dict, pvalue.PValue, pvalue.DoOutputsTuple))\n-\n-          if isinstance(new_output, pvalue.PValue):\n-            new_output.element_type = None\n-            self.pipeline._infer_result_type(\n-                replacement_transform, inputs, new_output)\n-\n-          if isinstance(new_output, dict):\n-            for new_tag, new_pcoll in new_output.items():\n-              replacement_transform_node.add_output(new_pcoll, new_tag)\n-          elif isinstance(new_output, pvalue.DoOutputsTuple):\n-            replacement_transform_node.add_output(\n-                new_output, new_output._main_tag)\n-          else:\n-            replacement_transform_node.add_output(new_output, new_output.tag)\n-\n-          # Recording updated outputs. This cannot be done in the same visitor\n-          # since if we dynamically update output type here, we'll run into\n-          # errors when visiting child nodes.\n-          #\n-          # NOTE: When replacing multiple outputs, the replacement PCollection\n-          # tags must have a matching tag in the original transform.\n-          if isinstance(new_output, pvalue.PValue):\n-            if not new_output.producer:\n-              new_output.producer = replacement_transform_node\n-            output_map[original_transform_node.outputs[new_output.tag]] = \\\n-                new_output\n-          elif isinstance(new_output, (pvalue.DoOutputsTuple, tuple)):\n-            for pcoll in new_output:\n-              if not pcoll.producer:\n-                pcoll.producer = replacement_transform_node\n-              output_map[original_transform_node.outputs[pcoll.tag]] = pcoll\n-          elif isinstance(new_output, dict):\n-            for tag, pcoll in new_output.items():\n-              if not pcoll.producer:\n-                pcoll.producer = replacement_transform_node\n-              output_map[original_transform_node.outputs[tag]] = pcoll\n-\n-          self.pipeline.transforms_stack.pop()\n+          try:\n+            # We have to add the new AppliedTransform to the stack before\n+            # expand() and pop it out later to make sure that parts get added\n+            # correctly.\n+            self.pipeline.transforms_stack.append(replacement_transform_node)", "originalCommit": "d3f8e4b23f7aaccdcd18e9799e1ebe61a9956b8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc0MjU0OA==", "url": "https://github.com/apache/beam/pull/11174#discussion_r396742548", "bodyText": "It wouldn't raise an error if it's still a list on the line, and if it's not a list (becomes a None or some other object) at the moment it causes an error, the finally block would error out too. So it's not necessary to exclude it from the try block.\nPutting it inside the try makes it a little bit more self-explained.", "author": "KevinGG", "createdAt": "2020-03-23T20:39:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkzMzYwNA=="}], "type": "inlineReview"}, {"oid": "9b67cd46172a5a537d84716c5a4eff56483e74f5", "url": "https://github.com/apache/beam/commit/9b67cd46172a5a537d84716c5a4eff56483e74f5", "message": "Fixed tests that passed in the past due to broken state when error is raised.", "committedDate": "2020-03-23T20:36:35Z", "type": "commit"}]}