{"pr_number": 10546, "pr_title": "[BEAM-9008] Add CassandraIO readAll method", "pr_createdAt": "2020-01-09T22:30:05Z", "pr_url": "https://github.com/apache/beam/pull/10546", "timeline": [{"oid": "e6e2a82264cab1bbbd6f6a2a8229ee9f89e61d8e", "url": "https://github.com/apache/beam/commit/e6e2a82264cab1bbbd6f6a2a8229ee9f89e61d8e", "message": "implementing CassandraIO.readAll", "committedDate": "2020-01-09T22:30:55Z", "type": "forcePushed"}, {"oid": "5679a3ffe38b628a5bef85062a1d435b7bcae798", "url": "https://github.com/apache/beam/commit/5679a3ffe38b628a5bef85062a1d435b7bcae798", "message": "implementing CassandraIO.readAll", "committedDate": "2020-01-09T22:36:04Z", "type": "forcePushed"}, {"oid": "3110e0334332eef17ae498124876486181ed5196", "url": "https://github.com/apache/beam/commit/3110e0334332eef17ae498124876486181ed5196", "message": "implementing CassandraIO.readAll", "committedDate": "2020-01-10T19:16:25Z", "type": "forcePushed"}, {"oid": "d85e6b95d64664af37148c792b35ff02abfd90f5", "url": "https://github.com/apache/beam/commit/d85e6b95d64664af37148c792b35ff02abfd90f5", "message": "implementing CassandraIO.readAll", "committedDate": "2020-01-10T20:21:45Z", "type": "forcePushed"}, {"oid": "c3a2f83fc21aca9eeafca4f98a993c4e2a2838fe", "url": "https://github.com/apache/beam/commit/c3a2f83fc21aca9eeafca4f98a993c4e2a2838fe", "message": "implementing CassandraIO.readAll", "committedDate": "2020-01-15T00:34:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcxNzI3Ng==", "url": "https://github.com/apache/beam/pull/10546#discussion_r365717276", "bodyText": "lowercase c", "author": "iemejia", "createdAt": "2020-01-13T09:55:38Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraConfig.java", "diffHunk": "@@ -0,0 +1,60 @@\n+package org.apache.beam.sdk.io.cassandra;\n+\n+import com.datastax.driver.core.Session;\n+import com.google.auto.value.AutoValue;\n+import java.io.Serializable;\n+import java.util.List;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+\n+@AutoValue\n+abstract class CassandraConfig<T> implements Serializable {\n+  @Nullable\n+  abstract ValueProvider<List<String>> hosts();\n+\n+  @Nullable\n+  abstract ValueProvider<String> query();\n+\n+  @Nullable\n+  abstract ValueProvider<Integer> port();\n+\n+  @Nullable\n+  abstract ValueProvider<String> keyspace();\n+\n+  @Nullable\n+  abstract ValueProvider<String> table();\n+\n+  @Nullable\n+  abstract ValueProvider<String> username();\n+\n+  @Nullable\n+  abstract ValueProvider<String> password();\n+\n+  @Nullable\n+  abstract ValueProvider<String> localDc();\n+\n+  @Nullable\n+  abstract ValueProvider<String> consistencyLevel();\n+\n+  @Nullable\n+  abstract SerializableFunction<Session, Mapper> mapperFactoryFn();\n+\n+  @Nullable\n+  abstract Class<T> entity();\n+\n+  public static <T> CassandraConfig<T> Create(ValueProvider<List<String>> hosts,", "originalCommit": "d85e6b95d64664af37148c792b35ff02abfd90f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk5NzkzNA==", "url": "https://github.com/apache/beam/pull/10546#discussion_r367997934", "bodyText": "Remove System.out.println", "author": "iemejia", "createdAt": "2020-01-17T15:37:30Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -1146,4 +918,297 @@ private void waitForFuturesToFinish() throws ExecutionException, InterruptedExce\n       }\n     }\n   }\n+\n+  /**\n+   * A {@link PTransform} to read data from Apache Cassandra. See {@link CassandraIO} for more\n+   * information on usage and configuration.\n+   */\n+  @AutoValue\n+  public abstract static class ReadAll<T>\n+      extends PTransform<PCollection<RingRange>, PCollection<T>> {\n+    @Nullable\n+    abstract ValueProvider<List<String>> hosts();\n+\n+    @Nullable\n+    abstract ValueProvider<String> query();\n+\n+    @Nullable\n+    abstract ValueProvider<Integer> port();\n+\n+    @Nullable\n+    abstract ValueProvider<String> keyspace();\n+\n+    @Nullable\n+    abstract ValueProvider<String> table();\n+\n+    @Nullable\n+    abstract Class<T> entity();\n+\n+    @Nullable\n+    abstract Coder<T> coder();\n+\n+    @Nullable\n+    abstract ValueProvider<String> username();\n+\n+    @Nullable\n+    abstract ValueProvider<String> password();\n+\n+    @Nullable\n+    abstract ValueProvider<String> localDc();\n+\n+    @Nullable\n+    abstract ValueProvider<String> consistencyLevel();\n+\n+    @Nullable\n+    abstract ValueProvider<Integer> splitCount();\n+\n+    @Nullable\n+    abstract SerializableFunction<Session, Mapper> mapperFactoryFn();\n+\n+    @Nullable\n+    abstract SerializableFunction<RingRange, Integer> groupingFn();\n+\n+    abstract Builder<T> builder();\n+\n+    /** Specify the hosts of the Apache Cassandra instances. */\n+    public ReadAll<T> withHosts(List<String> hosts) {\n+      checkArgument(hosts != null, \"hosts can not be null\");\n+      checkArgument(!hosts.isEmpty(), \"hosts can not be empty\");\n+      return withHosts(ValueProvider.StaticValueProvider.of(hosts));\n+    }\n+\n+    /** Specify the hosts of the Apache Cassandra instances. */\n+    public ReadAll<T> withHosts(ValueProvider<List<String>> hosts) {\n+      return builder().setHosts(hosts).build();\n+    }\n+\n+    /** Specify the port number of the Apache Cassandra instances. */\n+    public ReadAll<T> withPort(int port) {\n+      checkArgument(port > 0, \"port must be > 0, but was: %s\", port);\n+      return withPort(ValueProvider.StaticValueProvider.of(port));\n+    }\n+\n+    /** Specify the port number of the Apache Cassandra instances. */\n+    public ReadAll<T> withPort(ValueProvider<Integer> port) {\n+      return builder().setPort(port).build();\n+    }\n+\n+    /** Specify the Cassandra keyspace where to read data. */\n+    public ReadAll<T> withKeyspace(String keyspace) {\n+      checkArgument(keyspace != null, \"keyspace can not be null\");\n+      return withKeyspace(ValueProvider.StaticValueProvider.of(keyspace));\n+    }\n+\n+    /** Specify the Cassandra keyspace where to read data. */\n+    public ReadAll<T> withKeyspace(ValueProvider<String> keyspace) {\n+      return builder().setKeyspace(keyspace).build();\n+    }\n+\n+    /** Specify the Cassandra table where to read data. */\n+    public ReadAll<T> withTable(String table) {\n+      checkArgument(table != null, \"table can not be null\");\n+      return withTable(ValueProvider.StaticValueProvider.of(table));\n+    }\n+\n+    /** Specify the Cassandra table where to read data. */\n+    public ReadAll<T> withTable(ValueProvider<String> table) {\n+      return builder().setTable(table).build();\n+    }\n+\n+    /** Specify the query to read data. */\n+    public ReadAll<T> withQuery(String query) {\n+      checkArgument(query != null && query.length() > 0, \"query cannot be null\");\n+      return withQuery(ValueProvider.StaticValueProvider.of(query));\n+    }\n+\n+    /** Specify the query to read data. */\n+    public ReadAll<T> withQuery(ValueProvider<String> query) {\n+      return builder().setQuery(query).build();\n+    }\n+\n+    /**\n+     * Specify the entity class (annotated POJO). The {@link CassandraIO} will read the data and\n+     * convert the data as entity instances. The {@link PCollection} resulting from the read will\n+     * contains entity elements.\n+     */\n+    public ReadAll<T> withEntity(Class<T> entity) {\n+      checkArgument(entity != null, \"entity can not be null\");\n+      return builder().setEntity(entity).build();\n+    }\n+\n+    /** Specify the {@link Coder} used to serialize the entity in the {@link PCollection}. */\n+    public ReadAll<T> withCoder(Coder<T> coder) {\n+      checkArgument(coder != null, \"coder can not be null\");\n+      return builder().setCoder(coder).build();\n+    }\n+\n+    /** Specify the username for authentication. */\n+    public ReadAll<T> withUsername(String username) {\n+      checkArgument(username != null, \"username can not be null\");\n+      return withUsername(ValueProvider.StaticValueProvider.of(username));\n+    }\n+\n+    /** Specify the username for authentication. */\n+    public ReadAll<T> withUsername(ValueProvider<String> username) {\n+      return builder().setUsername(username).build();\n+    }\n+\n+    /** Specify the password used for authentication. */\n+    public ReadAll<T> withPassword(String password) {\n+      checkArgument(password != null, \"password can not be null\");\n+      return withPassword(ValueProvider.StaticValueProvider.of(password));\n+    }\n+\n+    /** Specify the password used for authentication. */\n+    public ReadAll<T> withPassword(ValueProvider<String> password) {\n+      return builder().setPassword(password).build();\n+    }\n+\n+    /** Specify the local DC used for the load balancing. */\n+    public ReadAll<T> withLocalDc(String localDc) {\n+      checkArgument(localDc != null, \"localDc can not be null\");\n+      return withLocalDc(ValueProvider.StaticValueProvider.of(localDc));\n+    }\n+\n+    /** Specify the local DC used for the load balancing. */\n+    public ReadAll<T> withLocalDc(ValueProvider<String> localDc) {\n+      return builder().setLocalDc(localDc).build();\n+    }\n+\n+    public ReadAll<T> withConsistencyLevel(String consistencyLevel) {\n+      checkArgument(consistencyLevel != null, \"consistencyLevel can not be null\");\n+      return withConsistencyLevel(ValueProvider.StaticValueProvider.of(consistencyLevel));\n+    }\n+\n+    public ReadAll<T> withConsistencyLevel(ValueProvider<String> consistencyLevel) {\n+      return builder().setConsistencyLevel(consistencyLevel).build();\n+    }\n+\n+    public ReadAll<T> withGroupingFn(SerializableFunction<RingRange, Integer> groupingFunction) {\n+      return builder().setGroupingFn(groupingFunction).build();\n+    }\n+\n+    public ReadAll<T> withSplitCount(ValueProvider<Integer> splitCount) {\n+      return builder().setSplitCount(splitCount).build();\n+    }\n+\n+    public ReadAll<T> withSlitCount(Integer splitCount) {\n+      checkArgument(splitCount != null, \"splitCount can not be null\");\n+      return withSplitCount(ValueProvider.StaticValueProvider.<Integer>of(splitCount));\n+    }\n+\n+    /**\n+     * A factory to create a specific {@link Mapper} for a given Cassandra Session. This is useful\n+     * to provide mappers that don't rely in Cassandra annotated objects.\n+     */\n+    public ReadAll<T> withMapperFactoryFn(SerializableFunction<Session, Mapper> mapperFactory) {\n+      checkArgument(\n+          mapperFactory != null,\n+          \"CassandraIO.withMapperFactory\" + \"(withMapperFactory) called with null value\");\n+      return builder().setMapperFactoryFn(mapperFactory).build();\n+    }\n+\n+    @Override\n+    public PCollection<T> expand(PCollection<RingRange> input) {\n+      checkArgument((hosts() != null && port() != null), \"WithHosts() and withPort() are required\");\n+      checkArgument(keyspace() != null, \"withKeyspace() is required\");\n+      checkArgument(table() != null, \"withTable() is required\");\n+      checkArgument(entity() != null, \"withEntity() is required\");\n+      checkArgument(coder() != null, \"withCoder() is required\");\n+      checkArgument(groupingFn() != null, \"GroupingFn OR splitCount must be set\");\n+\n+      try (Cluster cluster =\n+          getCluster(hosts(), port(), username(), password(), localDc(), consistencyLevel())) {\n+        return input\n+            .apply(\n+                \"mapping for the grouping function\",\n+                MapElements.into(\n+                        TypeDescriptors.kvs(\n+                            TypeDescriptors.integers(), TypeDescriptor.of(RingRange.class)))\n+                    .via(rr -> KV.of(groupingFn().apply(rr), rr)))\n+            .apply(\"Grouping by grouping function\", GroupByKey.create())\n+            .apply(\n+                \"mapping to key\",\n+                MapElements.into(TypeDescriptors.iterables(TypeDescriptor.of(RingRange.class)))\n+                    .via(kv -> kv.getValue()))\n+            .apply(\"ParDo\", ParDo.of(new QueryFn<>(getCassandraConfig())))\n+            .setCoder(coder());\n+      }\n+    }\n+\n+    CassandraConfig<T> getCassandraConfig() {\n+      return CassandraConfig.create(\n+          hosts(),\n+          query(),\n+          port(),\n+          keyspace(),\n+          table(),\n+          username(),\n+          password(),\n+          localDc(),\n+          consistencyLevel(),\n+          mapperFactoryFn(),\n+          entity());\n+    }\n+\n+    @AutoValue.Builder\n+    abstract static class Builder<T> {\n+      abstract Builder<T> setHosts(ValueProvider<List<String>> hosts);\n+\n+      abstract Builder<T> setQuery(ValueProvider<String> query);\n+\n+      abstract Builder<T> setPort(ValueProvider<Integer> port);\n+\n+      abstract Builder<T> setKeyspace(ValueProvider<String> keyspace);\n+\n+      abstract Builder<T> setTable(ValueProvider<String> table);\n+\n+      abstract Builder<T> setEntity(Class<T> entity);\n+\n+      abstract Optional<Class<T>> entity();\n+\n+      abstract Builder<T> setCoder(Coder<T> coder);\n+\n+      abstract Builder<T> setUsername(ValueProvider<String> username);\n+\n+      abstract Builder<T> setPassword(ValueProvider<String> password);\n+\n+      abstract Builder<T> setLocalDc(ValueProvider<String> localDc);\n+\n+      abstract Builder<T> setConsistencyLevel(ValueProvider<String> consistencyLevel);\n+\n+      abstract Builder<T> setSplitCount(ValueProvider<Integer> splitCount);\n+\n+      abstract ValueProvider<Integer> splitCount();\n+\n+      abstract Builder<T> setMapperFactoryFn(SerializableFunction<Session, Mapper> mapperFactoryFn);\n+\n+      abstract Optional<SerializableFunction<Session, Mapper>> mapperFactoryFn();\n+\n+      abstract Builder<T> setGroupingFn(SerializableFunction<RingRange, Integer> groupingFn);\n+\n+      abstract Optional<SerializableFunction<RingRange, Integer>> groupingFn();\n+\n+      abstract ReadAll<T> autoBuild();\n+\n+      public ReadAll<T> build() {\n+        if (!mapperFactoryFn().isPresent() && entity().isPresent()) {\n+          setMapperFactoryFn(new DefaultObjectMapperFactory(entity().get()));\n+        }\n+        System.out.println(this.groupingFn());", "originalCommit": "c3a2f83fc21aca9eeafca4f98a993c4e2a2838fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk5ODUzNA==", "url": "https://github.com/apache/beam/pull/10546#discussion_r367998534", "bodyText": "remove public and rename to ReadFn since the goal here would be just to Read", "author": "iemejia", "createdAt": "2020-01-17T15:38:37Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/QueryFn.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.cassandra;\n+\n+import com.datastax.driver.core.Cluster;\n+import com.datastax.driver.core.ColumnMetadata;\n+import com.datastax.driver.core.PreparedStatement;\n+import com.datastax.driver.core.ResultSet;\n+import com.datastax.driver.core.Session;\n+import com.datastax.driver.core.Token;\n+import java.util.Iterator;\n+import java.util.stream.Collectors;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class QueryFn<T> extends DoFn<Iterable<RingRange>, T> {", "originalCommit": "c3a2f83fc21aca9eeafca4f98a993c4e2a2838fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAxMTMzMg==", "url": "https://github.com/apache/beam/pull/10546#discussion_r368011332", "bodyText": "this can be the flatted version no? DoFn<RingRange, T> or actually the new Query objectr I mention above DoFn<CassandraQuery, T>.", "author": "iemejia", "createdAt": "2020-01-17T16:02:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk5ODUzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIzOTU3OQ==", "url": "https://github.com/apache/beam/pull/10546#discussion_r369239579", "bodyText": "I don't think we want this flattened here, the way I'm using readAll currently is I am hashing into groups of queries based on actual shard, which is owned by a core (in ScyllaDB), so grouping queries gives finer grained control over how much load we put on a core.  Someone using cassandra could use a similar split idea for making sure to limit the number of concurrent TokenRanges owned by the same node in Cassandra.", "author": "vmarquez", "createdAt": "2020-01-21T20:58:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk5ODUzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk5OTAxMg==", "url": "https://github.com/apache/beam/pull/10546#discussion_r367999012", "bodyText": "Replace CassandraIO.class with the new ReadFn.class", "author": "iemejia", "createdAt": "2020-01-17T15:39:36Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/QueryFn.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.cassandra;\n+\n+import com.datastax.driver.core.Cluster;\n+import com.datastax.driver.core.ColumnMetadata;\n+import com.datastax.driver.core.PreparedStatement;\n+import com.datastax.driver.core.ResultSet;\n+import com.datastax.driver.core.Session;\n+import com.datastax.driver.core.Token;\n+import java.util.Iterator;\n+import java.util.stream.Collectors;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class QueryFn<T> extends DoFn<Iterable<RingRange>, T> {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CassandraIO.class);", "originalCommit": "c3a2f83fc21aca9eeafca4f98a993c4e2a2838fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk5OTIzMg==", "url": "https://github.com/apache/beam/pull/10546#discussion_r367999232", "bodyText": "Remove public", "author": "iemejia", "createdAt": "2020-01-17T15:40:03Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/QueryFn.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.cassandra;\n+\n+import com.datastax.driver.core.Cluster;\n+import com.datastax.driver.core.ColumnMetadata;\n+import com.datastax.driver.core.PreparedStatement;\n+import com.datastax.driver.core.ResultSet;\n+import com.datastax.driver.core.Session;\n+import com.datastax.driver.core.Token;\n+import java.util.Iterator;\n+import java.util.stream.Collectors;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class QueryFn<T> extends DoFn<Iterable<RingRange>, T> {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CassandraIO.class);\n+\n+  private final CassandraConfig<T> read;\n+\n+  private transient Cluster cluster;\n+\n+  private transient Session session;\n+\n+  private String partitionKey;\n+\n+  public QueryFn(CassandraConfig<T> read) {", "originalCommit": "c3a2f83fc21aca9eeafca4f98a993c4e2a2838fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzk5OTUxNw==", "url": "https://github.com/apache/beam/pull/10546#discussion_r367999517", "bodyText": "nit: remove space", "author": "iemejia", "createdAt": "2020-01-17T15:40:35Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/QueryFn.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.cassandra;\n+\n+import com.datastax.driver.core.Cluster;\n+import com.datastax.driver.core.ColumnMetadata;\n+import com.datastax.driver.core.PreparedStatement;\n+import com.datastax.driver.core.ResultSet;\n+import com.datastax.driver.core.Session;\n+import com.datastax.driver.core.Token;\n+import java.util.Iterator;\n+import java.util.stream.Collectors;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class QueryFn<T> extends DoFn<Iterable<RingRange>, T> {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(CassandraIO.class);\n+\n+  private final CassandraConfig<T> read;\n+\n+  private transient Cluster cluster;\n+\n+  private transient Session session;\n+\n+  private String partitionKey;\n+\n+  public QueryFn(CassandraConfig<T> read) {\n+    this.read = read;\n+  }\n+\n+  @Setup\n+  public void setup() {\n+    this.cluster =\n+        CassandraIO.getCluster(\n+            read.hosts(),\n+            read.port(),\n+            read.username(),\n+            read.password(),\n+            read.localDc(),\n+            read.consistencyLevel());\n+    this.session = this.cluster.connect(read.keyspace().get());\n+    this.partitionKey =\n+        cluster.getMetadata().getKeyspace(read.keyspace().get()).getTable(read.table().get())\n+            .getPartitionKey().stream()\n+            .map(ColumnMetadata::getName)\n+            .collect(Collectors.joining(\",\"));\n+  }\n+\n+  public void teardown() {\n+    this.session.close();\n+    this.cluster.close();\n+  }\n+\n+  @ProcessElement\n+  public void processElement(@Element Iterable<RingRange> tokens, OutputReceiver<T> receiver) {\n+", "originalCommit": "c3a2f83fc21aca9eeafca4f98a993c4e2a2838fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAwMDk5Mw==", "url": "https://github.com/apache/beam/pull/10546#discussion_r368000993", "bodyText": "Since RingRange may end up been compared for equality too can you please add equals/hashcode too. And add a test that tests that Serializability and equality works in Beam we have the SerializableUtils.ensureSerializableRoundTrip that should make it.", "author": "iemejia", "createdAt": "2020-01-17T15:43:22Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/RingRange.java", "diffHunk": "@@ -17,10 +17,11 @@\n  */\n package org.apache.beam.sdk.io.cassandra;\n \n+import java.io.Serializable;\n import java.math.BigInteger;\n \n /** Models a Cassandra token range. */\n-final class RingRange {\n+final class RingRange implements Serializable {", "originalCommit": "c3a2f83fc21aca9eeafca4f98a993c4e2a2838fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYyNjI5OA==", "url": "https://github.com/apache/beam/pull/10546#discussion_r368626298", "bodyText": "Actually this should probably be done not for this class but for the CassandraQuery object", "author": "iemejia", "createdAt": "2020-01-20T16:09:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAwMDk5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAxMzY0MA==", "url": "https://github.com/apache/beam/pull/10546#discussion_r368013640", "bodyText": "Can you move this one to QueryFn since that's the only place where it is used.", "author": "iemejia", "createdAt": "2020-01-17T16:07:15Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -732,6 +505,35 @@ public T getCurrent() throws NoSuchElementException {\n     DELETE\n   }\n \n+  /**\n+   * Check if the current partitioner is the Murmur3 (default in Cassandra version newer than 2).\n+   */\n+  @VisibleForTesting\n+  static boolean isMurmur3Partitioner(Cluster cluster) {\n+    return MURMUR3PARTITIONER.equals(cluster.getMetadata().getPartitioner());\n+  }\n+\n+  static String generateRangeQuery(CassandraConfig spec, String partitionKey) {", "originalCommit": "c3a2f83fc21aca9eeafca4f98a993c4e2a2838fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAxMzc4MA==", "url": "https://github.com/apache/beam/pull/10546#discussion_r368013780", "bodyText": "Same for this one, move to QueryFn", "author": "iemejia", "createdAt": "2020-01-17T16:07:32Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -732,6 +505,35 @@ public T getCurrent() throws NoSuchElementException {\n     DELETE\n   }\n \n+  /**\n+   * Check if the current partitioner is the Murmur3 (default in Cassandra version newer than 2).\n+   */\n+  @VisibleForTesting\n+  static boolean isMurmur3Partitioner(Cluster cluster) {\n+    return MURMUR3PARTITIONER.equals(cluster.getMetadata().getPartitioner());\n+  }\n+\n+  static String generateRangeQuery(CassandraConfig spec, String partitionKey) {\n+    final String rangeFilter =\n+        Joiner.on(\" AND \")\n+            .skipNulls()\n+            .join(\n+                String.format(\"(token(%s) >= ?)\", partitionKey),\n+                String.format(\"(token(%s) < ?)\", partitionKey));\n+    final String query =\n+        (spec.query() == null)\n+            ? buildQuery(spec) + \" WHERE \" + rangeFilter\n+            : buildQuery(spec) + \" AND \" + rangeFilter;\n+    LOG.debug(\"CassandraIO generated query : {}\", query);\n+    return query;\n+  }\n+\n+  private static String buildQuery(CassandraConfig spec) {", "originalCommit": "c3a2f83fc21aca9eeafca4f98a993c4e2a2838fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYxOTE3Mg==", "url": "https://github.com/apache/beam/pull/10546#discussion_r368619172", "bodyText": "We should divide this object into two: One that has the parameters we need to query elements and other that has just the connection part. The goal is that the query part will be sufficient to do a read and to be splitted if necessary, with this we might have a richer set of options than just with RingRange for example to have ReadAll query multiple tables. This object probably should include: query, keyspace, table, entity and RingRange.", "author": "iemejia", "createdAt": "2020-01-20T15:55:43Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraConfig.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.cassandra;\n+\n+import com.datastax.driver.core.Session;\n+import com.google.auto.value.AutoValue;\n+import java.io.Serializable;\n+import java.util.List;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+\n+@AutoValue\n+abstract class CassandraConfig<T> implements Serializable {\n+  @Nullable\n+  abstract ValueProvider<List<String>> hosts();\n+\n+  @Nullable\n+  abstract ValueProvider<String> query();", "originalCommit": "c3a2f83fc21aca9eeafca4f98a993c4e2a2838fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg5ODM1Ng==", "url": "https://github.com/apache/beam/pull/10546#discussion_r405898356", "bodyText": "This class isn't used anymore, I will delete this.  All of the relevant information for a connection is now on the Read being passed in to ReadAll.", "author": "vmarquez", "createdAt": "2020-04-09T00:59:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYxOTE3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYyMjQ0NQ==", "url": "https://github.com/apache/beam/pull/10546#discussion_r368622445", "bodyText": "For maintenance coherence in DoFn based IOs we follow a pattern where the first part Creates the required object to query (the one I mentioned above), the second splits the query into multiples queries for each partition via a SplitFn extends DoFn and then with the result of such splits we do a read equivalent to current QueryFn. Can you refactor this segment to behave like that (with the query object I mentioned above).", "author": "iemejia", "createdAt": "2020-01-20T16:01:31Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -325,7 +359,58 @@ private CassandraIO() {}\n       checkArgument(entity() != null, \"withEntity() is required\");\n       checkArgument(coder() != null, \"withCoder() is required\");\n \n-      return input.apply(org.apache.beam.sdk.io.Read.from(new CassandraSource<>(this, null)));\n+      try (Cluster cluster =\n+          getCluster(hosts(), port(), username(), password(), localDc(), consistencyLevel())) {\n+        if (isMurmur3Partitioner(cluster)) {\n+          LOG.info(\"Murmur3Partitioner detected, splitting\");\n+\n+          List<BigInteger> tokens =", "originalCommit": "c3a2f83fc21aca9eeafca4f98a993c4e2a2838fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYyMzk5Ng==", "url": "https://github.com/apache/beam/pull/10546#discussion_r368623996", "bodyText": "We don't need this one anymore I think we can remove this class now as well as: CassandraIO.getRingFraction and CassandraIOTest.testRingFraction. Can you remove these too please.", "author": "iemejia", "createdAt": "2020-01-20T16:04:39Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -608,121 +470,32 @@ static double getRingFraction(List<TokenRange> tokenRanges) {\n       return ringFraction;\n     }\n \n-    /**\n-     * Check if the current partitioner is the Murmur3 (default in Cassandra version newer than 2).\n-     */\n-    @VisibleForTesting\n-    static boolean isMurmur3Partitioner(Cluster cluster) {\n-      return MURMUR3PARTITIONER.equals(cluster.getMetadata().getPartitioner());\n-    }\n-\n     /** Measure distance between two tokens. */\n     @VisibleForTesting\n     static BigInteger distance(BigInteger left, BigInteger right) {\n       return (right.compareTo(left) > 0)\n           ? right.subtract(left)\n           : right.subtract(left).add(SplitGenerator.getRangeSize(MURMUR3PARTITIONER));\n     }\n+  }\n \n-    /**\n-     * Represent a token range in Cassandra instance, wrapping the partition count, size and token\n-     * range.\n-     */\n-    @VisibleForTesting\n-    static class TokenRange {\n-      private final long partitionCount;\n-      private final long meanPartitionSize;\n-      private final BigInteger rangeStart;\n-      private final BigInteger rangeEnd;\n-\n-      TokenRange(\n-          long partitionCount, long meanPartitionSize, BigInteger rangeStart, BigInteger rangeEnd) {\n-        this.partitionCount = partitionCount;\n-        this.meanPartitionSize = meanPartitionSize;\n-        this.rangeStart = rangeStart;\n-        this.rangeEnd = rangeEnd;\n-      }\n-    }\n-\n-    private class CassandraReader extends BoundedSource.BoundedReader<T> {\n-      private final CassandraIO.CassandraSource<T> source;\n-      private Cluster cluster;\n-      private Session session;\n-      private Iterator<T> iterator;\n-      private T current;\n-\n-      CassandraReader(CassandraSource<T> source) {\n-        this.source = source;\n-      }\n-\n-      @Override\n-      public boolean start() {\n-        LOG.debug(\"Starting Cassandra reader\");\n-        cluster =\n-            getCluster(\n-                source.spec.hosts(),\n-                source.spec.port(),\n-                source.spec.username(),\n-                source.spec.password(),\n-                source.spec.localDc(),\n-                source.spec.consistencyLevel());\n-        session = cluster.connect(source.spec.keyspace().get());\n-        LOG.debug(\"Queries: \" + source.splitQueries);\n-        List<ResultSetFuture> futures = new ArrayList<>();\n-        for (String query : source.splitQueries) {\n-          futures.add(session.executeAsync(query));\n-        }\n-\n-        final Mapper<T> mapper = getMapper(session, source.spec.entity());\n-\n-        for (ResultSetFuture result : futures) {\n-          if (iterator == null) {\n-            iterator = mapper.map(result.getUninterruptibly());\n-          } else {\n-            iterator = Iterators.concat(iterator, mapper.map(result.getUninterruptibly()));\n-          }\n-        }\n-\n-        return advance();\n-      }\n-\n-      @Override\n-      public boolean advance() {\n-        if (iterator.hasNext()) {\n-          current = iterator.next();\n-          return true;\n-        }\n-        current = null;\n-        return false;\n-      }\n-\n-      @Override\n-      public void close() {\n-        LOG.debug(\"Closing Cassandra reader\");\n-        if (session != null) {\n-          session.close();\n-        }\n-        if (cluster != null) {\n-          cluster.close();\n-        }\n-      }\n-\n-      @Override\n-      public T getCurrent() throws NoSuchElementException {\n-        if (current == null) {\n-          throw new NoSuchElementException();\n-        }\n-        return current;\n-      }\n-\n-      @Override\n-      public CassandraIO.CassandraSource<T> getCurrentSource() {\n-        return source;\n-      }\n-\n-      private Mapper<T> getMapper(Session session, Class<T> enitity) {\n-        return source.spec.mapperFactoryFn().apply(session);\n-      }\n+  /**\n+   * Represent a token range in Cassandra instance, wrapping the partition count, size and token\n+   * range.\n+   */\n+  @VisibleForTesting\n+  static class TokenRange {", "originalCommit": "c3a2f83fc21aca9eeafca4f98a993c4e2a2838fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYyNjUxNQ==", "url": "https://github.com/apache/beam/pull/10546#discussion_r368626515", "bodyText": "nit: remove space", "author": "iemejia", "createdAt": "2020-01-20T16:09:46Z", "path": "sdks/java/io/cassandra/src/test/java/org/apache/beam/sdk/io/cassandra/CassandraIOTest.java", "diffHunk": "@@ -312,6 +298,52 @@ public void testRead() throws Exception {\n     pipeline.run();\n   }\n \n+  @Test\n+  public void testReadAll() {\n+", "originalCommit": "c3a2f83fc21aca9eeafca4f98a993c4e2a2838fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYyNjY0NQ==", "url": "https://github.com/apache/beam/pull/10546#discussion_r368626645", "bodyText": "nit: remove space", "author": "iemejia", "createdAt": "2020-01-20T16:10:03Z", "path": "sdks/java/io/cassandra/src/test/java/org/apache/beam/sdk/io/cassandra/CassandraIOTest.java", "diffHunk": "@@ -387,6 +420,7 @@ public Mapper apply(Session input) {\n \n     @Override\n     public Iterator map(ResultSet resultSet) {\n+", "originalCommit": "c3a2f83fc21aca9eeafca4f98a993c4e2a2838fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYyNzEzNg==", "url": "https://github.com/apache/beam/pull/10546#discussion_r368627136", "bodyText": "Once we have the SplitFn we should probably test this, actually we had a lot of historic issues with Splitting on this connector so please pay attention to ensure we don't introduce regressions.", "author": "iemejia", "createdAt": "2020-01-20T16:10:56Z", "path": "sdks/java/io/cassandra/src/test/java/org/apache/beam/sdk/io/cassandra/CassandraIOTest.java", "diffHunk": "@@ -466,40 +500,9 @@ public void testCustomMapperImplDelete() {\n     assertEquals(1, counter.intValue());\n   }\n \n-  @Test\n-  public void testSplit() throws Exception {\n-    PipelineOptions options = PipelineOptionsFactory.create();", "originalCommit": "c3a2f83fc21aca9eeafca4f98a993c4e2a2838fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI0NDkzNQ==", "url": "https://github.com/apache/beam/pull/10546#discussion_r369244935", "bodyText": "Hmm, if you know of relevant issues that we previously had, lmk, I will also look through the issue tracker to see if there were previous bugs.", "author": "vmarquez", "createdAt": "2020-01-21T21:11:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYyNzEzNg=="}], "type": "inlineReview"}, {"oid": "30fddc24c38e37932ada8e3e145ed4879e35b38b", "url": "https://github.com/apache/beam/commit/30fddc24c38e37932ada8e3e145ed4879e35b38b", "message": "Refactor to allow Read to use ReadAll, and ReadAll takes Read<T>", "committedDate": "2020-03-30T23:08:53Z", "type": "forcePushed"}, {"oid": "3f9cc6c95601c655fdc11720a18c75c78d2d78a4", "url": "https://github.com/apache/beam/commit/3f9cc6c95601c655fdc11720a18c75c78d2d78a4", "message": "Refactor to allow Read to use ReadAll, and ReadAll takes Read<T>", "committedDate": "2020-03-30T23:49:22Z", "type": "forcePushed"}, {"oid": "d9dd5d0f9be24dda4fa31c4642076e519c345aa2", "url": "https://github.com/apache/beam/commit/d9dd5d0f9be24dda4fa31c4642076e519c345aa2", "message": "Refactor to allow Read to use ReadAll, and ReadAll takes Read<T>", "committedDate": "2020-03-31T01:49:47Z", "type": "forcePushed"}, {"oid": "9f622c6f7c5c0962f996aa8074dfe11ad21b9f21", "url": "https://github.com/apache/beam/commit/9f622c6f7c5c0962f996aa8074dfe11ad21b9f21", "message": "Refactor to allow Read to use ReadAll, and ReadAll takes Read<T>", "committedDate": "2020-04-01T04:43:40Z", "type": "forcePushed"}, {"oid": "d9dd5d0f9be24dda4fa31c4642076e519c345aa2", "url": "https://github.com/apache/beam/commit/d9dd5d0f9be24dda4fa31c4642076e519c345aa2", "message": "Refactor to allow Read to use ReadAll, and ReadAll takes Read<T>", "committedDate": "2020-03-31T01:49:47Z", "type": "forcePushed"}, {"oid": "3feafb0fcbc940693cdcb29db620e181cc1af864", "url": "https://github.com/apache/beam/commit/3feafb0fcbc940693cdcb29db620e181cc1af864", "message": "Refactor to allow Read to use ReadAll, and ReadAll takes Read<T>", "committedDate": "2020-04-04T01:10:18Z", "type": "forcePushed"}, {"oid": "80f3ca7d7c53ac008ea25993d7061bfa626104e4", "url": "https://github.com/apache/beam/commit/80f3ca7d7c53ac008ea25993d7061bfa626104e4", "message": "Refactor to allow Read to use ReadAll, and ReadAll takes Read<T>", "committedDate": "2020-04-06T18:08:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg2NDg0MA==", "url": "https://github.com/apache/beam/pull/10546#discussion_r405864840", "bodyText": "We should produce a PCollection<Read> here instead and this splitting logic should be moved into the SplitFn function.", "author": "iemejia", "createdAt": "2020-04-08T23:06:31Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -318,15 +354,84 @@ private CassandraIO() {}\n       return builder().setMapperFactoryFn(mapperFactory).build();\n     }\n \n+    public Read<T> withRingRange(RingRange ringRange) {\n+      return withRingRange(ValueProvider.StaticValueProvider.of(ringRange));\n+    }\n+\n+    public Read<T> withRingRange(ValueProvider<RingRange> ringRange) {\n+      return builder().setRingRange(ringRange).build();\n+    }\n+\n     @Override\n     public PCollection<T> expand(PBegin input) {\n       checkArgument((hosts() != null && port() != null), \"WithHosts() and withPort() are required\");\n       checkArgument(keyspace() != null, \"withKeyspace() is required\");\n       checkArgument(table() != null, \"withTable() is required\");\n       checkArgument(entity() != null, \"withEntity() is required\");\n       checkArgument(coder() != null, \"withCoder() is required\");\n+      try (Cluster cluster =\n+          getCluster(hosts(), port(), username(), password(), localDc(), consistencyLevel())) {\n+        Integer splitCount = cluster.getMetadata().getAllHosts().size();\n+        if (minNumberOfSplits() != null && minNumberOfSplits().get() != null) {\n+          splitCount = minNumberOfSplits().get();\n+        }\n+        ReadAll<T> readAll =\n+            CassandraIO.<T>readAll()\n+                .withCoder(this.coder())\n+                .withConsistencyLevel(this.consistencyLevel())\n+                .withEntity(this.entity())\n+                .withHosts(this.hosts())\n+                .withKeyspace(this.keyspace())\n+                .withLocalDc(this.localDc())\n+                .withPort(this.port())\n+                .withPassword(this.password())\n+                .withQuery(this.query())\n+                .withTable(this.table())\n+                .withUsername(this.username())\n+                .withSplitCount(splitCount)\n+                .withMapperFactoryFn(this.mapperFactoryFn());\n \n-      return input.apply(org.apache.beam.sdk.io.Read.from(new CassandraSource<>(this, null)));\n+        if (isMurmur3Partitioner(cluster)) {\n+          LOG.info(\"Murmur3Partitioner detected, splitting\");\n+\n+          List<BigInteger> tokens =\n+              cluster.getMetadata().getTokenRanges().stream()\n+                  .map(tokenRange -> new BigInteger(tokenRange.getEnd().getValue().toString()))\n+                  .collect(Collectors.toList());\n+\n+          SplitGenerator splitGenerator =\n+              new SplitGenerator(cluster.getMetadata().getPartitioner());\n+\n+          List<Read<T>> splits =", "originalCommit": "80f3ca7d7c53ac008ea25993d7061bfa626104e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg2NTg3Mw==", "url": "https://github.com/apache/beam/pull/10546#discussion_r405865873", "bodyText": "private static class SplitFn<T> extends DoFn<Read<T>, Read<T>>\nNotice that in the second Read you should setup the RingRange so each individual Read can then be Read by a DoFn that knows how to read Read specifications with a RingRange.", "author": "iemejia", "createdAt": "2020-04-08T23:09:48Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -318,15 +354,84 @@ private CassandraIO() {}\n       return builder().setMapperFactoryFn(mapperFactory).build();\n     }\n \n+    public Read<T> withRingRange(RingRange ringRange) {\n+      return withRingRange(ValueProvider.StaticValueProvider.of(ringRange));\n+    }\n+\n+    public Read<T> withRingRange(ValueProvider<RingRange> ringRange) {\n+      return builder().setRingRange(ringRange).build();\n+    }\n+\n     @Override\n     public PCollection<T> expand(PBegin input) {\n       checkArgument((hosts() != null && port() != null), \"WithHosts() and withPort() are required\");\n       checkArgument(keyspace() != null, \"withKeyspace() is required\");\n       checkArgument(table() != null, \"withTable() is required\");\n       checkArgument(entity() != null, \"withEntity() is required\");\n       checkArgument(coder() != null, \"withCoder() is required\");\n+      try (Cluster cluster =\n+          getCluster(hosts(), port(), username(), password(), localDc(), consistencyLevel())) {\n+        Integer splitCount = cluster.getMetadata().getAllHosts().size();\n+        if (minNumberOfSplits() != null && minNumberOfSplits().get() != null) {\n+          splitCount = minNumberOfSplits().get();\n+        }\n+        ReadAll<T> readAll =\n+            CassandraIO.<T>readAll()\n+                .withCoder(this.coder())\n+                .withConsistencyLevel(this.consistencyLevel())\n+                .withEntity(this.entity())\n+                .withHosts(this.hosts())\n+                .withKeyspace(this.keyspace())\n+                .withLocalDc(this.localDc())\n+                .withPort(this.port())\n+                .withPassword(this.password())\n+                .withQuery(this.query())\n+                .withTable(this.table())\n+                .withUsername(this.username())\n+                .withSplitCount(splitCount)\n+                .withMapperFactoryFn(this.mapperFactoryFn());\n \n-      return input.apply(org.apache.beam.sdk.io.Read.from(new CassandraSource<>(this, null)));\n+        if (isMurmur3Partitioner(cluster)) {\n+          LOG.info(\"Murmur3Partitioner detected, splitting\");\n+\n+          List<BigInteger> tokens =\n+              cluster.getMetadata().getTokenRanges().stream()\n+                  .map(tokenRange -> new BigInteger(tokenRange.getEnd().getValue().toString()))\n+                  .collect(Collectors.toList());\n+\n+          SplitGenerator splitGenerator =\n+              new SplitGenerator(cluster.getMetadata().getPartitioner());\n+\n+          List<Read<T>> splits =\n+              splitGenerator.generateSplits(splitCount, tokens).stream()\n+                  .map(rr -> CassandraIO.<T>read().withRingRange(rr))\n+                  .collect(Collectors.toList());\n+\n+          return input.apply(\"Creating splits\", Create.of(splits)).apply(\"readAll\", readAll);\n+\n+        } else {\n+          LOG.warn(\n+              \"Only Murmur3Partitioner is supported for splitting, using an unique source for \"\n+                  + \"the read\");\n+          String partitioner = cluster.getMetadata().getPartitioner();\n+          RingRange totalRingRange =\n+              new RingRange(\n+                  SplitGenerator.getRangeMin(partitioner), SplitGenerator.getRangeMax(partitioner));\n+          return input\n+              .apply(Create.of(CassandraIO.<T>read().withRingRange(totalRingRange)))\n+              .apply(readAll)\n+              .setCoder(coder());\n+        }\n+      }\n+    }\n+\n+    private static class SplitFn<T> extends DoFn<List<RingRange>, Read<T>> {", "originalCommit": "80f3ca7d7c53ac008ea25993d7061bfa626104e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg2NjAzMA==", "url": "https://github.com/apache/beam/pull/10546#discussion_r405866030", "bodyText": "The split logic that is above should be here.", "author": "iemejia", "createdAt": "2020-04-08T23:10:19Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -318,15 +354,84 @@ private CassandraIO() {}\n       return builder().setMapperFactoryFn(mapperFactory).build();\n     }\n \n+    public Read<T> withRingRange(RingRange ringRange) {\n+      return withRingRange(ValueProvider.StaticValueProvider.of(ringRange));\n+    }\n+\n+    public Read<T> withRingRange(ValueProvider<RingRange> ringRange) {\n+      return builder().setRingRange(ringRange).build();\n+    }\n+\n     @Override\n     public PCollection<T> expand(PBegin input) {\n       checkArgument((hosts() != null && port() != null), \"WithHosts() and withPort() are required\");\n       checkArgument(keyspace() != null, \"withKeyspace() is required\");\n       checkArgument(table() != null, \"withTable() is required\");\n       checkArgument(entity() != null, \"withEntity() is required\");\n       checkArgument(coder() != null, \"withCoder() is required\");\n+      try (Cluster cluster =\n+          getCluster(hosts(), port(), username(), password(), localDc(), consistencyLevel())) {\n+        Integer splitCount = cluster.getMetadata().getAllHosts().size();\n+        if (minNumberOfSplits() != null && minNumberOfSplits().get() != null) {\n+          splitCount = minNumberOfSplits().get();\n+        }\n+        ReadAll<T> readAll =\n+            CassandraIO.<T>readAll()\n+                .withCoder(this.coder())\n+                .withConsistencyLevel(this.consistencyLevel())\n+                .withEntity(this.entity())\n+                .withHosts(this.hosts())\n+                .withKeyspace(this.keyspace())\n+                .withLocalDc(this.localDc())\n+                .withPort(this.port())\n+                .withPassword(this.password())\n+                .withQuery(this.query())\n+                .withTable(this.table())\n+                .withUsername(this.username())\n+                .withSplitCount(splitCount)\n+                .withMapperFactoryFn(this.mapperFactoryFn());\n \n-      return input.apply(org.apache.beam.sdk.io.Read.from(new CassandraSource<>(this, null)));\n+        if (isMurmur3Partitioner(cluster)) {\n+          LOG.info(\"Murmur3Partitioner detected, splitting\");\n+\n+          List<BigInteger> tokens =\n+              cluster.getMetadata().getTokenRanges().stream()\n+                  .map(tokenRange -> new BigInteger(tokenRange.getEnd().getValue().toString()))\n+                  .collect(Collectors.toList());\n+\n+          SplitGenerator splitGenerator =\n+              new SplitGenerator(cluster.getMetadata().getPartitioner());\n+\n+          List<Read<T>> splits =\n+              splitGenerator.generateSplits(splitCount, tokens).stream()\n+                  .map(rr -> CassandraIO.<T>read().withRingRange(rr))\n+                  .collect(Collectors.toList());\n+\n+          return input.apply(\"Creating splits\", Create.of(splits)).apply(\"readAll\", readAll);\n+\n+        } else {\n+          LOG.warn(\n+              \"Only Murmur3Partitioner is supported for splitting, using an unique source for \"\n+                  + \"the read\");\n+          String partitioner = cluster.getMetadata().getPartitioner();\n+          RingRange totalRingRange =\n+              new RingRange(\n+                  SplitGenerator.getRangeMin(partitioner), SplitGenerator.getRangeMax(partitioner));\n+          return input\n+              .apply(Create.of(CassandraIO.<T>read().withRingRange(totalRingRange)))\n+              .apply(readAll)\n+              .setCoder(coder());\n+        }\n+      }\n+    }\n+\n+    private static class SplitFn<T> extends DoFn<List<RingRange>, Read<T>> {\n+      @ProcessElement\n+      public void processElement(@Element List<RingRange> input, OutputReceiver<Read<T>> output) {\n+        for (RingRange rr : input) {", "originalCommit": "80f3ca7d7c53ac008ea25993d7061bfa626104e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg2NzUxMQ==", "url": "https://github.com/apache/beam/pull/10546#discussion_r405867511", "bodyText": "This transform should not have any attribute / with method, those come from the Read in the input PCollection.", "author": "iemejia", "createdAt": "2020-04-08T23:14:54Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -1170,4 +887,344 @@ private void waitForFuturesToFinish() throws ExecutionException, InterruptedExce\n       }\n     }\n   }\n+\n+  /**\n+   * A {@link PTransform} to read data from Apache Cassandra. See {@link CassandraIO} for more\n+   * information on usage and configuration.\n+   */\n+  @AutoValue\n+  public abstract static class ReadAll<T> extends PTransform<PCollection<Read<T>>, PCollection<T>> {\n+\n+    @Nullable\n+    abstract ValueProvider<List<String>> hosts();", "originalCommit": "80f3ca7d7c53ac008ea25993d7061bfa626104e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg3ODQ5OA==", "url": "https://github.com/apache/beam/pull/10546#discussion_r405878498", "bodyText": "For ReadAll to be useable we need to establish connection information in the setup phase of the QueryFn, so we'll need all this before a Read<T> comes in.   I'd also like to keep the API between ReadAll and Read similar so it's easy for the end user to switch a Read<T> with a ReadAll<T>, and just operating on a different type.", "author": "vmarquez", "createdAt": "2020-04-08T23:49:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg2NzUxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg2OTkxMQ==", "url": "https://github.com/apache/beam/pull/10546#discussion_r405869911", "bodyText": "The key point here is to apply for every read the split function and produce subsequent reads with RingRanges that then are Reshuffled and passed to a ParDo with the ReadFn function.", "author": "iemejia", "createdAt": "2020-04-08T23:22:09Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -1170,4 +887,344 @@ private void waitForFuturesToFinish() throws ExecutionException, InterruptedExce\n       }\n     }\n   }\n+\n+  /**\n+   * A {@link PTransform} to read data from Apache Cassandra. See {@link CassandraIO} for more\n+   * information on usage and configuration.\n+   */\n+  @AutoValue\n+  public abstract static class ReadAll<T> extends PTransform<PCollection<Read<T>>, PCollection<T>> {\n+\n+    @Nullable\n+    abstract ValueProvider<List<String>> hosts();\n+\n+    @Nullable\n+    abstract ValueProvider<String> query();\n+\n+    @Nullable\n+    abstract ValueProvider<Integer> port();\n+\n+    @Nullable\n+    abstract ValueProvider<String> keyspace();\n+\n+    @Nullable\n+    abstract ValueProvider<String> table();\n+\n+    @Nullable\n+    abstract Class<T> entity();\n+\n+    @Nullable\n+    abstract Coder<T> coder();\n+\n+    @Nullable\n+    abstract ValueProvider<String> username();\n+\n+    @Nullable\n+    abstract ValueProvider<String> password();\n+\n+    @Nullable\n+    abstract ValueProvider<String> localDc();\n+\n+    @Nullable\n+    abstract ValueProvider<String> consistencyLevel();\n+\n+    @Nullable\n+    abstract ValueProvider<Integer> splitCount();\n+\n+    @Nullable\n+    abstract SerializableFunction<Session, Mapper> mapperFactoryFn();\n+\n+    @Nullable\n+    abstract SerializableFunction<RingRange, Integer> groupingFn();\n+\n+    abstract Builder<T> builder();\n+\n+    /** Specify the hosts of the Apache Cassandra instances. */\n+    public ReadAll<T> withHosts(List<String> hosts) {\n+      checkArgument(hosts != null, \"hosts can not be null\");\n+      checkArgument(!hosts.isEmpty(), \"hosts can not be empty\");\n+      return withHosts(ValueProvider.StaticValueProvider.of(hosts));\n+    }\n+\n+    /** Specify the hosts of the Apache Cassandra instances. */\n+    public ReadAll<T> withHosts(ValueProvider<List<String>> hosts) {\n+      return builder().setHosts(hosts).build();\n+    }\n+\n+    /** Specify the port number of the Apache Cassandra instances. */\n+    public ReadAll<T> withPort(int port) {\n+      checkArgument(port > 0, \"port must be > 0, but was: %s\", port);\n+      return withPort(ValueProvider.StaticValueProvider.of(port));\n+    }\n+\n+    /** Specify the port number of the Apache Cassandra instances. */\n+    public ReadAll<T> withPort(ValueProvider<Integer> port) {\n+      return builder().setPort(port).build();\n+    }\n+\n+    /** Specify the Cassandra keyspace where to read data. */\n+    public ReadAll<T> withKeyspace(String keyspace) {\n+      checkArgument(keyspace != null, \"keyspace can not be null\");\n+      return withKeyspace(ValueProvider.StaticValueProvider.of(keyspace));\n+    }\n+\n+    /** Specify the Cassandra keyspace where to read data. */\n+    public ReadAll<T> withKeyspace(ValueProvider<String> keyspace) {\n+      return builder().setKeyspace(keyspace).build();\n+    }\n+\n+    /** Specify the Cassandra table where to read data. */\n+    public ReadAll<T> withTable(String table) {\n+      checkArgument(table != null, \"table can not be null\");\n+      return withTable(ValueProvider.StaticValueProvider.of(table));\n+    }\n+\n+    /** Specify the Cassandra table where to read data. */\n+    public ReadAll<T> withTable(ValueProvider<String> table) {\n+      return builder().setTable(table).build();\n+    }\n+\n+    /** Specify the query to read data. */\n+    public ReadAll<T> withQuery(String query) {\n+      checkArgument(query != null && query.length() > 0, \"query cannot be null\");\n+      return withQuery(ValueProvider.StaticValueProvider.of(query));\n+    }\n+\n+    /** Specify the query to read data. */\n+    public ReadAll<T> withQuery(ValueProvider<String> query) {\n+      return builder().setQuery(query).build();\n+    }\n+\n+    /**\n+     * Specify the entity class (annotated POJO). The {@link CassandraIO} will read the data and\n+     * convert the data as entity instances. The {@link PCollection} resulting from the read will\n+     * contains entity elements.\n+     */\n+    public ReadAll<T> withEntity(Class<T> entity) {\n+      checkArgument(entity != null, \"entity can not be null\");\n+      return builder().setEntity(entity).build();\n+    }\n+\n+    /** Specify the {@link Coder} used to serialize the entity in the {@link PCollection}. */\n+    public ReadAll<T> withCoder(Coder<T> coder) {\n+      checkArgument(coder != null, \"coder can not be null\");\n+      return builder().setCoder(coder).build();\n+    }\n+\n+    /** Specify the username for authentication. */\n+    public ReadAll<T> withUsername(String username) {\n+      checkArgument(username != null, \"username can not be null\");\n+      return withUsername(ValueProvider.StaticValueProvider.of(username));\n+    }\n+\n+    /** Specify the username for authentication. */\n+    public ReadAll<T> withUsername(ValueProvider<String> username) {\n+      return builder().setUsername(username).build();\n+    }\n+\n+    /** Specify the password used for authentication. */\n+    public ReadAll<T> withPassword(String password) {\n+      checkArgument(password != null, \"password can not be null\");\n+      return withPassword(ValueProvider.StaticValueProvider.of(password));\n+    }\n+\n+    /** Specify the password used for authentication. */\n+    public ReadAll<T> withPassword(ValueProvider<String> password) {\n+      return builder().setPassword(password).build();\n+    }\n+\n+    /** Specify the local DC used for the load balancing. */\n+    public ReadAll<T> withLocalDc(String localDc) {\n+      checkArgument(localDc != null, \"localDc can not be null\");\n+      return withLocalDc(ValueProvider.StaticValueProvider.of(localDc));\n+    }\n+\n+    /** Specify the local DC used for the load balancing. */\n+    public ReadAll<T> withLocalDc(ValueProvider<String> localDc) {\n+      return builder().setLocalDc(localDc).build();\n+    }\n+\n+    public ReadAll<T> withConsistencyLevel(String consistencyLevel) {\n+      checkArgument(consistencyLevel != null, \"consistencyLevel can not be null\");\n+      return withConsistencyLevel(ValueProvider.StaticValueProvider.of(consistencyLevel));\n+    }\n+\n+    public ReadAll<T> withConsistencyLevel(ValueProvider<String> consistencyLevel) {\n+      return builder().setConsistencyLevel(consistencyLevel).build();\n+    }\n+\n+    public ReadAll<T> withGroupingFn(SerializableFunction<RingRange, Integer> groupingFunction) {\n+      return builder().setGroupingFn(groupingFunction).build();\n+    }\n+\n+    public ReadAll<T> withSplitCount(ValueProvider<Integer> splitCount) {\n+      return builder().setSplitCount(splitCount).build();\n+    }\n+\n+    public ReadAll<T> withSplitCount(Integer splitCount) {\n+      checkArgument(splitCount != null, \"splitCount can not be null\");\n+      return withSplitCount(ValueProvider.StaticValueProvider.<Integer>of(splitCount));\n+    }\n+\n+    /**\n+     * A factory to create a specific {@link Mapper} for a given Cassandra Session. This is useful\n+     * to provide mappers that don't rely in Cassandra annotated objects.\n+     */\n+    public ReadAll<T> withMapperFactoryFn(SerializableFunction<Session, Mapper> mapperFactory) {\n+      checkArgument(\n+          mapperFactory != null,\n+          \"CassandraIO.withMapperFactory\" + \"(withMapperFactory) called with null value\");\n+      return builder().setMapperFactoryFn(mapperFactory).build();\n+    }\n+\n+    @Override\n+    public PCollection<T> expand(PCollection<Read<T>> input) {\n+      checkArgument((hosts() != null && port() != null), \"WithHosts() and withPort() are required\");\n+      checkArgument(keyspace() != null, \"withKeyspace() is required\");\n+      checkArgument(table() != null, \"withTable() is required\");\n+      checkArgument(entity() != null, \"withEntity() is required\");\n+      checkArgument(coder() != null, \"withCoder() is required\");\n+      checkArgument(groupingFn() != null, \"GroupingFn OR splitCount must be set\");\n+      try (Cluster cluster =", "originalCommit": "80f3ca7d7c53ac008ea25993d7061bfa626104e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg4MDA5MQ==", "url": "https://github.com/apache/beam/pull/10546#discussion_r405880091", "bodyText": "Not sure I understand what you mean here, some assistance would be appreciated. If I can elaborate on why I wrote it this way, I was trying to copy this:\nhttps://github.com/iemejia/beam/blob/a49a7561daf7c1f756b70b44b6d6ca8fe3afc8cb/sdks/java/io/solr/src/main/java/org/apache/beam/sdk/io/solr/SolrIO.java#L494\nbut instead of doing a Reshuffle.viaRandomKey() I wanted to do a GroupByKey, that way we can allow the user to control how the data is shuffled, for instance, to more evenly distribute load accross nodes by looking at the RingRange.  The FlattenGrouped is just to flatten out the Iterable that GroupByKey produces.  So this is the same overall design as the above code but gives the user a bit more flexibillity imho.", "author": "vmarquez", "createdAt": "2020-04-08T23:54:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg2OTkxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg3MDE0OQ==", "url": "https://github.com/apache/beam/pull/10546#discussion_r405870149", "bodyText": "You don't need this ReadAll ref here, Read is enough, ReadAll is the one that delegates to a normal Read.", "author": "iemejia", "createdAt": "2020-04-08T23:22:54Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/ReadFn.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.cassandra;\n+\n+import com.datastax.driver.core.Cluster;\n+import com.datastax.driver.core.ColumnMetadata;\n+import com.datastax.driver.core.PreparedStatement;\n+import com.datastax.driver.core.ResultSet;\n+import com.datastax.driver.core.Session;\n+import com.datastax.driver.core.Token;\n+import java.util.Iterator;\n+import java.util.stream.Collectors;\n+import org.apache.beam.sdk.io.cassandra.CassandraIO.Read;\n+import org.apache.beam.sdk.io.cassandra.CassandraIO.ReadAll;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Joiner;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class ReadFn<T> extends DoFn<Read<T>, T> {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ReadFn.class);\n+\n+  private transient Cluster cluster;\n+\n+  private transient Session session;\n+\n+  private final ReadAll<T> readAll;\n+\n+  public ReadFn(ReadAll<T> readAll) {\n+    this.readAll = readAll;", "originalCommit": "80f3ca7d7c53ac008ea25993d7061bfa626104e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg3NDg4Nw==", "url": "https://github.com/apache/beam/pull/10546#discussion_r405874887", "bodyText": "I'm fairly certain we need the ReadAll passed in here so we have the information on how to construct a connection on setup.\nIf you want I can spend more time getting performance data, but without caching the connection on setup I saw more than two orders of magnitude slowdown on just the CassandraIOTest.", "author": "vmarquez", "createdAt": "2020-04-08T23:37:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg3MDE0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg5NDAzOQ==", "url": "https://github.com/apache/beam/pull/10546#discussion_r405894039", "bodyText": "Caching connections is something we can do in a subsequent PR. Let's get first right the API and then optimize that part. We can cache connections at the class level on the ReadFn by creating some size limited pool of connections that we identify by some combination of parameters and we reuse if possible.", "author": "iemejia", "createdAt": "2020-04-09T00:43:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg3MDE0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg5NTE3OA==", "url": "https://github.com/apache/beam/pull/10546#discussion_r405895178", "bodyText": "@iemejia the tests don't even finish running locally after ten minutes when running CassandraIOTest if we don't cache the connection, I don't think it will ever finish running on the Jenkins server :)  I have already tried doing it without establishing a connection in setup, it's not workable.  The CassandraIOTest returns over 200 partitions to return 10 rows.  That means it has to establish over 20 connections and tear them down per row...", "author": "vmarquez", "createdAt": "2020-04-09T00:47:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg3MDE0OQ=="}], "type": "inlineReview"}, {"oid": "291759e176412e3818192cfc3168dcba8275d563", "url": "https://github.com/apache/beam/commit/291759e176412e3818192cfc3168dcba8275d563", "message": "removing some unused code for readAll", "committedDate": "2020-04-09T17:13:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NTQyNg==", "url": "https://github.com/apache/beam/pull/10546#discussion_r416975426", "bodyText": "This looks perfect!", "author": "iemejia", "createdAt": "2020-04-28T23:03:57Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -391,36 +393,57 @@ static Cluster getCluster(\n                 .withSplitCount(splitCount)\n                 .withMapperFactoryFn(this.mapperFactoryFn());\n \n-        if (isMurmur3Partitioner(cluster)) {\n-          LOG.info(\"Murmur3Partitioner detected, splitting\");\n-\n-          List<BigInteger> tokens =\n-              cluster.getMetadata().getTokenRanges().stream()\n-                  .map(tokenRange -> new BigInteger(tokenRange.getEnd().getValue().toString()))\n-                  .collect(Collectors.toList());\n-\n-          SplitGenerator splitGenerator =\n-              new SplitGenerator(cluster.getMetadata().getPartitioner());\n-\n-          List<Read<T>> splits =\n-              splitGenerator.generateSplits(splitCount, tokens).stream()\n-                  .map(rr -> CassandraIO.<T>read().withRingRange(rr))\n-                  .collect(Collectors.toList());\n+        return input\n+            .apply(Create.of(this))\n+            .apply(ParDo.of(new SplitFn<T>()))\n+            .setCoder(SerializableCoder.of(new TypeDescriptor<Read<T>>() {}))\n+            .apply(Reshuffle.viaRandomKey())\n+            .apply(readAll);\n+      }\n+    }\n \n-          return input.apply(\"Creating splits\", Create.of(splits)).apply(\"readAll\", readAll);\n+    private static class SplitFn<T> extends DoFn<Read<T>, Read<T>> {", "originalCommit": "335808e814aa3bc68de3cd84e08e1af5fc3704cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NjA0Mw==", "url": "https://github.com/apache/beam/pull/10546#discussion_r416976043", "bodyText": "Now we need to tackle this in two parts maybe, one is to implement the read with a ReadFn like method  and as a next step to get rid of all the methods on ReadAll to simplify it to its core.", "author": "iemejia", "createdAt": "2020-04-28T23:05:40Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -391,36 +393,57 @@ static Cluster getCluster(\n                 .withSplitCount(splitCount)\n                 .withMapperFactoryFn(this.mapperFactoryFn());\n \n-        if (isMurmur3Partitioner(cluster)) {\n-          LOG.info(\"Murmur3Partitioner detected, splitting\");\n-\n-          List<BigInteger> tokens =\n-              cluster.getMetadata().getTokenRanges().stream()\n-                  .map(tokenRange -> new BigInteger(tokenRange.getEnd().getValue().toString()))\n-                  .collect(Collectors.toList());\n-\n-          SplitGenerator splitGenerator =\n-              new SplitGenerator(cluster.getMetadata().getPartitioner());\n-\n-          List<Read<T>> splits =\n-              splitGenerator.generateSplits(splitCount, tokens).stream()\n-                  .map(rr -> CassandraIO.<T>read().withRingRange(rr))\n-                  .collect(Collectors.toList());\n+        return input\n+            .apply(Create.of(this))\n+            .apply(ParDo.of(new SplitFn<T>()))\n+            .setCoder(SerializableCoder.of(new TypeDescriptor<Read<T>>() {}))\n+            .apply(Reshuffle.viaRandomKey())\n+            .apply(readAll);", "originalCommit": "335808e814aa3bc68de3cd84e08e1af5fc3704cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f2c78f5a7883d835756b3cff1c65a5c8d91c4a82", "url": "https://github.com/apache/beam/commit/f2c78f5a7883d835756b3cff1c65a5c8d91c4a82", "message": "implementing CassandraIO.readAll", "committedDate": "2020-06-01T04:23:05Z", "type": "forcePushed"}, {"oid": "211c831f8912768d8dda93a877b2d13eb1634cda", "url": "https://github.com/apache/beam/commit/211c831f8912768d8dda93a877b2d13eb1634cda", "message": "implementing CassandraIO.readAll", "committedDate": "2020-06-01T17:09:04Z", "type": "forcePushed"}, {"oid": "a116abe3c944420c007e6d4afc914bf29267ae8d", "url": "https://github.com/apache/beam/commit/a116abe3c944420c007e6d4afc914bf29267ae8d", "message": "implementing CassandraIO.readAll", "committedDate": "2020-06-01T17:20:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg4Njg1Ng==", "url": "https://github.com/apache/beam/pull/10546#discussion_r433886856", "bodyText": "private", "author": "iemejia", "createdAt": "2020-06-02T13:45:42Z", "path": "sdks/java/io/cassandra/src/test/java/org/apache/beam/sdk/io/cassandra/CassandraIOTest.java", "diffHunk": "@@ -317,9 +302,70 @@ public void testRead() throws Exception {\n     PAssert.that(mapped.apply(\"Count occurrences per scientist\", Count.perKey()))\n         .satisfies(\n             input -> {\n+              int count = 0;\n               for (KV<String, Long> element : input) {\n+                count++;\n                 assertEquals(element.getKey(), NUM_ROWS / 10, element.getValue().longValue());\n               }\n+              assertEquals(11, count);\n+              return null;\n+            });\n+\n+    pipeline.run();\n+  }\n+\n+  CassandraIO.Read<Scientist> getReadWithRingRange(RingRange... rr) {", "originalCommit": "a116abe3c944420c007e6d4afc914bf29267ae8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg5NjM3Mg==", "url": "https://github.com/apache/beam/pull/10546#discussion_r433896372", "bodyText": "Can we move this method to the test class where it is used. I don't want to add Cassandra specific Metadata to the public API of RingRange with the hope this will help us evolve RingRange into a proper Restriction (future work out of the scope of this PR)\nCan you also please add a public static RingRange of(BigInteger start, BigInteger send) method and make the normal constructor private and refactor in every use.", "author": "iemejia", "createdAt": "2020-06-02T13:58:21Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/RingRange.java", "diffHunk": "@@ -55,4 +58,9 @@ public boolean isWrapping() {\n   public String toString() {\n     return String.format(\"(%s,%s]\", start.toString(), end.toString());\n   }\n+\n+  public static RingRange fromEncodedKey(Metadata metadata, ByteBuffer... bb) {", "originalCommit": "a116abe3c944420c007e6d4afc914bf29267ae8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDIzOTY4Ng==", "url": "https://github.com/apache/beam/pull/10546#discussion_r504239686", "bodyText": "Any reason not to do this? It looks like a convenience method that if you depend in other place (outside of Beam) you can easily move there.", "author": "iemejia", "createdAt": "2020-10-13T20:29:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg5NjM3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg5Njk5NA==", "url": "https://github.com/apache/beam/pull/10546#discussion_r433896994", "bodyText": "nit: For the tests can we assure that every reference to the tables and Scientist object usage follows this order: id, name, department.", "author": "iemejia", "createdAt": "2020-06-02T13:59:14Z", "path": "sdks/java/io/cassandra/src/test/java/org/apache/beam/sdk/io/cassandra/CassandraIOTest.java", "diffHunk": "@@ -191,39 +186,44 @@ private static void insertData() throws Exception {\n     LOG.info(\"Create Cassandra tables\");\n     session.execute(\n         String.format(\n-            \"CREATE TABLE IF NOT EXISTS %s.%s(person_id int, person_name text, PRIMARY KEY\"\n-                + \"(person_id));\",\n+            \"CREATE TABLE IF NOT EXISTS %s.%s(person_department text, person_id int, person_name text, PRIMARY KEY\"", "originalCommit": "a116abe3c944420c007e6d4afc914bf29267ae8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg5Nzg0OQ==", "url": "https://github.com/apache/beam/pull/10546#discussion_r433897849", "bodyText": "why TEMP ?", "author": "iemejia", "createdAt": "2020-06-02T14:00:13Z", "path": "sdks/java/io/cassandra/src/test/java/org/apache/beam/sdk/io/cassandra/CassandraIOTest.java", "diffHunk": "@@ -480,66 +527,22 @@ public void testCustomMapperImplDelete() {\n     assertEquals(1, counter.intValue());\n   }\n \n-  @Test\n-  public void testSplit() throws Exception {\n-    PipelineOptions options = PipelineOptionsFactory.create();\n-    CassandraIO.Read<Scientist> read =\n-        CassandraIO.<Scientist>read()\n-            .withHosts(Collections.singletonList(CASSANDRA_HOST))\n-            .withPort(cassandraPort)\n-            .withKeyspace(CASSANDRA_KEYSPACE)\n-            .withTable(CASSANDRA_TABLE)\n-            .withEntity(Scientist.class)\n-            .withCoder(SerializableCoder.of(Scientist.class));\n-\n-    // initialSource will be read without splitting (which does not happen in production)\n-    // so we need to provide splitQueries to avoid NPE in source.reader.start()\n-    String splitQuery = QueryBuilder.select().from(CASSANDRA_KEYSPACE, CASSANDRA_TABLE).toString();\n-    CassandraIO.CassandraSource<Scientist> initialSource =\n-        new CassandraIO.CassandraSource<>(read, Collections.singletonList(splitQuery));\n-    int desiredBundleSizeBytes = 2048;\n-    long estimatedSize = initialSource.getEstimatedSizeBytes(options);\n-    List<BoundedSource<Scientist>> splits = initialSource.split(desiredBundleSizeBytes, options);\n-    SourceTestUtils.assertSourcesEqualReferenceSource(initialSource, splits, options);\n-    float expectedNumSplitsloat =\n-        (float) initialSource.getEstimatedSizeBytes(options) / desiredBundleSizeBytes;\n-    long sum = 0;\n-\n-    for (BoundedSource<Scientist> subSource : splits) {\n-      sum += subSource.getEstimatedSizeBytes(options);\n-    }\n-\n-    // due to division and cast estimateSize != sum but will be close. Exact equals checked below\n-    assertEquals((long) (estimatedSize / splits.size()) * splits.size(), sum);\n-\n-    int expectedNumSplits = (int) Math.ceil(expectedNumSplitsloat);\n-    assertEquals(\"Wrong number of splits\", expectedNumSplits, splits.size());\n-    int emptySplits = 0;\n-    for (BoundedSource<Scientist> subSource : splits) {\n-      if (readFromSource(subSource, options).isEmpty()) {\n-        emptySplits += 1;\n-      }\n-    }\n-    assertThat(\n-        \"There are too many empty splits, parallelism is sub-optimal\",\n-        emptySplits,\n-        lessThan((int) (ACCEPTABLE_EMPTY_SPLITS_PERCENTAGE * splits.size())));\n-  }\n-\n   private List<Row> getRows(String table) {\n     ResultSet result =\n         session.execute(\n             String.format(\"select person_id,person_name from %s.%s\", CASSANDRA_KEYSPACE, table));\n     return result.all();\n   }\n \n+  // TEMP TEST", "originalCommit": "a116abe3c944420c007e6d4afc914bf29267ae8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMwNDc2Mw==", "url": "https://github.com/apache/beam/pull/10546#discussion_r434304763", "bodyText": "Ooops I think this was left in from when I was experimenting with something, I will remove.", "author": "vmarquez", "createdAt": "2020-06-03T04:45:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg5Nzg0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk5NjE5MA==", "url": "https://github.com/apache/beam/pull/10546#discussion_r433996190", "bodyText": "nit: move below we tend to preserve the lifecycle order of methods setup-startbundle-processElement-finishbundle-teardown", "author": "iemejia", "createdAt": "2020-06-02T16:03:39Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/ReadFn.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.cassandra;\n+\n+import com.datastax.driver.core.Cluster;\n+import com.datastax.driver.core.ColumnMetadata;\n+import com.datastax.driver.core.PreparedStatement;\n+import com.datastax.driver.core.ResultSet;\n+import com.datastax.driver.core.Session;\n+import com.datastax.driver.core.Token;\n+import java.util.Iterator;\n+import java.util.stream.Collectors;\n+import org.apache.beam.sdk.io.cassandra.CassandraIO.Read;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Joiner;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class ReadFn<T> extends DoFn<Read<T>, T> {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ReadFn.class);\n+\n+  private transient Cluster cluster;\n+\n+  private transient Session session;\n+\n+  private transient Read<T> lastRead;\n+\n+  @Teardown\n+  public void teardown() {", "originalCommit": "a116abe3c944420c007e6d4afc914bf29267ae8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDAwNTQyOA==", "url": "https://github.com/apache/beam/pull/10546#discussion_r434005428", "bodyText": "Remove", "author": "iemejia", "createdAt": "2020-06-02T16:17:04Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -326,7 +371,78 @@ private CassandraIO() {}\n       checkArgument(entity() != null, \"withEntity() is required\");\n       checkArgument(coder() != null, \"withCoder() is required\");\n \n-      return input.apply(org.apache.beam.sdk.io.Read.from(new CassandraSource<>(this, null)));\n+      ReadAll<T> readAll = CassandraIO.<T>readAll().withCoder(this.coder());\n+\n+      return input\n+          .apply(Create.of(this))\n+          .apply(ParDo.of(new SplitFn()))\n+          .setCoder(SerializableCoder.of(new TypeDescriptor<Read<T>>() {}))\n+          // .apply(Reshuffle.viaRandomKey())", "originalCommit": "a116abe3c944420c007e6d4afc914bf29267ae8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyMzA0MA==", "url": "https://github.com/apache/beam/pull/10546#discussion_r434123040", "bodyText": "move down into the apply, it makes the code more readable.", "author": "iemejia", "createdAt": "2020-06-02T19:23:05Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -326,7 +371,78 @@ private CassandraIO() {}\n       checkArgument(entity() != null, \"withEntity() is required\");\n       checkArgument(coder() != null, \"withCoder() is required\");\n \n-      return input.apply(org.apache.beam.sdk.io.Read.from(new CassandraSource<>(this, null)));\n+      ReadAll<T> readAll = CassandraIO.<T>readAll().withCoder(this.coder());", "originalCommit": "a116abe3c944420c007e6d4afc914bf29267ae8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyNDEwNw==", "url": "https://github.com/apache/beam/pull/10546#discussion_r434124107", "bodyText": "Move the Split as the first step of the ReadAll expansion so non advanced users (those who do not specify RingRange manually could get their code 'partitioned' correctly.", "author": "iemejia", "createdAt": "2020-06-02T19:25:07Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -326,7 +371,78 @@ private CassandraIO() {}\n       checkArgument(entity() != null, \"withEntity() is required\");\n       checkArgument(coder() != null, \"withCoder() is required\");\n \n-      return input.apply(org.apache.beam.sdk.io.Read.from(new CassandraSource<>(this, null)));\n+      ReadAll<T> readAll = CassandraIO.<T>readAll().withCoder(this.coder());\n+\n+      return input\n+          .apply(Create.of(this))\n+          .apply(ParDo.of(new SplitFn()))", "originalCommit": "a116abe3c944420c007e6d4afc914bf29267ae8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE1NDA0Nw==", "url": "https://github.com/apache/beam/pull/10546#discussion_r434154047", "bodyText": "Also add the \"Split\", name to the step", "author": "iemejia", "createdAt": "2020-06-02T20:23:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyNDEwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg1NTUyMw==", "url": "https://github.com/apache/beam/pull/10546#discussion_r436855523", "bodyText": "Move the Split as the first step of the ReadAll expansion so non advanced users (those who do not specify RingRange manually could get their code 'partitioned' correctly.\n\nI am not sure I understand what you mean here, could you explain more?", "author": "vmarquez", "createdAt": "2020-06-08T16:59:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyNDEwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyNjIzMg==", "url": "https://github.com/apache/beam/pull/10546#discussion_r434126232", "bodyText": "\ud83d\udc4d for making it public now!", "author": "iemejia", "createdAt": "2020-06-02T19:28:55Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/RingRange.java", "diffHunk": "@@ -17,10 +17,13 @@\n  */\n package org.apache.beam.sdk.io.cassandra;\n \n+import com.datastax.driver.core.Metadata;\n+import java.io.Serializable;\n import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n \n /** Models a Cassandra token range. */\n-final class RingRange {\n+public final class RingRange implements Serializable {", "originalCommit": "a116abe3c944420c007e6d4afc914bf29267ae8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyNzE5Ng==", "url": "https://github.com/apache/beam/pull/10546#discussion_r434127196", "bodyText": "We should add the equals() and hashCode() methods, those are now mandatory for the Set contract used in CassandraIO to be consistent.", "author": "iemejia", "createdAt": "2020-06-02T19:30:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyNjIzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE1MjQ0Nw==", "url": "https://github.com/apache/beam/pull/10546#discussion_r434152447", "bodyText": "Since it seems the new split implementation does not use isWrapping() please remove that method from the RingRange class", "author": "iemejia", "createdAt": "2020-06-02T20:20:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyNjIzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyOTI1OA==", "url": "https://github.com/apache/beam/pull/10546#discussion_r434129258", "bodyText": "Please also add @Experimental(Kind.SOURCE_SINK) to the class.", "author": "iemejia", "createdAt": "2020-06-02T19:34:34Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/RingRange.java", "diffHunk": "@@ -17,10 +17,13 @@\n  */\n package org.apache.beam.sdk.io.cassandra;\n \n+import com.datastax.driver.core.Metadata;\n+import java.io.Serializable;\n import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n \n /** Models a Cassandra token range. */\n-final class RingRange {\n+public final class RingRange implements Serializable {", "originalCommit": "a116abe3c944420c007e6d4afc914bf29267ae8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEzNTk1OA==", "url": "https://github.com/apache/beam/pull/10546#discussion_r434135958", "bodyText": "\ud83d\udc4f remove repeated and useless \ud83d\udc4f", "author": "iemejia", "createdAt": "2020-06-02T19:47:50Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -370,384 +488,16 @@ private CassandraIO() {}\n         return autoBuild();\n       }\n     }\n-  }\n-\n-  @VisibleForTesting\n-  static class CassandraSource<T> extends BoundedSource<T> {\n-    final Read<T> spec;\n-    final List<String> splitQueries;\n-    // split source ached size - can't be calculated when already split\n-    Long estimatedSize;\n-    private static final String MURMUR3PARTITIONER = \"org.apache.cassandra.dht.Murmur3Partitioner\";\n-\n-    CassandraSource(Read<T> spec, List<String> splitQueries) {\n-      this(spec, splitQueries, null);\n-    }\n-\n-    private CassandraSource(Read<T> spec, List<String> splitQueries, Long estimatedSize) {\n-      this.estimatedSize = estimatedSize;\n-      this.spec = spec;\n-      this.splitQueries = splitQueries;\n-    }\n-\n-    @Override\n-    public Coder<T> getOutputCoder() {\n-      return spec.coder();\n-    }\n-\n-    @Override\n-    public BoundedReader<T> createReader(PipelineOptions pipelineOptions) {\n-      return new CassandraReader(this);\n-    }\n-\n-    @Override\n-    public List<BoundedSource<T>> split(\n-        long desiredBundleSizeBytes, PipelineOptions pipelineOptions) {\n-      try (Cluster cluster =\n-          getCluster(\n-              spec.hosts(),\n-              spec.port(),\n-              spec.username(),\n-              spec.password(),\n-              spec.localDc(),\n-              spec.consistencyLevel())) {\n-        if (isMurmur3Partitioner(cluster)) {\n-          LOG.info(\"Murmur3Partitioner detected, splitting\");\n-          return splitWithTokenRanges(\n-              spec, desiredBundleSizeBytes, getEstimatedSizeBytes(pipelineOptions), cluster);\n-        } else {\n-          LOG.warn(\n-              \"Only Murmur3Partitioner is supported for splitting, using a unique source for \"\n-                  + \"the read\");\n-          return Collections.singletonList(\n-              new CassandraIO.CassandraSource<>(spec, Collections.singletonList(buildQuery(spec))));\n-        }\n-      }\n-    }\n-\n-    private static String buildQuery(Read spec) {\n-      return (spec.query() == null)\n-          ? String.format(\"SELECT * FROM %s.%s\", spec.keyspace().get(), spec.table().get())\n-          : spec.query().get().toString();\n-    }\n-\n-    /**\n-     * Compute the number of splits based on the estimated size and the desired bundle size, and\n-     * create several sources.\n-     */\n-    private List<BoundedSource<T>> splitWithTokenRanges(\n-        CassandraIO.Read<T> spec,\n-        long desiredBundleSizeBytes,\n-        long estimatedSizeBytes,\n-        Cluster cluster) {\n-      long numSplits =\n-          getNumSplits(desiredBundleSizeBytes, estimatedSizeBytes, spec.minNumberOfSplits());\n-      LOG.info(\"Number of desired splits is {}\", numSplits);\n-\n-      SplitGenerator splitGenerator = new SplitGenerator(cluster.getMetadata().getPartitioner());\n-      List<BigInteger> tokens =\n-          cluster.getMetadata().getTokenRanges().stream()\n-              .map(tokenRange -> new BigInteger(tokenRange.getEnd().getValue().toString()))\n-              .collect(Collectors.toList());\n-      List<List<RingRange>> splits = splitGenerator.generateSplits(numSplits, tokens);\n-      LOG.info(\"{} splits were actually generated\", splits.size());\n-\n-      final String partitionKey =\n-          cluster.getMetadata().getKeyspace(spec.keyspace().get()).getTable(spec.table().get())\n-              .getPartitionKey().stream()\n-              .map(ColumnMetadata::getName)\n-              .collect(Collectors.joining(\",\"));\n-\n-      List<TokenRange> tokenRanges =\n-          getTokenRanges(cluster, spec.keyspace().get(), spec.table().get());\n-      final long estimatedSize = getEstimatedSizeBytesFromTokenRanges(tokenRanges) / splits.size();\n-\n-      List<BoundedSource<T>> sources = new ArrayList<>();\n-      for (List<RingRange> split : splits) {\n-        List<String> queries = new ArrayList<>();\n-        for (RingRange range : split) {\n-          if (range.isWrapping()) {\n-            // A wrapping range is one that overlaps from the end of the partitioner range and its\n-            // start (ie : when the start token of the split is greater than the end token)\n-            // We need to generate two queries here : one that goes from the start token to the end\n-            // of\n-            // the partitioner range, and the other from the start of the partitioner range to the\n-            // end token of the split.\n-            queries.add(generateRangeQuery(spec, partitionKey, range.getStart(), null));\n-            // Generation of the second query of the wrapping range\n-            queries.add(generateRangeQuery(spec, partitionKey, null, range.getEnd()));\n-          } else {\n-            queries.add(generateRangeQuery(spec, partitionKey, range.getStart(), range.getEnd()));\n-          }\n-        }\n-        sources.add(new CassandraIO.CassandraSource<>(spec, queries, estimatedSize));\n-      }\n-      return sources;\n-    }\n-\n-    private static String generateRangeQuery(\n-        Read spec, String partitionKey, BigInteger rangeStart, BigInteger rangeEnd) {\n-      final String rangeFilter =\n-          Joiner.on(\" AND \")\n-              .skipNulls()\n-              .join(\n-                  rangeStart == null\n-                      ? null\n-                      : String.format(\"(token(%s) >= %d)\", partitionKey, rangeStart),\n-                  rangeEnd == null\n-                      ? null\n-                      : String.format(\"(token(%s) < %d)\", partitionKey, rangeEnd));\n-      final String query =\n-          (spec.query() == null)\n-              ? buildQuery(spec) + \" WHERE \" + rangeFilter\n-              : buildQuery(spec) + \" AND \" + rangeFilter;\n-      LOG.debug(\"CassandraIO generated query : {}\", query);\n-      return query;\n-    }\n-\n-    private static long getNumSplits(\n-        long desiredBundleSizeBytes,\n-        long estimatedSizeBytes,\n-        @Nullable ValueProvider<Integer> minNumberOfSplits) {\n-      long numSplits =\n-          desiredBundleSizeBytes > 0 ? (estimatedSizeBytes / desiredBundleSizeBytes) : 1;\n-      if (numSplits <= 0) {\n-        LOG.warn(\"Number of splits is less than 0 ({}), fallback to 1\", numSplits);\n-        numSplits = 1;\n-      }\n-      return minNumberOfSplits != null ? Math.max(numSplits, minNumberOfSplits.get()) : numSplits;\n-    }\n-\n-    /**\n-     * Returns cached estimate for split or if missing calculate size for whole table. Highly\n-     * innacurate if query is specified.\n-     *\n-     * @param pipelineOptions\n-     * @return\n-     */\n-    @Override\n-    public long getEstimatedSizeBytes(PipelineOptions pipelineOptions) {\n-      if (estimatedSize != null) {\n-        return estimatedSize;\n-      } else {\n-        try (Cluster cluster =\n-            getCluster(\n-                spec.hosts(),\n-                spec.port(),\n-                spec.username(),\n-                spec.password(),\n-                spec.localDc(),\n-                spec.consistencyLevel())) {\n-          if (isMurmur3Partitioner(cluster)) {\n-            try {\n-              List<TokenRange> tokenRanges =\n-                  getTokenRanges(cluster, spec.keyspace().get(), spec.table().get());\n-              this.estimatedSize = getEstimatedSizeBytesFromTokenRanges(tokenRanges);\n-              return this.estimatedSize;\n-            } catch (Exception e) {\n-              LOG.warn(\"Can't estimate the size\", e);\n-              return 0L;\n-            }\n-          } else {\n-            LOG.warn(\"Only Murmur3 partitioner is supported, can't estimate the size\");\n-            return 0L;\n-          }\n-        }\n-      }\n-    }\n-\n-    @VisibleForTesting\n-    static long getEstimatedSizeBytesFromTokenRanges(List<TokenRange> tokenRanges) {\n-      long size = 0L;\n-      for (TokenRange tokenRange : tokenRanges) {\n-        size = size + tokenRange.meanPartitionSize * tokenRange.partitionCount;\n-      }\n-      return Math.round(size / getRingFraction(tokenRanges));\n-    }\n \n-    @Override\n-    public void populateDisplayData(DisplayData.Builder builder) {\n-      super.populateDisplayData(builder);\n-      if (spec.hosts() != null) {\n-        builder.add(DisplayData.item(\"hosts\", spec.hosts().toString()));\n-      }\n-      if (spec.port() != null) {\n-        builder.add(DisplayData.item(\"port\", spec.port()));\n-      }\n-      builder.addIfNotNull(DisplayData.item(\"keyspace\", spec.keyspace()));\n-      builder.addIfNotNull(DisplayData.item(\"table\", spec.table()));\n-      builder.addIfNotNull(DisplayData.item(\"username\", spec.username()));\n-      builder.addIfNotNull(DisplayData.item(\"localDc\", spec.localDc()));\n-      builder.addIfNotNull(DisplayData.item(\"consistencyLevel\", spec.consistencyLevel()));\n-    }\n     // ------------- CASSANDRA SOURCE UTIL METHODS ---------------//\n \n-    /**\n-     * Gets the list of token ranges that a table occupies on a give Cassandra node.\n-     *\n-     * <p>NB: This method is compatible with Cassandra 2.1.5 and greater.\n-     */\n-    private static List<TokenRange> getTokenRanges(Cluster cluster, String keyspace, String table) {\n-      try (Session session = cluster.newSession()) {\n-        ResultSet resultSet =\n-            session.execute(\n-                \"SELECT range_start, range_end, partitions_count, mean_partition_size FROM \"\n-                    + \"system.size_estimates WHERE keyspace_name = ? AND table_name = ?\",\n-                keyspace,\n-                table);\n-\n-        ArrayList<TokenRange> tokenRanges = new ArrayList<>();\n-        for (Row row : resultSet) {\n-          TokenRange tokenRange =\n-              new TokenRange(\n-                  row.getLong(\"partitions_count\"),\n-                  row.getLong(\"mean_partition_size\"),\n-                  new BigInteger(row.getString(\"range_start\")),\n-                  new BigInteger(row.getString(\"range_end\")));\n-          tokenRanges.add(tokenRange);\n-        }\n-        // The table may not contain the estimates yet\n-        // or have partitions_count and mean_partition_size fields = 0\n-        // if the data was just inserted and the amount of data in the table was small.\n-        // This is very common situation during tests,\n-        // when we insert a few rows and immediately query them.\n-        // However, for tiny data sets the lack of size estimates is not a problem at all,\n-        // because we don't want to split tiny data anyways.\n-        // Therefore, we're not issuing a warning if the result set was empty\n-        // or mean_partition_size and partitions_count = 0.\n-        return tokenRanges;\n-      }\n-    }\n-\n-    /** Compute the percentage of token addressed compared with the whole tokens in the cluster. */\n-    @VisibleForTesting\n-    static double getRingFraction(List<TokenRange> tokenRanges) {\n-      double ringFraction = 0;\n-      for (TokenRange tokenRange : tokenRanges) {\n-        ringFraction =\n-            ringFraction\n-                + (distance(tokenRange.rangeStart, tokenRange.rangeEnd).doubleValue()\n-                    / SplitGenerator.getRangeSize(MURMUR3PARTITIONER).doubleValue());\n-      }\n-      return ringFraction;\n-    }\n-\n-    /**\n-     * Check if the current partitioner is the Murmur3 (default in Cassandra version newer than 2).\n-     */\n-    @VisibleForTesting\n-    static boolean isMurmur3Partitioner(Cluster cluster) {\n-      return MURMUR3PARTITIONER.equals(cluster.getMetadata().getPartitioner());\n-    }\n-\n     /** Measure distance between two tokens. */\n     @VisibleForTesting\n     static BigInteger distance(BigInteger left, BigInteger right) {\n       return (right.compareTo(left) > 0)\n           ? right.subtract(left)\n           : right.subtract(left).add(SplitGenerator.getRangeSize(MURMUR3PARTITIONER));\n     }\n-\n-    /**\n-     * Represent a token range in Cassandra instance, wrapping the partition count, size and token\n-     * range.\n-     */\n-    @VisibleForTesting\n-    static class TokenRange {", "originalCommit": "a116abe3c944420c007e6d4afc914bf29267ae8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE0MTkyMQ==", "url": "https://github.com/apache/beam/pull/10546#discussion_r434141921", "bodyText": "Better define Integer splitCount = read.minNumberOfSplits().get(); first, this will allow you to skip one server visit if it is already set up by the user.", "author": "iemejia", "createdAt": "2020-06-02T19:59:23Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -326,7 +371,78 @@ private CassandraIO() {}\n       checkArgument(entity() != null, \"withEntity() is required\");\n       checkArgument(coder() != null, \"withCoder() is required\");\n \n-      return input.apply(org.apache.beam.sdk.io.Read.from(new CassandraSource<>(this, null)));\n+      ReadAll<T> readAll = CassandraIO.<T>readAll().withCoder(this.coder());\n+\n+      return input\n+          .apply(Create.of(this))\n+          .apply(ParDo.of(new SplitFn()))\n+          .setCoder(SerializableCoder.of(new TypeDescriptor<Read<T>>() {}))\n+          // .apply(Reshuffle.viaRandomKey())\n+          .apply(readAll);\n+    }\n+\n+    private class SplitFn extends DoFn<Read<T>, Read<T>> {\n+\n+      @ProcessElement\n+      public void process(\n+          @Element CassandraIO.Read<T> read, OutputReceiver<Read<T>> outputReceiver) {\n+\n+        try (Cluster cluster =\n+            getCluster(\n+                read.hosts(),\n+                read.port(),\n+                read.username(),\n+                read.password(),\n+                read.localDc(),\n+                read.consistencyLevel())) {\n+          if (isMurmur3Partitioner(cluster)) {\n+            LOG.info(\"Murmur3Partitioner detected, splitting\");\n+\n+            List<BigInteger> tokens =\n+                cluster.getMetadata().getTokenRanges().stream()\n+                    .map(tokenRange -> new BigInteger(tokenRange.getEnd().getValue().toString()))\n+                    .collect(Collectors.toList());\n+            Integer splitCount = cluster.getMetadata().getAllHosts().size();", "originalCommit": "a116abe3c944420c007e6d4afc914bf29267ae8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE0MjQwMA==", "url": "https://github.com/apache/beam/pull/10546#discussion_r434142400", "bodyText": "Since we need Metadata below and getMetadata() makes a synchronized operation maybe obtain Metadata once and reuse after.", "author": "iemejia", "createdAt": "2020-06-02T20:00:14Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -326,7 +371,78 @@ private CassandraIO() {}\n       checkArgument(entity() != null, \"withEntity() is required\");\n       checkArgument(coder() != null, \"withCoder() is required\");\n \n-      return input.apply(org.apache.beam.sdk.io.Read.from(new CassandraSource<>(this, null)));\n+      ReadAll<T> readAll = CassandraIO.<T>readAll().withCoder(this.coder());\n+\n+      return input\n+          .apply(Create.of(this))\n+          .apply(ParDo.of(new SplitFn()))\n+          .setCoder(SerializableCoder.of(new TypeDescriptor<Read<T>>() {}))\n+          // .apply(Reshuffle.viaRandomKey())\n+          .apply(readAll);\n+    }\n+\n+    private class SplitFn extends DoFn<Read<T>, Read<T>> {\n+\n+      @ProcessElement\n+      public void process(\n+          @Element CassandraIO.Read<T> read, OutputReceiver<Read<T>> outputReceiver) {\n+\n+        try (Cluster cluster =\n+            getCluster(\n+                read.hosts(),\n+                read.port(),\n+                read.username(),\n+                read.password(),\n+                read.localDc(),\n+                read.consistencyLevel())) {\n+          if (isMurmur3Partitioner(cluster)) {\n+            LOG.info(\"Murmur3Partitioner detected, splitting\");\n+\n+            List<BigInteger> tokens =\n+                cluster.getMetadata().getTokenRanges().stream()", "originalCommit": "a116abe3c944420c007e6d4afc914bf29267ae8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE0NTkwMw==", "url": "https://github.com/apache/beam/pull/10546#discussion_r434145903", "bodyText": "Do you think this logic is already covered by the new implementation or that we cannot end up having issues on wrapping ranges e.g. repeated data. I can barely remember why we went into these 'hacks' I expected this to be a responsability of SplitGenerator?", "author": "iemejia", "createdAt": "2020-06-02T20:07:27Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -370,384 +488,16 @@ private CassandraIO() {}\n         return autoBuild();\n       }\n     }\n-  }\n-\n-  @VisibleForTesting\n-  static class CassandraSource<T> extends BoundedSource<T> {\n-    final Read<T> spec;\n-    final List<String> splitQueries;\n-    // split source ached size - can't be calculated when already split\n-    Long estimatedSize;\n-    private static final String MURMUR3PARTITIONER = \"org.apache.cassandra.dht.Murmur3Partitioner\";\n-\n-    CassandraSource(Read<T> spec, List<String> splitQueries) {\n-      this(spec, splitQueries, null);\n-    }\n-\n-    private CassandraSource(Read<T> spec, List<String> splitQueries, Long estimatedSize) {\n-      this.estimatedSize = estimatedSize;\n-      this.spec = spec;\n-      this.splitQueries = splitQueries;\n-    }\n-\n-    @Override\n-    public Coder<T> getOutputCoder() {\n-      return spec.coder();\n-    }\n-\n-    @Override\n-    public BoundedReader<T> createReader(PipelineOptions pipelineOptions) {\n-      return new CassandraReader(this);\n-    }\n-\n-    @Override\n-    public List<BoundedSource<T>> split(\n-        long desiredBundleSizeBytes, PipelineOptions pipelineOptions) {\n-      try (Cluster cluster =\n-          getCluster(\n-              spec.hosts(),\n-              spec.port(),\n-              spec.username(),\n-              spec.password(),\n-              spec.localDc(),\n-              spec.consistencyLevel())) {\n-        if (isMurmur3Partitioner(cluster)) {\n-          LOG.info(\"Murmur3Partitioner detected, splitting\");\n-          return splitWithTokenRanges(\n-              spec, desiredBundleSizeBytes, getEstimatedSizeBytes(pipelineOptions), cluster);\n-        } else {\n-          LOG.warn(\n-              \"Only Murmur3Partitioner is supported for splitting, using a unique source for \"\n-                  + \"the read\");\n-          return Collections.singletonList(\n-              new CassandraIO.CassandraSource<>(spec, Collections.singletonList(buildQuery(spec))));\n-        }\n-      }\n-    }\n-\n-    private static String buildQuery(Read spec) {\n-      return (spec.query() == null)\n-          ? String.format(\"SELECT * FROM %s.%s\", spec.keyspace().get(), spec.table().get())\n-          : spec.query().get().toString();\n-    }\n-\n-    /**\n-     * Compute the number of splits based on the estimated size and the desired bundle size, and\n-     * create several sources.\n-     */\n-    private List<BoundedSource<T>> splitWithTokenRanges(\n-        CassandraIO.Read<T> spec,\n-        long desiredBundleSizeBytes,\n-        long estimatedSizeBytes,\n-        Cluster cluster) {\n-      long numSplits =\n-          getNumSplits(desiredBundleSizeBytes, estimatedSizeBytes, spec.minNumberOfSplits());\n-      LOG.info(\"Number of desired splits is {}\", numSplits);\n-\n-      SplitGenerator splitGenerator = new SplitGenerator(cluster.getMetadata().getPartitioner());\n-      List<BigInteger> tokens =\n-          cluster.getMetadata().getTokenRanges().stream()\n-              .map(tokenRange -> new BigInteger(tokenRange.getEnd().getValue().toString()))\n-              .collect(Collectors.toList());\n-      List<List<RingRange>> splits = splitGenerator.generateSplits(numSplits, tokens);\n-      LOG.info(\"{} splits were actually generated\", splits.size());\n-\n-      final String partitionKey =\n-          cluster.getMetadata().getKeyspace(spec.keyspace().get()).getTable(spec.table().get())\n-              .getPartitionKey().stream()\n-              .map(ColumnMetadata::getName)\n-              .collect(Collectors.joining(\",\"));\n-\n-      List<TokenRange> tokenRanges =\n-          getTokenRanges(cluster, spec.keyspace().get(), spec.table().get());\n-      final long estimatedSize = getEstimatedSizeBytesFromTokenRanges(tokenRanges) / splits.size();\n-\n-      List<BoundedSource<T>> sources = new ArrayList<>();\n-      for (List<RingRange> split : splits) {\n-        List<String> queries = new ArrayList<>();\n-        for (RingRange range : split) {\n-          if (range.isWrapping()) {", "originalCommit": "a116abe3c944420c007e6d4afc914bf29267ae8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMxODg0Ng==", "url": "https://github.com/apache/beam/pull/10546#discussion_r434318846", "bodyText": "Hm, let me think about this.", "author": "vmarquez", "createdAt": "2020-06-03T05:38:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE0NTkwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDIzNjczNA==", "url": "https://github.com/apache/beam/pull/10546#discussion_r504236734", "bodyText": "What is the take on this? More concretely I really would like we could test corner cases of splitting like we had in the removed test methods like testEstimatedSizeBytesFromTokenRanges and the others.", "author": "iemejia", "createdAt": "2020-10-13T20:24:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE0NTkwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE0ODAzNQ==", "url": "https://github.com/apache/beam/pull/10546#discussion_r434148035", "bodyText": "You do not need to rebuild the object the current output here should be simply read.withRingRanges(new HashSet<>(rr));", "author": "iemejia", "createdAt": "2020-06-02T20:11:27Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -326,7 +371,78 @@ private CassandraIO() {}\n       checkArgument(entity() != null, \"withEntity() is required\");\n       checkArgument(coder() != null, \"withCoder() is required\");\n \n-      return input.apply(org.apache.beam.sdk.io.Read.from(new CassandraSource<>(this, null)));\n+      ReadAll<T> readAll = CassandraIO.<T>readAll().withCoder(this.coder());\n+\n+      return input\n+          .apply(Create.of(this))\n+          .apply(ParDo.of(new SplitFn()))\n+          .setCoder(SerializableCoder.of(new TypeDescriptor<Read<T>>() {}))\n+          // .apply(Reshuffle.viaRandomKey())\n+          .apply(readAll);\n+    }\n+\n+    private class SplitFn extends DoFn<Read<T>, Read<T>> {\n+\n+      @ProcessElement\n+      public void process(\n+          @Element CassandraIO.Read<T> read, OutputReceiver<Read<T>> outputReceiver) {\n+\n+        try (Cluster cluster =\n+            getCluster(\n+                read.hosts(),\n+                read.port(),\n+                read.username(),\n+                read.password(),\n+                read.localDc(),\n+                read.consistencyLevel())) {\n+          if (isMurmur3Partitioner(cluster)) {\n+            LOG.info(\"Murmur3Partitioner detected, splitting\");\n+\n+            List<BigInteger> tokens =\n+                cluster.getMetadata().getTokenRanges().stream()\n+                    .map(tokenRange -> new BigInteger(tokenRange.getEnd().getValue().toString()))\n+                    .collect(Collectors.toList());\n+            Integer splitCount = cluster.getMetadata().getAllHosts().size();\n+            if (read.minNumberOfSplits() != null && read.minNumberOfSplits().get() != null) {\n+              splitCount = read.minNumberOfSplits().get();\n+            }\n+\n+            SplitGenerator splitGenerator =\n+                new SplitGenerator(cluster.getMetadata().getPartitioner());\n+            splitGenerator\n+                .generateSplits(splitCount, tokens)\n+                .forEach(\n+                    rr ->\n+                        outputReceiver.output(\n+                            CassandraIO.<T>read()", "originalCommit": "a116abe3c944420c007e6d4afc914bf29267ae8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMxODUzMg==", "url": "https://github.com/apache/beam/pull/10546#discussion_r434318532", "bodyText": "I think we still need to create a new Read<T> because the SplitGenerator returns a List<List<RingRange>>, so each of the outer list will be a different Read, the inner List will be set to the RingRange.", "author": "vmarquez", "createdAt": "2020-06-03T05:37:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE0ODAzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE0ODQyNw==", "url": "https://github.com/apache/beam/pull/10546#discussion_r434148427", "bodyText": "same as above the output is the initial read with the modified RingRange otherwise you would need to copy/define all attributes.", "author": "iemejia", "createdAt": "2020-06-02T20:12:14Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -326,7 +371,78 @@ private CassandraIO() {}\n       checkArgument(entity() != null, \"withEntity() is required\");\n       checkArgument(coder() != null, \"withCoder() is required\");\n \n-      return input.apply(org.apache.beam.sdk.io.Read.from(new CassandraSource<>(this, null)));\n+      ReadAll<T> readAll = CassandraIO.<T>readAll().withCoder(this.coder());\n+\n+      return input\n+          .apply(Create.of(this))\n+          .apply(ParDo.of(new SplitFn()))\n+          .setCoder(SerializableCoder.of(new TypeDescriptor<Read<T>>() {}))\n+          // .apply(Reshuffle.viaRandomKey())\n+          .apply(readAll);\n+    }\n+\n+    private class SplitFn extends DoFn<Read<T>, Read<T>> {\n+\n+      @ProcessElement\n+      public void process(\n+          @Element CassandraIO.Read<T> read, OutputReceiver<Read<T>> outputReceiver) {\n+\n+        try (Cluster cluster =\n+            getCluster(\n+                read.hosts(),\n+                read.port(),\n+                read.username(),\n+                read.password(),\n+                read.localDc(),\n+                read.consistencyLevel())) {\n+          if (isMurmur3Partitioner(cluster)) {\n+            LOG.info(\"Murmur3Partitioner detected, splitting\");\n+\n+            List<BigInteger> tokens =\n+                cluster.getMetadata().getTokenRanges().stream()\n+                    .map(tokenRange -> new BigInteger(tokenRange.getEnd().getValue().toString()))\n+                    .collect(Collectors.toList());\n+            Integer splitCount = cluster.getMetadata().getAllHosts().size();\n+            if (read.minNumberOfSplits() != null && read.minNumberOfSplits().get() != null) {\n+              splitCount = read.minNumberOfSplits().get();\n+            }\n+\n+            SplitGenerator splitGenerator =\n+                new SplitGenerator(cluster.getMetadata().getPartitioner());\n+            splitGenerator\n+                .generateSplits(splitCount, tokens)\n+                .forEach(\n+                    rr ->\n+                        outputReceiver.output(\n+                            CassandraIO.<T>read()\n+                                .withRingRanges(new HashSet<>(rr))\n+                                .withCoder(coder())\n+                                .withConsistencyLevel(consistencyLevel())\n+                                .withEntity(entity())\n+                                .withHosts(hosts())\n+                                .withKeyspace(keyspace())\n+                                .withLocalDc(localDc())\n+                                .withPort(port())\n+                                .withPassword(password())\n+                                .withQuery(query())\n+                                .withTable(table())\n+                                .withUsername(username())\n+                                .withMapperFactoryFn(mapperFactoryFn())));\n+          } else {\n+            LOG.warn(\n+                \"Only Murmur3Partitioner is supported for splitting, using an unique source for \"\n+                    + \"the read\");\n+            String partitioner = cluster.getMetadata().getPartitioner();\n+            RingRange totalRingRange =\n+                new RingRange(\n+                    SplitGenerator.getRangeMin(partitioner),\n+                    SplitGenerator.getRangeMax(partitioner));\n+            outputReceiver.output(\n+                CassandraIO.<T>read()", "originalCommit": "a116abe3c944420c007e6d4afc914bf29267ae8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE1MTQwNg==", "url": "https://github.com/apache/beam/pull/10546#discussion_r434151406", "bodyText": "I think we are missing here the case when the user already defines his RingRange  in the input read, what should we do in that case? my intutition tells me we should just pass the read as an output without changes, but if we want to split his decision we should have the RingRange input in account somehow.", "author": "iemejia", "createdAt": "2020-06-02T20:18:13Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -326,7 +371,78 @@ private CassandraIO() {}\n       checkArgument(entity() != null, \"withEntity() is required\");\n       checkArgument(coder() != null, \"withCoder() is required\");\n \n-      return input.apply(org.apache.beam.sdk.io.Read.from(new CassandraSource<>(this, null)));\n+      ReadAll<T> readAll = CassandraIO.<T>readAll().withCoder(this.coder());\n+\n+      return input\n+          .apply(Create.of(this))\n+          .apply(ParDo.of(new SplitFn()))\n+          .setCoder(SerializableCoder.of(new TypeDescriptor<Read<T>>() {}))\n+          // .apply(Reshuffle.viaRandomKey())\n+          .apply(readAll);\n+    }\n+\n+    private class SplitFn extends DoFn<Read<T>, Read<T>> {\n+\n+      @ProcessElement\n+      public void process(\n+          @Element CassandraIO.Read<T> read, OutputReceiver<Read<T>> outputReceiver) {\n+\n+        try (Cluster cluster =\n+            getCluster(\n+                read.hosts(),\n+                read.port(),\n+                read.username(),\n+                read.password(),\n+                read.localDc(),\n+                read.consistencyLevel())) {\n+          if (isMurmur3Partitioner(cluster)) {", "originalCommit": "a116abe3c944420c007e6d4afc914bf29267ae8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMwMzc4NA==", "url": "https://github.com/apache/beam/pull/10546#discussion_r434303784", "bodyText": "Oops I did forget that, I will add. Good catch.", "author": "vmarquez", "createdAt": "2020-06-03T04:41:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE1MTQwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE1MzQ2MQ==", "url": "https://github.com/apache/beam/pull/10546#discussion_r434153461", "bodyText": "\"Reshuffle\"", "author": "iemejia", "createdAt": "2020-06-02T20:22:23Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -1170,4 +898,44 @@ private void waitForFuturesToFinish() throws ExecutionException, InterruptedExce\n       }\n     }\n   }\n+\n+  /**\n+   * A {@link PTransform} to read data from Apache Cassandra. See {@link CassandraIO} for more\n+   * information on usage and configuration.\n+   */\n+  @AutoValue\n+  public abstract static class ReadAll<T> extends PTransform<PCollection<Read<T>>, PCollection<T>> {\n+\n+    @Nullable\n+    abstract Coder<T> coder();\n+\n+    abstract ReadAll.Builder<T> builder();\n+\n+    /** Specify the {@link Coder} used to serialize the entity in the {@link PCollection}. */\n+    public ReadAll<T> withCoder(Coder<T> coder) {\n+      checkArgument(coder != null, \"coder can not be null\");\n+      return builder().setCoder(coder).build();\n+    }\n+\n+    @Override\n+    public PCollection<T> expand(PCollection<Read<T>> input) {\n+      checkArgument(coder() != null, \"withCoder() is required\");\n+      return input\n+          .apply(\"shuffle\", Reshuffle.viaRandomKey())", "originalCommit": "a116abe3c944420c007e6d4afc914bf29267ae8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE1MzU1Mg==", "url": "https://github.com/apache/beam/pull/10546#discussion_r434153552", "bodyText": "\"Read\"", "author": "iemejia", "createdAt": "2020-06-02T20:22:34Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -1170,4 +898,44 @@ private void waitForFuturesToFinish() throws ExecutionException, InterruptedExce\n       }\n     }\n   }\n+\n+  /**\n+   * A {@link PTransform} to read data from Apache Cassandra. See {@link CassandraIO} for more\n+   * information on usage and configuration.\n+   */\n+  @AutoValue\n+  public abstract static class ReadAll<T> extends PTransform<PCollection<Read<T>>, PCollection<T>> {\n+\n+    @Nullable\n+    abstract Coder<T> coder();\n+\n+    abstract ReadAll.Builder<T> builder();\n+\n+    /** Specify the {@link Coder} used to serialize the entity in the {@link PCollection}. */\n+    public ReadAll<T> withCoder(Coder<T> coder) {\n+      checkArgument(coder != null, \"coder can not be null\");\n+      return builder().setCoder(coder).build();\n+    }\n+\n+    @Override\n+    public PCollection<T> expand(PCollection<Read<T>> input) {\n+      checkArgument(coder() != null, \"withCoder() is required\");\n+      return input\n+          .apply(\"shuffle\", Reshuffle.viaRandomKey())\n+          .apply(\"read\", ParDo.of(new ReadFn<>()))\n+          .setCoder(this.coder());", "originalCommit": "a116abe3c944420c007e6d4afc914bf29267ae8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE4MDY4Nw==", "url": "https://github.com/apache/beam/pull/10546#discussion_r434180687", "bodyText": "coder should come from the input read", "author": "iemejia", "createdAt": "2020-06-02T21:17:31Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -1170,4 +898,44 @@ private void waitForFuturesToFinish() throws ExecutionException, InterruptedExce\n       }\n     }\n   }\n+\n+  /**\n+   * A {@link PTransform} to read data from Apache Cassandra. See {@link CassandraIO} for more\n+   * information on usage and configuration.\n+   */\n+  @AutoValue\n+  public abstract static class ReadAll<T> extends PTransform<PCollection<Read<T>>, PCollection<T>> {\n+\n+    @Nullable\n+    abstract Coder<T> coder();\n+\n+    abstract ReadAll.Builder<T> builder();\n+\n+    /** Specify the {@link Coder} used to serialize the entity in the {@link PCollection}. */\n+    public ReadAll<T> withCoder(Coder<T> coder) {\n+      checkArgument(coder != null, \"coder can not be null\");\n+      return builder().setCoder(coder).build();\n+    }\n+\n+    @Override\n+    public PCollection<T> expand(PCollection<Read<T>> input) {\n+      checkArgument(coder() != null, \"withCoder() is required\");\n+      return input\n+          .apply(\"shuffle\", Reshuffle.viaRandomKey())\n+          .apply(\"read\", ParDo.of(new ReadFn<>()))\n+          .setCoder(this.coder());", "originalCommit": "a116abe3c944420c007e6d4afc914bf29267ae8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE4MDk3Mg==", "url": "https://github.com/apache/beam/pull/10546#discussion_r434180972", "bodyText": "I am not sure if we need this, I assume the coder comes form the `Read input.", "author": "iemejia", "createdAt": "2020-06-02T21:17:58Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -1170,4 +898,44 @@ private void waitForFuturesToFinish() throws ExecutionException, InterruptedExce\n       }\n     }\n   }\n+\n+  /**\n+   * A {@link PTransform} to read data from Apache Cassandra. See {@link CassandraIO} for more\n+   * information on usage and configuration.\n+   */\n+  @AutoValue\n+  public abstract static class ReadAll<T> extends PTransform<PCollection<Read<T>>, PCollection<T>> {\n+\n+    @Nullable\n+    abstract Coder<T> coder();\n+\n+    abstract ReadAll.Builder<T> builder();\n+\n+    /** Specify the {@link Coder} used to serialize the entity in the {@link PCollection}. */\n+    public ReadAll<T> withCoder(Coder<T> coder) {", "originalCommit": "a116abe3c944420c007e6d4afc914bf29267ae8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg3MDUwOA==", "url": "https://github.com/apache/beam/pull/10546#discussion_r434870508", "bodyText": "I think we do, but am not sure.  You have to call setCoder on the PCollection itself, so we don't have access to the PCollection<Read<T>> at a point when we also have access to a single Read<T> (they are only supplied in the ReadFn which can't call setCoder on the PTransform).  Is my thinking correct?  I could be unaware of a different way to do this.", "author": "vmarquez", "createdAt": "2020-06-03T21:33:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE4MDk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDIyNjI0Nw==", "url": "https://github.com/apache/beam/pull/10546#discussion_r504226247", "bodyText": "Right not so beautiful but well we have to live with this \ud83d\udc4d", "author": "iemejia", "createdAt": "2020-10-13T20:10:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE4MDk3Mg=="}], "type": "inlineReview"}, {"oid": "cbd25ad65a2f87b6b9a6f8da5169b005af186ee6", "url": "https://github.com/apache/beam/commit/cbd25ad65a2f87b6b9a6f8da5169b005af186ee6", "message": "minor changes requested", "committedDate": "2020-06-08T17:00:17Z", "type": "forcePushed"}, {"oid": "4ab11508cfb4f037a1b8c86003b174ff6268c55d", "url": "https://github.com/apache/beam/commit/4ab11508cfb4f037a1b8c86003b174ff6268c55d", "message": "make query without ringrange work", "committedDate": "2020-07-16T00:30:22Z", "type": "forcePushed"}, {"oid": "f3377d98ca9ed9988a866f3671fe1106fbb437bd", "url": "https://github.com/apache/beam/commit/f3377d98ca9ed9988a866f3671fe1106fbb437bd", "message": "implementing CassandraIO.readAll", "committedDate": "2020-09-24T02:50:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzc4ODkzOQ==", "url": "https://github.com/apache/beam/pull/10546#discussion_r503788939", "bodyText": "Please move this one inside of SplitFn.\nYou would probably need some hack like:\nPCollection<Read<T>> split = (PCollection<Read<T>>) input.apply(\"Split\", ParDo.of(new SplitFn()));\nreturn split\n      .apply(\"Reshuffle\", Reshuffle.viaRandomKey())\n      .apply(\"Read\", ParDo.of(new ReadFn<>()));", "author": "iemejia", "createdAt": "2020-10-13T09:05:47Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -128,11 +126,18 @@\n \n   private CassandraIO() {}\n \n+  private static final String MURMUR3PARTITIONER = \"org.apache.cassandra.dht.Murmur3Partitioner\";", "originalCommit": "f3377d98ca9ed9988a866f3671fe1106fbb437bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDIyMDk0Nw==", "url": "https://github.com/apache/beam/pull/10546#discussion_r504220947", "bodyText": "I prefer to assign the result of getRingRanges to a Set and assign it to a variable to help ease potential debugging in the future.", "author": "iemejia", "createdAt": "2020-10-13T20:00:38Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -373,7 +419,86 @@ private CassandraIO() {}\n       checkArgument(entity() != null, \"withEntity() is required\");\n       checkArgument(coder() != null, \"withCoder() is required\");\n \n-      return input.apply(org.apache.beam.sdk.io.Read.from(new CassandraSource<>(this, null)));\n+      ReadAll<T> readAll = CassandraIO.readAll();\n+\n+      return input\n+          .apply(Create.of(this))\n+          .apply(\"Split\", ParDo.of(new SplitFn()))\n+          .setCoder(SerializableCoder.of(new TypeDescriptor<Read<T>>() {}))\n+          .apply(\"ReadAll\", readAll.withCoder(this.coder()));\n+    }\n+\n+    private class SplitFn extends DoFn<Read<T>, Read<T>> {\n+\n+      @ProcessElement\n+      public void process(\n+          @Element CassandraIO.Read<T> read, OutputReceiver<Read<T>> outputReceiver) {\n+        getRingRanges(read)", "originalCommit": "f3377d98ca9ed9988a866f3671fe1106fbb437bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDIyMTI0Mw==", "url": "https://github.com/apache/beam/pull/10546#discussion_r504221243", "bodyText": "return a Set (see comment above)", "author": "iemejia", "createdAt": "2020-10-13T20:01:10Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -373,7 +419,86 @@ private CassandraIO() {}\n       checkArgument(entity() != null, \"withEntity() is required\");\n       checkArgument(coder() != null, \"withCoder() is required\");\n \n-      return input.apply(org.apache.beam.sdk.io.Read.from(new CassandraSource<>(this, null)));\n+      ReadAll<T> readAll = CassandraIO.readAll();\n+\n+      return input\n+          .apply(Create.of(this))\n+          .apply(\"Split\", ParDo.of(new SplitFn()))\n+          .setCoder(SerializableCoder.of(new TypeDescriptor<Read<T>>() {}))\n+          .apply(\"ReadAll\", readAll.withCoder(this.coder()));\n+    }\n+\n+    private class SplitFn extends DoFn<Read<T>, Read<T>> {\n+\n+      @ProcessElement\n+      public void process(\n+          @Element CassandraIO.Read<T> read, OutputReceiver<Read<T>> outputReceiver) {\n+        getRingRanges(read)\n+            .forEach(\n+                rr ->\n+                    outputReceiver.output(\n+                        CassandraIO.<T>read()\n+                            .withRingRanges(new HashSet<>(rr))\n+                            .withCoder(coder())\n+                            .withConsistencyLevel(consistencyLevel())\n+                            .withEntity(entity())\n+                            .withHosts(hosts())\n+                            .withKeyspace(keyspace())\n+                            .withLocalDc(localDc())\n+                            .withPort(port())\n+                            .withPassword(password())\n+                            .withQuery(query())\n+                            .withTable(table())\n+                            .withUsername(username())\n+                            .withMapperFactoryFn(mapperFactoryFn())));\n+      }\n+\n+      Stream<Set<RingRange>> getRingRanges(Read<T> read) {", "originalCommit": "f3377d98ca9ed9988a866f3671fe1106fbb437bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDIyNDYyMQ==", "url": "https://github.com/apache/beam/pull/10546#discussion_r504224621", "bodyText": "If we change the type I suppose we can make this return simpler.", "author": "iemejia", "createdAt": "2020-10-13T20:07:32Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -373,7 +419,86 @@ private CassandraIO() {}\n       checkArgument(entity() != null, \"withEntity() is required\");\n       checkArgument(coder() != null, \"withCoder() is required\");\n \n-      return input.apply(org.apache.beam.sdk.io.Read.from(new CassandraSource<>(this, null)));\n+      ReadAll<T> readAll = CassandraIO.readAll();\n+\n+      return input\n+          .apply(Create.of(this))\n+          .apply(\"Split\", ParDo.of(new SplitFn()))\n+          .setCoder(SerializableCoder.of(new TypeDescriptor<Read<T>>() {}))\n+          .apply(\"ReadAll\", readAll.withCoder(this.coder()));\n+    }\n+\n+    private class SplitFn extends DoFn<Read<T>, Read<T>> {\n+\n+      @ProcessElement\n+      public void process(\n+          @Element CassandraIO.Read<T> read, OutputReceiver<Read<T>> outputReceiver) {\n+        getRingRanges(read)\n+            .forEach(\n+                rr ->\n+                    outputReceiver.output(\n+                        CassandraIO.<T>read()\n+                            .withRingRanges(new HashSet<>(rr))\n+                            .withCoder(coder())\n+                            .withConsistencyLevel(consistencyLevel())\n+                            .withEntity(entity())\n+                            .withHosts(hosts())\n+                            .withKeyspace(keyspace())\n+                            .withLocalDc(localDc())\n+                            .withPort(port())\n+                            .withPassword(password())\n+                            .withQuery(query())\n+                            .withTable(table())\n+                            .withUsername(username())\n+                            .withMapperFactoryFn(mapperFactoryFn())));\n+      }\n+\n+      Stream<Set<RingRange>> getRingRanges(Read<T> read) {\n+        if (read.ringRanges() == null || read.ringRanges().get() == null) {\n+          try (Cluster cluster =\n+              getCluster(\n+                  read.hosts(),\n+                  read.port(),\n+                  read.username(),\n+                  read.password(),\n+                  read.localDc(),\n+                  read.consistencyLevel())) {\n+            if (isMurmur3Partitioner(cluster)) {\n+              LOG.info(\"Murmur3Partitioner detected, splitting\");\n+              Integer splitCount;\n+              if (read.minNumberOfSplits() != null && read.minNumberOfSplits().get() != null) {\n+                splitCount = read.minNumberOfSplits().get();\n+              } else {\n+                splitCount = cluster.getMetadata().getAllHosts().size();\n+              }\n+              List<BigInteger> tokens =\n+                  cluster.getMetadata().getTokenRanges().stream()\n+                      .map(tokenRange -> new BigInteger(tokenRange.getEnd().getValue().toString()))\n+                      .collect(Collectors.toList());\n+              SplitGenerator splitGenerator =\n+                  new SplitGenerator(cluster.getMetadata().getPartitioner());\n+\n+              return splitGenerator.generateSplits(splitCount, tokens).stream()\n+                  .map(l -> new HashSet<>(l));\n+\n+            } else {\n+              LOG.warn(\n+                  \"Only Murmur3Partitioner is supported for splitting, using an unique source for \"\n+                      + \"the read\");\n+              String partitioner = cluster.getMetadata().getPartitioner();\n+              RingRange totalRingRange =\n+                  RingRange.of(\n+                      SplitGenerator.getRangeMin(partitioner),\n+                      SplitGenerator.getRangeMax(partitioner));\n+              return Collections.<Set<RingRange>>singleton(", "originalCommit": "f3377d98ca9ed9988a866f3671fe1106fbb437bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDIyNTU5Mw==", "url": "https://github.com/apache/beam/pull/10546#discussion_r504225593", "bodyText": "Can we move this one into SplitFn too since it is not used in other places.", "author": "iemejia", "createdAt": "2020-10-13T20:09:33Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -423,396 +550,20 @@ private CassandraIO() {}\n     }\n   }\n \n-  @VisibleForTesting\n-  static class CassandraSource<T> extends BoundedSource<T> {\n-    final Read<T> spec;\n-    final List<String> splitQueries;\n-    // split source ached size - can't be calculated when already split\n-    Long estimatedSize;\n-    private static final String MURMUR3PARTITIONER = \"org.apache.cassandra.dht.Murmur3Partitioner\";\n-\n-    CassandraSource(Read<T> spec, List<String> splitQueries) {\n-      this(spec, splitQueries, null);\n-    }\n-\n-    private CassandraSource(Read<T> spec, List<String> splitQueries, Long estimatedSize) {\n-      this.estimatedSize = estimatedSize;\n-      this.spec = spec;\n-      this.splitQueries = splitQueries;\n-    }\n-\n-    @Override\n-    public Coder<T> getOutputCoder() {\n-      return spec.coder();\n-    }\n-\n-    @Override\n-    public BoundedReader<T> createReader(PipelineOptions pipelineOptions) {\n-      return new CassandraReader(this);\n-    }\n-\n-    @Override\n-    public List<BoundedSource<T>> split(\n-        long desiredBundleSizeBytes, PipelineOptions pipelineOptions) {\n-      try (Cluster cluster =\n-          getCluster(\n-              spec.hosts(),\n-              spec.port(),\n-              spec.username(),\n-              spec.password(),\n-              spec.localDc(),\n-              spec.consistencyLevel(),\n-              spec.connectTimeout(),\n-              spec.readTimeout())) {\n-        if (isMurmur3Partitioner(cluster)) {\n-          LOG.info(\"Murmur3Partitioner detected, splitting\");\n-          return splitWithTokenRanges(\n-              spec, desiredBundleSizeBytes, getEstimatedSizeBytes(pipelineOptions), cluster);\n-        } else {\n-          LOG.warn(\n-              \"Only Murmur3Partitioner is supported for splitting, using a unique source for \"\n-                  + \"the read\");\n-          return Collections.singletonList(\n-              new CassandraIO.CassandraSource<>(spec, Collections.singletonList(buildQuery(spec))));\n-        }\n-      }\n-    }\n-\n-    private static String buildQuery(Read spec) {\n-      return (spec.query() == null)\n-          ? String.format(\"SELECT * FROM %s.%s\", spec.keyspace().get(), spec.table().get())\n-          : spec.query().get().toString();\n-    }\n-\n-    /**\n-     * Compute the number of splits based on the estimated size and the desired bundle size, and\n-     * create several sources.\n-     */\n-    private List<BoundedSource<T>> splitWithTokenRanges(\n-        CassandraIO.Read<T> spec,\n-        long desiredBundleSizeBytes,\n-        long estimatedSizeBytes,\n-        Cluster cluster) {\n-      long numSplits =\n-          getNumSplits(desiredBundleSizeBytes, estimatedSizeBytes, spec.minNumberOfSplits());\n-      LOG.info(\"Number of desired splits is {}\", numSplits);\n-\n-      SplitGenerator splitGenerator = new SplitGenerator(cluster.getMetadata().getPartitioner());\n-      List<BigInteger> tokens =\n-          cluster.getMetadata().getTokenRanges().stream()\n-              .map(tokenRange -> new BigInteger(tokenRange.getEnd().getValue().toString()))\n-              .collect(Collectors.toList());\n-      List<List<RingRange>> splits = splitGenerator.generateSplits(numSplits, tokens);\n-      LOG.info(\"{} splits were actually generated\", splits.size());\n-\n-      final String partitionKey =\n-          cluster.getMetadata().getKeyspace(spec.keyspace().get()).getTable(spec.table().get())\n-              .getPartitionKey().stream()\n-              .map(ColumnMetadata::getName)\n-              .collect(Collectors.joining(\",\"));\n-\n-      List<TokenRange> tokenRanges =\n-          getTokenRanges(cluster, spec.keyspace().get(), spec.table().get());\n-      final long estimatedSize = getEstimatedSizeBytesFromTokenRanges(tokenRanges) / splits.size();\n-\n-      List<BoundedSource<T>> sources = new ArrayList<>();\n-      for (List<RingRange> split : splits) {\n-        List<String> queries = new ArrayList<>();\n-        for (RingRange range : split) {\n-          if (range.isWrapping()) {\n-            // A wrapping range is one that overlaps from the end of the partitioner range and its\n-            // start (ie : when the start token of the split is greater than the end token)\n-            // We need to generate two queries here : one that goes from the start token to the end\n-            // of\n-            // the partitioner range, and the other from the start of the partitioner range to the\n-            // end token of the split.\n-            queries.add(generateRangeQuery(spec, partitionKey, range.getStart(), null));\n-            // Generation of the second query of the wrapping range\n-            queries.add(generateRangeQuery(spec, partitionKey, null, range.getEnd()));\n-          } else {\n-            queries.add(generateRangeQuery(spec, partitionKey, range.getStart(), range.getEnd()));\n-          }\n-        }\n-        sources.add(new CassandraIO.CassandraSource<>(spec, queries, estimatedSize));\n-      }\n-      return sources;\n-    }\n-\n-    private static String generateRangeQuery(\n-        Read spec, String partitionKey, BigInteger rangeStart, BigInteger rangeEnd) {\n-      final String rangeFilter =\n-          Joiner.on(\" AND \")\n-              .skipNulls()\n-              .join(\n-                  rangeStart == null\n-                      ? null\n-                      : String.format(\"(token(%s) >= %d)\", partitionKey, rangeStart),\n-                  rangeEnd == null\n-                      ? null\n-                      : String.format(\"(token(%s) < %d)\", partitionKey, rangeEnd));\n-      final String query =\n-          (spec.query() == null)\n-              ? buildQuery(spec) + \" WHERE \" + rangeFilter\n-              : buildQuery(spec) + \" AND \" + rangeFilter;\n-      LOG.debug(\"CassandraIO generated query : {}\", query);\n-      return query;\n-    }\n-\n-    private static long getNumSplits(\n-        long desiredBundleSizeBytes,\n-        long estimatedSizeBytes,\n-        @Nullable ValueProvider<Integer> minNumberOfSplits) {\n-      long numSplits =\n-          desiredBundleSizeBytes > 0 ? (estimatedSizeBytes / desiredBundleSizeBytes) : 1;\n-      if (numSplits <= 0) {\n-        LOG.warn(\"Number of splits is less than 0 ({}), fallback to 1\", numSplits);\n-        numSplits = 1;\n-      }\n-      return minNumberOfSplits != null ? Math.max(numSplits, minNumberOfSplits.get()) : numSplits;\n-    }\n-\n-    /**\n-     * Returns cached estimate for split or if missing calculate size for whole table. Highly\n-     * innacurate if query is specified.\n-     *\n-     * @param pipelineOptions\n-     * @return\n-     */\n-    @Override\n-    public long getEstimatedSizeBytes(PipelineOptions pipelineOptions) {\n-      if (estimatedSize != null) {\n-        return estimatedSize;\n-      } else {\n-        try (Cluster cluster =\n-            getCluster(\n-                spec.hosts(),\n-                spec.port(),\n-                spec.username(),\n-                spec.password(),\n-                spec.localDc(),\n-                spec.consistencyLevel(),\n-                spec.connectTimeout(),\n-                spec.readTimeout())) {\n-          if (isMurmur3Partitioner(cluster)) {\n-            try {\n-              List<TokenRange> tokenRanges =\n-                  getTokenRanges(cluster, spec.keyspace().get(), spec.table().get());\n-              this.estimatedSize = getEstimatedSizeBytesFromTokenRanges(tokenRanges);\n-              return this.estimatedSize;\n-            } catch (Exception e) {\n-              LOG.warn(\"Can't estimate the size\", e);\n-              return 0L;\n-            }\n-          } else {\n-            LOG.warn(\"Only Murmur3 partitioner is supported, can't estimate the size\");\n-            return 0L;\n-          }\n-        }\n-      }\n-    }\n-\n-    @VisibleForTesting\n-    static long getEstimatedSizeBytesFromTokenRanges(List<TokenRange> tokenRanges) {\n-      long size = 0L;\n-      for (TokenRange tokenRange : tokenRanges) {\n-        size = size + tokenRange.meanPartitionSize * tokenRange.partitionCount;\n-      }\n-      return Math.round(size / getRingFraction(tokenRanges));\n-    }\n-\n-    @Override\n-    public void populateDisplayData(DisplayData.Builder builder) {\n-      super.populateDisplayData(builder);\n-      if (spec.hosts() != null) {\n-        builder.add(DisplayData.item(\"hosts\", spec.hosts().toString()));\n-      }\n-      if (spec.port() != null) {\n-        builder.add(DisplayData.item(\"port\", spec.port()));\n-      }\n-      builder.addIfNotNull(DisplayData.item(\"keyspace\", spec.keyspace()));\n-      builder.addIfNotNull(DisplayData.item(\"table\", spec.table()));\n-      builder.addIfNotNull(DisplayData.item(\"username\", spec.username()));\n-      builder.addIfNotNull(DisplayData.item(\"localDc\", spec.localDc()));\n-      builder.addIfNotNull(DisplayData.item(\"consistencyLevel\", spec.consistencyLevel()));\n-    }\n-    // ------------- CASSANDRA SOURCE UTIL METHODS ---------------//\n-\n-    /**\n-     * Gets the list of token ranges that a table occupies on a give Cassandra node.\n-     *\n-     * <p>NB: This method is compatible with Cassandra 2.1.5 and greater.\n-     */\n-    private static List<TokenRange> getTokenRanges(Cluster cluster, String keyspace, String table) {\n-      try (Session session = cluster.newSession()) {\n-        ResultSet resultSet =\n-            session.execute(\n-                \"SELECT range_start, range_end, partitions_count, mean_partition_size FROM \"\n-                    + \"system.size_estimates WHERE keyspace_name = ? AND table_name = ?\",\n-                keyspace,\n-                table);\n-\n-        ArrayList<TokenRange> tokenRanges = new ArrayList<>();\n-        for (Row row : resultSet) {\n-          TokenRange tokenRange =\n-              new TokenRange(\n-                  row.getLong(\"partitions_count\"),\n-                  row.getLong(\"mean_partition_size\"),\n-                  new BigInteger(row.getString(\"range_start\")),\n-                  new BigInteger(row.getString(\"range_end\")));\n-          tokenRanges.add(tokenRange);\n-        }\n-        // The table may not contain the estimates yet\n-        // or have partitions_count and mean_partition_size fields = 0\n-        // if the data was just inserted and the amount of data in the table was small.\n-        // This is very common situation during tests,\n-        // when we insert a few rows and immediately query them.\n-        // However, for tiny data sets the lack of size estimates is not a problem at all,\n-        // because we don't want to split tiny data anyways.\n-        // Therefore, we're not issuing a warning if the result set was empty\n-        // or mean_partition_size and partitions_count = 0.\n-        return tokenRanges;\n-      }\n-    }\n-\n-    /** Compute the percentage of token addressed compared with the whole tokens in the cluster. */\n-    @VisibleForTesting\n-    static double getRingFraction(List<TokenRange> tokenRanges) {\n-      double ringFraction = 0;\n-      for (TokenRange tokenRange : tokenRanges) {\n-        ringFraction =\n-            ringFraction\n-                + (distance(tokenRange.rangeStart, tokenRange.rangeEnd).doubleValue()\n-                    / SplitGenerator.getRangeSize(MURMUR3PARTITIONER).doubleValue());\n-      }\n-      return ringFraction;\n-    }\n-\n-    /**\n-     * Check if the current partitioner is the Murmur3 (default in Cassandra version newer than 2).\n-     */\n-    @VisibleForTesting\n-    static boolean isMurmur3Partitioner(Cluster cluster) {\n-      return MURMUR3PARTITIONER.equals(cluster.getMetadata().getPartitioner());\n-    }\n-\n-    /** Measure distance between two tokens. */\n-    @VisibleForTesting\n-    static BigInteger distance(BigInteger left, BigInteger right) {\n-      return (right.compareTo(left) > 0)\n-          ? right.subtract(left)\n-          : right.subtract(left).add(SplitGenerator.getRangeSize(MURMUR3PARTITIONER));\n-    }\n-\n-    /**\n-     * Represent a token range in Cassandra instance, wrapping the partition count, size and token\n-     * range.\n-     */\n-    @VisibleForTesting\n-    static class TokenRange {\n-      private final long partitionCount;\n-      private final long meanPartitionSize;\n-      private final BigInteger rangeStart;\n-      private final BigInteger rangeEnd;\n-\n-      TokenRange(\n-          long partitionCount, long meanPartitionSize, BigInteger rangeStart, BigInteger rangeEnd) {\n-        this.partitionCount = partitionCount;\n-        this.meanPartitionSize = meanPartitionSize;\n-        this.rangeStart = rangeStart;\n-        this.rangeEnd = rangeEnd;\n-      }\n-    }\n-\n-    private class CassandraReader extends BoundedSource.BoundedReader<T> {\n-      private final CassandraIO.CassandraSource<T> source;\n-      private Cluster cluster;\n-      private Session session;\n-      private Iterator<T> iterator;\n-      private T current;\n-\n-      CassandraReader(CassandraSource<T> source) {\n-        this.source = source;\n-      }\n-\n-      @Override\n-      public boolean start() {\n-        LOG.debug(\"Starting Cassandra reader\");\n-        cluster =\n-            getCluster(\n-                source.spec.hosts(),\n-                source.spec.port(),\n-                source.spec.username(),\n-                source.spec.password(),\n-                source.spec.localDc(),\n-                source.spec.consistencyLevel(),\n-                source.spec.connectTimeout(),\n-                source.spec.readTimeout());\n-        session = cluster.connect(source.spec.keyspace().get());\n-        LOG.debug(\"Queries: \" + source.splitQueries);\n-        List<ResultSetFuture> futures = new ArrayList<>();\n-        for (String query : source.splitQueries) {\n-          futures.add(session.executeAsync(query));\n-        }\n-\n-        final Mapper<T> mapper = getMapper(session, source.spec.entity());\n-\n-        for (ResultSetFuture result : futures) {\n-          if (iterator == null) {\n-            iterator = mapper.map(result.getUninterruptibly());\n-          } else {\n-            iterator = Iterators.concat(iterator, mapper.map(result.getUninterruptibly()));\n-          }\n-        }\n-\n-        return advance();\n-      }\n-\n-      @Override\n-      public boolean advance() {\n-        if (iterator.hasNext()) {\n-          current = iterator.next();\n-          return true;\n-        }\n-        current = null;\n-        return false;\n-      }\n-\n-      @Override\n-      public void close() {\n-        LOG.debug(\"Closing Cassandra reader\");\n-        if (session != null) {\n-          session.close();\n-        }\n-        if (cluster != null) {\n-          cluster.close();\n-        }\n-      }\n-\n-      @Override\n-      public T getCurrent() throws NoSuchElementException {\n-        if (current == null) {\n-          throw new NoSuchElementException();\n-        }\n-        return current;\n-      }\n-\n-      @Override\n-      public CassandraIO.CassandraSource<T> getCurrentSource() {\n-        return source;\n-      }\n-\n-      private Mapper<T> getMapper(Session session, Class<T> enitity) {\n-        return source.spec.mapperFactoryFn().apply(session);\n-      }\n-    }\n-  }\n-\n   /** Specify the mutation type: either write or delete. */\n   public enum MutationType {\n     WRITE,\n     DELETE\n   }\n \n+  /**\n+   * Check if the current partitioner is the Murmur3 (default in Cassandra version newer than 2).\n+   */\n+  @VisibleForTesting\n+  static boolean isMurmur3Partitioner(Cluster cluster) {", "originalCommit": "f3377d98ca9ed9988a866f3671fe1106fbb437bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDIzMzI2OQ==", "url": "https://github.com/apache/beam/pull/10546#discussion_r504233269", "bodyText": "Why we have a different getCluster method than the one for the Read, also why were socket options removed there? I think we can maybe move this one outside to a sort of CassandraUtils package, but that's optional, however the use of the same method should not be changed by this PR if there is not a strong reason to do so.", "author": "iemejia", "createdAt": "2020-10-13T20:20:42Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -143,6 +148,36 @@ private CassandraIO() {}\n     return Write.<T>builder(MutationType.DELETE).build();\n   }\n \n+  /** Get a Cassandra cluster using hosts and port. */\n+  static Cluster getCluster(", "originalCommit": "f3377d98ca9ed9988a866f3671fe1106fbb437bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTAyNDYwNA==", "url": "https://github.com/apache/beam/pull/10546#discussion_r505024604", "bodyText": "@iemejia this was done accidentally after the merge.  I will remove it.", "author": "vmarquez", "createdAt": "2020-10-14T22:30:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDIzMzI2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI0MjcxNQ==", "url": "https://github.com/apache/beam/pull/10546#discussion_r504242715", "bodyText": "private static class SplitFn<T>", "author": "iemejia", "createdAt": "2020-10-13T20:35:32Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -373,7 +419,86 @@ private CassandraIO() {}\n       checkArgument(entity() != null, \"withEntity() is required\");\n       checkArgument(coder() != null, \"withCoder() is required\");\n \n-      return input.apply(org.apache.beam.sdk.io.Read.from(new CassandraSource<>(this, null)));\n+      ReadAll<T> readAll = CassandraIO.readAll();\n+\n+      return input\n+          .apply(Create.of(this))\n+          .apply(\"Split\", ParDo.of(new SplitFn()))\n+          .setCoder(SerializableCoder.of(new TypeDescriptor<Read<T>>() {}))\n+          .apply(\"ReadAll\", readAll.withCoder(this.coder()));\n+    }\n+\n+    private class SplitFn extends DoFn<Read<T>, Read<T>> {", "originalCommit": "f3377d98ca9ed9988a866f3671fe1106fbb437bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI1ODY5NA==", "url": "https://github.com/apache/beam/pull/10546#discussion_r504258694", "bodyText": "Move this up before the withCoder method", "author": "iemejia", "createdAt": "2020-10-13T21:07:02Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -1281,4 +1032,44 @@ private void waitForFuturesToFinish() throws ExecutionException, InterruptedExce\n       }\n     }\n   }\n+\n+  /**\n+   * A {@link PTransform} to read data from Apache Cassandra. See {@link CassandraIO} for more\n+   * information on usage and configuration.\n+   */\n+  @AutoValue\n+  public abstract static class ReadAll<T> extends PTransform<PCollection<Read<T>>, PCollection<T>> {\n+\n+    @Nullable\n+    abstract Coder<T> coder();\n+\n+    abstract ReadAll.Builder<T> builder();\n+\n+    /** Specify the {@link Coder} used to serialize the entity in the {@link PCollection}. */\n+    public ReadAll<T> withCoder(Coder<T> coder) {\n+      checkArgument(coder != null, \"coder can not be null\");\n+      return builder().setCoder(coder).build();\n+    }\n+\n+    @Override\n+    public PCollection<T> expand(PCollection<Read<T>> input) {\n+      checkArgument(coder() != null, \"withCoder() is required\");\n+      return input\n+          .apply(\"Reshuffle\", Reshuffle.viaRandomKey())\n+          .apply(\"Read\", ParDo.of(new ReadFn<>()))\n+          .setCoder(this.coder());\n+    }\n+\n+    @AutoValue.Builder\n+    abstract static class Builder<T> {", "originalCommit": "f3377d98ca9ed9988a866f3671fe1106fbb437bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI2MTQ0Nw==", "url": "https://github.com/apache/beam/pull/10546#discussion_r504261447", "bodyText": "Remove ReadAll.", "author": "iemejia", "createdAt": "2020-10-13T21:12:34Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -1281,4 +1032,44 @@ private void waitForFuturesToFinish() throws ExecutionException, InterruptedExce\n       }\n     }\n   }\n+\n+  /**\n+   * A {@link PTransform} to read data from Apache Cassandra. See {@link CassandraIO} for more\n+   * information on usage and configuration.\n+   */\n+  @AutoValue\n+  public abstract static class ReadAll<T> extends PTransform<PCollection<Read<T>>, PCollection<T>> {\n+\n+    @Nullable\n+    abstract Coder<T> coder();\n+\n+    abstract ReadAll.Builder<T> builder();", "originalCommit": "f3377d98ca9ed9988a866f3671fe1106fbb437bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI3MzkxNg==", "url": "https://github.com/apache/beam/pull/10546#discussion_r504273916", "bodyText": "Can you please move this Split into the ReadAll expand method. When not specified RingRanges like in the read() case we should split them on the ReadAll expansion. Of course if RingRanges are specified we will probably ignore recalculating them.", "author": "iemejia", "createdAt": "2020-10-13T21:38:41Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/CassandraIO.java", "diffHunk": "@@ -373,7 +419,86 @@ private CassandraIO() {}\n       checkArgument(entity() != null, \"withEntity() is required\");\n       checkArgument(coder() != null, \"withCoder() is required\");\n \n-      return input.apply(org.apache.beam.sdk.io.Read.from(new CassandraSource<>(this, null)));\n+      ReadAll<T> readAll = CassandraIO.readAll();\n+\n+      return input\n+          .apply(Create.of(this))\n+          .apply(\"Split\", ParDo.of(new SplitFn()))", "originalCommit": "f3377d98ca9ed9988a866f3671fe1106fbb437bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcwMjQ5Mg==", "url": "https://github.com/apache/beam/pull/10546#discussion_r505702492", "bodyText": "I don't think it makes sense to move to the readAll...  The readAll takes a Read<>, so on encountering each Read<>, we want to check if there isn't a ringRange or Query set, and then expand it?  I think it is much cleaner here, and I think this is where you originally suggested the split happen?", "author": "vmarquez", "createdAt": "2020-10-15T17:05:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI3MzkxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI3NTE1MQ==", "url": "https://github.com/apache/beam/pull/10546#discussion_r504275151", "bodyText": "This is still a bit messy, don't you think we can get something similar by using something like connection pooling and delegate this complexity to the driver (where it should reside)?\nhttps://docs.datastax.com/en/developer/java-driver/2.1/manual/pooling/\nNotice that I am not familiar with this but after a quicklook seems to be worth the look.", "author": "iemejia", "createdAt": "2020-10-13T21:41:17Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/ReadFn.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.cassandra;\n+\n+import com.datastax.driver.core.Cluster;\n+import com.datastax.driver.core.ColumnMetadata;\n+import com.datastax.driver.core.PreparedStatement;\n+import com.datastax.driver.core.ResultSet;\n+import com.datastax.driver.core.Session;\n+import com.datastax.driver.core.Token;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.beam.sdk.io.cassandra.CassandraIO.Read;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Joiner;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class ReadFn<T> extends DoFn<Read<T>, T> {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ReadFn.class);\n+\n+  private transient Cluster cluster;\n+\n+  private transient Session session;\n+\n+  private transient Read<T> lastRead;\n+\n+  @ProcessElement\n+  public void processElement(@Element Read<T> read, OutputReceiver<T> receiver) {\n+    Session session = getSession(read);\n+    Mapper<T> mapper = read.mapperFactoryFn().apply(session);\n+    String partitionKey =\n+        cluster.getMetadata().getKeyspace(read.keyspace().get()).getTable(read.table().get())\n+            .getPartitionKey().stream()\n+            .map(ColumnMetadata::getName)\n+            .collect(Collectors.joining(\",\"));\n+\n+    String query = generateRangeQuery(read, partitionKey, read.ringRanges() != null);\n+    PreparedStatement preparedStatement = session.prepare(query);\n+    Set<RingRange> ringRanges =\n+        read.ringRanges() == null ? Collections.<RingRange>emptySet() : read.ringRanges().get();\n+\n+    for (RingRange rr : ringRanges) {\n+      Token startToken = cluster.getMetadata().newToken(rr.getStart().toString());\n+      Token endToken = cluster.getMetadata().newToken(rr.getEnd().toString());\n+      ResultSet rs =\n+          session.execute(preparedStatement.bind().setToken(0, startToken).setToken(1, endToken));\n+      Iterator<T> iter = mapper.map(rs);\n+      while (iter.hasNext()) {\n+        T n = iter.next();\n+        receiver.output(n);\n+      }\n+    }\n+\n+    if (read.ringRanges() == null) {\n+      ResultSet rs = session.execute(preparedStatement.bind());\n+      Iterator<T> iter = mapper.map(rs);\n+      while (iter.hasNext()) {\n+        receiver.output(iter.next());\n+      }\n+    }\n+  }\n+\n+  @Teardown\n+  public void teardown() {\n+    if (session != null) {\n+      this.session.close();\n+    }\n+    if (cluster != null) {\n+      this.cluster.close();\n+    }\n+  }\n+\n+  private Session getSession(Read<T> read) {\n+    if (cluster == null || !reuseCluster(this.lastRead, read)) {\n+      this.cluster =\n+          CassandraIO.getCluster(\n+              read.hosts(),\n+              read.port(),\n+              read.username(),\n+              read.password(),\n+              read.localDc(),\n+              read.consistencyLevel());\n+    }\n+    if (session == null || !reuseSession(lastRead, read)) {\n+      this.session = this.cluster.connect(read.keyspace().get());\n+    }\n+    this.lastRead = read;\n+    return this.session;\n+  }\n+\n+  private static <T> boolean reuseCluster(Read<T> readA, Read<T> readB) {\n+    return readA != null", "originalCommit": "f3377d98ca9ed9988a866f3671fe1106fbb437bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY4ODk1Nw==", "url": "https://github.com/apache/beam/pull/10546#discussion_r505688957", "bodyText": "I didn't address this yet, wanted your thoughts on it.  I agree it can be improved.\nThe driver will handle Connection pooling, (handling N number of connections per cassandra host and sharing them in a thread safe way), but we still need to initiate a Session per Cassandra instance, and maintain a reference to the Session to keep those connections in scope (under the hood).\nSo we could use something as simple as a Map<?, Cluster> and Map<?, Session>, but remember we have to do both, since each Read<> might be hitting an entirely different cassandra cluster (hence the need to maintain different Cluster objects as well).   If we wanted something fancier, we could try a guava LRU or something on the off chance the user is initiating hundreds(thousands/millions?) of different Session objects.", "author": "vmarquez", "createdAt": "2020-10-15T16:43:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI3NTE1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI3NzU1MQ==", "url": "https://github.com/apache/beam/pull/10546#discussion_r504277551", "bodyText": "Remove if unused", "author": "iemejia", "createdAt": "2020-10-13T21:46:52Z", "path": "sdks/java/io/cassandra/src/main/java/org/apache/beam/sdk/io/cassandra/ReadFn.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.cassandra;\n+\n+import com.datastax.driver.core.Cluster;\n+import com.datastax.driver.core.ColumnMetadata;\n+import com.datastax.driver.core.PreparedStatement;\n+import com.datastax.driver.core.ResultSet;\n+import com.datastax.driver.core.Session;\n+import com.datastax.driver.core.Token;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.beam.sdk.io.cassandra.CassandraIO.Read;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Joiner;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class ReadFn<T> extends DoFn<Read<T>, T> {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(ReadFn.class);\n+\n+  private transient Cluster cluster;\n+\n+  private transient Session session;\n+\n+  private transient Read<T> lastRead;\n+\n+  @ProcessElement\n+  public void processElement(@Element Read<T> read, OutputReceiver<T> receiver) {\n+    Session session = getSession(read);\n+    Mapper<T> mapper = read.mapperFactoryFn().apply(session);\n+    String partitionKey =\n+        cluster.getMetadata().getKeyspace(read.keyspace().get()).getTable(read.table().get())\n+            .getPartitionKey().stream()\n+            .map(ColumnMetadata::getName)\n+            .collect(Collectors.joining(\",\"));\n+\n+    String query = generateRangeQuery(read, partitionKey, read.ringRanges() != null);\n+    PreparedStatement preparedStatement = session.prepare(query);\n+    Set<RingRange> ringRanges =\n+        read.ringRanges() == null ? Collections.<RingRange>emptySet() : read.ringRanges().get();\n+\n+    for (RingRange rr : ringRanges) {\n+      Token startToken = cluster.getMetadata().newToken(rr.getStart().toString());\n+      Token endToken = cluster.getMetadata().newToken(rr.getEnd().toString());\n+      ResultSet rs =\n+          session.execute(preparedStatement.bind().setToken(0, startToken).setToken(1, endToken));\n+      Iterator<T> iter = mapper.map(rs);\n+      while (iter.hasNext()) {\n+        T n = iter.next();\n+        receiver.output(n);\n+      }\n+    }\n+\n+    if (read.ringRanges() == null) {\n+      ResultSet rs = session.execute(preparedStatement.bind());\n+      Iterator<T> iter = mapper.map(rs);\n+      while (iter.hasNext()) {\n+        receiver.output(iter.next());\n+      }\n+    }\n+  }\n+\n+  @Teardown\n+  public void teardown() {\n+    if (session != null) {\n+      this.session.close();\n+    }\n+    if (cluster != null) {\n+      this.cluster.close();\n+    }\n+  }\n+\n+  private Session getSession(Read<T> read) {\n+    if (cluster == null || !reuseCluster(this.lastRead, read)) {\n+      this.cluster =\n+          CassandraIO.getCluster(\n+              read.hosts(),\n+              read.port(),\n+              read.username(),\n+              read.password(),\n+              read.localDc(),\n+              read.consistencyLevel());\n+    }\n+    if (session == null || !reuseSession(lastRead, read)) {\n+      this.session = this.cluster.connect(read.keyspace().get());\n+    }\n+    this.lastRead = read;\n+    return this.session;\n+  }\n+\n+  private static <T> boolean reuseCluster(Read<T> readA, Read<T> readB) {\n+    return readA != null\n+        && readA.hosts().get().equals(readB.hosts().get())\n+        && readA.port().get().equals(readB.port().get())\n+        && ((readA.username() != null && readA.username().equals(readB.username()))\n+            || (readA.username() == null && readB.username() == null))\n+        && ((readA.consistencyLevel() != null\n+                && readA.consistencyLevel().equals(readB.consistencyLevel()))\n+            || (readA.consistencyLevel() == null && readB.consistencyLevel() == null))\n+        && ((readA.localDc() != null && readA.localDc().equals(readB.consistencyLevel()))\n+            || (readA.localDc() == null && readB.localDc() == null));\n+  }\n+\n+  // TODO: Unit test\n+  private static <T> boolean reuseSession(Read<T> readA, Read<T> readB) {\n+    return (readA.keyspace() != null && readA.keyspace().equals(readB.keyspace()))\n+        || (readA.keyspace() == null && readB.keyspace() == null);\n+  }\n+\n+  /*\n+  private static String generateRangeQuery(Read<?> spec, String partitionKey) {", "originalCommit": "f3377d98ca9ed9988a866f3671fe1106fbb437bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8bb91d2b0fca16c5eae74773e247d9eab43a9a5f", "url": "https://github.com/apache/beam/commit/8bb91d2b0fca16c5eae74773e247d9eab43a9a5f", "message": "moving split back to handle issue with query/ringranges", "committedDate": "2021-02-16T17:46:45Z", "type": "forcePushed"}, {"oid": "cf749f1b408894f5056821e52c1ee3fc9125f9cf", "url": "https://github.com/apache/beam/commit/cf749f1b408894f5056821e52c1ee3fc9125f9cf", "message": "connection sharing", "committedDate": "2021-06-23T00:30:28Z", "type": "forcePushed"}, {"oid": "53e2f5efeff684842ae350e797a15e7ed7cdfc86", "url": "https://github.com/apache/beam/commit/53e2f5efeff684842ae350e797a15e7ed7cdfc86", "message": "[BEAM-9008] adds CassandraIO.readAll", "committedDate": "2021-09-02T05:05:39Z", "type": "forcePushed"}, {"oid": "e12fc33e55e23db9f2aee330039d16dace34f9aa", "url": "https://github.com/apache/beam/commit/e12fc33e55e23db9f2aee330039d16dace34f9aa", "message": "[BEAM-9008] adds CassandraIO.readAll", "committedDate": "2021-09-07T22:31:14Z", "type": "commit"}, {"oid": "e12fc33e55e23db9f2aee330039d16dace34f9aa", "url": "https://github.com/apache/beam/commit/e12fc33e55e23db9f2aee330039d16dace34f9aa", "message": "[BEAM-9008] adds CassandraIO.readAll", "committedDate": "2021-09-07T22:31:14Z", "type": "forcePushed"}]}