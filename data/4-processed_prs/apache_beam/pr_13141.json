{"pr_number": 13141, "pr_title": "[BEAM-9547] Dataframe corrwith.", "pr_createdAt": "2020-10-19T21:56:33Z", "pr_url": "https://github.com/apache/beam/pull/13141", "timeline": [{"oid": "6b11baa923882f8644e55e0d695a27ea0b90dfd7", "url": "https://github.com/apache/beam/commit/6b11baa923882f8644e55e0d695a27ea0b90dfd7", "message": "[BEAM-9547] Dataframe corrwith.", "committedDate": "2020-10-19T21:55:23Z", "type": "commit"}, {"oid": "b0ffe9ce91221a278c740cc89d8d154e68ab5ff7", "url": "https://github.com/apache/beam/commit/b0ffe9ce91221a278c740cc89d8d154e68ab5ff7", "message": "lint", "committedDate": "2020-10-19T22:40:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2MjY3Ng==", "url": "https://github.com/apache/beam/pull/13141#discussion_r512962676", "bodyText": "Is this safe to implement with elementwise_method? (need to justify this to myself)\nI think it will work for most cases.. the resulting expression will require partitionings.Index since we do that if any arg is a DeferredBase, and other should always be one. That should handle axis='index'. Also all of the join modes should work as intended within Index partitions.\nI think actually for axis='columns' Index partitioning is too restrictive. We could do that without any partitioning. Is that right?\nLooking at the remaining args:\n\ncopy: I think copy=False won't work since we can't predict if the operation is inplace or not, it depends on the data.\nfill_value: Works trivially\nmethod: non-default options are order-sensitive\nlimit: I don't think we can support this correctly right now without Singleton partitioning\nlevel, fill_axis, broadcast_axis: I'm not actually sure what these are doing.\n\nCan we reject the options that won't work?", "author": "TheNeuralBit", "createdAt": "2020-10-27T19:19:21Z", "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -575,6 +575,8 @@ def __setitem__(self, key, value):\n     else:\n       raise NotImplementedError(key)\n \n+  align = frame_base._elementwise_method('align')", "originalCommit": "b0ffe9ce91221a278c740cc89d8d154e68ab5ff7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY2NjExNQ==", "url": "https://github.com/apache/beam/pull/13141#discussion_r513666115", "bodyText": "Good call. Done.", "author": "robertwb", "createdAt": "2020-10-28T18:19:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2MjY3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk4MjIzNQ==", "url": "https://github.com/apache/beam/pull/13141#discussion_r512982235", "bodyText": "It looks like method is actually the only kwarg that overlaps between corr and corrwith. We should probably pass that explicitly, and handle the remaining arg, drop, here.", "author": "TheNeuralBit", "createdAt": "2020-10-27T19:45:32Z", "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -771,6 +773,62 @@ def fill_matrix(*args):\n               requires_partition_by=partitionings.Singleton(),\n               proxy=proxy))\n \n+  @frame_base.args_to_kwargs(pd.DataFrame)\n+  @frame_base.populate_defaults(pd.DataFrame)\n+  def corrwith(self, other, axis, **kwargs):\n+    if axis not in (0, 'index'):\n+      raise NotImplementedError('corrwith(axis=%r)' % axis)\n+    if not isinstance(other, frame_base.DeferredFrame):\n+      other = frame_base.DeferredFrame.wrap(\n+          expressions.ConstantExpression(other))\n+\n+    if isinstance(other, DeferredSeries):\n+      proxy = self._expr.proxy().corrwith(other._expr.proxy())\n+      self, other = self.align(other, axis=0, join='inner')\n+      corrs = [self[col].corr(other, **kwargs) for col in proxy.index]", "originalCommit": "b0ffe9ce91221a278c740cc89d8d154e68ab5ff7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY2NjIyNA==", "url": "https://github.com/apache/beam/pull/13141#discussion_r513666224", "bodyText": "Resolved.", "author": "robertwb", "createdAt": "2020-10-28T18:19:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk4MjIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk4NDM3Ng==", "url": "https://github.com/apache/beam/pull/13141#discussion_r512984376", "bodyText": "nit: The two branches here are almost identical, the only difference is valid_cols vs. proxy.index. You might consider re-working this so the other logic is shared. That might just make it more confusing though... up to you.", "author": "TheNeuralBit", "createdAt": "2020-10-27T19:48:16Z", "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -771,6 +773,62 @@ def fill_matrix(*args):\n               requires_partition_by=partitionings.Singleton(),\n               proxy=proxy))\n \n+  @frame_base.args_to_kwargs(pd.DataFrame)\n+  @frame_base.populate_defaults(pd.DataFrame)\n+  def corrwith(self, other, axis, **kwargs):\n+    if axis not in (0, 'index'):\n+      raise NotImplementedError('corrwith(axis=%r)' % axis)\n+    if not isinstance(other, frame_base.DeferredFrame):\n+      other = frame_base.DeferredFrame.wrap(\n+          expressions.ConstantExpression(other))\n+\n+    if isinstance(other, DeferredSeries):\n+      proxy = self._expr.proxy().corrwith(other._expr.proxy())\n+      self, other = self.align(other, axis=0, join='inner')\n+      corrs = [self[col].corr(other, **kwargs) for col in proxy.index]\n+      def fill_dataframe(*args):\n+        result = proxy.copy(deep=True)\n+        for col, value in zip(proxy.index, args):\n+          result[col] = value\n+        return result\n+      with expressions.allow_non_parallel_operations(True):\n+        return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+            'fill_dataframe',\n+            fill_dataframe,\n+            [corr._expr for corr in corrs],\n+            requires_partition_by=partitionings.Singleton(),\n+            proxy=proxy))\n+\n+    elif isinstance(other, DeferredDataFrame):\n+      proxy = self._expr.proxy().corrwith(other._expr.proxy())\n+      self, other = self.align(other, axis=0, join='inner')\n+      valid_cols = list(\n+          set(self.columns)\n+          .intersection(other.columns)\n+          .intersection(proxy.index))\n+      corrs = [self[col].corr(other[col], **kwargs) for col in valid_cols]\n+      def fill_dataframe(*args):\n+        result = proxy.copy(deep=True)\n+        for col, value in zip(valid_cols, args):\n+          result[col] = value\n+        return result\n+      with expressions.allow_non_parallel_operations(True):\n+        return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+            'fill_dataframe',\n+            fill_dataframe,\n+            [corr._expr for corr in corrs],\n+            requires_partition_by=partitionings.Singleton(),\n+            proxy=proxy))", "originalCommit": "b0ffe9ce91221a278c740cc89d8d154e68ab5ff7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY2NjM4Mw==", "url": "https://github.com/apache/beam/pull/13141#discussion_r513666383", "bodyText": "I've consolidated them now.", "author": "robertwb", "createdAt": "2020-10-28T18:20:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk4NDM3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk4NjUxMg==", "url": "https://github.com/apache/beam/pull/13141#discussion_r512986512", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  corrs = [self[col].corr(other[col], **kwargs) for col in valid_cols]\n          \n          \n            \n                  def fill_dataframe(*args):\n          \n          \n            \n                  # Generate expressions to compute the actual correlations\n          \n          \n            \n                  corrs = [self[col].corr(other[col], **kwargs) for col in valid_cols]\n          \n          \n            \n                  # Combine the results\n          \n          \n            \n                  def fill_dataframe(*args):\n          \n      \n    \n    \n  \n\nIt took me a while to realize this is what was going on, hopefully this will expedite it for future readers.", "author": "TheNeuralBit", "createdAt": "2020-10-27T19:50:20Z", "path": "sdks/python/apache_beam/dataframe/frames.py", "diffHunk": "@@ -771,6 +773,62 @@ def fill_matrix(*args):\n               requires_partition_by=partitionings.Singleton(),\n               proxy=proxy))\n \n+  @frame_base.args_to_kwargs(pd.DataFrame)\n+  @frame_base.populate_defaults(pd.DataFrame)\n+  def corrwith(self, other, axis, **kwargs):\n+    if axis not in (0, 'index'):\n+      raise NotImplementedError('corrwith(axis=%r)' % axis)\n+    if not isinstance(other, frame_base.DeferredFrame):\n+      other = frame_base.DeferredFrame.wrap(\n+          expressions.ConstantExpression(other))\n+\n+    if isinstance(other, DeferredSeries):\n+      proxy = self._expr.proxy().corrwith(other._expr.proxy())\n+      self, other = self.align(other, axis=0, join='inner')\n+      corrs = [self[col].corr(other, **kwargs) for col in proxy.index]\n+      def fill_dataframe(*args):\n+        result = proxy.copy(deep=True)\n+        for col, value in zip(proxy.index, args):\n+          result[col] = value\n+        return result\n+      with expressions.allow_non_parallel_operations(True):\n+        return frame_base.DeferredFrame.wrap(\n+          expressions.ComputedExpression(\n+            'fill_dataframe',\n+            fill_dataframe,\n+            [corr._expr for corr in corrs],\n+            requires_partition_by=partitionings.Singleton(),\n+            proxy=proxy))\n+\n+    elif isinstance(other, DeferredDataFrame):\n+      proxy = self._expr.proxy().corrwith(other._expr.proxy())\n+      self, other = self.align(other, axis=0, join='inner')\n+      valid_cols = list(\n+          set(self.columns)\n+          .intersection(other.columns)\n+          .intersection(proxy.index))\n+      corrs = [self[col].corr(other[col], **kwargs) for col in valid_cols]\n+      def fill_dataframe(*args):", "originalCommit": "b0ffe9ce91221a278c740cc89d8d154e68ab5ff7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "925bd834e4dfb1c42172e5828e7c30f36e1e6681", "url": "https://github.com/apache/beam/commit/925bd834e4dfb1c42172e5828e7c30f36e1e6681", "message": "Additional comments.\n\nCo-authored-by: Brian Hulette <hulettbh@gmail.com>", "committedDate": "2020-10-28T17:24:58Z", "type": "commit"}, {"oid": "c25098245822cc663c4271dabd6f413db0ecde56", "url": "https://github.com/apache/beam/commit/c25098245822cc663c4271dabd6f413db0ecde56", "message": "address reviewer comments", "committedDate": "2020-10-28T18:19:26Z", "type": "commit"}, {"oid": "5b54818fea0820c6c656237fafe53deaa8241d97", "url": "https://github.com/apache/beam/commit/5b54818fea0820c6c656237fafe53deaa8241d97", "message": "Merge branch 'master' into dataframe-corr", "committedDate": "2020-10-28T20:57:38Z", "type": "commit"}, {"oid": "8b1142e6576e32cd67cc9a28bd51ebc062f03945", "url": "https://github.com/apache/beam/commit/8b1142e6576e32cd67cc9a28bd51ebc062f03945", "message": "lint", "committedDate": "2020-10-28T20:58:31Z", "type": "commit"}]}