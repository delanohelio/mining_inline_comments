{"pr_number": 11197, "pr_title": "[BEAM-8292] Portable Reshuffle for Go SDK", "pr_createdAt": "2020-03-23T17:37:29Z", "pr_url": "https://github.com/apache/beam/pull/11197", "timeline": [{"oid": "9fd411d1fdd2c773af72cf2501138ff4f1768fba", "url": "https://github.com/apache/beam/commit/9fd411d1fdd2c773af72cf2501138ff4f1768fba", "message": "[BEAM-8292] Portable Reshuffle for Go SDK", "committedDate": "2020-03-23T17:25:58Z", "type": "commit"}, {"oid": "968e45f6602a635f0f1229a374eed704672ef91e", "url": "https://github.com/apache/beam/commit/968e45f6602a635f0f1229a374eed704672ef91e", "message": "Fix placement of exec translation.", "committedDate": "2020-03-23T20:18:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgyMzE5OQ==", "url": "https://github.com/apache/beam/pull/11197#discussion_r396823199", "bodyText": "I know this is just preserving the existing behavior, but it seems weird to return err here instead of return nil, even if it is guaranteed to be nil at this point.", "author": "youngoli", "createdAt": "2020-03-23T23:38:41Z", "path": "sdks/go/pkg/beam/core/runtime/exec/coder.go", "diffHunk": "@@ -259,59 +298,82 @@ type customDecoder struct {\n \tdec Decoder\n }\n \n-func (c *customDecoder) Decode(r io.Reader) (*FullValue, error) {\n+func (c *customDecoder) DecodeTo(r io.Reader, fv *FullValue) error {\n \t// (1) Read length-prefixed encoded data\n \n \tsize, err := coder.DecodeVarInt(r)\n \tif err != nil {\n-\t\treturn nil, err\n+\t\treturn err\n \t}\n \tdata, err := ioutilx.ReadN(r, (int)(size))\n \tif err != nil {\n-\t\treturn nil, err\n+\t\treturn err\n \t}\n \n \t// (2) Call decode\n \n \tval, err := c.dec.Decode(c.t, data)\n \tif err != nil {\n+\t\treturn err\n+\t}\n+\t*fv = FullValue{Elm: val}\n+\treturn err", "originalCommit": "968e45f6602a635f0f1229a374eed704672ef91e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMwODU4Mg==", "url": "https://github.com/apache/beam/pull/11197#discussion_r397308582", "bodyText": "Good catch. Thanks!", "author": "lostluck", "createdAt": "2020-03-24T16:51:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgyMzE5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg1MzM0OA==", "url": "https://github.com/apache/beam/pull/11197#discussion_r396853348", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tif err := n.Out.ProcessElement(ctx, &n.ret); err != nil {\n          \n          \n            \n            \t\treturn err\n          \n          \n            \n            \t}\n          \n          \n            \n            \treturn nil\n          \n          \n            \n            \treturn n.Out.ProcessElement(ctx, &n.ret)", "author": "youngoli", "createdAt": "2020-03-24T01:26:48Z", "path": "sdks/go/pkg/beam/core/runtime/exec/reshuffle.go", "diffHunk": "@@ -0,0 +1,170 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package exec\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"math/rand\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/coder\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n+)\n+\n+// ReshuffleInput is a Node.\n+type ReshuffleInput struct {\n+\tUID   UnitID\n+\tSID   StreamID\n+\tCoder *coder.Coder // Coder for the input PCollection.\n+\tSeed  int64\n+\tOut   Node\n+\n+\tr    *rand.Rand\n+\tenc  ElementEncoder\n+\twEnc WindowEncoder\n+\tb    bytes.Buffer\n+\t// ret is a cached allocations for passing to the next Unit. Units never modify the passed in FullValue.\n+\tret FullValue\n+}\n+\n+// ID returns the unit debug id.\n+func (n *ReshuffleInput) ID() UnitID {\n+\treturn n.UID\n+}\n+\n+// Up initializes the value and window encoders, and the random source.\n+func (n *ReshuffleInput) Up(ctx context.Context) error {\n+\tn.enc = MakeElementEncoder(coder.SkipW(n.Coder))\n+\tn.wEnc = MakeWindowEncoder(n.Coder.Window)\n+\tn.r = rand.New(rand.NewSource(n.Seed))\n+\treturn nil\n+}\n+\n+// StartBundle is a no-op.\n+func (n *ReshuffleInput) StartBundle(ctx context.Context, id string, data DataContext) error {\n+\treturn MultiStartBundle(ctx, id, data, n.Out)\n+}\n+\n+func (n *ReshuffleInput) ProcessElement(ctx context.Context, value *FullValue, values ...ReStream) error {\n+\tn.b.Reset()\n+\tif err := EncodeWindowedValueHeader(n.wEnc, value.Windows, value.Timestamp, &n.b); err != nil {\n+\t\treturn err\n+\t}\n+\tif err := n.enc.Encode(value, &n.b); err != nil {\n+\t\treturn errors.WithContextf(err, \"encoding element %v with coder %v\", value, n.Coder)\n+\t}\n+\tn.ret = FullValue{Elm: n.r.Int(), Elm2: n.b.Bytes(), Timestamp: value.Timestamp}\n+\tif err := n.Out.ProcessElement(ctx, &n.ret); err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil", "originalCommit": "968e45f6602a635f0f1229a374eed704672ef91e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg1NTA0Nw==", "url": "https://github.com/apache/beam/pull/11197#discussion_r396855047", "bodyText": "Should this also be clearing n.ret like ReshuffleInput does?", "author": "youngoli", "createdAt": "2020-03-24T01:33:12Z", "path": "sdks/go/pkg/beam/core/runtime/exec/reshuffle.go", "diffHunk": "@@ -0,0 +1,170 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package exec\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"math/rand\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/coder\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n+)\n+\n+// ReshuffleInput is a Node.\n+type ReshuffleInput struct {\n+\tUID   UnitID\n+\tSID   StreamID\n+\tCoder *coder.Coder // Coder for the input PCollection.\n+\tSeed  int64\n+\tOut   Node\n+\n+\tr    *rand.Rand\n+\tenc  ElementEncoder\n+\twEnc WindowEncoder\n+\tb    bytes.Buffer\n+\t// ret is a cached allocations for passing to the next Unit. Units never modify the passed in FullValue.\n+\tret FullValue\n+}\n+\n+// ID returns the unit debug id.\n+func (n *ReshuffleInput) ID() UnitID {\n+\treturn n.UID\n+}\n+\n+// Up initializes the value and window encoders, and the random source.\n+func (n *ReshuffleInput) Up(ctx context.Context) error {\n+\tn.enc = MakeElementEncoder(coder.SkipW(n.Coder))\n+\tn.wEnc = MakeWindowEncoder(n.Coder.Window)\n+\tn.r = rand.New(rand.NewSource(n.Seed))\n+\treturn nil\n+}\n+\n+// StartBundle is a no-op.\n+func (n *ReshuffleInput) StartBundle(ctx context.Context, id string, data DataContext) error {\n+\treturn MultiStartBundle(ctx, id, data, n.Out)\n+}\n+\n+func (n *ReshuffleInput) ProcessElement(ctx context.Context, value *FullValue, values ...ReStream) error {\n+\tn.b.Reset()\n+\tif err := EncodeWindowedValueHeader(n.wEnc, value.Windows, value.Timestamp, &n.b); err != nil {\n+\t\treturn err\n+\t}\n+\tif err := n.enc.Encode(value, &n.b); err != nil {\n+\t\treturn errors.WithContextf(err, \"encoding element %v with coder %v\", value, n.Coder)\n+\t}\n+\tn.ret = FullValue{Elm: n.r.Int(), Elm2: n.b.Bytes(), Timestamp: value.Timestamp}\n+\tif err := n.Out.ProcessElement(ctx, &n.ret); err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+// FinishBundle propagates finish bundle, and clears cached state.\n+func (n *ReshuffleInput) FinishBundle(ctx context.Context) error {\n+\tn.b = bytes.Buffer{}\n+\tn.ret = FullValue{}\n+\treturn MultiFinishBundle(ctx, n.Out)\n+}\n+\n+// Down is a no-op.\n+func (n *ReshuffleInput) Down(ctx context.Context) error {\n+\treturn nil\n+}\n+\n+func (n *ReshuffleInput) String() string {\n+\treturn fmt.Sprintf(\"ReshuffleInput[%v] Coder:%v\", n.SID, n.Coder)\n+}\n+\n+// ReshuffleOutput is a Node.\n+type ReshuffleOutput struct {\n+\tUID   UnitID\n+\tSID   StreamID\n+\tCoder *coder.Coder // Coder for the receiving PCollection.\n+\tOut   Node\n+\n+\tb    bytes.Buffer\n+\tdec  ElementDecoder\n+\twDec WindowDecoder\n+\tret  FullValue\n+}\n+\n+// ID returns the unit debug id.\n+func (n *ReshuffleOutput) ID() UnitID {\n+\treturn n.UID\n+}\n+\n+// Up initializes the value and window encoders, and the random source.\n+func (n *ReshuffleOutput) Up(ctx context.Context) error {\n+\tn.dec = MakeElementDecoder(coder.SkipW(n.Coder))\n+\tn.wDec = MakeWindowDecoder(n.Coder.Window)\n+\treturn nil\n+}\n+\n+// StartBundle is a no-op.\n+func (n *ReshuffleOutput) StartBundle(ctx context.Context, id string, data DataContext) error {\n+\treturn MultiStartBundle(ctx, id, data, n.Out)\n+}\n+\n+func (n *ReshuffleOutput) ProcessElement(ctx context.Context, value *FullValue, values ...ReStream) error {\n+\t// Marshal the pieces into a temporary buffer since they must be transmitted on FnAPI as a single\n+\t// unit.\n+\tvs, err := values[0].Open()\n+\tif err != nil {\n+\t\treturn errors.WithContextf(err, \"decoding values for %v with coder %v\", value, n.Coder)\n+\t}\n+\tdefer vs.Close()\n+\tfor {\n+\t\tv, err := vs.Read()\n+\t\tif err != nil {\n+\t\t\tif err == io.EOF {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t\treturn errors.WithContextf(err, \"reading values for %v\", n)\n+\t\t}\n+\t\tn.b = *bytes.NewBuffer(v.Elm.([]byte))\n+\t\tws, ts, err := DecodeWindowedValueHeader(n.wDec, &n.b)\n+\t\tif err != nil {\n+\t\t\treturn errors.WithContextf(err, \"decoding windows for %v\", n)\n+\t\t}\n+\t\tif err := n.dec.DecodeTo(&n.b, &n.ret); err != nil {\n+\t\t\treturn errors.WithContextf(err, \"decoding element for %v\", n)\n+\t\t}\n+\t\tn.ret.Windows = ws\n+\t\tn.ret.Timestamp = ts\n+\t\tif err := n.Out.ProcessElement(ctx, &n.ret); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// FinishBundle propagates finish bundle to downstream nodes.\n+func (n *ReshuffleOutput) FinishBundle(ctx context.Context) error {\n+\tn.b = bytes.Buffer{}", "originalCommit": "968e45f6602a635f0f1229a374eed704672ef91e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMxNTU0MQ==", "url": "https://github.com/apache/beam/pull/11197#discussion_r397315541", "bodyText": "Yes it should. Thanks!", "author": "lostluck", "createdAt": "2020-03-24T17:01:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg1NTA0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg1NjA3Nw==", "url": "https://github.com/apache/beam/pull/11197#discussion_r396856077", "bodyText": "It's strange to me that values[] can have multiple elements, but this method ends up actually reading all the values from the first element of it. Could you explain why that happens? Are there sometimes multiple ReStreams representing different things?", "author": "youngoli", "createdAt": "2020-03-24T01:37:28Z", "path": "sdks/go/pkg/beam/core/runtime/exec/reshuffle.go", "diffHunk": "@@ -0,0 +1,170 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package exec\n+\n+import (\n+\t\"bytes\"\n+\t\"context\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"math/rand\"\n+\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/core/graph/coder\"\n+\t\"github.com/apache/beam/sdks/go/pkg/beam/internal/errors\"\n+)\n+\n+// ReshuffleInput is a Node.\n+type ReshuffleInput struct {\n+\tUID   UnitID\n+\tSID   StreamID\n+\tCoder *coder.Coder // Coder for the input PCollection.\n+\tSeed  int64\n+\tOut   Node\n+\n+\tr    *rand.Rand\n+\tenc  ElementEncoder\n+\twEnc WindowEncoder\n+\tb    bytes.Buffer\n+\t// ret is a cached allocations for passing to the next Unit. Units never modify the passed in FullValue.\n+\tret FullValue\n+}\n+\n+// ID returns the unit debug id.\n+func (n *ReshuffleInput) ID() UnitID {\n+\treturn n.UID\n+}\n+\n+// Up initializes the value and window encoders, and the random source.\n+func (n *ReshuffleInput) Up(ctx context.Context) error {\n+\tn.enc = MakeElementEncoder(coder.SkipW(n.Coder))\n+\tn.wEnc = MakeWindowEncoder(n.Coder.Window)\n+\tn.r = rand.New(rand.NewSource(n.Seed))\n+\treturn nil\n+}\n+\n+// StartBundle is a no-op.\n+func (n *ReshuffleInput) StartBundle(ctx context.Context, id string, data DataContext) error {\n+\treturn MultiStartBundle(ctx, id, data, n.Out)\n+}\n+\n+func (n *ReshuffleInput) ProcessElement(ctx context.Context, value *FullValue, values ...ReStream) error {\n+\tn.b.Reset()\n+\tif err := EncodeWindowedValueHeader(n.wEnc, value.Windows, value.Timestamp, &n.b); err != nil {\n+\t\treturn err\n+\t}\n+\tif err := n.enc.Encode(value, &n.b); err != nil {\n+\t\treturn errors.WithContextf(err, \"encoding element %v with coder %v\", value, n.Coder)\n+\t}\n+\tn.ret = FullValue{Elm: n.r.Int(), Elm2: n.b.Bytes(), Timestamp: value.Timestamp}\n+\tif err := n.Out.ProcessElement(ctx, &n.ret); err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+// FinishBundle propagates finish bundle, and clears cached state.\n+func (n *ReshuffleInput) FinishBundle(ctx context.Context) error {\n+\tn.b = bytes.Buffer{}\n+\tn.ret = FullValue{}\n+\treturn MultiFinishBundle(ctx, n.Out)\n+}\n+\n+// Down is a no-op.\n+func (n *ReshuffleInput) Down(ctx context.Context) error {\n+\treturn nil\n+}\n+\n+func (n *ReshuffleInput) String() string {\n+\treturn fmt.Sprintf(\"ReshuffleInput[%v] Coder:%v\", n.SID, n.Coder)\n+}\n+\n+// ReshuffleOutput is a Node.\n+type ReshuffleOutput struct {\n+\tUID   UnitID\n+\tSID   StreamID\n+\tCoder *coder.Coder // Coder for the receiving PCollection.\n+\tOut   Node\n+\n+\tb    bytes.Buffer\n+\tdec  ElementDecoder\n+\twDec WindowDecoder\n+\tret  FullValue\n+}\n+\n+// ID returns the unit debug id.\n+func (n *ReshuffleOutput) ID() UnitID {\n+\treturn n.UID\n+}\n+\n+// Up initializes the value and window encoders, and the random source.\n+func (n *ReshuffleOutput) Up(ctx context.Context) error {\n+\tn.dec = MakeElementDecoder(coder.SkipW(n.Coder))\n+\tn.wDec = MakeWindowDecoder(n.Coder.Window)\n+\treturn nil\n+}\n+\n+// StartBundle is a no-op.\n+func (n *ReshuffleOutput) StartBundle(ctx context.Context, id string, data DataContext) error {\n+\treturn MultiStartBundle(ctx, id, data, n.Out)\n+}\n+\n+func (n *ReshuffleOutput) ProcessElement(ctx context.Context, value *FullValue, values ...ReStream) error {\n+\t// Marshal the pieces into a temporary buffer since they must be transmitted on FnAPI as a single\n+\t// unit.\n+\tvs, err := values[0].Open()", "originalCommit": "968e45f6602a635f0f1229a374eed704672ef91e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMxNDM0NA==", "url": "https://github.com/apache/beam/pull/11197#discussion_r397314344", "bodyText": "This is the Go SDK future proofing itself, against CoGBK supporting multiple datastreams from the runner. Functionally, only datasource.go would need to change in that case.  You can see a comment to that effect in datasource.go, and then nearly everything else deals with the values streams properly under that assumption.\nIn this case, we know that if this code is being used, it's coming from a single GBK, which means there's only a single stream of values, and then since we're framework side, we just handle the stream directly. In that way, it's similar to how we're handling CoGBKs presently, with synthetic inject and expand steps to get to the right number of joined streams, even though the Runner is only providing us with a single data stream for the grouped data.", "author": "lostluck", "createdAt": "2020-03-24T16:59:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg1NjA3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4NjU2Ng==", "url": "https://github.com/apache/beam/pull/11197#discussion_r396886566", "bodyText": "Is this input supposed to be postReify? I would've expected inputID from the previous step.", "author": "youngoli", "createdAt": "2020-03-24T03:42:59Z", "path": "sdks/go/pkg/beam/core/runtime/graphx/translate.go", "diffHunk": "@@ -473,6 +479,164 @@ func (m *marshaller) addNode(n *graph.Node) string {\n \treturn m.makeNode(id, m.coders.Add(n.Coder), n)\n }\n \n+// expandReshuffle translates resharding to a composite reshuffle\n+// transform.\n+//\n+// With proper runner support, the SDK doesn't need to do anything.\n+// However, we still need to provide a backup plan in terms of other\n+// PTransforms in the event the runner doesn't have a native implementation.\n+//\n+// In particular, the \"backup plan\" needs to:\n+//\n+//  * Encode the windowed element, preserving timestamps.\n+//  * Add random keys to the encoded windowed element []bytes\n+//  * GroupByKey (in the global window).\n+//  * Explode the resulting elements list.\n+//  * Decode the windowed element []bytes.\n+//\n+// While a simple reshard can be written in user terms, (timestamps and windows\n+// are accessible to user functions) there are some framework internal\n+// optimizations that can be done if the framework is aware of the reshard, though\n+// ideally this is handled on the runner side.\n+//\n+// User code is able to write reshards, but it's easier to access\n+// the window coders framework side, which is critical for the reshard\n+// to function with unbounded inputs.\n+func (m *marshaller) expandReshuffle(edge NamedEdge) string {\n+\tid := edgeID(edge.Edge)\n+\tvar kvCoderID, gbkCoderID string\n+\t{\n+\t\tkv := makeUnionCoder()\n+\t\tkvCoderID = m.coders.Add(kv)\n+\t\tgbkCoderID = m.coders.Add(coder.NewCoGBK(kv.Components))\n+\t}\n+\n+\tvar subtransforms []string\n+\n+\tin := edge.Edge.Input[0]\n+\n+\torigInput := m.addNode(in.From)\n+\t// We need to preserve the old windowing/triggering here\n+\t// for re-instatement after the GBK.\n+\tpreservedWSId := m.pcollections[origInput].GetWindowingStrategyId()\n+\n+\t// Get the windowing strategy from before:\n+\tpostReify := fmt.Sprintf(\"%v_%v_reifyts\", nodeID(in.From), id)\n+\tm.makeNode(postReify, kvCoderID, in.From)\n+\n+\t// We need to replace postReify's windowing strategy with one appropriate\n+\t// for reshuffles.\n+\t{\n+\t\twfn := window.NewGlobalWindows()\n+\t\tm.pcollections[postReify].WindowingStrategyId =\n+\t\t\tm.internWindowingStrategy(&pb.WindowingStrategy{\n+\t\t\t\t// Not segregated by time...\n+\t\t\t\tWindowFn: makeWindowFn(wfn),\n+\t\t\t\t// ...output after every element is received...\n+\t\t\t\tTrigger: &pb.Trigger{\n+\t\t\t\t\t// Should this be an Always trigger instead?\n+\t\t\t\t\tTrigger: &pb.Trigger_ElementCount_{\n+\t\t\t\t\t\tElementCount: &pb.Trigger_ElementCount{\n+\t\t\t\t\t\t\tElementCount: 1,\n+\t\t\t\t\t\t},\n+\t\t\t\t\t},\n+\t\t\t\t},\n+\t\t\t\t// ...and after outputing, discard the output elements...\n+\t\t\t\tAccumulationMode: pb.AccumulationMode_DISCARDING,\n+\t\t\t\t// ...and since every pane should have 1 element,\n+\t\t\t\t// try to preserve the timestamp.\n+\t\t\t\tOutputTime: pb.OutputTime_EARLIEST_IN_PANE,\n+\t\t\t\t// Defaults copied from marshalWindowingStrategy.\n+\t\t\t\t// TODO(BEAM-3304): migrate to user side operations once trigger support is in.\n+\t\t\t\tEnvironmentId:   m.addDefaultEnv(),\n+\t\t\t\tMergeStatus:     pb.MergeStatus_NON_MERGING,\n+\t\t\t\tWindowCoderId:   m.coders.AddWindowCoder(makeWindowCoder(wfn)),\n+\t\t\t\tClosingBehavior: pb.ClosingBehavior_EMIT_IF_NONEMPTY,\n+\t\t\t\tAllowedLateness: 0,\n+\t\t\t\tOnTimeBehavior:  pb.OnTimeBehavior_FIRE_ALWAYS,\n+\t\t\t})\n+\t}\n+\n+\t// Inputs (i)\n+\n+\tinputID := fmt.Sprintf(\"%v_reifyts\", id)\n+\tpayload := &pb.ParDoPayload{\n+\t\tDoFn: &pb.FunctionSpec{\n+\t\t\tUrn: URNReshuffleInput,\n+\t\t\tPayload: []byte(protox.MustEncodeBase64(&v1.TransformPayload{\n+\t\t\t\tUrn: URNReshuffleInput,\n+\t\t\t})),\n+\t\t},\n+\t}\n+\tinput := &pb.PTransform{\n+\t\tUniqueName: inputID,\n+\t\tSpec: &pb.FunctionSpec{\n+\t\t\tUrn:     URNParDo,\n+\t\t\tPayload: protox.MustEncode(payload),\n+\t\t},\n+\t\tInputs:        map[string]string{\"i0\": nodeID(in.From)},\n+\t\tOutputs:       map[string]string{\"i0\": postReify},\n+\t\tEnvironmentId: m.addDefaultEnv(),\n+\t}\n+\tm.transforms[inputID] = input\n+\tsubtransforms = append(subtransforms, inputID)\n+\n+\toutNode := edge.Edge.Output[0].To\n+\n+\t// GBK\n+\n+\tgbkOut := fmt.Sprintf(\"%v_out\", nodeID(outNode))\n+\tm.makeNode(gbkOut, gbkCoderID, outNode)\n+\n+\tgbkID := fmt.Sprintf(\"%v_gbk\", id)\n+\tgbk := &pb.PTransform{\n+\t\tUniqueName: gbkID,\n+\t\tSpec:       &pb.FunctionSpec{Urn: URNGBK},\n+\t\tInputs:     map[string]string{\"i0\": postReify},", "originalCommit": "968e45f6602a635f0f1229a374eed704672ef91e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMwNTMwNg==", "url": "https://github.com/apache/beam/pull/11197#discussion_r397305306", "bodyText": "Yup. postReify is the PCollection that has the random keys and the full windowed value as serialized bytes.\nThe input from the previous step is used on line 577.\nin represents strictly inbound data (and specifically the main input), and From indicates the \"Node\" in the graph. In this model of the pipeline PCollections are Nodes, and Transforms are Edges.", "author": "lostluck", "createdAt": "2020-03-24T16:47:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4NjU2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ1MTU1MA==", "url": "https://github.com/apache/beam/pull/11197#discussion_r397451550", "bodyText": "Oh ok, I see it now. I was completely misinterpreting the expansion here. So if I understand correctly, it should look like this, right? (With pcollections/nodes in square brackets and transforms/edges as arrows)\n[in.From] ---input---> [postReify] ---gbk---> [gbkOut] ---output---> [out.To]\n\nWhere input and output are the newly added Reshuffle transforms. That looks right to me, and rereading the code it looks consistent with that.", "author": "youngoli", "createdAt": "2020-03-24T20:49:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4NjU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4NzgxMA==", "url": "https://github.com/apache/beam/pull/11197#discussion_r396887810", "bodyText": "Here and elsewhere in this comment, Reshuffle is referred to as \"Reshard\". I think it's fine to refer to it as a reshard informally, since that's what it functionally is, but the places where it's used as a proper noun should be switched to Reshuffle.", "author": "youngoli", "createdAt": "2020-03-24T03:48:20Z", "path": "sdks/go/pkg/beam/gbk.go", "diffHunk": "@@ -95,3 +95,52 @@ func TryCoGroupByKey(s Scope, cols ...PCollection) (PCollection, error) {\n \tret.SetCoder(NewCoder(ret.Type()))\n \treturn ret, nil\n }\n+\n+// Reshuffle copies a PCollection of the same kind and using the same element\n+// coder, and maintains the same windowing information. Importantly, it allows\n+// the result PCollection to be processed with a different sharding, in a\n+// different stage than the input PCollection.\n+//\n+// For example, if a computation needs a lot of parallelism but\n+// produces only a small amount of output data, then the computation\n+// producing the data can run with as much parallelism as needed,\n+// while the output file is written with a smaller amount of\n+// parallelism, using the following pattern:\n+//\n+//   pc := bigHairyComputationNeedingParallelism(scope) // PCollection<string>\n+//   resharded := beam.Reshard(scope, pc)                // PCollection<string>", "originalCommit": "968e45f6602a635f0f1229a374eed704672ef91e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg4Nzk2Ng==", "url": "https://github.com/apache/beam/pull/11197#discussion_r396887966", "bodyText": "Same as previous comment, using Reshard instead of Reshuffle. The error message a few lines below also does that.", "author": "youngoli", "createdAt": "2020-03-24T03:49:02Z", "path": "sdks/go/pkg/beam/gbk.go", "diffHunk": "@@ -95,3 +95,52 @@ func TryCoGroupByKey(s Scope, cols ...PCollection) (PCollection, error) {\n \tret.SetCoder(NewCoder(ret.Type()))\n \treturn ret, nil\n }\n+\n+// Reshuffle copies a PCollection of the same kind and using the same element\n+// coder, and maintains the same windowing information. Importantly, it allows\n+// the result PCollection to be processed with a different sharding, in a\n+// different stage than the input PCollection.\n+//\n+// For example, if a computation needs a lot of parallelism but\n+// produces only a small amount of output data, then the computation\n+// producing the data can run with as much parallelism as needed,\n+// while the output file is written with a smaller amount of\n+// parallelism, using the following pattern:\n+//\n+//   pc := bigHairyComputationNeedingParallelism(scope) // PCollection<string>\n+//   resharded := beam.Reshard(scope, pc)                // PCollection<string>\n+//\n+// Another use case is when one has a non-deterministic DoFn followed by one\n+// that performs externally-visible side effects. Inserting a Reshard\n+// between these DoFns ensures that retries of the second DoFn will always be\n+// the same, which is necessary to make side effects idempotent.\n+//\n+// A Reshuffle will force a break in the optimized pipeline. Consequently,\n+// this operation should be used sparingly, only after determining that the\n+// pipeline without reshard is broken in some way and performing an extra\n+// operation is worth the cost.\n+func Reshuffle(s Scope, col PCollection) PCollection {\n+\treturn Must(TryReshuffle(s, col))\n+}\n+\n+// TryReshuffle inserts a Reshard into the pipeline, and returns an error if", "originalCommit": "968e45f6602a635f0f1229a374eed704672ef91e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dbd6d0ad3e31c43f0952e21ce0dec7976c203f56", "url": "https://github.com/apache/beam/commit/dbd6d0ad3e31c43f0952e21ce0dec7976c203f56", "message": "Update sdks/go/pkg/beam/core/runtime/exec/reshuffle.go\r\n\r\nsame code, but shorter\n\nCo-Authored-By: Daniel Oliveira <younghoono@gmail.com>", "committedDate": "2020-03-24T16:52:44Z", "type": "commit"}, {"oid": "250ea89c14328845d5238cbd6cd6a30bc13ac85d", "url": "https://github.com/apache/beam/commit/250ea89c14328845d5238cbd6cd6a30bc13ac85d", "message": "review comments", "committedDate": "2020-03-24T17:02:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ2ODg2Mg==", "url": "https://github.com/apache/beam/pull/11197#discussion_r399468862", "bodyText": "In answer to this comment, yes it should be Always", "author": "dpmills", "createdAt": "2020-03-27T18:41:06Z", "path": "sdks/go/pkg/beam/core/runtime/graphx/translate.go", "diffHunk": "@@ -473,6 +479,164 @@ func (m *marshaller) addNode(n *graph.Node) string {\n \treturn m.makeNode(id, m.coders.Add(n.Coder), n)\n }\n \n+// expandReshuffle translates resharding to a composite reshuffle\n+// transform.\n+//\n+// With proper runner support, the SDK doesn't need to do anything.\n+// However, we still need to provide a backup plan in terms of other\n+// PTransforms in the event the runner doesn't have a native implementation.\n+//\n+// In particular, the \"backup plan\" needs to:\n+//\n+//  * Encode the windowed element, preserving timestamps.\n+//  * Add random keys to the encoded windowed element []bytes\n+//  * GroupByKey (in the global window).\n+//  * Explode the resulting elements list.\n+//  * Decode the windowed element []bytes.\n+//\n+// While a simple reshard can be written in user terms, (timestamps and windows\n+// are accessible to user functions) there are some framework internal\n+// optimizations that can be done if the framework is aware of the reshard, though\n+// ideally this is handled on the runner side.\n+//\n+// User code is able to write reshards, but it's easier to access\n+// the window coders framework side, which is critical for the reshard\n+// to function with unbounded inputs.\n+func (m *marshaller) expandReshuffle(edge NamedEdge) string {\n+\tid := edgeID(edge.Edge)\n+\tvar kvCoderID, gbkCoderID string\n+\t{\n+\t\tkv := makeUnionCoder()\n+\t\tkvCoderID = m.coders.Add(kv)\n+\t\tgbkCoderID = m.coders.Add(coder.NewCoGBK(kv.Components))\n+\t}\n+\n+\tvar subtransforms []string\n+\n+\tin := edge.Edge.Input[0]\n+\n+\torigInput := m.addNode(in.From)\n+\t// We need to preserve the old windowing/triggering here\n+\t// for re-instatement after the GBK.\n+\tpreservedWSId := m.pcollections[origInput].GetWindowingStrategyId()\n+\n+\t// Get the windowing strategy from before:\n+\tpostReify := fmt.Sprintf(\"%v_%v_reifyts\", nodeID(in.From), id)\n+\tm.makeNode(postReify, kvCoderID, in.From)\n+\n+\t// We need to replace postReify's windowing strategy with one appropriate\n+\t// for reshuffles.\n+\t{\n+\t\twfn := window.NewGlobalWindows()\n+\t\tm.pcollections[postReify].WindowingStrategyId =\n+\t\t\tm.internWindowingStrategy(&pb.WindowingStrategy{\n+\t\t\t\t// Not segregated by time...\n+\t\t\t\tWindowFn: makeWindowFn(wfn),\n+\t\t\t\t// ...output after every element is received...\n+\t\t\t\tTrigger: &pb.Trigger{\n+\t\t\t\t\t// Should this be an Always trigger instead?", "originalCommit": "250ea89c14328845d5238cbd6cd6a30bc13ac85d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ3NDI0Mw==", "url": "https://github.com/apache/beam/pull/11197#discussion_r399474243", "bodyText": "Thanks!", "author": "lostluck", "createdAt": "2020-03-27T18:51:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ2ODg2Mg=="}], "type": "inlineReview"}, {"oid": "cf1621742d7527cdc909e0d5f481941945931cc9", "url": "https://github.com/apache/beam/commit/cf1621742d7527cdc909e0d5f481941945931cc9", "message": "Switch from ElementCount(1) to Always trigger.", "committedDate": "2020-03-27T18:51:45Z", "type": "commit"}]}