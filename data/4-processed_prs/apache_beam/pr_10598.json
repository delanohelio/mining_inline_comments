{"pr_number": 10598, "pr_title": "[BEAM-8626] Implement status fn api handler in python sdk", "pr_createdAt": "2020-01-15T18:04:30Z", "pr_url": "https://github.com/apache/beam/pull/10598", "timeline": [{"oid": "93665a903e1b015fe097c488971b808dd8125c70", "url": "https://github.com/apache/beam/commit/93665a903e1b015fe097c488971b808dd8125c70", "message": "[BEAM-8626] Implement status fn api handler in python sdk", "committedDate": "2020-01-15T18:56:13Z", "type": "forcePushed"}, {"oid": "7cc279797f17fcf40f3baefa3479e2d4fc75af47", "url": "https://github.com/apache/beam/commit/7cc279797f17fcf40f3baefa3479e2d4fc75af47", "message": "[BEAM-8626] Implement status fn api handler in python sdk", "committedDate": "2020-01-15T21:11:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0NTM0NA==", "url": "https://github.com/apache/beam/pull/10598#discussion_r367745344", "bodyText": "Let's add documentation and move it to sdks/python/apache_beam/testing/util.py", "author": "angoenka", "createdAt": "2020-01-17T02:38:04Z", "path": "sdks/python/apache_beam/runners/test/utils.py", "diffHunk": "@@ -0,0 +1,49 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\n+from __future__ import absolute_import\n+\n+import sys\n+import threading\n+\n+from future.utils import raise_\n+\n+\n+def timeout(timeout_secs):", "originalCommit": "7cc279797f17fcf40f3baefa3479e2d4fc75af47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0NTYyNw==", "url": "https://github.com/apache/beam/pull/10598#discussion_r367745627", "bodyText": "Let's add it as the last entry to keep the ordering of the arguments same and backward compatible,", "author": "angoenka", "createdAt": "2020-01-17T02:39:40Z", "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -73,6 +74,7 @@ class SdkHarness(object):\n \n   def __init__(self,\n                control_address,  # type: str\n+               status_address=None,  # type: Optional[str, unicode]", "originalCommit": "7cc279797f17fcf40f3baefa3479e2d4fc75af47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwNDg1NA==", "url": "https://github.com/apache/beam/pull/10598#discussion_r368104854", "bodyText": "done.", "author": "y1chi", "createdAt": "2020-01-17T19:41:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0NTYyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0NjQ1OQ==", "url": "https://github.com/apache/beam/pull/10598#discussion_r367746459", "bodyText": "Let's move it in sdk_worker_main where we keep other reporting related code.", "author": "angoenka", "createdAt": "2020-01-17T02:44:00Z", "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -110,6 +112,15 @@ def __init__(self,\n         data_channel_factory=self._data_channel_factory,\n         fns=self._fns)\n \n+    if status_address:", "originalCommit": "7cc279797f17fcf40f3baefa3479e2d4fc75af47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwNTYzOQ==", "url": "https://github.com/apache/beam/pull/10598#discussion_r368105639", "bodyText": "I need to do the actual initialization inside sdk_worker since I want to pass the active bundle cache in sdk worker in order to report the dangling operation.", "author": "y1chi", "createdAt": "2020-01-17T19:43:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0NjQ1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE5MDAxNg==", "url": "https://github.com/apache/beam/pull/10598#discussion_r369190016", "bodyText": "Sounds good", "author": "angoenka", "createdAt": "2020-01-21T19:11:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0NjQ1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0ODU5OA==", "url": "https://github.com/apache/beam/pull/10598#discussion_r367748598", "bodyText": "We have thread dump code in sdk_worker_main.py under get_thread_dump.\nShall we reuse it or move it here.", "author": "angoenka", "createdAt": "2020-01-17T02:55:40Z", "path": "sdks/python/apache_beam/runners/worker/worker_status.py", "diffHunk": "@@ -0,0 +1,139 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\"\"\"Worker status api handler for reporting SDK harness debug info.\"\"\"\n+\n+from __future__ import absolute_import\n+from __future__ import division\n+\n+import queue\n+import sys\n+import threading\n+import traceback\n+from collections import defaultdict\n+\n+import grpc\n+\n+from apache_beam.portability.api import beam_fn_api_pb2\n+from apache_beam.portability.api import beam_fn_api_pb2_grpc\n+from apache_beam.runners.worker.channel_factory import GRPCChannelFactory\n+from apache_beam.runners.worker.worker_id_interceptor import WorkerIdInterceptor\n+\n+\n+def thread_dump():", "originalCommit": "7cc279797f17fcf40f3baefa3479e2d4fc75af47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwMjc2NA==", "url": "https://github.com/apache/beam/pull/10598#discussion_r368102764", "bodyText": "I made few changes to the thread dump format. I'll reuse the function, I think eventually we probably won't need the status http server.", "author": "y1chi", "createdAt": "2020-01-17T19:36:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0ODU5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MzM5Mg==", "url": "https://github.com/apache/beam/pull/10598#discussion_r368193392", "bodyText": "I agree, we can get rid of status http server.", "author": "angoenka", "createdAt": "2020-01-18T01:07:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0ODU5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE5NTA1MA==", "url": "https://github.com/apache/beam/pull/10598#discussion_r369195050", "bodyText": "As mentioned above, Lets add a jira to clean StatusServer in sdk_worker_main", "author": "angoenka", "createdAt": "2020-01-21T19:21:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc0ODU5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1MTY4NQ==", "url": "https://github.com/apache/beam/pull/10598#discussion_r367751685", "bodyText": "We can also expose it over a http server on dynamic port.", "author": "angoenka", "createdAt": "2020-01-17T03:13:40Z", "path": "sdks/python/apache_beam/runners/worker/worker_status.py", "diffHunk": "@@ -0,0 +1,139 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\"\"\"Worker status api handler for reporting SDK harness debug info.\"\"\"\n+\n+from __future__ import absolute_import\n+from __future__ import division\n+\n+import queue\n+import sys\n+import threading\n+import traceback\n+from collections import defaultdict\n+\n+import grpc\n+\n+from apache_beam.portability.api import beam_fn_api_pb2\n+from apache_beam.portability.api import beam_fn_api_pb2_grpc\n+from apache_beam.runners.worker.channel_factory import GRPCChannelFactory\n+from apache_beam.runners.worker.worker_id_interceptor import WorkerIdInterceptor\n+\n+\n+def thread_dump():\n+  # deduplicate threads with same stack trace\n+  stack_traces = defaultdict(list)\n+  frames = sys._current_frames()  # pylint: disable=protected-access\n+\n+  for t in threading.enumerate():\n+    stack_trace = ''.join(traceback.format_stack(frames[t.ident]))\n+    thread_ident_name = (t.ident, t.name)\n+    stack_traces[stack_trace].append(thread_ident_name)\n+\n+  all_traces = ['=' * 10 + 'THREAD DUMP' + '=' * 10]\n+  for stack, identity in stack_traces.items():\n+    ident, name = identity[0]\n+    trace = '--- Thread #%s name: %s %s---\\n' % (\n+        ident, name, 'and other %d threads' %\n+        (len(identity) - 1) if len(identity) > 1 else '')\n+    if len(identity) > 1:\n+      trace += 'threads: %s\\n' % identity\n+    trace += stack\n+    all_traces.append(trace)\n+  all_traces.append('=' * 30)\n+  return '\\n'.join(x.encode('utf-8') for x in all_traces)\n+\n+\n+def active_processing_bundles_state(bundle_process_cache):\n+  active_bundles = ['=' * 10 + 'ACTIVE PROCESSING BUNDLES' + '=' * 10]\n+  if not bundle_process_cache.active_bundle_processors:\n+    active_bundles.append(\"No active processing bundles.\")\n+  else:\n+    cache = []\n+    for instruction in list(\n+        bundle_process_cache.active_bundle_processors.keys()):\n+      processor = bundle_process_cache.lookup(instruction)\n+      if processor:\n+        info = processor.state_sampler.get_info()\n+        cache.append((instruction,\n+                      processor.process_bundle_descriptor.id,\n+                      info.tracked_thread, info.time_since_transition))\n+    # reverse sort active bundle by time since last transition, keep top 10.\n+    cache.sort(key=lambda x: x[-1], reverse=True)\n+    for s in cache[:10]:\n+      state = '--- instruction %s ---\\n' % s[0]\n+      state += 'ProcessBundleDescriptorId: %s\\n' % s[1]\n+      state += \"tracked thread: %s\\n\" % s[2]\n+      state += \"time since transition: %.2f seconds\\n\" % (s[3] / 1e9)\n+      active_bundles.append(state)\n+\n+  active_bundles.append('=' * 30)\n+  return '\\n'.join(x.encode('utf-8') for x in active_bundles)\n+\n+\n+DONE = object()\n+\n+\n+class FnApiWorkerStatusHandler(object):\n+  def __init__(self, status_address, bundle_process_cache=None):\n+    self._alive = True\n+    self._bundle_process_cache = bundle_process_cache\n+    ch = GRPCChannelFactory.insecure_channel(status_address)\n+    grpc.channel_ready_future(ch).result(timeout=60)\n+    self._status_channel = grpc.intercept_channel(ch, WorkerIdInterceptor())\n+    self._status_stub = beam_fn_api_pb2_grpc.BeamFnWorkerStatusStub(\n+        self._status_channel)\n+    self._responses = queue.Queue()\n+    self._server = threading.Thread(target=lambda: self._serve(),\n+                                    name='fn_api_status_handler')\n+    self._server.daemon = True\n+    self._server.start()\n+\n+  def _get_responses(self):\n+    while True:\n+      response = self._responses.get()\n+      if response is DONE:\n+        self._alive = False\n+        return\n+      yield response\n+\n+  def _serve(self):\n+    while self._alive:\n+      for request in self._status_stub.WorkerStatus(self._get_responses()):\n+        try:\n+          response = self.generate_status_response()\n+        except Exception:\n+          traceback_string = traceback.format_exc()\n+          self._responses.put(\n+              beam_fn_api_pb2.WorkerStatusResponse(\n+                  id=request.id,\n+                  error=\"Exception encountered while generating \"\n+                  \"status page: %s\" % traceback_string))\n+          continue\n+\n+        self._responses.put(\n+            beam_fn_api_pb2.WorkerStatusResponse(id=request.id,\n+                                                 status_info=response))\n+\n+  def generate_status_response(self):", "originalCommit": "7cc279797f17fcf40f3baefa3479e2d4fc75af47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwNjcwNg==", "url": "https://github.com/apache/beam/pull/10598#discussion_r368106706", "bodyText": "it's possible but since eventually we'll be able to query the runner like localhost:port/sdk_status?id=<sdk_id>, it has same effect as exposing it individually.", "author": "y1chi", "createdAt": "2020-01-17T19:45:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1MTY4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE5MzQ0Mw==", "url": "https://github.com/apache/beam/pull/10598#discussion_r368193443", "bodyText": "Sounds reasonable.", "author": "angoenka", "createdAt": "2020-01-18T01:08:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1MTY4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1MjU4OA==", "url": "https://github.com/apache/beam/pull/10598#discussion_r367752588", "bodyText": "We can move the response collection here and avoid continue later on to make code simple.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      response = self.generate_status_response()\n          \n          \n            \n                      self._responses.put(beam_fn_api_pb2.WorkerStatusResponse(id=request.id, status_info=self.generate_status_response()))", "author": "angoenka", "createdAt": "2020-01-17T03:18:32Z", "path": "sdks/python/apache_beam/runners/worker/worker_status.py", "diffHunk": "@@ -0,0 +1,139 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\"\"\"Worker status api handler for reporting SDK harness debug info.\"\"\"\n+\n+from __future__ import absolute_import\n+from __future__ import division\n+\n+import queue\n+import sys\n+import threading\n+import traceback\n+from collections import defaultdict\n+\n+import grpc\n+\n+from apache_beam.portability.api import beam_fn_api_pb2\n+from apache_beam.portability.api import beam_fn_api_pb2_grpc\n+from apache_beam.runners.worker.channel_factory import GRPCChannelFactory\n+from apache_beam.runners.worker.worker_id_interceptor import WorkerIdInterceptor\n+\n+\n+def thread_dump():\n+  # deduplicate threads with same stack trace\n+  stack_traces = defaultdict(list)\n+  frames = sys._current_frames()  # pylint: disable=protected-access\n+\n+  for t in threading.enumerate():\n+    stack_trace = ''.join(traceback.format_stack(frames[t.ident]))\n+    thread_ident_name = (t.ident, t.name)\n+    stack_traces[stack_trace].append(thread_ident_name)\n+\n+  all_traces = ['=' * 10 + 'THREAD DUMP' + '=' * 10]\n+  for stack, identity in stack_traces.items():\n+    ident, name = identity[0]\n+    trace = '--- Thread #%s name: %s %s---\\n' % (\n+        ident, name, 'and other %d threads' %\n+        (len(identity) - 1) if len(identity) > 1 else '')\n+    if len(identity) > 1:\n+      trace += 'threads: %s\\n' % identity\n+    trace += stack\n+    all_traces.append(trace)\n+  all_traces.append('=' * 30)\n+  return '\\n'.join(x.encode('utf-8') for x in all_traces)\n+\n+\n+def active_processing_bundles_state(bundle_process_cache):\n+  active_bundles = ['=' * 10 + 'ACTIVE PROCESSING BUNDLES' + '=' * 10]\n+  if not bundle_process_cache.active_bundle_processors:\n+    active_bundles.append(\"No active processing bundles.\")\n+  else:\n+    cache = []\n+    for instruction in list(\n+        bundle_process_cache.active_bundle_processors.keys()):\n+      processor = bundle_process_cache.lookup(instruction)\n+      if processor:\n+        info = processor.state_sampler.get_info()\n+        cache.append((instruction,\n+                      processor.process_bundle_descriptor.id,\n+                      info.tracked_thread, info.time_since_transition))\n+    # reverse sort active bundle by time since last transition, keep top 10.\n+    cache.sort(key=lambda x: x[-1], reverse=True)\n+    for s in cache[:10]:\n+      state = '--- instruction %s ---\\n' % s[0]\n+      state += 'ProcessBundleDescriptorId: %s\\n' % s[1]\n+      state += \"tracked thread: %s\\n\" % s[2]\n+      state += \"time since transition: %.2f seconds\\n\" % (s[3] / 1e9)\n+      active_bundles.append(state)\n+\n+  active_bundles.append('=' * 30)\n+  return '\\n'.join(x.encode('utf-8') for x in active_bundles)\n+\n+\n+DONE = object()\n+\n+\n+class FnApiWorkerStatusHandler(object):\n+  def __init__(self, status_address, bundle_process_cache=None):\n+    self._alive = True\n+    self._bundle_process_cache = bundle_process_cache\n+    ch = GRPCChannelFactory.insecure_channel(status_address)\n+    grpc.channel_ready_future(ch).result(timeout=60)\n+    self._status_channel = grpc.intercept_channel(ch, WorkerIdInterceptor())\n+    self._status_stub = beam_fn_api_pb2_grpc.BeamFnWorkerStatusStub(\n+        self._status_channel)\n+    self._responses = queue.Queue()\n+    self._server = threading.Thread(target=lambda: self._serve(),\n+                                    name='fn_api_status_handler')\n+    self._server.daemon = True\n+    self._server.start()\n+\n+  def _get_responses(self):\n+    while True:\n+      response = self._responses.get()\n+      if response is DONE:\n+        self._alive = False\n+        return\n+      yield response\n+\n+  def _serve(self):\n+    while self._alive:\n+      for request in self._status_stub.WorkerStatus(self._get_responses()):\n+        try:\n+          response = self.generate_status_response()", "originalCommit": "7cc279797f17fcf40f3baefa3479e2d4fc75af47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwODY3OA==", "url": "https://github.com/apache/beam/pull/10598#discussion_r368108678", "bodyText": "done.", "author": "y1chi", "createdAt": "2020-01-17T19:50:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1MjU4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1MzI2Mg==", "url": "https://github.com/apache/beam/pull/10598#discussion_r367753262", "bodyText": "We can remove this if we move addition of response above.", "author": "angoenka", "createdAt": "2020-01-17T03:22:09Z", "path": "sdks/python/apache_beam/runners/worker/worker_status.py", "diffHunk": "@@ -0,0 +1,139 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\"\"\"Worker status api handler for reporting SDK harness debug info.\"\"\"\n+\n+from __future__ import absolute_import\n+from __future__ import division\n+\n+import queue\n+import sys\n+import threading\n+import traceback\n+from collections import defaultdict\n+\n+import grpc\n+\n+from apache_beam.portability.api import beam_fn_api_pb2\n+from apache_beam.portability.api import beam_fn_api_pb2_grpc\n+from apache_beam.runners.worker.channel_factory import GRPCChannelFactory\n+from apache_beam.runners.worker.worker_id_interceptor import WorkerIdInterceptor\n+\n+\n+def thread_dump():\n+  # deduplicate threads with same stack trace\n+  stack_traces = defaultdict(list)\n+  frames = sys._current_frames()  # pylint: disable=protected-access\n+\n+  for t in threading.enumerate():\n+    stack_trace = ''.join(traceback.format_stack(frames[t.ident]))\n+    thread_ident_name = (t.ident, t.name)\n+    stack_traces[stack_trace].append(thread_ident_name)\n+\n+  all_traces = ['=' * 10 + 'THREAD DUMP' + '=' * 10]\n+  for stack, identity in stack_traces.items():\n+    ident, name = identity[0]\n+    trace = '--- Thread #%s name: %s %s---\\n' % (\n+        ident, name, 'and other %d threads' %\n+        (len(identity) - 1) if len(identity) > 1 else '')\n+    if len(identity) > 1:\n+      trace += 'threads: %s\\n' % identity\n+    trace += stack\n+    all_traces.append(trace)\n+  all_traces.append('=' * 30)\n+  return '\\n'.join(x.encode('utf-8') for x in all_traces)\n+\n+\n+def active_processing_bundles_state(bundle_process_cache):\n+  active_bundles = ['=' * 10 + 'ACTIVE PROCESSING BUNDLES' + '=' * 10]\n+  if not bundle_process_cache.active_bundle_processors:\n+    active_bundles.append(\"No active processing bundles.\")\n+  else:\n+    cache = []\n+    for instruction in list(\n+        bundle_process_cache.active_bundle_processors.keys()):\n+      processor = bundle_process_cache.lookup(instruction)\n+      if processor:\n+        info = processor.state_sampler.get_info()\n+        cache.append((instruction,\n+                      processor.process_bundle_descriptor.id,\n+                      info.tracked_thread, info.time_since_transition))\n+    # reverse sort active bundle by time since last transition, keep top 10.\n+    cache.sort(key=lambda x: x[-1], reverse=True)\n+    for s in cache[:10]:\n+      state = '--- instruction %s ---\\n' % s[0]\n+      state += 'ProcessBundleDescriptorId: %s\\n' % s[1]\n+      state += \"tracked thread: %s\\n\" % s[2]\n+      state += \"time since transition: %.2f seconds\\n\" % (s[3] / 1e9)\n+      active_bundles.append(state)\n+\n+  active_bundles.append('=' * 30)\n+  return '\\n'.join(x.encode('utf-8') for x in active_bundles)\n+\n+\n+DONE = object()\n+\n+\n+class FnApiWorkerStatusHandler(object):\n+  def __init__(self, status_address, bundle_process_cache=None):\n+    self._alive = True\n+    self._bundle_process_cache = bundle_process_cache\n+    ch = GRPCChannelFactory.insecure_channel(status_address)\n+    grpc.channel_ready_future(ch).result(timeout=60)\n+    self._status_channel = grpc.intercept_channel(ch, WorkerIdInterceptor())\n+    self._status_stub = beam_fn_api_pb2_grpc.BeamFnWorkerStatusStub(\n+        self._status_channel)\n+    self._responses = queue.Queue()\n+    self._server = threading.Thread(target=lambda: self._serve(),\n+                                    name='fn_api_status_handler')\n+    self._server.daemon = True\n+    self._server.start()\n+\n+  def _get_responses(self):\n+    while True:\n+      response = self._responses.get()\n+      if response is DONE:\n+        self._alive = False\n+        return\n+      yield response\n+\n+  def _serve(self):\n+    while self._alive:\n+      for request in self._status_stub.WorkerStatus(self._get_responses()):\n+        try:\n+          response = self.generate_status_response()\n+        except Exception:\n+          traceback_string = traceback.format_exc()\n+          self._responses.put(\n+              beam_fn_api_pb2.WorkerStatusResponse(\n+                  id=request.id,\n+                  error=\"Exception encountered while generating \"\n+                  \"status page: %s\" % traceback_string))\n+          continue\n+\n+        self._responses.put(\n+            beam_fn_api_pb2.WorkerStatusResponse(id=request.id,\n+                                                 status_info=response))", "originalCommit": "7cc279797f17fcf40f3baefa3479e2d4fc75af47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwODY1Mg==", "url": "https://github.com/apache/beam/pull/10598#discussion_r368108652", "bodyText": "done.", "author": "y1chi", "createdAt": "2020-01-17T19:50:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc1MzI2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE5MzgyNg==", "url": "https://github.com/apache/beam/pull/10598#discussion_r369193826", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    _LOGGER.info('Error creating worker status request handler, skipping '\n          \n          \n            \n                    _LOGGER.warn('Error creating worker status request handler, skipping '", "author": "angoenka", "createdAt": "2020-01-21T19:19:17Z", "path": "sdks/python/apache_beam/runners/worker/sdk_worker.py", "diffHunk": "@@ -110,6 +112,15 @@ def __init__(self,\n         data_channel_factory=self._data_channel_factory,\n         fns=self._fns)\n \n+    if status_address:\n+      try:\n+        self._status_handler = FnApiWorkerStatusHandler(\n+            status_address, self._bundle_processor_cache)\n+      except Exception:\n+        traceback_string = traceback.format_exc()\n+        _LOGGER.info('Error creating worker status request handler, skipping '", "originalCommit": "20b8aac09c9d72c07b5c155b2afb9fc1dca351fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIzOTkyMA==", "url": "https://github.com/apache/beam/pull/10598#discussion_r369239920", "bodyText": "done.", "author": "y1chi", "createdAt": "2020-01-21T20:59:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE5MzgyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE5NDU0Mw==", "url": "https://github.com/apache/beam/pull/10598#discussion_r369194543", "bodyText": "Lets add a jira to clean StatusServer from here completely once we have rolled out Debug capture.", "author": "angoenka", "createdAt": "2020-01-21T19:20:47Z", "path": "sdks/python/apache_beam/runners/worker/sdk_worker_main.py", "diffHunk": "@@ -78,8 +67,7 @@ def do_GET(self):  # pylint: disable=invalid-name\n         self.send_header('Content-Type', 'text/plain')\n         self.end_headers()\n \n-        for line in StatusServer.get_thread_dump():\n-          self.wfile.write(line.encode('utf-8'))\n+        self.wfile.write(thread_dump())", "originalCommit": "20b8aac09c9d72c07b5c155b2afb9fc1dca351fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI1NTgxMw==", "url": "https://github.com/apache/beam/pull/10598#discussion_r369255813", "bodyText": "created https://issues.apache.org/jira/browse/BEAM-9165", "author": "y1chi", "createdAt": "2020-01-21T21:36:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE5NDU0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE5NjUxMA==", "url": "https://github.com/apache/beam/pull/10598#discussion_r369196510", "bodyText": "Let's add a jira to group threads which have same thread stack for easier analysis and reducing text size.\nThis can be a starter task for new beam contributors.", "author": "angoenka", "createdAt": "2020-01-21T19:24:47Z", "path": "sdks/python/apache_beam/runners/worker/worker_status.py", "diffHunk": "@@ -0,0 +1,148 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\"\"\"Worker status api handler for reporting SDK harness debug info.\"\"\"\n+\n+from __future__ import absolute_import\n+from __future__ import division\n+\n+import queue\n+import sys\n+import threading\n+import traceback\n+from collections import defaultdict\n+\n+import grpc\n+\n+from apache_beam.portability.api import beam_fn_api_pb2\n+from apache_beam.portability.api import beam_fn_api_pb2_grpc\n+from apache_beam.runners.worker.channel_factory import GRPCChannelFactory\n+from apache_beam.runners.worker.worker_id_interceptor import WorkerIdInterceptor\n+\n+\n+def thread_dump():\n+  \"\"\"Get a thread dump for the current SDK worker harness. \"\"\"\n+  # deduplicate threads with same stack trace\n+  stack_traces = defaultdict(list)\n+  frames = sys._current_frames()  # pylint: disable=protected-access\n+\n+  for t in threading.enumerate():\n+    stack_trace = ''.join(traceback.format_stack(frames[t.ident]))\n+    thread_ident_name = (t.ident, t.name)\n+    stack_traces[stack_trace].append(thread_ident_name)\n+\n+  all_traces = ['=' * 10 + 'THREAD DUMP' + '=' * 10]\n+  for stack, identity in stack_traces.items():", "originalCommit": "20b8aac09c9d72c07b5c155b2afb9fc1dca351fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIzNzM3NA==", "url": "https://github.com/apache/beam/pull/10598#discussion_r369237374", "bodyText": "isn't it already included in this PR?", "author": "y1chi", "createdAt": "2020-01-21T20:53:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE5NjUxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI1MjU0Mg==", "url": "https://github.com/apache/beam/pull/10598#discussion_r369252542", "bodyText": "You are right. It's already in this PR.\nWe can print names of all the threads along with count so that we don't miss any information.", "author": "angoenka", "createdAt": "2020-01-21T21:29:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE5NjUxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE5NzY3OA==", "url": "https://github.com/apache/beam/pull/10598#discussion_r369197678", "bodyText": "This can be private method.", "author": "angoenka", "createdAt": "2020-01-21T19:27:07Z", "path": "sdks/python/apache_beam/runners/worker/worker_status.py", "diffHunk": "@@ -0,0 +1,148 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\"\"\"Worker status api handler for reporting SDK harness debug info.\"\"\"\n+\n+from __future__ import absolute_import\n+from __future__ import division\n+\n+import queue\n+import sys\n+import threading\n+import traceback\n+from collections import defaultdict\n+\n+import grpc\n+\n+from apache_beam.portability.api import beam_fn_api_pb2\n+from apache_beam.portability.api import beam_fn_api_pb2_grpc\n+from apache_beam.runners.worker.channel_factory import GRPCChannelFactory\n+from apache_beam.runners.worker.worker_id_interceptor import WorkerIdInterceptor\n+\n+\n+def thread_dump():\n+  \"\"\"Get a thread dump for the current SDK worker harness. \"\"\"\n+  # deduplicate threads with same stack trace\n+  stack_traces = defaultdict(list)\n+  frames = sys._current_frames()  # pylint: disable=protected-access\n+\n+  for t in threading.enumerate():\n+    stack_trace = ''.join(traceback.format_stack(frames[t.ident]))\n+    thread_ident_name = (t.ident, t.name)\n+    stack_traces[stack_trace].append(thread_ident_name)\n+\n+  all_traces = ['=' * 10 + 'THREAD DUMP' + '=' * 10]\n+  for stack, identity in stack_traces.items():\n+    ident, name = identity[0]\n+    trace = '--- Thread #%s name: %s %s---\\n' % (\n+        ident, name, 'and other %d threads' %\n+        (len(identity) - 1) if len(identity) > 1 else '')\n+    if len(identity) > 1:\n+      trace += 'threads: %s\\n' % identity\n+    trace += stack\n+    all_traces.append(trace)\n+  all_traces.append('=' * 30)\n+  return '\\n'.join(x.encode('utf-8') for x in all_traces)\n+\n+\n+def active_processing_bundles_state(bundle_process_cache):", "originalCommit": "20b8aac09c9d72c07b5c155b2afb9fc1dca351fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI1NTk2Mg==", "url": "https://github.com/apache/beam/pull/10598#discussion_r369255962", "bodyText": "done.", "author": "y1chi", "createdAt": "2020-01-21T21:36:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE5NzY3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI1Nzc3NQ==", "url": "https://github.com/apache/beam/pull/10598#discussion_r369257775", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                trace = '--- Thread #%s name: %s %s---\\n' % (\n          \n          \n            \n                trace = '--- Threads (%d) %s --- \\n' % (len(identity), [ident+':'+name for (ident, name) in identity])", "author": "angoenka", "createdAt": "2020-01-21T21:41:05Z", "path": "sdks/python/apache_beam/runners/worker/worker_status.py", "diffHunk": "@@ -0,0 +1,148 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+\"\"\"Worker status api handler for reporting SDK harness debug info.\"\"\"\n+\n+from __future__ import absolute_import\n+from __future__ import division\n+\n+import queue\n+import sys\n+import threading\n+import traceback\n+from collections import defaultdict\n+\n+import grpc\n+\n+from apache_beam.portability.api import beam_fn_api_pb2\n+from apache_beam.portability.api import beam_fn_api_pb2_grpc\n+from apache_beam.runners.worker.channel_factory import GRPCChannelFactory\n+from apache_beam.runners.worker.worker_id_interceptor import WorkerIdInterceptor\n+\n+\n+def thread_dump():\n+  \"\"\"Get a thread dump for the current SDK worker harness. \"\"\"\n+  # deduplicate threads with same stack trace\n+  stack_traces = defaultdict(list)\n+  frames = sys._current_frames()  # pylint: disable=protected-access\n+\n+  for t in threading.enumerate():\n+    stack_trace = ''.join(traceback.format_stack(frames[t.ident]))\n+    thread_ident_name = (t.ident, t.name)\n+    stack_traces[stack_trace].append(thread_ident_name)\n+\n+  all_traces = ['=' * 10 + 'THREAD DUMP' + '=' * 10]\n+  for stack, identity in stack_traces.items():\n+    ident, name = identity[0]\n+    trace = '--- Thread #%s name: %s %s---\\n' % (", "originalCommit": "20b8aac09c9d72c07b5c155b2afb9fc1dca351fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI2NDk2MA==", "url": "https://github.com/apache/beam/pull/10598#discussion_r369264960", "bodyText": "this is already printed in a separated line below.", "author": "y1chi", "createdAt": "2020-01-21T21:57:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI1Nzc3NQ=="}], "type": "inlineReview"}, {"oid": "04c14a176eaa47bc6ca35683299d5679908544cd", "url": "https://github.com/apache/beam/commit/04c14a176eaa47bc6ca35683299d5679908544cd", "message": "fixup", "committedDate": "2020-01-23T21:50:58Z", "type": "forcePushed"}, {"oid": "747cd9c3a61e8267757d68097f91168dc166878a", "url": "https://github.com/apache/beam/commit/747cd9c3a61e8267757d68097f91168dc166878a", "message": "[BEAM-8626] Implement status fn api handler in python sdk", "committedDate": "2020-01-23T21:52:07Z", "type": "commit"}, {"oid": "549d7c1ea927248f6fb9e5b32ffd4ce4f67ac322", "url": "https://github.com/apache/beam/commit/549d7c1ea927248f6fb9e5b32ffd4ce4f67ac322", "message": "Address comments", "committedDate": "2020-01-23T21:52:07Z", "type": "commit"}, {"oid": "d753736697021e998784be7b78260bab39b76a52", "url": "https://github.com/apache/beam/commit/d753736697021e998784be7b78260bab39b76a52", "message": "fixup", "committedDate": "2020-01-23T21:55:25Z", "type": "commit"}, {"oid": "d753736697021e998784be7b78260bab39b76a52", "url": "https://github.com/apache/beam/commit/d753736697021e998784be7b78260bab39b76a52", "message": "fixup", "committedDate": "2020-01-23T21:55:25Z", "type": "forcePushed"}, {"oid": "2e0247981f834ec5df61475b284f605e034bc635", "url": "https://github.com/apache/beam/commit/2e0247981f834ec5df61475b284f605e034bc635", "message": "fix test", "committedDate": "2020-01-24T21:21:02Z", "type": "forcePushed"}, {"oid": "b1bd4660efce5bfd03536f27e6e7d6de37994c11", "url": "https://github.com/apache/beam/commit/b1bd4660efce5bfd03536f27e6e7d6de37994c11", "message": "fix test", "committedDate": "2020-01-24T21:32:34Z", "type": "commit"}, {"oid": "b1bd4660efce5bfd03536f27e6e7d6de37994c11", "url": "https://github.com/apache/beam/commit/b1bd4660efce5bfd03536f27e6e7d6de37994c11", "message": "fix test", "committedDate": "2020-01-24T21:32:34Z", "type": "forcePushed"}]}