{"pr_number": 10946, "pr_title": "[BEAM-9363] TUMBLE as TVF", "pr_createdAt": "2020-02-24T06:34:09Z", "pr_url": "https://github.com/apache/beam/pull/10946", "timeline": [{"oid": "f8daf25aede8eb76e80352a48e31c0e72775f8a5", "url": "https://github.com/apache/beam/commit/f8daf25aede8eb76e80352a48e31c0e72775f8a5", "message": "[BEAM-9363] TUMBLE as TVF.", "committedDate": "2020-04-14T18:19:53Z", "type": "forcePushed"}, {"oid": "0a3eadfacf14ffd8fd5355cfca1d8c346951e20c", "url": "https://github.com/apache/beam/commit/0a3eadfacf14ffd8fd5355cfca1d8c346951e20c", "message": "[BEAM-9363] TUMBLE as TVF.", "committedDate": "2020-04-14T18:21:50Z", "type": "forcePushed"}, {"oid": "999b44ca918f355cba37d11533a05751eebbd9bf", "url": "https://github.com/apache/beam/commit/999b44ca918f355cba37d11533a05751eebbd9bf", "message": "[BEAM-9363] TUMBLE as TVF.", "committedDate": "2020-04-14T18:24:33Z", "type": "forcePushed"}, {"oid": "0d1f235d3d4fb647027ad5ec625973802a15c7d0", "url": "https://github.com/apache/beam/commit/0d1f235d3d4fb647027ad5ec625973802a15c7d0", "message": "[BEAM-9363] TUMBLE as TVF.", "committedDate": "2020-04-14T18:27:09Z", "type": "commit"}, {"oid": "0d1f235d3d4fb647027ad5ec625973802a15c7d0", "url": "https://github.com/apache/beam/commit/0d1f235d3d4fb647027ad5ec625973802a15c7d0", "message": "[BEAM-9363] TUMBLE as TVF.", "committedDate": "2020-04-14T18:27:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM0ODIyMQ==", "url": "https://github.com/apache/beam/pull/10946#discussion_r408348221", "bodyText": "This is named like it is a generic table function scan, but it seems to implement just a very specialized table function. Shouldn't the function be a parameter to the rel?", "author": "kennknowles", "createdAt": "2020-04-14T18:29:52Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamTableFunctionScanRel.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.sql.impl.rel;\n+\n+import static org.apache.beam.vendor.calcite.v1_20_0.com.google.common.base.Preconditions.checkArgument;\n+\n+import java.lang.reflect.Type;\n+import java.util.List;\n+import java.util.Set;\n+import org.apache.beam.sdk.extensions.sql.impl.planner.BeamCostModel;\n+import org.apache.beam.sdk.extensions.sql.impl.planner.NodeStats;\n+import org.apache.beam.sdk.extensions.sql.impl.utils.CalciteUtils;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.windowing.FixedWindows;\n+import org.apache.beam.sdk.transforms.windowing.IntervalWindow;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.Row;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.plan.RelOptCluster;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.plan.RelTraitSet;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.RelNode;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.core.TableFunctionScan;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.metadata.RelColumnMapping;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelDataType;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexCall;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexInputRef;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexLiteral;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexNode;\n+import org.joda.time.Duration;\n+\n+public class BeamTableFunctionScanRel extends TableFunctionScan implements BeamRelNode {", "originalCommit": "0d1f235d3d4fb647027ad5ec625973802a15c7d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM1MTQ0Ng==", "url": "https://github.com/apache/beam/pull/10946#discussion_r408351446", "bodyText": "I agree your opinion on parametrization.\nGiven that only windowing TVF is the only TVF usage, having or not having a parameter does not matter, because I don't have a concrete idea what other table-valued function we will support and how.\nI would like to leave parametrization to the future when there is a need to support other TVF.  Either we limit windowing to BeamWindowingTableFunctionScanRel and have another Rel for other usage, or still have a general Rel but support all. It's not clear to me which approach is better, and that might can be answered when there is a need to support other  usage.\nAlso to clarify: I do have a plan to support not only UDF, UDAF, but also user-defined tabled function, and that will happen in near term.", "author": "amaliujia", "createdAt": "2020-04-14T18:35:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM0ODIyMQ=="}], "type": "inlineReview"}, {"oid": "cef7f2b0dfded87b4a2df7f3ecc52b491104a169", "url": "https://github.com/apache/beam/commit/cef7f2b0dfded87b4a2df7f3ecc52b491104a169", "message": "fixup! add missing java import.", "committedDate": "2020-04-14T20:14:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY0ODc0NA==", "url": "https://github.com/apache/beam/pull/10946#discussion_r421648744", "bodyText": "Can you add a class comment please?", "author": "tysonjh", "createdAt": "2020-05-07T16:49:41Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamTableFunctionScanRel.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.sql.impl.rel;\n+\n+import static org.apache.beam.vendor.calcite.v1_20_0.com.google.common.base.Preconditions.checkArgument;\n+\n+import java.lang.reflect.Type;\n+import java.util.List;\n+import java.util.Set;\n+import org.apache.beam.sdk.extensions.sql.impl.planner.BeamCostModel;\n+import org.apache.beam.sdk.extensions.sql.impl.planner.NodeStats;\n+import org.apache.beam.sdk.extensions.sql.impl.utils.CalciteUtils;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.windowing.FixedWindows;\n+import org.apache.beam.sdk.transforms.windowing.IntervalWindow;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.Row;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.plan.RelOptCluster;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.plan.RelTraitSet;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.RelNode;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.core.TableFunctionScan;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.metadata.RelColumnMapping;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelDataType;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexCall;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexInputRef;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexLiteral;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexNode;\n+import org.joda.time.Duration;\n+\n+public class BeamTableFunctionScanRel extends TableFunctionScan implements BeamRelNode {", "originalCommit": "0d1f235d3d4fb647027ad5ec625973802a15c7d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM0NTY1Nw==", "url": "https://github.com/apache/beam/pull/10946#discussion_r422345657", "bodyText": "Done", "author": "amaliujia", "createdAt": "2020-05-08T20:02:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY0ODc0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY0OTYzOQ==", "url": "https://github.com/apache/beam/pull/10946#discussion_r421649639", "bodyText": "This is now closed. Maybe it is worth cleaning up the comment now?", "author": "tysonjh", "createdAt": "2020-05-07T16:51:08Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/planner/BeamRuleSets.java", "diffHunk": "@@ -133,7 +134,7 @@\n           // remove unnecessary sort rule\n           // https://issues.apache.org/jira/browse/BEAM-5073", "originalCommit": "0d1f235d3d4fb647027ad5ec625973802a15c7d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM0NTk0OA==", "url": "https://github.com/apache/beam/pull/10946#discussion_r422345948", "bodyText": "Nice catch. I decided to re-open that Jira (so keep the work for re-enabling SortRemoveRule).\nKeep comments as what it is now.", "author": "amaliujia", "createdAt": "2020-05-08T20:03:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY0OTYzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY1NjYwNw==", "url": "https://github.com/apache/beam/pull/10946#discussion_r421656607", "bodyText": "I don't know checkArgument too well, does it output the expected size? E.g. it would be nice if this error message said something like,\n%s expected 1 input but received %s", "author": "tysonjh", "createdAt": "2020-05-07T17:02:20Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamTableFunctionScanRel.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.sql.impl.rel;\n+\n+import static org.apache.beam.vendor.calcite.v1_20_0.com.google.common.base.Preconditions.checkArgument;\n+\n+import java.lang.reflect.Type;\n+import java.util.List;\n+import java.util.Set;\n+import org.apache.beam.sdk.extensions.sql.impl.planner.BeamCostModel;\n+import org.apache.beam.sdk.extensions.sql.impl.planner.NodeStats;\n+import org.apache.beam.sdk.extensions.sql.impl.utils.CalciteUtils;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.windowing.FixedWindows;\n+import org.apache.beam.sdk.transforms.windowing.IntervalWindow;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.Row;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.plan.RelOptCluster;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.plan.RelTraitSet;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.RelNode;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.core.TableFunctionScan;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.metadata.RelColumnMapping;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelDataType;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexCall;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexInputRef;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexLiteral;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexNode;\n+import org.joda.time.Duration;\n+\n+public class BeamTableFunctionScanRel extends TableFunctionScan implements BeamRelNode {\n+  public BeamTableFunctionScanRel(\n+      RelOptCluster cluster,\n+      RelTraitSet traitSet,\n+      List<RelNode> inputs,\n+      RexNode rexCall,\n+      Type elementType,\n+      RelDataType rowType,\n+      Set<RelColumnMapping> columnMappings) {\n+    super(cluster, traitSet, inputs, rexCall, elementType, rowType, columnMappings);\n+  }\n+\n+  @Override\n+  public TableFunctionScan copy(\n+      RelTraitSet traitSet,\n+      List<RelNode> list,\n+      RexNode rexNode,\n+      Type type,\n+      RelDataType relDataType,\n+      Set<RelColumnMapping> set) {\n+    return new BeamTableFunctionScanRel(\n+        getCluster(), traitSet, list, rexNode, type, relDataType, columnMappings);\n+  }\n+\n+  @Override\n+  public PTransform<PCollectionList<Row>, PCollection<Row>> buildPTransform() {\n+    return new Transform();\n+  }\n+\n+  private class Transform extends PTransform<PCollectionList<Row>, PCollection<Row>> {\n+\n+    @Override\n+    public PCollection<Row> expand(PCollectionList<Row> input) {\n+      checkArgument(\n+          input.size() == 1,\n+          \"Wrong number of inputs for %s: %s\",", "originalCommit": "0d1f235d3d4fb647027ad5ec625973802a15c7d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM0NjA0OQ==", "url": "https://github.com/apache/beam/pull/10946#discussion_r422346049", "bodyText": "Nice idea! Done!", "author": "amaliujia", "createdAt": "2020-05-08T20:03:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY1NjYwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY1ODIzNA==", "url": "https://github.com/apache/beam/pull/10946#discussion_r421658234", "bodyText": "Here too. It would be nice if the error message included the offending operator name.", "author": "tysonjh", "createdAt": "2020-05-07T17:05:02Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamTableFunctionScanRel.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.sql.impl.rel;\n+\n+import static org.apache.beam.vendor.calcite.v1_20_0.com.google.common.base.Preconditions.checkArgument;\n+\n+import java.lang.reflect.Type;\n+import java.util.List;\n+import java.util.Set;\n+import org.apache.beam.sdk.extensions.sql.impl.planner.BeamCostModel;\n+import org.apache.beam.sdk.extensions.sql.impl.planner.NodeStats;\n+import org.apache.beam.sdk.extensions.sql.impl.utils.CalciteUtils;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.windowing.FixedWindows;\n+import org.apache.beam.sdk.transforms.windowing.IntervalWindow;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.Row;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.plan.RelOptCluster;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.plan.RelTraitSet;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.RelNode;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.core.TableFunctionScan;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.metadata.RelColumnMapping;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelDataType;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexCall;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexInputRef;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexLiteral;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexNode;\n+import org.joda.time.Duration;\n+\n+public class BeamTableFunctionScanRel extends TableFunctionScan implements BeamRelNode {\n+  public BeamTableFunctionScanRel(\n+      RelOptCluster cluster,\n+      RelTraitSet traitSet,\n+      List<RelNode> inputs,\n+      RexNode rexCall,\n+      Type elementType,\n+      RelDataType rowType,\n+      Set<RelColumnMapping> columnMappings) {\n+    super(cluster, traitSet, inputs, rexCall, elementType, rowType, columnMappings);\n+  }\n+\n+  @Override\n+  public TableFunctionScan copy(\n+      RelTraitSet traitSet,\n+      List<RelNode> list,\n+      RexNode rexNode,\n+      Type type,\n+      RelDataType relDataType,\n+      Set<RelColumnMapping> set) {\n+    return new BeamTableFunctionScanRel(\n+        getCluster(), traitSet, list, rexNode, type, relDataType, columnMappings);\n+  }\n+\n+  @Override\n+  public PTransform<PCollectionList<Row>, PCollection<Row>> buildPTransform() {\n+    return new Transform();\n+  }\n+\n+  private class Transform extends PTransform<PCollectionList<Row>, PCollection<Row>> {\n+\n+    @Override\n+    public PCollection<Row> expand(PCollectionList<Row> input) {\n+      checkArgument(\n+          input.size() == 1,\n+          \"Wrong number of inputs for %s: %s\",\n+          BeamTableFunctionScanRel.class.getSimpleName(),\n+          input);\n+      checkArgument(\n+          ((RexCall) getCall()).getOperator().getName().equals(\"TUMBLE\"),\n+          \"Only support TUMBLE table-valued function\");", "originalCommit": "0d1f235d3d4fb647027ad5ec625973802a15c7d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNDc5Ng==", "url": "https://github.com/apache/beam/pull/10946#discussion_r422414796", "bodyText": "Done.", "author": "amaliujia", "createdAt": "2020-05-08T23:11:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY1ODIzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2MTY4NA==", "url": "https://github.com/apache/beam/pull/10946#discussion_r421661684", "bodyText": "If this isn't to be resolved in this PR, would having an associated Jira be appropriate?\nOr... is this TODO out of date? I see window start and end are used below.", "author": "tysonjh", "createdAt": "2020-05-07T17:10:59Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamTableFunctionScanRel.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.sql.impl.rel;\n+\n+import static org.apache.beam.vendor.calcite.v1_20_0.com.google.common.base.Preconditions.checkArgument;\n+\n+import java.lang.reflect.Type;\n+import java.util.List;\n+import java.util.Set;\n+import org.apache.beam.sdk.extensions.sql.impl.planner.BeamCostModel;\n+import org.apache.beam.sdk.extensions.sql.impl.planner.NodeStats;\n+import org.apache.beam.sdk.extensions.sql.impl.utils.CalciteUtils;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.windowing.FixedWindows;\n+import org.apache.beam.sdk.transforms.windowing.IntervalWindow;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.Row;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.plan.RelOptCluster;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.plan.RelTraitSet;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.RelNode;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.core.TableFunctionScan;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.metadata.RelColumnMapping;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelDataType;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexCall;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexInputRef;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexLiteral;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexNode;\n+import org.joda.time.Duration;\n+\n+public class BeamTableFunctionScanRel extends TableFunctionScan implements BeamRelNode {\n+  public BeamTableFunctionScanRel(\n+      RelOptCluster cluster,\n+      RelTraitSet traitSet,\n+      List<RelNode> inputs,\n+      RexNode rexCall,\n+      Type elementType,\n+      RelDataType rowType,\n+      Set<RelColumnMapping> columnMappings) {\n+    super(cluster, traitSet, inputs, rexCall, elementType, rowType, columnMappings);\n+  }\n+\n+  @Override\n+  public TableFunctionScan copy(\n+      RelTraitSet traitSet,\n+      List<RelNode> list,\n+      RexNode rexNode,\n+      Type type,\n+      RelDataType relDataType,\n+      Set<RelColumnMapping> set) {\n+    return new BeamTableFunctionScanRel(\n+        getCluster(), traitSet, list, rexNode, type, relDataType, columnMappings);\n+  }\n+\n+  @Override\n+  public PTransform<PCollectionList<Row>, PCollection<Row>> buildPTransform() {\n+    return new Transform();\n+  }\n+\n+  private class Transform extends PTransform<PCollectionList<Row>, PCollection<Row>> {\n+\n+    @Override\n+    public PCollection<Row> expand(PCollectionList<Row> input) {\n+      checkArgument(\n+          input.size() == 1,\n+          \"Wrong number of inputs for %s: %s\",\n+          BeamTableFunctionScanRel.class.getSimpleName(),\n+          input);\n+      checkArgument(\n+          ((RexCall) getCall()).getOperator().getName().equals(\"TUMBLE\"),\n+          \"Only support TUMBLE table-valued function\");\n+      RexCall call = ((RexCall) getCall());\n+      RexInputRef wmCol = (RexInputRef) call.getOperands().get(1);\n+      PCollection<Row> upstream = input.get(0);\n+      Schema outputSchema = CalciteUtils.toSchema(getRowType());\n+      return upstream\n+          .apply(\n+              ParDo.of(\n+                  new FixedWindowDoFn(\n+                      FixedWindows.of(durationParameter(call.getOperands().get(2))),\n+                      wmCol.getIndex(),\n+                      outputSchema)))\n+          .setRowSchema(outputSchema);\n+    }\n+  }\n+\n+  private Duration durationParameter(RexNode node) {\n+    return Duration.millis(longValue(node));\n+  }\n+\n+  private long longValue(RexNode operand) {\n+    if (operand instanceof RexLiteral) {\n+      return ((Number) RexLiteral.value(operand)).longValue();\n+    } else {\n+      throw new IllegalArgumentException(String.format(\"[%s] is not valid.\", operand));\n+    }\n+  }\n+\n+  private static class FixedWindowDoFn extends DoFn<Row, Row> {\n+    private int windowFieldIndex;\n+    private FixedWindows windowFn;\n+    private Schema outputSchema;\n+\n+    public FixedWindowDoFn(FixedWindows windowFn, int windowFieldIndex, Schema schema) {\n+      this.windowFn = windowFn;\n+      this.windowFieldIndex = windowFieldIndex;\n+      this.outputSchema = schema;\n+    }\n+\n+    @ProcessElement\n+    public void processElement(ProcessContext c) {\n+      Row row = c.element();\n+      IntervalWindow window = windowFn.assignWindow(row.getDateTime(windowFieldIndex).toInstant());\n+      Row.Builder builder = Row.withSchema(outputSchema);\n+      builder.addValues(row.getValues());\n+      // TODO: add window_start and window_end;", "originalCommit": "0d1f235d3d4fb647027ad5ec625973802a15c7d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM0NjE5Mg==", "url": "https://github.com/apache/beam/pull/10946#discussion_r422346192", "bodyText": "Ah it is out-of-date... Removed", "author": "amaliujia", "createdAt": "2020-05-08T20:03:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2MTY4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2NDgxNg==", "url": "https://github.com/apache/beam/pull/10946#discussion_r421664816", "bodyText": "Can you explain the logic here? It may be worth adding a comment to describe the calculation.\nFor example, how does cpu = row_count^2 * row_size ? It isn't obvious to me.", "author": "tysonjh", "createdAt": "2020-05-07T17:16:25Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamTableFunctionScanRel.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.sql.impl.rel;\n+\n+import static org.apache.beam.vendor.calcite.v1_20_0.com.google.common.base.Preconditions.checkArgument;\n+\n+import java.lang.reflect.Type;\n+import java.util.List;\n+import java.util.Set;\n+import org.apache.beam.sdk.extensions.sql.impl.planner.BeamCostModel;\n+import org.apache.beam.sdk.extensions.sql.impl.planner.NodeStats;\n+import org.apache.beam.sdk.extensions.sql.impl.utils.CalciteUtils;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.windowing.FixedWindows;\n+import org.apache.beam.sdk.transforms.windowing.IntervalWindow;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.Row;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.plan.RelOptCluster;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.plan.RelTraitSet;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.RelNode;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.core.TableFunctionScan;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.metadata.RelColumnMapping;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelDataType;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexCall;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexInputRef;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexLiteral;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexNode;\n+import org.joda.time.Duration;\n+\n+public class BeamTableFunctionScanRel extends TableFunctionScan implements BeamRelNode {\n+  public BeamTableFunctionScanRel(\n+      RelOptCluster cluster,\n+      RelTraitSet traitSet,\n+      List<RelNode> inputs,\n+      RexNode rexCall,\n+      Type elementType,\n+      RelDataType rowType,\n+      Set<RelColumnMapping> columnMappings) {\n+    super(cluster, traitSet, inputs, rexCall, elementType, rowType, columnMappings);\n+  }\n+\n+  @Override\n+  public TableFunctionScan copy(\n+      RelTraitSet traitSet,\n+      List<RelNode> list,\n+      RexNode rexNode,\n+      Type type,\n+      RelDataType relDataType,\n+      Set<RelColumnMapping> set) {\n+    return new BeamTableFunctionScanRel(\n+        getCluster(), traitSet, list, rexNode, type, relDataType, columnMappings);\n+  }\n+\n+  @Override\n+  public PTransform<PCollectionList<Row>, PCollection<Row>> buildPTransform() {\n+    return new Transform();\n+  }\n+\n+  private class Transform extends PTransform<PCollectionList<Row>, PCollection<Row>> {\n+\n+    @Override\n+    public PCollection<Row> expand(PCollectionList<Row> input) {\n+      checkArgument(\n+          input.size() == 1,\n+          \"Wrong number of inputs for %s: %s\",\n+          BeamTableFunctionScanRel.class.getSimpleName(),\n+          input);\n+      checkArgument(\n+          ((RexCall) getCall()).getOperator().getName().equals(\"TUMBLE\"),\n+          \"Only support TUMBLE table-valued function\");\n+      RexCall call = ((RexCall) getCall());\n+      RexInputRef wmCol = (RexInputRef) call.getOperands().get(1);\n+      PCollection<Row> upstream = input.get(0);\n+      Schema outputSchema = CalciteUtils.toSchema(getRowType());\n+      return upstream\n+          .apply(\n+              ParDo.of(\n+                  new FixedWindowDoFn(\n+                      FixedWindows.of(durationParameter(call.getOperands().get(2))),\n+                      wmCol.getIndex(),\n+                      outputSchema)))\n+          .setRowSchema(outputSchema);\n+    }\n+  }\n+\n+  private Duration durationParameter(RexNode node) {\n+    return Duration.millis(longValue(node));\n+  }\n+\n+  private long longValue(RexNode operand) {\n+    if (operand instanceof RexLiteral) {\n+      return ((Number) RexLiteral.value(operand)).longValue();\n+    } else {\n+      throw new IllegalArgumentException(String.format(\"[%s] is not valid.\", operand));\n+    }\n+  }\n+\n+  private static class FixedWindowDoFn extends DoFn<Row, Row> {\n+    private int windowFieldIndex;\n+    private FixedWindows windowFn;\n+    private Schema outputSchema;\n+\n+    public FixedWindowDoFn(FixedWindows windowFn, int windowFieldIndex, Schema schema) {\n+      this.windowFn = windowFn;\n+      this.windowFieldIndex = windowFieldIndex;\n+      this.outputSchema = schema;\n+    }\n+\n+    @ProcessElement\n+    public void processElement(ProcessContext c) {\n+      Row row = c.element();\n+      IntervalWindow window = windowFn.assignWindow(row.getDateTime(windowFieldIndex).toInstant());\n+      Row.Builder builder = Row.withSchema(outputSchema);\n+      builder.addValues(row.getValues());\n+      // TODO: add window_start and window_end;\n+      builder.addValue(window.start());\n+      builder.addValue(window.end());\n+      c.output(builder.build());\n+    }\n+  }\n+\n+  @Override\n+  public NodeStats estimateNodeStats(RelMetadataQuery mq) {\n+    return BeamSqlRelUtils.getNodeStats(getInput(0), mq);\n+  }\n+\n+  @Override\n+  public BeamCostModel beamComputeSelfCost(RelOptPlanner planner, RelMetadataQuery mq) {\n+    NodeStats inputEstimates = BeamSqlRelUtils.getNodeStats(getInput(0), mq);\n+\n+    final double rowSize = getRowType().getFieldCount();\n+    final double cpu = inputEstimates.getRowCount() * inputEstimates.getRowCount() * rowSize;\n+    final double cpuRate = inputEstimates.getRate() * inputEstimates.getWindow() * rowSize;", "originalCommit": "0d1f235d3d4fb647027ad5ec625973802a15c7d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM1MzM3MA==", "url": "https://github.com/apache/beam/pull/10946#discussion_r422353370", "bodyText": "I believe it is carried over from a class in BeamSQL. Such computation was a part of a intern project before about SQL cost based optimization.\nLet me do some research and see how it should work.", "author": "amaliujia", "createdAt": "2020-05-08T20:19:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2NDgxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcwMTAyMg==", "url": "https://github.com/apache/beam/pull/10946#discussion_r424701022", "bodyText": "Yeah the cpu computation is wrong (I copied it from SortRel).\nThe reasonable computation is cpu = inputEstimates.getRowCount() * rowSize * function_per_row_cost_factor;. Because we don't have a reasonable stats for function_per_row_cost_factor, the formula is simplified as row count times row size.", "author": "amaliujia", "createdAt": "2020-05-13T20:08:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2NDgxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2NTg4OA==", "url": "https://github.com/apache/beam/pull/10946#discussion_r421665888", "bodyText": "Please add a class comment.", "author": "tysonjh", "createdAt": "2020-05-07T17:18:15Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rule/BeamTableFunctionScanRule.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.sql.impl.rule;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import org.apache.beam.sdk.extensions.sql.impl.rel.BeamLogicalConvention;\n+import org.apache.beam.sdk.extensions.sql.impl.rel.BeamTableFunctionScanRel;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.plan.Convention;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.RelNode;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.convert.ConverterRule;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.core.TableFunctionScan;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.logical.LogicalTableFunctionScan;\n+\n+public class BeamTableFunctionScanRule extends ConverterRule {", "originalCommit": "0d1f235d3d4fb647027ad5ec625973802a15c7d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM0NjIyOA==", "url": "https://github.com/apache/beam/pull/10946#discussion_r422346228", "bodyText": "Done", "author": "amaliujia", "createdAt": "2020-05-08T20:03:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2NTg4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2NjQzOQ==", "url": "https://github.com/apache/beam/pull/10946#discussion_r421666439", "bodyText": "Should this be a checkArgument?", "author": "tysonjh", "createdAt": "2020-05-07T17:19:09Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rule/BeamTableFunctionScanRule.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.sql.impl.rule;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import org.apache.beam.sdk.extensions.sql.impl.rel.BeamLogicalConvention;\n+import org.apache.beam.sdk.extensions.sql.impl.rel.BeamTableFunctionScanRel;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.plan.Convention;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.RelNode;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.convert.ConverterRule;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.core.TableFunctionScan;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.logical.LogicalTableFunctionScan;\n+\n+public class BeamTableFunctionScanRule extends ConverterRule {\n+  public static final BeamTableFunctionScanRule INSTANCE = new BeamTableFunctionScanRule();\n+\n+  private BeamTableFunctionScanRule() {\n+    super(\n+        LogicalTableFunctionScan.class,\n+        Convention.NONE,\n+        BeamLogicalConvention.INSTANCE,\n+        \"BeamTableFunctionScanRule\");\n+  }\n+\n+  @Override\n+  public RelNode convert(RelNode relNode) {\n+    TableFunctionScan tableFunctionScan = (TableFunctionScan) relNode;\n+    // only support one input for table function scan.", "originalCommit": "0d1f235d3d4fb647027ad5ec625973802a15c7d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM0NzA3MQ==", "url": "https://github.com/apache/beam/pull/10946#discussion_r422347071", "bodyText": "Nice catch. This is a ConverterRule whose canConvert returns always true. I mis-remembered it is RelOptRule in which the input size check should be in canConvert (and in fact there is no canConvert override).\nAdded the checkArgument.", "author": "amaliujia", "createdAt": "2020-05-08T20:05:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2NjQzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY3MDIwMA==", "url": "https://github.com/apache/beam/pull/10946#discussion_r421670200", "bodyText": "Please add class comment.", "author": "tysonjh", "createdAt": "2020-05-07T17:25:37Z", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/SqlWindowTableFunction.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.sql.zetasql;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelDataType;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelDataTypeField;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelDataTypeFieldImpl;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelRecordType;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.sql.SqlFunction;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.sql.SqlFunctionCategory;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.sql.SqlKind;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.sql.SqlNode;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.sql.type.SqlReturnTypeInference;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.sql.validate.SqlValidator;\n+\n+public class SqlWindowTableFunction extends SqlFunction {", "originalCommit": "0d1f235d3d4fb647027ad5ec625973802a15c7d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM0NzEzNg==", "url": "https://github.com/apache/beam/pull/10946#discussion_r422347136", "bodyText": "Done", "author": "amaliujia", "createdAt": "2020-05-08T20:05:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY3MDIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY3MjUzNA==", "url": "https://github.com/apache/beam/pull/10946#discussion_r421672534", "bodyText": "For my own understanding, where are they checked?", "author": "tysonjh", "createdAt": "2020-05-07T17:29:17Z", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/SqlWindowTableFunction.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.sql.zetasql;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelDataType;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelDataTypeField;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelDataTypeFieldImpl;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelRecordType;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.sql.SqlFunction;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.sql.SqlFunctionCategory;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.sql.SqlKind;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.sql.SqlNode;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.sql.type.SqlReturnTypeInference;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.sql.validate.SqlValidator;\n+\n+public class SqlWindowTableFunction extends SqlFunction {\n+  public SqlWindowTableFunction(String name) {\n+    super(\n+        name,\n+        SqlKind.OTHER_FUNCTION,\n+        ARG0_TABLE_FUNCTION_WINDOWING,\n+        null,\n+        null,\n+        SqlFunctionCategory.SYSTEM);\n+  }\n+\n+  @Override\n+  public SqlOperandCountRange getOperandCountRange() {\n+    return SqlOperandCountRanges.of(3);\n+  }\n+\n+  @Override\n+  public boolean checkOperandTypes(SqlCallBinding callBinding, boolean throwOnFailure) {\n+    // There should only be three operands, and number of operands are checked before\n+    // this call.", "originalCommit": "0d1f235d3d4fb647027ad5ec625973802a15c7d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM0NzU0Mw==", "url": "https://github.com/apache/beam/pull/10946#discussion_r422347543", "bodyText": "There is a method in this class:\n  @Override\n  public SqlOperandCountRange getOperandCountRange() {\n    return SqlOperandCountRanges.of(3);\n  }\n\nCalcite will call this method to validate the size of arguments.", "author": "amaliujia", "createdAt": "2020-05-08T20:06:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY3MjUzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY3NTczMw==", "url": "https://github.com/apache/beam/pull/10946#discussion_r421675733", "bodyText": "Please add a method comment since it is public and not 'simple' like a getter or setter.", "author": "tysonjh", "createdAt": "2020-05-07T17:34:39Z", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java", "diffHunk": "@@ -551,6 +561,60 @@ public RexNode convertResolvedLiteral(ResolvedLiteral resolvedLiteral) {\n     return ret;\n   }\n \n+  public RexCall convertTableValuedFunction(", "originalCommit": "0d1f235d3d4fb647027ad5ec625973802a15c7d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM0NzYxOA==", "url": "https://github.com/apache/beam/pull/10946#discussion_r422347618", "bodyText": "Done.", "author": "amaliujia", "createdAt": "2020-05-08T20:06:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY3NTczMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY3ODA3OA==", "url": "https://github.com/apache/beam/pull/10946#discussion_r421678078", "bodyText": "Can you do wmCol.getName() or is this different?", "author": "tysonjh", "createdAt": "2020-05-07T17:38:38Z", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java", "diffHunk": "@@ -551,6 +561,60 @@ public RexNode convertResolvedLiteral(ResolvedLiteral resolvedLiteral) {\n     return ret;\n   }\n \n+  public RexCall convertTableValuedFunction(\n+      RelNode input,\n+      TableValuedFunction tvf,\n+      List<ResolvedNodes.ResolvedTVFArgument> argumentList,\n+      List<ResolvedColumn> inputTableColumns) {\n+    switch (tvf.getName()) {\n+      case \"TUMBLE\":\n+        // TUMBLE tvf's second argument is descriptor.\n+        ResolvedColumn wmCol =\n+            extractWatermarkColumnFromDescriptor(argumentList.get(1).getDescriptorArg());\n+        if (wmCol.getType().getKind() != TYPE_TIMESTAMP) {\n+          throw new IllegalArgumentException(\n+              \"Watermarked column should be TIMESTAMP type: \"\n+                  + extractWatermarkColumnNameFromDescriptor(", "originalCommit": "0d1f235d3d4fb647027ad5ec625973802a15c7d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM1MDYxNA==", "url": "https://github.com/apache/beam/pull/10946#discussion_r422350614", "bodyText": "I implemented descriptor in ZetaSQL. Per my implementation, a descriptor argument contains two class members:\na. ImmutableList<ResolvedColumn>\nb. ImmutableList<String>\nThe ImmutableList<String> contains exact column names where ImmutableList<ResolvedColumn> contains a list of ColumnRef that connects these exact columns names with columns from input table.\nI am not 100% sure whether names in those ColumnRef always match exact names. So use extractWatermarkColumnNameFromDescriptor method to have a 100% guarantee on getting columns names that users typed into their queries.", "author": "amaliujia", "createdAt": "2020-05-08T20:13:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY3ODA3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY3OTM2OQ==", "url": "https://github.com/apache/beam/pull/10946#discussion_r421679369", "bodyText": "Would this be more descriptive as an IllegalStateException? Either way having a message would be useful here.", "author": "tysonjh", "createdAt": "2020-05-07T17:40:49Z", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java", "diffHunk": "@@ -551,6 +561,60 @@ public RexNode convertResolvedLiteral(ResolvedLiteral resolvedLiteral) {\n     return ret;\n   }\n \n+  public RexCall convertTableValuedFunction(\n+      RelNode input,\n+      TableValuedFunction tvf,\n+      List<ResolvedNodes.ResolvedTVFArgument> argumentList,\n+      List<ResolvedColumn> inputTableColumns) {\n+    switch (tvf.getName()) {\n+      case \"TUMBLE\":\n+        // TUMBLE tvf's second argument is descriptor.\n+        ResolvedColumn wmCol =\n+            extractWatermarkColumnFromDescriptor(argumentList.get(1).getDescriptorArg());\n+        if (wmCol.getType().getKind() != TYPE_TIMESTAMP) {\n+          throw new IllegalArgumentException(\n+              \"Watermarked column should be TIMESTAMP type: \"\n+                  + extractWatermarkColumnNameFromDescriptor(\n+                      argumentList.get(1).getDescriptorArg()));\n+        }\n+        return (RexCall)\n+            rexBuilder()\n+                .makeCall(\n+                    new SqlWindowTableFunction(SqlKind.TUMBLE.name()),\n+                    convertRelNodeToRexRangeRef(input),\n+                    convertWatermarkedResolvedColumnToRexInputRef(wmCol, inputTableColumns),\n+                    convertIntervalToRexIntervalLiteral(\n+                        (ResolvedLiteral) argumentList.get(2).getExpr()));\n+      default:\n+        throw new UnsupportedOperationException(\n+            \"Does not support table-valued function: \" + tvf.getName());\n+    }\n+  }\n+\n+  private RexInputRef convertWatermarkedResolvedColumnToRexInputRef(\n+      ResolvedColumn wmCol, List<ResolvedColumn> inputTableColumns) {\n+    for (int i = 0; i < inputTableColumns.size(); i++) {\n+      if (inputTableColumns.get(i).equals(wmCol)) {\n+        return rexBuilder()\n+            .makeInputRef(TypeUtils.toRelDataType(rexBuilder(), wmCol.getType(), false), i);\n+      }\n+    }\n+\n+    // ZetaSQL parser guarantees that wmCol can be found from inputTableColumns.\n+    // so it shouldn't reach here.\n+    throw new IllegalArgumentException();", "originalCommit": "0d1f235d3d4fb647027ad5ec625973802a15c7d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM1MTc5Mg==", "url": "https://github.com/apache/beam/pull/10946#discussion_r422351792", "bodyText": "I moved comments at line 603 to being exception message. I don't have a concert description for in which normal case it will reach this step. It could reach this step when ZetaSQL has bugs, but putting something like \"ZetaSQL has bugs to make you reach this exception\" sounds not useful neither.", "author": "amaliujia", "createdAt": "2020-05-08T20:15:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY3OTM2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY3OTkxMA==", "url": "https://github.com/apache/beam/pull/10946#discussion_r421679910", "bodyText": "Please add a class comment. They're really useful and should be on all classes and non-trivial public methods.", "author": "tysonjh", "createdAt": "2020-05-07T17:41:40Z", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/TVFScanConverter.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.sql.zetasql.translation;\n+\n+import com.google.zetasql.resolvedast.ResolvedNode;\n+import com.google.zetasql.resolvedast.ResolvedNodes.ResolvedTVFArgument;\n+import com.google.zetasql.resolvedast.ResolvedNodes.ResolvedTVFScan;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.RelNode;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.logical.LogicalTableFunctionScan;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelDataType;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelDataTypeField;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelDataTypeFieldImpl;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelRecordType;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.sql.type.SqlTypeName;\n+\n+class TVFScanConverter extends RelConverter<ResolvedTVFScan> {", "originalCommit": "0d1f235d3d4fb647027ad5ec625973802a15c7d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM1MjEyNw==", "url": "https://github.com/apache/beam/pull/10946#discussion_r422352127", "bodyText": "Done.", "author": "amaliujia", "createdAt": "2020-05-08T20:16:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY3OTkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY4MTIwNA==", "url": "https://github.com/apache/beam/pull/10946#discussion_r421681204", "bodyText": "I've seen window_start and window_end come up a few times in this PR. Is there a reasonable place to have these as constants and would it make sense to do this?", "author": "tysonjh", "createdAt": "2020-05-07T17:43:56Z", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/TVFScanConverter.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.sql.zetasql.translation;\n+\n+import com.google.zetasql.resolvedast.ResolvedNode;\n+import com.google.zetasql.resolvedast.ResolvedNodes.ResolvedTVFArgument;\n+import com.google.zetasql.resolvedast.ResolvedNodes.ResolvedTVFScan;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.RelNode;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.logical.LogicalTableFunctionScan;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelDataType;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelDataTypeField;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelDataTypeFieldImpl;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelRecordType;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.sql.type.SqlTypeName;\n+\n+class TVFScanConverter extends RelConverter<ResolvedTVFScan> {\n+\n+  TVFScanConverter(ConversionContext context) {\n+    super(context);\n+  }\n+\n+  @Override\n+  public RelNode convert(ResolvedTVFScan zetaNode, List<RelNode> inputs) {\n+    RelNode input = inputs.get(0);\n+    RelNode tableFunctionScan =\n+        LogicalTableFunctionScan.create(\n+            getCluster(),\n+            inputs,\n+            getExpressionConverter()\n+                .convertTableValuedFunction(\n+                    input,\n+                    zetaNode.getTvf(),\n+                    zetaNode.getArgumentList(),\n+                    zetaNode.getArgumentList().get(0).getScan().getColumnList()),\n+            null,\n+            createRowTypeWithWindowStartAndEnd(input.getRowType()),\n+            Collections.EMPTY_SET);\n+\n+    return tableFunctionScan;\n+  }\n+\n+  @Override\n+  public List<ResolvedNode> getInputs(ResolvedTVFScan zetaNode) {\n+    List<ResolvedNode> inputs = new ArrayList();\n+    for (ResolvedTVFArgument argument : zetaNode.getArgumentList()) {\n+      if (argument.getScan() != null) {\n+        inputs.add(argument.getScan());\n+      }\n+    }\n+    return inputs;\n+  }\n+\n+  private RelDataType createRowTypeWithWindowStartAndEnd(RelDataType inputRowType) {\n+    List<RelDataTypeField> newFields = new ArrayList<>(inputRowType.getFieldList());\n+    RelDataType timestampType = getCluster().getTypeFactory().createSqlType(SqlTypeName.TIMESTAMP);\n+\n+    RelDataTypeField windowStartField =\n+        new RelDataTypeFieldImpl(\"window_start\", newFields.size(), timestampType);", "originalCommit": "0d1f235d3d4fb647027ad5ec625973802a15c7d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM1MjQyNA==", "url": "https://github.com/apache/beam/pull/10946#discussion_r422352424", "bodyText": "Good idea. I added a util class named TVFStreamingUtils to encapsulate common constants and util functions for TVF streaming.", "author": "amaliujia", "createdAt": "2020-05-08T20:17:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY4MTIwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk0OTgxOA==", "url": "https://github.com/apache/beam/pull/10946#discussion_r426949818", "bodyText": "Use the constant?", "author": "apilloud", "createdAt": "2020-05-18T23:40:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY4MTIwNA=="}], "type": "inlineReview"}, {"oid": "f15f14ce180ba8da11de613f54d432c91ec276f2", "url": "https://github.com/apache/beam/commit/f15f14ce180ba8da11de613f54d432c91ec276f2", "message": "fixup! address comments", "committedDate": "2020-05-08T20:01:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI3OTg2OQ==", "url": "https://github.com/apache/beam/pull/10946#discussion_r423279869", "bodyText": "This still appears to actually be a \"FixedWindowsTableFunctionRel\".", "author": "kennknowles", "createdAt": "2020-05-11T19:50:52Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamTableFunctionScanRel.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.sql.impl.rel;\n+\n+import static org.apache.beam.vendor.calcite.v1_20_0.com.google.common.base.Preconditions.checkArgument;\n+\n+import java.lang.reflect.Type;\n+import java.util.List;\n+import java.util.Set;\n+import org.apache.beam.sdk.extensions.sql.impl.planner.BeamCostModel;\n+import org.apache.beam.sdk.extensions.sql.impl.planner.NodeStats;\n+import org.apache.beam.sdk.extensions.sql.impl.utils.CalciteUtils;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.windowing.FixedWindows;\n+import org.apache.beam.sdk.transforms.windowing.IntervalWindow;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.Row;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.plan.RelOptCluster;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.plan.RelTraitSet;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.RelNode;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.core.TableFunctionScan;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.metadata.RelColumnMapping;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelDataType;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexCall;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexInputRef;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexLiteral;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexNode;\n+import org.joda.time.Duration;\n+\n+/**\n+ * BeamRelNode to replace {@code TableFunctionScan}. Currently this class limits to support\n+ * table-valued function for streaming windowing.\n+ */\n+public class BeamTableFunctionScanRel extends TableFunctionScan implements BeamRelNode {\n+  public BeamTableFunctionScanRel(\n+      RelOptCluster cluster,\n+      RelTraitSet traitSet,\n+      List<RelNode> inputs,\n+      RexNode rexCall,\n+      Type elementType,\n+      RelDataType rowType,\n+      Set<RelColumnMapping> columnMappings) {\n+    super(cluster, traitSet, inputs, rexCall, elementType, rowType, columnMappings);\n+  }\n+\n+  @Override\n+  public TableFunctionScan copy(\n+      RelTraitSet traitSet,\n+      List<RelNode> list,\n+      RexNode rexNode,\n+      Type type,\n+      RelDataType relDataType,\n+      Set<RelColumnMapping> set) {\n+    return new BeamTableFunctionScanRel(\n+        getCluster(), traitSet, list, rexNode, type, relDataType, columnMappings);\n+  }\n+\n+  @Override\n+  public PTransform<PCollectionList<Row>, PCollection<Row>> buildPTransform() {\n+    return new Transform();\n+  }\n+\n+  private class Transform extends PTransform<PCollectionList<Row>, PCollection<Row>> {\n+\n+    @Override\n+    public PCollection<Row> expand(PCollectionList<Row> input) {\n+      checkArgument(\n+          input.size() == 1,\n+          \"Wrong number of inputs for %s, expected 1 input but received: %s\",\n+          BeamTableFunctionScanRel.class.getSimpleName(),\n+          input);\n+      String operatorName = ((RexCall) getCall()).getOperator().getName();\n+      checkArgument(\n+          operatorName.equals(\"TUMBLE\"),\n+          \"Only support TUMBLE table-valued function. Current operator: %s\",\n+          operatorName);\n+      RexCall call = ((RexCall) getCall());\n+      RexInputRef wmCol = (RexInputRef) call.getOperands().get(1);\n+      PCollection<Row> upstream = input.get(0);\n+      Schema outputSchema = CalciteUtils.toSchema(getRowType());\n+      return upstream\n+          .apply(\n+              ParDo.of(\n+                  new FixedWindowDoFn(", "originalCommit": "f15f14ce180ba8da11de613f54d432c91ec276f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMwMDU3Nw==", "url": "https://github.com/apache/beam/pull/10946#discussion_r423300577", "bodyText": "Interesting point. Let me check if there are benefits to split TUMBLE/HOP/SESSION at Rel level, especially what is the impact on JOIN.", "author": "amaliujia", "createdAt": "2020-05-11T20:30:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI3OTg2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3OTMyMw==", "url": "https://github.com/apache/beam/pull/10946#discussion_r424679323", "bodyText": "Ok, I have thought about this. Can we keep what this code is since it will still fast evolving?\nThere are a few dimensions to consider:\n\nif TUMBLE, SESSION, HOP have their own Rels\nHow many Rels needed for JOIN with windowing\n\nI believe we will have better answer after we see HOP and SESSION implementation.", "author": "amaliujia", "createdAt": "2020-05-13T19:27:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI3OTg2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA3MzYyOA==", "url": "https://github.com/apache/beam/pull/10946#discussion_r426073628", "bodyText": "My point is really that committing the code like this makes code with names that don't make sense. If you get interrupted to do something else after this PR, then the codebase will be in an incorrect state.", "author": "kennknowles", "createdAt": "2020-05-15T22:29:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI3OTg2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2OTM2Mg==", "url": "https://github.com/apache/beam/pull/10946#discussion_r426969362", "bodyText": "I guess I got what you meant: you think it should be a PTransform, not a DoFn for this FixedWindow assignment? (I was confused on why this transforming should be a Rel)\nIf so, either PTransform or a DoFn seems work to me.", "author": "amaliujia", "createdAt": "2020-05-19T00:53:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI3OTg2OQ=="}], "type": "inlineReview"}, {"oid": "2d98f20b1c0c248f5d6b1f1a72b61f50054e16c8", "url": "https://github.com/apache/beam/commit/2d98f20b1c0c248f5d6b1f1a72b61f50054e16c8", "message": "fixup! update Rel cost computation.", "committedDate": "2020-05-13T20:04:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk0NjUyMg==", "url": "https://github.com/apache/beam/pull/10946#discussion_r426946522", "bodyText": "Shouldn't columnMappings here be set? This is discarding the value provided as an argument to copy.", "author": "apilloud", "createdAt": "2020-05-18T23:29:34Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamTableFunctionScanRel.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.sql.impl.rel;\n+\n+import static org.apache.beam.vendor.calcite.v1_20_0.com.google.common.base.Preconditions.checkArgument;\n+\n+import java.lang.reflect.Type;\n+import java.util.List;\n+import java.util.Set;\n+import org.apache.beam.sdk.extensions.sql.impl.planner.BeamCostModel;\n+import org.apache.beam.sdk.extensions.sql.impl.planner.NodeStats;\n+import org.apache.beam.sdk.extensions.sql.impl.utils.CalciteUtils;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.windowing.FixedWindows;\n+import org.apache.beam.sdk.transforms.windowing.IntervalWindow;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.Row;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.plan.RelOptCluster;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.plan.RelTraitSet;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.RelNode;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.core.TableFunctionScan;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.metadata.RelColumnMapping;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelDataType;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexCall;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexInputRef;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexLiteral;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexNode;\n+import org.joda.time.Duration;\n+\n+/**\n+ * BeamRelNode to replace {@code TableFunctionScan}. Currently this class limits to support\n+ * table-valued function for streaming windowing.\n+ */\n+public class BeamTableFunctionScanRel extends TableFunctionScan implements BeamRelNode {\n+  public BeamTableFunctionScanRel(\n+      RelOptCluster cluster,\n+      RelTraitSet traitSet,\n+      List<RelNode> inputs,\n+      RexNode rexCall,\n+      Type elementType,\n+      RelDataType rowType,\n+      Set<RelColumnMapping> columnMappings) {\n+    super(cluster, traitSet, inputs, rexCall, elementType, rowType, columnMappings);\n+  }\n+\n+  @Override\n+  public TableFunctionScan copy(\n+      RelTraitSet traitSet,\n+      List<RelNode> list,\n+      RexNode rexNode,\n+      Type type,\n+      RelDataType relDataType,\n+      Set<RelColumnMapping> set) {\n+    return new BeamTableFunctionScanRel(\n+        getCluster(), traitSet, list, rexNode, type, relDataType, columnMappings);", "originalCommit": "2d98f20b1c0c248f5d6b1f1a72b61f50054e16c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2Njc0OQ==", "url": "https://github.com/apache/beam/pull/10946#discussion_r426966749", "bodyText": "Good catch! Replaced with the right parameter.", "author": "amaliujia", "createdAt": "2020-05-19T00:43:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk0NjUyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk0ODQ4Ng==", "url": "https://github.com/apache/beam/pull/10946#discussion_r426948486", "bodyText": "all three of these should be final.", "author": "apilloud", "createdAt": "2020-05-18T23:36:20Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamTableFunctionScanRel.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.sql.impl.rel;\n+\n+import static org.apache.beam.vendor.calcite.v1_20_0.com.google.common.base.Preconditions.checkArgument;\n+\n+import java.lang.reflect.Type;\n+import java.util.List;\n+import java.util.Set;\n+import org.apache.beam.sdk.extensions.sql.impl.planner.BeamCostModel;\n+import org.apache.beam.sdk.extensions.sql.impl.planner.NodeStats;\n+import org.apache.beam.sdk.extensions.sql.impl.utils.CalciteUtils;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.windowing.FixedWindows;\n+import org.apache.beam.sdk.transforms.windowing.IntervalWindow;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionList;\n+import org.apache.beam.sdk.values.Row;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.plan.RelOptCluster;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.plan.RelTraitSet;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.RelNode;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.core.TableFunctionScan;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.metadata.RelColumnMapping;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelDataType;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexCall;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexInputRef;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexLiteral;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rex.RexNode;\n+import org.joda.time.Duration;\n+\n+/**\n+ * BeamRelNode to replace {@code TableFunctionScan}. Currently this class limits to support\n+ * table-valued function for streaming windowing.\n+ */\n+public class BeamTableFunctionScanRel extends TableFunctionScan implements BeamRelNode {\n+  public BeamTableFunctionScanRel(\n+      RelOptCluster cluster,\n+      RelTraitSet traitSet,\n+      List<RelNode> inputs,\n+      RexNode rexCall,\n+      Type elementType,\n+      RelDataType rowType,\n+      Set<RelColumnMapping> columnMappings) {\n+    super(cluster, traitSet, inputs, rexCall, elementType, rowType, columnMappings);\n+  }\n+\n+  @Override\n+  public TableFunctionScan copy(\n+      RelTraitSet traitSet,\n+      List<RelNode> list,\n+      RexNode rexNode,\n+      Type type,\n+      RelDataType relDataType,\n+      Set<RelColumnMapping> set) {\n+    return new BeamTableFunctionScanRel(\n+        getCluster(), traitSet, list, rexNode, type, relDataType, columnMappings);\n+  }\n+\n+  @Override\n+  public PTransform<PCollectionList<Row>, PCollection<Row>> buildPTransform() {\n+    return new Transform();\n+  }\n+\n+  private class Transform extends PTransform<PCollectionList<Row>, PCollection<Row>> {\n+\n+    @Override\n+    public PCollection<Row> expand(PCollectionList<Row> input) {\n+      checkArgument(\n+          input.size() == 1,\n+          \"Wrong number of inputs for %s, expected 1 input but received: %s\",\n+          BeamTableFunctionScanRel.class.getSimpleName(),\n+          input);\n+      String operatorName = ((RexCall) getCall()).getOperator().getName();\n+      checkArgument(\n+          operatorName.equals(\"TUMBLE\"),\n+          \"Only support TUMBLE table-valued function. Current operator: %s\",\n+          operatorName);\n+      RexCall call = ((RexCall) getCall());\n+      RexInputRef wmCol = (RexInputRef) call.getOperands().get(1);\n+      PCollection<Row> upstream = input.get(0);\n+      Schema outputSchema = CalciteUtils.toSchema(getRowType());\n+      return upstream\n+          .apply(\n+              ParDo.of(\n+                  new FixedWindowDoFn(\n+                      FixedWindows.of(durationParameter(call.getOperands().get(2))),\n+                      wmCol.getIndex(),\n+                      outputSchema)))\n+          .setRowSchema(outputSchema);\n+    }\n+  }\n+\n+  private Duration durationParameter(RexNode node) {\n+    return Duration.millis(longValue(node));\n+  }\n+\n+  private long longValue(RexNode operand) {\n+    if (operand instanceof RexLiteral) {\n+      return ((Number) RexLiteral.value(operand)).longValue();\n+    } else {\n+      throw new IllegalArgumentException(String.format(\"[%s] is not valid.\", operand));\n+    }\n+  }\n+\n+  private static class FixedWindowDoFn extends DoFn<Row, Row> {\n+    private int windowFieldIndex;", "originalCommit": "2d98f20b1c0c248f5d6b1f1a72b61f50054e16c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk0OTY3Mg==", "url": "https://github.com/apache/beam/pull/10946#discussion_r426949672", "bodyText": "Nit: This seems like stuff that should go in SqlWindowTableFunction. Do these constants really need their own class?", "author": "apilloud", "createdAt": "2020-05-18T23:40:21Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/utils/TVFStreamingUtils.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.sql.impl.utils;\n+\n+/** Provides static constants or utils for TVF streaming. */\n+public class TVFStreamingUtils {", "originalCommit": "2d98f20b1c0c248f5d6b1f1a72b61f50054e16c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2NzQxMA==", "url": "https://github.com/apache/beam/pull/10946#discussion_r426967410", "bodyText": "SqlWindowTableFunction is a class in Calcite (since 1.22.0). After we successfully upgrade to newer version of Calcite (I hope), we can remove SqlWindowTableFunction, thus there is a need to keep a TVFStreamingUtils.\nThere could be an argument though that such constants can be put into  SqlWindowTableFunction in Calcite. We can leave such discussion in the future.", "author": "amaliujia", "createdAt": "2020-05-19T00:46:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk0OTY3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk3NDM2NQ==", "url": "https://github.com/apache/beam/pull/10946#discussion_r426974365", "bodyText": "In that case, drop the constants all together. You can't reference a class in Beam from Calcite, and these constants are used in that class.", "author": "apilloud", "createdAt": "2020-05-19T01:12:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk0OTY3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk0OTg2Nw==", "url": "https://github.com/apache/beam/pull/10946#discussion_r426949867", "bodyText": "Use the constant?", "author": "apilloud", "createdAt": "2020-05-18T23:41:01Z", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/TVFScanConverter.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.sql.zetasql.translation;\n+\n+import com.google.zetasql.resolvedast.ResolvedNode;\n+import com.google.zetasql.resolvedast.ResolvedNodes.ResolvedTVFArgument;\n+import com.google.zetasql.resolvedast.ResolvedNodes.ResolvedTVFScan;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.RelNode;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.logical.LogicalTableFunctionScan;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelDataType;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelDataTypeField;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelDataTypeFieldImpl;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.rel.type.RelRecordType;\n+import org.apache.beam.vendor.calcite.v1_20_0.org.apache.calcite.sql.type.SqlTypeName;\n+\n+/** Converts TVFScan. */\n+class TVFScanConverter extends RelConverter<ResolvedTVFScan> {\n+\n+  TVFScanConverter(ConversionContext context) {\n+    super(context);\n+  }\n+\n+  @Override\n+  public RelNode convert(ResolvedTVFScan zetaNode, List<RelNode> inputs) {\n+    RelNode input = inputs.get(0);\n+    RelNode tableFunctionScan =\n+        LogicalTableFunctionScan.create(\n+            getCluster(),\n+            inputs,\n+            getExpressionConverter()\n+                .convertTableValuedFunction(\n+                    input,\n+                    zetaNode.getTvf(),\n+                    zetaNode.getArgumentList(),\n+                    zetaNode.getArgumentList().get(0).getScan().getColumnList()),\n+            null,\n+            createRowTypeWithWindowStartAndEnd(input.getRowType()),\n+            Collections.EMPTY_SET);\n+\n+    return tableFunctionScan;\n+  }\n+\n+  @Override\n+  public List<ResolvedNode> getInputs(ResolvedTVFScan zetaNode) {\n+    List<ResolvedNode> inputs = new ArrayList();\n+    for (ResolvedTVFArgument argument : zetaNode.getArgumentList()) {\n+      if (argument.getScan() != null) {\n+        inputs.add(argument.getScan());\n+      }\n+    }\n+    return inputs;\n+  }\n+\n+  private RelDataType createRowTypeWithWindowStartAndEnd(RelDataType inputRowType) {\n+    List<RelDataTypeField> newFields = new ArrayList<>(inputRowType.getFieldList());\n+    RelDataType timestampType = getCluster().getTypeFactory().createSqlType(SqlTypeName.TIMESTAMP);\n+\n+    RelDataTypeField windowStartField =\n+        new RelDataTypeFieldImpl(\"window_start\", newFields.size(), timestampType);\n+    newFields.add(windowStartField);\n+    RelDataTypeField windowEndField =\n+        new RelDataTypeFieldImpl(\"window_end\", newFields.size(), timestampType);", "originalCommit": "2d98f20b1c0c248f5d6b1f1a72b61f50054e16c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk1MDYxMQ==", "url": "https://github.com/apache/beam/pull/10946#discussion_r426950611", "bodyText": "I really hope you got a badge for that function name...", "author": "apilloud", "createdAt": "2020-05-18T23:43:44Z", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/SqlAnalyzer.java", "diffHunk": "@@ -175,6 +185,37 @@ private void addBuiltinFunctionsToCatalog(SimpleCatalog catalog, AnalyzerOptions\n                     Mode.SCALAR,\n                     ImmutableList.of(resolvedFunc.getSignature())))\n         .forEach(catalog::addFunction);\n+\n+    FunctionArgumentType retType =\n+        new FunctionArgumentType(SignatureArgumentKind.ARG_TYPE_RELATION);\n+\n+    FunctionArgumentType inputTableType =\n+        new FunctionArgumentType(SignatureArgumentKind.ARG_TYPE_RELATION);\n+\n+    FunctionArgumentType descriptorType =\n+        new FunctionArgumentType(\n+            SignatureArgumentKind.ARG_TYPE_DESCRIPTOR,\n+            FunctionArgumentTypeOptionsProto.newBuilder()\n+                .setDescriptorResolutionTableOffset(0)\n+                .build(),\n+            1);\n+\n+    FunctionArgumentType stringType =\n+        new FunctionArgumentType(TypeFactory.createSimpleType(TypeKind.TYPE_STRING));\n+\n+    // TUMBLE\n+    catalog.addTableValuedFunction(\n+        new TableValuedFunction.ForwardInputSchemaToOutputSchemaWithAppendedColumnTVF(", "originalCommit": "2d98f20b1c0c248f5d6b1f1a72b61f50054e16c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk2ODM5OA==", "url": "https://github.com/apache/beam/pull/10946#discussion_r426968398", "bodyText": "Yeah. And at least I am glad this name itself does not exceed 80 chars so it at least fits into a single line..", "author": "amaliujia", "createdAt": "2020-05-19T00:49:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk1MDYxMQ=="}], "type": "inlineReview"}, {"oid": "d030159dbd9159d5eb9fcc9efc838cb41222624b", "url": "https://github.com/apache/beam/commit/d030159dbd9159d5eb9fcc9efc838cb41222624b", "message": "fixup! address comments.", "committedDate": "2020-05-19T00:42:34Z", "type": "commit"}]}