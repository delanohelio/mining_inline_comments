{"pr_number": 10501, "pr_title": "[BEAM-5605] Add support for channel splitting to the gRPC read \"source\" and propagate \"split\" calls to the downstream receiver", "pr_createdAt": "2020-01-03T23:22:15Z", "pr_url": "https://github.com/apache/beam/pull/10501", "timeline": [{"oid": "d5415732ff067e85852c4f5433efd0003269f880", "url": "https://github.com/apache/beam/commit/d5415732ff067e85852c4f5433efd0003269f880", "message": "[BEAM-3684] Add support for channel splitting to the gRPC read \"source\" and propagate \"split\" calls to the downstream receiver\n\nThis code mirrors the logic/implementation within https://github.com/apache/beam/blob/16757ef9a6da4d0ac218c6c4d6b19e2a49ccca45/sdks/python/apache_beam/runners/worker/bundle_processor.py#L206\n\nTo be able to propagate the split call to the downstream receiver, I collapsed all the harness FnDataReceiver types into two existing implementations and one new implementations.\nThe previous hierarchy was:\nelement counting receiver -> time counting receiver -> multiplexing receiver (possibly the original receiver)\n\nThe current implementation combined the element counting, time counting and multiplexing into the MultiplexingMetricTrackingFnDataReceiver while for the singleton case into the MetricTrackingFnDataReceiver.\nTo propagate splits, a SplittingMetricTrackingFnDataReceiver was created that extends the MetricTrackingFnDataReceiver. Note, like in Python, there is currently no support for splitting as in https://github.com/apache/beam/blob/c167d8ef99b21148bcab7c37538a6ef2f64864c7/sdks/python/apache_beam/runners/worker/operations.py#L133", "committedDate": "2020-01-03T23:16:55Z", "type": "commit"}, {"oid": "8b992dbdb087e354eb93201b109b82aaae98a7bc", "url": "https://github.com/apache/beam/commit/8b992dbdb087e354eb93201b109b82aaae98a7bc", "message": "[BEAM-9059] Migrate PTransformTranslation to use string constants", "committedDate": "2020-01-07T00:12:57Z", "type": "forcePushed"}, {"oid": "d0eb6dd0cf8305c9b5c0bd53a31783337d9ed939", "url": "https://github.com/apache/beam/commit/d0eb6dd0cf8305c9b5c0bd53a31783337d9ed939", "message": "[BEAM-9059] Migrate PTransformTranslation to use string constants", "committedDate": "2020-01-07T00:17:40Z", "type": "forcePushed"}, {"oid": "d5415732ff067e85852c4f5433efd0003269f880", "url": "https://github.com/apache/beam/commit/d5415732ff067e85852c4f5433efd0003269f880", "message": "[BEAM-3684] Add support for channel splitting to the gRPC read \"source\" and propagate \"split\" calls to the downstream receiver\n\nThis code mirrors the logic/implementation within https://github.com/apache/beam/blob/16757ef9a6da4d0ac218c6c4d6b19e2a49ccca45/sdks/python/apache_beam/runners/worker/bundle_processor.py#L206\n\nTo be able to propagate the split call to the downstream receiver, I collapsed all the harness FnDataReceiver types into two existing implementations and one new implementations.\nThe previous hierarchy was:\nelement counting receiver -> time counting receiver -> multiplexing receiver (possibly the original receiver)\n\nThe current implementation combined the element counting, time counting and multiplexing into the MultiplexingMetricTrackingFnDataReceiver while for the singleton case into the MetricTrackingFnDataReceiver.\nTo propagate splits, a SplittingMetricTrackingFnDataReceiver was created that extends the MetricTrackingFnDataReceiver. Note, like in Python, there is currently no support for splitting as in https://github.com/apache/beam/blob/c167d8ef99b21148bcab7c37538a6ef2f64864c7/sdks/python/apache_beam/runners/worker/operations.py#L133", "committedDate": "2020-01-03T23:16:55Z", "type": "forcePushed"}, {"oid": "a4f0a05889450257ccabfe78a171bb0a4e3b3d19", "url": "https://github.com/apache/beam/commit/a4f0a05889450257ccabfe78a171bb0a4e3b3d19", "message": "fixup! Fix spot/find bugs issues", "committedDate": "2020-01-07T17:55:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3OTk2MQ==", "url": "https://github.com/apache/beam/pull/10501#discussion_r365479961", "bodyText": "0 based index of the current element being processed(?).", "author": "robertwb", "createdAt": "2020-01-11T00:26:21Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java", "diffHunk": "@@ -131,6 +137,11 @@\n   private final BeamFnDataClient beamFnDataClient;\n   private final Coder<WindowedValue<OutputT>> coder;\n \n+  private final Object splittingLock = new Object();\n+  // 0-based count of the number of elements", "originalCommit": "a4f0a05889450257ccabfe78a171bb0a4e3b3d19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4MDA2Mg==", "url": "https://github.com/apache/beam/pull/10501#discussion_r365480062", "bodyText": "0-based index of the first element to not process. (Or is this the last element to process?)", "author": "robertwb", "createdAt": "2020-01-11T00:26:55Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java", "diffHunk": "@@ -131,6 +137,11 @@\n   private final BeamFnDataClient beamFnDataClient;\n   private final Coder<WindowedValue<OutputT>> coder;\n \n+  private final Object splittingLock = new Object();\n+  // 0-based count of the number of elements\n+  private long index = -1;\n+  // 0-based count of the number of elements", "originalCommit": "a4f0a05889450257ccabfe78a171bb0a4e3b3d19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0MjUxMg==", "url": "https://github.com/apache/beam/pull/10501#discussion_r365942512", "bodyText": "first element to not process.", "author": "lukecwik", "createdAt": "2020-01-13T17:54:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4MDA2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4MzQwMw==", "url": "https://github.com/apache/beam/pull/10501#discussion_r365483403", "bodyText": "Should this be an else clause below?", "author": "robertwb", "createdAt": "2020-01-11T00:48:51Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java", "diffHunk": "@@ -170,7 +181,109 @@ public void registerInputLocation() {\n             apiServiceDescriptor,\n             LogicalEndpoint.of(processBundleInstructionIdSupplier.get(), pTransformId),\n             coder,\n-            consumer);\n+            this::forwardElementToConsumer);\n+  }\n+\n+  public void forwardElementToConsumer(WindowedValue<OutputT> element) throws Exception {\n+    synchronized (splittingLock) {\n+      if (index == stopIndex - 1) {\n+        return;\n+      }\n+      index += 1;\n+    }\n+    consumer.accept(element);\n+  }\n+\n+  public void split(\n+      ProcessBundleSplitRequest request, ProcessBundleSplitResponse.Builder response) {\n+    DesiredSplit desiredSplit = request.getDesiredSplitsMap().get(pTransformId);\n+    if (desiredSplit == null) {\n+      return;\n+    }\n+\n+    long totalBufferSize = desiredSplit.getEstimatedInputElements();\n+\n+    HandlesSplits splittingConsumer = null;\n+    if (consumer instanceof HandlesSplits) {\n+      splittingConsumer = ((HandlesSplits) consumer);\n+    }\n+\n+    synchronized (splittingLock) {\n+      // Since we hold the splittingLock, we guarantee that we will not pass the next element\n+      // to the downstream consumer. We still have a race where the downstream consumer may\n+      // have yet to see the element or has completed processing the element by the time\n+      // we ask it to split (even after we have asked for its progress).\n+\n+      // If the split request we received was delayed and is less then the known number of elements\n+      // then use \"index + 1\" as the total size. Similarly, if we have already split and the\n+      // split request is bounded incorrectly, use the stop index as the upper bound.\n+      if (totalBufferSize < index + 1) {\n+        totalBufferSize = index + 1;\n+      } else if (totalBufferSize > stopIndex) {\n+        totalBufferSize = stopIndex;\n+      }\n+\n+      // In the case where we have yet to process an element, set the current element progress to 1.", "originalCommit": "a4f0a05889450257ccabfe78a171bb0a4e3b3d19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzMjIzNQ==", "url": "https://github.com/apache/beam/pull/10501#discussion_r365932235", "bodyText": "Its logically the same where the else clause is the default based upon what we initialize.", "author": "lukecwik", "createdAt": "2020-01-13T17:32:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4MzQwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4ODM0Mw==", "url": "https://github.com/apache/beam/pull/10501#discussion_r365488343", "bodyText": "Compute the number of elements that we should \"keep.\"", "author": "robertwb", "createdAt": "2020-01-11T01:35:09Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java", "diffHunk": "@@ -170,7 +181,109 @@ public void registerInputLocation() {\n             apiServiceDescriptor,\n             LogicalEndpoint.of(processBundleInstructionIdSupplier.get(), pTransformId),\n             coder,\n-            consumer);\n+            this::forwardElementToConsumer);\n+  }\n+\n+  public void forwardElementToConsumer(WindowedValue<OutputT> element) throws Exception {\n+    synchronized (splittingLock) {\n+      if (index == stopIndex - 1) {\n+        return;\n+      }\n+      index += 1;\n+    }\n+    consumer.accept(element);\n+  }\n+\n+  public void split(\n+      ProcessBundleSplitRequest request, ProcessBundleSplitResponse.Builder response) {\n+    DesiredSplit desiredSplit = request.getDesiredSplitsMap().get(pTransformId);\n+    if (desiredSplit == null) {\n+      return;\n+    }\n+\n+    long totalBufferSize = desiredSplit.getEstimatedInputElements();\n+\n+    HandlesSplits splittingConsumer = null;\n+    if (consumer instanceof HandlesSplits) {\n+      splittingConsumer = ((HandlesSplits) consumer);\n+    }\n+\n+    synchronized (splittingLock) {\n+      // Since we hold the splittingLock, we guarantee that we will not pass the next element\n+      // to the downstream consumer. We still have a race where the downstream consumer may\n+      // have yet to see the element or has completed processing the element by the time\n+      // we ask it to split (even after we have asked for its progress).\n+\n+      // If the split request we received was delayed and is less then the known number of elements\n+      // then use \"index + 1\" as the total size. Similarly, if we have already split and the\n+      // split request is bounded incorrectly, use the stop index as the upper bound.\n+      if (totalBufferSize < index + 1) {\n+        totalBufferSize = index + 1;\n+      } else if (totalBufferSize > stopIndex) {\n+        totalBufferSize = stopIndex;\n+      }\n+\n+      // In the case where we have yet to process an element, set the current element progress to 1.\n+      double currentElementProgress = 1;\n+\n+      // If we have started processing at least one element, attempt to get the downstream\n+      // progress defaulting to 0.5 if no progress was able to get fetched.\n+      if (index >= 0) {\n+        if (splittingConsumer != null) {\n+          currentElementProgress = splittingConsumer.getProgress();\n+        } else {\n+          currentElementProgress = 0.5;\n+        }\n+      }\n+\n+      checkArgument(\n+          desiredSplit.getAllowedSplitPointsList().isEmpty(),\n+          \"TODO: BEAM-3836, support split point restrictions.\");\n+\n+      // Now figure out where to split.\n+      //\n+      // The units here (except for keepOfElementRemainder) are all in terms of number or\n+      // (possibly fractional) elements.\n+\n+      // Compute the amount of \"remaining\" work that we know of.\n+      double remainder = totalBufferSize - index - currentElementProgress;\n+      // Compute the fraction of work that we should \"keep\".", "originalCommit": "a4f0a05889450257ccabfe78a171bb0a4e3b3d19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0MzAwOQ==", "url": "https://github.com/apache/beam/pull/10501#discussion_r365943009", "bodyText": "Done", "author": "lukecwik", "createdAt": "2020-01-13T17:55:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4ODM0Mw=="}], "type": "inlineReview"}, {"oid": "2fa35c420915b4be43e3a4a56429ec247c74ed50", "url": "https://github.com/apache/beam/commit/2fa35c420915b4be43e3a4a56429ec247c74ed50", "message": "fixup! Address comments.", "committedDate": "2020-01-13T17:56:21Z", "type": "commit"}]}