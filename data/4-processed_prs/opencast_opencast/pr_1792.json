{"pr_number": 1792, "pr_title": "Standalone downloads Paella plugin", "pr_createdAt": "2020-08-20T19:39:36Z", "pr_url": "https://github.com/opencast/opencast/pull/1792", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1MTc1NA==", "url": "https://github.com/opencast/opencast/pull/1792#discussion_r478651754", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      var match_flavors = false;\n          \n          \n            \n                      for (var flavorsIndex = 0; flavorsIndex < self._flavors.length; flavorsIndex++) {\n          \n          \n            \n                        var flavor = self._flavors[flavorsIndex];\n          \n          \n            \n                        if (track.type === flavor) {\n          \n          \n            \n                          match_flavors = true;\n          \n          \n            \n                          break;\n          \n          \n            \n                        }\n          \n          \n            \n                      }\n          \n          \n            \n                      var match_flavors = self._flavors.find(flavor => flavor == track.type);", "author": "lkiesow", "createdAt": "2020-08-27T19:39:23Z", "path": "modules/engage-paella-player/src/main/paella-opencast/plugins/es.upv.paella.opencast.downloadsButtonPlugin/mh_downloads.js", "diffHunk": "@@ -0,0 +1,272 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+class DownloadTrack {\n+  constructor(oc_track) {\n+    if (oc_track.audio == undefined && oc_track.video == undefined) {\n+      throw 'No audio and video';\n+    }\n+    this.flavor = oc_track.type;\n+    this.mimetype = paella.dictionary.translate(oc_track.mimetype);\n+    this.url = oc_track.url;\n+    if (oc_track.audio) {\n+      this.type = 'audio';\n+      this.audio_bitrate = oc_track.audio.bitrate;\n+    }\n+    if (oc_track.video) {\n+      this.type = 'video';\n+      this.video_resolution = oc_track.video.resolution;\n+      //this.video_quality = oc_track.video.resolution.split('x', 2)[1] + 'p';\n+      this.video_framerate = oc_track.video.framerate;\n+    }\n+  }\n+}\n+\n+/*global Class*/\n+paella.addPlugin(function() {\n+  return class DownloadsButtonPlugin extends paella.ButtonPlugin {\n+\n+    constructor() {\n+      super();\n+      this._tags = [];\n+      this._flavors = [];\n+      this._tags_and_flavors = false;\n+      this._episode = undefined;\n+      this._tracks = [];\n+    }\n+\n+    getSubclass() { return 'downloadsButton'; }\n+    getName() { return 'es.upv.paella.opencast.downloadsButtonPlugin'; }\n+    getIndex() { return 1000; }\n+    getDefaultToolTip() { return paella.dictionary.translate('Downloads'); }\n+    getAlignment() { return 'right'; }\n+    getButtonType() { return paella.ButtonPlugin.type.popUpButton; }\n+    getIconClass() { return 'icon-folder-download'; }\n+\n+    setup() {\n+      var self = this;\n+      if (self.config) {\n+        self._tags = [];\n+        if (self.config.tags) {\n+          self._tags = self.config.tags;\n+        }\n+        self._flavors = [];\n+        if (self.config.flavors) {\n+          self._flavors = self.config.flavors;\n+        }\n+        self._tags_and_flavors = false;\n+        if (self.config.tags_and_flavors) {\n+          self._tags_and_flavors = self.config.tags_and_flavors;\n+        }\n+      }\n+    }\n+\n+    checkEnabled(onSuccess) {\n+      var self = this;\n+      if (paella.player.isLiveStream()) {\n+        onSuccess(false);\n+      } else {\n+        paella.opencast.getEpisode()\n+        .then(function(episode) {\n+          self._episode = episode;\n+          // we can't filter tracks by tags and flavors\n+          // because the setup function will be called after checkEnabled\n+          onSuccess(true);\n+        })\n+        .catch(function(error) {\n+          base.log.error('opencast downloads button plugin disabled: ' + error);\n+          onSuccess(false);\n+        });\n+      }\n+    }\n+\n+    buildContent(domElement) {\n+      var self = this;\n+      if (self._episode !== undefined) {\n+        self.loadTracksFromEpisode();\n+      }\n+      self.renderTracks(domElement);\n+    }\n+\n+    loadTracksFromEpisode() {\n+      var self = this;\n+      var tracks = self._episode.mediapackage.media.track;\n+      if (!(tracks instanceof Array)) { tracks = [tracks]; }\n+\n+      var parsedTracks = [];\n+      for (var tracksIndex = 0; tracksIndex < tracks.length; tracksIndex++) {\n+        var track = tracks[tracksIndex];\n+        // only show static file content over http\n+        // skip streaming tracks\n+        if (track.url.startsWith('http')\n+            && (track.mimetype.indexOf('video') >= 0) || track.mimetype.indexOf('audio') >= 0) {\n+\n+          // skip live events\n+          if (track.live != undefined) {\n+            if (track.live) { continue; }\n+          }\n+\n+          // skip and tags\n+          if (self._tags.length > 0 && (track.tags == undefined || track.tags.tag == undefined\n+                || track.tags.tag.length < 1)) {\n+            continue;\n+          }\n+\n+          var match_tags = false;\n+          for (var tagsIndex = 0; tagsIndex < self._tags.length; tagsIndex++) {\n+            var tag = self._tags[tagsIndex];\n+            if (track.tags.tag.indexOf(tag) >= 0) {\n+              match_tags = true;\n+              break;\n+            }\n+          }\n+          // skip by flavor\n+          var match_flavors = false;\n+          for (var flavorsIndex = 0; flavorsIndex < self._flavors.length; flavorsIndex++) {\n+            var flavor = self._flavors[flavorsIndex];\n+            if (track.type === flavor) {\n+              match_flavors = true;\n+              break;\n+            }\n+          }", "originalCommit": "aa0cc7f1ed38bd860ba50f839ea03868ae006eb8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ0MTM5Nw==", "url": "https://github.com/opencast/opencast/pull/1792#discussion_r497441397", "bodyText": "Hi @lkiesow, I agree your suggestion looks a way less ugly. But the find function isn't supported by IE (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find), isn't? Do we want to keep uggly looking code or ensure the IE compatibility?", "author": "wsmirnow", "createdAt": "2020-09-30T11:39:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1MTc1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ0OTgxOA==", "url": "https://github.com/opencast/opencast/pull/1792#discussion_r497449818", "bodyText": "I think we aren't compatible with IE for a while now. IE also isn't really supported anywhere any longer.", "author": "lkiesow", "createdAt": "2020-09-30T11:54:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1MTc1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1NDYzMw==", "url": "https://github.com/opencast/opencast/pull/1792#discussion_r478654633", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      var match_tags = false;\n          \n          \n            \n                      for (var tagsIndex = 0; tagsIndex < self._tags.length; tagsIndex++) {\n          \n          \n            \n                        var tag = self._tags[tagsIndex];\n          \n          \n            \n                        if (track.tags.tag.indexOf(tag) >= 0) {\n          \n          \n            \n                          match_tags = true;\n          \n          \n            \n                          break;\n          \n          \n            \n                        }\n          \n          \n            \n                      }\n          \n          \n            \n                      var match_tags = self._tags.find(tag => track.tags.tag.indexOf(tag) >= 0);", "author": "lkiesow", "createdAt": "2020-08-27T19:44:53Z", "path": "modules/engage-paella-player/src/main/paella-opencast/plugins/es.upv.paella.opencast.downloadsButtonPlugin/mh_downloads.js", "diffHunk": "@@ -0,0 +1,272 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+class DownloadTrack {\n+  constructor(oc_track) {\n+    if (oc_track.audio == undefined && oc_track.video == undefined) {\n+      throw 'No audio and video';\n+    }\n+    this.flavor = oc_track.type;\n+    this.mimetype = paella.dictionary.translate(oc_track.mimetype);\n+    this.url = oc_track.url;\n+    if (oc_track.audio) {\n+      this.type = 'audio';\n+      this.audio_bitrate = oc_track.audio.bitrate;\n+    }\n+    if (oc_track.video) {\n+      this.type = 'video';\n+      this.video_resolution = oc_track.video.resolution;\n+      //this.video_quality = oc_track.video.resolution.split('x', 2)[1] + 'p';\n+      this.video_framerate = oc_track.video.framerate;\n+    }\n+  }\n+}\n+\n+/*global Class*/\n+paella.addPlugin(function() {\n+  return class DownloadsButtonPlugin extends paella.ButtonPlugin {\n+\n+    constructor() {\n+      super();\n+      this._tags = [];\n+      this._flavors = [];\n+      this._tags_and_flavors = false;\n+      this._episode = undefined;\n+      this._tracks = [];\n+    }\n+\n+    getSubclass() { return 'downloadsButton'; }\n+    getName() { return 'es.upv.paella.opencast.downloadsButtonPlugin'; }\n+    getIndex() { return 1000; }\n+    getDefaultToolTip() { return paella.dictionary.translate('Downloads'); }\n+    getAlignment() { return 'right'; }\n+    getButtonType() { return paella.ButtonPlugin.type.popUpButton; }\n+    getIconClass() { return 'icon-folder-download'; }\n+\n+    setup() {\n+      var self = this;\n+      if (self.config) {\n+        self._tags = [];\n+        if (self.config.tags) {\n+          self._tags = self.config.tags;\n+        }\n+        self._flavors = [];\n+        if (self.config.flavors) {\n+          self._flavors = self.config.flavors;\n+        }\n+        self._tags_and_flavors = false;\n+        if (self.config.tags_and_flavors) {\n+          self._tags_and_flavors = self.config.tags_and_flavors;\n+        }\n+      }\n+    }\n+\n+    checkEnabled(onSuccess) {\n+      var self = this;\n+      if (paella.player.isLiveStream()) {\n+        onSuccess(false);\n+      } else {\n+        paella.opencast.getEpisode()\n+        .then(function(episode) {\n+          self._episode = episode;\n+          // we can't filter tracks by tags and flavors\n+          // because the setup function will be called after checkEnabled\n+          onSuccess(true);\n+        })\n+        .catch(function(error) {\n+          base.log.error('opencast downloads button plugin disabled: ' + error);\n+          onSuccess(false);\n+        });\n+      }\n+    }\n+\n+    buildContent(domElement) {\n+      var self = this;\n+      if (self._episode !== undefined) {\n+        self.loadTracksFromEpisode();\n+      }\n+      self.renderTracks(domElement);\n+    }\n+\n+    loadTracksFromEpisode() {\n+      var self = this;\n+      var tracks = self._episode.mediapackage.media.track;\n+      if (!(tracks instanceof Array)) { tracks = [tracks]; }\n+\n+      var parsedTracks = [];\n+      for (var tracksIndex = 0; tracksIndex < tracks.length; tracksIndex++) {\n+        var track = tracks[tracksIndex];\n+        // only show static file content over http\n+        // skip streaming tracks\n+        if (track.url.startsWith('http')\n+            && (track.mimetype.indexOf('video') >= 0) || track.mimetype.indexOf('audio') >= 0) {\n+\n+          // skip live events\n+          if (track.live != undefined) {\n+            if (track.live) { continue; }\n+          }\n+\n+          // skip and tags\n+          if (self._tags.length > 0 && (track.tags == undefined || track.tags.tag == undefined\n+                || track.tags.tag.length < 1)) {\n+            continue;\n+          }\n+\n+          var match_tags = false;\n+          for (var tagsIndex = 0; tagsIndex < self._tags.length; tagsIndex++) {\n+            var tag = self._tags[tagsIndex];\n+            if (track.tags.tag.indexOf(tag) >= 0) {\n+              match_tags = true;\n+              break;\n+            }\n+          }", "originalCommit": "aa0cc7f1ed38bd860ba50f839ea03868ae006eb8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1ODI5MQ==", "url": "https://github.com/opencast/opencast/pull/1792#discussion_r478658291", "bodyText": "This will break if no resolution is defined.", "author": "lkiesow", "createdAt": "2020-08-27T19:51:51Z", "path": "modules/engage-paella-player/src/main/paella-opencast/plugins/es.upv.paella.opencast.downloadsButtonPlugin/mh_downloads.js", "diffHunk": "@@ -0,0 +1,272 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+class DownloadTrack {\n+  constructor(oc_track) {\n+    if (oc_track.audio == undefined && oc_track.video == undefined) {\n+      throw 'No audio and video';\n+    }\n+    this.flavor = oc_track.type;\n+    this.mimetype = paella.dictionary.translate(oc_track.mimetype);\n+    this.url = oc_track.url;\n+    if (oc_track.audio) {\n+      this.type = 'audio';\n+      this.audio_bitrate = oc_track.audio.bitrate;\n+    }\n+    if (oc_track.video) {\n+      this.type = 'video';\n+      this.video_resolution = oc_track.video.resolution;\n+      //this.video_quality = oc_track.video.resolution.split('x', 2)[1] + 'p';\n+      this.video_framerate = oc_track.video.framerate;\n+    }\n+  }\n+}\n+\n+/*global Class*/\n+paella.addPlugin(function() {\n+  return class DownloadsButtonPlugin extends paella.ButtonPlugin {\n+\n+    constructor() {\n+      super();\n+      this._tags = [];\n+      this._flavors = [];\n+      this._tags_and_flavors = false;\n+      this._episode = undefined;\n+      this._tracks = [];\n+    }\n+\n+    getSubclass() { return 'downloadsButton'; }\n+    getName() { return 'es.upv.paella.opencast.downloadsButtonPlugin'; }\n+    getIndex() { return 1000; }\n+    getDefaultToolTip() { return paella.dictionary.translate('Downloads'); }\n+    getAlignment() { return 'right'; }\n+    getButtonType() { return paella.ButtonPlugin.type.popUpButton; }\n+    getIconClass() { return 'icon-folder-download'; }\n+\n+    setup() {\n+      var self = this;\n+      if (self.config) {\n+        self._tags = [];\n+        if (self.config.tags) {\n+          self._tags = self.config.tags;\n+        }\n+        self._flavors = [];\n+        if (self.config.flavors) {\n+          self._flavors = self.config.flavors;\n+        }\n+        self._tags_and_flavors = false;\n+        if (self.config.tags_and_flavors) {\n+          self._tags_and_flavors = self.config.tags_and_flavors;\n+        }\n+      }\n+    }\n+\n+    checkEnabled(onSuccess) {\n+      var self = this;\n+      if (paella.player.isLiveStream()) {\n+        onSuccess(false);\n+      } else {\n+        paella.opencast.getEpisode()\n+        .then(function(episode) {\n+          self._episode = episode;\n+          // we can't filter tracks by tags and flavors\n+          // because the setup function will be called after checkEnabled\n+          onSuccess(true);\n+        })\n+        .catch(function(error) {\n+          base.log.error('opencast downloads button plugin disabled: ' + error);\n+          onSuccess(false);\n+        });\n+      }\n+    }\n+\n+    buildContent(domElement) {\n+      var self = this;\n+      if (self._episode !== undefined) {\n+        self.loadTracksFromEpisode();\n+      }\n+      self.renderTracks(domElement);\n+    }\n+\n+    loadTracksFromEpisode() {\n+      var self = this;\n+      var tracks = self._episode.mediapackage.media.track;\n+      if (!(tracks instanceof Array)) { tracks = [tracks]; }\n+\n+      var parsedTracks = [];\n+      for (var tracksIndex = 0; tracksIndex < tracks.length; tracksIndex++) {\n+        var track = tracks[tracksIndex];\n+        // only show static file content over http\n+        // skip streaming tracks\n+        if (track.url.startsWith('http')\n+            && (track.mimetype.indexOf('video') >= 0) || track.mimetype.indexOf('audio') >= 0) {\n+\n+          // skip live events\n+          if (track.live != undefined) {\n+            if (track.live) { continue; }\n+          }\n+\n+          // skip and tags\n+          if (self._tags.length > 0 && (track.tags == undefined || track.tags.tag == undefined\n+                || track.tags.tag.length < 1)) {\n+            continue;\n+          }\n+\n+          var match_tags = false;\n+          for (var tagsIndex = 0; tagsIndex < self._tags.length; tagsIndex++) {\n+            var tag = self._tags[tagsIndex];\n+            if (track.tags.tag.indexOf(tag) >= 0) {\n+              match_tags = true;\n+              break;\n+            }\n+          }\n+          // skip by flavor\n+          var match_flavors = false;\n+          for (var flavorsIndex = 0; flavorsIndex < self._flavors.length; flavorsIndex++) {\n+            var flavor = self._flavors[flavorsIndex];\n+            if (track.type === flavor) {\n+              match_flavors = true;\n+              break;\n+            }\n+          }\n+\n+          if (self._tags.length > 0 && self._flavors.length > 0) {\n+            if (self._tags_and_flavors) {\n+              if (!(match_tags && match_flavors)) { continue; }\n+            } else {\n+              if (!(match_tags || match_flavors)) { continue; }\n+            }\n+          } else {\n+            if (self._tags.length > 0 && !match_tags) { continue; }\n+            if (self._flavors.length > 0 && !match_flavors) { continue; }\n+          }\n+\n+          var parsedTrack = new DownloadTrack(track);\n+          parsedTracks.push(parsedTrack);\n+        }\n+      }\n+      self._tracks = parsedTracks;\n+    }\n+\n+    renderTracks(domElement) {\n+      var self = this;\n+      let container = document.createElement('div');\n+      container.className = 'downloadsButtonContainer';\n+\n+      if (self._episode === undefined || self._tracks.length < 1) {\n+        container.innerHTML = '<div class=\"downloadsItemContainer\"><p class=\"noTracks\">'\n+                                + paella.dictionary.translate('No downloads available') + '</p></div';\n+      } else {\n+        let trackTypes = ['video', 'audio'];\n+        let flavors = self._tracks.reduce(function(result, track) {\n+          if (result.indexOf(track.flavor) < 0) {\n+            result.push(track.flavor);\n+          }\n+          return result;\n+        }, []);\n+\n+        // group by flavor\n+        for (let flavorsIndex = 0; flavorsIndex < flavors.length; flavorsIndex++) {\n+          let flavor = flavors[flavorsIndex];\n+          let flavorContainer = document.createElement('div');\n+          flavorContainer.className = 'downloadsButtonItemContainer';\n+\n+          let flavorNameContainer = document.createElement('p');\n+          flavorNameContainer.innerText = flavor;\n+          flavorContainer.appendChild(flavorNameContainer);\n+\n+          // order by type (audio or video)\n+          for (let trackTypesIndex = 0; trackTypesIndex < trackTypes.length; trackTypesIndex++) {\n+            let trackType = trackTypes[trackTypesIndex];\n+            let tracks = self._tracks.filter(function(track) {\n+              return this === track.type;\n+            }, trackType);\n+\n+            // order by mimetype\n+            let trackMimetypes = tracks.reduce(function(result, track) {\n+              if (result.indexOf(track.mimetype) < 0) {\n+                result.push(track.mimetype);\n+              }\n+              return result;\n+            }, []);\n+\n+            trackMimetypes.sort(function(f1, f2) {\n+              return f1 === f2 ? 0 : f1 > f2 ? 1 : -1;\n+            });\n+\n+            // order by video resolution or audio bitrate\n+            for (let trackMimetypesIndex = 0; trackMimetypesIndex < trackMimetypes.length; trackMimetypesIndex++) {\n+              let mimetype = trackMimetypes[trackMimetypesIndex];\n+              let filteredTracks = tracks.filter(function(track) {\n+                return track.flavor === this.flavor && track.mimetype === this.mimetype;\n+              }, { 'flavor': flavor, 'mimetype': mimetype });\n+              filteredTracks.sort(function(t1, t2) {\n+                if (t1.type === t2.type) {\n+                  if ('video' === t1.type) {\n+                    let t1_height = t1.video_resolution.split('x')[1];\n+                    let t2_height = t2.video_resolution.split('x')[1];", "originalCommit": "aa0cc7f1ed38bd860ba50f839ea03868ae006eb8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY3Mzk5NA==", "url": "https://github.com/opencast/opencast/pull/1792#discussion_r478673994", "bodyText": "No it won't. Sorry.", "author": "lkiesow", "createdAt": "2020-08-27T20:22:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1ODI5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY2NjgxMg==", "url": "https://github.com/opencast/opencast/pull/1792#discussion_r478666812", "bodyText": "It might be simpler to use sets instead:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    let flavors = self._tracks.reduce(function(result, track) {\n          \n          \n            \n                      if (result.indexOf(track.flavor) < 0) {\n          \n          \n            \n                        result.push(track.flavor);\n          \n          \n            \n                      }\n          \n          \n            \n                      return result;\n          \n          \n            \n                    }, []);\n          \n          \n            \n                    let flavors = new Set(self._tracks.map(track => track.flavor)); \n          \n      \n    \n    \n  \n\nBut that also means that you would need to use Set functions below and iterate using for-of of forEach", "author": "lkiesow", "createdAt": "2020-08-27T20:08:33Z", "path": "modules/engage-paella-player/src/main/paella-opencast/plugins/es.upv.paella.opencast.downloadsButtonPlugin/mh_downloads.js", "diffHunk": "@@ -0,0 +1,272 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+class DownloadTrack {\n+  constructor(oc_track) {\n+    if (oc_track.audio == undefined && oc_track.video == undefined) {\n+      throw 'No audio and video';\n+    }\n+    this.flavor = oc_track.type;\n+    this.mimetype = paella.dictionary.translate(oc_track.mimetype);\n+    this.url = oc_track.url;\n+    if (oc_track.audio) {\n+      this.type = 'audio';\n+      this.audio_bitrate = oc_track.audio.bitrate;\n+    }\n+    if (oc_track.video) {\n+      this.type = 'video';\n+      this.video_resolution = oc_track.video.resolution;\n+      //this.video_quality = oc_track.video.resolution.split('x', 2)[1] + 'p';\n+      this.video_framerate = oc_track.video.framerate;\n+    }\n+  }\n+}\n+\n+/*global Class*/\n+paella.addPlugin(function() {\n+  return class DownloadsButtonPlugin extends paella.ButtonPlugin {\n+\n+    constructor() {\n+      super();\n+      this._tags = [];\n+      this._flavors = [];\n+      this._tags_and_flavors = false;\n+      this._episode = undefined;\n+      this._tracks = [];\n+    }\n+\n+    getSubclass() { return 'downloadsButton'; }\n+    getName() { return 'es.upv.paella.opencast.downloadsButtonPlugin'; }\n+    getIndex() { return 1000; }\n+    getDefaultToolTip() { return paella.dictionary.translate('Downloads'); }\n+    getAlignment() { return 'right'; }\n+    getButtonType() { return paella.ButtonPlugin.type.popUpButton; }\n+    getIconClass() { return 'icon-folder-download'; }\n+\n+    setup() {\n+      var self = this;\n+      if (self.config) {\n+        self._tags = [];\n+        if (self.config.tags) {\n+          self._tags = self.config.tags;\n+        }\n+        self._flavors = [];\n+        if (self.config.flavors) {\n+          self._flavors = self.config.flavors;\n+        }\n+        self._tags_and_flavors = false;\n+        if (self.config.tags_and_flavors) {\n+          self._tags_and_flavors = self.config.tags_and_flavors;\n+        }\n+      }\n+    }\n+\n+    checkEnabled(onSuccess) {\n+      var self = this;\n+      if (paella.player.isLiveStream()) {\n+        onSuccess(false);\n+      } else {\n+        paella.opencast.getEpisode()\n+        .then(function(episode) {\n+          self._episode = episode;\n+          // we can't filter tracks by tags and flavors\n+          // because the setup function will be called after checkEnabled\n+          onSuccess(true);\n+        })\n+        .catch(function(error) {\n+          base.log.error('opencast downloads button plugin disabled: ' + error);\n+          onSuccess(false);\n+        });\n+      }\n+    }\n+\n+    buildContent(domElement) {\n+      var self = this;\n+      if (self._episode !== undefined) {\n+        self.loadTracksFromEpisode();\n+      }\n+      self.renderTracks(domElement);\n+    }\n+\n+    loadTracksFromEpisode() {\n+      var self = this;\n+      var tracks = self._episode.mediapackage.media.track;\n+      if (!(tracks instanceof Array)) { tracks = [tracks]; }\n+\n+      var parsedTracks = [];\n+      for (var tracksIndex = 0; tracksIndex < tracks.length; tracksIndex++) {\n+        var track = tracks[tracksIndex];\n+        // only show static file content over http\n+        // skip streaming tracks\n+        if (track.url.startsWith('http')\n+            && (track.mimetype.indexOf('video') >= 0) || track.mimetype.indexOf('audio') >= 0) {\n+\n+          // skip live events\n+          if (track.live != undefined) {\n+            if (track.live) { continue; }\n+          }\n+\n+          // skip and tags\n+          if (self._tags.length > 0 && (track.tags == undefined || track.tags.tag == undefined\n+                || track.tags.tag.length < 1)) {\n+            continue;\n+          }\n+\n+          var match_tags = false;\n+          for (var tagsIndex = 0; tagsIndex < self._tags.length; tagsIndex++) {\n+            var tag = self._tags[tagsIndex];\n+            if (track.tags.tag.indexOf(tag) >= 0) {\n+              match_tags = true;\n+              break;\n+            }\n+          }\n+          // skip by flavor\n+          var match_flavors = false;\n+          for (var flavorsIndex = 0; flavorsIndex < self._flavors.length; flavorsIndex++) {\n+            var flavor = self._flavors[flavorsIndex];\n+            if (track.type === flavor) {\n+              match_flavors = true;\n+              break;\n+            }\n+          }\n+\n+          if (self._tags.length > 0 && self._flavors.length > 0) {\n+            if (self._tags_and_flavors) {\n+              if (!(match_tags && match_flavors)) { continue; }\n+            } else {\n+              if (!(match_tags || match_flavors)) { continue; }\n+            }\n+          } else {\n+            if (self._tags.length > 0 && !match_tags) { continue; }\n+            if (self._flavors.length > 0 && !match_flavors) { continue; }\n+          }\n+\n+          var parsedTrack = new DownloadTrack(track);\n+          parsedTracks.push(parsedTrack);\n+        }\n+      }\n+      self._tracks = parsedTracks;\n+    }\n+\n+    renderTracks(domElement) {\n+      var self = this;\n+      let container = document.createElement('div');\n+      container.className = 'downloadsButtonContainer';\n+\n+      if (self._episode === undefined || self._tracks.length < 1) {\n+        container.innerHTML = '<div class=\"downloadsItemContainer\"><p class=\"noTracks\">'\n+                                + paella.dictionary.translate('No downloads available') + '</p></div';\n+      } else {\n+        let trackTypes = ['video', 'audio'];\n+        let flavors = self._tracks.reduce(function(result, track) {\n+          if (result.indexOf(track.flavor) < 0) {\n+            result.push(track.flavor);\n+          }\n+          return result;\n+        }, []);", "originalCommit": "aa0cc7f1ed38bd860ba50f839ea03868ae006eb8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY2ODg1OA==", "url": "https://github.com/opencast/opencast/pull/1792#discussion_r478668858", "bodyText": "iirc, Paella uses Babel anyway so it might be easier to use\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      for (let trackTypesIndex = 0; trackTypesIndex < trackTypes.length; trackTypesIndex++) {\n          \n          \n            \n                        let trackType = trackTypes[trackTypesIndex];\n          \n          \n            \n                      for (const trackType of trackTypes) {", "author": "lkiesow", "createdAt": "2020-08-27T20:12:20Z", "path": "modules/engage-paella-player/src/main/paella-opencast/plugins/es.upv.paella.opencast.downloadsButtonPlugin/mh_downloads.js", "diffHunk": "@@ -0,0 +1,272 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+class DownloadTrack {\n+  constructor(oc_track) {\n+    if (oc_track.audio == undefined && oc_track.video == undefined) {\n+      throw 'No audio and video';\n+    }\n+    this.flavor = oc_track.type;\n+    this.mimetype = paella.dictionary.translate(oc_track.mimetype);\n+    this.url = oc_track.url;\n+    if (oc_track.audio) {\n+      this.type = 'audio';\n+      this.audio_bitrate = oc_track.audio.bitrate;\n+    }\n+    if (oc_track.video) {\n+      this.type = 'video';\n+      this.video_resolution = oc_track.video.resolution;\n+      //this.video_quality = oc_track.video.resolution.split('x', 2)[1] + 'p';\n+      this.video_framerate = oc_track.video.framerate;\n+    }\n+  }\n+}\n+\n+/*global Class*/\n+paella.addPlugin(function() {\n+  return class DownloadsButtonPlugin extends paella.ButtonPlugin {\n+\n+    constructor() {\n+      super();\n+      this._tags = [];\n+      this._flavors = [];\n+      this._tags_and_flavors = false;\n+      this._episode = undefined;\n+      this._tracks = [];\n+    }\n+\n+    getSubclass() { return 'downloadsButton'; }\n+    getName() { return 'es.upv.paella.opencast.downloadsButtonPlugin'; }\n+    getIndex() { return 1000; }\n+    getDefaultToolTip() { return paella.dictionary.translate('Downloads'); }\n+    getAlignment() { return 'right'; }\n+    getButtonType() { return paella.ButtonPlugin.type.popUpButton; }\n+    getIconClass() { return 'icon-folder-download'; }\n+\n+    setup() {\n+      var self = this;\n+      if (self.config) {\n+        self._tags = [];\n+        if (self.config.tags) {\n+          self._tags = self.config.tags;\n+        }\n+        self._flavors = [];\n+        if (self.config.flavors) {\n+          self._flavors = self.config.flavors;\n+        }\n+        self._tags_and_flavors = false;\n+        if (self.config.tags_and_flavors) {\n+          self._tags_and_flavors = self.config.tags_and_flavors;\n+        }\n+      }\n+    }\n+\n+    checkEnabled(onSuccess) {\n+      var self = this;\n+      if (paella.player.isLiveStream()) {\n+        onSuccess(false);\n+      } else {\n+        paella.opencast.getEpisode()\n+        .then(function(episode) {\n+          self._episode = episode;\n+          // we can't filter tracks by tags and flavors\n+          // because the setup function will be called after checkEnabled\n+          onSuccess(true);\n+        })\n+        .catch(function(error) {\n+          base.log.error('opencast downloads button plugin disabled: ' + error);\n+          onSuccess(false);\n+        });\n+      }\n+    }\n+\n+    buildContent(domElement) {\n+      var self = this;\n+      if (self._episode !== undefined) {\n+        self.loadTracksFromEpisode();\n+      }\n+      self.renderTracks(domElement);\n+    }\n+\n+    loadTracksFromEpisode() {\n+      var self = this;\n+      var tracks = self._episode.mediapackage.media.track;\n+      if (!(tracks instanceof Array)) { tracks = [tracks]; }\n+\n+      var parsedTracks = [];\n+      for (var tracksIndex = 0; tracksIndex < tracks.length; tracksIndex++) {\n+        var track = tracks[tracksIndex];\n+        // only show static file content over http\n+        // skip streaming tracks\n+        if (track.url.startsWith('http')\n+            && (track.mimetype.indexOf('video') >= 0) || track.mimetype.indexOf('audio') >= 0) {\n+\n+          // skip live events\n+          if (track.live != undefined) {\n+            if (track.live) { continue; }\n+          }\n+\n+          // skip and tags\n+          if (self._tags.length > 0 && (track.tags == undefined || track.tags.tag == undefined\n+                || track.tags.tag.length < 1)) {\n+            continue;\n+          }\n+\n+          var match_tags = false;\n+          for (var tagsIndex = 0; tagsIndex < self._tags.length; tagsIndex++) {\n+            var tag = self._tags[tagsIndex];\n+            if (track.tags.tag.indexOf(tag) >= 0) {\n+              match_tags = true;\n+              break;\n+            }\n+          }\n+          // skip by flavor\n+          var match_flavors = false;\n+          for (var flavorsIndex = 0; flavorsIndex < self._flavors.length; flavorsIndex++) {\n+            var flavor = self._flavors[flavorsIndex];\n+            if (track.type === flavor) {\n+              match_flavors = true;\n+              break;\n+            }\n+          }\n+\n+          if (self._tags.length > 0 && self._flavors.length > 0) {\n+            if (self._tags_and_flavors) {\n+              if (!(match_tags && match_flavors)) { continue; }\n+            } else {\n+              if (!(match_tags || match_flavors)) { continue; }\n+            }\n+          } else {\n+            if (self._tags.length > 0 && !match_tags) { continue; }\n+            if (self._flavors.length > 0 && !match_flavors) { continue; }\n+          }\n+\n+          var parsedTrack = new DownloadTrack(track);\n+          parsedTracks.push(parsedTrack);\n+        }\n+      }\n+      self._tracks = parsedTracks;\n+    }\n+\n+    renderTracks(domElement) {\n+      var self = this;\n+      let container = document.createElement('div');\n+      container.className = 'downloadsButtonContainer';\n+\n+      if (self._episode === undefined || self._tracks.length < 1) {\n+        container.innerHTML = '<div class=\"downloadsItemContainer\"><p class=\"noTracks\">'\n+                                + paella.dictionary.translate('No downloads available') + '</p></div';\n+      } else {\n+        let trackTypes = ['video', 'audio'];\n+        let flavors = self._tracks.reduce(function(result, track) {\n+          if (result.indexOf(track.flavor) < 0) {\n+            result.push(track.flavor);\n+          }\n+          return result;\n+        }, []);\n+\n+        // group by flavor\n+        for (let flavorsIndex = 0; flavorsIndex < flavors.length; flavorsIndex++) {\n+          let flavor = flavors[flavorsIndex];\n+          let flavorContainer = document.createElement('div');\n+          flavorContainer.className = 'downloadsButtonItemContainer';\n+\n+          let flavorNameContainer = document.createElement('p');\n+          flavorNameContainer.innerText = flavor;\n+          flavorContainer.appendChild(flavorNameContainer);\n+\n+          // order by type (audio or video)\n+          for (let trackTypesIndex = 0; trackTypesIndex < trackTypes.length; trackTypesIndex++) {\n+            let trackType = trackTypes[trackTypesIndex];", "originalCommit": "aa0cc7f1ed38bd860ba50f839ea03868ae006eb8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY3MDg3Ng==", "url": "https://github.com/opencast/opencast/pull/1792#discussion_r478670876", "bodyText": "This is just natural sorting, isn't it? So this should be identical to just calling sort() without custom function\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        trackMimetypes.sort(function(f1, f2) {\n          \n          \n            \n                          return f1 === f2 ? 0 : f1 > f2 ? 1 : -1;\n          \n          \n            \n                        });\n          \n          \n            \n                        trackMimetypes.sort();", "author": "lkiesow", "createdAt": "2020-08-27T20:16:20Z", "path": "modules/engage-paella-player/src/main/paella-opencast/plugins/es.upv.paella.opencast.downloadsButtonPlugin/mh_downloads.js", "diffHunk": "@@ -0,0 +1,272 @@\n+/**\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ *\n+ * The Apereo Foundation licenses this file to you under the Educational\n+ * Community License, Version 2.0 (the \"License\"); you may not use this file\n+ * except in compliance with the License. You may obtain a copy of the License\n+ * at:\n+ *\n+ *   http://opensource.org/licenses/ecl2.txt\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ *\n+ */\n+\n+class DownloadTrack {\n+  constructor(oc_track) {\n+    if (oc_track.audio == undefined && oc_track.video == undefined) {\n+      throw 'No audio and video';\n+    }\n+    this.flavor = oc_track.type;\n+    this.mimetype = paella.dictionary.translate(oc_track.mimetype);\n+    this.url = oc_track.url;\n+    if (oc_track.audio) {\n+      this.type = 'audio';\n+      this.audio_bitrate = oc_track.audio.bitrate;\n+    }\n+    if (oc_track.video) {\n+      this.type = 'video';\n+      this.video_resolution = oc_track.video.resolution;\n+      //this.video_quality = oc_track.video.resolution.split('x', 2)[1] + 'p';\n+      this.video_framerate = oc_track.video.framerate;\n+    }\n+  }\n+}\n+\n+/*global Class*/\n+paella.addPlugin(function() {\n+  return class DownloadsButtonPlugin extends paella.ButtonPlugin {\n+\n+    constructor() {\n+      super();\n+      this._tags = [];\n+      this._flavors = [];\n+      this._tags_and_flavors = false;\n+      this._episode = undefined;\n+      this._tracks = [];\n+    }\n+\n+    getSubclass() { return 'downloadsButton'; }\n+    getName() { return 'es.upv.paella.opencast.downloadsButtonPlugin'; }\n+    getIndex() { return 1000; }\n+    getDefaultToolTip() { return paella.dictionary.translate('Downloads'); }\n+    getAlignment() { return 'right'; }\n+    getButtonType() { return paella.ButtonPlugin.type.popUpButton; }\n+    getIconClass() { return 'icon-folder-download'; }\n+\n+    setup() {\n+      var self = this;\n+      if (self.config) {\n+        self._tags = [];\n+        if (self.config.tags) {\n+          self._tags = self.config.tags;\n+        }\n+        self._flavors = [];\n+        if (self.config.flavors) {\n+          self._flavors = self.config.flavors;\n+        }\n+        self._tags_and_flavors = false;\n+        if (self.config.tags_and_flavors) {\n+          self._tags_and_flavors = self.config.tags_and_flavors;\n+        }\n+      }\n+    }\n+\n+    checkEnabled(onSuccess) {\n+      var self = this;\n+      if (paella.player.isLiveStream()) {\n+        onSuccess(false);\n+      } else {\n+        paella.opencast.getEpisode()\n+        .then(function(episode) {\n+          self._episode = episode;\n+          // we can't filter tracks by tags and flavors\n+          // because the setup function will be called after checkEnabled\n+          onSuccess(true);\n+        })\n+        .catch(function(error) {\n+          base.log.error('opencast downloads button plugin disabled: ' + error);\n+          onSuccess(false);\n+        });\n+      }\n+    }\n+\n+    buildContent(domElement) {\n+      var self = this;\n+      if (self._episode !== undefined) {\n+        self.loadTracksFromEpisode();\n+      }\n+      self.renderTracks(domElement);\n+    }\n+\n+    loadTracksFromEpisode() {\n+      var self = this;\n+      var tracks = self._episode.mediapackage.media.track;\n+      if (!(tracks instanceof Array)) { tracks = [tracks]; }\n+\n+      var parsedTracks = [];\n+      for (var tracksIndex = 0; tracksIndex < tracks.length; tracksIndex++) {\n+        var track = tracks[tracksIndex];\n+        // only show static file content over http\n+        // skip streaming tracks\n+        if (track.url.startsWith('http')\n+            && (track.mimetype.indexOf('video') >= 0) || track.mimetype.indexOf('audio') >= 0) {\n+\n+          // skip live events\n+          if (track.live != undefined) {\n+            if (track.live) { continue; }\n+          }\n+\n+          // skip and tags\n+          if (self._tags.length > 0 && (track.tags == undefined || track.tags.tag == undefined\n+                || track.tags.tag.length < 1)) {\n+            continue;\n+          }\n+\n+          var match_tags = false;\n+          for (var tagsIndex = 0; tagsIndex < self._tags.length; tagsIndex++) {\n+            var tag = self._tags[tagsIndex];\n+            if (track.tags.tag.indexOf(tag) >= 0) {\n+              match_tags = true;\n+              break;\n+            }\n+          }\n+          // skip by flavor\n+          var match_flavors = false;\n+          for (var flavorsIndex = 0; flavorsIndex < self._flavors.length; flavorsIndex++) {\n+            var flavor = self._flavors[flavorsIndex];\n+            if (track.type === flavor) {\n+              match_flavors = true;\n+              break;\n+            }\n+          }\n+\n+          if (self._tags.length > 0 && self._flavors.length > 0) {\n+            if (self._tags_and_flavors) {\n+              if (!(match_tags && match_flavors)) { continue; }\n+            } else {\n+              if (!(match_tags || match_flavors)) { continue; }\n+            }\n+          } else {\n+            if (self._tags.length > 0 && !match_tags) { continue; }\n+            if (self._flavors.length > 0 && !match_flavors) { continue; }\n+          }\n+\n+          var parsedTrack = new DownloadTrack(track);\n+          parsedTracks.push(parsedTrack);\n+        }\n+      }\n+      self._tracks = parsedTracks;\n+    }\n+\n+    renderTracks(domElement) {\n+      var self = this;\n+      let container = document.createElement('div');\n+      container.className = 'downloadsButtonContainer';\n+\n+      if (self._episode === undefined || self._tracks.length < 1) {\n+        container.innerHTML = '<div class=\"downloadsItemContainer\"><p class=\"noTracks\">'\n+                                + paella.dictionary.translate('No downloads available') + '</p></div';\n+      } else {\n+        let trackTypes = ['video', 'audio'];\n+        let flavors = self._tracks.reduce(function(result, track) {\n+          if (result.indexOf(track.flavor) < 0) {\n+            result.push(track.flavor);\n+          }\n+          return result;\n+        }, []);\n+\n+        // group by flavor\n+        for (let flavorsIndex = 0; flavorsIndex < flavors.length; flavorsIndex++) {\n+          let flavor = flavors[flavorsIndex];\n+          let flavorContainer = document.createElement('div');\n+          flavorContainer.className = 'downloadsButtonItemContainer';\n+\n+          let flavorNameContainer = document.createElement('p');\n+          flavorNameContainer.innerText = flavor;\n+          flavorContainer.appendChild(flavorNameContainer);\n+\n+          // order by type (audio or video)\n+          for (let trackTypesIndex = 0; trackTypesIndex < trackTypes.length; trackTypesIndex++) {\n+            let trackType = trackTypes[trackTypesIndex];\n+            let tracks = self._tracks.filter(function(track) {\n+              return this === track.type;\n+            }, trackType);\n+\n+            // order by mimetype\n+            let trackMimetypes = tracks.reduce(function(result, track) {\n+              if (result.indexOf(track.mimetype) < 0) {\n+                result.push(track.mimetype);\n+              }\n+              return result;\n+            }, []);\n+\n+            trackMimetypes.sort(function(f1, f2) {\n+              return f1 === f2 ? 0 : f1 > f2 ? 1 : -1;\n+            });", "originalCommit": "aa0cc7f1ed38bd860ba50f839ea03868ae006eb8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY3Mjc2OQ==", "url": "https://github.com/opencast/opencast/pull/1792#discussion_r478672769", "bodyText": "If you introduce new localization files, you need to add them to .crowdin.yaml", "author": "lkiesow", "createdAt": "2020-08-27T20:20:16Z", "path": "modules/engage-paella-player/src/main/paella-opencast/plugins/es.upv.paella.opencast.downloadsButtonPlugin/localization/da-DK.json", "diffHunk": "@@ -0,0 +1,3 @@\n+{", "originalCommit": "aa0cc7f1ed38bd860ba50f839ea03868ae006eb8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzUyODczNg==", "url": "https://github.com/opencast/opencast/pull/1792#discussion_r497528736", "bodyText": "The crowdin configuration currently match the new plugin location", "author": "wsmirnow", "createdAt": "2020-09-30T13:54:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY3Mjc2OQ=="}], "type": "inlineReview"}, {"oid": "a967ade6fa8d1f157c1c3f3d793dd032289bbfc4", "url": "https://github.com/opencast/opencast/commit/a967ade6fa8d1f157c1c3f3d793dd032289bbfc4", "message": "Standalone downloads Paella plugin\n\nOn click on the downloads button in the right menu area of the Paella player, all available tracks for download will be shown. The download links are grouped by flavor and ordered by type (audio or video), mimetype and video resolution or audio bitrate in this order. You can also configure tags and/or flavors of tracks, that should be availabe for download. The plugin does not replace the previous downloads tab from description plugin but is an additional standalone plugin. You can enable or disable these both independently.", "committedDate": "2021-04-13T00:16:22Z", "type": "commit"}, {"oid": "210a887aa8807fb48167bd939df49c468164b54d", "url": "https://github.com/opencast/opencast/commit/210a887aa8807fb48167bd939df49c468164b54d", "message": "improved code quality and resolved review suggestions", "committedDate": "2021-04-13T00:16:23Z", "type": "forcePushed"}, {"oid": "fbef4d95f41793f36b954f3de446380567964bbf", "url": "https://github.com/opencast/opencast/commit/fbef4d95f41793f36b954f3de446380567964bbf", "message": "improved code quality and resolved review suggestions", "committedDate": "2021-04-13T00:45:54Z", "type": "commit"}, {"oid": "fbef4d95f41793f36b954f3de446380567964bbf", "url": "https://github.com/opencast/opencast/commit/fbef4d95f41793f36b954f3de446380567964bbf", "message": "improved code quality and resolved review suggestions", "committedDate": "2021-04-13T00:45:54Z", "type": "forcePushed"}]}