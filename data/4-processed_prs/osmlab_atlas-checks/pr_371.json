{"pr_number": 371, "pr_title": "Add LevelCrossingOnRailwayCheck", "pr_createdAt": "2020-09-22T20:22:41Z", "pr_url": "https://github.com/osmlab/atlas-checks/pull/371", "timeline": [{"oid": "67791f2ea6ccf8bfb63b2c8b5b594807196d816f", "url": "https://github.com/osmlab/atlas-checks/commit/67791f2ea6ccf8bfb63b2c8b5b594807196d816f", "message": "Add railway level_crossing check", "committedDate": "2020-09-22T19:44:19Z", "type": "commit"}, {"oid": "ff115c10bfd5224f4aa8e3c4d983fbc30dee113a", "url": "https://github.com/osmlab/atlas-checks/commit/ff115c10bfd5224f4aa8e3c4d983fbc30dee113a", "message": "Add documentation and fix bug found in first version", "committedDate": "2020-09-23T15:18:10Z", "type": "commit"}, {"oid": "b37865a14d8be8e9691055fd82d949b6e9ca6d0e", "url": "https://github.com/osmlab/atlas-checks/commit/b37865a14d8be8e9691055fd82d949b6e9ca6d0e", "message": "Fix code smell issues", "committedDate": "2020-09-23T17:29:57Z", "type": "commit"}, {"oid": "8e52c678da89d753165038fc4dd6fbbefd24d567", "url": "https://github.com/osmlab/atlas-checks/commit/8e52c678da89d753165038fc4dd6fbbefd24d567", "message": "Fix code smell complexity issue", "committedDate": "2020-09-23T19:08:20Z", "type": "commit"}, {"oid": "3cd71be669b22853696d17b7c76244b57e18053f", "url": "https://github.com/osmlab/atlas-checks/commit/3cd71be669b22853696d17b7c76244b57e18053f", "message": "Add levelcrossing doc to available checks doc", "committedDate": "2020-09-23T20:02:59Z", "type": "commit"}, {"oid": "359bff9179c730e9cbc2725cbdaefa58ef9b9230", "url": "https://github.com/osmlab/atlas-checks/commit/359bff9179c730e9cbc2725cbdaefa58ef9b9230", "message": "skipping rails that are also highways in some cases", "committedDate": "2020-09-25T20:51:58Z", "type": "commit"}, {"oid": "872d82ced9403f140bd6104c836ff6cbdf8a3ceb", "url": "https://github.com/osmlab/atlas-checks/commit/872d82ced9403f140bd6104c836ff6cbdf8a3ceb", "message": "fix spotlessJava failure.", "committedDate": "2020-09-30T01:01:47Z", "type": "commit"}, {"oid": "895acc9de82fb87d0a8bb63e1968c244ef7f50e9", "url": "https://github.com/osmlab/atlas-checks/commit/895acc9de82fb87d0a8bb63e1968c244ef7f50e9", "message": "Merge branch 'dev' of github.com:/osmlab/atlas-checks into level_crossing-check", "committedDate": "2020-10-01T19:01:38Z", "type": "commit"}, {"oid": "b6a9d1c263fff9f5e5cf0cb6f0775e0ba0b826df", "url": "https://github.com/osmlab/atlas-checks/commit/b6a9d1c263fff9f5e5cf0cb6f0775e0ba0b826df", "message": "add fix suggestions", "committedDate": "2020-10-05T16:00:16Z", "type": "commit"}, {"oid": "b38a1529e5d54b6725bb7715789dfbf6c8bccadb", "url": "https://github.com/osmlab/atlas-checks/commit/b38a1529e5d54b6725bb7715789dfbf6c8bccadb", "message": "Merge branch 'dev' of github.com:atiannicelli/atlas-checks into level_crossing-check", "committedDate": "2020-10-19T18:00:00Z", "type": "commit"}, {"oid": "2c6b4ed7f03756b4f43ca67febf2d777b9c8696f", "url": "https://github.com/osmlab/atlas-checks/commit/2c6b4ed7f03756b4f43ca67febf2d777b9c8696f", "message": "Update to deal with layers better.", "committedDate": "2020-10-22T00:47:24Z", "type": "commit"}, {"oid": "b803cabe2d59047b7e0884cbbb381ab1636e120c", "url": "https://github.com/osmlab/atlas-checks/commit/b803cabe2d59047b7e0884cbbb381ab1636e120c", "message": "Ignore construction and proposed rails.", "committedDate": "2020-10-23T17:54:45Z", "type": "commit"}, {"oid": "47ac84ea32732f73b0b5db2187a81e04b83d4c2d", "url": "https://github.com/osmlab/atlas-checks/commit/47ac84ea32732f73b0b5db2187a81e04b83d4c2d", "message": "Make it smell good.", "committedDate": "2020-10-23T18:30:08Z", "type": "commit"}, {"oid": "8d2d5fdaf0258663658217b58088eeda1828318d", "url": "https://github.com/osmlab/atlas-checks/commit/8d2d5fdaf0258663658217b58088eeda1828318d", "message": "fix smells", "committedDate": "2020-10-23T18:34:02Z", "type": "commit"}, {"oid": "7f9c950ea60e24e4c9a9c430d54986536a096cc3", "url": "https://github.com/osmlab/atlas-checks/commit/7f9c950ea60e24e4c9a9c430d54986536a096cc3", "message": "kick travis to retest", "committedDate": "2020-10-23T19:31:30Z", "type": "commit"}, {"oid": "17099e4a36a1c6ef15b72d028e08576a0266f534", "url": "https://github.com/osmlab/atlas-checks/commit/17099e4a36a1c6ef15b72d028e08576a0266f534", "message": "one more smell removed.", "committedDate": "2020-10-23T20:59:25Z", "type": "commit"}, {"oid": "5b04f39cd9bfdb95120aae02296da81fce1126eb", "url": "https://github.com/osmlab/atlas-checks/commit/5b04f39cd9bfdb95120aae02296da81fce1126eb", "message": "convert rail list to filter", "committedDate": "2020-10-28T16:30:10Z", "type": "commit"}, {"oid": "08f66b4f3263fd3e51badd50b9f140d728fe54e2", "url": "https://github.com/osmlab/atlas-checks/commit/08f66b4f3263fd3e51badd50b9f140d728fe54e2", "message": "Add rail list to configuration file.", "committedDate": "2020-10-28T16:31:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ1NjE0Nw==", "url": "https://github.com/osmlab/atlas-checks/pull/371#discussion_r514456147", "bodyText": "Please add this to the configuration file. Otherwise it can be easy to forget it exists.", "author": "Bentleysb", "createdAt": "2020-10-29T17:54:14Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LevelCrossingOnRailwayCheck.java", "diffHunk": "@@ -0,0 +1,369 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.complete.CompleteEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasItem;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.ConstructionDateTag;\n+import org.openstreetmap.atlas.tags.ConstructionTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.RailwayTag;\n+import org.openstreetmap.atlas.tags.annotations.validation.Validators;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * This check is to detect and flag nodes under the three scenarios below: 1) When a railway crosses\n+ * a highway, but intersection node is missing. 2) When railway/highway intersection node exists,\n+ * but railway=level_crossing tag is missing. 3) When tag railway=level_crossing exists, on a node,\n+ * but is lacking of either highway or railway going through the node (osmose 7090), or not on a\n+ * node, instead, on the related way features (osmose 9015)\n+ *\n+ * @author aiannicelli\n+ */\n+public class LevelCrossingOnRailwayCheck extends BaseCheck<Long>\n+{\n+    private static final String RAILWAY_FILTER_DEFAULT = \"railway->rail,tram,disused,preserved,miniature,light_rail,subway,narrow_gauge\";\n+    private final TaggableFilter railwayFilter;\n+    private static final Long OSM_LAYER_DEFAULT = 0L;\n+    private final Long layerDefault;\n+    private static final String INVALID_TAGGED_OBJECT = \"The object (OSM ID: {0,number,#}) has `railway=level_crossing` \"\n+            + \"but is not a node. To fix: Remove `railway=level_crossing` tag.\";\n+    private static final int INVALID_TAGGED_OBJECT_INDEX = 0;\n+    private static final String NODE_MISSING_LC_TAG = \"The intersection node (OSM ID: {0,number,#}) is \"\n+            + \"missing a `railway=level_crossing` tag. This means that there are at least one valid railway and one \"\n+            + \"car navigable highway on the same layer at this node. To fix: If the two ways should be on different \"\n+            + \"layers then adjust the layer tags for each way appropriately. If the two ways do intersect on the same \"\n+            + \"layer then add the `railway=level_crossing` tag to this node.\";\n+    private static final int NODE_MISSING_LC_TAG_INDEX = 1;\n+    private static final String NODE_INVALID_LC_TAG_NO_HIGHWAY = \"The node (OSM ID: {0,number,#}) has \"\n+            + \"`railway=level_crossing` tag, but there is no car navigable highway at this intersection. \"\n+            + \"To fix: Remove railway=level_crossing tag.\";\n+    private static final int NODE_INVALID_LC_TAG_NO_HIGHWAY_INDEX = 2;\n+    private static final String NODE_INVALID_LC_TAG_NO_RAILWAY = \"The node (OSM ID: {0,number,#}) has \"\n+            + \"`railway=level_crossing` tag, but there are no existing rails at this intersection. \"\n+            + \"To fix: Remove railway=level_crossing tag.\";\n+    private static final int NODE_INVALID_LC_TAG_NO_RAILWAY_INDEX = 3;\n+    private static final String NODE_INVALID_LC_TAG_LAYERS = \"The node (OSM ID: {0,number,#}) has `railway=level_crossing` \"\n+            + \"tag, but there are no railway and highway intersection on the same layer. \"\n+            + \"To fix: If the railway and highway should be on the same layer then update the layer tags for both ways \"\n+            + \"to be equal. If the ways are on different layers then remove railway=level_crossing tag.\";\n+    private static final int NODE_INVALID_LC_TAG_LAYERS_INDEX = 4;\n+    private static final String INTERSECTION_MISSING_NODE = \"The railway (OSM ID: {0,number,#}) has one or more car \"\n+            + \"navigable intersections on the same layer that are missing intersection nodes. To fix: \"\n+            + \"If highway and railway do cross at the same layer then add appropriate intersection node(s) with \"\n+            + \"`railway=level_crossing` tag. If highway and railway are on different layers then update the \"\n+            + \"appropriate layer tag for the way that goes under or over the other way.\";\n+    private static final int INTERSECTION_MISSING_NODE_INDEX = 5;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INVALID_TAGGED_OBJECT,\n+            NODE_MISSING_LC_TAG, NODE_INVALID_LC_TAG_NO_HIGHWAY, NODE_INVALID_LC_TAG_NO_RAILWAY,\n+            NODE_INVALID_LC_TAG_LAYERS, INTERSECTION_MISSING_NODE);\n+    private static final List<String> CONSTRUCTION_TAGS = List.of(HighwayTag.KEY, RailwayTag.KEY);\n+    private static final long serialVersionUID = -2063033332877849846L;\n+\n+    /**\n+     * constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public LevelCrossingOnRailwayCheck(final Configuration configuration)\n+    {\n+\n+        super(configuration);\n+        this.layerDefault = this.configurationValue(configuration, \"layer.default\",", "originalCommit": "08f66b4f3263fd3e51badd50b9f140d728fe54e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU2MTcxOQ==", "url": "https://github.com/osmlab/atlas-checks/pull/371#discussion_r514561719", "bodyText": "Done", "author": "atiannicelli", "createdAt": "2020-10-29T20:56:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ1NjE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ2MDgxMw==", "url": "https://github.com/osmlab/atlas-checks/pull/371#discussion_r514460813", "bodyText": "Nice!", "author": "Bentleysb", "createdAt": "2020-10-29T18:01:35Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LevelCrossingOnRailwayCheck.java", "diffHunk": "@@ -0,0 +1,369 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.complete.CompleteEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasItem;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.ConstructionDateTag;\n+import org.openstreetmap.atlas.tags.ConstructionTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.RailwayTag;\n+import org.openstreetmap.atlas.tags.annotations.validation.Validators;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * This check is to detect and flag nodes under the three scenarios below: 1) When a railway crosses\n+ * a highway, but intersection node is missing. 2) When railway/highway intersection node exists,\n+ * but railway=level_crossing tag is missing. 3) When tag railway=level_crossing exists, on a node,\n+ * but is lacking of either highway or railway going through the node (osmose 7090), or not on a\n+ * node, instead, on the related way features (osmose 9015)\n+ *\n+ * @author aiannicelli\n+ */\n+public class LevelCrossingOnRailwayCheck extends BaseCheck<Long>\n+{\n+    private static final String RAILWAY_FILTER_DEFAULT = \"railway->rail,tram,disused,preserved,miniature,light_rail,subway,narrow_gauge\";\n+    private final TaggableFilter railwayFilter;\n+    private static final Long OSM_LAYER_DEFAULT = 0L;\n+    private final Long layerDefault;\n+    private static final String INVALID_TAGGED_OBJECT = \"The object (OSM ID: {0,number,#}) has `railway=level_crossing` \"\n+            + \"but is not a node. To fix: Remove `railway=level_crossing` tag.\";\n+    private static final int INVALID_TAGGED_OBJECT_INDEX = 0;\n+    private static final String NODE_MISSING_LC_TAG = \"The intersection node (OSM ID: {0,number,#}) is \"\n+            + \"missing a `railway=level_crossing` tag. This means that there are at least one valid railway and one \"\n+            + \"car navigable highway on the same layer at this node. To fix: If the two ways should be on different \"\n+            + \"layers then adjust the layer tags for each way appropriately. If the two ways do intersect on the same \"\n+            + \"layer then add the `railway=level_crossing` tag to this node.\";\n+    private static final int NODE_MISSING_LC_TAG_INDEX = 1;\n+    private static final String NODE_INVALID_LC_TAG_NO_HIGHWAY = \"The node (OSM ID: {0,number,#}) has \"\n+            + \"`railway=level_crossing` tag, but there is no car navigable highway at this intersection. \"\n+            + \"To fix: Remove railway=level_crossing tag.\";\n+    private static final int NODE_INVALID_LC_TAG_NO_HIGHWAY_INDEX = 2;\n+    private static final String NODE_INVALID_LC_TAG_NO_RAILWAY = \"The node (OSM ID: {0,number,#}) has \"\n+            + \"`railway=level_crossing` tag, but there are no existing rails at this intersection. \"\n+            + \"To fix: Remove railway=level_crossing tag.\";\n+    private static final int NODE_INVALID_LC_TAG_NO_RAILWAY_INDEX = 3;\n+    private static final String NODE_INVALID_LC_TAG_LAYERS = \"The node (OSM ID: {0,number,#}) has `railway=level_crossing` \"\n+            + \"tag, but there are no railway and highway intersection on the same layer. \"\n+            + \"To fix: If the railway and highway should be on the same layer then update the layer tags for both ways \"\n+            + \"to be equal. If the ways are on different layers then remove railway=level_crossing tag.\";\n+    private static final int NODE_INVALID_LC_TAG_LAYERS_INDEX = 4;\n+    private static final String INTERSECTION_MISSING_NODE = \"The railway (OSM ID: {0,number,#}) has one or more car \"\n+            + \"navigable intersections on the same layer that are missing intersection nodes. To fix: \"\n+            + \"If highway and railway do cross at the same layer then add appropriate intersection node(s) with \"\n+            + \"`railway=level_crossing` tag. If highway and railway are on different layers then update the \"\n+            + \"appropriate layer tag for the way that goes under or over the other way.\";\n+    private static final int INTERSECTION_MISSING_NODE_INDEX = 5;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INVALID_TAGGED_OBJECT,\n+            NODE_MISSING_LC_TAG, NODE_INVALID_LC_TAG_NO_HIGHWAY, NODE_INVALID_LC_TAG_NO_RAILWAY,\n+            NODE_INVALID_LC_TAG_LAYERS, INTERSECTION_MISSING_NODE);\n+    private static final List<String> CONSTRUCTION_TAGS = List.of(HighwayTag.KEY, RailwayTag.KEY);\n+    private static final long serialVersionUID = -2063033332877849846L;\n+\n+    /**\n+     * constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public LevelCrossingOnRailwayCheck(final Configuration configuration)\n+    {\n+\n+        super(configuration);\n+        this.layerDefault = this.configurationValue(configuration, \"layer.default\",\n+                OSM_LAYER_DEFAULT);\n+        this.railwayFilter = this.configurationValue(configuration, \"railway.filter\",\n+                RAILWAY_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+    }\n+\n+    /**\n+     * Object check looks for the vaild objects to check for level_crossing tag.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        /*-\n+         * The following objects should be checked:\n+         *  1) Any node.\n+         *  2) Any object that is tagged with railway=level_crossing.\n+         *  3) Any object that is tagged as a railway as indicted in railway.filter.\n+         */\n+        return object instanceof Node\n+                || Validators.isOfType(object, RailwayTag.class, RailwayTag.LEVEL_CROSSING)\n+                || this.railwayFilter.test(object);\n+    }\n+\n+    /**\n+     * Create a Return Flags for level_crossing objects.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that contains flagged issue details\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        /*-\n+         * The following invalid situations are to be flagged:\n+         *  1) object is node and\n+         *     a) is marked as a level crossing but does in not an intersection of highway and railway\n+         *     b) is not tagged as a level crossing and is an intersection of highway and railway.\n+         *  2) object is not a node or point and is tagged with railway=level_crossing.\n+         *  3) object is railway and intersects a highway on the same layer but there is no node.\n+         */\n+\n+        final Optional<CheckFlag> flagIncorrectlyTagged = this.flagIncorrectlyTagged(object);\n+        if (!flagIncorrectlyTagged.isEmpty())\n+        {\n+            return flagIncorrectlyTagged;\n+        }\n+        final Optional<CheckFlag> flagNonNodeTagged = this.flagNonNodeTagged(object);\n+        if (!flagNonNodeTagged.isEmpty())\n+        {\n+            return flagNonNodeTagged;\n+        }\n+        final Optional<CheckFlag> flagInvalidIntersections = this.flagInvalidIntersections(object);\n+        if (!flagInvalidIntersections.isEmpty())\n+        {\n+            return flagInvalidIntersections;\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Flag nodes incorrectly tagged with level_crossing or missing level_crossing tag.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that contains flagged issue details\n+     */\n+    private Optional<CheckFlag> flagIncorrectlyTagged(final AtlasObject object)\n+    {\n+        if (object instanceof Node)\n+        {\n+            final Node node = (Node) object;\n+\n+            final int issueType = this.isValidLevelCrossingNode(node);\n+            if (Validators.isOfType(node, RailwayTag.class, RailwayTag.LEVEL_CROSSING)\n+                    && issueType > 0)\n+            {\n+                // This is a node that is tagged with railway=level_crossing and is not a\n+                // railway/highway intersection\n+                return Optional.of(this\n+                        .createFlag(object,\n+                                this.getLocalizedInstruction(issueType, object.getOsmIdentifier()))\n+                        .addFixSuggestion(FeatureChange.add(", "originalCommit": "08f66b4f3263fd3e51badd50b9f140d728fe54e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ2MzU1Ng==", "url": "https://github.com/osmlab/atlas-checks/pull/371#discussion_r514463556", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (!(object instanceof Node || object instanceof Point)\n          \n          \n            \n                    if (!(object instanceof LocationItem)", "author": "Bentleysb", "createdAt": "2020-10-29T18:05:49Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LevelCrossingOnRailwayCheck.java", "diffHunk": "@@ -0,0 +1,369 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.complete.CompleteEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasItem;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.geography.atlas.items.Point;\n+import org.openstreetmap.atlas.tags.ConstructionDateTag;\n+import org.openstreetmap.atlas.tags.ConstructionTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.RailwayTag;\n+import org.openstreetmap.atlas.tags.annotations.validation.Validators;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * This check is to detect and flag nodes under the three scenarios below: 1) When a railway crosses\n+ * a highway, but intersection node is missing. 2) When railway/highway intersection node exists,\n+ * but railway=level_crossing tag is missing. 3) When tag railway=level_crossing exists, on a node,\n+ * but is lacking of either highway or railway going through the node (osmose 7090), or not on a\n+ * node, instead, on the related way features (osmose 9015)\n+ *\n+ * @author aiannicelli\n+ */\n+public class LevelCrossingOnRailwayCheck extends BaseCheck<Long>\n+{\n+    private static final String RAILWAY_FILTER_DEFAULT = \"railway->rail,tram,disused,preserved,miniature,light_rail,subway,narrow_gauge\";\n+    private final TaggableFilter railwayFilter;\n+    private static final Long OSM_LAYER_DEFAULT = 0L;\n+    private final Long layerDefault;\n+    private static final String INVALID_TAGGED_OBJECT = \"The object (OSM ID: {0,number,#}) has `railway=level_crossing` \"\n+            + \"but is not a node. To fix: Remove `railway=level_crossing` tag.\";\n+    private static final int INVALID_TAGGED_OBJECT_INDEX = 0;\n+    private static final String NODE_MISSING_LC_TAG = \"The intersection node (OSM ID: {0,number,#}) is \"\n+            + \"missing a `railway=level_crossing` tag. This means that there are at least one valid railway and one \"\n+            + \"car navigable highway on the same layer at this node. To fix: If the two ways should be on different \"\n+            + \"layers then adjust the layer tags for each way appropriately. If the two ways do intersect on the same \"\n+            + \"layer then add the `railway=level_crossing` tag to this node.\";\n+    private static final int NODE_MISSING_LC_TAG_INDEX = 1;\n+    private static final String NODE_INVALID_LC_TAG_NO_HIGHWAY = \"The node (OSM ID: {0,number,#}) has \"\n+            + \"`railway=level_crossing` tag, but there is no car navigable highway at this intersection. \"\n+            + \"To fix: Remove railway=level_crossing tag.\";\n+    private static final int NODE_INVALID_LC_TAG_NO_HIGHWAY_INDEX = 2;\n+    private static final String NODE_INVALID_LC_TAG_NO_RAILWAY = \"The node (OSM ID: {0,number,#}) has \"\n+            + \"`railway=level_crossing` tag, but there are no existing rails at this intersection. \"\n+            + \"To fix: Remove railway=level_crossing tag.\";\n+    private static final int NODE_INVALID_LC_TAG_NO_RAILWAY_INDEX = 3;\n+    private static final String NODE_INVALID_LC_TAG_LAYERS = \"The node (OSM ID: {0,number,#}) has `railway=level_crossing` \"\n+            + \"tag, but there are no railway and highway intersection on the same layer. \"\n+            + \"To fix: If the railway and highway should be on the same layer then update the layer tags for both ways \"\n+            + \"to be equal. If the ways are on different layers then remove railway=level_crossing tag.\";\n+    private static final int NODE_INVALID_LC_TAG_LAYERS_INDEX = 4;\n+    private static final String INTERSECTION_MISSING_NODE = \"The railway (OSM ID: {0,number,#}) has one or more car \"\n+            + \"navigable intersections on the same layer that are missing intersection nodes. To fix: \"\n+            + \"If highway and railway do cross at the same layer then add appropriate intersection node(s) with \"\n+            + \"`railway=level_crossing` tag. If highway and railway are on different layers then update the \"\n+            + \"appropriate layer tag for the way that goes under or over the other way.\";\n+    private static final int INTERSECTION_MISSING_NODE_INDEX = 5;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INVALID_TAGGED_OBJECT,\n+            NODE_MISSING_LC_TAG, NODE_INVALID_LC_TAG_NO_HIGHWAY, NODE_INVALID_LC_TAG_NO_RAILWAY,\n+            NODE_INVALID_LC_TAG_LAYERS, INTERSECTION_MISSING_NODE);\n+    private static final List<String> CONSTRUCTION_TAGS = List.of(HighwayTag.KEY, RailwayTag.KEY);\n+    private static final long serialVersionUID = -2063033332877849846L;\n+\n+    /**\n+     * constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public LevelCrossingOnRailwayCheck(final Configuration configuration)\n+    {\n+\n+        super(configuration);\n+        this.layerDefault = this.configurationValue(configuration, \"layer.default\",\n+                OSM_LAYER_DEFAULT);\n+        this.railwayFilter = this.configurationValue(configuration, \"railway.filter\",\n+                RAILWAY_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+    }\n+\n+    /**\n+     * Object check looks for the vaild objects to check for level_crossing tag.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        /*-\n+         * The following objects should be checked:\n+         *  1) Any node.\n+         *  2) Any object that is tagged with railway=level_crossing.\n+         *  3) Any object that is tagged as a railway as indicted in railway.filter.\n+         */\n+        return object instanceof Node\n+                || Validators.isOfType(object, RailwayTag.class, RailwayTag.LEVEL_CROSSING)\n+                || this.railwayFilter.test(object);\n+    }\n+\n+    /**\n+     * Create a Return Flags for level_crossing objects.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that contains flagged issue details\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        /*-\n+         * The following invalid situations are to be flagged:\n+         *  1) object is node and\n+         *     a) is marked as a level crossing but does in not an intersection of highway and railway\n+         *     b) is not tagged as a level crossing and is an intersection of highway and railway.\n+         *  2) object is not a node or point and is tagged with railway=level_crossing.\n+         *  3) object is railway and intersects a highway on the same layer but there is no node.\n+         */\n+\n+        final Optional<CheckFlag> flagIncorrectlyTagged = this.flagIncorrectlyTagged(object);\n+        if (!flagIncorrectlyTagged.isEmpty())\n+        {\n+            return flagIncorrectlyTagged;\n+        }\n+        final Optional<CheckFlag> flagNonNodeTagged = this.flagNonNodeTagged(object);\n+        if (!flagNonNodeTagged.isEmpty())\n+        {\n+            return flagNonNodeTagged;\n+        }\n+        final Optional<CheckFlag> flagInvalidIntersections = this.flagInvalidIntersections(object);\n+        if (!flagInvalidIntersections.isEmpty())\n+        {\n+            return flagInvalidIntersections;\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Flag nodes incorrectly tagged with level_crossing or missing level_crossing tag.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that contains flagged issue details\n+     */\n+    private Optional<CheckFlag> flagIncorrectlyTagged(final AtlasObject object)\n+    {\n+        if (object instanceof Node)\n+        {\n+            final Node node = (Node) object;\n+\n+            final int issueType = this.isValidLevelCrossingNode(node);\n+            if (Validators.isOfType(node, RailwayTag.class, RailwayTag.LEVEL_CROSSING)\n+                    && issueType > 0)\n+            {\n+                // This is a node that is tagged with railway=level_crossing and is not a\n+                // railway/highway intersection\n+                return Optional.of(this\n+                        .createFlag(object,\n+                                this.getLocalizedInstruction(issueType, object.getOsmIdentifier()))\n+                        .addFixSuggestion(FeatureChange.add(\n+                                (AtlasEntity) ((CompleteEntity) CompleteEntity\n+                                        .from((AtlasEntity) object)).withRemovedTag(RailwayTag.KEY),\n+                                object.getAtlas())));\n+            }\n+            if (!Validators.isOfType(node, RailwayTag.class, RailwayTag.LEVEL_CROSSING)\n+                    && issueType == 0)\n+            {\n+                // This is a valid railway/highway intersect node that is not tagged with\n+                // railway=level_crossing\n+                return Optional.of(this\n+                        .createFlag(object,\n+                                this.getLocalizedInstruction(NODE_MISSING_LC_TAG_INDEX,\n+                                        object.getOsmIdentifier()))\n+                        .addFixSuggestion(FeatureChange.add(\n+                                (AtlasEntity) ((CompleteEntity) CompleteEntity\n+                                        .from((AtlasEntity) object)).withAddedTag(RailwayTag.KEY,\n+                                                RailwayTag.LEVEL_CROSSING.toString().toLowerCase()),\n+                                object.getAtlas())));\n+\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Flag all railway/highway intersections that are missing an intersection node\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that contains flagged issue details\n+     */\n+    private Optional<CheckFlag> flagInvalidIntersections(final AtlasObject object)\n+    {\n+        if (object instanceof Line && this.railwayFilter.test(object))\n+        {\n+            final Line railway = (Line) object;\n+            final Atlas atlas = railway.getAtlas();\n+            final List<Location> badIntersectingHighways = new ArrayList<>();\n+\n+            Iterables.asList(atlas.edgesIntersecting(railway.bounds()))\n+                    .forEach(highway -> badIntersectingHighways\n+                            .addAll(this.missingNodesAtIntersectionOnSameLayer(railway, highway)));\n+            if (!badIntersectingHighways.isEmpty())\n+            {\n+                return Optional.of(this.createFlag(object,\n+                        this.getLocalizedInstruction(INTERSECTION_MISSING_NODE_INDEX,\n+                                railway.getOsmIdentifier()),\n+                        badIntersectingHighways));\n+            }\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Flag all objects that are not nodes or points that are tagged with railway=level_crossing\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that contains flagged issue details\n+     */\n+    private Optional<CheckFlag> flagNonNodeTagged(final AtlasObject object)\n+    {\n+        if (!(object instanceof Node || object instanceof Point)", "originalCommit": "08f66b4f3263fd3e51badd50b9f140d728fe54e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU2MjU0OA==", "url": "https://github.com/osmlab/atlas-checks/pull/371#discussion_r514562548", "bodyText": "Done", "author": "atiannicelli", "createdAt": "2020-10-29T20:58:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ2MzU1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ2ODIxMA==", "url": "https://github.com/osmlab/atlas-checks/pull/371#discussion_r514468210", "bodyText": "Please add a some unit tests that use the ConfigurationResolver.inLineConfiguration() to check that the 2 configurables work as expected. And please test that the expected fix suggestions are created.", "author": "Bentleysb", "createdAt": "2020-10-29T18:13:04Z", "path": "src/test/java/org/openstreetmap/atlas/checks/validation/intersections/LevelCrossingOnRailwayCheckTest.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.openstreetmap.atlas.checks.configuration.ConfigurationResolver;\n+import org.openstreetmap.atlas.checks.validation.verifier.ConsumerBasedExpectedCheckVerifier;\n+\n+/**\n+ * Unit tests for {@link LevelCrossingOnRailwayCheck}.\n+ *\n+ * @author atiannicelli\n+ */\n+public class LevelCrossingOnRailwayCheckTest", "originalCommit": "08f66b4f3263fd3e51badd50b9f140d728fe54e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU2MjI4MQ==", "url": "https://github.com/osmlab/atlas-checks/pull/371#discussion_r514562281", "bodyText": "Done. I added two new tests to specifically test the two config parameters. Also added verifications for fix suggestions.", "author": "atiannicelli", "createdAt": "2020-10-29T20:58:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ2ODIxMA=="}], "type": "inlineReview"}, {"oid": "b82641e0bdaba4bb163d601a3ad8eeb8c189fe25", "url": "https://github.com/osmlab/atlas-checks/commit/b82641e0bdaba4bb163d601a3ad8eeb8c189fe25", "message": "Fix PR review requested changes", "committedDate": "2020-10-29T20:56:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAzMDI0Nw==", "url": "https://github.com/osmlab/atlas-checks/pull/371#discussion_r517030247", "bodyText": "nit: issueType could be better served as an Enum to avoid referencing docs for explanation", "author": "seancoulter", "createdAt": "2020-11-04T00:20:20Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LevelCrossingOnRailwayCheck.java", "diffHunk": "@@ -0,0 +1,369 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.complete.CompleteEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasItem;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.ConstructionDateTag;\n+import org.openstreetmap.atlas.tags.ConstructionTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.RailwayTag;\n+import org.openstreetmap.atlas.tags.annotations.validation.Validators;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * This check is to detect and flag nodes under the three scenarios below: 1) When a railway crosses\n+ * a highway, but intersection node is missing. 2) When railway/highway intersection node exists,\n+ * but railway=level_crossing tag is missing. 3) When tag railway=level_crossing exists, on a node,\n+ * but is lacking of either highway or railway going through the node (osmose 7090), or not on a\n+ * node, instead, on the related way features (osmose 9015)\n+ *\n+ * @author aiannicelli\n+ */\n+public class LevelCrossingOnRailwayCheck extends BaseCheck<Long>\n+{\n+    private static final String RAILWAY_FILTER_DEFAULT = \"railway->rail,tram,disused,preserved,miniature,light_rail,subway,narrow_gauge\";\n+    private final TaggableFilter railwayFilter;\n+    private static final Long OSM_LAYER_DEFAULT = 0L;\n+    private final Long layerDefault;\n+    private static final String INVALID_TAGGED_OBJECT = \"The object (OSM ID: {0,number,#}) has `railway=level_crossing` \"\n+            + \"but is not a node. To fix: Remove `railway=level_crossing` tag.\";\n+    private static final int INVALID_TAGGED_OBJECT_INDEX = 0;\n+    private static final String NODE_MISSING_LC_TAG = \"The intersection node (OSM ID: {0,number,#}) is \"\n+            + \"missing a `railway=level_crossing` tag. This means that there are at least one valid railway and one \"\n+            + \"car navigable highway on the same layer at this node. To fix: If the two ways should be on different \"\n+            + \"layers then adjust the layer tags for each way appropriately. If the two ways do intersect on the same \"\n+            + \"layer then add the `railway=level_crossing` tag to this node.\";\n+    private static final int NODE_MISSING_LC_TAG_INDEX = 1;\n+    private static final String NODE_INVALID_LC_TAG_NO_HIGHWAY = \"The node (OSM ID: {0,number,#}) has \"\n+            + \"`railway=level_crossing` tag, but there is no car navigable highway at this intersection. \"\n+            + \"To fix: Remove railway=level_crossing tag.\";\n+    private static final int NODE_INVALID_LC_TAG_NO_HIGHWAY_INDEX = 2;\n+    private static final String NODE_INVALID_LC_TAG_NO_RAILWAY = \"The node (OSM ID: {0,number,#}) has \"\n+            + \"`railway=level_crossing` tag, but there are no existing rails at this intersection. \"\n+            + \"To fix: Remove railway=level_crossing tag.\";\n+    private static final int NODE_INVALID_LC_TAG_NO_RAILWAY_INDEX = 3;\n+    private static final String NODE_INVALID_LC_TAG_LAYERS = \"The node (OSM ID: {0,number,#}) has `railway=level_crossing` \"\n+            + \"tag, but there are no railway and highway intersection on the same layer. \"\n+            + \"To fix: If the railway and highway should be on the same layer then update the layer tags for both ways \"\n+            + \"to be equal. If the ways are on different layers then remove railway=level_crossing tag.\";\n+    private static final int NODE_INVALID_LC_TAG_LAYERS_INDEX = 4;\n+    private static final String INTERSECTION_MISSING_NODE = \"The railway (OSM ID: {0,number,#}) has one or more car \"\n+            + \"navigable intersections on the same layer that are missing intersection nodes. To fix: \"\n+            + \"If highway and railway do cross at the same layer then add appropriate intersection node(s) with \"\n+            + \"`railway=level_crossing` tag. If highway and railway are on different layers then update the \"\n+            + \"appropriate layer tag for the way that goes under or over the other way.\";\n+    private static final int INTERSECTION_MISSING_NODE_INDEX = 5;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INVALID_TAGGED_OBJECT,\n+            NODE_MISSING_LC_TAG, NODE_INVALID_LC_TAG_NO_HIGHWAY, NODE_INVALID_LC_TAG_NO_RAILWAY,\n+            NODE_INVALID_LC_TAG_LAYERS, INTERSECTION_MISSING_NODE);\n+    private static final List<String> CONSTRUCTION_TAGS = List.of(HighwayTag.KEY, RailwayTag.KEY);\n+    private static final long serialVersionUID = -2063033332877849846L;\n+\n+    /**\n+     * constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public LevelCrossingOnRailwayCheck(final Configuration configuration)\n+    {\n+\n+        super(configuration);\n+        this.layerDefault = this.configurationValue(configuration, \"layer.default\",\n+                OSM_LAYER_DEFAULT);\n+        this.railwayFilter = this.configurationValue(configuration, \"railway.filter\",\n+                RAILWAY_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+    }\n+\n+    /**\n+     * Object check looks for the vaild objects to check for level_crossing tag.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        /*-\n+         * The following objects should be checked:\n+         *  1) Any node.\n+         *  2) Any object that is tagged with railway=level_crossing.\n+         *  3) Any object that is tagged as a railway as indicted in railway.filter.\n+         */\n+        return object instanceof Node\n+                || Validators.isOfType(object, RailwayTag.class, RailwayTag.LEVEL_CROSSING)\n+                || this.railwayFilter.test(object);\n+    }\n+\n+    /**\n+     * Create a Return Flags for level_crossing objects.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that contains flagged issue details\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        /*-\n+         * The following invalid situations are to be flagged:\n+         *  1) object is node and\n+         *     a) is marked as a level crossing but does in not an intersection of highway and railway\n+         *     b) is not tagged as a level crossing and is an intersection of highway and railway.\n+         *  2) object is not a node or point and is tagged with railway=level_crossing.\n+         *  3) object is railway and intersects a highway on the same layer but there is no node.\n+         */\n+\n+        final Optional<CheckFlag> flagIncorrectlyTagged = this.flagIncorrectlyTagged(object);\n+        if (!flagIncorrectlyTagged.isEmpty())\n+        {\n+            return flagIncorrectlyTagged;\n+        }\n+        final Optional<CheckFlag> flagNonNodeTagged = this.flagNonNodeTagged(object);\n+        if (!flagNonNodeTagged.isEmpty())\n+        {\n+            return flagNonNodeTagged;\n+        }\n+        final Optional<CheckFlag> flagInvalidIntersections = this.flagInvalidIntersections(object);\n+        if (!flagInvalidIntersections.isEmpty())\n+        {\n+            return flagInvalidIntersections;\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Flag nodes incorrectly tagged with level_crossing or missing level_crossing tag.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that contains flagged issue details\n+     */\n+    private Optional<CheckFlag> flagIncorrectlyTagged(final AtlasObject object)\n+    {\n+        if (object instanceof Node)\n+        {\n+            final Node node = (Node) object;\n+\n+            final int issueType = this.isValidLevelCrossingNode(node);\n+            if (Validators.isOfType(node, RailwayTag.class, RailwayTag.LEVEL_CROSSING)\n+                    && issueType > 0)", "originalCommit": "b82641e0bdaba4bb163d601a3ad8eeb8c189fe25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQwODI1Ng==", "url": "https://github.com/osmlab/atlas-checks/pull/371#discussion_r517408256", "bodyText": "Addressed in latest version.", "author": "atiannicelli", "createdAt": "2020-11-04T15:02:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAzMDI0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAzMDY2Ng==", "url": "https://github.com/osmlab/atlas-checks/pull/371#discussion_r517030666", "bodyText": "just a thought. could the railway tag just have the wrong value, but the feature is still a legitimate \"railway\"? in which case we may want to not send up a fix suggestion", "author": "seancoulter", "createdAt": "2020-11-04T00:21:50Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/intersections/LevelCrossingOnRailwayCheck.java", "diffHunk": "@@ -0,0 +1,369 @@\n+package org.openstreetmap.atlas.checks.validation.intersections;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.Location;\n+import org.openstreetmap.atlas.geography.atlas.Atlas;\n+import org.openstreetmap.atlas.geography.atlas.change.FeatureChange;\n+import org.openstreetmap.atlas.geography.atlas.complete.CompleteEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasEntity;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasItem;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.items.Line;\n+import org.openstreetmap.atlas.geography.atlas.items.LocationItem;\n+import org.openstreetmap.atlas.geography.atlas.items.Node;\n+import org.openstreetmap.atlas.tags.ConstructionDateTag;\n+import org.openstreetmap.atlas.tags.ConstructionTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.LayerTag;\n+import org.openstreetmap.atlas.tags.RailwayTag;\n+import org.openstreetmap.atlas.tags.annotations.validation.Validators;\n+import org.openstreetmap.atlas.tags.filters.TaggableFilter;\n+import org.openstreetmap.atlas.utilities.collections.Iterables;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * This check is to detect and flag nodes under the three scenarios below: 1) When a railway crosses\n+ * a highway, but intersection node is missing. 2) When railway/highway intersection node exists,\n+ * but railway=level_crossing tag is missing. 3) When tag railway=level_crossing exists, on a node,\n+ * but is lacking of either highway or railway going through the node (osmose 7090), or not on a\n+ * node, instead, on the related way features (osmose 9015)\n+ *\n+ * @author aiannicelli\n+ */\n+public class LevelCrossingOnRailwayCheck extends BaseCheck<Long>\n+{\n+    private static final String RAILWAY_FILTER_DEFAULT = \"railway->rail,tram,disused,preserved,miniature,light_rail,subway,narrow_gauge\";\n+    private final TaggableFilter railwayFilter;\n+    private static final Long OSM_LAYER_DEFAULT = 0L;\n+    private final Long layerDefault;\n+    private static final String INVALID_TAGGED_OBJECT = \"The object (OSM ID: {0,number,#}) has `railway=level_crossing` \"\n+            + \"but is not a node. To fix: Remove `railway=level_crossing` tag.\";\n+    private static final int INVALID_TAGGED_OBJECT_INDEX = 0;\n+    private static final String NODE_MISSING_LC_TAG = \"The intersection node (OSM ID: {0,number,#}) is \"\n+            + \"missing a `railway=level_crossing` tag. This means that there are at least one valid railway and one \"\n+            + \"car navigable highway on the same layer at this node. To fix: If the two ways should be on different \"\n+            + \"layers then adjust the layer tags for each way appropriately. If the two ways do intersect on the same \"\n+            + \"layer then add the `railway=level_crossing` tag to this node.\";\n+    private static final int NODE_MISSING_LC_TAG_INDEX = 1;\n+    private static final String NODE_INVALID_LC_TAG_NO_HIGHWAY = \"The node (OSM ID: {0,number,#}) has \"\n+            + \"`railway=level_crossing` tag, but there is no car navigable highway at this intersection. \"\n+            + \"To fix: Remove railway=level_crossing tag.\";\n+    private static final int NODE_INVALID_LC_TAG_NO_HIGHWAY_INDEX = 2;\n+    private static final String NODE_INVALID_LC_TAG_NO_RAILWAY = \"The node (OSM ID: {0,number,#}) has \"\n+            + \"`railway=level_crossing` tag, but there are no existing rails at this intersection. \"\n+            + \"To fix: Remove railway=level_crossing tag.\";\n+    private static final int NODE_INVALID_LC_TAG_NO_RAILWAY_INDEX = 3;\n+    private static final String NODE_INVALID_LC_TAG_LAYERS = \"The node (OSM ID: {0,number,#}) has `railway=level_crossing` \"\n+            + \"tag, but there are no railway and highway intersection on the same layer. \"\n+            + \"To fix: If the railway and highway should be on the same layer then update the layer tags for both ways \"\n+            + \"to be equal. If the ways are on different layers then remove railway=level_crossing tag.\";\n+    private static final int NODE_INVALID_LC_TAG_LAYERS_INDEX = 4;\n+    private static final String INTERSECTION_MISSING_NODE = \"The railway (OSM ID: {0,number,#}) has one or more car \"\n+            + \"navigable intersections on the same layer that are missing intersection nodes. To fix: \"\n+            + \"If highway and railway do cross at the same layer then add appropriate intersection node(s) with \"\n+            + \"`railway=level_crossing` tag. If highway and railway are on different layers then update the \"\n+            + \"appropriate layer tag for the way that goes under or over the other way.\";\n+    private static final int INTERSECTION_MISSING_NODE_INDEX = 5;\n+\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(INVALID_TAGGED_OBJECT,\n+            NODE_MISSING_LC_TAG, NODE_INVALID_LC_TAG_NO_HIGHWAY, NODE_INVALID_LC_TAG_NO_RAILWAY,\n+            NODE_INVALID_LC_TAG_LAYERS, INTERSECTION_MISSING_NODE);\n+    private static final List<String> CONSTRUCTION_TAGS = List.of(HighwayTag.KEY, RailwayTag.KEY);\n+    private static final long serialVersionUID = -2063033332877849846L;\n+\n+    /**\n+     * constructor\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public LevelCrossingOnRailwayCheck(final Configuration configuration)\n+    {\n+\n+        super(configuration);\n+        this.layerDefault = this.configurationValue(configuration, \"layer.default\",\n+                OSM_LAYER_DEFAULT);\n+        this.railwayFilter = this.configurationValue(configuration, \"railway.filter\",\n+                RAILWAY_FILTER_DEFAULT, TaggableFilter::forDefinition);\n+    }\n+\n+    /**\n+     * Object check looks for the vaild objects to check for level_crossing tag.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        /*-\n+         * The following objects should be checked:\n+         *  1) Any node.\n+         *  2) Any object that is tagged with railway=level_crossing.\n+         *  3) Any object that is tagged as a railway as indicted in railway.filter.\n+         */\n+        return object instanceof Node\n+                || Validators.isOfType(object, RailwayTag.class, RailwayTag.LEVEL_CROSSING)\n+                || this.railwayFilter.test(object);\n+    }\n+\n+    /**\n+     * Create a Return Flags for level_crossing objects.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that contains flagged issue details\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        /*-\n+         * The following invalid situations are to be flagged:\n+         *  1) object is node and\n+         *     a) is marked as a level crossing but does in not an intersection of highway and railway\n+         *     b) is not tagged as a level crossing and is an intersection of highway and railway.\n+         *  2) object is not a node or point and is tagged with railway=level_crossing.\n+         *  3) object is railway and intersects a highway on the same layer but there is no node.\n+         */\n+\n+        final Optional<CheckFlag> flagIncorrectlyTagged = this.flagIncorrectlyTagged(object);\n+        if (!flagIncorrectlyTagged.isEmpty())\n+        {\n+            return flagIncorrectlyTagged;\n+        }\n+        final Optional<CheckFlag> flagNonNodeTagged = this.flagNonNodeTagged(object);\n+        if (!flagNonNodeTagged.isEmpty())\n+        {\n+            return flagNonNodeTagged;\n+        }\n+        final Optional<CheckFlag> flagInvalidIntersections = this.flagInvalidIntersections(object);\n+        if (!flagInvalidIntersections.isEmpty())\n+        {\n+            return flagInvalidIntersections;\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Flag nodes incorrectly tagged with level_crossing or missing level_crossing tag.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that contains flagged issue details\n+     */\n+    private Optional<CheckFlag> flagIncorrectlyTagged(final AtlasObject object)\n+    {\n+        if (object instanceof Node)\n+        {\n+            final Node node = (Node) object;\n+\n+            final int issueType = this.isValidLevelCrossingNode(node);\n+            if (Validators.isOfType(node, RailwayTag.class, RailwayTag.LEVEL_CROSSING)\n+                    && issueType > 0)\n+            {\n+                // This is a node that is tagged with railway=level_crossing and is not a\n+                // railway/highway intersection\n+                return Optional.of(this\n+                        .createFlag(object,\n+                                this.getLocalizedInstruction(issueType, object.getOsmIdentifier()))\n+                        .addFixSuggestion(FeatureChange.add(\n+                                (AtlasEntity) ((CompleteEntity) CompleteEntity\n+                                        .from((AtlasEntity) object)).withRemovedTag(RailwayTag.KEY),", "originalCommit": "b82641e0bdaba4bb163d601a3ad8eeb8c189fe25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM3NDUxNg==", "url": "https://github.com/osmlab/atlas-checks/pull/371#discussion_r517374516", "bodyText": "In this check the feature is a node, so it is not a rail way. There are valid \"railway\" tags for nodes, but this specific check is determining that the \"level_crossing\" value is not correct. I guess there could be some other valid key value for this node, but I'm not sure how to determine that. Are you saying that you don't want a fix suggestion associated with this flagged issue?", "author": "atiannicelli", "createdAt": "2020-11-04T14:16:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAzMDY2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU1MDk1OQ==", "url": "https://github.com/osmlab/atlas-checks/pull/371#discussion_r517550959", "bodyText": "Yeah after thinking about this for a bit we could still send up the fix suggestion. My only concern was that the editor might want to change the Railway tag value to something more appropriate if applicable, instead of deleting the tag,  but they have the ability to do that by just not applying the fix suggestion", "author": "seancoulter", "createdAt": "2020-11-04T18:34:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAzMDY2Ng=="}], "type": "inlineReview"}, {"oid": "0b2631841aaf9ee775646651e095d496b937a329", "url": "https://github.com/osmlab/atlas-checks/commit/0b2631841aaf9ee775646651e095d496b937a329", "message": "Add enum for isValidLevelCrossingNode function", "committedDate": "2020-11-04T15:01:43Z", "type": "commit"}]}