{"pr_number": 358, "pr_title": "Construction check", "pr_createdAt": "2020-09-08T21:27:06Z", "pr_url": "https://github.com/osmlab/atlas-checks/pull/358", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNzk2Mw==", "url": "https://github.com/osmlab/atlas-checks/pull/358#discussion_r490417963", "bodyText": "It would be great if these could be added as tag classed here.", "author": "Bentleysb", "createdAt": "2020-09-17T16:59:59Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/ConstructionCheck.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.Year;\n+import java.time.YearMonth;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * The purpose of this check is to identify construction tags where the construction hasn't been\n+ * checked on recently, or the expected finish date has been passed.\n+ *\n+ * @author v-brjor\n+ */\n+public class ConstructionCheck extends BaseCheck<Long>\n+{\n+    private static final long serialVersionUID = -5857500094506755337L;\n+    private static final double OLD_CONSTRUCTION_DAYS_DEFAULT = (double) 365 * 2;\n+    private static final double OLD_CHECK_DATE_MONTHS_DEFAULT = 6;\n+    private static final String CONSTRUCTION_PASSED_DATE = \"The {0} tag has been exceeded. If the construction is still ongoing please update the date with a new completion date from an official source. Otherwise please modify this to be a completed feature\";\n+    private static final String CONSTRUCTION_CHECK_DATE_OLD = \"It has been more than {0} months since this construction was last checked. If this is still under construction please update the check_date tag. Otherwise please modify this to be a completed feature.\";\n+    private static final String CONSTRUCTION_LAST_EDITED_OLD = \"This feature has had a construction tag, with no updates, for more than {0} days. If this is still under construction please update the check_date tag. Otherwise please modify this to be a completed feature.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            CONSTRUCTION_PASSED_DATE, CONSTRUCTION_CHECK_DATE_OLD, CONSTRUCTION_LAST_EDITED_OLD);\n+    private static final List<DateTimeFormatter> YEAR_FORMATTERS = Collections.singletonList(\n+            // 2020\n+            DateTimeFormatter.ofPattern(\"yyyy\"));\n+    private static final List<DateTimeFormatter> YEAR_MONTH_FORMATTERS = Arrays.asList(\n+            // 2020-1\n+            DateTimeFormatter.ofPattern(\"yyyy-M\"),\n+            // 1-2020\n+            DateTimeFormatter.ofPattern(\"M-yyyy\"),\n+            // Jan-2020\n+            DateTimeFormatter.ofPattern(\"MMM-yyyy\"),\n+            // January 2020\n+            DateTimeFormatter.ofPattern(\"MMMM yyyy\"));\n+    private static final List<DateTimeFormatter> FULL_DATE_FORMATTERS = Arrays.asList(\n+            // 2020-1-1\n+            DateTimeFormatter.ofPattern(\"yyyy-M-d\"),\n+            // 1-1-2020\n+            DateTimeFormatter.ofPattern(\"d-M-yyyy\"),\n+            // 1-Jan-2020\n+            DateTimeFormatter.ofPattern(\"d-MMM-yyyy\"),\n+            // 1 January 2020\n+            DateTimeFormatter.ofPattern(\"d MMMM yyyy\"));\n+    private static final LocalDate TODAYS_DATE = LocalDate.now();\n+    private static final List<String> DATE_TAGS = Arrays.asList(\"opening_date\", \"open_date\",", "originalCommit": "df92d3f84c988f2cdebd96e0c8fe348e470e96d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzNDA5Ng==", "url": "https://github.com/osmlab/atlas-checks/pull/358#discussion_r491034096", "bodyText": "Waiting on this: osmlab/atlas#679", "author": "brianjor", "createdAt": "2020-09-18T15:41:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNzk2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM0NDQwMw==", "url": "https://github.com/osmlab/atlas-checks/pull/358#discussion_r498344403", "bodyText": "I didn't add \"date_on\" because it has no mention of it in the OSM wiki, should it still be included?", "author": "brianjor", "createdAt": "2020-10-01T15:43:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNzk2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMjcwNA==", "url": "https://github.com/osmlab/atlas-checks/pull/358#discussion_r490422704", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final List<String> CONSTRUCTION_TAGS = List.of(\"highway\", \"landuse\", \"building\");\n          \n          \n            \n                private static final List<String> CONSTRUCTION_TAGS = List.of(HighwayTag.KEY.toString(), LandUseTag.KEY.toString(), BuildingTag.KEY.toString());", "author": "Bentleysb", "createdAt": "2020-09-17T17:07:55Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/ConstructionCheck.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.Year;\n+import java.time.YearMonth;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * The purpose of this check is to identify construction tags where the construction hasn't been\n+ * checked on recently, or the expected finish date has been passed.\n+ *\n+ * @author v-brjor\n+ */\n+public class ConstructionCheck extends BaseCheck<Long>\n+{\n+    private static final long serialVersionUID = -5857500094506755337L;\n+    private static final double OLD_CONSTRUCTION_DAYS_DEFAULT = (double) 365 * 2;\n+    private static final double OLD_CHECK_DATE_MONTHS_DEFAULT = 6;\n+    private static final String CONSTRUCTION_PASSED_DATE = \"The {0} tag has been exceeded. If the construction is still ongoing please update the date with a new completion date from an official source. Otherwise please modify this to be a completed feature\";\n+    private static final String CONSTRUCTION_CHECK_DATE_OLD = \"It has been more than {0} months since this construction was last checked. If this is still under construction please update the check_date tag. Otherwise please modify this to be a completed feature.\";\n+    private static final String CONSTRUCTION_LAST_EDITED_OLD = \"This feature has had a construction tag, with no updates, for more than {0} days. If this is still under construction please update the check_date tag. Otherwise please modify this to be a completed feature.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            CONSTRUCTION_PASSED_DATE, CONSTRUCTION_CHECK_DATE_OLD, CONSTRUCTION_LAST_EDITED_OLD);\n+    private static final List<DateTimeFormatter> YEAR_FORMATTERS = Collections.singletonList(\n+            // 2020\n+            DateTimeFormatter.ofPattern(\"yyyy\"));\n+    private static final List<DateTimeFormatter> YEAR_MONTH_FORMATTERS = Arrays.asList(\n+            // 2020-1\n+            DateTimeFormatter.ofPattern(\"yyyy-M\"),\n+            // 1-2020\n+            DateTimeFormatter.ofPattern(\"M-yyyy\"),\n+            // Jan-2020\n+            DateTimeFormatter.ofPattern(\"MMM-yyyy\"),\n+            // January 2020\n+            DateTimeFormatter.ofPattern(\"MMMM yyyy\"));\n+    private static final List<DateTimeFormatter> FULL_DATE_FORMATTERS = Arrays.asList(\n+            // 2020-1-1\n+            DateTimeFormatter.ofPattern(\"yyyy-M-d\"),\n+            // 1-1-2020\n+            DateTimeFormatter.ofPattern(\"d-M-yyyy\"),\n+            // 1-Jan-2020\n+            DateTimeFormatter.ofPattern(\"d-MMM-yyyy\"),\n+            // 1 January 2020\n+            DateTimeFormatter.ofPattern(\"d MMMM yyyy\"));\n+    private static final LocalDate TODAYS_DATE = LocalDate.now();\n+    private static final List<String> DATE_TAGS = Arrays.asList(\"opening_date\", \"open_date\",\n+            \"construction:date\", \"temporary:date_on\", \"date_on\");\n+    private static final List<String> CONSTRUCTION_TAGS = List.of(\"highway\", \"landuse\", \"building\");", "originalCommit": "df92d3f84c988f2cdebd96e0c8fe348e470e96d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyNDUzOA==", "url": "https://github.com/osmlab/atlas-checks/pull/358#discussion_r490424538", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .anyMatch(tag -> tag.equals(\"construction\")\n          \n          \n            \n                            .anyMatch(tag -> tag.equals(ConstructionTag.KEY.toString())\n          \n      \n    \n    \n  \n\nor if you pass in the atlas object:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .anyMatch(tag -> tag.equals(\"construction\")\n          \n          \n            \n                            .anyMatch(tag -> Validators.hasValueFor(object, ConstructionTag.class)", "author": "Bentleysb", "createdAt": "2020-09-17T17:11:08Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/ConstructionCheck.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.Year;\n+import java.time.YearMonth;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * The purpose of this check is to identify construction tags where the construction hasn't been\n+ * checked on recently, or the expected finish date has been passed.\n+ *\n+ * @author v-brjor\n+ */\n+public class ConstructionCheck extends BaseCheck<Long>\n+{\n+    private static final long serialVersionUID = -5857500094506755337L;\n+    private static final double OLD_CONSTRUCTION_DAYS_DEFAULT = (double) 365 * 2;\n+    private static final double OLD_CHECK_DATE_MONTHS_DEFAULT = 6;\n+    private static final String CONSTRUCTION_PASSED_DATE = \"The {0} tag has been exceeded. If the construction is still ongoing please update the date with a new completion date from an official source. Otherwise please modify this to be a completed feature\";\n+    private static final String CONSTRUCTION_CHECK_DATE_OLD = \"It has been more than {0} months since this construction was last checked. If this is still under construction please update the check_date tag. Otherwise please modify this to be a completed feature.\";\n+    private static final String CONSTRUCTION_LAST_EDITED_OLD = \"This feature has had a construction tag, with no updates, for more than {0} days. If this is still under construction please update the check_date tag. Otherwise please modify this to be a completed feature.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            CONSTRUCTION_PASSED_DATE, CONSTRUCTION_CHECK_DATE_OLD, CONSTRUCTION_LAST_EDITED_OLD);\n+    private static final List<DateTimeFormatter> YEAR_FORMATTERS = Collections.singletonList(\n+            // 2020\n+            DateTimeFormatter.ofPattern(\"yyyy\"));\n+    private static final List<DateTimeFormatter> YEAR_MONTH_FORMATTERS = Arrays.asList(\n+            // 2020-1\n+            DateTimeFormatter.ofPattern(\"yyyy-M\"),\n+            // 1-2020\n+            DateTimeFormatter.ofPattern(\"M-yyyy\"),\n+            // Jan-2020\n+            DateTimeFormatter.ofPattern(\"MMM-yyyy\"),\n+            // January 2020\n+            DateTimeFormatter.ofPattern(\"MMMM yyyy\"));\n+    private static final List<DateTimeFormatter> FULL_DATE_FORMATTERS = Arrays.asList(\n+            // 2020-1-1\n+            DateTimeFormatter.ofPattern(\"yyyy-M-d\"),\n+            // 1-1-2020\n+            DateTimeFormatter.ofPattern(\"d-M-yyyy\"),\n+            // 1-Jan-2020\n+            DateTimeFormatter.ofPattern(\"d-MMM-yyyy\"),\n+            // 1 January 2020\n+            DateTimeFormatter.ofPattern(\"d MMMM yyyy\"));\n+    private static final LocalDate TODAYS_DATE = LocalDate.now();\n+    private static final List<String> DATE_TAGS = Arrays.asList(\"opening_date\", \"open_date\",\n+            \"construction:date\", \"temporary:date_on\", \"date_on\");\n+    private static final List<String> CONSTRUCTION_TAGS = List.of(\"highway\", \"landuse\", \"building\");\n+\n+    private final int oldConstructionDays;\n+    private final int oldCheckDateMonths;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public ConstructionCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.oldConstructionDays = this.configurationValue(configuration, \"oldConstructionDays\",\n+                OLD_CONSTRUCTION_DAYS_DEFAULT, Double::intValue);\n+        this.oldCheckDateMonths = this.configurationValue(configuration, \"oldCheckDateMonth\",\n+                OLD_CHECK_DATE_MONTHS_DEFAULT, Double::intValue);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        final Map<String, String> keySet = object.getOsmTags();\n+        return !this.isFlagged(object.getOsmIdentifier()) && isConstruction(keySet);\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        this.markAsFlagged(object.getOsmIdentifier());\n+\n+        final Map<String, String> tags = object.getTags();\n+\n+        final Optional<String> dateTag = getDateTag(tags);\n+        if (dateTag.isPresent())\n+        {\n+            final String tagDate = tags.get(dateTag.get());\n+\n+            final Optional<LocalDate> parsedDate = parseDate(tagDate);\n+            if (parsedDate.isPresent() && parsedDate.get().isBefore(TODAYS_DATE))\n+            {\n+                return Optional\n+                        .of(createFlag(object, this.getLocalizedInstruction(0, dateTag.get())));\n+            }\n+        }\n+\n+        if (tags.containsKey(\"check_date\"))\n+        {\n+            final Optional<LocalDate> parseDateChecked = parseDate(tags.get(\"check_date\"));\n+            if (parseDateChecked.isPresent())\n+            {\n+                final long monthsBetween = ChronoUnit.MONTHS.between(parseDateChecked.get(),\n+                        TODAYS_DATE);\n+                if (monthsBetween > this.oldCheckDateMonths)\n+                {\n+                    return Optional.of(createFlag(object,\n+                            this.getLocalizedInstruction(1, this.oldCheckDateMonths)));\n+                }\n+            }\n+        }\n+\n+        if (tags.containsKey(\"last_edit_time\"))\n+        {\n+            final long timestamp = Long.parseLong(tags.get(\"last_edit_time\"));\n+            final LocalDate lastEditDate = Instant.ofEpochMilli(timestamp)\n+                    .atZone(ZoneId.systemDefault()).toLocalDate();\n+\n+            final long numberOfDays = ChronoUnit.DAYS.between(lastEditDate, TODAYS_DATE);\n+            if (numberOfDays > this.oldConstructionDays)\n+            {\n+                return Optional.of(createFlag(object,\n+                        this.getLocalizedInstruction(2, this.oldConstructionDays)));\n+            }\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Gets the tag that holds a date.\n+     *\n+     * @param keySet\n+     *            Tags from the object.\n+     * @return a tag that is considered a date for construction.\n+     */\n+    private Optional<String> getDateTag(final Map<String, String> keySet)\n+    {\n+        return DATE_TAGS.stream().filter(keySet::containsKey).findFirst();\n+    }\n+\n+    /**\n+     * Checks if the tags of an object signify it as being under construction.\n+     *\n+     * @param tags\n+     *            Tags from the object\n+     * @return true if the object is under construction, otherwise false\n+     */\n+    private boolean isConstruction(final Map<String, String> tags)\n+    {\n+        return tags.keySet().stream()\n+                .anyMatch(tag -> tag.equals(\"construction\")", "originalCommit": "df92d3f84c988f2cdebd96e0c8fe348e470e96d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyNzM4NQ==", "url": "https://github.com/osmlab/atlas-checks/pull/358#discussion_r490427385", "bodyText": "If the object is an Edge we will want to flag all the master edges with the same OSM ID (see InvalidTagsCheck for an example).", "author": "Bentleysb", "createdAt": "2020-09-17T17:16:04Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/ConstructionCheck.java", "diffHunk": "@@ -0,0 +1,234 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.Year;\n+import java.time.YearMonth;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * The purpose of this check is to identify construction tags where the construction hasn't been\n+ * checked on recently, or the expected finish date has been passed.\n+ *\n+ * @author v-brjor\n+ */\n+public class ConstructionCheck extends BaseCheck<Long>\n+{\n+    private static final long serialVersionUID = -5857500094506755337L;\n+    private static final double OLD_CONSTRUCTION_DAYS_DEFAULT = (double) 365 * 2;\n+    private static final double OLD_CHECK_DATE_MONTHS_DEFAULT = 6;\n+    private static final String CONSTRUCTION_PASSED_DATE = \"The {0} tag has been exceeded. If the construction is still ongoing please update the date with a new completion date from an official source. Otherwise please modify this to be a completed feature\";\n+    private static final String CONSTRUCTION_CHECK_DATE_OLD = \"It has been more than {0} months since this construction was last checked. If this is still under construction please update the check_date tag. Otherwise please modify this to be a completed feature.\";\n+    private static final String CONSTRUCTION_LAST_EDITED_OLD = \"This feature has had a construction tag, with no updates, for more than {0} days. If this is still under construction please update the check_date tag. Otherwise please modify this to be a completed feature.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            CONSTRUCTION_PASSED_DATE, CONSTRUCTION_CHECK_DATE_OLD, CONSTRUCTION_LAST_EDITED_OLD);\n+    private static final List<DateTimeFormatter> YEAR_FORMATTERS = Collections.singletonList(\n+            // 2020\n+            DateTimeFormatter.ofPattern(\"yyyy\"));\n+    private static final List<DateTimeFormatter> YEAR_MONTH_FORMATTERS = Arrays.asList(\n+            // 2020-1\n+            DateTimeFormatter.ofPattern(\"yyyy-M\"),\n+            // 1-2020\n+            DateTimeFormatter.ofPattern(\"M-yyyy\"),\n+            // Jan-2020\n+            DateTimeFormatter.ofPattern(\"MMM-yyyy\"),\n+            // January 2020\n+            DateTimeFormatter.ofPattern(\"MMMM yyyy\"));\n+    private static final List<DateTimeFormatter> FULL_DATE_FORMATTERS = Arrays.asList(\n+            // 2020-1-1\n+            DateTimeFormatter.ofPattern(\"yyyy-M-d\"),\n+            // 1-1-2020\n+            DateTimeFormatter.ofPattern(\"d-M-yyyy\"),\n+            // 1-Jan-2020\n+            DateTimeFormatter.ofPattern(\"d-MMM-yyyy\"),\n+            // 1 January 2020\n+            DateTimeFormatter.ofPattern(\"d MMMM yyyy\"));\n+    private static final LocalDate TODAYS_DATE = LocalDate.now();\n+    private static final List<String> DATE_TAGS = Arrays.asList(\"opening_date\", \"open_date\",\n+            \"construction:date\", \"temporary:date_on\", \"date_on\");\n+    private static final List<String> CONSTRUCTION_TAGS = List.of(\"highway\", \"landuse\", \"building\");\n+\n+    private final int oldConstructionDays;\n+    private final int oldCheckDateMonths;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public ConstructionCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.oldConstructionDays = this.configurationValue(configuration, \"oldConstructionDays\",\n+                OLD_CONSTRUCTION_DAYS_DEFAULT, Double::intValue);\n+        this.oldCheckDateMonths = this.configurationValue(configuration, \"oldCheckDateMonth\",\n+                OLD_CHECK_DATE_MONTHS_DEFAULT, Double::intValue);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        final Map<String, String> keySet = object.getOsmTags();\n+        return !this.isFlagged(object.getOsmIdentifier()) && isConstruction(keySet);\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        this.markAsFlagged(object.getOsmIdentifier());\n+\n+        final Map<String, String> tags = object.getTags();\n+\n+        final Optional<String> dateTag = getDateTag(tags);\n+        if (dateTag.isPresent())\n+        {\n+            final String tagDate = tags.get(dateTag.get());\n+\n+            final Optional<LocalDate> parsedDate = parseDate(tagDate);\n+            if (parsedDate.isPresent() && parsedDate.get().isBefore(TODAYS_DATE))\n+            {\n+                return Optional\n+                        .of(createFlag(object, this.getLocalizedInstruction(0, dateTag.get())));", "originalCommit": "df92d3f84c988f2cdebd96e0c8fe348e470e96d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c9e36b3ff230fadf02ae86557ef28c2aa0c1e9b1", "url": "https://github.com/osmlab/atlas-checks/commit/c9e36b3ff230fadf02ae86557ef28c2aa0c1e9b1", "message": "initial check", "committedDate": "2020-09-25T19:15:31Z", "type": "commit"}, {"oid": "37303e319be59d21173930e6ef9978dffa5bbf53", "url": "https://github.com/osmlab/atlas-checks/commit/37303e319be59d21173930e6ef9978dffa5bbf53", "message": "First good run", "committedDate": "2020-09-25T19:15:31Z", "type": "commit"}, {"oid": "7718f67499d9676e14ecdd7d39b07d264c14bf50", "url": "https://github.com/osmlab/atlas-checks/commit/7718f67499d9676e14ecdd7d39b07d264c14bf50", "message": "Cleaner looking date parsing", "committedDate": "2020-09-25T19:15:31Z", "type": "commit"}, {"oid": "6f42c6df6b86249bb8c0ad68f469a3a591b6d38e", "url": "https://github.com/osmlab/atlas-checks/commit/6f42c6df6b86249bb8c0ad68f469a3a591b6d38e", "message": "Added more date formatters", "committedDate": "2020-09-25T19:15:32Z", "type": "commit"}, {"oid": "9152f4841302b553a7fefd1309b30897188715ca", "url": "https://github.com/osmlab/atlas-checks/commit/9152f4841302b553a7fefd1309b30897188715ca", "message": "Removed unnessesary check", "committedDate": "2020-09-25T19:15:32Z", "type": "commit"}, {"oid": "de768a49038a0b5e7f3ecc8e9c72b5150ac1533c", "url": "https://github.com/osmlab/atlas-checks/commit/de768a49038a0b5e7f3ecc8e9c72b5150ac1533c", "message": "removed print statement", "committedDate": "2020-09-25T19:15:32Z", "type": "commit"}, {"oid": "f3d9b7bd94d9b765ff6e3b14fe2e46fa775e25dd", "url": "https://github.com/osmlab/atlas-checks/commit/f3d9b7bd94d9b765ff6e3b14fe2e46fa775e25dd", "message": "Initial Tests", "committedDate": "2020-09-25T19:15:32Z", "type": "commit"}, {"oid": "589f7d3cb45ce62c7fb3dfba87ff3f813bda5d15", "url": "https://github.com/osmlab/atlas-checks/commit/589f7d3cb45ce62c7fb3dfba87ff3f813bda5d15", "message": "Modified check if is valid construction", "committedDate": "2020-09-25T19:15:32Z", "type": "commit"}, {"oid": "e21fa08806b98ee58622cb706cfb9d0d8be04a5b", "url": "https://github.com/osmlab/atlas-checks/commit/e21fa08806b98ee58622cb706cfb9d0d8be04a5b", "message": "Added new tests, fixed old isConstruction tests", "committedDate": "2020-09-25T19:15:32Z", "type": "commit"}, {"oid": "6d02db55e41edbcb9ee3c0c04edd470479974cfa", "url": "https://github.com/osmlab/atlas-checks/commit/6d02db55e41edbcb9ee3c0c04edd470479974cfa", "message": "Fixed test name", "committedDate": "2020-09-25T19:15:32Z", "type": "commit"}, {"oid": "b71dde0b14dd9067b76bb5a4af6d58c5b366b50e", "url": "https://github.com/osmlab/atlas-checks/commit/b71dde0b14dd9067b76bb5a4af6d58c5b366b50e", "message": "renamed keySet to tags", "committedDate": "2020-09-25T19:15:32Z", "type": "commit"}, {"oid": "71e9e191625d0e20fbd9fb2e9a1a8fd646da9869", "url": "https://github.com/osmlab/atlas-checks/commit/71e9e191625d0e20fbd9fb2e9a1a8fd646da9869", "message": "Docs", "committedDate": "2020-09-25T19:15:32Z", "type": "commit"}, {"oid": "3aaea2bccd3cdedf6e64ea1a1a3358be92d293ee", "url": "https://github.com/osmlab/atlas-checks/commit/3aaea2bccd3cdedf6e64ea1a1a3358be92d293ee", "message": "passes gradlew check -x test -x integrationtest", "committedDate": "2020-09-25T19:15:32Z", "type": "commit"}, {"oid": "5e544eb126d7893c3647f107ae1f8ec4bbb60141", "url": "https://github.com/osmlab/atlas-checks/commit/5e544eb126d7893c3647f107ae1f8ec4bbb60141", "message": "SonarCloud fix", "committedDate": "2020-09-25T19:15:33Z", "type": "commit"}, {"oid": "c8532f250074685ade2abb3fc6e56299fe3acdab", "url": "https://github.com/osmlab/atlas-checks/commit/c8532f250074685ade2abb3fc6e56299fe3acdab", "message": "Missed ending '|' in available_checks doc", "committedDate": "2020-09-25T19:15:33Z", "type": "commit"}, {"oid": "97636680a328546e7dc09315b8a70bcbacace0ff", "url": "https://github.com/osmlab/atlas-checks/commit/97636680a328546e7dc09315b8a70bcbacace0ff", "message": "Replaced strings with *Tag.KEY, new requirements to pass gradlew check", "committedDate": "2020-09-25T20:20:43Z", "type": "commit"}, {"oid": "97636680a328546e7dc09315b8a70bcbacace0ff", "url": "https://github.com/osmlab/atlas-checks/commit/97636680a328546e7dc09315b8a70bcbacace0ff", "message": "Replaced strings with *Tag.KEY, new requirements to pass gradlew check", "committedDate": "2020-09-25T20:20:43Z", "type": "forcePushed"}, {"oid": "e33bc063a1a76f6e692c91a414281cd3660bca5b", "url": "https://github.com/osmlab/atlas-checks/commit/e33bc063a1a76f6e692c91a414281cd3660bca5b", "message": "Missed these tags", "committedDate": "2020-10-01T15:42:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYyMzY1Mg==", "url": "https://github.com/osmlab/atlas-checks/pull/358#discussion_r498623652", "bodyText": "Just curious - whats the reasoning behind these values? Is 2 years a recommend length of time for checking these highways?", "author": "danielduhh", "createdAt": "2020-10-02T05:29:46Z", "path": "config/configuration.json", "diffHunk": "@@ -189,6 +189,16 @@\n       \"tags\": \"highway\"\n     }\n   },\n+  \"ConstructionCheck\": {\n+    \"oldConstructionDays\": 730.0,", "originalCommit": "e33bc063a1a76f6e692c91a414281cd3660bca5b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkwMTg4Nw==", "url": "https://github.com/osmlab/atlas-checks/pull/358#discussion_r498901887", "bodyText": "Osmose uses 2 years as the limit for something to have been in construction when no date tags are available\nhttps://github.com/osm-fr/osmose-backend/blob/master/plugins/Construction.py#L36\nAnd the 6 month check_date was also from their check, though someone would have to update the check_date each time it gets flagged instead of marking as false positive:\nhttps://github.com/osm-fr/osmose-backend/blob/master/plugins/Construction.py#L98", "author": "brianjor", "createdAt": "2020-10-02T15:43:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYyMzY1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYyMzk0MQ==", "url": "https://github.com/osmlab/atlas-checks/pull/358#discussion_r498623941", "bodyText": "This could be useful in atlas \ud83d\ude04", "author": "danielduhh", "createdAt": "2020-10-02T05:31:28Z", "path": "src/main/java/org/openstreetmap/atlas/checks/validation/tag/ConstructionCheck.java", "diffHunk": "@@ -0,0 +1,258 @@\n+package org.openstreetmap.atlas.checks.validation.tag;\n+\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.Year;\n+import java.time.YearMonth;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import org.openstreetmap.atlas.checks.base.BaseCheck;\n+import org.openstreetmap.atlas.checks.flag.CheckFlag;\n+import org.openstreetmap.atlas.geography.atlas.items.AtlasObject;\n+import org.openstreetmap.atlas.geography.atlas.items.Edge;\n+import org.openstreetmap.atlas.geography.atlas.walker.OsmWayWalker;\n+import org.openstreetmap.atlas.tags.BuildingTag;\n+import org.openstreetmap.atlas.tags.CheckDateTag;\n+import org.openstreetmap.atlas.tags.ConstructionDateTag;\n+import org.openstreetmap.atlas.tags.ConstructionTag;\n+import org.openstreetmap.atlas.tags.HighwayTag;\n+import org.openstreetmap.atlas.tags.LandUseTag;\n+import org.openstreetmap.atlas.tags.LastEditTimeTag;\n+import org.openstreetmap.atlas.tags.OpenDateTag;\n+import org.openstreetmap.atlas.tags.OpeningDateTag;\n+import org.openstreetmap.atlas.tags.TemporaryDateOnTag;\n+import org.openstreetmap.atlas.utilities.configuration.Configuration;\n+\n+/**\n+ * The purpose of this check is to identify construction tags where the construction hasn't been\n+ * checked on recently, or the expected finish date has been passed.\n+ *\n+ * @author v-brjor\n+ */\n+public class ConstructionCheck extends BaseCheck<Long>\n+{\n+    private static final long serialVersionUID = -5857500094506755337L;\n+    private static final double OLD_CONSTRUCTION_DAYS_DEFAULT = (double) 365 * 2;\n+    private static final double OLD_CHECK_DATE_MONTHS_DEFAULT = 6;\n+    private static final String CONSTRUCTION_PASSED_DATE = \"The {0} tag has been exceeded. If the construction is still ongoing please update the date with a new completion date from an official source. Otherwise please modify this to be a completed feature\";\n+    private static final String CONSTRUCTION_CHECK_DATE_OLD = \"It has been more than {0} months since this construction was last checked. If this is still under construction please update the check_date tag. Otherwise please modify this to be a completed feature.\";\n+    private static final String CONSTRUCTION_LAST_EDITED_OLD = \"This feature has had a construction tag, with no updates, for more than {0} days. If this is still under construction please update the check_date tag. Otherwise please modify this to be a completed feature.\";\n+    private static final List<String> FALLBACK_INSTRUCTIONS = Arrays.asList(\n+            CONSTRUCTION_PASSED_DATE, CONSTRUCTION_CHECK_DATE_OLD, CONSTRUCTION_LAST_EDITED_OLD);\n+    private static final List<DateTimeFormatter> YEAR_FORMATTERS = Collections.singletonList(\n+            // 2020\n+            DateTimeFormatter.ofPattern(\"yyyy\"));\n+    private static final List<DateTimeFormatter> YEAR_MONTH_FORMATTERS = Arrays.asList(\n+            // 2020-1\n+            DateTimeFormatter.ofPattern(\"yyyy-M\"),\n+            // 1-2020\n+            DateTimeFormatter.ofPattern(\"M-yyyy\"),\n+            // Jan-2020\n+            DateTimeFormatter.ofPattern(\"MMM-yyyy\"),\n+            // January 2020\n+            DateTimeFormatter.ofPattern(\"MMMM yyyy\"));\n+    private static final List<DateTimeFormatter> FULL_DATE_FORMATTERS = Arrays.asList(\n+            // 2020-1-1\n+            DateTimeFormatter.ofPattern(\"yyyy-M-d\"),\n+            // 1-1-2020\n+            DateTimeFormatter.ofPattern(\"d-M-yyyy\"),\n+            // 1-Jan-2020\n+            DateTimeFormatter.ofPattern(\"d-MMM-yyyy\"),\n+            // 1 January 2020\n+            DateTimeFormatter.ofPattern(\"d MMMM yyyy\"));\n+    private static final LocalDate TODAYS_DATE = LocalDate.now();\n+    private static final List<String> DATE_TAGS = Arrays.asList(OpeningDateTag.KEY, OpenDateTag.KEY,\n+            ConstructionDateTag.KEY, TemporaryDateOnTag.KEY, \"date_on\");\n+    private static final List<String> CONSTRUCTION_TAGS = List.of(HighwayTag.KEY, LandUseTag.KEY,\n+            BuildingTag.KEY);\n+\n+    private final int oldConstructionDays;\n+    private final int oldCheckDateMonths;\n+\n+    /**\n+     * The default constructor that must be supplied. The Atlas Checks framework will generate the\n+     * checks with this constructor, supplying a configuration that can be used to adjust any\n+     * parameters that the check uses during operation.\n+     *\n+     * @param configuration\n+     *            the JSON configuration for this check\n+     */\n+    public ConstructionCheck(final Configuration configuration)\n+    {\n+        super(configuration);\n+        this.oldConstructionDays = this.configurationValue(configuration, \"oldConstructionDays\",\n+                OLD_CONSTRUCTION_DAYS_DEFAULT, Double::intValue);\n+        this.oldCheckDateMonths = this.configurationValue(configuration, \"oldCheckDateMonth\",\n+                OLD_CHECK_DATE_MONTHS_DEFAULT, Double::intValue);\n+    }\n+\n+    /**\n+     * This function will validate if the supplied atlas object is valid for the check.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return {@code true} if this object should be checked\n+     */\n+    @Override\n+    public boolean validCheckForObject(final AtlasObject object)\n+    {\n+        final Map<String, String> keySet = object.getOsmTags();\n+        return !this.isFlagged(object.getOsmIdentifier()) && this.isConstruction(keySet);\n+    }\n+\n+    @Override\n+    protected CheckFlag createFlag(final AtlasObject object, final String instruction)\n+    {\n+        if (object instanceof Edge)\n+        {\n+            return super.createFlag(new OsmWayWalker((Edge) object).collectEdges(), instruction);\n+        }\n+        return super.createFlag(object, instruction);\n+    }\n+\n+    /**\n+     * This is the actual function that will check to see whether the object needs to be flagged.\n+     *\n+     * @param object\n+     *            the atlas object supplied by the Atlas-Checks framework for evaluation\n+     * @return an optional {@link CheckFlag} object that\n+     */\n+    @Override\n+    protected Optional<CheckFlag> flag(final AtlasObject object)\n+    {\n+        this.markAsFlagged(object.getOsmIdentifier());\n+\n+        final Map<String, String> tags = object.getTags();\n+\n+        final Optional<String> dateTag = this.getDateTag(tags);\n+        if (dateTag.isPresent())\n+        {\n+            final String tagDate = tags.get(dateTag.get());\n+\n+            final Optional<LocalDate> parsedDate = this.parseDate(tagDate);\n+            if (parsedDate.isPresent() && parsedDate.get().isBefore(TODAYS_DATE))\n+            {\n+                return Optional.of(\n+                        this.createFlag(object, this.getLocalizedInstruction(0, dateTag.get())));\n+            }\n+        }\n+\n+        if (tags.containsKey(CheckDateTag.KEY))\n+        {\n+            final Optional<LocalDate> parseDateChecked = this.parseDate(tags.get(CheckDateTag.KEY));\n+            if (parseDateChecked.isPresent())\n+            {\n+                final long monthsBetween = ChronoUnit.MONTHS.between(parseDateChecked.get(),\n+                        TODAYS_DATE);\n+                if (monthsBetween > this.oldCheckDateMonths)\n+                {\n+                    return Optional.of(this.createFlag(object,\n+                            this.getLocalizedInstruction(1, this.oldCheckDateMonths)));\n+                }\n+            }\n+        }\n+\n+        if (tags.containsKey(LastEditTimeTag.KEY))\n+        {\n+            final long timestamp = Long.parseLong(tags.get(LastEditTimeTag.KEY));\n+            final LocalDate lastEditDate = Instant.ofEpochMilli(timestamp)\n+                    .atZone(ZoneId.systemDefault()).toLocalDate();\n+\n+            final long numberOfDays = ChronoUnit.DAYS.between(lastEditDate, TODAYS_DATE);\n+            if (numberOfDays > this.oldConstructionDays)\n+            {\n+                return Optional.of(this.createFlag(object,\n+                        this.getLocalizedInstruction(2, this.oldConstructionDays)));\n+            }\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    @Override\n+    protected List<String> getFallbackInstructions()\n+    {\n+        return FALLBACK_INSTRUCTIONS;\n+    }\n+\n+    /**\n+     * Gets the tag that holds a date.\n+     *\n+     * @param keySet\n+     *            Tags from the object.\n+     * @return a tag that is considered a date for construction.\n+     */\n+    private Optional<String> getDateTag(final Map<String, String> keySet)\n+    {\n+        return DATE_TAGS.stream().filter(keySet::containsKey).findFirst();\n+    }\n+\n+    /**\n+     * Checks if the tags of an object signify it as being under construction.\n+     *\n+     * @param tags\n+     *            Tags from the object\n+     * @return true if the object is under construction, otherwise false\n+     */\n+    private boolean isConstruction(final Map<String, String> tags)\n+    {\n+        return tags.keySet().stream()\n+                .anyMatch(tag -> tag.equals(ConstructionTag.KEY)\n+                        || tag.startsWith(\"construction:\") && !tag.equals(ConstructionDateTag.KEY))\n+                || CONSTRUCTION_TAGS.stream()\n+                        .anyMatch(tag -> ConstructionTag.KEY.equals(tags.get(tag)));\n+    }\n+\n+    /**\n+     * Attempts to parse the date string to ISO 8601 yyyy-mm-dd.\n+     *\n+     * @param tagDate\n+     *            String representation of a date from a tag.\n+     * @return the parsed date.\n+     */\n+    private Optional<LocalDate> parseDate(final String tagDate)", "originalCommit": "e33bc063a1a76f6e692c91a414281cd3660bca5b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}