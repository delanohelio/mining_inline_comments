{"pr_number": 10836, "pr_title": "Update table metadata from changes in UDB", "pr_createdAt": "2020-02-04T03:46:23Z", "pr_url": "https://github.com/Alluxio/alluxio/pull/10836", "timeline": [{"oid": "32ce4ed4166bb734cc2ac000492bcfd608c6e88b", "url": "https://github.com/Alluxio/alluxio/commit/32ce4ed4166bb734cc2ac000492bcfd608c6e88b", "message": "[WIP] Use docker container of HMS", "committedDate": "2020-02-04T03:45:29Z", "type": "commit"}, {"oid": "e48a1b7511923f66128555f503aee5a76587739d", "url": "https://github.com/Alluxio/alluxio/commit/e48a1b7511923f66128555f503aee5a76587739d", "message": "Add license", "committedDate": "2020-02-04T05:53:55Z", "type": "commit"}, {"oid": "dc5cf01c42347603fca71728a74c83cb7bb32cf1", "url": "https://github.com/Alluxio/alluxio/commit/dc5cf01c42347603fca71728a74c83cb7bb32cf1", "message": "Fix checkstyle", "committedDate": "2020-02-04T13:54:54Z", "type": "commit"}, {"oid": "c06a1099e7fc0aa68f4586566e7b0c9931da5aa6", "url": "https://github.com/Alluxio/alluxio/commit/c06a1099e7fc0aa68f4586566e7b0c9931da5aa6", "message": "Clean up tests", "committedDate": "2020-02-04T21:37:15Z", "type": "commit"}, {"oid": "60f7f41147e2684a90b5081922c4875474e0a41e", "url": "https://github.com/Alluxio/alluxio/commit/60f7f41147e2684a90b5081922c4875474e0a41e", "message": "Support removal/renaming of udb tables", "committedDate": "2020-02-05T15:12:20Z", "type": "commit"}, {"oid": "42acd50afd984493d6d21af48bc6e13871cce9ae", "url": "https://github.com/Alluxio/alluxio/commit/42acd50afd984493d6d21af48bc6e13871cce9ae", "message": "Improve concurrency for sync in catalog", "committedDate": "2020-02-05T20:57:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU0NTkwOA==", "url": "https://github.com/Alluxio/alluxio/pull/10836#discussion_r375545908", "bodyText": "Under what conditions would this be triggered? Since we lock the db for sync operations, how do we end up with two updates to the same table?  Or is this assuming that we add future write operations?", "author": "yuzhu", "createdAt": "2020-02-05T22:33:20Z", "path": "table/server/master/src/main/java/alluxio/master/table/Database.java", "diffHunk": "@@ -179,70 +173,165 @@ public void addTable(String tableName, Table table) {\n   }\n \n   /**\n-   * Syncs the metadata from the under db.\n+   * Syncs the metadata from the under db. To avoid concurrent sync operations, this requires\n+   * external synchronization.\n+   *\n    * @param context journal context\n    * @return true if the database changed as a result of fullSync\n    */\n   public boolean sync(JournalContext context) throws IOException {\n-    boolean returnVal = false;\n+    boolean updated = false;\n     DatabaseInfo newDbInfo = mUdb.getDatabaseInfo();\n     if (!newDbInfo.equals(mDatabaseInfo)) {\n       applyAndJournal(context, Journal.JournalEntry.newBuilder()\n           .setUpdateDatabaseInfo(toJournalProto(newDbInfo, mName)).build());\n+      updated = true;\n     }\n-\n-    for (String tableName : mUdb.getTableNames()) {\n-      // TODO(gpang): concurrency control\n-      boolean tableUpdated = false;\n-      Table table = mTables.get(tableName);\n-      if (table == null) {\n-        // add table from udb\n-        LOG.debug(\"Importing a new table \" + tableName + \" into database \" + mName);\n-        UdbTable udbTable = mUdb.getTable(tableName);\n-        table = Table.create(this, udbTable);\n-        tableUpdated = true;\n-      } else {\n-        LOG.debug(\"Syncing an existing table \" + tableName + \" in database \" + mName);\n-        tableUpdated = table.sync(mUdb.getTable(tableName));\n-      }\n-      if (tableUpdated) {\n-        alluxio.proto.journal.Table.AddTableEntry addTableEntry = table.toJournalProto();\n+    Set<String> udbTableNames = new HashSet<>(mUdb.getTableNames());\n+    for (String tableName : udbTableNames) {\n+      Table previousTable = mTables.get(tableName);\n+      UdbTable udbTable = mUdb.getTable(tableName);\n+      Table newTable = Table.create(this, udbTable, previousTable);\n+\n+      if (newTable != null) {\n+        // table was created or was updated\n+        alluxio.proto.journal.Table.AddTableEntry addTableEntry = newTable.toJournalProto();\n         Journal.JournalEntry entry = Journal.JournalEntry.newBuilder().setAddTable(addTableEntry)\n             .build();\n         applyAndJournal(context, entry);\n-        returnVal = true;\n+        updated = true;\n       }\n     }\n-    return returnVal;\n+    for (Table existingTable : mTables.values()) {\n+      if (!udbTableNames.contains(existingTable.getName())) {\n+        // this table no longer exists in udb\n+        alluxio.proto.journal.Table.RemoveTableEntry removeTableEntry =\n+            alluxio.proto.journal.Table.RemoveTableEntry.newBuilder()\n+                .setDbName(mName)\n+                .setTableName(existingTable.getName())\n+                .setVersion(existingTable.getVersion())\n+                .build();\n+        Journal.JournalEntry entry = Journal.JournalEntry.newBuilder()\n+            .setRemoveTable(removeTableEntry)\n+            .build();\n+        applyAndJournal(context, entry);\n+        updated = true;\n+      }\n+    }\n+    return updated;\n+  }\n+\n+  @Override\n+  public void applyAndJournal(Supplier<JournalContext> context, Journal.JournalEntry entry) {\n+    // This is journaled differently from others components, since optimistic concurrency control\n+    // is utilized. There are no external locks for the table, so the locking will happen during\n+    // the access of the tables map.\n+    processJournalEntryInternal(entry, context.get());\n   }\n \n   @Override\n   public boolean processJournalEntry(Journal.JournalEntry entry) {\n+    // Do not journal when processing journal entries\n+    return processJournalEntryInternal(entry, null);\n+  }\n+\n+  /**\n+   * @param entry the journal entry to process\n+   * @param context the journal context, will not journal if null\n+   * @return whether the entry type is supported by this journaled object\n+   */\n+  private boolean processJournalEntryInternal(Journal.JournalEntry entry,\n+      @Nullable JournalContext context) {\n     if (entry.hasAddTable()) {\n-      alluxio.proto.journal.Table.AddTableEntry addTable = entry.getAddTable();\n-      if (addTable.getDbName().equals(mName)) {\n-        apply(addTable);\n-        return true;\n-      }\n+      return applyAddTable(context, entry);\n+    }\n+    if (entry.hasRemoveTable()) {\n+      return applyRemoveTable(context, entry);\n     }\n     if (entry.hasUpdateDatabaseInfo()) {\n-      alluxio.proto.journal.Table.UpdateDatabaseInfoEntry updateDb = entry.getUpdateDatabaseInfo();\n-      if (updateDb.getDbName().equals(mName)) {\n-        apply(updateDb);\n-        return true;\n-      }\n+      return applyUpdateDbInfo(context, entry);\n     }\n     return false;\n   }\n \n-  private void apply(alluxio.proto.journal.Table.UpdateDatabaseInfoEntry updateDb) {\n+  private boolean applyUpdateDbInfo(@Nullable JournalContext context, Journal.JournalEntry entry) {\n+    alluxio.proto.journal.Table.UpdateDatabaseInfoEntry updateDb = entry.getUpdateDatabaseInfo();\n+    if (!updateDb.getDbName().equals(mName)) {\n+      return false;\n+    }\n+    if (context != null) {\n+      context.append(entry);\n+    }\n     mDatabaseInfo = new DatabaseInfo(updateDb.getLocation(), updateDb.getOwnerName(),\n         updateDb.getOwnerType(), updateDb.getComment(), updateDb.getParameterMap());\n+    return true;\n+  }\n+\n+  private boolean applyAddTable(@Nullable JournalContext context, Journal.JournalEntry entry) {\n+    alluxio.proto.journal.Table.AddTableEntry addTable = entry.getAddTable();\n+    if (!addTable.getDbName().equals(mName)) {\n+      return false;\n+    }\n+\n+    Table newTable = Table.create(this, addTable);\n+    mTables.compute(newTable.getName(), (key, existingTable) -> {\n+      boolean writeNewTable = false;\n+      if (existingTable == null && (newTable.getVersion() == Table.FIRST_VERSION)) {\n+        // this table is being newly inserted, and has the expected first version\n+        LOG.info(\"Adding new table {}.{}\", mName, newTable.getName());\n+        writeNewTable = true;\n+      }\n+\n+      if (existingTable != null && (newTable.getPreviousVersion() == existingTable.getVersion())) {\n+        // Previous table already exists, and matches the new table's previous version\n+        LOG.info(\"Updating table {}.{} to version {}\", mName, newTable.getName(),\n+            newTable.getVersion());\n+        writeNewTable = true;\n+      }\n+\n+      if (writeNewTable) {\n+        // The new table has been successfully validated, so update the map with the new table,\n+        // and journal the entry if the journal context exists.\n+        if (context != null) {\n+          context.append(entry);\n+        }\n+        return newTable;\n+      } else {\n+        // The table to add does not validate with the existing table, so another thread must\n+        // have updated the map. Do not modify the map.\n+        return existingTable;", "originalCommit": "42acd50afd984493d6d21af48bc6e13871cce9ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTk2NDc5NA==", "url": "https://github.com/Alluxio/alluxio/pull/10836#discussion_r375964794", "bodyText": "Yes, currently, the syncs are serialized, but this is for correctness for future write operations.", "author": "gpang", "createdAt": "2020-02-06T17:06:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU0NTkwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkwOTcxNA==", "url": "https://github.com/Alluxio/alluxio/pull/10836#discussion_r375909714", "bodyText": "this condition would always succeed when there is a transformation, because getLayout would return the transformed layout.\nThat is probably not what you intended.", "author": "yuzhu", "createdAt": "2020-02-06T15:39:22Z", "path": "table/server/master/src/main/java/alluxio/master/table/Table.java", "diffHunk": "@@ -43,114 +43,110 @@\n @NotThreadSafe\n public class Table {\n   private static final Logger LOG = LoggerFactory.getLogger(Table.class);\n+  private static final long UNDEFINED_VERSION = -1;\n+\n+  public static final long FIRST_VERSION = 1;\n \n-  private String mName;\n   private final Database mDatabase;\n-  private Schema mSchema;\n-  private PartitionScheme mPartitionScheme;\n-  private String mOwner;\n-  private List<ColumnStatisticsInfo> mStatistics;\n-  private Map<String, String> mParameters;\n+  private final String mName;\n+  private final long mVersion;\n+  private final long mVersionCreationTime;\n+  private final long mPreviousVersion;\n \n-  private Table(Database database, UdbTable udbTable) {\n-    mDatabase = database;\n-    sync(udbTable);\n-  }\n+  private final Schema mSchema;\n+  private final PartitionScheme mPartitionScheme;\n+  private final String mOwner;\n+  private final List<ColumnStatisticsInfo> mStatistics;\n+  private final Map<String, String> mParameters;\n \n-  private Table(Database database, List<Partition> partitions, Schema schema, String tableName,\n-      String owner, List<ColumnStatisticsInfo> columnStats,\n-      Map<String, String> parameters, List<FieldSchema> partitionCols, Layout layout) {\n+  /**\n+   * @param database the database\n+   * @param udbTable the udb table to sync from\n+   * @param previousTable the previous table, or {@code null} if creating first version of table\n+   */\n+  private Table(Database database, UdbTable udbTable, @Nullable Table previousTable) {\n     mDatabase = database;\n-    mName = tableName;\n-    mSchema = schema;\n-    mPartitionScheme = PartitionScheme.create(partitions, layout, partitionCols);\n-    mOwner = owner;\n-    mStatistics = columnStats;\n-    mParameters = new HashMap<>(parameters);\n-  }\n+    mVersion = previousTable == null ? FIRST_VERSION : previousTable.mVersion + 1;\n+    mPreviousVersion = previousTable == null ? UNDEFINED_VERSION : previousTable.mVersion;\n+    mVersionCreationTime = CommonUtils.getCurrentMs();\n \n-  private boolean isSyncable(UdbTable udbTable) {\n-    if (mSchema == null && mPartitionScheme == null) {\n-      return true;\n-    }\n-    if (!Objects.equals(mSchema, udbTable.getSchema())) {\n-      // can't sync if the schema is different\n-      return false;\n-    }\n-    if (mPartitionScheme == null || mPartitionScheme.getPartitionCols().isEmpty()) {\n-      // can't sync if it is non-partitioned table\n-      return false;\n-    }\n-    List<FieldSchema> partitionCols = new ArrayList<>(udbTable.getPartitionCols());\n-    return Objects.equals(partitionCols, mPartitionScheme.getPartitionCols());\n-  }\n+    mName = udbTable.getName();\n+    mSchema = udbTable.getSchema();\n+    mOwner = udbTable.getOwner();\n+    mStatistics = udbTable.getStatistics();\n+    mParameters = new HashMap<>(udbTable.getParameters());\n \n-  /**\n-   * Sync the table with a udbtable.\n-   *\n-   * @param udbTable udb table to be synced\n-   * @return true if the table changed\n-   */\n-  public boolean sync(UdbTable udbTable) {\n-    boolean changed = false;\n-    try {\n-      if (!isSyncable(udbTable)) {\n-        return false;\n-      }\n-      // only sync these fields if the table is uninitialized\n-      if (mName == null) {\n-        mName = udbTable.getName();\n-        mSchema = udbTable.getSchema();\n-        mOwner = udbTable.getOwner();\n-        mStatistics = udbTable.getStatistics();\n-        mParameters = new HashMap<>(udbTable.getParameters());\n-        changed = true;\n-      }\n-      List<Partition> partitions = mPartitionScheme == null\n-          ? new ArrayList<>() : new ArrayList<>(mPartitionScheme.getPartitions());\n-      Layout tableLayout = mPartitionScheme == null\n-          ? udbTable.getLayout() : mPartitionScheme.getTableLayout();\n-      Set<String> partNames = partitions.stream().map(Partition::getSpec)\n-          .collect(Collectors.toSet());\n-      for (UdbPartition udbpart : udbTable.getPartitions()) {\n-        if (!partNames.contains(udbpart.getSpec())) {\n-          partitions.add(new Partition(udbpart));\n-          changed = true;\n+    // TODO(gpang): inspect listing of table or partition location?\n+\n+    // Compare udb partitions with the existing partitions\n+    List<Partition> partitions = new ArrayList<>(udbTable.getPartitions().size());\n+    if (previousTable != null) {\n+      // spec to existing partition\n+      Map<String, Partition> existingPartitions =\n+          previousTable.mPartitionScheme.getPartitions().stream()\n+              .collect(Collectors.toMap(Partition::getSpec, Function.identity()));\n+      for (UdbPartition udbPartition : udbTable.getPartitions()) {\n+        Partition newPartition = existingPartitions.get(udbPartition.getSpec());\n+        if (newPartition == null) {\n+          // partition does not exist yet\n+          newPartition = new Partition(udbPartition);\n+        } else if (!newPartition.getLayout().equals(udbPartition.getLayout())) {", "originalCommit": "42acd50afd984493d6d21af48bc6e13871cce9ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTk3NjIzMg==", "url": "https://github.com/Alluxio/alluxio/pull/10836#discussion_r375976232", "bodyText": "Thanks! using base layout", "author": "gpang", "createdAt": "2020-02-06T17:28:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkwOTcxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkxNDExMg==", "url": "https://github.com/Alluxio/alluxio/pull/10836#discussion_r375914112", "bodyText": "similar to above, this layout comparison would fail if there is transformation. Probably want getBaseLayout", "author": "yuzhu", "createdAt": "2020-02-06T15:46:05Z", "path": "table/server/master/src/main/java/alluxio/master/table/Table.java", "diffHunk": "@@ -205,6 +215,38 @@ public Schema getSchema() {\n     return plans;\n   }\n \n+  /**\n+   * @param udbTable the udb table to check against\n+   * @return true if the table should be synced, because of differences in the udb table\n+   */\n+  public boolean shouldSync(UdbTable udbTable) {\n+    if (!Objects.equals(mName, udbTable.getName())\n+        || !Objects.equals(mSchema, udbTable.getSchema())\n+        || !Objects.equals(mOwner, udbTable.getOwner())\n+        || !Objects.equals(mStatistics, udbTable.getStatistics())\n+        || !Objects.equals(mParameters, udbTable.getParameters())) {\n+      // some fields are different\n+      return true;\n+    }\n+\n+    Map<String, Partition> existingPartitions = mPartitionScheme.getPartitions().stream()\n+        .collect(Collectors.toMap(Partition::getSpec, Function.identity()));\n+    if (existingPartitions.size() != udbTable.getPartitions().size()) {\n+      return true;\n+    }\n+\n+    for (UdbPartition udbPartition : udbTable.getPartitions()) {\n+      Partition newPartition = existingPartitions.get(udbPartition.getSpec());\n+      if (newPartition == null || !newPartition.getLayout()", "originalCommit": "42acd50afd984493d6d21af48bc6e13871cce9ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTk3NjMyOA==", "url": "https://github.com/Alluxio/alluxio/pull/10836#discussion_r375976328", "bodyText": "Thanks! using base layout", "author": "gpang", "createdAt": "2020-02-06T17:28:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkxNDExMg=="}], "type": "inlineReview"}, {"oid": "54f4c4eb354d2f879b35de4525a8dcc15fdbd262", "url": "https://github.com/Alluxio/alluxio/commit/54f4c4eb354d2f879b35de4525a8dcc15fdbd262", "message": "Use base layout for syncing criteria", "committedDate": "2020-02-06T17:30:53Z", "type": "commit"}, {"oid": "8dfd205397a237497c6124cb7514e2a6ec87720b", "url": "https://github.com/Alluxio/alluxio/commit/8dfd205397a237497c6124cb7514e2a6ec87720b", "message": "Add transformed test", "committedDate": "2020-02-06T18:02:13Z", "type": "commit"}]}