{"pr_number": 10707, "pr_title": "Implement LocalCacheManager", "pr_createdAt": "2020-01-07T21:20:06Z", "pr_url": "https://github.com/Alluxio/alluxio/pull/10707", "timeline": [{"oid": "685ebe7a66030e81b56d88237fc7434668c306b1", "url": "https://github.com/Alluxio/alluxio/commit/685ebe7a66030e81b56d88237fc7434668c306b1", "message": "Implement LocalCacheManager", "committedDate": "2020-01-07T21:18:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk1ODMyMA==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r363958320", "bodyText": "I don't feel very good about this constructor. It seems counter-intuitive to have the fsContext as an argument here.\nThere is already an fsContext embededed within the fs object. Is there a better way to access it?", "author": "ZacBlanco", "createdAt": "2020-01-07T21:25:55Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileSystem.java", "diffHunk": "@@ -23,14 +24,16 @@\n public class LocalCacheFileSystem extends DelegatingFileSystem {\n \n   private final LocalCacheManager mLocalCacheManager;\n+  private final FileSystemContext mFsContext;\n \n   /**\n    * @param fs a FileSystem instance to query on local cache miss\n    */\n-  public LocalCacheFileSystem(FileSystem fs) {\n+  public LocalCacheFileSystem(FileSystem fs, FileSystemContext fsContext) {", "originalCommit": "685ebe7a66030e81b56d88237fc7434668c306b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM3NjM3NQ==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r364376375", "bodyText": "I don't see a way to access it unless we expose it from the FileSystem interface.", "author": "bf8086", "createdAt": "2020-01-08T18:26:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk1ODMyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2OTU2MA==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r363969560", "bodyText": "do we ever need to make this configurable?", "author": "ZacBlanco", "createdAt": "2020-01-07T21:53:44Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -11,74 +11,251 @@\n \n package alluxio.client.file.cache;\n \n+import alluxio.client.file.FileSystemContext;\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.resource.LockResource;\n+import alluxio.util.io.BufferUtils;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n+import java.nio.channels.Channels;\n import java.nio.channels.ReadableByteChannel;\n import java.nio.channels.WritableByteChannel;\n+import java.util.Arrays;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n+import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n /**\n- * A class to manage cached pages. This class will\n- * 1. Ensure thread-safety\n- * 2. Bookkeep Cache Replacement Alg\n+ * A class to manage cached pages. This class coordinates different components to respond for\n+ * thread-safety and operate cache replacement policies.\n  *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ul>\n+ * <li>1. Acquire page lock</li>\n+ * <li>2. Acquire metastore lock mMetaLock</li>\n+ * <li>3. Release metastore lock mMetaLock</li>\n+ * <li>4. Release page lock</li>\n+ * </ul>\n  */\n @ThreadSafe\n public class LocalCacheManager {\n   private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n+  /** Number of page locks to strip. */\n+  private static int PAGE_LOCK_SIZE = 256;", "originalCommit": "685ebe7a66030e81b56d88237fc7434668c306b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM3NTk1Nw==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r364375957", "bodyText": "Doesn't hurt to add a property.", "author": "bf8086", "createdAt": "2020-01-08T18:25:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2OTU2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUyNzg0NQ==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r364527845", "bodyText": "this is a very internal config and I don't expect the users to tune this value.\nGiven we have already too many configuration keys, I would leave this a constant large enough, e.g., a few thousands.", "author": "apc999", "createdAt": "2020-01-09T01:52:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2OTU2MA=="}], "type": "inlineReview"}, {"oid": "4e49242b68194fb815cfc138fac24b64d895f313", "url": "https://github.com/Alluxio/alluxio/commit/4e49242b68194fb815cfc138fac24b64d895f313", "message": "Fix checkstyles", "committedDate": "2020-01-07T22:04:09Z", "type": "commit"}, {"oid": "3d77abf0fa9d247dcc8a8f6d10035a34907486e5", "url": "https://github.com/Alluxio/alluxio/commit/3d77abf0fa9d247dcc8a8f6d10035a34907486e5", "message": "add unit tests and minor fixes", "committedDate": "2020-01-08T01:52:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA4MzExNg==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r364083116", "bodyText": "shouldn't it be mPageStore.size() based on my convo with @ZacBlanco", "author": "apc999", "createdAt": "2020-01-08T06:45:18Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -11,74 +11,253 @@\n \n package alluxio.client.file.cache;\n \n+import alluxio.client.file.FileSystemContext;\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.resource.LockResource;\n+import alluxio.util.io.BufferUtils;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n+import java.nio.channels.Channels;\n import java.nio.channels.ReadableByteChannel;\n import java.nio.channels.WritableByteChannel;\n+import java.util.Arrays;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n+import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n /**\n- * A class to manage cached pages. This class will\n- * 1. Ensure thread-safety\n- * 2. Bookkeep Cache Replacement Alg\n+ * A class to manage cached pages. This class coordinates different components to respond for\n+ * thread-safety and operate cache replacement policies.\n  *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ul>\n+ * <li>1. Acquire page lock</li>\n+ * <li>2. Acquire metastore lock mMetaLock</li>\n+ * <li>3. Release metastore lock mMetaLock</li>\n+ * <li>4. Release page lock</li>\n+ * </ul>\n  */\n @ThreadSafe\n public class LocalCacheManager {\n   private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n \n-  private final CacheEvictor mEvictor = CacheEvictor.create();\n-  private final PageStore mPageStore = PageStore.create();\n-  private final MetaStore mMetaStore = new MetaStore();\n+  private final int mPageSize;\n+  private final long mCacheSize;\n+  private final int mLockSize;\n+  private final CacheEvictor mEvictor;\n+  /** A readwrite lock pool to guard individual pages based on striping. */\n+  private final ReadWriteLock[] mPageLocks;\n+  private final PageStore mPageStore;\n+  /** A readwrite lock to guard metadata operations. */\n+  private final ReadWriteLock mMetaLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"mMetaLock\")\n+  private final MetaStore mMetaStore;\n+  private final FileSystemContext mFsContext;\n+\n+  /**\n+   * @param fsContext filesystem context\n+   */\n+  public LocalCacheManager(FileSystemContext fsContext) {\n+    this(fsContext, new MetaStore(), PageStore.create(), CacheEvictor.create());\n+  }\n \n-  public LocalCacheManager() {\n+  /**\n+   * @param fsContext filesystem context\n+   */\n+  @VisibleForTesting\n+  LocalCacheManager(FileSystemContext fsContext, MetaStore metaStore,\n+                    PageStore pageStore, CacheEvictor evictor) {\n+    mFsContext = fsContext;\n+    mMetaStore = metaStore;\n+    mPageStore = pageStore;\n+    mEvictor = evictor;\n+    mPageSize = (int) mFsContext.getClusterConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mCacheSize = mFsContext.getClusterConf().getBytes(PropertyKey.USER_CLIENT_CACHE_SIZE);\n+    mLockSize = mFsContext.getClusterConf().getInt(PropertyKey.USER_CLIENT_CACHE_LOCK_SIZE);\n+    mPageLocks = new ReentrantReadWriteLock[mLockSize];\n+    for (int i = 0; i < mLockSize; i++) {\n+      mPageLocks[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  /**\n+   * Gets the lock for a particular page. Note that multiple pages may share the same lock as lock\n+   * striping is used to reduce resource overhead for locks.\n+   *\n+   * @param fileId file identifier\n+   * @param pageIndex index of the page within the file\n+   * @return the corresponding page lock\n+   */\n+  private ReadWriteLock getPageLock(long fileId, long pageIndex) {\n+    return mPageLocks[(int) (fileId + pageIndex) % mLockSize];\n+  }\n+\n+  /**\n+   * Gets a pair of locks to operate two given pages. One MUST acquire the first lock followed by\n+   * the second lock.\n+   *\n+   * @param fileId file identifier\n+   * @param pageIndex index of the page within the file\n+   * @param fileId2 file identifier\n+   * @param pageIndex2 index of the page within the file\n+   * @return the corresponding page lock pair\n+   */\n+  private Pair<ReadWriteLock, ReadWriteLock> getPageLockPair(long fileId, long pageIndex,\n+      long fileId2, long pageIndex2) {\n+    if (fileId + pageIndex < fileId2 + pageIndex2) {\n+      return new Pair<>(getPageLock(fileId, pageIndex), getPageLock(fileId2, pageIndex2));\n+    } else {\n+      return new Pair<>(getPageLock(fileId2, pageIndex2), getPageLock(fileId, pageIndex));\n+    }\n   }\n \n   /**\n-   * Writes a new page from a source channel to the store.\n+   * Writes a new page from a source channel with best effort.\n    *\n-   * @param pageId page ID\n+   * @param fileId file identifier\n+   * @param pageIndex index of the page within the file\n    * @param src source channel to read this new page\n    * @throws IOException\n    * @return the number of bytes written\n    */\n-  int put(long pageId, ReadableByteChannel src) throws IOException {\n-    mMetaStore.addPage(pageId);\n-    mPageStore.put(pageId, src);\n-    return 0;\n+  public int put(long fileId, long pageIndex, ReadableByteChannel src) throws IOException {\n+    long victimFileId = 0;\n+    long victimPageIndex = 0;\n+\n+    ReadWriteLock pageLock = getPageLock(fileId, pageIndex);\n+    try (LockResource r = new LockResource(pageLock.writeLock())) {\n+      boolean alreadyCached;\n+      boolean needEvict = false;\n+      try (LockResource r2 = new LockResource(mMetaLock.writeLock())) {\n+        alreadyCached = mMetaStore.hasPage(fileId, pageIndex);\n+        if (!alreadyCached) {\n+          needEvict = (mPageSize + mMetaStore.size()) > mCacheSize;", "originalCommit": "3d77abf0fa9d247dcc8a8f6d10035a34907486e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM4MzczOA==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r364383738", "bodyText": "I don't see it on the PageStore interface yet. Should I go ahead and add it?", "author": "bf8086", "createdAt": "2020-01-08T18:43:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA4MzExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQzODkzOA==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r364438938", "bodyText": "Refactored the method to PageStore.", "author": "bf8086", "createdAt": "2020-01-08T20:55:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA4MzExNg=="}], "type": "inlineReview"}, {"oid": "f381481a9ca629d19fc8ada534c13a7c8089d000", "url": "https://github.com/Alluxio/alluxio/commit/f381481a9ca629d19fc8ada534c13a7c8089d000", "message": "move the size method", "committedDate": "2020-01-08T20:44:54Z", "type": "commit"}, {"oid": "e68d1f47d06d274afd6b1d1bd40ae94f87244df6", "url": "https://github.com/Alluxio/alluxio/commit/e68d1f47d06d274afd6b1d1bd40ae94f87244df6", "message": "clean up test", "committedDate": "2020-01-08T21:27:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUyODc4Ng==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r364528786", "bodyText": "this local cache manager should be shared across multiple different LocalCacheFileSystem instances (e.g., different thread may init their own instances). in other words, we don't want to have multiple instances of this manager or they will race on reading/writing files. As a result, we may want to introduce the instance ofLocalCacheManager as a singleton in the context.", "author": "apc999", "createdAt": "2020-01-09T01:56:53Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileSystem.java", "diffHunk": "@@ -23,14 +24,17 @@\n public class LocalCacheFileSystem extends DelegatingFileSystem {\n \n   private final LocalCacheManager mLocalCacheManager;\n+  private final FileSystemContext mFsContext;\n \n   /**\n    * @param fs a FileSystem instance to query on local cache miss\n+   * @param fsContext file system context\n    */\n-  public LocalCacheFileSystem(FileSystem fs) {\n+  public LocalCacheFileSystem(FileSystem fs, FileSystemContext fsContext) {\n     super(fs);\n+    mFsContext = fsContext;\n     // needs to be moved outside FileSystem constructor\n-    mLocalCacheManager = new LocalCacheManager();\n+    mLocalCacheManager = new LocalCacheManager(mFsContext);", "originalCommit": "e68d1f47d06d274afd6b1d1bd40ae94f87244df6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk1MzI3OA==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r364953278", "bodyText": "Done. For initial implementation the local cache manager is global to all file system clients.", "author": "bf8086", "createdAt": "2020-01-09T20:49:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUyODc4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUzMDg2MA==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r364530860", "bodyText": "why throwing IOException here?", "author": "apc999", "createdAt": "2020-01-09T02:07:50Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/PageStore.java", "diffHunk": "@@ -56,9 +56,14 @@ static PageStore create() {\n    * Deletes a page from the store.\n    *\n    * @param fileId file identifier\n-   * @param pageIndex index of page within the file.\n+   * @param pageIndex index of page within the file\n    * @return if the page was deleted\n    * @throws IOException\n    */\n   boolean delete(long fileId, long pageIndex) throws IOException;\n+\n+  /**\n+   * @return size of the data in store\n+   */\n+  long size() throws IOException;", "originalCommit": "e68d1f47d06d274afd6b1d1bd40ae94f87244df6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f7c4ef3873f82bf5ed979b7dbcb33172934339e1", "url": "https://github.com/Alluxio/alluxio/commit/f7c4ef3873f82bf5ed979b7dbcb33172934339e1", "message": "Make local cache manager a singleton", "committedDate": "2020-01-09T20:45:50Z", "type": "commit"}, {"oid": "7a2e1971af22d7d0744851c7bbcffcf0b1e425fb", "url": "https://github.com/Alluxio/alluxio/commit/7a2e1971af22d7d0744851c7bbcffcf0b1e425fb", "message": "Add cache manager interface", "committedDate": "2020-01-09T22:23:17Z", "type": "commit"}, {"oid": "3b44aaa0a9edcc3411a7ba5372fbf1eec492fe96", "url": "https://github.com/Alluxio/alluxio/commit/3b44aaa0a9edcc3411a7ba5372fbf1eec492fe96", "message": "Merge remote-tracking branch 'upstream/lite' into lite_cachemgr", "committedDate": "2020-01-10T19:32:47Z", "type": "commit"}, {"oid": "8969909b743039fe0cdd72d7e519f6afc6b72033", "url": "https://github.com/Alluxio/alluxio/commit/8969909b743039fe0cdd72d7e519f6afc6b72033", "message": "Merge remote-tracking branch 'upstream/lite' into lite_cachemgr", "committedDate": "2020-01-10T22:02:26Z", "type": "commit"}, {"oid": "3b97e8c3d844fc868cff9ae0378baad5ed4aca35", "url": "https://github.com/Alluxio/alluxio/commit/3b97e8c3d844fc868cff9ae0378baad5ed4aca35", "message": "update API signatures", "committedDate": "2020-01-10T23:02:20Z", "type": "commit"}, {"oid": "af9a3a5b10e1b90c390d9737b9d22e07c4b1ec18", "url": "https://github.com/Alluxio/alluxio/commit/af9a3a5b10e1b90c390d9737b9d22e07c4b1ec18", "message": "update meta store API", "committedDate": "2020-01-10T23:11:33Z", "type": "commit"}, {"oid": "cadc31fb47fcdbcd1a3b401bcbd8a82c3049d60c", "url": "https://github.com/Alluxio/alluxio/commit/cadc31fb47fcdbcd1a3b401bcbd8a82c3049d60c", "message": "fix checkstyles", "committedDate": "2020-01-10T23:22:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3MTMwMw==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365471303", "bodyText": "Given how often we use the fileId, pageIndex pair, it might be worth creating an explicit object.", "author": "calvinjia", "createdAt": "2020-01-10T23:35:31Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/CacheEvictor.java", "diffHunk": "@@ -24,10 +27,34 @@ static CacheEvictor create() {\n     return null;\n   }\n \n-  void updateOnGet(long pageId);\n+  /**\n+   * Updates evictor after a get operation.\n+   *\n+   * @param fileId ID of the file\n+   * @param pageIndex index of the page within the file\n+   */\n+  void updateOnGet(long fileId, long pageIndex);\n \n-  void updateOnPut(long pageId);\n+  /**\n+   * Updates evictor after a put operation.\n+   *\n+   * @param fileId ID of the file\n+   * @param pageIndex index of the page within the file\n+   */\n+  void updateOnPut(long fileId, long pageIndex);\n \n-  List<Long> getPagesToEvict(int pages);\n+  /**\n+   * Updates evictor after a delete operation.\n+   *\n+   * @param fileId ID of the file\n+   * @param pageIndex index of the page within the file\n+   */\n+  void updateOnDelete(long fileId, long pageIndex);\n \n+  /**\n+   * Find a page to evict.\n+   *\n+   * @return a pair of long values representing (fileId, pageIndex)\n+   */\n+  Pair<Long, Long> evict();", "originalCommit": "cadc31fb47fcdbcd1a3b401bcbd8a82c3049d60c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTUwMTUzOQ==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365501539", "bodyText": "Refactored.", "author": "bf8086", "createdAt": "2020-01-11T05:34:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3MTMwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3Nzc0Nw==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365477747", "bodyText": "@Nullable\nReadableByteChannel get(long fileId, long pageIndex) throws IOException;", "author": "apc999", "createdAt": "2020-01-11T00:11:26Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/CacheManager.java", "diffHunk": "@@ -1,37 +1,73 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n package alluxio.client.file.cache;\n \n-import alluxio.client.file.cache.store.PageNotFoundException;\n+import alluxio.client.file.FileSystemContext;\n \n import java.io.IOException;\n import java.nio.channels.ReadableByteChannel;\n \n-interface CacheManager {\n+/**\n+ * Interface for managing cached pages.\n+ */\n+public interface CacheManager {\n+  /**\n+   * @param fsContext filesystem context\n+   * @return an instance of {@link CacheManager}\n+   */\n+  static CacheManager create(FileSystemContext fsContext) {\n+    return new LocalCacheManager(fsContext);\n+  }\n \n   /**\n-   * Writes a new page from a source channel to the store.\n+   * Writes a new page from a source channel with best effort.\n    *\n-   * @param fileId file ID\n-   * @param pageId page ID\n+   * @param fileId file identifier\n+   * @param pageIndex index of the page within the file\n    * @param page page data\n-   * @return the number of bytes written\n+   * @throws IOException\n+   */\n+  void put(long fileId, long pageIndex, byte[] page) throws IOException;\n+\n+  /**\n+   * Reads a page to the destination channel.\n+   *\n+   * @param fileId file identifier\n+   * @param pageIndex index of the page within the file\n+   * @throws PageNotFoundException if page is not found in the store\n+   * @return the number of bytes read\n    */\n-  int put(long fileId, long pageId, byte[] page) throws IOException;\n+  ReadableByteChannel get(long fileId, long pageIndex) throws IOException,", "originalCommit": "cadc31fb47fcdbcd1a3b401bcbd8a82c3049d60c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4NTk4NQ==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365485985", "bodyText": "Updated.", "author": "bf8086", "createdAt": "2020-01-11T01:09:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3Nzc0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3ODAyMw==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365478023", "bodyText": "Does the length parameter help underlying implementations? For the caller, length is not important since they have control over how many bytes are being read.", "author": "calvinjia", "createdAt": "2020-01-11T00:13:29Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/CacheManager.java", "diffHunk": "@@ -1,37 +1,73 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n package alluxio.client.file.cache;\n \n-import alluxio.client.file.cache.store.PageNotFoundException;\n+import alluxio.client.file.FileSystemContext;\n \n import java.io.IOException;\n import java.nio.channels.ReadableByteChannel;\n \n-interface CacheManager {\n+/**\n+ * Interface for managing cached pages.\n+ */\n+public interface CacheManager {\n+  /**\n+   * @param fsContext filesystem context\n+   * @return an instance of {@link CacheManager}\n+   */\n+  static CacheManager create(FileSystemContext fsContext) {\n+    return new LocalCacheManager(fsContext);\n+  }\n \n   /**\n-   * Writes a new page from a source channel to the store.\n+   * Writes a new page from a source channel with best effort.\n    *\n-   * @param fileId file ID\n-   * @param pageId page ID\n+   * @param fileId file identifier\n+   * @param pageIndex index of the page within the file\n    * @param page page data\n-   * @return the number of bytes written\n+   * @throws IOException\n+   */\n+  void put(long fileId, long pageIndex, byte[] page) throws IOException;\n+\n+  /**\n+   * Reads a page to the destination channel.\n+   *\n+   * @param fileId file identifier\n+   * @param pageIndex index of the page within the file\n+   * @throws PageNotFoundException if page is not found in the store\n+   * @return the number of bytes read\n    */\n-  int put(long fileId, long pageId, byte[] page) throws IOException;\n+  ReadableByteChannel get(long fileId, long pageIndex) throws IOException,\n+      PageNotFoundException;\n \n   /**\n-   * Gets a page from the store to the destination channel.\n+   * Reads a part of a page to the destination channel.\n    *\n-   * @param fileId file ID\n-   * @param pageId page ID\n-   * @return a channel to read the page\n+   * @param fileId file identifier\n+   * @param pageIndex index of the page within the file\n+   * @param pageOffset offset into the page\n+   * @param length length to read\n+   * @throws PageNotFoundException if page is not found in the store\n+   * @return the number of bytes read\n    */\n-  ReadableByteChannel get(long fileId, long pageId) throws IOException;\n+  ReadableByteChannel get(long fileId, long pageIndex, int pageOffset, int length)", "originalCommit": "cadc31fb47fcdbcd1a3b401bcbd8a82c3049d60c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4MDAwMQ==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365480001", "bodyText": "Shouldn't be much difference in the underlying implementation.", "author": "bf8086", "createdAt": "2020-01-11T00:26:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3ODAyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4MDQ0Ng==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365480446", "bodyText": "In that case I don't think we need to specify length?", "author": "calvinjia", "createdAt": "2020-01-11T00:29:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3ODAyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4NzIyNg==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365487226", "bodyText": "Removed.", "author": "bf8086", "createdAt": "2020-01-11T01:22:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3ODAyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3ODE5Nw==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365478197", "bodyText": "Use try-with-catch?", "author": "apc999", "createdAt": "2020-01-11T00:14:42Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java", "diffHunk": "@@ -106,21 +106,30 @@ public int read(byte[] b, int off, int len) throws IOException {\n       int currentPageOffset = (int) (mPosition % PAGE_SIZE);\n       int bytesLeftInPage = (int) Math.min(PAGE_SIZE - currentPageOffset, len - bytesRead);\n       // TODO(calvin): Update this to take page offset when API is updated\n-      ReadableByteChannel cachedData = mCacheManager.get(mStatus.getFileId(), currentPage);\n+      ReadableByteChannel cachedData = null;\n+      try {\n+        cachedData = mCacheManager.get(mStatus.getFileId(), currentPage);\n+      } catch (PageNotFoundException e) {\n+        // ignore exception and continue to read remote data\n+      }\n       if (cachedData != null) { // cache hit\n         // wrap return byte array in a bytebuffer and set the pos/limit for the page read\n-        ByteBuffer buf = ByteBuffer.wrap(b);\n-        buf.position(off + bytesRead);\n-        buf.limit(off + bytesRead + bytesLeftInPage);\n-        // read data from cache\n-        while (buf.position() != buf.limit()) {\n-          if (cachedData.read(buf) == -1) {\n-            break;\n+        try {", "originalCommit": "cadc31fb47fcdbcd1a3b401bcbd8a82c3049d60c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4NTg4Mg==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365485882", "bodyText": "Done.", "author": "bf8086", "createdAt": "2020-01-11T01:08:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3ODE5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3ODIwNQ==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365478205", "bodyText": "Should we do something in this error case, it doesn't seem safe to proceed?", "author": "calvinjia", "createdAt": "2020-01-11T00:14:45Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -11,53 +11,240 @@\n \n package alluxio.client.file.cache;\n \n-import alluxio.client.file.cache.store.PageNotFoundException;\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.zookeeper.server.ByteBufferInputStream;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Channels;\n import java.nio.channels.ReadableByteChannel;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n+import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n /**\n- * A class to manage cached pages. This class will\n- * 1. Ensure thread-safety\n- * 2. Bookkeep Cache Replacement Alg\n+ * A class to manage cached pages. This class coordinates different components to respond for\n+ * thread-safety and operate cache replacement policies.\n  *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ul>\n+ * <li>1. Acquire page lock</li>\n+ * <li>2. Acquire metastore lock mMetaLock</li>\n+ * <li>3. Release metastore lock mMetaLock</li>\n+ * <li>4. Release page lock</li>\n+ * </ul>\n  */\n @ThreadSafe\n public class LocalCacheManager implements CacheManager {\n   private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n \n-  private final CacheEvictor mEvictor = CacheEvictor.create();\n-  private final PageStore mPageStore = PageStore.create();\n-  private final MetaStore mMetaStore = new MetaStore();\n+  private static final int LOCK_SIZE = 1024;\n+  private final int mPageSize;\n+  private final long mCacheSize;\n+  private final CacheEvictor mEvictor;\n+  /** A readwrite lock pool to guard individual pages based on striping. */\n+  private final ReadWriteLock[] mPageLocks = new ReentrantReadWriteLock[LOCK_SIZE];\n+  private final PageStore mPageStore;\n+  /** A readwrite lock to guard metadata operations. */\n+  private final ReadWriteLock mMetaLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"mMetaLock\")\n+  private final MetaStore mMetaStore;\n+  private final FileSystemContext mFsContext;\n \n-  public LocalCacheManager() {\n+  /**\n+   * @param fsContext filesystem context\n+   */\n+  public LocalCacheManager(FileSystemContext fsContext) {\n+    this(fsContext, new MetaStore(), PageStore.create(), CacheEvictor.create());\n   }\n \n-  @Override\n-  public int put(long fileId, long pageId, byte[] page) throws IOException {\n-    mMetaStore.addPage(pageId);\n-    mPageStore.put(fileId, pageId, page);\n-    return 0;\n+  /**\n+   * @param fsContext filesystem context\n+   */\n+  @VisibleForTesting\n+  LocalCacheManager(FileSystemContext fsContext, MetaStore metaStore,\n+                    PageStore pageStore, CacheEvictor evictor) {\n+    mFsContext = fsContext;\n+    mMetaStore = metaStore;\n+    mPageStore = pageStore;\n+    mEvictor = evictor;\n+    mPageSize = (int) mFsContext.getClusterConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mCacheSize = mFsContext.getClusterConf().getBytes(PropertyKey.USER_CLIENT_CACHE_SIZE)\n+        / mPageSize;\n+    for (int i = 0; i < LOCK_SIZE; i++) {\n+      mPageLocks[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  /**\n+   * Gets the lock for a particular page. Note that multiple pages may share the same lock as lock\n+   * striping is used to reduce resource overhead for locks.\n+   *\n+   * @param fileId file identifier\n+   * @param pageIndex index of the page within the file\n+   * @return the corresponding page lock\n+   */\n+  private ReadWriteLock getPageLock(long fileId, long pageIndex) {\n+    return mPageLocks[(int) (fileId + pageIndex) % LOCK_SIZE];\n+  }\n+\n+  /**\n+   * Gets a pair of locks to operate two given pages. One MUST acquire the first lock followed by\n+   * the second lock.\n+   *\n+   * @param fileId file identifier\n+   * @param pageIndex index of the page within the file\n+   * @param fileId2 file identifier\n+   * @param pageIndex2 index of the page within the file\n+   * @return the corresponding page lock pair\n+   */\n+  private Pair<ReadWriteLock, ReadWriteLock> getPageLockPair(long fileId, long pageIndex,\n+      long fileId2, long pageIndex2) {\n+    if (fileId + pageIndex < fileId2 + pageIndex2) {\n+      return new Pair<>(getPageLock(fileId, pageIndex), getPageLock(fileId2, pageIndex2));\n+    } else {\n+      return new Pair<>(getPageLock(fileId2, pageIndex2), getPageLock(fileId, pageIndex));\n+    }\n   }\n \n   @Override\n-  public ReadableByteChannel get(long fileId, long pageId) throws IOException {\n-    if (!mMetaStore.hasPage(pageId)) {\n+  public void put(long fileId, long pageIndex, byte[] page) throws IOException {\n+    long victimFileId = 0;\n+    long victimPageIndex = 0;\n \n+    ReadWriteLock pageLock = getPageLock(fileId, pageIndex);\n+    try (LockResource r = new LockResource(pageLock.writeLock())) {\n+      boolean alreadyCached;\n+      boolean needEvict = false;\n+      try (LockResource r2 = new LockResource(mMetaLock.writeLock())) {\n+        alreadyCached = mMetaStore.hasPage(fileId, pageIndex);\n+        if (!alreadyCached) {\n+          needEvict = mPageStore.size() + 1 > mCacheSize;\n+          if (needEvict) {\n+            Pair<Long, Long> victim = mEvictor.evict();\n+            victimFileId = victim.getFirst();\n+            victimPageIndex = victim.getSecond();\n+          } else {\n+            mMetaStore.addPage(fileId, pageIndex);\n+          }\n+        }\n+      }\n+      if (alreadyCached) {\n+        try {\n+          mPageStore.delete(fileId, pageIndex);\n+        } catch (PageNotFoundException e) {\n+          // this should never happen with proper locking\n+          LOG.error(\"failed to delete page {} {} from page store\", fileId, pageIndex, e);\n+        }\n+        mEvictor.updateOnPut(fileId, pageIndex);\n+        mPageStore.put(fileId, pageIndex, page);\n+      } else if (!needEvict) {\n+        mEvictor.updateOnPut(fileId, pageIndex);\n+        mPageStore.put(fileId, pageIndex, page);\n+      }\n     }\n-    mEvictor.updateOnGet(pageId);\n-    return null;\n+\n+    Pair<ReadWriteLock, ReadWriteLock> pageLockPair =\n+        getPageLockPair(fileId, pageIndex, victimFileId, victimPageIndex);\n+    try (LockResource r1 = new LockResource(pageLockPair.getFirst().writeLock());\n+        LockResource r2 = new LockResource(pageLockPair.getSecond().writeLock())) {\n+      try (LockResource r3 = new LockResource(mMetaLock.writeLock())) {\n+        if (mMetaStore.hasPage(fileId, pageIndex)) {\n+          LOG.warn(\"fileId {} pageIndex {} is already inserted by a racing thread\",\n+              fileId, pageIndex);\n+          return;\n+        }\n+        if (!mMetaStore.hasPage(victimFileId, victimPageIndex)) {\n+          LOG.warn(\"fileId {} pageIndex {} is already evicted by a racing thread\",\n+              fileId, pageIndex);\n+          return;\n+        }\n+        try {\n+          mMetaStore.removePage(victimFileId, victimPageIndex);\n+        } catch (PageNotFoundException e) {\n+          // this should never happen with proper locking\n+          LOG.error(\"failed to remove page {} {} from meta store\",\n+              victimFileId, victimPageIndex, e);\n+        }", "originalCommit": "cadc31fb47fcdbcd1a3b401bcbd8a82c3049d60c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3ODcwNA==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365478704", "bodyText": "Yeah we can throw IllegalStateException instead.", "author": "bf8086", "createdAt": "2020-01-11T00:18:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3ODIwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3ODk5Ng==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365478996", "bodyText": "Could you update the page size constant used in LocalCacheFileInStream?", "author": "calvinjia", "createdAt": "2020-01-11T00:19:55Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -11,53 +11,240 @@\n \n package alluxio.client.file.cache;\n \n-import alluxio.client.file.cache.store.PageNotFoundException;\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.zookeeper.server.ByteBufferInputStream;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Channels;\n import java.nio.channels.ReadableByteChannel;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n+import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n /**\n- * A class to manage cached pages. This class will\n- * 1. Ensure thread-safety\n- * 2. Bookkeep Cache Replacement Alg\n+ * A class to manage cached pages. This class coordinates different components to respond for\n+ * thread-safety and operate cache replacement policies.\n  *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ul>\n+ * <li>1. Acquire page lock</li>\n+ * <li>2. Acquire metastore lock mMetaLock</li>\n+ * <li>3. Release metastore lock mMetaLock</li>\n+ * <li>4. Release page lock</li>\n+ * </ul>\n  */\n @ThreadSafe\n public class LocalCacheManager implements CacheManager {\n   private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n \n-  private final CacheEvictor mEvictor = CacheEvictor.create();\n-  private final PageStore mPageStore = PageStore.create();\n-  private final MetaStore mMetaStore = new MetaStore();\n+  private static final int LOCK_SIZE = 1024;\n+  private final int mPageSize;\n+  private final long mCacheSize;\n+  private final CacheEvictor mEvictor;\n+  /** A readwrite lock pool to guard individual pages based on striping. */\n+  private final ReadWriteLock[] mPageLocks = new ReentrantReadWriteLock[LOCK_SIZE];\n+  private final PageStore mPageStore;\n+  /** A readwrite lock to guard metadata operations. */\n+  private final ReadWriteLock mMetaLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"mMetaLock\")\n+  private final MetaStore mMetaStore;\n+  private final FileSystemContext mFsContext;\n \n-  public LocalCacheManager() {\n+  /**\n+   * @param fsContext filesystem context\n+   */\n+  public LocalCacheManager(FileSystemContext fsContext) {\n+    this(fsContext, new MetaStore(), PageStore.create(), CacheEvictor.create());\n   }\n \n-  @Override\n-  public int put(long fileId, long pageId, byte[] page) throws IOException {\n-    mMetaStore.addPage(pageId);\n-    mPageStore.put(fileId, pageId, page);\n-    return 0;\n+  /**\n+   * @param fsContext filesystem context\n+   */\n+  @VisibleForTesting\n+  LocalCacheManager(FileSystemContext fsContext, MetaStore metaStore,\n+                    PageStore pageStore, CacheEvictor evictor) {\n+    mFsContext = fsContext;\n+    mMetaStore = metaStore;\n+    mPageStore = pageStore;\n+    mEvictor = evictor;\n+    mPageSize = (int) mFsContext.getClusterConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);", "originalCommit": "cadc31fb47fcdbcd1a3b401bcbd8a82c3049d60c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4NTE0MA==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365485140", "bodyText": "Updated.", "author": "bf8086", "createdAt": "2020-01-11T01:02:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3ODk5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3ODQ4NQ==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365478485", "bodyText": "incorrect javadoc with missing params", "author": "apc999", "createdAt": "2020-01-11T00:16:27Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -11,53 +11,240 @@\n \n package alluxio.client.file.cache;\n \n-import alluxio.client.file.cache.store.PageNotFoundException;\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.zookeeper.server.ByteBufferInputStream;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Channels;\n import java.nio.channels.ReadableByteChannel;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n+import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n /**\n- * A class to manage cached pages. This class will\n- * 1. Ensure thread-safety\n- * 2. Bookkeep Cache Replacement Alg\n+ * A class to manage cached pages. This class coordinates different components to respond for\n+ * thread-safety and operate cache replacement policies.\n  *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ul>\n+ * <li>1. Acquire page lock</li>\n+ * <li>2. Acquire metastore lock mMetaLock</li>\n+ * <li>3. Release metastore lock mMetaLock</li>\n+ * <li>4. Release page lock</li>\n+ * </ul>\n  */\n @ThreadSafe\n public class LocalCacheManager implements CacheManager {\n   private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n \n-  private final CacheEvictor mEvictor = CacheEvictor.create();\n-  private final PageStore mPageStore = PageStore.create();\n-  private final MetaStore mMetaStore = new MetaStore();\n+  private static final int LOCK_SIZE = 1024;\n+  private final int mPageSize;\n+  private final long mCacheSize;\n+  private final CacheEvictor mEvictor;\n+  /** A readwrite lock pool to guard individual pages based on striping. */\n+  private final ReadWriteLock[] mPageLocks = new ReentrantReadWriteLock[LOCK_SIZE];\n+  private final PageStore mPageStore;\n+  /** A readwrite lock to guard metadata operations. */\n+  private final ReadWriteLock mMetaLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"mMetaLock\")\n+  private final MetaStore mMetaStore;\n+  private final FileSystemContext mFsContext;\n \n-  public LocalCacheManager() {\n+  /**\n+   * @param fsContext filesystem context\n+   */\n+  public LocalCacheManager(FileSystemContext fsContext) {\n+    this(fsContext, new MetaStore(), PageStore.create(), CacheEvictor.create());\n   }\n \n-  @Override\n-  public int put(long fileId, long pageId, byte[] page) throws IOException {\n-    mMetaStore.addPage(pageId);\n-    mPageStore.put(fileId, pageId, page);\n-    return 0;\n+  /**\n+   * @param fsContext filesystem context", "originalCommit": "cadc31fb47fcdbcd1a3b401bcbd8a82c3049d60c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4NTAxNg==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365485016", "bodyText": "Fixed.", "author": "bf8086", "createdAt": "2020-01-11T01:01:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3ODQ4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3OTAxNA==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365479014", "bodyText": "return null. using Exceptions for control flow is undesired.", "author": "apc999", "createdAt": "2020-01-11T00:20:03Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -11,53 +11,240 @@\n \n package alluxio.client.file.cache;\n \n-import alluxio.client.file.cache.store.PageNotFoundException;\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.zookeeper.server.ByteBufferInputStream;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Channels;\n import java.nio.channels.ReadableByteChannel;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n+import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n /**\n- * A class to manage cached pages. This class will\n- * 1. Ensure thread-safety\n- * 2. Bookkeep Cache Replacement Alg\n+ * A class to manage cached pages. This class coordinates different components to respond for\n+ * thread-safety and operate cache replacement policies.\n  *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ul>\n+ * <li>1. Acquire page lock</li>\n+ * <li>2. Acquire metastore lock mMetaLock</li>\n+ * <li>3. Release metastore lock mMetaLock</li>\n+ * <li>4. Release page lock</li>\n+ * </ul>\n  */\n @ThreadSafe\n public class LocalCacheManager implements CacheManager {\n   private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n \n-  private final CacheEvictor mEvictor = CacheEvictor.create();\n-  private final PageStore mPageStore = PageStore.create();\n-  private final MetaStore mMetaStore = new MetaStore();\n+  private static final int LOCK_SIZE = 1024;\n+  private final int mPageSize;\n+  private final long mCacheSize;\n+  private final CacheEvictor mEvictor;\n+  /** A readwrite lock pool to guard individual pages based on striping. */\n+  private final ReadWriteLock[] mPageLocks = new ReentrantReadWriteLock[LOCK_SIZE];\n+  private final PageStore mPageStore;\n+  /** A readwrite lock to guard metadata operations. */\n+  private final ReadWriteLock mMetaLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"mMetaLock\")\n+  private final MetaStore mMetaStore;\n+  private final FileSystemContext mFsContext;\n \n-  public LocalCacheManager() {\n+  /**\n+   * @param fsContext filesystem context\n+   */\n+  public LocalCacheManager(FileSystemContext fsContext) {\n+    this(fsContext, new MetaStore(), PageStore.create(), CacheEvictor.create());\n   }\n \n-  @Override\n-  public int put(long fileId, long pageId, byte[] page) throws IOException {\n-    mMetaStore.addPage(pageId);\n-    mPageStore.put(fileId, pageId, page);\n-    return 0;\n+  /**\n+   * @param fsContext filesystem context\n+   */\n+  @VisibleForTesting\n+  LocalCacheManager(FileSystemContext fsContext, MetaStore metaStore,\n+                    PageStore pageStore, CacheEvictor evictor) {\n+    mFsContext = fsContext;\n+    mMetaStore = metaStore;\n+    mPageStore = pageStore;\n+    mEvictor = evictor;\n+    mPageSize = (int) mFsContext.getClusterConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mCacheSize = mFsContext.getClusterConf().getBytes(PropertyKey.USER_CLIENT_CACHE_SIZE)\n+        / mPageSize;\n+    for (int i = 0; i < LOCK_SIZE; i++) {\n+      mPageLocks[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  /**\n+   * Gets the lock for a particular page. Note that multiple pages may share the same lock as lock\n+   * striping is used to reduce resource overhead for locks.\n+   *\n+   * @param fileId file identifier\n+   * @param pageIndex index of the page within the file\n+   * @return the corresponding page lock\n+   */\n+  private ReadWriteLock getPageLock(long fileId, long pageIndex) {\n+    return mPageLocks[(int) (fileId + pageIndex) % LOCK_SIZE];\n+  }\n+\n+  /**\n+   * Gets a pair of locks to operate two given pages. One MUST acquire the first lock followed by\n+   * the second lock.\n+   *\n+   * @param fileId file identifier\n+   * @param pageIndex index of the page within the file\n+   * @param fileId2 file identifier\n+   * @param pageIndex2 index of the page within the file\n+   * @return the corresponding page lock pair\n+   */\n+  private Pair<ReadWriteLock, ReadWriteLock> getPageLockPair(long fileId, long pageIndex,\n+      long fileId2, long pageIndex2) {\n+    if (fileId + pageIndex < fileId2 + pageIndex2) {\n+      return new Pair<>(getPageLock(fileId, pageIndex), getPageLock(fileId2, pageIndex2));\n+    } else {\n+      return new Pair<>(getPageLock(fileId2, pageIndex2), getPageLock(fileId, pageIndex));\n+    }\n   }\n \n   @Override\n-  public ReadableByteChannel get(long fileId, long pageId) throws IOException {\n-    if (!mMetaStore.hasPage(pageId)) {\n+  public void put(long fileId, long pageIndex, byte[] page) throws IOException {\n+    long victimFileId = 0;\n+    long victimPageIndex = 0;\n \n+    ReadWriteLock pageLock = getPageLock(fileId, pageIndex);\n+    try (LockResource r = new LockResource(pageLock.writeLock())) {\n+      boolean alreadyCached;\n+      boolean needEvict = false;\n+      try (LockResource r2 = new LockResource(mMetaLock.writeLock())) {\n+        alreadyCached = mMetaStore.hasPage(fileId, pageIndex);\n+        if (!alreadyCached) {\n+          needEvict = mPageStore.size() + 1 > mCacheSize;\n+          if (needEvict) {\n+            Pair<Long, Long> victim = mEvictor.evict();\n+            victimFileId = victim.getFirst();\n+            victimPageIndex = victim.getSecond();\n+          } else {\n+            mMetaStore.addPage(fileId, pageIndex);\n+          }\n+        }\n+      }\n+      if (alreadyCached) {\n+        try {\n+          mPageStore.delete(fileId, pageIndex);\n+        } catch (PageNotFoundException e) {\n+          // this should never happen with proper locking\n+          LOG.error(\"failed to delete page {} {} from page store\", fileId, pageIndex, e);\n+        }\n+        mEvictor.updateOnPut(fileId, pageIndex);\n+        mPageStore.put(fileId, pageIndex, page);\n+      } else if (!needEvict) {\n+        mEvictor.updateOnPut(fileId, pageIndex);\n+        mPageStore.put(fileId, pageIndex, page);\n+      }\n     }\n-    mEvictor.updateOnGet(pageId);\n-    return null;\n+\n+    Pair<ReadWriteLock, ReadWriteLock> pageLockPair =\n+        getPageLockPair(fileId, pageIndex, victimFileId, victimPageIndex);\n+    try (LockResource r1 = new LockResource(pageLockPair.getFirst().writeLock());\n+        LockResource r2 = new LockResource(pageLockPair.getSecond().writeLock())) {\n+      try (LockResource r3 = new LockResource(mMetaLock.writeLock())) {\n+        if (mMetaStore.hasPage(fileId, pageIndex)) {\n+          LOG.warn(\"fileId {} pageIndex {} is already inserted by a racing thread\",\n+              fileId, pageIndex);\n+          return;\n+        }\n+        if (!mMetaStore.hasPage(victimFileId, victimPageIndex)) {\n+          LOG.warn(\"fileId {} pageIndex {} is already evicted by a racing thread\",\n+              fileId, pageIndex);\n+          return;\n+        }\n+        try {\n+          mMetaStore.removePage(victimFileId, victimPageIndex);\n+        } catch (PageNotFoundException e) {\n+          // this should never happen with proper locking\n+          LOG.error(\"failed to remove page {} {} from meta store\",\n+              victimFileId, victimPageIndex, e);\n+        }\n+        mEvictor.updateOnDelete(victimFileId, victimPageIndex);\n+        mMetaStore.addPage(fileId, pageIndex);\n+        mEvictor.updateOnPut(fileId, pageIndex);\n+      }\n+      try {\n+        mPageStore.delete(victimFileId, victimPageIndex);\n+      } catch (PageNotFoundException e) {\n+        // this should never happen with proper locking\n+        LOG.error(\"failed to delete page {} {} from page store\", victimFileId, victimPageIndex, e);\n+      }\n+      mPageStore.put(fileId, pageIndex, page);\n+    }\n+  }\n+\n+  @Override\n+  public ReadableByteChannel get(long fileId, long pageIndex) throws IOException,\n+      PageNotFoundException {\n+    return get(fileId, pageIndex, 0, mPageSize);\n   }\n \n   @Override\n-  public boolean delete(long fileId, long pageId) throws IOException, PageNotFoundException {\n-    mMetaStore.removePage(pageId);\n-    mPageStore.delete(fileId, pageId);\n-    return false;\n+  public ReadableByteChannel get(long fileId, long pageIndex, int pageOffset, int length)\n+      throws IOException, PageNotFoundException {\n+    Preconditions.checkArgument(pageOffset + length <= mPageSize,\n+        \"Read exceeds page boundary: offset=%s length=%s, size=%s\", pageOffset, length, mPageSize);\n+    ReadableByteChannel ret;\n+    boolean hasPage;\n+    ReadWriteLock pageLock = getPageLock(fileId, pageIndex);\n+    try (LockResource r = new LockResource(pageLock.readLock())) {\n+      try (LockResource r2 = new LockResource(mMetaLock.readLock())) {\n+        hasPage = mMetaStore.hasPage(fileId, pageIndex);\n+      }\n+      if (!hasPage) {\n+        throw new PageNotFoundException(", "originalCommit": "cadc31fb47fcdbcd1a3b401bcbd8a82c3049d60c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4NDk5Mg==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365484992", "bodyText": "Refactored.", "author": "bf8086", "createdAt": "2020-01-11T01:01:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3OTAxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3OTE3NQ==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365479175", "bodyText": "we typically put all Alluxio exceptions together rather than leaving them  in different packages.", "author": "apc999", "createdAt": "2020-01-11T00:21:07Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/PageNotFoundException.java", "diffHunk": "@@ -10,7 +10,7 @@\n  *\n  */\n \n-package alluxio.client.file.cache.store;\n+package alluxio.client.file.cache;", "originalCommit": "cadc31fb47fcdbcd1a3b401bcbd8a82c3049d60c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4NDg0Ng==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365484846", "bodyText": "Moved.", "author": "bf8086", "createdAt": "2020-01-11T00:59:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3OTE3NQ=="}], "type": "inlineReview"}, {"oid": "2520b69d6575df495504ac068ce8fc1fde9689aa", "url": "https://github.com/Alluxio/alluxio/commit/2520b69d6575df495504ac068ce8fc1fde9689aa", "message": "address comments", "committedDate": "2020-01-11T00:57:01Z", "type": "commit"}, {"oid": "e2c449d63423d31d86a74385f171d47657c5bb35", "url": "https://github.com/Alluxio/alluxio/commit/e2c449d63423d31d86a74385f171d47657c5bb35", "message": "throw exception on missing page", "committedDate": "2020-01-11T01:06:11Z", "type": "commit"}, {"oid": "c0342b0759cf83f54f03a9a262646b11555ce923", "url": "https://github.com/Alluxio/alluxio/commit/c0342b0759cf83f54f03a9a262646b11555ce923", "message": "remove length from get parameter", "committedDate": "2020-01-11T01:22:20Z", "type": "commit"}, {"oid": "820d2d285ea7718f32b0d84939babe55efbf7706", "url": "https://github.com/Alluxio/alluxio/commit/820d2d285ea7718f32b0d84939babe55efbf7706", "message": "create page id object", "committedDate": "2020-01-11T05:34:02Z", "type": "commit"}, {"oid": "5c6f08423f98d85cb4ede4fe74f560c39a38a3f2", "url": "https://github.com/Alluxio/alluxio/commit/5c6f08423f98d85cb4ede4fe74f560c39a38a3f2", "message": "More cleanup", "committedDate": "2020-01-12T06:23:35Z", "type": "commit"}]}