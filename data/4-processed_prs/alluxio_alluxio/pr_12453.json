{"pr_number": 12453, "pr_title": "Improve concurrent read performance through RPC", "pr_createdAt": "2020-11-03T05:55:19Z", "pr_url": "https://github.com/Alluxio/alluxio/pull/12453", "timeline": [{"oid": "74b484b67727b55357893f2e51dd02ffda5ee38a", "url": "https://github.com/Alluxio/alluxio/commit/74b484b67727b55357893f2e51dd02ffda5ee38a", "message": "fix multi-process read perf issue\n\nCo-authored-by: bastrik <rzhang56@illinois.edu>", "committedDate": "2020-11-03T05:52:06Z", "type": "commit"}, {"oid": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "url": "https://github.com/Alluxio/alluxio/commit/990e3df845d5dfaf8b750a899e2dfb825096cf79", "message": "fix multiple process read perf issue, by creating shared grpc data reader\n\nCo-authored-by: bastrik <rzhang56@illinois.edu>", "committedDate": "2020-11-03T05:53:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4Mjg1MA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517082850", "bodyText": "What's the performance difference (rough numbers are enough) in the following scenario compared to original impl\n\nsingle process Fuse read with NaiveSharedGrpcDataReader\nSingle process Fuse read without NaiveSharedGrpcDataReader\nMultiple (four) processes Fuse read with NaiveSharedGrpcDataReader\nMultiple (four) processes Fuse read without NaiveSharedGrpcDataReader", "author": "LuQQiu", "createdAt": "2020-11-04T03:49:52Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java", "diffHunk": "@@ -337,8 +341,42 @@ public void seek(long pos) throws IOException {\n     }\n     if (pos < mPos) {\n       mEOF = false;\n+      if (mDataReader instanceof NaiveSharedGrpcDataReader) {\n+        NaiveSharedGrpcDataReader reader = (NaiveSharedGrpcDataReader)mDataReader;\n+        reader.seek(pos);\n+        if (mCurrentChunk != null) {\n+          mCurrentChunk.release();\n+          mCurrentChunk = null;\n+        }\n+      } else {\n+        closeDataReader();\n+      }\n+    } else if (pos < mLength) {\n+      // Try to read data already in queue\n+      long curPos = mPos;\n+      while (mCurrentChunk != null && curPos < pos) {\n+        long nextPos = curPos + mCurrentChunk.readableBytes();\n+        if (nextPos <= pos) {\n+          curPos = nextPos; \n+          mCurrentChunk.release();\n+          mCurrentChunk = mDataReader.readChunkNoWait();\n+        } else {\n+          // TODO introduce seek in DataBuffer\n+          int toRead = (int)(pos - curPos);\n+          final byte[] b = new byte[toRead];\n+          mCurrentChunk.readBytes(b, 0, toRead);\n+          curPos = pos;\n+        }\n+      }\n+\n+      if (curPos < pos) {", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI2OTIwNA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518269204", "bodyText": "Just have some rough number:\n\nSingle process fuse read\nNaivceDataReader -> 11s\nGrpcDataReader -> 18 ~ 20 s\n4 processes\nNaiveDataReader -> 20s\nGrpcDataReader -> 500 ~ 600 s, 1600s in worst case\n\nBy the way, if with code change in BlockInStream.seek + GrpcDataReader, single process perf is 20s, and 4 process read perf is 140 ~ 150s", "author": "chaowangnk1", "createdAt": "2020-11-05T18:24:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4Mjg1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4MzgyNA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517083824", "bodyText": "Change to NaiveCachedGrpcDataReader then will be easier to debug", "author": "LuQQiu", "createdAt": "2020-11-04T03:54:30Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.DataMessage;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import alluxio.resource.LockResource;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that streams a region from gRPC data server.\n+ *\n+ * Protocol:\n+ * 1. The client sends a read request (id, offset, length).\n+ * 2. Once the server receives the request, it streams chunks to the client. The streaming pauses\n+ *    if the server's buffer is full and resumes if the buffer is not full.\n+ * 3. The client reads chunks from the stream using an iterator.\n+ * 4. The client can cancel the read request at anytime. The cancel request is ignored by the\n+ *    server if everything has been sent to channel.\n+ * 5. To make it simple to handle errors, the channel is closed if any error occurs.\n+ */\n+@NotThreadSafe\n+public final class NaiveCachedGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveCachedGrpcDataReader.class);\n+\n+  private final int mReaderBufferSizeMessages;\n+  private final long mDataTimeoutMs;\n+  private final FileSystemContext mContext;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final ReadRequest mReadRequest;\n+  private final WorkerNetAddress mAddress;\n+\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+\n+  private final DataBuffer[] mDataBuffers; \n+  private int mBufferCount = 0;\n+  private final ReentrantReadWriteLock mBufferLocks = new ReentrantReadWriteLock();\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+\n+  /**\n+   * Creates an instance of {@link NaiveCachedGrpcDataReader}.\n+   *\n+   * @param context the file system context\n+   * @param address the data server address\n+   * @param readRequest the read request\n+   */\n+  public NaiveCachedGrpcDataReader(FileSystemContext context, WorkerNetAddress address,\n+      ReadRequest readRequest) throws IOException {\n+    mContext = context;\n+    mAddress = address;\n+    mPosToRead = readRequest.getOffset();\n+    mReadRequest = readRequest;\n+    AlluxioConfiguration alluxioConf = context.getClusterConf();\n+    mReaderBufferSizeMessages = alluxioConf\n+        .getInt(PropertyKey.USER_STREAMING_READER_BUFFER_SIZE_MESSAGES);\n+    mDataTimeoutMs = alluxioConf.getMs(PropertyKey.USER_STREAMING_DATA_TIMEOUT);\n+    mMarshaller = new ReadResponseMarshaller();\n+    mClient = mContext.acquireBlockWorkerClient(address);\n+    long blockSize = readRequest.getLength() + readRequest.getOffset();\n+    long chunkSize = readRequest.getChunkSize();\n+    int buffCount = (int)(blockSize / chunkSize);\n+    if ((blockSize % chunkSize) != 0) {\n+      buffCount += 1;\n+    }\n+    mDataBuffers = new DataBuffer[buffCount];\n+\n+    try {\n+      String desc = \"GrpcDataReader\";", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4NjczMA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517086730", "bodyText": "Why remove the part for GrpcDataMessagingBlockingStream?", "author": "LuQQiu", "createdAt": "2020-11-04T04:07:59Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.DataMessage;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import alluxio.resource.LockResource;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that streams a region from gRPC data server.\n+ *\n+ * Protocol:\n+ * 1. The client sends a read request (id, offset, length).\n+ * 2. Once the server receives the request, it streams chunks to the client. The streaming pauses\n+ *    if the server's buffer is full and resumes if the buffer is not full.\n+ * 3. The client reads chunks from the stream using an iterator.\n+ * 4. The client can cancel the read request at anytime. The cancel request is ignored by the\n+ *    server if everything has been sent to channel.\n+ * 5. To make it simple to handle errors, the channel is closed if any error occurs.\n+ */\n+@NotThreadSafe\n+public final class NaiveCachedGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveCachedGrpcDataReader.class);\n+\n+  private final int mReaderBufferSizeMessages;\n+  private final long mDataTimeoutMs;\n+  private final FileSystemContext mContext;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final ReadRequest mReadRequest;\n+  private final WorkerNetAddress mAddress;\n+\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+\n+  private final DataBuffer[] mDataBuffers; \n+  private int mBufferCount = 0;\n+  private final ReentrantReadWriteLock mBufferLocks = new ReentrantReadWriteLock();\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+\n+  /**\n+   * Creates an instance of {@link NaiveCachedGrpcDataReader}.\n+   *\n+   * @param context the file system context\n+   * @param address the data server address\n+   * @param readRequest the read request\n+   */\n+  public NaiveCachedGrpcDataReader(FileSystemContext context, WorkerNetAddress address,\n+      ReadRequest readRequest) throws IOException {\n+    mContext = context;\n+    mAddress = address;\n+    mPosToRead = readRequest.getOffset();\n+    mReadRequest = readRequest;\n+    AlluxioConfiguration alluxioConf = context.getClusterConf();\n+    mReaderBufferSizeMessages = alluxioConf\n+        .getInt(PropertyKey.USER_STREAMING_READER_BUFFER_SIZE_MESSAGES);\n+    mDataTimeoutMs = alluxioConf.getMs(PropertyKey.USER_STREAMING_DATA_TIMEOUT);\n+    mMarshaller = new ReadResponseMarshaller();\n+    mClient = mContext.acquireBlockWorkerClient(address);\n+    long blockSize = readRequest.getLength() + readRequest.getOffset();\n+    long chunkSize = readRequest.getChunkSize();\n+    int buffCount = (int)(blockSize / chunkSize);\n+    if ((blockSize % chunkSize) != 0) {\n+      buffCount += 1;\n+    }\n+    mDataBuffers = new DataBuffer[buffCount];\n+\n+    try {\n+      String desc = \"GrpcDataReader\";\n+      if (LOG.isDebugEnabled()) { // More detailed description when debug logging is enabled\n+        desc = MoreObjects.toStringHelper(this)\n+          .add(\"request\", mReadRequest)\n+          .add(\"address\", address)\n+          .toString();\n+      }\n+      mStream = new GrpcBlockingStream<>(mClient.get()::readBlock, mReaderBufferSizeMessages,\n+          desc);\n+      mStream.send(mReadRequest, mDataTimeoutMs);\n+    } catch (Exception e) {\n+      mClient.close();\n+      throw e;\n+    }\n+  }\n+\n+  public DataBuffer readChunk(int index) throws IOException {\n+    if (index >= mDataBuffers.length) {\n+      return null;\n+    }\n+    \n+    try (LockResource r1 = new LockResource(mBufferLocks.writeLock())) {\n+      while (index >= mBufferCount) {\n+        DataBuffer buffer = readChunk();\n+        mDataBuffers[mBufferCount] = buffer;\n+        ++mBufferCount;\n+      }\n+    }\n+\n+    return mDataBuffers[index];\n+  }\n+\n+  private DataBuffer readChunk() throws IOException {", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcwMjM0OA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517702348", "bodyText": "GrpcDataMessagingBlockingStream can't be used here.\nDataBuffer.getReadOnlyByteBuffer is used to clone a copy in SharedDataReader.readChunk. getReadOnlyByteBuffer is not implemented in DataBuffer returned from GrpcDataMessagingBlockingStream.", "author": "chaowangnk1", "createdAt": "2020-11-05T00:00:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4NjczMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU0NjU2Nw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517546567", "bodyText": "if the client's buffer is full?", "author": "LuQQiu", "createdAt": "2020-11-04T18:27:13Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.DataMessage;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import alluxio.resource.LockResource;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that streams a region from gRPC data server.\n+ *\n+ * Protocol:\n+ * 1. The client sends a read request (id, offset, length).\n+ * 2. Once the server receives the request, it streams chunks to the client. The streaming pauses\n+ *    if the server's buffer is full and resumes if the buffer is not full.", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU0NzYyMw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517547623", "bodyText": "Will we add a mechanism to limit the available buffer used for the NaiveReader and make the available buffer configurable? Can be done in future PRs.\nKind of worry about the data reader introduces the client-side OOM issue.", "author": "LuQQiu", "createdAt": "2020-11-04T18:29:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU0NjU2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU2MjA4MA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517562080", "bodyText": "if index < mBufferCount, no need to lock?", "author": "LuQQiu", "createdAt": "2020-11-04T18:54:32Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.DataMessage;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import alluxio.resource.LockResource;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that streams a region from gRPC data server.\n+ *\n+ * Protocol:\n+ * 1. The client sends a read request (id, offset, length).\n+ * 2. Once the server receives the request, it streams chunks to the client. The streaming pauses\n+ *    if the server's buffer is full and resumes if the buffer is not full.\n+ * 3. The client reads chunks from the stream using an iterator.\n+ * 4. The client can cancel the read request at anytime. The cancel request is ignored by the\n+ *    server if everything has been sent to channel.\n+ * 5. To make it simple to handle errors, the channel is closed if any error occurs.\n+ */\n+@NotThreadSafe\n+public final class NaiveCachedGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveCachedGrpcDataReader.class);\n+\n+  private final int mReaderBufferSizeMessages;\n+  private final long mDataTimeoutMs;\n+  private final FileSystemContext mContext;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final ReadRequest mReadRequest;\n+  private final WorkerNetAddress mAddress;\n+\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+\n+  private final DataBuffer[] mDataBuffers; \n+  private int mBufferCount = 0;\n+  private final ReentrantReadWriteLock mBufferLocks = new ReentrantReadWriteLock();\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+\n+  /**\n+   * Creates an instance of {@link NaiveCachedGrpcDataReader}.\n+   *\n+   * @param context the file system context\n+   * @param address the data server address\n+   * @param readRequest the read request\n+   */\n+  public NaiveCachedGrpcDataReader(FileSystemContext context, WorkerNetAddress address,\n+      ReadRequest readRequest) throws IOException {\n+    mContext = context;\n+    mAddress = address;\n+    mPosToRead = readRequest.getOffset();\n+    mReadRequest = readRequest;\n+    AlluxioConfiguration alluxioConf = context.getClusterConf();\n+    mReaderBufferSizeMessages = alluxioConf\n+        .getInt(PropertyKey.USER_STREAMING_READER_BUFFER_SIZE_MESSAGES);\n+    mDataTimeoutMs = alluxioConf.getMs(PropertyKey.USER_STREAMING_DATA_TIMEOUT);\n+    mMarshaller = new ReadResponseMarshaller();\n+    mClient = mContext.acquireBlockWorkerClient(address);\n+    long blockSize = readRequest.getLength() + readRequest.getOffset();\n+    long chunkSize = readRequest.getChunkSize();\n+    int buffCount = (int)(blockSize / chunkSize);\n+    if ((blockSize % chunkSize) != 0) {\n+      buffCount += 1;\n+    }\n+    mDataBuffers = new DataBuffer[buffCount];\n+\n+    try {\n+      String desc = \"GrpcDataReader\";\n+      if (LOG.isDebugEnabled()) { // More detailed description when debug logging is enabled\n+        desc = MoreObjects.toStringHelper(this)\n+          .add(\"request\", mReadRequest)\n+          .add(\"address\", address)\n+          .toString();\n+      }\n+      mStream = new GrpcBlockingStream<>(mClient.get()::readBlock, mReaderBufferSizeMessages,\n+          desc);\n+      mStream.send(mReadRequest, mDataTimeoutMs);\n+    } catch (Exception e) {\n+      mClient.close();\n+      throw e;\n+    }\n+  }\n+\n+  public DataBuffer readChunk(int index) throws IOException {\n+    if (index >= mDataBuffers.length) {\n+      return null;\n+    }\n+    \n+    try (LockResource r1 = new LockResource(mBufferLocks.writeLock())) {", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI3MDc0Mw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518270743", "bodyText": "Good point, that could save some runtime", "author": "chaowangnk1", "createdAt": "2020-11-05T18:27:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU2MjA4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY3Njg0Mg==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517676842", "bodyText": "isn't this case (pos < mLength) given? since we asserted pos <= mLength and return on pos == mLength", "author": "apc999", "createdAt": "2020-11-04T22:48:25Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java", "diffHunk": "@@ -337,8 +341,42 @@ public void seek(long pos) throws IOException {\n     }\n     if (pos < mPos) {\n       mEOF = false;\n+      if (mDataReader instanceof NaiveSharedGrpcDataReader) {\n+        NaiveSharedGrpcDataReader reader = (NaiveSharedGrpcDataReader)mDataReader;\n+        reader.seek(pos);\n+        if (mCurrentChunk != null) {\n+          mCurrentChunk.release();\n+          mCurrentChunk = null;\n+        }\n+      } else {\n+        closeDataReader();\n+      }\n+    } else if (pos < mLength) {", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI2NTI2Ng==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518265266", "bodyText": "'else' part is for (pos == mLength).  CloseDataReader() is mandatory in this case.\nAnd 'return' is on pos == mPos but not pos == mLength.", "author": "chaowangnk1", "createdAt": "2020-11-05T18:17:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY3Njg0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMwNjk2MA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518306960", "bodyText": "Make sense, changed to else{} directly and remove the original else{} block.", "author": "LuQQiu", "createdAt": "2020-11-05T19:24:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY3Njg0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY3NzYwOA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517677608", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              DataBuffer readChunkNoWait() throws IOException;\n          \n          \n            \n              @Nullable\n          \n          \n            \n              DataBuffer readChunkNoWait() throws IOException;", "author": "apc999", "createdAt": "2020-11-04T22:50:14Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/DataReader.java", "diffHunk": "@@ -28,6 +28,13 @@\n    */\n   DataBuffer readChunk() throws IOException;\n \n+  /**\n+   * Try to read a chunk without waiting for data ready. \n+   *\n+   * @return the data buffer or null if EOF is reached or data is not ready.\n+   */\n+  DataBuffer readChunkNoWait() throws IOException;", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMwNzA3MQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518307071", "bodyText": "Done", "author": "LuQQiu", "createdAt": "2020-11-05T19:24:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY3NzYwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY3OTA4Mg==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517679082", "bodyText": "please complete the javadoc", "author": "apc999", "createdAt": "2020-11-04T22:53:46Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/GrpcBlockingStream.java", "diffHunk": "@@ -172,6 +172,15 @@ public ResT receive(long timeoutMs) throws IOException {\n     }\n   }\n \n+  /**\n+   * Check if there are responses in the queue\n+   * @return ", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMwNzE4Nw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518307187", "bodyText": "Done", "author": "LuQQiu", "createdAt": "2020-11-05T19:25:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY3OTA4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY3OTUwMw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517679503", "bodyText": "mResponses.size() > 0 ?", "author": "apc999", "createdAt": "2020-11-04T22:54:51Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/GrpcBlockingStream.java", "diffHunk": "@@ -172,6 +172,15 @@ public ResT receive(long timeoutMs) throws IOException {\n     }\n   }\n \n+  /**\n+   * Check if there are responses in the queue\n+   * @return \n+   * @throws IOException if any error occurs\n+   */\n+  public boolean hasResponseInCache() {\n+    return mResponses.size() != 0;", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMwNzMyOQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518307329", "bodyText": "Done", "author": "LuQQiu", "createdAt": "2020-11-05T19:25:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY3OTUwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMjIxNA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517712214", "bodyText": "@Nullable", "author": "apc999", "createdAt": "2020-11-05T00:33:05Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/GrpcDataReader.java", "diffHunk": "@@ -161,6 +161,16 @@ public DataBuffer readChunk() throws IOException {\n     return buffer;\n   }\n \n+  @Override\n+  public DataBuffer readChunkNoWait() throws IOException {", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMwNzYyNA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518307624", "bodyText": "Done", "author": "LuQQiu", "createdAt": "2020-11-05T19:25:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMjIxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMzAwMw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517713003", "bodyText": "let's avoid throwing exceptions in a constructor. If this is required, create a static factory method to create an instance which may throw exceptions rather than having it in constructor. Constructor should be lightweight and no requirement to cover its failure case", "author": "apc999", "createdAt": "2020-11-05T00:35:53Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.DataMessage;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import alluxio.resource.LockResource;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that streams a region from gRPC data server.\n+ *\n+ * Protocol:\n+ * 1. The client sends a read request (id, offset, length).\n+ * 2. Once the server receives the request, it streams chunks to the client. The streaming pauses\n+ *    if the server's buffer is full and resumes if the buffer is not full.\n+ * 3. The client reads chunks from the stream using an iterator.\n+ * 4. The client can cancel the read request at anytime. The cancel request is ignored by the\n+ *    server if everything has been sent to channel.\n+ * 5. To make it simple to handle errors, the channel is closed if any error occurs.\n+ */\n+@NotThreadSafe\n+public final class NaiveCachedGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveCachedGrpcDataReader.class);\n+\n+  private final int mReaderBufferSizeMessages;\n+  private final long mDataTimeoutMs;\n+  private final FileSystemContext mContext;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final ReadRequest mReadRequest;\n+  private final WorkerNetAddress mAddress;\n+\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+\n+  private final DataBuffer[] mDataBuffers; \n+  private int mBufferCount = 0;\n+  private final ReentrantReadWriteLock mBufferLocks = new ReentrantReadWriteLock();\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+\n+  /**\n+   * Creates an instance of {@link NaiveCachedGrpcDataReader}.\n+   *\n+   * @param context the file system context\n+   * @param address the data server address\n+   * @param readRequest the read request\n+   */\n+  public NaiveCachedGrpcDataReader(FileSystemContext context, WorkerNetAddress address,", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMwODAzMg==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518308032", "bodyText": "Move the logics to Factory, please take a look", "author": "LuQQiu", "createdAt": "2020-11-05T19:26:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMzAwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMzUyNQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517713525", "bodyText": "same comments on constructor vs factory method as NaiveCachedGrpcDataReader.\nSince this is private and only invoked by Factory.create, we should avoid throwing Exceptions here, and you can move the part of code that may throw exception to the factory method", "author": "apc999", "createdAt": "2020-11-05T00:37:37Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.DataMessage;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that streams a region from gRPC data server.\n+ *\n+ * NaiveSharedGrpcDataReader is a POC to solve multi-process-read perf issue.\n+ * It follows GrpcDataReader protocol.\n+ * It takes strong assumption:\n+ *    Parallel read to the same file happens on the same time, so that read request is \n+ *    serialized by kernel\n+ */\n+@NotThreadSafe\n+public final class NaiveSharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveSharedGrpcDataReader.class);\n+\n+  private final NaiveCachedGrpcDataReader mCachedDataReader;\n+  private final long mBlockId;\n+\n+  private long mChunkSize;\n+  private long mBlockSize;\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  private final static ReentrantReadWriteLock mBlockLocks = new ReentrantReadWriteLock();\n+  private final static Map<Long, NaiveCachedGrpcDataReader> mBlockReaders = new HashMap<>();\n+\n+  /**\n+   * Creates an instance of {@link NaiveSharedGrpcDataReader}.\n+   *\n+   * @param context the file system context\n+   * @param address the data server address\n+   * @param readRequest the read request\n+   */\n+  private NaiveSharedGrpcDataReader(FileSystemContext context, WorkerNetAddress address,", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMwODI0Mw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518308243", "bodyText": "Moved the logics to Factory, please take a look", "author": "LuQQiu", "createdAt": "2020-11-05T19:26:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMzUyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxNDAxMQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517714011", "bodyText": "@GuardedBy(\"mBlockLocks\")\nis mBlockReaders the only data structure to protect by this lock?", "author": "apc999", "createdAt": "2020-11-05T00:39:22Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.DataMessage;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that streams a region from gRPC data server.\n+ *\n+ * NaiveSharedGrpcDataReader is a POC to solve multi-process-read perf issue.\n+ * It follows GrpcDataReader protocol.\n+ * It takes strong assumption:\n+ *    Parallel read to the same file happens on the same time, so that read request is \n+ *    serialized by kernel\n+ */\n+@NotThreadSafe\n+public final class NaiveSharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveSharedGrpcDataReader.class);\n+\n+  private final NaiveCachedGrpcDataReader mCachedDataReader;\n+  private final long mBlockId;\n+\n+  private long mChunkSize;\n+  private long mBlockSize;\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  private final static ReentrantReadWriteLock mBlockLocks = new ReentrantReadWriteLock();\n+  private final static Map<Long, NaiveCachedGrpcDataReader> mBlockReaders = new HashMap<>();", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI3MTI1MA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518271250", "bodyText": "to q2, yes, it's the only resource protected by this lock", "author": "chaowangnk1", "createdAt": "2020-11-05T18:28:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxNDAxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMwODkzNw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518308937", "bodyText": "Added\nYeah, it mainly use for BlockReaders, didn't find other data structures fully protected by this lock", "author": "LuQQiu", "createdAt": "2020-11-05T19:27:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxNDAxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyMzI1Ng==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517723256", "bodyText": "can we move this outside of critical session?", "author": "apc999", "createdAt": "2020-11-05T01:10:24Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.DataMessage;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that streams a region from gRPC data server.\n+ *\n+ * NaiveSharedGrpcDataReader is a POC to solve multi-process-read perf issue.\n+ * It follows GrpcDataReader protocol.\n+ * It takes strong assumption:\n+ *    Parallel read to the same file happens on the same time, so that read request is \n+ *    serialized by kernel\n+ */\n+@NotThreadSafe\n+public final class NaiveSharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveSharedGrpcDataReader.class);\n+\n+  private final NaiveCachedGrpcDataReader mCachedDataReader;\n+  private final long mBlockId;\n+\n+  private long mChunkSize;\n+  private long mBlockSize;\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  private final static ReentrantReadWriteLock mBlockLocks = new ReentrantReadWriteLock();\n+  private final static Map<Long, NaiveCachedGrpcDataReader> mBlockReaders = new HashMap<>();\n+\n+  /**\n+   * Creates an instance of {@link NaiveSharedGrpcDataReader}.\n+   *\n+   * @param context the file system context\n+   * @param address the data server address\n+   * @param readRequest the read request\n+   */\n+  private NaiveSharedGrpcDataReader(FileSystemContext context, WorkerNetAddress address,\n+      ReadRequest readRequest) throws IOException {\n+    mChunkSize = readRequest.getChunkSize();\n+    mPosToRead = readRequest.getOffset();\n+    mBlockSize = readRequest.getLength() + readRequest.getOffset();\n+    try (LockResource r1 = new LockResource(mBlockLocks.writeLock())) {\n+      mBlockId = readRequest.getBlockId();", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMwOTAwMQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518309001", "bodyText": "Done", "author": "LuQQiu", "createdAt": "2020-11-05T19:27:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyMzI1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyMzY2Ng==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517723666", "bodyText": "I actually think this part of looking up and returning cached reader should go to factory rather than constructor here", "author": "apc999", "createdAt": "2020-11-05T01:11:51Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.DataMessage;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that streams a region from gRPC data server.\n+ *\n+ * NaiveSharedGrpcDataReader is a POC to solve multi-process-read perf issue.\n+ * It follows GrpcDataReader protocol.\n+ * It takes strong assumption:\n+ *    Parallel read to the same file happens on the same time, so that read request is \n+ *    serialized by kernel\n+ */\n+@NotThreadSafe\n+public final class NaiveSharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveSharedGrpcDataReader.class);\n+\n+  private final NaiveCachedGrpcDataReader mCachedDataReader;\n+  private final long mBlockId;\n+\n+  private long mChunkSize;\n+  private long mBlockSize;\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  private final static ReentrantReadWriteLock mBlockLocks = new ReentrantReadWriteLock();\n+  private final static Map<Long, NaiveCachedGrpcDataReader> mBlockReaders = new HashMap<>();\n+\n+  /**\n+   * Creates an instance of {@link NaiveSharedGrpcDataReader}.\n+   *\n+   * @param context the file system context\n+   * @param address the data server address\n+   * @param readRequest the read request\n+   */\n+  private NaiveSharedGrpcDataReader(FileSystemContext context, WorkerNetAddress address,\n+      ReadRequest readRequest) throws IOException {\n+    mChunkSize = readRequest.getChunkSize();\n+    mPosToRead = readRequest.getOffset();\n+    mBlockSize = readRequest.getLength() + readRequest.getOffset();\n+    try (LockResource r1 = new LockResource(mBlockLocks.writeLock())) {", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI3NDM2Ng==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518274366", "bodyText": "That's a better option.", "author": "chaowangnk1", "createdAt": "2020-11-05T18:33:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyMzY2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMxMDI0NQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518310245", "bodyText": "Moved", "author": "LuQQiu", "createdAt": "2020-11-05T19:28:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyMzY2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyNDE3MQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517724171", "bodyText": "Considering Closer?", "author": "apc999", "createdAt": "2020-11-05T01:13:44Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.DataMessage;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import alluxio.resource.LockResource;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that streams a region from gRPC data server.\n+ *\n+ * Protocol:\n+ * 1. The client sends a read request (id, offset, length).\n+ * 2. Once the server receives the request, it streams chunks to the client. The streaming pauses\n+ *    if the server's buffer is full and resumes if the buffer is not full.\n+ * 3. The client reads chunks from the stream using an iterator.\n+ * 4. The client can cancel the read request at anytime. The cancel request is ignored by the\n+ *    server if everything has been sent to channel.\n+ * 5. To make it simple to handle errors, the channel is closed if any error occurs.\n+ */\n+@NotThreadSafe\n+public final class NaiveCachedGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveCachedGrpcDataReader.class);\n+\n+  private final int mReaderBufferSizeMessages;\n+  private final long mDataTimeoutMs;\n+  private final FileSystemContext mContext;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final ReadRequest mReadRequest;\n+  private final WorkerNetAddress mAddress;\n+\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+\n+  private final DataBuffer[] mDataBuffers; \n+  private int mBufferCount = 0;\n+  private final ReentrantReadWriteLock mBufferLocks = new ReentrantReadWriteLock();\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+\n+  /**\n+   * Creates an instance of {@link NaiveCachedGrpcDataReader}.\n+   *\n+   * @param context the file system context\n+   * @param address the data server address\n+   * @param readRequest the read request\n+   */\n+  public NaiveCachedGrpcDataReader(FileSystemContext context, WorkerNetAddress address,\n+      ReadRequest readRequest) throws IOException {\n+    mContext = context;\n+    mAddress = address;\n+    mPosToRead = readRequest.getOffset();\n+    mReadRequest = readRequest;\n+    AlluxioConfiguration alluxioConf = context.getClusterConf();\n+    mReaderBufferSizeMessages = alluxioConf\n+        .getInt(PropertyKey.USER_STREAMING_READER_BUFFER_SIZE_MESSAGES);\n+    mDataTimeoutMs = alluxioConf.getMs(PropertyKey.USER_STREAMING_DATA_TIMEOUT);\n+    mMarshaller = new ReadResponseMarshaller();\n+    mClient = mContext.acquireBlockWorkerClient(address);\n+    long blockSize = readRequest.getLength() + readRequest.getOffset();\n+    long chunkSize = readRequest.getChunkSize();\n+    int buffCount = (int)(blockSize / chunkSize);\n+    if ((blockSize % chunkSize) != 0) {\n+      buffCount += 1;\n+    }\n+    mDataBuffers = new DataBuffer[buffCount];\n+\n+    try {\n+      String desc = \"GrpcDataReader\";\n+      if (LOG.isDebugEnabled()) { // More detailed description when debug logging is enabled\n+        desc = MoreObjects.toStringHelper(this)\n+          .add(\"request\", mReadRequest)\n+          .add(\"address\", address)\n+          .toString();\n+      }\n+      mStream = new GrpcBlockingStream<>(mClient.get()::readBlock, mReaderBufferSizeMessages,\n+          desc);\n+      mStream.send(mReadRequest, mDataTimeoutMs);\n+    } catch (Exception e) {\n+      mClient.close();\n+      throw e;\n+    }\n+  }\n+\n+  public DataBuffer readChunk(int index) throws IOException {\n+    if (index >= mDataBuffers.length) {\n+      return null;\n+    }\n+    \n+    try (LockResource r1 = new LockResource(mBufferLocks.writeLock())) {\n+      while (index >= mBufferCount) {\n+        DataBuffer buffer = readChunk();\n+        mDataBuffers[mBufferCount] = buffer;\n+        ++mBufferCount;\n+      }\n+    }\n+\n+    return mDataBuffers[index];\n+  }\n+\n+  private DataBuffer readChunk() throws IOException {\n+    Preconditions.checkState(!mClient.get().isShutdown(),\n+        \"Data reader is closed while reading data chunks.\");\n+    DataBuffer buffer = null;\n+    ReadResponse response = null;\n+    response = mStream.receive(mDataTimeoutMs);\n+    if (response != null) {\n+      Preconditions.checkState(response.hasChunk() && response.getChunk().hasData(),\n+          \"response should always contain chunk\");\n+\n+      ByteBuffer byteBuffer = response.getChunk().getData().asReadOnlyByteBuffer();\n+      buffer = new NioDataBuffer(byteBuffer, byteBuffer.remaining());\n+    } else {\n+      return null;\n+    }\n+    mPosToRead += buffer.readableBytes();\n+    try {\n+      mStream.send(mReadRequest.toBuilder().setOffsetReceived(mPosToRead).build());\n+    } catch (Exception e) {\n+      // nothing is done as the receipt is sent at best effort\n+      LOG.debug(\"Failed to send receipt of data to worker {} for request {}: {}.\", mAddress,\n+          mReadRequest, e.getMessage());\n+    }\n+    Preconditions.checkState(mPosToRead - mReadRequest.getOffset() <= mReadRequest.getLength());\n+    return buffer;\n+  }\n+\n+  public void close() throws IOException {\n+    try {\n+      if (mClient.get().isShutdown()) {\n+        return;\n+      }\n+      mStream.close();\n+      mStream.waitForComplete(mDataTimeoutMs);\n+    } finally {\n+      mMarshaller.close();", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyNjQ4MA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517726480", "bodyText": "I think this is a redundant case. please check", "author": "apc999", "createdAt": "2020-11-05T01:21:50Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java", "diffHunk": "@@ -337,8 +341,42 @@ public void seek(long pos) throws IOException {\n     }\n     if (pos < mPos) {\n       mEOF = false;\n+      if (mDataReader instanceof NaiveSharedGrpcDataReader) {\n+        NaiveSharedGrpcDataReader reader = (NaiveSharedGrpcDataReader)mDataReader;\n+        reader.seek(pos);\n+        if (mCurrentChunk != null) {\n+          mCurrentChunk.release();\n+          mCurrentChunk = null;\n+        }\n+      } else {\n+        closeDataReader();\n+      }\n+    } else if (pos < mLength) {\n+      // Try to read data already in queue\n+      long curPos = mPos;\n+      while (mCurrentChunk != null && curPos < pos) {\n+        long nextPos = curPos + mCurrentChunk.readableBytes();\n+        if (nextPos <= pos) {\n+          curPos = nextPos; \n+          mCurrentChunk.release();\n+          mCurrentChunk = mDataReader.readChunkNoWait();\n+        } else {\n+          // TODO introduce seek in DataBuffer\n+          int toRead = (int)(pos - curPos);\n+          final byte[] b = new byte[toRead];\n+          mCurrentChunk.readBytes(b, 0, toRead);\n+          curPos = pos;\n+        }\n+      }\n+\n+      if (curPos < pos) {\n+        // Not enough data in queue, close the data reader\n+        closeDataReader();\n+      }\n+    } else {\n+      closeDataReader();", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMxNTgyMw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518315823", "bodyText": "Removed this block, think it's abundant as well", "author": "LuQQiu", "createdAt": "2020-11-05T19:35:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyNjQ4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyNjY3MQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517726671", "bodyText": "how about naming this method : readChunkIfReady", "author": "apc999", "createdAt": "2020-11-05T01:22:35Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/DataReader.java", "diffHunk": "@@ -28,6 +28,13 @@\n    */\n   DataBuffer readChunk() throws IOException;\n \n+  /**\n+   * Try to read a chunk without waiting for data ready. \n+   *\n+   * @return the data buffer or null if EOF is reached or data is not ready.\n+   */\n+  DataBuffer readChunkNoWait() throws IOException;", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMxNTk2MQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518315961", "bodyText": "Renamed", "author": "LuQQiu", "createdAt": "2020-11-05T19:35:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyNjY3MQ=="}], "type": "inlineReview"}, {"oid": "ccfecf3af7bb034800ea4e112ea598ef886776dc", "url": "https://github.com/Alluxio/alluxio/commit/ccfecf3af7bb034800ea4e112ea598ef886776dc", "message": "Fix the blockSize bug, move logics from constructor to factory and fix codestyle", "committedDate": "2020-11-05T19:13:44Z", "type": "commit"}, {"oid": "ef197c31a6e860e03f7971b0e3a4a6c4968d8e1d", "url": "https://github.com/Alluxio/alluxio/commit/ef197c31a6e860e03f7971b0e3a4a6c4968d8e1d", "message": "Change to closer", "committedDate": "2020-11-05T19:36:15Z", "type": "commit"}, {"oid": "b913c5eaf7f3f9e4f3cb2248654a42abcae15968", "url": "https://github.com/Alluxio/alluxio/commit/b913c5eaf7f3f9e4f3cb2248654a42abcae15968", "message": "Small fix", "committedDate": "2020-11-05T22:08:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxNDExNg==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518514116", "bodyText": "Tries to read a chunk if there is data ready. If chunk is not null, the caller needs to release it", "author": "apc999", "createdAt": "2020-11-06T04:16:25Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/DataReader.java", "diffHunk": "@@ -28,6 +30,14 @@\n    */\n   DataBuffer readChunk() throws IOException;\n \n+  /**\n+   * Try to read a chunk if the data is ready.", "originalCommit": "b913c5eaf7f3f9e4f3cb2248654a42abcae15968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwNjIzNw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519006237", "bodyText": "Done", "author": "LuQQiu", "createdAt": "2020-11-06T21:09:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxNDExNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxNTM3OQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518515379", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private final DataBuffer[] mDataBuffers;\n          \n          \n            \n              @GuardedBy(\"mBlockLocks\")\n          \n          \n            \n              private final DataBuffer[] mDataBuffers;", "author": "apc999", "createdAt": "2020-11-06T04:22:06Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.io.Closer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public final class NaiveCachedGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveCachedGrpcDataReader.class);\n+\n+  private final WorkerNetAddress mAddress;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final long mDataTimeoutMs;\n+  private final ReadRequest mReadRequest;\n+\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+  /**\n+   * Count the number of threads that are accessing the same block together.\n+   * When no thread is accessing this block, the cached data will be GCed.\n+   */\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+  private final Closer mCloser;\n+\n+  private volatile int mBufferCount = 0;\n+  private final DataBuffer[] mDataBuffers;", "originalCommit": "b913c5eaf7f3f9e4f3cb2248654a42abcae15968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3NjE4NA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518876184", "bodyText": "For mDataBuffers, only the update (write buff) is guarded by the mBufferLocks, all other read operations are not protected.", "author": "LuQQiu", "createdAt": "2020-11-06T16:50:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxNTM3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxNTY2Mw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518515663", "bodyText": "any reason to use volatile int rather than AtomicInteger?", "author": "apc999", "createdAt": "2020-11-06T04:23:26Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.io.Closer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public final class NaiveCachedGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveCachedGrpcDataReader.class);\n+\n+  private final WorkerNetAddress mAddress;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final long mDataTimeoutMs;\n+  private final ReadRequest mReadRequest;\n+\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+  /**\n+   * Count the number of threads that are accessing the same block together.\n+   * When no thread is accessing this block, the cached data will be GCed.\n+   */\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+  private final Closer mCloser;\n+\n+  private volatile int mBufferCount = 0;", "originalCommit": "b913c5eaf7f3f9e4f3cb2248654a42abcae15968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkwMjgyMQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518902821", "bodyText": "Volatile and AtomicInteger don't make a difference here.  AtomicInteger internally uses volatile for the integer value. AtomicInteger mainly improved for setting values. in our case, we only increase the value under a write lock.", "author": "LuQQiu", "createdAt": "2020-11-06T17:37:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxNTY2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwNjA5OA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519006098", "bodyText": "Changed the volatile to AtomicInteger", "author": "LuQQiu", "createdAt": "2020-11-06T21:08:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxNTY2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxNjM2OA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518516368", "bodyText": "any reason to have this registration here rather than in constructor or factory method?", "author": "apc999", "createdAt": "2020-11-06T04:26:20Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.io.Closer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public final class NaiveCachedGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveCachedGrpcDataReader.class);\n+\n+  private final WorkerNetAddress mAddress;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final long mDataTimeoutMs;\n+  private final ReadRequest mReadRequest;\n+\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+  /**\n+   * Count the number of threads that are accessing the same block together.\n+   * When no thread is accessing this block, the cached data will be GCed.\n+   */\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+  private final Closer mCloser;\n+\n+  private volatile int mBufferCount = 0;\n+  private final DataBuffer[] mDataBuffers;\n+  private final ReentrantReadWriteLock mBufferLocks = new ReentrantReadWriteLock();\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link NaiveCachedGrpcDataReader}.\n+   *\n+   * @param address the data server address\n+   * @param client the block worker client to read data from\n+   * @param closer the closer\n+   * @param dataBuffers the data buffers to cache block data in chunk\n+   * @param dataTimeoutMs the maximum time to wait for a data response\n+   * @param readRequest the read request\n+   * @param stream the underlying gRPC stream to read data\n+   */\n+  private NaiveCachedGrpcDataReader(WorkerNetAddress address,\n+      CloseableResource<BlockWorkerClient> client, Closer closer, DataBuffer[] dataBuffers,\n+      long dataTimeoutMs, ReadRequest readRequest,\n+      GrpcBlockingStream<ReadRequest, ReadResponse> stream) {\n+    mAddress = address;\n+    mClient = client;\n+    mCloser = closer;\n+    mDataBuffers = dataBuffers;\n+    mDataTimeoutMs = dataTimeoutMs;\n+    mMarshaller = new ReadResponseMarshaller();\n+    mPosToRead = readRequest.getOffset();\n+    mReadRequest = readRequest;\n+    mStream = stream;\n+  }\n+\n+  /**\n+   * Reads a specific chunk from the block.\n+   *\n+   * @param index the chunk index\n+   * @return the chunk data if exists\n+   */\n+  public DataBuffer readChunk(int index) throws IOException {\n+    if (index >= mDataBuffers.length) {\n+      return null;\n+    }\n+\n+    if (index >= mBufferCount) {\n+      try (LockResource r1 = new LockResource(mBufferLocks.writeLock())) {\n+        while (index >= mBufferCount) {\n+          DataBuffer buffer = readChunk();\n+          mDataBuffers[mBufferCount] = buffer;\n+          ++mBufferCount;\n+        }\n+      }\n+    }\n+\n+    return mDataBuffers[index];\n+  }\n+\n+  /**\n+   * Reads a chunk of data.\n+   *\n+   * @return a chunk of data\n+   */\n+  private DataBuffer readChunk() throws IOException {\n+    Preconditions.checkState(!mClient.get().isShutdown(),\n+        \"Data reader is closed while reading data chunks.\");\n+    DataBuffer buffer = null;\n+    ReadResponse response = null;\n+    response = mStream.receive(mDataTimeoutMs);\n+    if (response != null) {\n+      Preconditions.checkState(response.hasChunk() && response.getChunk().hasData(),\n+          \"response should always contain chunk\");\n+\n+      ByteBuffer byteBuffer = response.getChunk().getData().asReadOnlyByteBuffer();\n+      buffer = new NioDataBuffer(byteBuffer, byteBuffer.remaining());\n+    } else {\n+      return null;\n+    }\n+    mPosToRead += buffer.readableBytes();\n+    try {\n+      mStream.send(mReadRequest.toBuilder().setOffsetReceived(mPosToRead).build());\n+    } catch (Exception e) {\n+      // nothing is done as the receipt is sent at best effort\n+      LOG.debug(\"Failed to send receipt of data to worker {} for request {}: {}.\", mAddress,\n+          mReadRequest, e.getMessage());\n+    }\n+    Preconditions.checkState(mPosToRead - mReadRequest.getOffset() <= mReadRequest.getLength());\n+    return buffer;\n+  }\n+\n+  /**\n+   * Closes the {@link NaiveCachedGrpcDataReader}.\n+   */\n+  public void close() throws IOException {\n+    if (mClient.get().isShutdown()) {\n+      return;\n+    }\n+    mCloser.register(() -> {\n+      mStream.close();\n+      mStream.waitForComplete(mDataTimeoutMs);\n+    });", "originalCommit": "b913c5eaf7f3f9e4f3cb2248654a42abcae15968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwNTc5Nw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519005797", "bodyText": "Moved to the constructor, thanks!", "author": "LuQQiu", "createdAt": "2020-11-06T21:08:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxNjM2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxOTE0Mg==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518519142", "bodyText": "Nit: I would prefer to put the creation of closer and dataBuffers inside the constructor rather than in factory method here. It is easier to reason the ownership of these data structures in that way. In contrast, the creation of stream , client is not guaranteed to succeed with exception possibly thrown, thus why we should leave it in factory method and pass them to constructor as param on successful creation.\nAs long as the constructor is ensured to complete, we should be good.", "author": "apc999", "createdAt": "2020-11-06T04:38:12Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.io.Closer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public final class NaiveCachedGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveCachedGrpcDataReader.class);\n+\n+  private final WorkerNetAddress mAddress;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final long mDataTimeoutMs;\n+  private final ReadRequest mReadRequest;\n+\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+  /**\n+   * Count the number of threads that are accessing the same block together.\n+   * When no thread is accessing this block, the cached data will be GCed.\n+   */\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+  private final Closer mCloser;\n+\n+  private volatile int mBufferCount = 0;\n+  private final DataBuffer[] mDataBuffers;\n+  private final ReentrantReadWriteLock mBufferLocks = new ReentrantReadWriteLock();\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link NaiveCachedGrpcDataReader}.\n+   *\n+   * @param address the data server address\n+   * @param client the block worker client to read data from\n+   * @param closer the closer\n+   * @param dataBuffers the data buffers to cache block data in chunk\n+   * @param dataTimeoutMs the maximum time to wait for a data response\n+   * @param readRequest the read request\n+   * @param stream the underlying gRPC stream to read data\n+   */\n+  private NaiveCachedGrpcDataReader(WorkerNetAddress address,\n+      CloseableResource<BlockWorkerClient> client, Closer closer, DataBuffer[] dataBuffers,\n+      long dataTimeoutMs, ReadRequest readRequest,\n+      GrpcBlockingStream<ReadRequest, ReadResponse> stream) {\n+    mAddress = address;\n+    mClient = client;\n+    mCloser = closer;\n+    mDataBuffers = dataBuffers;\n+    mDataTimeoutMs = dataTimeoutMs;\n+    mMarshaller = new ReadResponseMarshaller();\n+    mPosToRead = readRequest.getOffset();\n+    mReadRequest = readRequest;\n+    mStream = stream;\n+  }\n+\n+  /**\n+   * Reads a specific chunk from the block.\n+   *\n+   * @param index the chunk index\n+   * @return the chunk data if exists\n+   */\n+  public DataBuffer readChunk(int index) throws IOException {\n+    if (index >= mDataBuffers.length) {\n+      return null;\n+    }\n+\n+    if (index >= mBufferCount) {\n+      try (LockResource r1 = new LockResource(mBufferLocks.writeLock())) {\n+        while (index >= mBufferCount) {\n+          DataBuffer buffer = readChunk();\n+          mDataBuffers[mBufferCount] = buffer;\n+          ++mBufferCount;\n+        }\n+      }\n+    }\n+\n+    return mDataBuffers[index];\n+  }\n+\n+  /**\n+   * Reads a chunk of data.\n+   *\n+   * @return a chunk of data\n+   */\n+  private DataBuffer readChunk() throws IOException {\n+    Preconditions.checkState(!mClient.get().isShutdown(),\n+        \"Data reader is closed while reading data chunks.\");\n+    DataBuffer buffer = null;\n+    ReadResponse response = null;\n+    response = mStream.receive(mDataTimeoutMs);\n+    if (response != null) {\n+      Preconditions.checkState(response.hasChunk() && response.getChunk().hasData(),\n+          \"response should always contain chunk\");\n+\n+      ByteBuffer byteBuffer = response.getChunk().getData().asReadOnlyByteBuffer();\n+      buffer = new NioDataBuffer(byteBuffer, byteBuffer.remaining());\n+    } else {\n+      return null;\n+    }\n+    mPosToRead += buffer.readableBytes();\n+    try {\n+      mStream.send(mReadRequest.toBuilder().setOffsetReceived(mPosToRead).build());\n+    } catch (Exception e) {\n+      // nothing is done as the receipt is sent at best effort\n+      LOG.debug(\"Failed to send receipt of data to worker {} for request {}: {}.\", mAddress,\n+          mReadRequest, e.getMessage());\n+    }\n+    Preconditions.checkState(mPosToRead - mReadRequest.getOffset() <= mReadRequest.getLength());\n+    return buffer;\n+  }\n+\n+  /**\n+   * Closes the {@link NaiveCachedGrpcDataReader}.\n+   */\n+  public void close() throws IOException {\n+    if (mClient.get().isShutdown()) {\n+      return;\n+    }\n+    mCloser.register(() -> {\n+      mStream.close();\n+      mStream.waitForComplete(mDataTimeoutMs);\n+    });\n+    mCloser.close();\n+  }\n+\n+  /**\n+   * Increases the reference count and return the current count.\n+   *\n+   * @return the current count\n+   */\n+  public int ref() {\n+    return mRefCount.incrementAndGet();\n+  }\n+\n+  /**\n+   * Decreases the reference count and return the current count.\n+   *\n+   * @return the current count\n+   */\n+  public int deRef() {\n+    return mRefCount.decrementAndGet();\n+  }\n+\n+  /**\n+   * @return the current count\n+   */\n+  public int getRefCount() {\n+    return mRefCount.get();\n+  }\n+\n+  /**\n+   * Factory class to create {@link NaiveCachedGrpcDataReader}s.\n+   */\n+  public static class Factory {\n+    private final FileSystemContext mContext;\n+    private final WorkerNetAddress mAddress;\n+    private final ReadRequest mReadRequest;\n+\n+    /**\n+     * Creates an instance of {@link NaiveCachedGrpcDataReader.Factory} for block reads.\n+     *\n+     * @param context the file system context\n+     * @param address the worker address\n+     * @param readRequest the read request\n+     */\n+    public Factory(FileSystemContext context, WorkerNetAddress address,\n+        ReadRequest readRequest) {\n+      mContext = context;\n+      mAddress = address;\n+      mReadRequest = readRequest;\n+    }\n+\n+    /**\n+     * @return a new {@link NaiveCachedGrpcDataReader}\n+     */\n+    public NaiveCachedGrpcDataReader create() throws IOException {\n+      AlluxioConfiguration alluxioConf = mContext.getClusterConf();\n+      int readerBufferSizeMessages = alluxioConf\n+          .getInt(PropertyKey.USER_STREAMING_READER_BUFFER_SIZE_MESSAGES);\n+      long dataTimeoutMs = alluxioConf.getMs(PropertyKey.USER_STREAMING_DATA_TIMEOUT);\n+\n+      Closer closer = Closer.create();\n+      CloseableResource<BlockWorkerClient> client = mContext.acquireBlockWorkerClient(mAddress);\n+      closer.register(client);\n+\n+      long blockSize = mReadRequest.getLength() + mReadRequest.getOffset();\n+      long chunkSize = mReadRequest.getChunkSize();\n+      int buffCount = (int) (blockSize / chunkSize);\n+      if ((blockSize % chunkSize) != 0) {\n+        buffCount += 1;\n+      }\n+      DataBuffer[] dataBuffers = new DataBuffer[buffCount];", "originalCommit": "b913c5eaf7f3f9e4f3cb2248654a42abcae15968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwNTYzNQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519005635", "bodyText": "Make sense. Moved the closer and DataBuffer[] related logics back to the constructor. The Closer in the constructor is better to show the ownership.", "author": "LuQQiu", "createdAt": "2020-11-06T21:07:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxOTE0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUyMDA4NA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518520084", "bodyText": "I would call this BufferCachingGrpcDataReader\nmy personal preference: do not to use final when defining a class  unless you are very sure no one should extend it\nBetter to extend DataReader unless there is particular reason", "author": "apc999", "createdAt": "2020-11-06T04:42:21Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.io.Closer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public final class NaiveCachedGrpcDataReader {", "originalCommit": "b913c5eaf7f3f9e4f3cb2248654a42abcae15968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk1NDg2MA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518954860", "bodyText": "Because the methods are different.\nDataReader's methods\n  DataBuffer readChunk() throws IOException;\n  DataBuffer readChunkIfReady() throws IOException;\n  long pos();\n\nare not related to bufferCachingGrpcDataReader. bufferCachingGrpcDataReader doesn't have pos concept and it's readChunk() is private. The main publicly available method is readChunk(index) to read a specific chunk from this block.", "author": "LuQQiu", "createdAt": "2020-11-06T19:19:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUyMDA4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUyMDQxNw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518520417", "bodyText": "nit: unnecessary empty line", "author": "apc999", "createdAt": "2020-11-06T04:44:05Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.io.Closer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public final class NaiveCachedGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveCachedGrpcDataReader.class);\n+\n+  private final WorkerNetAddress mAddress;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final long mDataTimeoutMs;\n+  private final ReadRequest mReadRequest;\n+", "originalCommit": "b913c5eaf7f3f9e4f3cb2248654a42abcae15968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwNTA2OQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519005069", "bodyText": "Removed", "author": "LuQQiu", "createdAt": "2020-11-06T21:06:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUyMDQxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUyMTY1NA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518521654", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change", "author": "apc999", "createdAt": "2020-11-06T04:49:22Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public final class NaiveSharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveSharedGrpcDataReader.class);\n+", "originalCommit": "b913c5eaf7f3f9e4f3cb2248654a42abcae15968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwNDg2NA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519004864", "bodyText": "Done", "author": "LuQQiu", "createdAt": "2020-11-06T21:05:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUyMTY1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUyOTczMA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518529730", "bodyText": "new NaiveCachedGrpcDataReader.Factory(mContext, mAddress, cacheRequest).create(); has RPCs inside and thus can take a long time. It is not a good idea to have a global lock here around a RPC. In case network connection is not working properly and there is some timing out triggered, this global lock will pause all new block reads for entire client across user processes.\nhow about instead of single global lock, create an array of locks, and lock the one in lock array based on block Id:\ntry (LockResource lockResource = \n    new LockResource(BLOCK_LOCKS[blockId % BLOCK_LOCKS.length].writeLock())) {\n  reader = BLOCK_READERS.computeIfAbsent(blockId, \n      blockId -> new NaiveCachedGrpcDataReader(...));\n  reader.ref();\n}", "author": "apc999", "createdAt": "2020-11-06T05:23:12Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public final class NaiveSharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveSharedGrpcDataReader.class);\n+\n+  private static final ReentrantReadWriteLock BLOCK_LOCK = new ReentrantReadWriteLock();\n+  /** A map from block id to the block's cached data reader. */\n+  @GuardedBy(\"mBlockLocks\")\n+  private static final Map<Long, NaiveCachedGrpcDataReader> BLOCK_READERS = new HashMap<>();\n+\n+  private final long mBlockId;\n+  private final NaiveCachedGrpcDataReader mCachedDataReader;\n+  private final long mChunkSize;\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link NaiveSharedGrpcDataReader}.\n+   *\n+   * @param readRequest the read request\n+   * @param reader the cached Grpc data reader for the given block\n+   */\n+  private NaiveSharedGrpcDataReader(ReadRequest readRequest, NaiveCachedGrpcDataReader reader) {\n+    mChunkSize = readRequest.getChunkSize();\n+    mPosToRead = readRequest.getOffset();\n+    mBlockId = readRequest.getBlockId();\n+    mCachedDataReader = reader;\n+  }\n+\n+  @Override\n+  public long pos() {\n+    return mPosToRead;\n+  }\n+\n+  /**\n+   * Seeks to a specific position.\n+   *\n+   * @param pos the position to seek to\n+   */\n+  public void seek(long pos) {\n+    mPosToRead = pos;\n+  }\n+\n+  @Override\n+  public DataBuffer readChunk() throws IOException {\n+    int index = (int) (mPosToRead / mChunkSize);\n+    DataBuffer chunk = mCachedDataReader.readChunk(index);\n+    if (chunk == null) {\n+      return null;\n+    }\n+    ByteBuffer bb = chunk.getReadOnlyByteBuffer();\n+    // Force to align to chunk size\n+    bb.position((int) (mPosToRead % mChunkSize));\n+    mPosToRead += mChunkSize - mPosToRead % mChunkSize;\n+\n+    return new NioDataBuffer(bb, bb.remaining());\n+  }\n+\n+  @Override\n+  public DataBuffer readChunkIfReady() throws IOException {\n+    // I'm naive, I'm reading chunks anyway\n+    return readChunk();\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    if (mCachedDataReader.deRef() == 0) {\n+      try (LockResource lockResource = new LockResource(BLOCK_LOCK.writeLock())) {\n+        if (mCachedDataReader.getRefCount() == 0) {\n+          mCachedDataReader.close();\n+          BLOCK_READERS.remove(mBlockId);\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Factory class to create {@link NaiveSharedGrpcDataReader}s.\n+   */\n+  public static class Factory implements DataReader.Factory {\n+    private final FileSystemContext mContext;\n+    private final WorkerNetAddress mAddress;\n+    private final ReadRequest mReadRequestPartial;\n+    private final long mBlockSize;\n+\n+    /**\n+     * Creates an instance of {@link NaiveSharedGrpcDataReader.Factory} for block reads.\n+     *\n+     * @param context the file system context\n+     * @param address the worker address\n+     * @param readRequestPartial the partial read request\n+     * @param blockSize the block size\n+     */\n+    public Factory(FileSystemContext context, WorkerNetAddress address,\n+        ReadRequest readRequestPartial, long blockSize) {\n+      mContext = context;\n+      mAddress = address;\n+      mReadRequestPartial = readRequestPartial;\n+      mBlockSize = blockSize;\n+    }\n+\n+    @Override\n+    public DataReader create(long offset, long len) throws IOException {\n+      long blockId = mReadRequestPartial.getBlockId();\n+      NaiveCachedGrpcDataReader reader;\n+      try (LockResource lockResource = new LockResource(BLOCK_LOCK.writeLock())) {\n+        reader = BLOCK_READERS.get(blockId);\n+        if (reader == null) {\n+          // I'm naive, I always read from 0 and read the whole block\n+          ReadRequest cacheRequest = mReadRequestPartial\n+              .toBuilder().setOffset(0).setLength(mBlockSize).build();\n+          reader = new NaiveCachedGrpcDataReader\n+              .Factory(mContext, mAddress, cacheRequest).create();\n+          BLOCK_READERS.put(blockId, reader);\n+        }\n+\n+        reader.ref();\n+      }", "originalCommit": "b913c5eaf7f3f9e4f3cb2248654a42abcae15968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwNDcwMg==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519004702", "bodyText": "Changed to use an array of locks\ntry (LockResource lockResource = new LockResource(\n          BLOCK_LOCKS[(int) (mBlockId % BLOCK_LOCKS.length)].writeLock())) {\n\nand changed the readers hashmap to ConcurrentHashMap.\ni didn't change to use computeIfAbsent because the BufferCachingGrpcDataReader creation will throw IOException which the compute function cannot process well.", "author": "LuQQiu", "createdAt": "2020-11-06T21:05:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUyOTczMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUzMzg3NA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518533874", "bodyText": "Regarding lock , Check my next comment on lock striping first.  AgainmCachedDataReader.close() may take a long time, we should not put this inside a critical session by a global lock.\nAfter lock striping, we can remove reader from the BLOCK_READERS map if its refcount reaches 0, but calling  mCachedDataReader.close() outside the lock to further make sure operations inside the lock is minimal.", "author": "apc999", "createdAt": "2020-11-06T05:39:25Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public final class NaiveSharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveSharedGrpcDataReader.class);\n+\n+  private static final ReentrantReadWriteLock BLOCK_LOCK = new ReentrantReadWriteLock();\n+  /** A map from block id to the block's cached data reader. */\n+  @GuardedBy(\"mBlockLocks\")\n+  private static final Map<Long, NaiveCachedGrpcDataReader> BLOCK_READERS = new HashMap<>();\n+\n+  private final long mBlockId;\n+  private final NaiveCachedGrpcDataReader mCachedDataReader;\n+  private final long mChunkSize;\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link NaiveSharedGrpcDataReader}.\n+   *\n+   * @param readRequest the read request\n+   * @param reader the cached Grpc data reader for the given block\n+   */\n+  private NaiveSharedGrpcDataReader(ReadRequest readRequest, NaiveCachedGrpcDataReader reader) {\n+    mChunkSize = readRequest.getChunkSize();\n+    mPosToRead = readRequest.getOffset();\n+    mBlockId = readRequest.getBlockId();\n+    mCachedDataReader = reader;\n+  }\n+\n+  @Override\n+  public long pos() {\n+    return mPosToRead;\n+  }\n+\n+  /**\n+   * Seeks to a specific position.\n+   *\n+   * @param pos the position to seek to\n+   */\n+  public void seek(long pos) {\n+    mPosToRead = pos;\n+  }\n+\n+  @Override\n+  public DataBuffer readChunk() throws IOException {\n+    int index = (int) (mPosToRead / mChunkSize);\n+    DataBuffer chunk = mCachedDataReader.readChunk(index);\n+    if (chunk == null) {\n+      return null;\n+    }\n+    ByteBuffer bb = chunk.getReadOnlyByteBuffer();\n+    // Force to align to chunk size\n+    bb.position((int) (mPosToRead % mChunkSize));\n+    mPosToRead += mChunkSize - mPosToRead % mChunkSize;\n+\n+    return new NioDataBuffer(bb, bb.remaining());\n+  }\n+\n+  @Override\n+  public DataBuffer readChunkIfReady() throws IOException {\n+    // I'm naive, I'm reading chunks anyway\n+    return readChunk();\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    if (mCachedDataReader.deRef() == 0) {\n+      try (LockResource lockResource = new LockResource(BLOCK_LOCK.writeLock())) {\n+        if (mCachedDataReader.getRefCount() == 0) {\n+          mCachedDataReader.close();\n+          BLOCK_READERS.remove(mBlockId);\n+        }\n+      }", "originalCommit": "b913c5eaf7f3f9e4f3cb2248654a42abcae15968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk2MzU2Nw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518963567", "bodyText": "Changed to\n      try (LockResource lockResource = new LockResource(\n          BLOCK_LOCKS[(int) (mBlockId % BLOCK_LOCKS.length)].writeLock())) {\n        if (mCachedDataReader.getRefCount() == 0) {\n          BLOCK_READERS.remove(mBlockId);\n        }\n      }\n      if (mCachedDataReader.getRefCount() == 0) {\n        mCachedDataReader.close();\n      }\n\nI think it should be thread-safe,\n\nThread B deRef() == 0\nThread A ref++\nThread B get the write lock and doesn't remove blockId from readers map\nThread A deRef() == 0\nThread B close the dataReader\nThread A remove blockId from readers map and close the dataReader again.\n\n\n\nThread B deRef() == 0\nThread A ref++\nThread B get the write lock and doesn't remove blockId from readers map\nThread B doesn't close the dataReader\nThread A remove blockId from readers map and close the dataReader.\n\nboth scenarios are safe", "author": "LuQQiu", "createdAt": "2020-11-06T19:38:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUzMzg3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUzNDY0MQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518534641", "bodyText": "currently this is not specific to fuse. we can either make it only works on fuse (e.g., check process type), or rename the flag to make it usable in general.\nFUSE_SHARED_GRPC_DATA_READER_ENABLED", "author": "apc999", "createdAt": "2020-11-06T05:42:23Z", "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -5551,6 +5560,8 @@ private static String javadocLink(String fullyQualifiedClassname) {\n     public static final String FUSE_DEBUG_ENABLED = \"alluxio.fuse.debug.enabled\";\n     public static final String FUSE_FS_NAME = \"alluxio.fuse.fs.name\";\n     public static final String FUSE_JNIFUSE_ENABLED = \"alluxio.fuse.jnifuse.enabled\";\n+    public static final String FUSE_SHARED_GRPC_DATA_READER", "originalCommit": "b913c5eaf7f3f9e4f3cb2248654a42abcae15968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk1MDE5OA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518950198", "bodyText": "I think it's specific to FUSE use case, not sure if it's able to work on other cases.\nThe bufferCachingDataReader is more general, but the SharedDataReader can be only used for fuse since it is based on the assumption\n * It follows GrpcDataReader protocol and takes strong assumption:\n * Parallel read to the same file happens on the same time, so that read request is\n * serialized by kernel\n\nit relies on one thread do seek() and then readChunk()  and then the other thread do seek() -> readChunk()s.", "author": "LuQQiu", "createdAt": "2020-11-06T19:09:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUzNDY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwMzI2MA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519003260", "bodyText": "Maybe we can change the current name SharedDataReader to FuseSharedDataReader to be more clear?", "author": "LuQQiu", "createdAt": "2020-11-06T21:01:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUzNDY0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUzNDk2Mw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518534963", "bodyText": "I would simply call this class SharedGrpcDataReader", "author": "apc999", "createdAt": "2020-11-06T05:43:42Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public final class NaiveSharedGrpcDataReader implements DataReader {", "originalCommit": "b913c5eaf7f3f9e4f3cb2248654a42abcae15968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwMjc5NQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519002795", "bodyText": "Changed to SharedGrpcDataReader", "author": "LuQQiu", "createdAt": "2020-11-06T21:00:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUzNDk2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUzNTg0NA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518535844", "bodyText": "can we also guard the newly added logic under flag FUSE_SHARED_GRPC_DATA_READER ?\nif (flag is off) {\n  if (pos < mPos) {\n    mEOF = false;\n  }\n  closeDataReader();\n  mPos = pos;\n  return;\n}\n// here starts the new logic", "author": "apc999", "createdAt": "2020-11-06T05:47:00Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java", "diffHunk": "@@ -337,8 +343,39 @@ public void seek(long pos) throws IOException {\n     }\n     if (pos < mPos) {\n       mEOF = false;\n+      if (mDataReader instanceof NaiveSharedGrpcDataReader) {", "originalCommit": "b913c5eaf7f3f9e4f3cb2248654a42abcae15968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk0ODIxMg==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518948212", "bodyText": "The try to read data already received but haven't processed logic works for both flag is off and on.  Will change the instanceof to a flag check.", "author": "LuQQiu", "createdAt": "2020-11-06T19:05:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUzNTg0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwMjU4Ng==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519002586", "bodyText": "Changed to if (mContext.getClusterConf().getBoolean(PropertyKey.FUSE_SHARED_CACHING_READER_ENABLED)) {", "author": "LuQQiu", "createdAt": "2020-11-06T21:00:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUzNTg0NA=="}], "type": "inlineReview"}, {"oid": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "url": "https://github.com/Alluxio/alluxio/commit/fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "message": "Change to multi locks and remove close out of lock", "committedDate": "2020-11-06T19:56:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzMjM0Ng==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519032346", "bodyText": "@LuQQiu this else branch is still not guarded and will still be accessible even the flag is off, right?", "author": "apc999", "createdAt": "2020-11-06T22:15:40Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java", "diffHunk": "@@ -337,8 +343,39 @@ public void seek(long pos) throws IOException {\n     }\n     if (pos < mPos) {\n       mEOF = false;\n+      if (mContext.getClusterConf().getBoolean(PropertyKey.FUSE_SHARED_CACHING_READER_ENABLED)) {\n+        SharedGrpcDataReader reader = (SharedGrpcDataReader) mDataReader;\n+        reader.seek(pos);\n+        if (mCurrentChunk != null) {\n+          mCurrentChunk.release();\n+          mCurrentChunk = null;\n+        }\n+      } else {\n+        closeDataReader();\n+      }\n+    } else {", "originalCommit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1NzMwOQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519057309", "bodyText": "Yeah, the change can be applied to all cases, not only related to sharedDataReader.\nDo we want to be safe and put it under the flag for now and maybe add a TODO(lu) to move it not guarded in the future?", "author": "LuQQiu", "createdAt": "2020-11-06T23:42:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzMjM0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA5NzYwNg==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519097606", "bodyText": "yes let's put all the new logic in BlockInStream protected by the flag and leave a TODO.\nThanks", "author": "apc999", "createdAt": "2020-11-07T04:22:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzMjM0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzNDM1MA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519034350", "bodyText": "nit: unnecessary empty lines at line 88 and 95. The code base should be compact for readability in general.", "author": "apc999", "createdAt": "2020-11-06T22:21:45Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.io.Closer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ */\n+@NotThreadSafe\n+public class BufferCachingGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(BufferCachingGrpcDataReader.class);\n+\n+  private final WorkerNetAddress mAddress;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final long mDataTimeoutMs;\n+  private final ReadRequest mReadRequest;\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+  /**\n+   * Count the number of threads that are accessing the same block together.\n+   * When no thread is accessing this block, the cached data will be GCed.\n+   */\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+  private final Closer mCloser;\n+\n+  private AtomicInteger mBufferCount = new AtomicInteger(0);\n+  private final DataBuffer[] mDataBuffers;\n+  private final ReentrantReadWriteLock mBufferLocks = new ReentrantReadWriteLock();\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link BufferCachingGrpcDataReader}.\n+   *\n+   * @param address the data server address\n+   * @param client the block worker client to read data from\n+   * @param dataTimeoutMs the maximum time to wait for a data response\n+   * @param readRequest the read request\n+   * @param stream the underlying gRPC stream to read data\n+   */\n+  private BufferCachingGrpcDataReader(WorkerNetAddress address,\n+      CloseableResource<BlockWorkerClient> client, long dataTimeoutMs,\n+      ReadRequest readRequest, GrpcBlockingStream<ReadRequest, ReadResponse> stream) {\n+    mAddress = address;\n+    mClient = client;\n+    mDataTimeoutMs = dataTimeoutMs;\n+    mMarshaller = new ReadResponseMarshaller();\n+    mPosToRead = readRequest.getOffset();\n+    mReadRequest = readRequest;\n+    mStream = stream;\n+", "originalCommit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3MzUzNA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519073534", "bodyText": "Removed, thanks", "author": "LuQQiu", "createdAt": "2020-11-07T01:03:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzNDM1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzNTYyMg==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519035622", "bodyText": "@Nullable", "author": "apc999", "createdAt": "2020-11-06T22:25:25Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.io.Closer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ */\n+@NotThreadSafe\n+public class BufferCachingGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(BufferCachingGrpcDataReader.class);\n+\n+  private final WorkerNetAddress mAddress;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final long mDataTimeoutMs;\n+  private final ReadRequest mReadRequest;\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+  /**\n+   * Count the number of threads that are accessing the same block together.\n+   * When no thread is accessing this block, the cached data will be GCed.\n+   */\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+  private final Closer mCloser;\n+\n+  private AtomicInteger mBufferCount = new AtomicInteger(0);\n+  private final DataBuffer[] mDataBuffers;\n+  private final ReentrantReadWriteLock mBufferLocks = new ReentrantReadWriteLock();\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link BufferCachingGrpcDataReader}.\n+   *\n+   * @param address the data server address\n+   * @param client the block worker client to read data from\n+   * @param dataTimeoutMs the maximum time to wait for a data response\n+   * @param readRequest the read request\n+   * @param stream the underlying gRPC stream to read data\n+   */\n+  private BufferCachingGrpcDataReader(WorkerNetAddress address,\n+      CloseableResource<BlockWorkerClient> client, long dataTimeoutMs,\n+      ReadRequest readRequest, GrpcBlockingStream<ReadRequest, ReadResponse> stream) {\n+    mAddress = address;\n+    mClient = client;\n+    mDataTimeoutMs = dataTimeoutMs;\n+    mMarshaller = new ReadResponseMarshaller();\n+    mPosToRead = readRequest.getOffset();\n+    mReadRequest = readRequest;\n+    mStream = stream;\n+\n+    mCloser = Closer.create();\n+    mCloser.register(mClient);\n+    mCloser.register(() -> {\n+      mStream.close();\n+      mStream.waitForComplete(mDataTimeoutMs);\n+    });\n+\n+    long blockSize = mReadRequest.getLength() + mReadRequest.getOffset();\n+    long chunkSize = mReadRequest.getChunkSize();\n+    int buffCount = (int) (blockSize / chunkSize);\n+    if ((blockSize % chunkSize) != 0) {\n+      buffCount += 1;\n+    }\n+    mDataBuffers = new DataBuffer[buffCount];\n+  }\n+\n+  /**\n+   * Reads a specific chunk from the block.\n+   *\n+   * @param index the chunk index\n+   * @return the chunk data if exists\n+   */\n+  public DataBuffer readChunk(int index) throws IOException {", "originalCommit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3MzkwNw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519073907", "bodyText": "Done", "author": "LuQQiu", "createdAt": "2020-11-07T01:05:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzNTYyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzODE5MA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519038190", "bodyText": "a few questions on reclaiming resources:\n\nif mClient is closed, do we still need to close mStream, and vise versa\nwhat should be the order to close mStream and mClient?", "author": "apc999", "createdAt": "2020-11-06T22:33:19Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.io.Closer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ */\n+@NotThreadSafe\n+public class BufferCachingGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(BufferCachingGrpcDataReader.class);\n+\n+  private final WorkerNetAddress mAddress;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final long mDataTimeoutMs;\n+  private final ReadRequest mReadRequest;\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+  /**\n+   * Count the number of threads that are accessing the same block together.\n+   * When no thread is accessing this block, the cached data will be GCed.\n+   */\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+  private final Closer mCloser;\n+\n+  private AtomicInteger mBufferCount = new AtomicInteger(0);\n+  private final DataBuffer[] mDataBuffers;\n+  private final ReentrantReadWriteLock mBufferLocks = new ReentrantReadWriteLock();\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link BufferCachingGrpcDataReader}.\n+   *\n+   * @param address the data server address\n+   * @param client the block worker client to read data from\n+   * @param dataTimeoutMs the maximum time to wait for a data response\n+   * @param readRequest the read request\n+   * @param stream the underlying gRPC stream to read data\n+   */\n+  private BufferCachingGrpcDataReader(WorkerNetAddress address,\n+      CloseableResource<BlockWorkerClient> client, long dataTimeoutMs,\n+      ReadRequest readRequest, GrpcBlockingStream<ReadRequest, ReadResponse> stream) {\n+    mAddress = address;\n+    mClient = client;\n+    mDataTimeoutMs = dataTimeoutMs;\n+    mMarshaller = new ReadResponseMarshaller();\n+    mPosToRead = readRequest.getOffset();\n+    mReadRequest = readRequest;\n+    mStream = stream;\n+\n+    mCloser = Closer.create();\n+    mCloser.register(mClient);", "originalCommit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2MzU3MA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519063570", "bodyText": "I guess the original way\n  @Override\n  public void close() throws IOException {\n    try {\n      if (mClient.get().isShutdown()) {\n        return;\n      }\n      mStream.close();\n      mStream.waitForComplete(mDataTimeoutMs);\n    } finally {\n      mMarshaller.close();\n      mClient.close();\n    }\n  }\n\nis used instead of the closer to guarantee the close sequence. The mStream is always close before mClient. So if mClient is shutdown, we know that stream is closed as well.\nin that case, may be better to keep the original way of closing items.", "author": "LuQQiu", "createdAt": "2020-11-07T00:09:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzODE5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3MzMyOA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519073328", "bodyText": "Changed back to the original close way to guarantee the order", "author": "LuQQiu", "createdAt": "2020-11-07T01:02:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzODE5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzODk1MQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519038951", "bodyText": "marking @Nullablewhenever it is possible. IDE will help a lot to warn null check in invokers.", "author": "apc999", "createdAt": "2020-11-06T22:35:31Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.io.Closer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ */\n+@NotThreadSafe\n+public class BufferCachingGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(BufferCachingGrpcDataReader.class);\n+\n+  private final WorkerNetAddress mAddress;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final long mDataTimeoutMs;\n+  private final ReadRequest mReadRequest;\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+  /**\n+   * Count the number of threads that are accessing the same block together.\n+   * When no thread is accessing this block, the cached data will be GCed.\n+   */\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+  private final Closer mCloser;\n+\n+  private AtomicInteger mBufferCount = new AtomicInteger(0);\n+  private final DataBuffer[] mDataBuffers;\n+  private final ReentrantReadWriteLock mBufferLocks = new ReentrantReadWriteLock();\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link BufferCachingGrpcDataReader}.\n+   *\n+   * @param address the data server address\n+   * @param client the block worker client to read data from\n+   * @param dataTimeoutMs the maximum time to wait for a data response\n+   * @param readRequest the read request\n+   * @param stream the underlying gRPC stream to read data\n+   */\n+  private BufferCachingGrpcDataReader(WorkerNetAddress address,\n+      CloseableResource<BlockWorkerClient> client, long dataTimeoutMs,\n+      ReadRequest readRequest, GrpcBlockingStream<ReadRequest, ReadResponse> stream) {\n+    mAddress = address;\n+    mClient = client;\n+    mDataTimeoutMs = dataTimeoutMs;\n+    mMarshaller = new ReadResponseMarshaller();\n+    mPosToRead = readRequest.getOffset();\n+    mReadRequest = readRequest;\n+    mStream = stream;\n+\n+    mCloser = Closer.create();\n+    mCloser.register(mClient);\n+    mCloser.register(() -> {\n+      mStream.close();\n+      mStream.waitForComplete(mDataTimeoutMs);\n+    });\n+\n+    long blockSize = mReadRequest.getLength() + mReadRequest.getOffset();\n+    long chunkSize = mReadRequest.getChunkSize();\n+    int buffCount = (int) (blockSize / chunkSize);\n+    if ((blockSize % chunkSize) != 0) {\n+      buffCount += 1;\n+    }\n+    mDataBuffers = new DataBuffer[buffCount];\n+  }\n+\n+  /**\n+   * Reads a specific chunk from the block.\n+   *\n+   * @param index the chunk index\n+   * @return the chunk data if exists\n+   */\n+  public DataBuffer readChunk(int index) throws IOException {\n+    if (index >= mDataBuffers.length) {\n+      return null;\n+    }\n+\n+    if (index >= mBufferCount.get()) {\n+      try (LockResource r1 = new LockResource(mBufferLocks.writeLock())) {\n+        while (index >= mBufferCount.get()) {\n+          DataBuffer buffer = readChunk();\n+          mDataBuffers[mBufferCount.get()] = buffer;\n+          mBufferCount.incrementAndGet();\n+        }\n+      }\n+    }\n+\n+    return mDataBuffers[index];\n+  }\n+\n+  /**\n+   * Reads a chunk of data.\n+   *\n+   * @return a chunk of data\n+   */\n+  private DataBuffer readChunk() throws IOException {", "originalCommit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3Mzk1OQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519073959", "bodyText": "Added, thanks! Will remember adding Nullable", "author": "LuQQiu", "createdAt": "2020-11-07T01:06:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzODk1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzOTUxNw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519039517", "bodyText": "The following code equivalent but slightly more readable.\nTypically return on failure/error cases earlier is easier to read and reason the control flow\nif (response == null) {\n  return null;\n}\nPreconditions.checkState(response.hasChunk() && response.getChunk().hasData(),\n      \"response should always contain chunk\");\nByteBuffer byteBuffer = response.getChunk().getData().asReadOnlyByteBuffer();\nbuffer = new NioDataBuffer(byteBuffer, byteBuffer.remaining());", "author": "apc999", "createdAt": "2020-11-06T22:37:10Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.io.Closer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ */\n+@NotThreadSafe\n+public class BufferCachingGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(BufferCachingGrpcDataReader.class);\n+\n+  private final WorkerNetAddress mAddress;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final long mDataTimeoutMs;\n+  private final ReadRequest mReadRequest;\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+  /**\n+   * Count the number of threads that are accessing the same block together.\n+   * When no thread is accessing this block, the cached data will be GCed.\n+   */\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+  private final Closer mCloser;\n+\n+  private AtomicInteger mBufferCount = new AtomicInteger(0);\n+  private final DataBuffer[] mDataBuffers;\n+  private final ReentrantReadWriteLock mBufferLocks = new ReentrantReadWriteLock();\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link BufferCachingGrpcDataReader}.\n+   *\n+   * @param address the data server address\n+   * @param client the block worker client to read data from\n+   * @param dataTimeoutMs the maximum time to wait for a data response\n+   * @param readRequest the read request\n+   * @param stream the underlying gRPC stream to read data\n+   */\n+  private BufferCachingGrpcDataReader(WorkerNetAddress address,\n+      CloseableResource<BlockWorkerClient> client, long dataTimeoutMs,\n+      ReadRequest readRequest, GrpcBlockingStream<ReadRequest, ReadResponse> stream) {\n+    mAddress = address;\n+    mClient = client;\n+    mDataTimeoutMs = dataTimeoutMs;\n+    mMarshaller = new ReadResponseMarshaller();\n+    mPosToRead = readRequest.getOffset();\n+    mReadRequest = readRequest;\n+    mStream = stream;\n+\n+    mCloser = Closer.create();\n+    mCloser.register(mClient);\n+    mCloser.register(() -> {\n+      mStream.close();\n+      mStream.waitForComplete(mDataTimeoutMs);\n+    });\n+\n+    long blockSize = mReadRequest.getLength() + mReadRequest.getOffset();\n+    long chunkSize = mReadRequest.getChunkSize();\n+    int buffCount = (int) (blockSize / chunkSize);\n+    if ((blockSize % chunkSize) != 0) {\n+      buffCount += 1;\n+    }\n+    mDataBuffers = new DataBuffer[buffCount];\n+  }\n+\n+  /**\n+   * Reads a specific chunk from the block.\n+   *\n+   * @param index the chunk index\n+   * @return the chunk data if exists\n+   */\n+  public DataBuffer readChunk(int index) throws IOException {\n+    if (index >= mDataBuffers.length) {\n+      return null;\n+    }\n+\n+    if (index >= mBufferCount.get()) {\n+      try (LockResource r1 = new LockResource(mBufferLocks.writeLock())) {\n+        while (index >= mBufferCount.get()) {\n+          DataBuffer buffer = readChunk();\n+          mDataBuffers[mBufferCount.get()] = buffer;\n+          mBufferCount.incrementAndGet();\n+        }\n+      }\n+    }\n+\n+    return mDataBuffers[index];\n+  }\n+\n+  /**\n+   * Reads a chunk of data.\n+   *\n+   * @return a chunk of data\n+   */\n+  private DataBuffer readChunk() throws IOException {\n+    Preconditions.checkState(!mClient.get().isShutdown(),\n+        \"Data reader is closed while reading data chunks.\");\n+    DataBuffer buffer = null;\n+    ReadResponse response = null;\n+    response = mStream.receive(mDataTimeoutMs);\n+    if (response != null) {\n+      Preconditions.checkState(response.hasChunk() && response.getChunk().hasData(),\n+          \"response should always contain chunk\");\n+\n+      ByteBuffer byteBuffer = response.getChunk().getData().asReadOnlyByteBuffer();\n+      buffer = new NioDataBuffer(byteBuffer, byteBuffer.remaining());\n+    } else {\n+      return null;\n+    }", "originalCommit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3NDAyMA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519074020", "bodyText": "Changed, thanks", "author": "LuQQiu", "createdAt": "2020-11-07T01:06:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzOTUxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA0MDc1NA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519040754", "bodyText": "return refcount incremented? kinda confusing to say the current count.", "author": "apc999", "createdAt": "2020-11-06T22:40:53Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.io.Closer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ */\n+@NotThreadSafe\n+public class BufferCachingGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(BufferCachingGrpcDataReader.class);\n+\n+  private final WorkerNetAddress mAddress;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final long mDataTimeoutMs;\n+  private final ReadRequest mReadRequest;\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+  /**\n+   * Count the number of threads that are accessing the same block together.\n+   * When no thread is accessing this block, the cached data will be GCed.\n+   */\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+  private final Closer mCloser;\n+\n+  private AtomicInteger mBufferCount = new AtomicInteger(0);\n+  private final DataBuffer[] mDataBuffers;\n+  private final ReentrantReadWriteLock mBufferLocks = new ReentrantReadWriteLock();\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link BufferCachingGrpcDataReader}.\n+   *\n+   * @param address the data server address\n+   * @param client the block worker client to read data from\n+   * @param dataTimeoutMs the maximum time to wait for a data response\n+   * @param readRequest the read request\n+   * @param stream the underlying gRPC stream to read data\n+   */\n+  private BufferCachingGrpcDataReader(WorkerNetAddress address,\n+      CloseableResource<BlockWorkerClient> client, long dataTimeoutMs,\n+      ReadRequest readRequest, GrpcBlockingStream<ReadRequest, ReadResponse> stream) {\n+    mAddress = address;\n+    mClient = client;\n+    mDataTimeoutMs = dataTimeoutMs;\n+    mMarshaller = new ReadResponseMarshaller();\n+    mPosToRead = readRequest.getOffset();\n+    mReadRequest = readRequest;\n+    mStream = stream;\n+\n+    mCloser = Closer.create();\n+    mCloser.register(mClient);\n+    mCloser.register(() -> {\n+      mStream.close();\n+      mStream.waitForComplete(mDataTimeoutMs);\n+    });\n+\n+    long blockSize = mReadRequest.getLength() + mReadRequest.getOffset();\n+    long chunkSize = mReadRequest.getChunkSize();\n+    int buffCount = (int) (blockSize / chunkSize);\n+    if ((blockSize % chunkSize) != 0) {\n+      buffCount += 1;\n+    }\n+    mDataBuffers = new DataBuffer[buffCount];\n+  }\n+\n+  /**\n+   * Reads a specific chunk from the block.\n+   *\n+   * @param index the chunk index\n+   * @return the chunk data if exists\n+   */\n+  public DataBuffer readChunk(int index) throws IOException {\n+    if (index >= mDataBuffers.length) {\n+      return null;\n+    }\n+\n+    if (index >= mBufferCount.get()) {\n+      try (LockResource r1 = new LockResource(mBufferLocks.writeLock())) {\n+        while (index >= mBufferCount.get()) {\n+          DataBuffer buffer = readChunk();\n+          mDataBuffers[mBufferCount.get()] = buffer;\n+          mBufferCount.incrementAndGet();\n+        }\n+      }\n+    }\n+\n+    return mDataBuffers[index];\n+  }\n+\n+  /**\n+   * Reads a chunk of data.\n+   *\n+   * @return a chunk of data\n+   */\n+  private DataBuffer readChunk() throws IOException {\n+    Preconditions.checkState(!mClient.get().isShutdown(),\n+        \"Data reader is closed while reading data chunks.\");\n+    DataBuffer buffer = null;\n+    ReadResponse response = null;\n+    response = mStream.receive(mDataTimeoutMs);\n+    if (response != null) {\n+      Preconditions.checkState(response.hasChunk() && response.getChunk().hasData(),\n+          \"response should always contain chunk\");\n+\n+      ByteBuffer byteBuffer = response.getChunk().getData().asReadOnlyByteBuffer();\n+      buffer = new NioDataBuffer(byteBuffer, byteBuffer.remaining());\n+    } else {\n+      return null;\n+    }\n+    mPosToRead += buffer.readableBytes();\n+    try {\n+      mStream.send(mReadRequest.toBuilder().setOffsetReceived(mPosToRead).build());\n+    } catch (Exception e) {\n+      // nothing is done as the receipt is sent at best effort\n+      LOG.debug(\"Failed to send receipt of data to worker {} for request {}: {}.\", mAddress,\n+          mReadRequest, e.getMessage());\n+    }\n+    Preconditions.checkState(mPosToRead - mReadRequest.getOffset() <= mReadRequest.getLength());\n+    return buffer;\n+  }\n+\n+  /**\n+   * Closes the {@link BufferCachingGrpcDataReader}.\n+   */\n+  public void close() throws IOException {\n+    if (mClient.get().isShutdown()) {\n+      return;\n+    }\n+    mCloser.close();\n+  }\n+\n+  /**\n+   * Increases the reference count and return the current count.\n+   *\n+   * @return the current count", "originalCommit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3NDAzMw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519074033", "bodyText": "Changed, thanks", "author": "LuQQiu", "createdAt": "2020-11-07T01:06:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA0MDc1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA0MTEzNA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519041134", "bodyText": "final.\nmark member variables final whenever possible.", "author": "apc999", "createdAt": "2020-11-06T22:41:58Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.io.Closer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ */\n+@NotThreadSafe\n+public class BufferCachingGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(BufferCachingGrpcDataReader.class);\n+\n+  private final WorkerNetAddress mAddress;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final long mDataTimeoutMs;\n+  private final ReadRequest mReadRequest;\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+  /**\n+   * Count the number of threads that are accessing the same block together.\n+   * When no thread is accessing this block, the cached data will be GCed.\n+   */\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+  private final Closer mCloser;\n+\n+  private AtomicInteger mBufferCount = new AtomicInteger(0);", "originalCommit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3NDE1Mg==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519074152", "bodyText": "Marked, thanks!", "author": "LuQQiu", "createdAt": "2020-11-07T01:07:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA0MTEzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1MDMyMQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519050321", "bodyText": "do we need to close stream here too?", "author": "apc999", "createdAt": "2020-11-06T23:13:55Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.io.Closer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ */\n+@NotThreadSafe\n+public class BufferCachingGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(BufferCachingGrpcDataReader.class);\n+\n+  private final WorkerNetAddress mAddress;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final long mDataTimeoutMs;\n+  private final ReadRequest mReadRequest;\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+  /**\n+   * Count the number of threads that are accessing the same block together.\n+   * When no thread is accessing this block, the cached data will be GCed.\n+   */\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+  private final Closer mCloser;\n+\n+  private AtomicInteger mBufferCount = new AtomicInteger(0);\n+  private final DataBuffer[] mDataBuffers;\n+  private final ReentrantReadWriteLock mBufferLocks = new ReentrantReadWriteLock();\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link BufferCachingGrpcDataReader}.\n+   *\n+   * @param address the data server address\n+   * @param client the block worker client to read data from\n+   * @param dataTimeoutMs the maximum time to wait for a data response\n+   * @param readRequest the read request\n+   * @param stream the underlying gRPC stream to read data\n+   */\n+  private BufferCachingGrpcDataReader(WorkerNetAddress address,\n+      CloseableResource<BlockWorkerClient> client, long dataTimeoutMs,\n+      ReadRequest readRequest, GrpcBlockingStream<ReadRequest, ReadResponse> stream) {\n+    mAddress = address;\n+    mClient = client;\n+    mDataTimeoutMs = dataTimeoutMs;\n+    mMarshaller = new ReadResponseMarshaller();\n+    mPosToRead = readRequest.getOffset();\n+    mReadRequest = readRequest;\n+    mStream = stream;\n+\n+    mCloser = Closer.create();\n+    mCloser.register(mClient);\n+    mCloser.register(() -> {\n+      mStream.close();\n+      mStream.waitForComplete(mDataTimeoutMs);\n+    });\n+\n+    long blockSize = mReadRequest.getLength() + mReadRequest.getOffset();\n+    long chunkSize = mReadRequest.getChunkSize();\n+    int buffCount = (int) (blockSize / chunkSize);\n+    if ((blockSize % chunkSize) != 0) {\n+      buffCount += 1;\n+    }\n+    mDataBuffers = new DataBuffer[buffCount];\n+  }\n+\n+  /**\n+   * Reads a specific chunk from the block.\n+   *\n+   * @param index the chunk index\n+   * @return the chunk data if exists\n+   */\n+  public DataBuffer readChunk(int index) throws IOException {\n+    if (index >= mDataBuffers.length) {\n+      return null;\n+    }\n+\n+    if (index >= mBufferCount.get()) {\n+      try (LockResource r1 = new LockResource(mBufferLocks.writeLock())) {\n+        while (index >= mBufferCount.get()) {\n+          DataBuffer buffer = readChunk();\n+          mDataBuffers[mBufferCount.get()] = buffer;\n+          mBufferCount.incrementAndGet();\n+        }\n+      }\n+    }\n+\n+    return mDataBuffers[index];\n+  }\n+\n+  /**\n+   * Reads a chunk of data.\n+   *\n+   * @return a chunk of data\n+   */\n+  private DataBuffer readChunk() throws IOException {\n+    Preconditions.checkState(!mClient.get().isShutdown(),\n+        \"Data reader is closed while reading data chunks.\");\n+    DataBuffer buffer = null;\n+    ReadResponse response = null;\n+    response = mStream.receive(mDataTimeoutMs);\n+    if (response != null) {\n+      Preconditions.checkState(response.hasChunk() && response.getChunk().hasData(),\n+          \"response should always contain chunk\");\n+\n+      ByteBuffer byteBuffer = response.getChunk().getData().asReadOnlyByteBuffer();\n+      buffer = new NioDataBuffer(byteBuffer, byteBuffer.remaining());\n+    } else {\n+      return null;\n+    }\n+    mPosToRead += buffer.readableBytes();\n+    try {\n+      mStream.send(mReadRequest.toBuilder().setOffsetReceived(mPosToRead).build());\n+    } catch (Exception e) {\n+      // nothing is done as the receipt is sent at best effort\n+      LOG.debug(\"Failed to send receipt of data to worker {} for request {}: {}.\", mAddress,\n+          mReadRequest, e.getMessage());\n+    }\n+    Preconditions.checkState(mPosToRead - mReadRequest.getOffset() <= mReadRequest.getLength());\n+    return buffer;\n+  }\n+\n+  /**\n+   * Closes the {@link BufferCachingGrpcDataReader}.\n+   */\n+  public void close() throws IOException {\n+    if (mClient.get().isShutdown()) {\n+      return;\n+    }\n+    mCloser.close();\n+  }\n+\n+  /**\n+   * Increases the reference count and return the current count.\n+   *\n+   * @return the current count\n+   */\n+  public int ref() {\n+    return mRefCount.incrementAndGet();\n+  }\n+\n+  /**\n+   * Decreases the reference count and return the current count.\n+   *\n+   * @return the current count\n+   */\n+  public int deRef() {\n+    return mRefCount.decrementAndGet();\n+  }\n+\n+  /**\n+   * @return the current count\n+   */\n+  public int getRefCount() {\n+    return mRefCount.get();\n+  }\n+\n+  /**\n+   * Factory class to create {@link BufferCachingGrpcDataReader}s.\n+   */\n+  public static class Factory {\n+    private final FileSystemContext mContext;\n+    private final WorkerNetAddress mAddress;\n+    private final ReadRequest mReadRequest;\n+\n+    /**\n+     * Creates an instance of {@link BufferCachingGrpcDataReader.Factory} for block reads.\n+     *\n+     * @param context the file system context\n+     * @param address the worker address\n+     * @param readRequest the read request\n+     */\n+    public Factory(FileSystemContext context, WorkerNetAddress address,\n+        ReadRequest readRequest) {\n+      mContext = context;\n+      mAddress = address;\n+      mReadRequest = readRequest;\n+    }\n+\n+    /**\n+     * @return a new {@link BufferCachingGrpcDataReader}\n+     */\n+    public BufferCachingGrpcDataReader create() throws IOException {\n+      AlluxioConfiguration alluxioConf = mContext.getClusterConf();\n+      int readerBufferSizeMessages = alluxioConf\n+          .getInt(PropertyKey.USER_STREAMING_READER_BUFFER_SIZE_MESSAGES);\n+      long dataTimeoutMs = alluxioConf.getMs(PropertyKey.USER_STREAMING_DATA_TIMEOUT);\n+\n+      CloseableResource<BlockWorkerClient> client = mContext.acquireBlockWorkerClient(mAddress);\n+\n+      GrpcBlockingStream<ReadRequest, ReadResponse> stream;\n+      try {\n+        String desc = \"BufferCachingGrpcDataReader\";\n+        if (LOG.isDebugEnabled()) { // More detailed description when debug logging is enabled\n+          desc = MoreObjects.toStringHelper(this)\n+              .add(\"request\", mReadRequest)\n+              .add(\"address\", mAddress)\n+              .toString();\n+        }\n+        // Stream here cannot be GrpcDataMessagingBlockingStream\n+        // DataBuffer.getReadOnlyByteBuffer is used to clone a copy in SharedDataReader.readChunk.\n+        // getReadOnlyByteBuffer is not implemented in DataBuffer\n+        // returned from GrpcDataMessagingBlockingStream.\n+        stream = new GrpcBlockingStream<>(client.get()::readBlock, readerBufferSizeMessages,\n+            desc);\n+        stream.send(mReadRequest, dataTimeoutMs);\n+      } catch (Exception e) {\n+        client.close();", "originalCommit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3NDIxMg==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519074212", "bodyText": "Add the stream close here,\nI am little worry about when creating the stream, errors thrown, but i guess can still do the close() since it checks isOpen first.", "author": "LuQQiu", "createdAt": "2020-11-07T01:08:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1MDMyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1MTM5OA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519051398", "bodyText": "I don't think we need another flag FUSE_SHARED_CACHING_READER_LOCKS on this.\nPicking a constant number like 32 is good enough to ensure ~32 concurrent readers.\nIn general, we should be very conservative in adding new configuration flags.\nUnless we're very sure users will tune it.", "author": "apc999", "createdAt": "2020-11-06T23:18:00Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.InstancedConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ConfigurationUtils;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public class SharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(SharedGrpcDataReader.class);\n+  private static final ReentrantReadWriteLock[] BLOCK_LOCKS;\n+  /** A map from block id to the block's cached data reader. */\n+  @GuardedBy(\"BLOCK_LOCKS\")\n+  private static final ConcurrentHashMap<Long, BufferCachingGrpcDataReader> BLOCK_READERS\n+      = new ConcurrentHashMap<>();\n+\n+  static {\n+    AlluxioConfiguration conf = new InstancedConfiguration(ConfigurationUtils.defaults());\n+    int lockNum = conf.getInt(PropertyKey.FUSE_SHARED_CACHING_READER_LOCKS);", "originalCommit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3NDUwMQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519074501", "bodyText": "Yeah, it may not be helpful and necessary to add it as a property, removed", "author": "LuQQiu", "createdAt": "2020-11-07T01:09:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1MTM5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1MjI2NA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519052264", "bodyText": "let's make a static util method to return the corresponding lock in the lock array based on block Id.\ne.g.,\nprivate static ReentrantReadWriteLock getBlockLock(long blockId) {\n  return BLOCK_LOCKS[(int) (blockId % BLOCK_LOCKS.length)]\n}\n\nThen in both close and create, let's all use the util method rather than hardcode the same logic twice.\nIn case we change the logic in the future, we only need to go one place", "author": "apc999", "createdAt": "2020-11-06T23:21:31Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.InstancedConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ConfigurationUtils;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public class SharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(SharedGrpcDataReader.class);\n+  private static final ReentrantReadWriteLock[] BLOCK_LOCKS;\n+  /** A map from block id to the block's cached data reader. */\n+  @GuardedBy(\"BLOCK_LOCKS\")\n+  private static final ConcurrentHashMap<Long, BufferCachingGrpcDataReader> BLOCK_READERS\n+      = new ConcurrentHashMap<>();\n+\n+  static {\n+    AlluxioConfiguration conf = new InstancedConfiguration(ConfigurationUtils.defaults());\n+    int lockNum = conf.getInt(PropertyKey.FUSE_SHARED_CACHING_READER_LOCKS);\n+    BLOCK_LOCKS = new ReentrantReadWriteLock[lockNum];\n+    for (int i = 0; i < lockNum; i++) {\n+      BLOCK_LOCKS[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  private final long mBlockId;\n+  private final BufferCachingGrpcDataReader mCachedDataReader;\n+  private final long mChunkSize;\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link SharedGrpcDataReader}.\n+   *\n+   * @param readRequest the read request\n+   * @param reader the cached Grpc data reader for the given block\n+   */\n+  private SharedGrpcDataReader(ReadRequest readRequest, BufferCachingGrpcDataReader reader) {\n+    mChunkSize = readRequest.getChunkSize();\n+    mPosToRead = readRequest.getOffset();\n+    mBlockId = readRequest.getBlockId();\n+    mCachedDataReader = reader;\n+  }\n+\n+  @Override\n+  public long pos() {\n+    return mPosToRead;\n+  }\n+\n+  /**\n+   * Seeks to a specific position.\n+   *\n+   * @param pos the position to seek to\n+   */\n+  public void seek(long pos) {\n+    mPosToRead = pos;\n+  }\n+\n+  @Override\n+  public DataBuffer readChunk() throws IOException {\n+    int index = (int) (mPosToRead / mChunkSize);\n+    DataBuffer chunk = mCachedDataReader.readChunk(index);\n+    if (chunk == null) {\n+      return null;\n+    }\n+    ByteBuffer bb = chunk.getReadOnlyByteBuffer();\n+    // Force to align to chunk size\n+    bb.position((int) (mPosToRead % mChunkSize));\n+    mPosToRead += mChunkSize - mPosToRead % mChunkSize;\n+\n+    return new NioDataBuffer(bb, bb.remaining());\n+  }\n+\n+  @Override\n+  public DataBuffer readChunkIfReady() throws IOException {\n+    // I'm naive, I'm reading chunks anyway\n+    return readChunk();\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    if (mCachedDataReader.deRef() == 0) {\n+      try (LockResource lockResource = new LockResource(\n+          BLOCK_LOCKS[(int) (mBlockId % BLOCK_LOCKS.length)].writeLock())) {", "originalCommit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3NDc4OQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519074789", "bodyText": "Changed, thanks", "author": "LuQQiu", "createdAt": "2020-11-07T01:11:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1MjI2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1NTY1Mg==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519055652", "bodyText": "readability suggestion:\nif (mCachedDataReader.deRef() > 0) {\n  return;\n}\n...", "author": "apc999", "createdAt": "2020-11-06T23:34:50Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.InstancedConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ConfigurationUtils;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public class SharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(SharedGrpcDataReader.class);\n+  private static final ReentrantReadWriteLock[] BLOCK_LOCKS;\n+  /** A map from block id to the block's cached data reader. */\n+  @GuardedBy(\"BLOCK_LOCKS\")\n+  private static final ConcurrentHashMap<Long, BufferCachingGrpcDataReader> BLOCK_READERS\n+      = new ConcurrentHashMap<>();\n+\n+  static {\n+    AlluxioConfiguration conf = new InstancedConfiguration(ConfigurationUtils.defaults());\n+    int lockNum = conf.getInt(PropertyKey.FUSE_SHARED_CACHING_READER_LOCKS);\n+    BLOCK_LOCKS = new ReentrantReadWriteLock[lockNum];\n+    for (int i = 0; i < lockNum; i++) {\n+      BLOCK_LOCKS[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  private final long mBlockId;\n+  private final BufferCachingGrpcDataReader mCachedDataReader;\n+  private final long mChunkSize;\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link SharedGrpcDataReader}.\n+   *\n+   * @param readRequest the read request\n+   * @param reader the cached Grpc data reader for the given block\n+   */\n+  private SharedGrpcDataReader(ReadRequest readRequest, BufferCachingGrpcDataReader reader) {\n+    mChunkSize = readRequest.getChunkSize();\n+    mPosToRead = readRequest.getOffset();\n+    mBlockId = readRequest.getBlockId();\n+    mCachedDataReader = reader;\n+  }\n+\n+  @Override\n+  public long pos() {\n+    return mPosToRead;\n+  }\n+\n+  /**\n+   * Seeks to a specific position.\n+   *\n+   * @param pos the position to seek to\n+   */\n+  public void seek(long pos) {\n+    mPosToRead = pos;\n+  }\n+\n+  @Override\n+  public DataBuffer readChunk() throws IOException {\n+    int index = (int) (mPosToRead / mChunkSize);\n+    DataBuffer chunk = mCachedDataReader.readChunk(index);\n+    if (chunk == null) {\n+      return null;\n+    }\n+    ByteBuffer bb = chunk.getReadOnlyByteBuffer();\n+    // Force to align to chunk size\n+    bb.position((int) (mPosToRead % mChunkSize));\n+    mPosToRead += mChunkSize - mPosToRead % mChunkSize;\n+\n+    return new NioDataBuffer(bb, bb.remaining());\n+  }\n+\n+  @Override\n+  public DataBuffer readChunkIfReady() throws IOException {\n+    // I'm naive, I'm reading chunks anyway\n+    return readChunk();\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    if (mCachedDataReader.deRef() == 0) {", "originalCommit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3NDgxMw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519074813", "bodyText": "Done thanks", "author": "LuQQiu", "createdAt": "2020-11-07T01:11:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1NTY1Mg=="}], "type": "inlineReview"}, {"oid": "1dbdd5cbac7591a08106e9a012a9fd26ac104ec6", "url": "https://github.com/Alluxio/alluxio/commit/1dbdd5cbac7591a08106e9a012a9fd26ac104ec6", "message": "Better close", "committedDate": "2020-11-07T00:43:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1OTc3MA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519059770", "bodyText": "This check is not complete. Even the config is true, usual GrpcDataReader will still be used if block size is <= 4 * chunksize.\nWould recommend to keep the logic of checking class of the instance. The logic inner if block is only applicable to cached data reader.", "author": "chaowangnk1", "createdAt": "2020-11-06T23:52:29Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java", "diffHunk": "@@ -337,8 +343,39 @@ public void seek(long pos) throws IOException {\n     }\n     if (pos < mPos) {\n       mEOF = false;\n+      if (mContext.getClusterConf().getBoolean(PropertyKey.FUSE_SHARED_CACHING_READER_ENABLED)) {", "originalCommit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3NjM0OQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519076349", "bodyText": "Oh good catch!! Will change back to instanceof", "author": "LuQQiu", "createdAt": "2020-11-07T01:23:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1OTc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2MjM2Mg==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519062362", "bodyText": "mMarshaller could be removed since it's not used in this class.", "author": "chaowangnk1", "createdAt": "2020-11-07T00:03:31Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.io.Closer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ */\n+@NotThreadSafe\n+public class BufferCachingGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(BufferCachingGrpcDataReader.class);\n+\n+  private final WorkerNetAddress mAddress;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final long mDataTimeoutMs;\n+  private final ReadRequest mReadRequest;\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+  /**\n+   * Count the number of threads that are accessing the same block together.\n+   * When no thread is accessing this block, the cached data will be GCed.\n+   */\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+  private final Closer mCloser;\n+\n+  private AtomicInteger mBufferCount = new AtomicInteger(0);\n+  private final DataBuffer[] mDataBuffers;\n+  private final ReentrantReadWriteLock mBufferLocks = new ReentrantReadWriteLock();\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link BufferCachingGrpcDataReader}.\n+   *\n+   * @param address the data server address\n+   * @param client the block worker client to read data from\n+   * @param dataTimeoutMs the maximum time to wait for a data response\n+   * @param readRequest the read request\n+   * @param stream the underlying gRPC stream to read data\n+   */\n+  private BufferCachingGrpcDataReader(WorkerNetAddress address,\n+      CloseableResource<BlockWorkerClient> client, long dataTimeoutMs,\n+      ReadRequest readRequest, GrpcBlockingStream<ReadRequest, ReadResponse> stream) {\n+    mAddress = address;\n+    mClient = client;\n+    mDataTimeoutMs = dataTimeoutMs;\n+    mMarshaller = new ReadResponseMarshaller();", "originalCommit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3NjQ2Mw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519076463", "bodyText": "Changed, thanks!", "author": "LuQQiu", "createdAt": "2020-11-07T01:24:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2MjM2Mg=="}], "type": "inlineReview"}, {"oid": "3da28c4213483a46fc2ea22644156f9ebedaff02", "url": "https://github.com/Alluxio/alluxio/commit/3da28c4213483a46fc2ea22644156f9ebedaff02", "message": "Fix BlockInStream.seek and remove mMarshaller", "committedDate": "2020-11-07T01:23:54Z", "type": "commit"}, {"oid": "eced1440c8c6cd0d3ae19952e80460c02930b953", "url": "https://github.com/Alluxio/alluxio/commit/eced1440c8c6cd0d3ae19952e80460c02930b953", "message": "Isolate BlockInStream seek fuse logic", "committedDate": "2020-11-08T00:18:04Z", "type": "commit"}]}