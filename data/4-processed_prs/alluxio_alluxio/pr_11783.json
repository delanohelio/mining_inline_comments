{"pr_number": 11783, "pr_title": "Add more options to collectInfo command", "pr_createdAt": "2020-07-20T02:54:25Z", "pr_url": "https://github.com/Alluxio/alluxio/pull/11783", "timeline": [{"oid": "27639c948dfd375ca569f054bf4c6c7f6a0ba85e", "url": "https://github.com/Alluxio/alluxio/commit/27639c948dfd375ca569f054bf4c6c7f6a0ba85e", "message": "checkstyle", "committedDate": "2020-07-22T16:23:20Z", "type": "forcePushed"}, {"oid": "e341ce0c966a2f8ff68f86be88aca6fd869db74a", "url": "https://github.com/Alluxio/alluxio/commit/e341ce0c966a2f8ff68f86be88aca6fd869db74a", "message": "add filename and timestamp selectors", "committedDate": "2020-07-23T02:19:59Z", "type": "commit"}, {"oid": "8bff88fb9f89054a25104709d902c8eeace03383", "url": "https://github.com/Alluxio/alluxio/commit/8bff88fb9f89054a25104709d902c8eeace03383", "message": "add datetime format inferrence unit tests", "committedDate": "2020-07-23T02:19:59Z", "type": "commit"}, {"oid": "43f057f08f7d21c54a0c01d747ee3ab147001b9f", "url": "https://github.com/Alluxio/alluxio/commit/43f057f08f7d21c54a0c01d747ee3ab147001b9f", "message": "do not copy alluxio-site.properties and do a local getConf", "committedDate": "2020-07-23T02:19:59Z", "type": "commit"}, {"oid": "9f14273a982293866ba0f42682ea660b41f828d3", "url": "https://github.com/Alluxio/alluxio/commit/9f14273a982293866ba0f42682ea660b41f828d3", "message": "include/exclude files", "committedDate": "2020-07-23T02:21:32Z", "type": "commit"}, {"oid": "661c3906050bfec65b3cd6b87338748adcc6562e", "url": "https://github.com/Alluxio/alluxio/commit/661c3906050bfec65b3cd6b87338748adcc6562e", "message": "verified time interval selection", "committedDate": "2020-07-23T02:21:32Z", "type": "commit"}, {"oid": "3fb012c8a6b0941e9b5856de264d9a92b57ddd1f", "url": "https://github.com/Alluxio/alluxio/commit/3fb012c8a6b0941e9b5856de264d9a92b57ddd1f", "message": "checkstyle", "committedDate": "2020-07-23T02:21:32Z", "type": "commit"}, {"oid": "44eadf4e8bce68574cb00124d95fc260ea872481", "url": "https://github.com/Alluxio/alluxio/commit/44eadf4e8bce68574cb00124d95fc260ea872481", "message": "checkstyl", "committedDate": "2020-07-23T02:21:32Z", "type": "commit"}, {"oid": "5817ed43ada0be247949cfd3f41d2b627a77de85", "url": "https://github.com/Alluxio/alluxio/commit/5817ed43ada0be247949cfd3f41d2b627a77de85", "message": "small changes", "committedDate": "2020-07-23T02:21:32Z", "type": "commit"}, {"oid": "3c5dbd5213734691355c34de9138b58ac21845d1", "url": "https://github.com/Alluxio/alluxio/commit/3c5dbd5213734691355c34de9138b58ac21845d1", "message": "smallfixes", "committedDate": "2020-07-23T03:19:44Z", "type": "commit"}, {"oid": "3c5dbd5213734691355c34de9138b58ac21845d1", "url": "https://github.com/Alluxio/alluxio/commit/3c5dbd5213734691355c34de9138b58ac21845d1", "message": "smallfixes", "committedDate": "2020-07-23T03:19:44Z", "type": "forcePushed"}, {"oid": "2d8e058355367addd575f70928c1c0dd942b1e17", "url": "https://github.com/Alluxio/alluxio/commit/2d8e058355367addd575f70928c1c0dd942b1e17", "message": "checkstyle", "committedDate": "2020-07-23T03:39:20Z", "type": "commit"}, {"oid": "3b899a7047b7e73ee144b6f6bb9ef0663b17b5ab", "url": "https://github.com/Alluxio/alluxio/commit/3b899a7047b7e73ee144b6f6bb9ef0663b17b5ab", "message": "findbugs", "committedDate": "2020-07-23T05:10:49Z", "type": "commit"}, {"oid": "2565428f0481809f8fffe7cfb85dbeb950ff7a80", "url": "https://github.com/Alluxio/alluxio/commit/2565428f0481809f8fffe7cfb85dbeb950ff7a80", "message": "smallfixes", "committedDate": "2020-07-23T07:19:34Z", "type": "commit"}, {"oid": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03", "url": "https://github.com/Alluxio/alluxio/commit/98934aea14aef7e3a0257ec9c29f0e4c5b479b03", "message": "verified", "committedDate": "2020-07-23T10:40:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM4MzcxNQ==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r459383715", "bodyText": "The parsed options will propagate to subcommands.", "author": "jiacheliu3", "createdAt": "2020-07-23T11:32:24Z", "path": "shell/src/main/java/alluxio/cli/bundler/CollectInfo.java", "diffHunk": "@@ -404,7 +466,7 @@ private int executeAndAddFile(String[] argv, List<File> filesToCollect) throws I\n       printHelp(String.format(\"%s is an unknown command.%n\", subCommand));\n       return 1;\n     }\n-    int ret = run(argv);\n+    int ret = cmd.run(cmdLine);", "originalCommit": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM4NDA3Mw==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r459384073", "bodyText": "The index changed cuz the invocation method changed.\n-    int ret = run(argv);\n+    int ret = cmd.run(cmdLine);", "author": "jiacheliu3", "createdAt": "2020-07-23T11:33:14Z", "path": "shell/src/main/java/alluxio/cli/bundler/command/AbstractCollectInfoCommand.java", "diffHunk": "@@ -56,12 +56,15 @@ public void validateArgs(CommandLine cl) throws InvalidArgumentException {\n    * */\n   public String getWorkingDirectory(CommandLine cl) {\n     String[] args = cl.getArgs();\n-    String baseDirPath = args[0];\n+    String baseDirPath = args[1];", "originalCommit": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM4NDU1NQ==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r459384555", "bodyText": "This will create parent directories if not existent.", "author": "jiacheliu3", "createdAt": "2020-07-23T11:34:23Z", "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectLogCommand.java", "diffHunk": "@@ -53,15 +156,149 @@ public boolean hasSubCommand() {\n   public int run(CommandLine cl) throws AlluxioException, IOException {\n     // Determine the working dir path\n     mWorkingDirPath = getWorkingDirectory(cl);\n-    String logDir = mFsContext.getClusterConf().get(PropertyKey.LOGS_DIR);\n \n     // TODO(jiacheng): phase 2 Copy intelligently find security risks\n-    // TODO(jiacheng): phase 2 components option\n-    FileUtils.copyDirectory(new File(logDir), new File(mWorkingDirPath), true);\n+    mIncludedPrefix = new HashSet<>(FILE_NAMES);\n+    // Define include list and exclude list\n+    if (cl.hasOption(INCLUDE_OPTION_NAME)) {\n+      Set<String> toInclude = parseFileNames(cl.getOptionValue(INCLUDE_OPTION_NAME));\n+      System.out.format(\"Include the following filename prefixes: %s%n\", toInclude);\n+      mIncludedPrefix.addAll(toInclude);\n+    }\n+    if (cl.hasOption(EXCLUDE_OPTION_NAME)) {\n+      mExcludedPrefix = parseFileNames(cl.getOptionValue(EXCLUDE_OPTION_NAME));\n+      System.out.format(\"Exclude the following filename prefixes: %s%n\", mExcludedPrefix);\n+    }\n+\n+    // Check file timestamps\n+    boolean checkTimeStamp = false;\n+    if (cl.hasOption(START_OPTION_NAME)) {\n+      String startTimeStr = cl.getOptionValue(START_OPTION_NAME);\n+      mStartTime = parseDateTime(startTimeStr);\n+      System.out.format(\"Time window start: %s%n\", mStartTime);\n+      checkTimeStamp = true;\n+    }\n+    if (cl.hasOption(END_OPTION_NAME)) {\n+      String endTimeStr = cl.getOptionValue(END_OPTION_NAME);\n+      mEndTime = parseDateTime(endTimeStr);\n+      System.out.format(\"Time window end: %s%n\", mEndTime);\n+      checkTimeStamp = true;\n+    }\n+    if (mStartTime != null && mEndTime != null && mStartTime.isAfter(mEndTime)) {\n+      System.err.format(\"ERROR: Start time %s is later than end time %s!%n\",\n+              mStartTime, mEndTime);\n+    }\n+\n+    if (!mLogDir.exists()) {\n+      System.err.format(\"ERROR: Alluxio log directory %s does not exist!%n\", mLogDirPath);\n+      return -1;\n+    }\n+\n+    List<File> allFiles = CommonUtils.recursiveListDir(mLogDir);\n+    for (File f : allFiles) {\n+      String relativePath = getRelativePathToLogDir(f);\n+      try {\n+        if (!shouldCopy(f, relativePath, checkTimeStamp)) {\n+          continue;\n+        }\n+        File targetFile = new File(mWorkingDirPath, relativePath);\n+        FileUtils.copyFile(f, targetFile, true);", "originalCommit": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM4NjE0NA==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r459386144", "bodyText": "This invokes Set#equals which compares the size and checks existence of all elements.", "author": "jiacheliu3", "createdAt": "2020-07-23T11:37:53Z", "path": "shell/src/test/java/alluxio/cli/bundler/InfoCollectorTestUtils.java", "diffHunk": "@@ -37,12 +44,37 @@ public static File createTemporaryDirectory() {\n   }\n \n   public static File createFileInDir(File dir, String fileName) throws IOException {\n-    File newFile = new File(Paths.get(dir.getAbsolutePath(), fileName).toString());\n+    File newFile = new File(Paths.get(dir.getCanonicalPath(), fileName).toUri());\n     newFile.createNewFile();\n     return newFile;\n   }\n \n+  public static File createDirInDir(File dir, String dirName) throws IOException {\n+    File newDir = new File(Paths.get(dir.getCanonicalPath(), dirName).toUri());\n+    newDir.mkdir();\n+    return newDir;\n+  }\n+\n   public static void create() {\n     Files.createTempDir();\n   }\n+\n+  public static void verifyAllFiles(File targetDir, Set<String> expectedFiles) throws IOException {\n+    Set<String> copiedFiles = getAllFileNamesRelative(targetDir, targetDir);\n+    assertEquals(expectedFiles, copiedFiles);", "originalCommit": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM4NjczMQ==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r459386731", "bodyText": "It might be controversial whether we use real content or abstractions here. I would argue real logs capture more.", "author": "jiacheliu3", "createdAt": "2020-07-23T11:39:09Z", "path": "shell/src/test/java/alluxio/cli/bundler/command/CollectLogCommandTest.java", "diffHunk": "@@ -19,56 +22,500 @@\n import alluxio.conf.InstancedConfiguration;\n import alluxio.conf.PropertyKey;\n import alluxio.exception.AlluxioException;\n+import alluxio.util.CommonUtils;\n \n import org.apache.commons.cli.CommandLine;\n-import org.junit.Assert;\n-import org.junit.BeforeClass;\n+import org.hamcrest.Description;\n+import org.hamcrest.TypeSafeMatcher;\n+import org.junit.After;\n+import org.junit.Before;\n import org.junit.Test;\n \n import java.io.File;\n+import java.io.FileWriter;\n import java.io.IOException;\n-import java.nio.file.Paths;\n-import java.util.Arrays;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n \n public class CollectLogCommandTest {\n-  private static InstancedConfiguration sConf;\n-  private static File sTestDir;\n-\n-  @BeforeClass\n-  public static void initConf() throws IOException {\n-    sTestDir = prepareLogDir(\"testLog\");\n-    sConf = InstancedConfiguration.defaults();\n-    sConf.set(PropertyKey.LOGS_DIR, sTestDir.getAbsolutePath());\n+  private static final int MILLISEC_TO_NANOSEC = 1_000_000;\n+\n+  private InstancedConfiguration mConf;\n+  private File mTestDir;\n+  private Set<String> mExpectedFiles;\n+\n+  @Before\n+  public void initLogDirAndConf() throws IOException {\n+    mTestDir = prepareLogDir();\n+    mConf = InstancedConfiguration.defaults();\n+    mConf.set(PropertyKey.LOGS_DIR, mTestDir.getAbsolutePath());\n+  }\n+\n+  @After\n+  public void emptyLogDir() {\n+    mConf.unset(PropertyKey.LOGS_DIR);\n+    mTestDir.delete();\n   }\n \n   // Prepare a temp dir with some log files\n-  private static File prepareLogDir(String prefix) throws IOException {\n+  private File prepareLogDir() throws IOException {\n     // The dir path will contain randomness so will be different every time\n-    File testConfDir = InfoCollectorTestUtils.createTemporaryDirectory();\n-    InfoCollectorTestUtils.createFileInDir(testConfDir, \"master.log\");\n-    InfoCollectorTestUtils.createFileInDir(testConfDir, \"worker.log\");\n-    return testConfDir;\n+    File testLogDir = InfoCollectorTestUtils.createTemporaryDirectory();\n+    // Prepare the normal log files that normal users will have\n+    for (String s : CollectLogCommand.FILE_NAMES) {\n+      InfoCollectorTestUtils.createFileInDir(testLogDir, s);\n+    }\n+    // Create some extra log files\n+    InfoCollectorTestUtils.createFileInDir(testLogDir, \"master.log.1\");\n+    InfoCollectorTestUtils.createFileInDir(testLogDir, \"master.log.2\");\n+    InfoCollectorTestUtils.createFileInDir(testLogDir, \"worker.log.backup\");\n+    // Remove the user file and create a directory\n+    File userDir = new File(testLogDir, \"user\");\n+    if (userDir.exists()) {\n+      userDir.delete();\n+    }\n+    // Put logs in the user log dir\n+    File userLogDir = InfoCollectorTestUtils.createDirInDir(testLogDir, \"user\");\n+    InfoCollectorTestUtils.createFileInDir(userLogDir, \"user_hadoop.log\");\n+    InfoCollectorTestUtils.createFileInDir(userLogDir, \"user_hadoop.out\");\n+    InfoCollectorTestUtils.createFileInDir(userLogDir, \"user_root.log\");\n+    InfoCollectorTestUtils.createFileInDir(userLogDir, \"user_root.out\");\n+\n+    // Set up expectation\n+    Set<String> createdFiles = InfoCollectorTestUtils\n+            .getAllFileNamesRelative(testLogDir, testLogDir);\n+    mExpectedFiles = createdFiles;\n+\n+    return testLogDir;\n+  }\n+\n+  @Test\n+  public void logFilesCopied() throws IOException, AlluxioException {\n+    CollectLogCommand cmd = new CollectLogCommand(FileSystemContext.create(mConf));\n+\n+    File targetDir = InfoCollectorTestUtils.createTemporaryDirectory();\n+    CommandLine mockCommandLine = mock(CommandLine.class);\n+    String[] mockArgs = new String[]{cmd.getCommandName(), targetDir.getAbsolutePath()};\n+    when(mockCommandLine.getArgs()).thenReturn(mockArgs);\n+    int ret = cmd.run(mockCommandLine);\n+    assertEquals(0, ret);\n+\n+    // Files will be copied to sub-dir of target dir\n+    File subDir = new File(targetDir, cmd.getCommandName());\n+\n+    InfoCollectorTestUtils.verifyAllFiles(subDir, mExpectedFiles);\n+  }\n+\n+  @Test\n+  public void irrelevantFileIgnored() throws Exception {\n+    // This file will not be copied\n+    // Not included in the expected set\n+    InfoCollectorTestUtils.createFileInDir(mTestDir, \"irrelevant\");\n+\n+    CollectLogCommand cmd = new CollectLogCommand(FileSystemContext.create(mConf));\n+    File targetDir = InfoCollectorTestUtils.createTemporaryDirectory();\n+    CommandLine mockCommandLine = mock(CommandLine.class);\n+    String[] mockArgs = new String[]{cmd.getCommandName(), targetDir.getAbsolutePath()};\n+    when(mockCommandLine.getArgs()).thenReturn(mockArgs);\n+    int ret = cmd.run(mockCommandLine);\n+    assertEquals(0, ret);\n+\n+    // Files will be copied to sub-dir of target dir\n+    File subDir = new File(targetDir, cmd.getCommandName());\n+\n+    InfoCollectorTestUtils.verifyAllFiles(subDir, mExpectedFiles);\n+  }\n+\n+  @Test\n+  public void fileNameExcluded() throws Exception {\n+    CollectLogCommand cmd = new CollectLogCommand(FileSystemContext.create(mConf));\n+    File targetDir = InfoCollectorTestUtils.createTemporaryDirectory();\n+    CommandLine mockCommandLine = mock(CommandLine.class);\n+    String[] mockArgs = new String[]{\n+            cmd.getCommandName(),\n+            targetDir.getAbsolutePath()\n+    };\n+    when(mockCommandLine.getArgs()).thenReturn(mockArgs);\n+    when(mockCommandLine.hasOption(eq(\"exclude-logs\"))).thenReturn(true);\n+    when(mockCommandLine.getOptionValue(eq(\"exclude-logs\"))).thenReturn(\"master.log.1, worker\");\n+    int ret = cmd.run(mockCommandLine);\n+    assertEquals(0, ret);\n+\n+    // Files will be copied to sub-dir of target dir\n+    File subDir = new File(targetDir, cmd.getCommandName());\n+    mExpectedFiles.remove(\"master.log.1\");\n+    mExpectedFiles.remove(\"worker.log\");\n+    mExpectedFiles.remove(\"worker.out\");\n+    mExpectedFiles.remove(\"worker.log.backup\");\n+\n+    InfoCollectorTestUtils.verifyAllFiles(subDir, mExpectedFiles);\n   }\n \n   @Test\n-  public void logDirCopied() throws IOException, AlluxioException {\n-    CollectLogCommand cmd = new CollectLogCommand(FileSystemContext.create(sConf));\n+  public void fileNameIncluded() throws Exception {\n+    InfoCollectorTestUtils.createFileInDir(mTestDir, \"alluxio_gc.log\");\n+    InfoCollectorTestUtils.createFileInDir(mTestDir, \"alluxio_gc.log.1\");\n+    InfoCollectorTestUtils.createFileInDir(mTestDir, \"alluxio_gc.log.2\");\n \n+    CollectLogCommand cmd = new CollectLogCommand(FileSystemContext.create(mConf));\n     File targetDir = InfoCollectorTestUtils.createTemporaryDirectory();\n     CommandLine mockCommandLine = mock(CommandLine.class);\n-    String[] mockArgs = new String[]{targetDir.getAbsolutePath()};\n+    String[] mockArgs = new String[]{\n+            cmd.getCommandName(),\n+            targetDir.getAbsolutePath()\n+    };\n     when(mockCommandLine.getArgs()).thenReturn(mockArgs);\n+    when(mockCommandLine.hasOption(eq(\"include-logs\"))).thenReturn(true);\n+    when(mockCommandLine.getOptionValue(eq(\"include-logs\"))).thenReturn(\"alluxio_gc\");\n     int ret = cmd.run(mockCommandLine);\n-    Assert.assertEquals(0, ret);\n+    assertEquals(0, ret);\n \n     // Files will be copied to sub-dir of target dir\n-    File subDir = new File(Paths.get(targetDir.getAbsolutePath(), cmd.getCommandName()).toString());\n-\n-    // Check the dir copied\n-    String[] files = subDir.list();\n-    Arrays.sort(files);\n-    String[] expectedFiles = sTestDir.list();\n-    Arrays.sort(expectedFiles);\n-    Assert.assertEquals(expectedFiles, files);\n+    File subDir = new File(targetDir, cmd.getCommandName());\n+    mExpectedFiles.add(\"alluxio_gc.log\");\n+    mExpectedFiles.add(\"alluxio_gc.log.1\");\n+    mExpectedFiles.add(\"alluxio_gc.log.2\");\n+\n+    InfoCollectorTestUtils.verifyAllFiles(subDir, mExpectedFiles);\n+  }\n+\n+  @Test\n+  public void endTimeFilter() throws Exception {\n+    // Define an issue end datetime\n+    // We ignore logs that are created after this\n+    LocalDateTime issueEnd = LocalDateTime.of(2020, 7, 8, 18, 0, 0);\n+    DateTimeFormatter fmt = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\n+\n+    // Other logs all end before this issue\n+    LocalDateTime logEnd = issueEnd.minusHours(1);\n+    long logEndTimestamp = logEnd.toEpochSecond(ZoneOffset.UTC);\n+    for (File f : CommonUtils.recursiveListDir(mTestDir)) {\n+      f.setLastModified(logEndTimestamp);\n+    }\n+\n+    // Some logs are created after this time, should be ignored\n+    File masterLog = new File(mTestDir, \"master.log\");\n+    String log = \"2020-07-08 18:53:45,129 INFO  CopycatServer - Server started successfully!\\n\"\n+            + \"2020-07-08 18:53:59,129 INFO  RaftJournalSystem - Started Raft Journal System..\\n\"\n+            + \"2020-07-09 00:01:59,135 INFO  DefaultMetaMaster - Standby master with address...\\n\"\n+            + \"2020-07-09 00:03:59,135 INFO  AlluxioMasterProcess - All masters started\\n\"\n+            + \"2020-07-09 01:12:59,138 INFO  AbstractPrimarySelector - Primary selector..\\n\"\n+            + \"2020-07-09 01:53:59,139 INFO  AbstractMaster - TableMaster: Stopped secondary..\";", "originalCommit": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5ODY2MA==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r459598660", "bodyText": "Can we add a unittest for this method?", "author": "gpang", "createdAt": "2020-07-23T17:05:52Z", "path": "core/common/src/main/java/alluxio/util/CommonUtils.java", "diffHunk": "@@ -828,5 +829,28 @@ public static boolean isAddressReachable(String hostname, int port) {\n     }\n   }\n \n+  /**\n+   * Recursively lists a dir and all its subdirs and return all the files.\n+   *\n+   * @param dir the directory\n+   * @return a list of all the files\n+   * */\n+  public static List<File> recursiveListDir(File dir) {", "originalCommit": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5OTA1OA==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r459599058", "bodyText": "Use Collections.emptyList() to avoid a new instance.", "author": "gpang", "createdAt": "2020-07-23T17:06:35Z", "path": "core/common/src/main/java/alluxio/util/CommonUtils.java", "diffHunk": "@@ -828,5 +829,28 @@ public static boolean isAddressReachable(String hostname, int port) {\n     }\n   }\n \n+  /**\n+   * Recursively lists a dir and all its subdirs and return all the files.\n+   *\n+   * @param dir the directory\n+   * @return a list of all the files\n+   * */\n+  public static List<File> recursiveListDir(File dir) {\n+    File[] files = dir.listFiles();\n+    // File#listFiles can return null when the path is invalid\n+    if (files == null) {\n+      return new ArrayList<>();", "originalCommit": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYwMDAwNg==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r459600006", "bodyText": "This lists a local dir, right? I think we should mention that in the javadoc and the name of the method.", "author": "gpang", "createdAt": "2020-07-23T17:08:17Z", "path": "core/common/src/main/java/alluxio/util/CommonUtils.java", "diffHunk": "@@ -828,5 +829,28 @@ public static boolean isAddressReachable(String hostname, int port) {\n     }\n   }\n \n+  /**\n+   * Recursively lists a dir and all its subdirs and return all the files.", "originalCommit": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYwNjIzOQ==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r459606239", "bodyText": "Somewhere in this usage message, we need to show how include and exclude work (relative order of them), and how start, end time work", "author": "gpang", "createdAt": "2020-07-23T17:18:45Z", "path": "shell/src/main/java/alluxio/cli/bundler/CollectInfo.java", "diffHunk": "@@ -61,7 +64,9 @@\n public class CollectInfo extends AbstractShell {\n   private static final Logger LOG = LoggerFactory.getLogger(CollectInfo.class);\n   private static final String USAGE =\n-      \"USAGE: collectInfo [--max-threads <threadNum>] [--local] [--help] COMMAND <outputPath>\\n\\n\"\n+      \"USAGE: collectInfo [--max-threads <threadNum>] [--local] [--help] \"\n+          + \"[--exclude-logs <filename-prefixes>] [--include-logs <filename-prefixes>] \"", "originalCommit": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTkzMDEyNA==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r459930124", "bodyText": "The help messages for options are printed at \n  \n    \n      alluxio/shell/src/main/java/alluxio/cli/bundler/CollectInfo.java\n    \n    \n         Line 154\n      in\n      c1ea6f3\n    \n    \n    \n    \n\n        \n          \n           help.printHelp(USAGE, OPTIONS); \n        \n    \n  \n\n Basically the description for each option is shown.\nFor a message that is more verbose, like working examples and how they can be organized to serve use cases, I guess that better suits to be in the document (linked in the help message for CollectInfo). What do you think?", "author": "jiacheliu3", "createdAt": "2020-07-24T08:53:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYwNjIzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI0MzQ1MQ==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461243451", "bodyText": "ahhh, ok. Now, I see the sub-command help. Then, why does this top level usage help mention start-time and include-logs, etc, when it is only a sub command option?", "author": "gpang", "createdAt": "2020-07-28T00:17:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYwNjIzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMwMDY0Mg==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461300642", "bodyText": "I extracted these option arguments here because they are shared by two options each. Seems it has more confusion that benefit, I will move it back to under the option.", "author": "jiacheliu3", "createdAt": "2020-07-28T03:48:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYwNjIzOQ=="}], "type": "inlineReview"}, {"oid": "bd63cf8efc3d129f85b38c0e27890bfca434eb84", "url": "https://github.com/Alluxio/alluxio/commit/bd63cf8efc3d129f85b38c0e27890bfca434eb84", "message": "resolve comment", "committedDate": "2020-07-24T08:42:27Z", "type": "commit"}, {"oid": "42964e5bde55199b2616dda9d09f856175a70c22", "url": "https://github.com/Alluxio/alluxio/commit/42964e5bde55199b2616dda9d09f856175a70c22", "message": "checkstyle", "committedDate": "2020-07-24T08:44:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI0NDE5Nw==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461244197", "bodyText": "This message makes it sound like the user should run mkdir. Instead, this could say:\n\"Creating working directory: %s %n\"\nSo it sounds like the command is creating the directory.", "author": "gpang", "createdAt": "2020-07-28T00:20:16Z", "path": "shell/src/main/java/alluxio/cli/bundler/command/AbstractCollectInfoCommand.java", "diffHunk": "@@ -56,12 +56,15 @@ public void validateArgs(CommandLine cl) throws InvalidArgumentException {\n    * */\n   public String getWorkingDirectory(CommandLine cl) {\n     String[] args = cl.getArgs();\n-    String baseDirPath = args[0];\n+    String baseDirPath = args[1];\n     String workingDirPath =  Paths.get(baseDirPath, this.getCommandName()).toString();\n     LOG.debug(\"Command %s works in %s\", this.getCommandName(), workingDirPath);\n     // mkdirs checks existence of the path\n     File workingDir = new File(workingDirPath);\n-    workingDir.mkdirs();\n+    if (!workingDir.exists()) {\n+      System.out.format(\"Working path %s does not exist. mkdir first%n\", workingDirPath);", "originalCommit": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI0NTg3Mw==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461245873", "bodyText": "is this to avoid copying credentials?", "author": "gpang", "createdAt": "2020-07-28T00:25:52Z", "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectConfigCommand.java", "diffHunk": "@@ -30,6 +36,10 @@\n   public static final String COMMAND_NAME = \"collectConfig\";\n   private static final Logger LOG = LoggerFactory.getLogger(CollectConfigCommand.class);\n \n+  private static final Set<String> EXCLUDED_FILES = Stream.of(\n+          Constants.SITE_PROPERTIES", "originalCommit": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMwMTIyNg==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461301226", "bodyText": "Yes this avoids copying unmasked credentials from alluxio-site.properties. We now do a local \"alluxio getConf\" which prints the credentials masked, and collect the output.\nHowever if the credentials are in alluxio-env.sh or elsewhere (given via ALLUXIO_JAVA_OPTS for example), I don't have a way to skip/mask them.", "author": "jiacheliu3", "createdAt": "2020-07-28T03:50:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI0NTg3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI0NTk3Ng==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461245976", "bodyText": "Would ImmutableSet.of(...) work?", "author": "gpang", "createdAt": "2020-07-28T00:26:12Z", "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectConfigCommand.java", "diffHunk": "@@ -30,6 +36,10 @@\n   public static final String COMMAND_NAME = \"collectConfig\";\n   private static final Logger LOG = LoggerFactory.getLogger(CollectConfigCommand.class);\n \n+  private static final Set<String> EXCLUDED_FILES = Stream.of(\n+          Constants.SITE_PROPERTIES\n+  ).collect(Collectors.toSet());", "originalCommit": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI0NjQ2NA==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461246464", "bodyText": "If these are supposed to prefixes, the variable name should be something like EXCLUDED_FILE_PREFIXES or something.", "author": "gpang", "createdAt": "2020-07-28T00:28:00Z", "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectConfigCommand.java", "diffHunk": "@@ -52,10 +62,21 @@ public boolean hasSubCommand() {\n   @Override\n   public int run(CommandLine cl) throws AlluxioException, IOException {\n     mWorkingDirPath = getWorkingDirectory(cl);\n-    String confDir = mFsContext.getClusterConf().get(PropertyKey.CONF_DIR);\n+    String confDirPath = mFsContext.getClusterConf().get(PropertyKey.CONF_DIR);\n \n-    // TODO(jiacheng): phase 2 copy intelligently, check security risks\n-    FileUtils.copyDirectory(new File(confDir), new File(mWorkingDirPath), true);\n+    File confDir = new File(confDirPath);\n+    List<File> allFiles = CommonUtils.recursiveListDir(confDir);\n+    for (File f : allFiles) {\n+      String relativePath = confDir.toURI().relativize(f.toURI()).getPath();\n+      // Ignore file prefixes to exclude\n+      for (String prefix : EXCLUDED_FILES) {", "originalCommit": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI0NjgwOQ==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461246809", "bodyText": "Is relativePath just the filename part?", "author": "gpang", "createdAt": "2020-07-28T00:29:05Z", "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectConfigCommand.java", "diffHunk": "@@ -52,10 +62,21 @@ public boolean hasSubCommand() {\n   @Override\n   public int run(CommandLine cl) throws AlluxioException, IOException {\n     mWorkingDirPath = getWorkingDirectory(cl);\n-    String confDir = mFsContext.getClusterConf().get(PropertyKey.CONF_DIR);\n+    String confDirPath = mFsContext.getClusterConf().get(PropertyKey.CONF_DIR);\n \n-    // TODO(jiacheng): phase 2 copy intelligently, check security risks\n-    FileUtils.copyDirectory(new File(confDir), new File(mWorkingDirPath), true);\n+    File confDir = new File(confDirPath);\n+    List<File> allFiles = CommonUtils.recursiveListDir(confDir);\n+    for (File f : allFiles) {\n+      String relativePath = confDir.toURI().relativize(f.toURI()).getPath();\n+      // Ignore file prefixes to exclude\n+      for (String prefix : EXCLUDED_FILES) {\n+        if (relativePath.startsWith(prefix)) {", "originalCommit": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMyMjM0NQ==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461322345", "bodyText": "Your are right, when checking the prefix it should be checking against the filename. The relativePath is the path relative to the conf dir, when the config files can be in nested directories. I think we still need the relativePath when copying, as we want to preserve the directory structure.", "author": "jiacheliu3", "createdAt": "2020-07-28T05:13:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI0NjgwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI0ODU0Ng==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461248546", "bodyText": "Is String.length() slow?", "author": "gpang", "createdAt": "2020-07-28T00:34:56Z", "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectLogCommand.java", "diffHunk": "@@ -71,4 +308,34 @@ public String getUsage() {\n   public String getDescription() {\n     return \"Collect Alluxio log files\";\n   }\n+\n+  /**\n+   * Identifies the datetime from a certain piece of log by trying various known patterns.\n+   * Returns null if unable to identify a datetime.\n+   *\n+   * @param s a log entry\n+   * @return identified datetime\n+   * */\n+  @Nullable\n+  public static LocalDateTime parseDateTime(String s) {\n+    for (Map.Entry<String, Integer> entry : FORMAT_TO_LEN.entrySet()) {\n+      String f = entry.getKey();\n+      int len = entry.getValue();", "originalCommit": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMyMzQ3MA==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461323470", "bodyText": "The thing is, the real length of the datetime string like \"2020-07-25T12:05:12.123+0800\" is not the same as length of the pattern \"yyyy-MM-dd'T'HH:mm:ss.SSSXX\". Note that the single quotes around T should not be counted and XX expands to \"+0800\".\nYea I should add examples to these formats.", "author": "jiacheliu3", "createdAt": "2020-07-28T05:16:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI0ODU0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI0ODc3Mg==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461248772", "bodyText": "Why can't this just be a list? Why do we need to cache the length?", "author": "gpang", "createdAt": "2020-07-28T00:35:43Z", "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectLogCommand.java", "diffHunk": "@@ -14,21 +14,121 @@\n import alluxio.client.file.FileSystemContext;\n import alluxio.conf.PropertyKey;\n import alluxio.exception.AlluxioException;\n+import alluxio.util.CommonUtils;\n \n+import jline.internal.Nullable;\n import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n import org.apache.commons.io.FileUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.io.File;\n+import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.net.URI;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n /**\n  * Command to collect Alluxio logs.\n  * */\n public class CollectLogCommand  extends AbstractCollectInfoCommand {\n   public static final String COMMAND_NAME = \"collectLog\";\n   private static final Logger LOG = LoggerFactory.getLogger(CollectLogCommand.class);\n+  public static final Set<String> FILE_NAMES = Stream.of(\n+      \"master.log\",\n+      \"master.out\",\n+      \"job_master.log\",\n+      \"job_master.out\",\n+      \"master_audit.log\",\n+      \"worker.log\",\n+      \"worker.out\",\n+      \"job_worker.log\",\n+      \"job_worker.out\",\n+      \"proxy.log\",\n+      \"proxy.out\",\n+      \"task.log\",\n+      \"task.out\",\n+      \"user\"\n+  ).collect(Collectors.toSet());\n+  // We tolerate the beginning of a log file to contain some rows that are not timestamped.\n+  // 30 is chosen because a YARN application log can have >20 rows in the beginning for\n+  // general information about a job.\n+  // The timestamped log entries start after this general information block.\n+  private static final int TRY_PARSE_LOG_ROWS = 30;\n+\n+  // Preserves the order of iteration, we try the longer pattern before the shorter one\n+  private static final Map<String, Integer> FORMAT_TO_LEN = new LinkedHashMap<String, Integer>(){", "originalCommit": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMyODY0NA==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461328644", "bodyText": "We need the length because the DateTimeFormatter CANNOT parse anything other than the datetime. For example a DateTimeFormatter of format \"yyyy-mm-dd\" cannot parse \"2020-07-15 INFO i did something\".  I have to cut the target string before parsing.\nOne example of existing wheels is org.apache.commons.lang.time.DateUtils.parse(String s). It builds its own state machine but still cannot avoid the need to index and cut the string s.\nAll in all, for each format I try, i need a DateTimeFormatter and a length of how much string I need. I've moved these two into one LinkedHashMap now, instead of using two separated maps.", "author": "jiacheliu3", "createdAt": "2020-07-28T05:33:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI0ODc3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI0OTIzOQ==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461249239", "bodyText": "why can't we just have an ordered list of formatters? Why do we need the string representation?", "author": "gpang", "createdAt": "2020-07-28T00:37:29Z", "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectLogCommand.java", "diffHunk": "@@ -14,21 +14,121 @@\n import alluxio.client.file.FileSystemContext;\n import alluxio.conf.PropertyKey;\n import alluxio.exception.AlluxioException;\n+import alluxio.util.CommonUtils;\n \n+import jline.internal.Nullable;\n import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n import org.apache.commons.io.FileUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.io.File;\n+import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.net.URI;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n /**\n  * Command to collect Alluxio logs.\n  * */\n public class CollectLogCommand  extends AbstractCollectInfoCommand {\n   public static final String COMMAND_NAME = \"collectLog\";\n   private static final Logger LOG = LoggerFactory.getLogger(CollectLogCommand.class);\n+  public static final Set<String> FILE_NAMES = Stream.of(\n+      \"master.log\",\n+      \"master.out\",\n+      \"job_master.log\",\n+      \"job_master.out\",\n+      \"master_audit.log\",\n+      \"worker.log\",\n+      \"worker.out\",\n+      \"job_worker.log\",\n+      \"job_worker.out\",\n+      \"proxy.log\",\n+      \"proxy.out\",\n+      \"task.log\",\n+      \"task.out\",\n+      \"user\"\n+  ).collect(Collectors.toSet());\n+  // We tolerate the beginning of a log file to contain some rows that are not timestamped.\n+  // 30 is chosen because a YARN application log can have >20 rows in the beginning for\n+  // general information about a job.\n+  // The timestamped log entries start after this general information block.\n+  private static final int TRY_PARSE_LOG_ROWS = 30;\n+\n+  // Preserves the order of iteration, we try the longer pattern before the shorter one\n+  private static final Map<String, Integer> FORMAT_TO_LEN = new LinkedHashMap<String, Integer>(){\n+    {\n+      put(\"yyyy-MM-dd HH:mm:ss,SSS\", 23);\n+      put(\"yyyy-MM-dd HH:mm:ss\", 19);\n+      put(\"yyyy-MM-dd HH:mm\", 16);\n+      put(\"yy/MM/dd HH:mm:ss\", 17);\n+      put(\"yy/MM/dd HH:mm\", 14);\n+      put(\"yyyy-MM-dd'T'HH:mm:ss.SSSXX\", 28);\n+      put(\"yyyy-MM-dd'T'HH:mm:ss\", 19);\n+      put(\"yyyy-MM-dd'T'HH:mm\", 16);\n+    }\n+  };\n+  private static final Map<String, DateTimeFormatter> STRING_TO_FORMATTER = initFormatters();", "originalCommit": "98934aea14aef7e3a0257ec9c29f0e4c5b479b03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMzMTU5OA==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461331598", "bodyText": "Yes the string representation is not necessary. It's removed and I only keep one map now instead of two.", "author": "jiacheliu3", "createdAt": "2020-07-28T05:43:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI0OTIzOQ=="}], "type": "inlineReview"}, {"oid": "85dd3eade62b25445f98d681325d9e337c3ce7cd", "url": "https://github.com/Alluxio/alluxio/commit/85dd3eade62b25445f98d681325d9e337c3ce7cd", "message": "resolve comments", "committedDate": "2020-07-28T05:42:09Z", "type": "commit"}, {"oid": "c37d51be6f7c645ba97fce63f784b81f1ce1a7bf", "url": "https://github.com/Alluxio/alluxio/commit/c37d51be6f7c645ba97fce63f784b81f1ce1a7bf", "message": "subcommand option messages", "committedDate": "2020-07-28T16:55:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4NDA4NQ==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461884085", "bodyText": "I think Collections.emptyList() will work better with type safety?", "author": "gpang", "createdAt": "2020-07-28T21:15:25Z", "path": "core/common/src/main/java/alluxio/util/CommonUtils.java", "diffHunk": "@@ -828,5 +829,28 @@ public static boolean isAddressReachable(String hostname, int port) {\n     }\n   }\n \n+  /**\n+   * Recursively lists a local dir and all its subdirs and return all the files.\n+   *\n+   * @param dir the directory\n+   * @return a list of all the files\n+   * */\n+  public static List<File> recursiveListLocalDir(File dir) {\n+    File[] files = dir.listFiles();\n+    // File#listFiles can return null when the path is invalid\n+    if (files == null) {\n+      return Collections.EMPTY_LIST;", "originalCommit": "c37d51be6f7c645ba97fce63f784b81f1ce1a7bf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4NTEyOQ==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461885129", "bodyText": "Doesn't this continue just move to the next entry in EXCLUDED_FILE_PREFIXES? Don't we want to go to the next entry in allFiles instead?", "author": "gpang", "createdAt": "2020-07-28T21:17:36Z", "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectConfigCommand.java", "diffHunk": "@@ -52,10 +60,22 @@ public boolean hasSubCommand() {\n   @Override\n   public int run(CommandLine cl) throws AlluxioException, IOException {\n     mWorkingDirPath = getWorkingDirectory(cl);\n-    String confDir = mFsContext.getClusterConf().get(PropertyKey.CONF_DIR);\n+    String confDirPath = mFsContext.getClusterConf().get(PropertyKey.CONF_DIR);\n \n-    // TODO(jiacheng): phase 2 copy intelligently, check security risks\n-    FileUtils.copyDirectory(new File(confDir), new File(mWorkingDirPath), true);\n+    File confDir = new File(confDirPath);\n+    List<File> allFiles = CommonUtils.recursiveListLocalDir(confDir);\n+    for (File f : allFiles) {\n+      String filename = f.getName();\n+      String relativePath = confDir.toURI().relativize(f.toURI()).getPath();\n+      // Ignore file prefixes to exclude\n+      for (String prefix : EXCLUDED_FILE_PREFIXES) {\n+        if (filename.startsWith(prefix)) {\n+          continue;", "originalCommit": "c37d51be6f7c645ba97fce63f784b81f1ce1a7bf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4NTY4OQ==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461885689", "bodyText": "I think this block needs to be outside the iteration over all EXCLUDED_FILE_PREFIXES.", "author": "gpang", "createdAt": "2020-07-28T21:18:45Z", "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectConfigCommand.java", "diffHunk": "@@ -52,10 +60,22 @@ public boolean hasSubCommand() {\n   @Override\n   public int run(CommandLine cl) throws AlluxioException, IOException {\n     mWorkingDirPath = getWorkingDirectory(cl);\n-    String confDir = mFsContext.getClusterConf().get(PropertyKey.CONF_DIR);\n+    String confDirPath = mFsContext.getClusterConf().get(PropertyKey.CONF_DIR);\n \n-    // TODO(jiacheng): phase 2 copy intelligently, check security risks\n-    FileUtils.copyDirectory(new File(confDir), new File(mWorkingDirPath), true);\n+    File confDir = new File(confDirPath);\n+    List<File> allFiles = CommonUtils.recursiveListLocalDir(confDir);\n+    for (File f : allFiles) {\n+      String filename = f.getName();\n+      String relativePath = confDir.toURI().relativize(f.toURI()).getPath();\n+      // Ignore file prefixes to exclude\n+      for (String prefix : EXCLUDED_FILE_PREFIXES) {\n+        if (filename.startsWith(prefix)) {\n+          continue;\n+        }\n+        File targetFile = new File(mWorkingDirPath, relativePath);", "originalCommit": "c37d51be6f7c645ba97fce63f784b81f1ce1a7bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMwNDY4NA==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r462304684", "bodyText": "Yea I messed up with two nested loops. I've changed this to use stream and only one loop. PTAL.", "author": "jiacheliu3", "createdAt": "2020-07-29T13:38:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4NTY4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4NjU2NQ==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461886565", "bodyText": "These are prefixes, in order to handle master.log.1, right? Should we include \"prefix\" in the name of the variable?", "author": "gpang", "createdAt": "2020-07-28T21:20:29Z", "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectLogCommand.java", "diffHunk": "@@ -14,21 +14,122 @@\n import alluxio.client.file.FileSystemContext;\n import alluxio.conf.PropertyKey;\n import alluxio.exception.AlluxioException;\n+import alluxio.util.CommonUtils;\n \n+import jline.internal.Nullable;\n import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n import org.apache.commons.io.FileUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.io.File;\n+import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.net.URI;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n /**\n  * Command to collect Alluxio logs.\n  * */\n public class CollectLogCommand  extends AbstractCollectInfoCommand {\n   public static final String COMMAND_NAME = \"collectLog\";\n   private static final Logger LOG = LoggerFactory.getLogger(CollectLogCommand.class);\n+  public static final Set<String> FILE_NAMES = Stream.of(", "originalCommit": "c37d51be6f7c645ba97fce63f784b81f1ce1a7bf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4Njk0Nw==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461886947", "bodyText": "I wonder if we need to make this larger, in order to ignore any long stack trace at the beginning of the file or something?", "author": "gpang", "createdAt": "2020-07-28T21:21:16Z", "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectLogCommand.java", "diffHunk": "@@ -14,21 +14,122 @@\n import alluxio.client.file.FileSystemContext;\n import alluxio.conf.PropertyKey;\n import alluxio.exception.AlluxioException;\n+import alluxio.util.CommonUtils;\n \n+import jline.internal.Nullable;\n import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n import org.apache.commons.io.FileUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.io.File;\n+import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.net.URI;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n /**\n  * Command to collect Alluxio logs.\n  * */\n public class CollectLogCommand  extends AbstractCollectInfoCommand {\n   public static final String COMMAND_NAME = \"collectLog\";\n   private static final Logger LOG = LoggerFactory.getLogger(CollectLogCommand.class);\n+  public static final Set<String> FILE_NAMES = Stream.of(\n+      \"master.log\",\n+      \"master.out\",\n+      \"job_master.log\",\n+      \"job_master.out\",\n+      \"master_audit.log\",\n+      \"worker.log\",\n+      \"worker.out\",\n+      \"job_worker.log\",\n+      \"job_worker.out\",\n+      \"proxy.log\",\n+      \"proxy.out\",\n+      \"task.log\",\n+      \"task.out\",\n+      \"user\"\n+  ).collect(Collectors.toSet());\n+  // We tolerate the beginning of a log file to contain some rows that are not timestamped.\n+  // 30 is chosen because a YARN application log can have >20 rows in the beginning for\n+  // general information about a job.\n+  // The timestamped log entries start after this general information block.\n+  private static final int TRY_PARSE_LOG_ROWS = 30;", "originalCommit": "c37d51be6f7c645ba97fce63f784b81f1ce1a7bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjMyMTA1OQ==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r462321059", "bodyText": "That's a good question. In fact, I believe log files all start with a complete log entry (meaning the line starts with a datetime if log4j configures normally). I've never seen a log file that starts with half of the log traces.\nBesides, if the long broken stack traces are possible, they can have nested exceptions (A ... caused by B... caused by C...) can be like 100 lines. I can probably change it to 100 lines. But there can be 100 log files rotating for each log group (master.log.1 ~ 99, worker.log.1 ~ 99 etc), I think it might get up to non-trivial much file parsing.", "author": "jiacheliu3", "createdAt": "2020-07-29T14:00:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4Njk0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE0NDQwOQ==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r463144409", "bodyText": "O ok. If the start of the log always starts with a complete log entry, then why do we need this parsing limit?", "author": "gpang", "createdAt": "2020-07-30T17:06:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4Njk0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4NzU2Nw==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461887567", "bodyText": "comment on what the second field is (what that length represents)", "author": "gpang", "createdAt": "2020-07-28T21:22:32Z", "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectLogCommand.java", "diffHunk": "@@ -14,21 +14,122 @@\n import alluxio.client.file.FileSystemContext;\n import alluxio.conf.PropertyKey;\n import alluxio.exception.AlluxioException;\n+import alluxio.util.CommonUtils;\n \n+import jline.internal.Nullable;\n import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n import org.apache.commons.io.FileUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.io.File;\n+import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.net.URI;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n /**\n  * Command to collect Alluxio logs.\n  * */\n public class CollectLogCommand  extends AbstractCollectInfoCommand {\n   public static final String COMMAND_NAME = \"collectLog\";\n   private static final Logger LOG = LoggerFactory.getLogger(CollectLogCommand.class);\n+  public static final Set<String> FILE_NAMES = Stream.of(\n+      \"master.log\",\n+      \"master.out\",\n+      \"job_master.log\",\n+      \"job_master.out\",\n+      \"master_audit.log\",\n+      \"worker.log\",\n+      \"worker.out\",\n+      \"job_worker.log\",\n+      \"job_worker.out\",\n+      \"proxy.log\",\n+      \"proxy.out\",\n+      \"task.log\",\n+      \"task.out\",\n+      \"user\"\n+  ).collect(Collectors.toSet());\n+  // We tolerate the beginning of a log file to contain some rows that are not timestamped.\n+  // 30 is chosen because a YARN application log can have >20 rows in the beginning for\n+  // general information about a job.\n+  // The timestamped log entries start after this general information block.\n+  private static final int TRY_PARSE_LOG_ROWS = 30;\n+\n+  // Preserves the order of iteration, we try the longer pattern before the shorter one", "originalCommit": "c37d51be6f7c645ba97fce63f784b81f1ce1a7bf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4OTg5Nw==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461889897", "bodyText": "what is the order of operation between include and exclude? For example, if master.log is in both include and exclude, what happens?", "author": "gpang", "createdAt": "2020-07-28T21:27:16Z", "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectLogCommand.java", "diffHunk": "@@ -14,21 +14,122 @@\n import alluxio.client.file.FileSystemContext;\n import alluxio.conf.PropertyKey;\n import alluxio.exception.AlluxioException;\n+import alluxio.util.CommonUtils;\n \n+import jline.internal.Nullable;\n import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n import org.apache.commons.io.FileUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.io.File;\n+import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.net.URI;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n /**\n  * Command to collect Alluxio logs.\n  * */\n public class CollectLogCommand  extends AbstractCollectInfoCommand {\n   public static final String COMMAND_NAME = \"collectLog\";\n   private static final Logger LOG = LoggerFactory.getLogger(CollectLogCommand.class);\n+  public static final Set<String> FILE_NAMES = Stream.of(\n+      \"master.log\",\n+      \"master.out\",\n+      \"job_master.log\",\n+      \"job_master.out\",\n+      \"master_audit.log\",\n+      \"worker.log\",\n+      \"worker.out\",\n+      \"job_worker.log\",\n+      \"job_worker.out\",\n+      \"proxy.log\",\n+      \"proxy.out\",\n+      \"task.log\",\n+      \"task.out\",\n+      \"user\"\n+  ).collect(Collectors.toSet());\n+  // We tolerate the beginning of a log file to contain some rows that are not timestamped.\n+  // 30 is chosen because a YARN application log can have >20 rows in the beginning for\n+  // general information about a job.\n+  // The timestamped log entries start after this general information block.\n+  private static final int TRY_PARSE_LOG_ROWS = 30;\n+\n+  // Preserves the order of iteration, we try the longer pattern before the shorter one\n+  private static final Map<DateTimeFormatter, Integer> FORMATTERS =\n+          new LinkedHashMap<DateTimeFormatter, Integer>(){\n+    {\n+      // \"2020-01-03 12:10:11,874\"\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss,SSS\"), 23);\n+      // \"2020-01-03 12:10:11\"\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\"), 19);\n+      // \"2020-01-03 12:10\"\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\"), 16);\n+      // \"20/01/03 12:10:11\"\n+      put(DateTimeFormatter.ofPattern(\"yy/MM/dd HH:mm:ss\"), 17);\n+      // \"20/01/03 12:10\"\n+      put(DateTimeFormatter.ofPattern(\"yy/MM/dd HH:mm\"), 14);\n+      // 2020-01-03T12:10:11.874+0800\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSSXX\"), 28);\n+      // 2020-01-03T12:10:11\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss\"), 19);\n+      // 2020-01-03T12:10\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm\"), 16);\n+    }\n+  };\n+\n+  private String mLogDirPath;\n+  private File mLogDir;\n+  private URI mLogDirUri;\n+  private Set<String> mIncludedPrefix;\n+  private Set<String> mExcludedPrefix;\n+  private LocalDateTime mStartTime;\n+  private LocalDateTime mEndTime;\n+\n+  public static final String INCLUDE_OPTION_NAME = \"include-logs\";\n+  private static final Option INCLUDE_OPTION =\n+          Option.builder().required(false).argName(\"filename-prefixes\")\n+                  .longOpt(INCLUDE_OPTION_NAME).hasArg(true)\n+                  .desc(\"extra log file name prefixes to include in ${ALLUXIO_HOME}/logs. \"", "originalCommit": "c37d51be6f7c645ba97fce63f784b81f1ce1a7bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcyODk3OA==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r462728978", "bodyText": "The definition of this --include-logs option was not very clear. Now it's changed to the below 3 options:\n--include-logs: replace the filename prefixes with what is defined here. Does not work tgt with the other two options (err out if given together).\n--exclude-logs: minus from the default filenames. This is checked before --additional-logs. If \"master.log\" is in both exclude and additional, it will be excluded. This caveat is now in the option description.\n--additional-logs: add to the default filenames. Checked after the exclusion.", "author": "jiacheliu3", "createdAt": "2020-07-30T04:34:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4OTg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MDE3OA==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461890178", "bodyText": "Does start time require end time?", "author": "gpang", "createdAt": "2020-07-28T21:27:53Z", "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectLogCommand.java", "diffHunk": "@@ -14,21 +14,122 @@\n import alluxio.client.file.FileSystemContext;\n import alluxio.conf.PropertyKey;\n import alluxio.exception.AlluxioException;\n+import alluxio.util.CommonUtils;\n \n+import jline.internal.Nullable;\n import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n import org.apache.commons.io.FileUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.io.File;\n+import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.net.URI;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n /**\n  * Command to collect Alluxio logs.\n  * */\n public class CollectLogCommand  extends AbstractCollectInfoCommand {\n   public static final String COMMAND_NAME = \"collectLog\";\n   private static final Logger LOG = LoggerFactory.getLogger(CollectLogCommand.class);\n+  public static final Set<String> FILE_NAMES = Stream.of(\n+      \"master.log\",\n+      \"master.out\",\n+      \"job_master.log\",\n+      \"job_master.out\",\n+      \"master_audit.log\",\n+      \"worker.log\",\n+      \"worker.out\",\n+      \"job_worker.log\",\n+      \"job_worker.out\",\n+      \"proxy.log\",\n+      \"proxy.out\",\n+      \"task.log\",\n+      \"task.out\",\n+      \"user\"\n+  ).collect(Collectors.toSet());\n+  // We tolerate the beginning of a log file to contain some rows that are not timestamped.\n+  // 30 is chosen because a YARN application log can have >20 rows in the beginning for\n+  // general information about a job.\n+  // The timestamped log entries start after this general information block.\n+  private static final int TRY_PARSE_LOG_ROWS = 30;\n+\n+  // Preserves the order of iteration, we try the longer pattern before the shorter one\n+  private static final Map<DateTimeFormatter, Integer> FORMATTERS =\n+          new LinkedHashMap<DateTimeFormatter, Integer>(){\n+    {\n+      // \"2020-01-03 12:10:11,874\"\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss,SSS\"), 23);\n+      // \"2020-01-03 12:10:11\"\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\"), 19);\n+      // \"2020-01-03 12:10\"\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\"), 16);\n+      // \"20/01/03 12:10:11\"\n+      put(DateTimeFormatter.ofPattern(\"yy/MM/dd HH:mm:ss\"), 17);\n+      // \"20/01/03 12:10\"\n+      put(DateTimeFormatter.ofPattern(\"yy/MM/dd HH:mm\"), 14);\n+      // 2020-01-03T12:10:11.874+0800\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSSXX\"), 28);\n+      // 2020-01-03T12:10:11\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss\"), 19);\n+      // 2020-01-03T12:10\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm\"), 16);\n+    }\n+  };\n+\n+  private String mLogDirPath;\n+  private File mLogDir;\n+  private URI mLogDirUri;\n+  private Set<String> mIncludedPrefix;\n+  private Set<String> mExcludedPrefix;\n+  private LocalDateTime mStartTime;\n+  private LocalDateTime mEndTime;\n+\n+  public static final String INCLUDE_OPTION_NAME = \"include-logs\";\n+  private static final Option INCLUDE_OPTION =\n+          Option.builder().required(false).argName(\"filename-prefixes\")\n+                  .longOpt(INCLUDE_OPTION_NAME).hasArg(true)\n+                  .desc(\"extra log file name prefixes to include in ${ALLUXIO_HOME}/logs. \"\n+                          + \"The files that start with the prefix will be included.\\n\"\n+                          + \"<filename-prefixes> filename prefixes, separated by comma\").build();\n+  public static final String EXCLUDE_OPTION_NAME = \"exclude-logs\";\n+  private static final Option EXCLUDE_OPTION =\n+          Option.builder().required(false).argName(\"filename-prefixes\")\n+                  .longOpt(EXCLUDE_OPTION_NAME).hasArg(true)\n+                  .desc(\"extra log file name prefixes to exclude in ${ALLUXIO_HOME}/logs. \"\n+                          + \"The files that start with the prefix will be excluded.\\n\"\n+                          + \"<filename-prefixes> filename prefixes, separated by comma\").build();\n+  private static final String START_OPTION_NAME = \"start-time\";\n+  private static final Option START_OPTION =\n+          Option.builder().required(false).argName(\"datetime\")\n+                  .longOpt(START_OPTION_NAME).hasArg(true)\n+                  .desc(\"logs that do not contain entries after this time will be ignored\\n\"", "originalCommit": "c37d51be6f7c645ba97fce63f784b81f1ce1a7bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM0MzA3Mg==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r462343072", "bodyText": "No it doesn't. When not specified, we keep everything that contains or starts after this start time with no end time. Added to the description.", "author": "jiacheliu3", "createdAt": "2020-07-29T14:28:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MDE3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MDI2NA==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461890264", "bodyText": "Does end time require start time?", "author": "gpang", "createdAt": "2020-07-28T21:28:05Z", "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectLogCommand.java", "diffHunk": "@@ -14,21 +14,122 @@\n import alluxio.client.file.FileSystemContext;\n import alluxio.conf.PropertyKey;\n import alluxio.exception.AlluxioException;\n+import alluxio.util.CommonUtils;\n \n+import jline.internal.Nullable;\n import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n import org.apache.commons.io.FileUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.io.File;\n+import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.net.URI;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n /**\n  * Command to collect Alluxio logs.\n  * */\n public class CollectLogCommand  extends AbstractCollectInfoCommand {\n   public static final String COMMAND_NAME = \"collectLog\";\n   private static final Logger LOG = LoggerFactory.getLogger(CollectLogCommand.class);\n+  public static final Set<String> FILE_NAMES = Stream.of(\n+      \"master.log\",\n+      \"master.out\",\n+      \"job_master.log\",\n+      \"job_master.out\",\n+      \"master_audit.log\",\n+      \"worker.log\",\n+      \"worker.out\",\n+      \"job_worker.log\",\n+      \"job_worker.out\",\n+      \"proxy.log\",\n+      \"proxy.out\",\n+      \"task.log\",\n+      \"task.out\",\n+      \"user\"\n+  ).collect(Collectors.toSet());\n+  // We tolerate the beginning of a log file to contain some rows that are not timestamped.\n+  // 30 is chosen because a YARN application log can have >20 rows in the beginning for\n+  // general information about a job.\n+  // The timestamped log entries start after this general information block.\n+  private static final int TRY_PARSE_LOG_ROWS = 30;\n+\n+  // Preserves the order of iteration, we try the longer pattern before the shorter one\n+  private static final Map<DateTimeFormatter, Integer> FORMATTERS =\n+          new LinkedHashMap<DateTimeFormatter, Integer>(){\n+    {\n+      // \"2020-01-03 12:10:11,874\"\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss,SSS\"), 23);\n+      // \"2020-01-03 12:10:11\"\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\"), 19);\n+      // \"2020-01-03 12:10\"\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\"), 16);\n+      // \"20/01/03 12:10:11\"\n+      put(DateTimeFormatter.ofPattern(\"yy/MM/dd HH:mm:ss\"), 17);\n+      // \"20/01/03 12:10\"\n+      put(DateTimeFormatter.ofPattern(\"yy/MM/dd HH:mm\"), 14);\n+      // 2020-01-03T12:10:11.874+0800\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSSXX\"), 28);\n+      // 2020-01-03T12:10:11\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss\"), 19);\n+      // 2020-01-03T12:10\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm\"), 16);\n+    }\n+  };\n+\n+  private String mLogDirPath;\n+  private File mLogDir;\n+  private URI mLogDirUri;\n+  private Set<String> mIncludedPrefix;\n+  private Set<String> mExcludedPrefix;\n+  private LocalDateTime mStartTime;\n+  private LocalDateTime mEndTime;\n+\n+  public static final String INCLUDE_OPTION_NAME = \"include-logs\";\n+  private static final Option INCLUDE_OPTION =\n+          Option.builder().required(false).argName(\"filename-prefixes\")\n+                  .longOpt(INCLUDE_OPTION_NAME).hasArg(true)\n+                  .desc(\"extra log file name prefixes to include in ${ALLUXIO_HOME}/logs. \"\n+                          + \"The files that start with the prefix will be included.\\n\"\n+                          + \"<filename-prefixes> filename prefixes, separated by comma\").build();\n+  public static final String EXCLUDE_OPTION_NAME = \"exclude-logs\";\n+  private static final Option EXCLUDE_OPTION =\n+          Option.builder().required(false).argName(\"filename-prefixes\")\n+                  .longOpt(EXCLUDE_OPTION_NAME).hasArg(true)\n+                  .desc(\"extra log file name prefixes to exclude in ${ALLUXIO_HOME}/logs. \"\n+                          + \"The files that start with the prefix will be excluded.\\n\"\n+                          + \"<filename-prefixes> filename prefixes, separated by comma\").build();\n+  private static final String START_OPTION_NAME = \"start-time\";\n+  private static final Option START_OPTION =\n+          Option.builder().required(false).argName(\"datetime\")\n+                  .longOpt(START_OPTION_NAME).hasArg(true)\n+                  .desc(\"logs that do not contain entries after this time will be ignored\\n\"\n+                          + \"<datetime> a datetime string like 2020-06-27T11:58:53\").build();\n+  private static final String END_OPTION_NAME = \"end-time\";\n+  private static final Option END_OPTION =\n+          Option.builder().required(false).argName(\"datetime\")\n+                  .longOpt(END_OPTION_NAME).hasArg(true)\n+                  .desc(\"logs that do not contain entries before this time will be ignored\\n\"", "originalCommit": "c37d51be6f7c645ba97fce63f784b81f1ce1a7bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM0MzQxNg==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r462343416", "bodyText": "Vice versa to the start time.", "author": "jiacheliu3", "createdAt": "2020-07-29T14:29:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MDI2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MTMyMA==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461891320", "bodyText": "mIncludedPrefix starts off with the entire list. Does that mean it can never be reduced? For example, if I use the option --include master.log this will still retrieve all logs because mIncludedPrefix = new HashSet<>(FILE_NAMES)?", "author": "gpang", "createdAt": "2020-07-28T21:30:10Z", "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectLogCommand.java", "diffHunk": "@@ -53,15 +157,144 @@ public boolean hasSubCommand() {\n   public int run(CommandLine cl) throws AlluxioException, IOException {\n     // Determine the working dir path\n     mWorkingDirPath = getWorkingDirectory(cl);\n-    String logDir = mFsContext.getClusterConf().get(PropertyKey.LOGS_DIR);\n \n     // TODO(jiacheng): phase 2 Copy intelligently find security risks\n-    // TODO(jiacheng): phase 2 components option\n-    FileUtils.copyDirectory(new File(logDir), new File(mWorkingDirPath), true);\n+    mIncludedPrefix = new HashSet<>(FILE_NAMES);\n+    // Define include list and exclude list\n+    if (cl.hasOption(INCLUDE_OPTION_NAME)) {\n+      Set<String> toInclude = parseFileNames(cl.getOptionValue(INCLUDE_OPTION_NAME));\n+      System.out.format(\"Include the following filename prefixes: %s%n\", toInclude);\n+      mIncludedPrefix.addAll(toInclude);", "originalCommit": "c37d51be6f7c645ba97fce63f784b81f1ce1a7bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM2NTYxMg==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r462365612", "bodyText": "Great question. This --include-logs was designed for extra logs that we don't know, like \"alluxio_gc.log\" which some people use for gc logs. These logs should be collected additional to all the rest of logs.\nThe use case you are thinking is also valid, where people just want a subset, like \"master.log\" and \"master.out\". This was not in the scope.\nI think I will change the current design to:\n--include-logs <file-names> to replace the included list. Eg. --include-logs \"master.log, master.out\" copies only master logs and master outs.\n--additional-logs <file-names> adds sth extra to the include list. Eg. --additional-logs \"alluxio_gc.log\" takes the specified gc logs tgt with all the rest of logs.\n--exclude-logs is kept the same.", "author": "jiacheliu3", "createdAt": "2020-07-29T14:57:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MTMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcyODE0Mw==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r462728143", "bodyText": "This is added.", "author": "jiacheliu3", "createdAt": "2020-07-30T04:31:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MTMyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MzI1Ng==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461893256", "bodyText": "We should guard this with if (mEndTime != null) and in the block, return false if it fails.", "author": "gpang", "createdAt": "2020-07-28T21:34:23Z", "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectLogCommand.java", "diffHunk": "@@ -53,15 +157,144 @@ public boolean hasSubCommand() {\n   public int run(CommandLine cl) throws AlluxioException, IOException {\n     // Determine the working dir path\n     mWorkingDirPath = getWorkingDirectory(cl);\n-    String logDir = mFsContext.getClusterConf().get(PropertyKey.LOGS_DIR);\n \n     // TODO(jiacheng): phase 2 Copy intelligently find security risks\n-    // TODO(jiacheng): phase 2 components option\n-    FileUtils.copyDirectory(new File(logDir), new File(mWorkingDirPath), true);\n+    mIncludedPrefix = new HashSet<>(FILE_NAMES);\n+    // Define include list and exclude list\n+    if (cl.hasOption(INCLUDE_OPTION_NAME)) {\n+      Set<String> toInclude = parseFileNames(cl.getOptionValue(INCLUDE_OPTION_NAME));\n+      System.out.format(\"Include the following filename prefixes: %s%n\", toInclude);\n+      mIncludedPrefix.addAll(toInclude);\n+    }\n+    if (cl.hasOption(EXCLUDE_OPTION_NAME)) {\n+      mExcludedPrefix = parseFileNames(cl.getOptionValue(EXCLUDE_OPTION_NAME));\n+      System.out.format(\"Exclude the following filename prefixes: %s%n\", mExcludedPrefix);\n+    }\n+\n+    // Check file timestamps\n+    boolean checkTimeStamp = false;\n+    if (cl.hasOption(START_OPTION_NAME)) {\n+      String startTimeStr = cl.getOptionValue(START_OPTION_NAME);\n+      mStartTime = parseDateTime(startTimeStr);\n+      System.out.format(\"Time window start: %s%n\", mStartTime);\n+      checkTimeStamp = true;\n+    }\n+    if (cl.hasOption(END_OPTION_NAME)) {\n+      String endTimeStr = cl.getOptionValue(END_OPTION_NAME);\n+      mEndTime = parseDateTime(endTimeStr);\n+      System.out.format(\"Time window end: %s%n\", mEndTime);\n+      checkTimeStamp = true;\n+    }\n+    if (mStartTime != null && mEndTime != null && mStartTime.isAfter(mEndTime)) {\n+      System.err.format(\"ERROR: Start time %s is later than end time %s!%n\",\n+              mStartTime, mEndTime);\n+    }\n+\n+    if (!mLogDir.exists()) {\n+      System.err.format(\"ERROR: Alluxio log directory %s does not exist!%n\", mLogDirPath);\n+      return -1;\n+    }\n+\n+    List<File> allFiles = CommonUtils.recursiveListLocalDir(mLogDir);\n+    for (File f : allFiles) {\n+      String relativePath = getRelativePathToLogDir(f);\n+      try {\n+        if (!shouldCopy(f, relativePath, checkTimeStamp)) {\n+          continue;\n+        }\n+        File targetFile = new File(mWorkingDirPath, relativePath);\n+        FileUtils.copyFile(f, targetFile, true);\n+      } catch (IOException e) {\n+        System.err.format(\"ERROR: file %s not found %s%n\", f.getCanonicalPath(), e.getMessage());\n+      }\n+    }\n \n     return 0;\n   }\n \n+  private String getRelativePathToLogDir(File f) {\n+    return mLogDirUri.relativize(f.toURI()).getPath();\n+  }\n+\n+  private boolean shouldCopy(File f, String relativePath, boolean checkTimeStamp)\n+          throws IOException {\n+    if (!fileNameIsWanted(relativePath)) {\n+      return false;\n+    }\n+    if (checkTimeStamp) {\n+      if (!fileTimeStampIsWanted(f)) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private boolean fileNameIsWanted(String fileName) {\n+    if (mExcludedPrefix != null) {\n+      for (String x : mExcludedPrefix) {\n+        if (fileName.startsWith(x)) {\n+          return false;\n+        }\n+      }\n+    }\n+    for (String s : mIncludedPrefix) {\n+      if (fileName.startsWith(s)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean fileTimeStampIsWanted(File f) throws IOException {\n+    long timestamp = f.lastModified();", "originalCommit": "c37d51be6f7c645ba97fce63f784b81f1ce1a7bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM0ODYzNA==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r462348634", "bodyText": "I think since we don't require start time to have end time, we want it to default to true unless the file is filtered out with the specified time interval.\nNote that the special case is we are not able to infer the start time of the file, we lean towards keeping it.\nUpdated the method description, hoping it makes the logic clearer.", "author": "jiacheliu3", "createdAt": "2020-07-29T14:35:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MzI1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE2ODg0Mw==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r463168843", "bodyText": "I was saying we have to do some \"work\" to determine if the end time is satisfied. However in the current code, I think we do all the \"work\" for determining each files' end and start times, but later, we only use the results of that work if the end and start times are specified (end != null or start != null).\nTherefore, my suggestion was to only do the \"work\" if the end or start times are specified (!= null). If both are null, then we would not check file end time, or file start time at all, and just return true.\nWhat do you think?", "author": "gpang", "createdAt": "2020-07-30T17:50:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MzI1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM5MDAxOQ==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r463390019", "bodyText": "Ah gotcha. That makes sense to me. Updated", "author": "jiacheliu3", "createdAt": "2020-07-31T03:45:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MzI1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MzMzNg==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461893336", "bodyText": "We should guard this with if (mStartTime != null) and in the block, return false if it fails.", "author": "gpang", "createdAt": "2020-07-28T21:34:34Z", "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectLogCommand.java", "diffHunk": "@@ -53,15 +157,144 @@ public boolean hasSubCommand() {\n   public int run(CommandLine cl) throws AlluxioException, IOException {\n     // Determine the working dir path\n     mWorkingDirPath = getWorkingDirectory(cl);\n-    String logDir = mFsContext.getClusterConf().get(PropertyKey.LOGS_DIR);\n \n     // TODO(jiacheng): phase 2 Copy intelligently find security risks\n-    // TODO(jiacheng): phase 2 components option\n-    FileUtils.copyDirectory(new File(logDir), new File(mWorkingDirPath), true);\n+    mIncludedPrefix = new HashSet<>(FILE_NAMES);\n+    // Define include list and exclude list\n+    if (cl.hasOption(INCLUDE_OPTION_NAME)) {\n+      Set<String> toInclude = parseFileNames(cl.getOptionValue(INCLUDE_OPTION_NAME));\n+      System.out.format(\"Include the following filename prefixes: %s%n\", toInclude);\n+      mIncludedPrefix.addAll(toInclude);\n+    }\n+    if (cl.hasOption(EXCLUDE_OPTION_NAME)) {\n+      mExcludedPrefix = parseFileNames(cl.getOptionValue(EXCLUDE_OPTION_NAME));\n+      System.out.format(\"Exclude the following filename prefixes: %s%n\", mExcludedPrefix);\n+    }\n+\n+    // Check file timestamps\n+    boolean checkTimeStamp = false;\n+    if (cl.hasOption(START_OPTION_NAME)) {\n+      String startTimeStr = cl.getOptionValue(START_OPTION_NAME);\n+      mStartTime = parseDateTime(startTimeStr);\n+      System.out.format(\"Time window start: %s%n\", mStartTime);\n+      checkTimeStamp = true;\n+    }\n+    if (cl.hasOption(END_OPTION_NAME)) {\n+      String endTimeStr = cl.getOptionValue(END_OPTION_NAME);\n+      mEndTime = parseDateTime(endTimeStr);\n+      System.out.format(\"Time window end: %s%n\", mEndTime);\n+      checkTimeStamp = true;\n+    }\n+    if (mStartTime != null && mEndTime != null && mStartTime.isAfter(mEndTime)) {\n+      System.err.format(\"ERROR: Start time %s is later than end time %s!%n\",\n+              mStartTime, mEndTime);\n+    }\n+\n+    if (!mLogDir.exists()) {\n+      System.err.format(\"ERROR: Alluxio log directory %s does not exist!%n\", mLogDirPath);\n+      return -1;\n+    }\n+\n+    List<File> allFiles = CommonUtils.recursiveListLocalDir(mLogDir);\n+    for (File f : allFiles) {\n+      String relativePath = getRelativePathToLogDir(f);\n+      try {\n+        if (!shouldCopy(f, relativePath, checkTimeStamp)) {\n+          continue;\n+        }\n+        File targetFile = new File(mWorkingDirPath, relativePath);\n+        FileUtils.copyFile(f, targetFile, true);\n+      } catch (IOException e) {\n+        System.err.format(\"ERROR: file %s not found %s%n\", f.getCanonicalPath(), e.getMessage());\n+      }\n+    }\n \n     return 0;\n   }\n \n+  private String getRelativePathToLogDir(File f) {\n+    return mLogDirUri.relativize(f.toURI()).getPath();\n+  }\n+\n+  private boolean shouldCopy(File f, String relativePath, boolean checkTimeStamp)\n+          throws IOException {\n+    if (!fileNameIsWanted(relativePath)) {\n+      return false;\n+    }\n+    if (checkTimeStamp) {\n+      if (!fileTimeStampIsWanted(f)) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private boolean fileNameIsWanted(String fileName) {\n+    if (mExcludedPrefix != null) {\n+      for (String x : mExcludedPrefix) {\n+        if (fileName.startsWith(x)) {\n+          return false;\n+        }\n+      }\n+    }\n+    for (String s : mIncludedPrefix) {\n+      if (fileName.startsWith(s)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean fileTimeStampIsWanted(File f) throws IOException {\n+    long timestamp = f.lastModified();\n+    LocalDateTime fileEndTime =\n+            LocalDateTime.ofInstant(Instant.ofEpochMilli(timestamp), ZoneId.systemDefault());\n+\n+    // Infer file start time by parsing the first bunch of rows", "originalCommit": "c37d51be6f7c645ba97fce63f784b81f1ce1a7bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM0ODg1Ng==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r462348856", "bodyText": "same", "author": "jiacheliu3", "createdAt": "2020-07-29T14:35:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MzMzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MzYzNQ==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r461893635", "bodyText": "will this skip empty strings?", "author": "gpang", "createdAt": "2020-07-28T21:35:08Z", "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectLogCommand.java", "diffHunk": "@@ -53,15 +157,144 @@ public boolean hasSubCommand() {\n   public int run(CommandLine cl) throws AlluxioException, IOException {\n     // Determine the working dir path\n     mWorkingDirPath = getWorkingDirectory(cl);\n-    String logDir = mFsContext.getClusterConf().get(PropertyKey.LOGS_DIR);\n \n     // TODO(jiacheng): phase 2 Copy intelligently find security risks\n-    // TODO(jiacheng): phase 2 components option\n-    FileUtils.copyDirectory(new File(logDir), new File(mWorkingDirPath), true);\n+    mIncludedPrefix = new HashSet<>(FILE_NAMES);\n+    // Define include list and exclude list\n+    if (cl.hasOption(INCLUDE_OPTION_NAME)) {\n+      Set<String> toInclude = parseFileNames(cl.getOptionValue(INCLUDE_OPTION_NAME));\n+      System.out.format(\"Include the following filename prefixes: %s%n\", toInclude);\n+      mIncludedPrefix.addAll(toInclude);\n+    }\n+    if (cl.hasOption(EXCLUDE_OPTION_NAME)) {\n+      mExcludedPrefix = parseFileNames(cl.getOptionValue(EXCLUDE_OPTION_NAME));\n+      System.out.format(\"Exclude the following filename prefixes: %s%n\", mExcludedPrefix);\n+    }\n+\n+    // Check file timestamps\n+    boolean checkTimeStamp = false;\n+    if (cl.hasOption(START_OPTION_NAME)) {\n+      String startTimeStr = cl.getOptionValue(START_OPTION_NAME);\n+      mStartTime = parseDateTime(startTimeStr);\n+      System.out.format(\"Time window start: %s%n\", mStartTime);\n+      checkTimeStamp = true;\n+    }\n+    if (cl.hasOption(END_OPTION_NAME)) {\n+      String endTimeStr = cl.getOptionValue(END_OPTION_NAME);\n+      mEndTime = parseDateTime(endTimeStr);\n+      System.out.format(\"Time window end: %s%n\", mEndTime);\n+      checkTimeStamp = true;\n+    }\n+    if (mStartTime != null && mEndTime != null && mStartTime.isAfter(mEndTime)) {\n+      System.err.format(\"ERROR: Start time %s is later than end time %s!%n\",\n+              mStartTime, mEndTime);\n+    }\n+\n+    if (!mLogDir.exists()) {\n+      System.err.format(\"ERROR: Alluxio log directory %s does not exist!%n\", mLogDirPath);\n+      return -1;\n+    }\n+\n+    List<File> allFiles = CommonUtils.recursiveListLocalDir(mLogDir);\n+    for (File f : allFiles) {\n+      String relativePath = getRelativePathToLogDir(f);\n+      try {\n+        if (!shouldCopy(f, relativePath, checkTimeStamp)) {\n+          continue;\n+        }\n+        File targetFile = new File(mWorkingDirPath, relativePath);\n+        FileUtils.copyFile(f, targetFile, true);\n+      } catch (IOException e) {\n+        System.err.format(\"ERROR: file %s not found %s%n\", f.getCanonicalPath(), e.getMessage());\n+      }\n+    }\n \n     return 0;\n   }\n \n+  private String getRelativePathToLogDir(File f) {\n+    return mLogDirUri.relativize(f.toURI()).getPath();\n+  }\n+\n+  private boolean shouldCopy(File f, String relativePath, boolean checkTimeStamp)\n+          throws IOException {\n+    if (!fileNameIsWanted(relativePath)) {\n+      return false;\n+    }\n+    if (checkTimeStamp) {\n+      if (!fileTimeStampIsWanted(f)) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private boolean fileNameIsWanted(String fileName) {\n+    if (mExcludedPrefix != null) {\n+      for (String x : mExcludedPrefix) {\n+        if (fileName.startsWith(x)) {\n+          return false;\n+        }\n+      }\n+    }\n+    for (String s : mIncludedPrefix) {\n+      if (fileName.startsWith(s)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean fileTimeStampIsWanted(File f) throws IOException {\n+    long timestamp = f.lastModified();\n+    LocalDateTime fileEndTime =\n+            LocalDateTime.ofInstant(Instant.ofEpochMilli(timestamp), ZoneId.systemDefault());\n+\n+    // Infer file start time by parsing the first bunch of rows\n+    LocalDateTime fileStartTime = inferFileStartTime(f);\n+    if (fileStartTime == null) {\n+      fileStartTime = LocalDateTime.MIN;\n+    }\n+\n+    // The file is earlier than the desired interval\n+    if (mStartTime != null && mStartTime.isAfter(fileEndTime)) {\n+      return false;\n+    }\n+    // The file is later than the desired interval\n+    if (mEndTime != null && mEndTime.isBefore(fileStartTime)) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Infer the starting time of a log file by parsing the log entries from the beginning.\n+   * It will try the first certain lines with various known datetime patterns.\n+   *\n+   * @param f log file\n+   * @return the parsed datetime\n+   * */\n+  public static LocalDateTime inferFileStartTime(File f) throws FileNotFoundException {\n+    int r = 0;\n+    try (Scanner scanner = new Scanner(f)) {\n+      while (scanner.hasNextLine() && r < TRY_PARSE_LOG_ROWS) {\n+        String line = scanner.nextLine();\n+        LocalDateTime datetime = parseDateTime(line);\n+        if (datetime != null) {\n+          return datetime;\n+        }\n+        r++;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  private Set<String> parseFileNames(String input) {\n+    Set<String> names = new HashSet<>();\n+    names.addAll(Stream.of(input.split(\",\")).map(String::trim).collect(Collectors.toList()));", "originalCommit": "c37d51be6f7c645ba97fce63f784b81f1ce1a7bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjM1MTY2OQ==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r462351669", "bodyText": "Yes", "author": "jiacheliu3", "createdAt": "2020-07-29T14:39:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MzYzNQ=="}], "type": "inlineReview"}, {"oid": "9188422dc22fe4826f4745568ecf3783b68776cd", "url": "https://github.com/Alluxio/alluxio/commit/9188422dc22fe4826f4745568ecf3783b68776cd", "message": "resolved part of comments", "committedDate": "2020-07-29T14:58:45Z", "type": "commit"}, {"oid": "67620a2fd8138edecd6cc7c10975770baf406041", "url": "https://github.com/Alluxio/alluxio/commit/67620a2fd8138edecd6cc7c10975770baf406041", "message": "add --additional-logs option", "committedDate": "2020-07-30T04:30:47Z", "type": "commit"}, {"oid": "de03e19048bdcd5a822c82145b6835bcaadeadb4", "url": "https://github.com/Alluxio/alluxio/commit/de03e19048bdcd5a822c82145b6835bcaadeadb4", "message": "Merge remote-tracking branch 'upstream/master' into collectinfo2", "committedDate": "2020-07-30T05:30:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE4MTg0Mw==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r463181843", "bodyText": "I think maybe we can achieve everything with only the --include flag, but that flag simply specifies the files to get. We can set the default for this flag as the list of FILE_NAMES_PREFIXES.\nHowever, if a user wants to exclude or include files, then they would have to add a --include with the full list they want.\nIf that is too unfriendly, then can't we just assume we download everything under logs/, and only have an --exclude flag, so any additional logs will automatically get retrieved, and the exclude is a simple way to not download some.\nI just thought having 3 flags was too much. Ideally we only need one. What do you think?", "author": "gpang", "createdAt": "2020-07-30T18:12:47Z", "path": "shell/src/main/java/alluxio/cli/bundler/command/CollectLogCommand.java", "diffHunk": "@@ -14,21 +14,148 @@\n import alluxio.client.file.FileSystemContext;\n import alluxio.conf.PropertyKey;\n import alluxio.exception.AlluxioException;\n+import alluxio.util.CommonUtils;\n \n+import jline.internal.Nullable;\n import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n import org.apache.commons.io.FileUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.io.File;\n+import java.io.FileNotFoundException;\n import java.io.IOException;\n+import java.net.URI;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n /**\n  * Command to collect Alluxio logs.\n  * */\n public class CollectLogCommand  extends AbstractCollectInfoCommand {\n   public static final String COMMAND_NAME = \"collectLog\";\n   private static final Logger LOG = LoggerFactory.getLogger(CollectLogCommand.class);\n+  public static final Set<String> FILE_NAMES_PREFIXES = Stream.of(\n+      \"master.log\",\n+      \"master.out\",\n+      \"job_master.log\",\n+      \"job_master.out\",\n+      \"master_audit.log\",\n+      \"worker.log\",\n+      \"worker.out\",\n+      \"job_worker.log\",\n+      \"job_worker.out\",\n+      \"proxy.log\",\n+      \"proxy.out\",\n+      \"task.log\",\n+      \"task.out\",\n+      \"user\"\n+  ).collect(Collectors.toSet());\n+  // We tolerate the beginning of a log file to contain some rows that are not timestamped.\n+  // A YARN application log can have >20 rows in the beginning for\n+  // general information about a job.\n+  // The timestamped log entries start after this general information block.\n+  private static final int TRY_PARSE_LOG_ROWS = 100;\n+\n+  // Preserves the order of iteration, we try the longer pattern before the shorter one.\n+  // The 1st field is the DateTimeFormatter of a specific pattern.\n+  // The 2nd field is the length to take from the beginning of the log entry.\n+  // The length of the format string can be different from the datetime string it parses to.\n+  // For example, \"yyyy-MM-dd'T'HH:mm:ss.SSSXX\" has length of 27 but parses to\n+  // \"2020-10-12T12:11:10.055+0800\".\n+  // Note that the single quotes around 'T' are not in the real string,\n+  // and \"XX\" parses to the timezone, which is \"+0800\".\n+  // The datetime parsing works only when the string matches exactly to the format.\n+  private static final Map<DateTimeFormatter, Integer> FORMATTERS =\n+          new LinkedHashMap<DateTimeFormatter, Integer>(){\n+    {\n+      // \"2020-01-03 12:10:11,874\"\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss,SSS\"), 23);\n+      // \"2020-01-03 12:10:11\"\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\"), 19);\n+      // \"2020-01-03 12:10\"\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm\"), 16);\n+      // \"20/01/03 12:10:11\"\n+      put(DateTimeFormatter.ofPattern(\"yy/MM/dd HH:mm:ss\"), 17);\n+      // \"20/01/03 12:10\"\n+      put(DateTimeFormatter.ofPattern(\"yy/MM/dd HH:mm\"), 14);\n+      // 2020-01-03T12:10:11.874+0800\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSSXX\"), 28);\n+      // 2020-01-03T12:10:11\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss\"), 19);\n+      // 2020-01-03T12:10\n+      put(DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm\"), 16);\n+    }\n+  };\n+\n+  private String mLogDirPath;\n+  private File mLogDir;\n+  private URI mLogDirUri;\n+  private Set<String> mIncludedPrefix;\n+  private Set<String> mExcludedPrefix;\n+  private LocalDateTime mStartTime;\n+  private LocalDateTime mEndTime;\n+\n+  public static final String INCLUDE_OPTION_NAME = \"include-logs\";\n+  public static final String EXCLUDE_OPTION_NAME = \"exclude-logs\";\n+  public static final String ADDITIONAL_OPTION_NAME = \"additional-logs\";\n+  private static final Option INCLUDE_OPTION =\n+          Option.builder().required(false).argName(\"filename-prefixes\")", "originalCommit": "de03e19048bdcd5a822c82145b6835bcaadeadb4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM5MzY4Mw==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r463393683", "bodyText": "I guess keeping only the --include will make it too verbose. For example I want everything plus my gc logs, then I will have to type --include-logs master,worker,job-master,job-worker,user,task,alluxio_gc. For less experienced users we may need to teach them how to make sure all components are included, to avoid another iteration. This makes --additional useful. For similar argument I would suggest keeping --exclude too.\nOn your other option, where we keep everything unless explicitly excluded. I've seen cases where some users put many irrelevant logs under Alluxio log dir and collectInfo is run by a general L1 team that just follow handbooks without looking into the Alluxio log dir. Then hundreds of blue talon and ZK logs are copied (10M * 100 for each node) and the collectInfo tarball size went to the ceiling. I hope to avoid this kind of pitfall.", "author": "jiacheliu3", "createdAt": "2020-07-31T04:02:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE4MTg0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgzODE0Ng==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r463838146", "bodyText": "Ahhh, I see. I didn't realize there would be so many extra logs like zk or others.\nWhy do we need 3 flags? Can't we just have the internal list of what we know, and just 2 flags --exclude and --additional?", "author": "gpang", "createdAt": "2020-07-31T21:01:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE4MTg0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkxOTczMg==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r463919732", "bodyText": "Logically we can remove the --include flag but that will make it a bit harder to just keep logs for one or two components. We have six different groups of log/out files master,worker,job-master,job-worker,user,task and I don't expect users to be very clear about what to exclude.\nIt gets trickier if we want finer granularity, like \"get the audit logs\", which translates to --include-logs master_audit or --exclude master.log, master.out, job-master, worker, job-worker, task, user.", "author": "jiacheliu3", "createdAt": "2020-08-01T04:21:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE4MTg0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDUyMDE4Nw==", "url": "https://github.com/Alluxio/alluxio/pull/11783#discussion_r464520187", "bodyText": "Ok, for now, this should be fine.", "author": "gpang", "createdAt": "2020-08-03T16:22:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE4MTg0Mw=="}], "type": "inlineReview"}, {"oid": "ab3ab9d708e778c43085eab92355de2f17c726d7", "url": "https://github.com/Alluxio/alluxio/commit/ab3ab9d708e778c43085eab92355de2f17c726d7", "message": "update check time", "committedDate": "2020-07-31T03:41:12Z", "type": "commit"}]}