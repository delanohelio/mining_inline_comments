{"pr_number": 1850, "pr_title": "Use RoutingCHGraph adapter for CH query algorithms", "pr_createdAt": "2020-01-10T10:37:40Z", "pr_url": "https://github.com/graphhopper/graphhopper/pull/1850", "timeline": [{"oid": "8c50578ada0eaa83316a7bd77db64ca961acfd81", "url": "https://github.com/graphhopper/graphhopper/commit/8c50578ada0eaa83316a7bd77db64ca961acfd81", "message": "Add CHRoutingGraph to be used for CH query algorithms", "committedDate": "2020-01-08T11:29:57Z", "type": "commit"}, {"oid": "f2dab52ea2546d9b636da12819f697ad8ee500fa", "url": "https://github.com/graphhopper/graphhopper/commit/f2dab52ea2546d9b636da12819f697ad8ee500fa", "message": "Try inlining edgeState()", "committedDate": "2020-01-09T18:09:57Z", "type": "commit"}, {"oid": "26149076d921886d7f09a9e0e174e4e39f9e0f8e", "url": "https://github.com/graphhopper/graphhopper/commit/26149076d921886d7f09a9e0e174e4e39f9e0f8e", "message": "Remove comment", "committedDate": "2020-01-09T18:12:36Z", "type": "commit"}, {"oid": "d00ac4731b175cdb6cdd7e41ae4c9622abd1007a", "url": "https://github.com/graphhopper/graphhopper/commit/d00ac4731b175cdb6cdd7e41ae4c9622abd1007a", "message": "Move comment", "committedDate": "2020-01-10T08:33:14Z", "type": "commit"}, {"oid": "0cef7ad8087f0c871a554627f98c7d2b3095a014", "url": "https://github.com/graphhopper/graphhopper/commit/0cef7ad8087f0c871a554627f98c7d2b3095a014", "message": "Undo inlining of edgeState(), its not faster", "committedDate": "2020-01-10T10:19:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE3OTMwNg==", "url": "https://github.com/graphhopper/graphhopper/pull/1850#discussion_r365179306", "bodyText": "@michaz ? Do we want the BaseGraph, the QueryGraph (of the CHGraph) or the CHGraph ?", "author": "easbar", "createdAt": "2020-01-10T10:55:43Z", "path": "core/src/main/java/com/graphhopper/routing/AlternativeRouteCH.java", "diffHunk": "@@ -76,22 +76,21 @@ public boolean apply(final int v, final SPTEntry fromSPTEntry) {\n                 // s -> v and v -> t need not be shortest paths. In fact, they can sometimes be pretty strange.\n                 // We still use this preliminary path to filter for shared path length with other alternatives,\n                 // so we don't have to work so much.\n-                Path preliminaryRoute = createPathExtractor(graph, weighting).extract(fromSPTEntry, toSPTEntry, fromSPTEntry.getWeightOfVisitedPath() + toSPTEntry.getWeightOfVisitedPath());\n+                Path preliminaryRoute = createPathExtractor(graph).extract(fromSPTEntry, toSPTEntry, fromSPTEntry.getWeightOfVisitedPath() + toSPTEntry.getWeightOfVisitedPath());\n                 double preliminaryShare = calculateShare(preliminaryRoute);\n                 if (preliminaryShare > maxShareFactor) {\n                     return true;\n                 }\n \n                 // Okay, now we want the s -> v -> t shortest via-path, so we route s -> v and v -> t\n                 // and glue them together.\n-                DijkstraBidirectionCHNoSOD svRouter = new DijkstraBidirectionCHNoSOD(graph, weighting);\n-                svRouter.setEdgeFilter(additionalEdgeFilter);\n+                DijkstraBidirectionCHNoSOD svRouter = new DijkstraBidirectionCHNoSOD(graph);\n                 final Path svPath = svRouter.calcPath(s, v);\n                 final IntIndexedContainer svNodes = svPath.calcNodes();\n-                DijkstraBidirectionCHNoSOD vtRouter = new DijkstraBidirectionCHNoSOD(graph, weighting);\n-                vtRouter.setEdgeFilter(additionalEdgeFilter);\n+                DijkstraBidirectionCHNoSOD vtRouter = new DijkstraBidirectionCHNoSOD(graph);\n                 final Path vtPath = vtRouter.calcPath(v, t);\n                 final IntIndexedContainer vtNodes = vtPath.calcNodes();\n+                // todonow: which graph do we want here ?", "originalCommit": "0cef7ad8087f0c871a554627f98c7d2b3095a014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE4MzExMA==", "url": "https://github.com/graphhopper/graphhopper/pull/1850#discussion_r365183110", "bodyText": "Well, the Path will be a path through the .. well, the graph. :-) Doesn't use shortcuts, but does use the query-graph nodes.\nSo technically, the QueryGraph of the BaseGraph. But the QueryGraph of the CHGraph works as well, I think, since it's a superset.", "author": "michaz", "createdAt": "2020-01-10T11:05:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE3OTMwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE4MzUxMA==", "url": "https://github.com/graphhopper/graphhopper/pull/1850#discussion_r365183510", "bodyText": "So you need virtual nodes + edges but you do not want shortcuts ?", "author": "easbar", "createdAt": "2020-01-10T11:06:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE3OTMwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE4NDkyMQ==", "url": "https://github.com/graphhopper/graphhopper/pull/1850#discussion_r365184921", "bodyText": "Correct, but I think I don't mind if there are shortcuts, I just don't use them.\nThe graph at this point is just used because the constructor of Path wants it, and that Path will not have shortcuts. Because I concatenate it from two \"expanded\" Paths from the CH-router.", "author": "michaz", "createdAt": "2020-01-10T11:10:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE3OTMwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE4NjI0Mw==", "url": "https://github.com/graphhopper/graphhopper/pull/1850#discussion_r365186243", "bodyText": "If (as you say) a CHGraph is ultimately something different than a Graph, then this class must conceptually probably get the CHGraph and the Graph, because it calls sub-routers (with the CHGraph), but it also wants to reason about the (pure) Graph.", "author": "michaz", "createdAt": "2020-01-10T11:13:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE3OTMwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE4NzIyNw==", "url": "https://github.com/graphhopper/graphhopper/pull/1850#discussion_r365187227", "bodyText": "It looks like the overriden .extract() method does not use the graph at all ? Do you really have to use the Path this way ? Can we not just get a list of edgeiteratorstates + total distance or something ?", "author": "easbar", "createdAt": "2020-01-10T11:16:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE3OTMwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE4NzYwMA==", "url": "https://github.com/graphhopper/graphhopper/pull/1850#discussion_r365187600", "bodyText": "Ah never mind the path is passed to another method that calls calcEdges (which uses the graph) ...", "author": "easbar", "createdAt": "2020-01-10T11:17:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE3OTMwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE4ODE1MA==", "url": "https://github.com/graphhopper/graphhopper/pull/1850#discussion_r365188150", "bodyText": "Yeah, the overridden extract is just a relic from something that was there before. If I don't need the Graph at all here, throw it out, no problem.\nBut I do want a Path. A Path through a Graph is something we should have as an element, without having to chop it up into bits. And we should be able to write operations like Concat over it.", "author": "michaz", "createdAt": "2020-01-10T11:19:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE3OTMwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE5MzIyOA==", "url": "https://github.com/graphhopper/graphhopper/pull/1850#discussion_r365193228", "bodyText": "Ok I changed to graph.getGraph().getBaseGraph() (sigh). This will be the query graph of the base graph, but we need to get rid of this construct.\n\nA Path through a Graph is something we should have as an element, without having to chop it up into bits\n\n? Can you explain what you mean here ? Where is the path chopped up into bits ?", "author": "easbar", "createdAt": "2020-01-10T11:33:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE3OTMwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE5NDM3NQ==", "url": "https://github.com/graphhopper/graphhopper/pull/1850#discussion_r365194375", "bodyText": "There should also be some tests for alternative route CH, maybe checking that all returned paths start and end in the right places and the weight is less than twice as big as the best one or something like this ?", "author": "easbar", "createdAt": "2020-01-10T11:36:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE3OTMwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE4MDI0OA==", "url": "https://github.com/graphhopper/graphhopper/pull/1850#discussion_r365180248", "bodyText": "I already removed the in/outEdgeExplorer for #1835 here. I left a few todos where we can simply move the access flags into the weighting for #1835.", "author": "easbar", "createdAt": "2020-01-10T10:57:58Z", "path": "core/src/main/java/com/graphhopper/routing/AbstractRoutingAlgorithm.java", "diffHunk": "@@ -56,8 +57,9 @@ public AbstractRoutingAlgorithm(Graph graph, Weighting weighting, TraversalMode\n         this.traversalMode = traversalMode;\n         this.graph = graph;\n         this.nodeAccess = graph.getNodeAccess();\n-        outEdgeExplorer = graph.createEdgeExplorer(DefaultEdgeFilter.outEdges(flagEncoder));\n-        inEdgeExplorer = graph.createEdgeExplorer(DefaultEdgeFilter.inEdges(flagEncoder));\n+        inEdgeFilter = DefaultEdgeFilter.inEdges(flagEncoder.getAccessEnc());\n+        outEdgeFilter = DefaultEdgeFilter.outEdges(flagEncoder.getAccessEnc());\n+        edgeExplorer = graph.createEdgeExplorer();\n     }", "originalCommit": "0cef7ad8087f0c871a554627f98c7d2b3095a014", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE4MDc2Ng==", "url": "https://github.com/graphhopper/graphhopper/pull/1850#discussion_r365180766", "bodyText": "In #1835 we can remove outEdgeFilter here and strictly rely on the returned weight from Weighting", "author": "easbar", "createdAt": "2020-01-10T10:59:01Z", "path": "core/src/main/java/com/graphhopper/routing/Dijkstra.java", "diffHunk": "@@ -68,19 +67,19 @@ public Path calcPath(int from, int to) {\n     }\n \n     protected void runAlgo() {\n-        EdgeExplorer explorer = outEdgeExplorer;\n         while (true) {\n             visitedNodes++;\n             if (isMaxVisitedNodesExceeded() || finished())\n                 break;\n \n             int currNode = currEdge.adjNode;\n-            EdgeIterator iter = explorer.setBaseNode(currNode);\n+            EdgeIterator iter = edgeExplorer.setBaseNode(currNode);\n             while (iter.next()) {\n                 if (!accept(iter, currEdge.edge))\n                     continue;\n \n-                double tmpWeight = weighting.calcWeight(iter, false, currEdge.edge) + currEdge.weight;\n+                // todo: for #1776/#1835 move the access check into weighting\n+                double tmpWeight = !outEdgeFilter.accept(iter) ? Double.POSITIVE_INFINITY : weighting.calcWeight(iter, false, currEdge.edge) + currEdge.weight;", "originalCommit": "0cef7ad8087f0c871a554627f98c7d2b3095a014", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "889dc79f94f079687b8d0592e401c12086f6c87c", "url": "https://github.com/graphhopper/graphhopper/commit/889dc79f94f079687b8d0592e401c12086f6c87c", "message": "Use Graph (including virtual edges+nodes in AlternativeRouteCH).", "committedDate": "2020-01-10T11:28:28Z", "type": "commit"}, {"oid": "a853ee7d16daed971ce31df124b23061e217d4de", "url": "https://github.com/graphhopper/graphhopper/commit/a853ee7d16daed971ce31df124b23061e217d4de", "message": "Add some javadocs", "committedDate": "2020-01-10T11:42:01Z", "type": "commit"}, {"oid": "8bb33af68ff32fc2287de824e1e5b4cae64f0749", "url": "https://github.com/graphhopper/graphhopper/commit/8bb33af68ff32fc2287de824e1e5b4cae64f0749", "message": "Merge branch 'master' into ch_routing_graph_2\n\n# Conflicts:\n#\tcore/src/main/java/com/graphhopper/routing/AbstractBidirAlgo.java\n#\tcore/src/main/java/com/graphhopper/routing/DijkstraBidirectionCH.java\n#\tcore/src/main/java/com/graphhopper/routing/ch/CHWeighting.java\n#\tcore/src/main/java/com/graphhopper/routing/ch/NodeBasedCHBidirPathExtractor.java", "committedDate": "2020-01-10T17:16:06Z", "type": "commit"}, {"oid": "d52495a81a317738251d41dadc824405ab8845fe", "url": "https://github.com/graphhopper/graphhopper/commit/d52495a81a317738251d41dadc824405ab8845fe", "message": "Merge branch 'master' into ch_routing_graph_2\n\n# Conflicts:\n#\tcore/src/main/java/com/graphhopper/routing/AlternativeRouteCH.java", "committedDate": "2020-01-15T08:38:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc2OTg2Mw==", "url": "https://github.com/graphhopper/graphhopper/pull/1850#discussion_r366769863", "bodyText": "Here the calcWeight operation is done although it could happen that the backward search has no entry and the weight is not used. Might be related to (not very likely):\n\nSo far the query speed seems to decrease by about 10%, I could not find out why exactly this is,\n\nBTW: does this slowdown occur for edge- and node-based queries?", "author": "karussell", "createdAt": "2020-01-15T09:26:47Z", "path": "core/src/main/java/com/graphhopper/routing/AbstractBidirCHAlgo.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing;\n+\n+import com.carrotsearch.hppc.IntObjectMap;\n+import com.graphhopper.routing.ch.NodeBasedCHBidirPathExtractor;\n+import com.graphhopper.routing.util.TraversalMode;\n+import com.graphhopper.storage.*;\n+\n+import java.util.PriorityQueue;\n+\n+import static com.graphhopper.util.EdgeIterator.ANY_EDGE;\n+import static com.graphhopper.util.EdgeIterator.NO_EDGE;\n+\n+/**\n+ * Common subclass for bidirectional CH algorithms.\n+ * <p>\n+ *\n+ * @author Peter Karich\n+ * @author easbar\n+ * @see AbstractNonCHBidirAlgo for non-CH bidirectional algorithms\n+ */\n+public abstract class AbstractBidirCHAlgo extends AbstractBidirAlgo implements BidirRoutingAlgorithm {\n+    protected final RoutingCHGraph graph;\n+    protected RoutingCHEdgeExplorer allEdgeExplorer;\n+    protected RoutingCHEdgeExplorer inEdgeExplorer;\n+    protected RoutingCHEdgeExplorer outEdgeExplorer;\n+    protected CHEdgeFilter levelEdgeFilter;\n+\n+    public AbstractBidirCHAlgo(RoutingCHGraph graph, TraversalMode tMode) {\n+        super(tMode);\n+        this.graph = graph;\n+        this.nodeAccess = graph.getGraph().getNodeAccess();\n+        allEdgeExplorer = graph.createAllEdgeExplorer();\n+        outEdgeExplorer = graph.createOutEdgeExplorer();\n+        inEdgeExplorer = graph.createInEdgeExplorer();\n+        levelEdgeFilter = new CHLevelEdgeFilter(graph);\n+        int size = Math.min(Math.max(200, graph.getNodes() / 10), 150_000);\n+        initCollections(size);\n+    }\n+\n+    @Override\n+    protected void initCollections(int size) {\n+        super.initCollections(Math.min(size, 2000));\n+    }\n+\n+    /**\n+     * Creates a new entry of the shortest path tree (a {@link SPTEntry} or one of its subclasses) during a dijkstra\n+     * expansion.\n+     *\n+     * @param edge    the edge that is currently processed for the expansion\n+     * @param incEdge the id of the edge that is incoming to the node the edge is pointed at. usually this is the same as\n+     *                edge.getEdge(), but for edge-based CH and in case edge is a shortcut incEdge is the original edge\n+     *                that is incoming to the node\n+     * @param weight  the weight the shortest path three entry should carry\n+     * @param parent  the parent entry of in the shortest path tree\n+     * @param reverse true if we are currently looking at the backward search, false otherwise\n+     */\n+    protected abstract SPTEntry createEntry(RoutingCHEdgeIteratorState edge, int incEdge, double weight, SPTEntry parent, boolean reverse);\n+\n+    protected BidirPathExtractor createPathExtractor(RoutingCHGraph graph) {\n+        return new NodeBasedCHBidirPathExtractor(graph);\n+    }\n+\n+    @Override\n+    protected void postInitFrom() {\n+        if (fromOutEdge == ANY_EDGE) {\n+            fillEdgesFromUsingFilter(levelEdgeFilter);\n+        } else {\n+            // need to use a local reference here, because additionalEdgeFilter is modified when calling fillEdgesFromUsingFilter\n+            final CHEdgeFilter tmpFilter = levelEdgeFilter;\n+            fillEdgesFromUsingFilter(new CHEdgeFilter() {\n+                @Override\n+                public boolean accept(RoutingCHEdgeIteratorState edgeState) {\n+                    return (tmpFilter == null || tmpFilter.accept(edgeState)) && edgeState.getOrigEdgeFirst() == fromOutEdge;\n+                }\n+            });\n+        }\n+    }\n+\n+    @Override\n+    protected void postInitTo() {\n+        if (toInEdge == ANY_EDGE) {\n+            fillEdgesToUsingFilter(levelEdgeFilter);\n+        } else {\n+            final CHEdgeFilter tmpFilter = levelEdgeFilter;\n+            fillEdgesToUsingFilter(new CHEdgeFilter() {\n+                @Override\n+                public boolean accept(RoutingCHEdgeIteratorState edgeState) {\n+                    return (tmpFilter == null || tmpFilter.accept(edgeState)) && edgeState.getOrigEdgeLast() == toInEdge;\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * @param edgeFilter edge filter used to fill edges. the {@link #levelEdgeFilter} reference will be set to\n+     *                   edgeFilter by this method, so make sure edgeFilter does not use it directly.\n+     */\n+    protected void fillEdgesFromUsingFilter(CHEdgeFilter edgeFilter) {\n+        // we temporarily ignore the additionalEdgeFilter\n+        CHEdgeFilter tmpFilter = levelEdgeFilter;\n+        levelEdgeFilter = edgeFilter;\n+        finishedFrom = !fillEdgesFrom();\n+        levelEdgeFilter = tmpFilter;\n+    }\n+\n+    /**\n+     * @see #fillEdgesFromUsingFilter(CHEdgeFilter)\n+     */\n+    protected void fillEdgesToUsingFilter(CHEdgeFilter edgeFilter) {\n+        // we temporarily ignore the additionalEdgeFilter\n+        CHEdgeFilter tmpFilter = levelEdgeFilter;\n+        levelEdgeFilter = edgeFilter;\n+        finishedTo = !fillEdgesTo();\n+        levelEdgeFilter = tmpFilter;\n+    }\n+\n+    @Override\n+    public boolean finished() {\n+        // we need to finish BOTH searches for CH!\n+        if (finishedFrom && finishedTo)\n+            return true;\n+\n+        // changed also the final finish condition for CH\n+        return currFrom.weight >= bestWeight && currTo.weight >= bestWeight;\n+    }\n+\n+    @Override\n+    boolean fillEdgesFrom() {\n+        if (pqOpenSetFrom.isEmpty()) {\n+            return false;\n+        }\n+        currFrom = pqOpenSetFrom.poll();\n+        visitedCountFrom++;\n+        if (fromEntryCanBeSkipped()) {\n+            return true;\n+        }\n+        if (fwdSearchCanBeStopped()) {\n+            return false;\n+        }\n+        bestWeightMapOther = bestWeightMapTo;\n+        fillEdges(currFrom, pqOpenSetFrom, bestWeightMapFrom, outEdgeExplorer, false);\n+        return true;\n+    }\n+\n+    @Override\n+    boolean fillEdgesTo() {\n+        if (pqOpenSetTo.isEmpty()) {\n+            return false;\n+        }\n+        currTo = pqOpenSetTo.poll();\n+        visitedCountTo++;\n+        if (toEntryCanBeSkipped()) {\n+            return true;\n+        }\n+        if (bwdSearchCanBeStopped()) {\n+            return false;\n+        }\n+        bestWeightMapOther = bestWeightMapFrom;\n+        fillEdges(currTo, pqOpenSetTo, bestWeightMapTo, inEdgeExplorer, true);\n+        return true;\n+    }\n+\n+    private void fillEdges(SPTEntry currEdge, PriorityQueue<SPTEntry> prioQueue,\n+                           IntObjectMap<SPTEntry> bestWeightMap, RoutingCHEdgeExplorer explorer, boolean reverse) {\n+        RoutingCHEdgeIterator iter = explorer.setBaseNode(currEdge.adjNode);\n+        while (iter.next()) {\n+            if (!accept(iter, currEdge, reverse))\n+                continue;\n+\n+            final double weight = calcWeight(iter, currEdge, reverse);\n+            if (Double.isInfinite(weight)) {\n+                continue;\n+            }\n+            final int origEdgeId = getOrigEdgeId(iter, reverse);\n+            final int traversalId = getTraversalId(iter, origEdgeId, reverse);\n+            SPTEntry entry = bestWeightMap.get(traversalId);\n+            if (entry == null) {\n+                entry = createEntry(iter, origEdgeId, weight, currEdge, reverse);\n+                bestWeightMap.put(traversalId, entry);\n+                prioQueue.add(entry);\n+            } else if (entry.getWeightOfVisitedPath() > weight) {\n+                prioQueue.remove(entry);\n+                updateEntry(entry, iter, origEdgeId, weight, currEdge, reverse);\n+                prioQueue.add(entry);\n+            } else\n+                continue;\n+\n+            if (updateBestPath) {\n+                // only needed for edge-based -> skip the calculation and use dummy value otherwise\n+                double edgeWeight = traversalMode.isEdgeBased() ? calcWeight(iter, reverse, NO_EDGE) : Double.POSITIVE_INFINITY;\n+                updateBestPath(edgeWeight, entry, origEdgeId, traversalId, reverse);", "originalCommit": "d52495a81a317738251d41dadc824405ab8845fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjgyMTY1OQ==", "url": "https://github.com/graphhopper/graphhopper/pull/1850#discussion_r366821659", "bodyText": "oh good point, its even worse: edge-based CH overrides the updateBestPath method and does not need edgeWeight in any case. will try if this makes the difference but I would guess so.\n\nBTW: does this slowdown occur for edge- and node-based queries?\n\nI think it is more pronounced for edge-based, but even after running many measurements I was not entirely sure", "author": "easbar", "createdAt": "2020-01-15T11:15:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc2OTg2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM0NzkyOA==", "url": "https://github.com/graphhopper/graphhopper/pull/1850#discussion_r367347928", "bodyText": "No, unfortunately this did not fix it. My next best guess is that RoutingCHGraph#getEdgeIteratorState creates two (vs. one) objects, which is relevant for path unpacking. So this could be fixed with #1847", "author": "easbar", "createdAt": "2020-01-16T10:42:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc2OTg2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc3MDc1MA==", "url": "https://github.com/graphhopper/graphhopper/pull/1850#discussion_r366770750", "bodyText": "For clarity it should be better:\n!outEdgeFilter.accept(iter) ? Double.POSITIVE_INFINITY : (weighting.calcWeight(iter, false, currEdge.edge) + currEdge.weightOfVisitedPath);", "author": "karussell", "createdAt": "2020-01-15T09:28:38Z", "path": "core/src/main/java/com/graphhopper/routing/AStar.java", "diffHunk": "@@ -83,19 +86,19 @@ public Path calcPath(int from, int to) {\n \n     private void runAlgo() {\n         double currWeightToGoal, estimationFullWeight;\n-        EdgeExplorer explorer = outEdgeExplorer;\n         while (true) {\n             visitedNodes++;\n             if (isMaxVisitedNodesExceeded() || finished())\n                 break;\n \n             int currNode = currEdge.adjNode;\n-            EdgeIterator iter = explorer.setBaseNode(currNode);\n+            EdgeIterator iter = edgeExplorer.setBaseNode(currNode);\n             while (iter.next()) {\n                 if (!accept(iter, currEdge.edge))\n                     continue;\n \n-                double tmpWeight = weighting.calcWeight(iter, false, currEdge.edge) + currEdge.weightOfVisitedPath;\n+                // todo: for #1776/#1835 move the access check into weighting\n+                double tmpWeight = !outEdgeFilter.accept(iter) ? Double.POSITIVE_INFINITY : weighting.calcWeight(iter, false, currEdge.edge) + currEdge.weightOfVisitedPath;", "originalCommit": "d52495a81a317738251d41dadc824405ab8845fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc3Mzc1NQ==", "url": "https://github.com/graphhopper/graphhopper/pull/1850#discussion_r366773755", "bodyText": "What are the use cases for the EdgeFilter for non-CH algos? (For CH there is the CHLevelEdgeFilter, but here?)\nIs it just regarding the vehicle edge and we can remove this code with #1835 ?", "author": "karussell", "createdAt": "2020-01-15T09:35:05Z", "path": "core/src/main/java/com/graphhopper/routing/AbstractNonCHBidirAlgo.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ *  Licensed to GraphHopper GmbH under one or more contributor\n+ *  license agreements. See the NOTICE file distributed with this work for\n+ *  additional information regarding copyright ownership.\n+ *\n+ *  GraphHopper GmbH licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except in\n+ *  compliance with the License. You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package com.graphhopper.routing;\n+\n+import com.carrotsearch.hppc.IntObjectMap;\n+import com.graphhopper.routing.util.DefaultEdgeFilter;\n+import com.graphhopper.routing.util.EdgeFilter;\n+import com.graphhopper.routing.util.FlagEncoder;\n+import com.graphhopper.routing.util.TraversalMode;\n+import com.graphhopper.routing.weighting.Weighting;\n+import com.graphhopper.storage.Graph;\n+import com.graphhopper.storage.SPTEntry;\n+import com.graphhopper.util.EdgeExplorer;\n+import com.graphhopper.util.EdgeIterator;\n+import com.graphhopper.util.EdgeIteratorState;\n+\n+import java.util.PriorityQueue;\n+\n+import static com.graphhopper.util.EdgeIterator.ANY_EDGE;\n+\n+/**\n+ * Common subclass for bidirectional algorithms.\n+ *\n+ * @author Peter Karich\n+ * @author easbar\n+ * @see AbstractBidirCHAlgo for bidirectional CH algorithms\n+ */\n+public abstract class AbstractNonCHBidirAlgo extends AbstractBidirAlgo implements BidirRoutingAlgorithm {\n+    protected final Graph graph;\n+    protected final Weighting weighting;\n+    protected final FlagEncoder flagEncoder;\n+    protected EdgeExplorer edgeExplorer;\n+    protected EdgeFilter inEdgeFilter;\n+    protected EdgeFilter outEdgeFilter;\n+    protected EdgeFilter additionalEdgeFilter;\n+\n+    public AbstractNonCHBidirAlgo(Graph graph, Weighting weighting, TraversalMode tMode) {\n+        super(tMode);\n+        this.weighting = weighting;\n+        this.flagEncoder = weighting.getFlagEncoder();\n+        this.graph = graph;\n+        this.nodeAccess = graph.getNodeAccess();\n+        edgeExplorer = graph.createEdgeExplorer();\n+        outEdgeFilter = DefaultEdgeFilter.outEdges(flagEncoder.getAccessEnc());\n+        inEdgeFilter = DefaultEdgeFilter.inEdges(flagEncoder.getAccessEnc());\n+        int size = Math.min(Math.max(200, graph.getNodes() / 10), 150_000);\n+        initCollections(size);\n+    }\n+\n+    /**\n+     * Creates a new entry of the shortest path tree (a {@link SPTEntry} or one of its subclasses) during a dijkstra\n+     * expansion.\n+     *\n+     * @param edge    the edge that is currently processed for the expansion\n+     * @param incEdge the id of the edge that is incoming to the node the edge is pointed at. usually this is the same as\n+     *                edge.getEdge(), but for edge-based CH and in case edge is a shortcut incEdge is the original edge\n+     *                that is incoming to the node\n+     * @param weight  the weight the shortest path three entry should carry\n+     * @param parent  the parent entry of in the shortest path tree\n+     * @param reverse true if we are currently looking at the backward search, false otherwise\n+     */\n+    protected abstract SPTEntry createEntry(EdgeIteratorState edge, int incEdge, double weight, SPTEntry parent, boolean reverse);\n+\n+    protected BidirPathExtractor createPathExtractor(Graph graph, Weighting weighting) {\n+        return new BidirPathExtractor(graph, weighting);\n+    }\n+\n+    protected void postInitFrom() {\n+        if (fromOutEdge == ANY_EDGE) {\n+            fillEdgesFromUsingFilter(additionalEdgeFilter);\n+        } else {\n+            // need to use a local reference here, because additionalEdgeFilter is modified when calling fillEdgesFromUsingFilter\n+            final EdgeFilter tmpFilter = additionalEdgeFilter;\n+            fillEdgesFromUsingFilter(new EdgeFilter() {\n+                @Override\n+                public boolean accept(EdgeIteratorState edgeState) {\n+                    return (tmpFilter == null || tmpFilter.accept(edgeState)) && edgeState.getOrigEdgeFirst() == fromOutEdge;\n+                }\n+            });\n+        }\n+    }\n+\n+    protected void postInitTo() {\n+        if (toInEdge == ANY_EDGE) {\n+            fillEdgesToUsingFilter(additionalEdgeFilter);\n+        } else {\n+            final EdgeFilter tmpFilter = additionalEdgeFilter;\n+            fillEdgesToUsingFilter(new EdgeFilter() {\n+                @Override\n+                public boolean accept(EdgeIteratorState edgeState) {\n+                    return (tmpFilter == null || tmpFilter.accept(edgeState)) && edgeState.getOrigEdgeLast() == toInEdge;\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * @param edgeFilter edge filter used to fill edges. the {@link #additionalEdgeFilter} reference will be set to\n+     *                   edgeFilter by this method, so make sure edgeFilter does not use it directly.\n+     */\n+    protected void fillEdgesFromUsingFilter(EdgeFilter edgeFilter) {\n+        // we temporarily ignore the additionalEdgeFilter\n+        EdgeFilter tmpFilter = additionalEdgeFilter;\n+        additionalEdgeFilter = edgeFilter;\n+        finishedFrom = !fillEdgesFrom();\n+        additionalEdgeFilter = tmpFilter;\n+    }\n+\n+    /**\n+     * @see #fillEdgesFromUsingFilter(EdgeFilter)\n+     */\n+    protected void fillEdgesToUsingFilter(EdgeFilter edgeFilter) {\n+        // we temporarily ignore the additionalEdgeFilter\n+        EdgeFilter tmpFilter = additionalEdgeFilter;\n+        additionalEdgeFilter = edgeFilter;\n+        finishedTo = !fillEdgesTo();\n+        additionalEdgeFilter = tmpFilter;\n+    }", "originalCommit": "d52495a81a317738251d41dadc824405ab8845fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkxMDg1Ng==", "url": "https://github.com/graphhopper/graphhopper/pull/1850#discussion_r366910856", "bodyText": "In most cases one can achieve the same effect as using additionalEdgeFilter by returning infinite weight for the corresponding edges in Weighting (or at least this it what it should be like with #1835). The only thing that comes to my mind is the initial routing step for routing with start/target edges where we use the filter to select the start/target edge. But yes we might be able to get rid of the filter entirely for #1835.", "author": "easbar", "createdAt": "2020-01-15T14:39:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc3Mzc1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQyOTQzNA==", "url": "https://github.com/graphhopper/graphhopper/pull/1850#discussion_r367429434", "bodyText": "Yes I just checked with this PR we can get rid of additional edge filter. Shall I do it here or in a follow up PR ?\nI removed the setEdgeFilter methods. Now the (previous) additionalEdgeFilter is only used internally (for 1) CH level filtering and 2) start/target edge filtering)\ne1996be", "author": "easbar", "createdAt": "2020-01-16T13:55:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc3Mzc1NQ=="}], "type": "inlineReview"}, {"oid": "c5f8bdc28f75cfe90a6befd6187f5e0066f25dd7", "url": "https://github.com/graphhopper/graphhopper/commit/c5f8bdc28f75cfe90a6befd6187f5e0066f25dd7", "message": "Add some clarifying parentheses", "committedDate": "2020-01-15T11:19:51Z", "type": "commit"}, {"oid": "f6cf858a5a03f5ba03d1293a37b479d01d9db184", "url": "https://github.com/graphhopper/graphhopper/commit/f6cf858a5a03f5ba03d1293a37b479d01d9db184", "message": "Skip edge weight calculation for edge-based CH", "committedDate": "2020-01-15T11:42:28Z", "type": "commit"}, {"oid": "8858e1088243cdf7397fa02efebae5e804d0ac7d", "url": "https://github.com/graphhopper/graphhopper/commit/8858e1088243cdf7397fa02efebae5e804d0ac7d", "message": "Add todo", "committedDate": "2020-01-15T11:51:13Z", "type": "commit"}, {"oid": "62dacb24a8bf53da5550fdcd447803d85094ad10", "url": "https://github.com/graphhopper/graphhopper/commit/62dacb24a8bf53da5550fdcd447803d85094ad10", "message": "Downgrade todo", "committedDate": "2020-01-16T13:38:44Z", "type": "commit"}, {"oid": "e1996be127502e647694af8286b6709b9c94be0c", "url": "https://github.com/graphhopper/graphhopper/commit/e1996be127502e647694af8286b6709b9c94be0c", "message": "Remove RoutingAlgo#setEdgeFilter methods, filter is only used internally now", "committedDate": "2020-01-16T14:07:18Z", "type": "commit"}, {"oid": "51e72828196e8d458c63f5afd94a0473db7cc23d", "url": "https://github.com/graphhopper/graphhopper/commit/51e72828196e8d458c63f5afd94a0473db7cc23d", "message": "Merge branch 'master' into ch_routing_graph_2", "committedDate": "2020-01-16T16:34:34Z", "type": "commit"}, {"oid": "7d4169418a9a5f5db60c0ae80f3156eeffb1bcc1", "url": "https://github.com/graphhopper/graphhopper/commit/7d4169418a9a5f5db60c0ae80f3156eeffb1bcc1", "message": "Merge branch 'master' into ch_routing_graph_2", "committedDate": "2020-01-19T07:51:27Z", "type": "commit"}]}