{"pr_number": 1607, "pr_title": "[#1604] Create head token if tokenAt has no result", "pr_createdAt": "2020-11-16T15:27:06Z", "pr_url": "https://github.com/AxonFramework/AxonFramework/pull/1607", "timeline": [{"oid": "b5337f7f15fd99fe16590d2915a954a4a8a469f3", "url": "https://github.com/AxonFramework/AxonFramework/commit/b5337f7f15fd99fe16590d2915a954a4a8a469f3", "message": "Revert to head token in absence of results\n\nIf no result is found on the createTokenAt, we assume the dateTime is\nafter the last event in the store. In that scenario we should default to\n the token at the last event in the store. If the assumption is\n incorrect, that would typically mean there are no events in the store\n anyhow, hence meaning the result of \"the last event in the store\"\n equals the original result.\n\n#1604", "committedDate": "2020-11-16T13:15:16Z", "type": "commit"}, {"oid": "37b8ac1c75468c5b636fc9072c93a529e73c91b0", "url": "https://github.com/AxonFramework/AxonFramework/commit/37b8ac1c75468c5b636fc9072c93a529e73c91b0", "message": "Fix tests\n\nThe MultiStreamableMessageSourceTest assumed null tokens on several\nspots when using createTokenAt, whilst this behaviour is changed towards\n a head token if the timestamp is greater than the most recent event\n\n#1604", "committedDate": "2020-11-16T15:20:26Z", "type": "commit"}, {"oid": "66034fe34834390c9f6ccaa5e745d0e4826edf7d", "url": "https://github.com/AxonFramework/AxonFramework/commit/66034fe34834390c9f6ccaa5e745d0e4826edf7d", "message": "Adjust indentation\n\nAdjust indentation\n\n#1604", "committedDate": "2020-11-16T15:27:25Z", "type": "commit"}, {"oid": "343d2e8e30493421d8c2f0b5d2574d9f63ee85d5", "url": "https://github.com/AxonFramework/AxonFramework/commit/343d2e8e30493421d8c2f0b5d2574d9f63ee85d5", "message": "Add test case validating token timestamp before first event\n\nIf the provided timestamp is before the first event in the store, it\nshould return the position of the first event. Validating this behaviour\n should be included in the test cases.\n\n#1604", "committedDate": "2020-11-17T08:00:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAyODEwOA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1607#discussion_r525028108", "bodyText": "I feel like the method should include the word index somewhere. And since you created this for head, we can have something similar for tail as we are doing almost the same thing at createTailToken - to have it consistent.", "author": "lfgcampos", "createdAt": "2020-11-17T10:00:36Z", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/eventstore/jdbc/JdbcEventStorageEngine.java", "diffHunk": "@@ -418,37 +431,40 @@ public TrackingToken createTailToken() {\n                 resultSet -> nextAndExtract(resultSet, 1, Long.class),\n                 e -> new EventStoreException(\"Failed to get tail token\", e)\n         ));\n-        return Optional.ofNullable(index)\n-                       .map(seq -> GapAwareTrackingToken.newInstance(seq, Collections.emptySet()))\n-                       .orElse(null);\n+        return createToken(index);\n     }\n \n     @Override\n     public TrackingToken createHeadToken() {\n+        return createToken(mostRecentToken());\n+    }\n+\n+    @Override\n+    public TrackingToken createTokenAt(Instant dateTime) {\n         Long index = transactionManager.fetchInTransaction(() -> executeQuery(\n+                getConnection(),\n+                connection -> createTokenAt(connection, dateTime),\n+                resultSet -> nextAndExtract(resultSet, 1, Long.class),\n+                e -> new EventStoreException(format(\"Failed to get token at [%s]\", dateTime), e)\n+        ));\n+        return index != null ? createToken(index) : createToken(mostRecentToken());\n+    }\n+\n+    private Long mostRecentToken() {", "originalCommit": "343d2e8e30493421d8c2f0b5d2574d9f63ee85d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA2NjMyMA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1607#discussion_r525066320", "bodyText": "Renaming to mostRecentIndex actually is reasonable, as we're dealing with indices. They might refer to tokens, but it's good to keep that apart at this stage.\nUncertain about a similar private method for the createTailToken though. The only reason I introduce the mostRecentToken/mostRecentIndex method is because I need it to be reused between the createHeadToken and createTokenAt methods. As we don't have to do a similar thing for tail tokens, I figure this should be fine to be honest.\nLet me know what you think!", "author": "smcvb", "createdAt": "2020-11-17T11:00:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAyODEwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA5NjEzNw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1607#discussion_r525096137", "bodyText": "That is completely fine!", "author": "lfgcampos", "createdAt": "2020-11-17T11:52:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAyODEwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAzNjk2OA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1607#discussion_r525036968", "bodyText": "nit: silly line break here", "author": "lfgcampos", "createdAt": "2020-11-17T10:14:22Z", "path": "eventsourcing/src/test/java/org/axonframework/eventsourcing/MultiStreamableMessageSourceTest.java", "diffHunk": "@@ -257,74 +257,103 @@ void peekWithMultipleStreams() throws InterruptedException {\n         singleEventStream.close();\n     }\n \n+    /**\n+     * Create a timestamp a bit prior to {@link Instant#now()}. This can for example be used on {@link\n+     * StreamableMessageSource#createTokenAt(Instant)} right after the insertion of some events, so that the created\n+     * token will take in these new events. Simply using {@link Instant#now()} allows for a window of opportunity which\n+     * misses these recent events.\n+     *\n+     * @return a timestamp a bit prior to {@link Instant#now()}\n+     */\n+    private static Instant recentTimeStamp() {\n+        return Instant.now().minusMillis(1000);\n+    }\n+\n     @Test\n     void createTailToken() {\n-        EventMessage pubToStreamA = GenericEventMessage.asEventMessage(\"Event1\");\n+        EventMessage<?> pubToStreamA = GenericEventMessage.asEventMessage(\"Event1\");\n         eventStoreA.publish(pubToStreamA);\n \n-        EventMessage pubToStreamB = GenericEventMessage.asEventMessage(\"Event2\");\n+        EventMessage<?> pubToStreamB = GenericEventMessage.asEventMessage(\"Event2\");\n         eventStoreB.publish(pubToStreamB);\n \n         MultiSourceTrackingToken tailToken = testSubject.createTailToken();\n \n-        assertEquals(-1L, tailToken.getTokenForStream(\"eventStoreA\").position().getAsLong());\n-        assertEquals(-1L, tailToken.getTokenForStream(\"eventStoreB\").position().getAsLong());\n+        OptionalLong storeAPosition = tailToken.getTokenForStream(\"eventStoreA\").position();\n+        assertTrue(storeAPosition.isPresent());\n+        assertEquals(-1L, storeAPosition.getAsLong());\n+        OptionalLong storeBPosition = tailToken.getTokenForStream(\"eventStoreB\").position();\n+        assertTrue(storeBPosition.isPresent());\n+        assertEquals(-1L, storeBPosition.getAsLong());\n     }\n \n     @Test\n     void createHeadToken() {\n-        EventMessage pubToStreamA = GenericEventMessage.asEventMessage(\"Event1\");\n+        EventMessage<?> pubToStreamA = GenericEventMessage.asEventMessage(\"Event1\");\n         eventStoreA.publish(pubToStreamA);\n \n-        EventMessage pubToStreamB = GenericEventMessage.asEventMessage(\"Event2\");\n+        EventMessage<?> pubToStreamB = GenericEventMessage.asEventMessage(\"Event2\");\n         eventStoreB.publish(pubToStreamB);\n         eventStoreB.publish(pubToStreamB);\n \n         MultiSourceTrackingToken headToken = testSubject.createHeadToken();\n \n-        assertEquals(0L, headToken.getTokenForStream(\"eventStoreA\").position().getAsLong());\n-        assertEquals(1L, headToken.getTokenForStream(\"eventStoreB\").position().getAsLong());\n+        OptionalLong storeAPosition = headToken.getTokenForStream(\"eventStoreA\").position();\n+        assertTrue(storeAPosition.isPresent());\n+        assertEquals(0L, storeAPosition.getAsLong());\n+        OptionalLong storeBPosition = headToken.getTokenForStream(\"eventStoreB\").position();\n+        assertTrue(storeBPosition.isPresent());\n+        assertEquals(1L, storeBPosition.getAsLong());\n     }\n \n     @Test\n     void createTokenAt() throws InterruptedException {\n-        EventMessage pubToStreamA = GenericEventMessage.asEventMessage(\"Event1\");\n+        EventMessage<?> pubToStreamA = GenericEventMessage.asEventMessage(\"Event1\");\n         eventStoreA.publish(pubToStreamA);\n         eventStoreA.publish(pubToStreamA);\n \n         Thread.sleep(20);\n \n-        EventMessage pubToStreamB = GenericEventMessage.asEventMessage(\"Event2\");\n+        EventMessage<?> pubToStreamB = GenericEventMessage.asEventMessage(\"Event2\");\n         eventStoreB.publish(pubToStreamB);\n \n-        MultiSourceTrackingToken createdAtToken = testSubject.createTokenAt(Instant.now().minus(10, ChronoUnit.MILLIS));\n-        //token should track events in eventStoreB and skip those in eventStoreA\n-        assertNull(createdAtToken.getTokenForStream(\"eventStoreA\"));\n-        assertEquals(-1L, createdAtToken.getTokenForStream(\"eventStoreB\").position().getAsLong());\n+        // Token should track events in eventStoreB and skip those in eventStoreA\n+        MultiSourceTrackingToken createdAtToken = testSubject.createTokenAt(Instant.now().minusMillis(10));\n+\n+        // storeA's token resembles an storeA head token since the create token at timestamp is after all its events\n+        assertEquals(eventStoreA.createHeadToken(), createdAtToken.getTokenForStream(\"eventStoreA\"));\n+        OptionalLong storeBPosition = createdAtToken.getTokenForStream(\"eventStoreB\").position();\n+        assertTrue(storeBPosition.isPresent());\n+        assertEquals(-1L, storeBPosition.getAsLong());\n     }\n \n     @Test\n     void createTokenSince() throws InterruptedException {\n-        EventMessage pubToStreamA = GenericEventMessage.asEventMessage(\"Event1\");\n+        EventMessage<?> pubToStreamA = GenericEventMessage.asEventMessage(\"Event1\");\n         eventStoreA.publish(pubToStreamA);\n         eventStoreA.publish(pubToStreamA);\n \n         Thread.sleep(20);\n \n-        EventMessage pubToStreamB = GenericEventMessage.asEventMessage(\"Event2\");\n+        EventMessage<?> pubToStreamB = GenericEventMessage.asEventMessage(\"Event2\");\n         eventStoreB.publish(pubToStreamB);\n \n+        // Token should track events in eventStoreB and skip those in eventStoreA\n         MultiSourceTrackingToken createdSinceToken = testSubject.createTokenSince(Duration.ofMillis(10));\n-        //token should track events in eventStoreB and skip those in eventStoreA\n-        assertNull(createdSinceToken.getTokenForStream(\"eventStoreA\"));\n-        assertEquals(-1L, createdSinceToken.getTokenForStream(\"eventStoreB\").position().getAsLong());\n+\n+        // storeA's token resembles an storeA head token since the create token at timestamp is after all its events\n+        assertEquals(eventStoreA.createHeadToken(), createdSinceToken.getTokenForStream(\"eventStoreA\"));\n+        OptionalLong storeBPosition = createdSinceToken.getTokenForStream(\"eventStoreB\").position();\n+        assertTrue(storeBPosition.isPresent());\n+        assertEquals(-1L, storeBPosition.getAsLong());\n     }\n \n     @Test\n     void configuredDifferentComparator() throws InterruptedException {\n         Comparator<Map.Entry<String, TrackedEventMessage<?>>> eventStoreAPriority =\n-                Comparator.comparing((Map.Entry<String, TrackedEventMessage<?>> e) -> !e.getKey().equals(\"eventStoreA\")).\n-                        thenComparing(e -> e.getValue().getTimestamp());\n+                Comparator.comparing((Map.Entry<String, TrackedEventMessage<?>> e) -> !e.getKey().equals(\"eventStoreA\"))\n+                          .", "originalCommit": "343d2e8e30493421d8c2f0b5d2574d9f63ee85d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA0MTY3Nw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1607#discussion_r525041677", "bodyText": "Same comment here, about having the word index somewhere.", "author": "lfgcampos", "createdAt": "2020-11-17T10:21:39Z", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/eventstore/jpa/JpaEventStorageEngine.java", "diffHunk": "@@ -325,27 +325,37 @@ public TrackingToken createTailToken() {\n \n     @Override\n     public TrackingToken createHeadToken() {\n-        List<Long> results = entityManager().createQuery(\n-                \"SELECT MAX(e.globalIndex) FROM \" + domainEventEntryEntityName() + \" e\", Long.class\n-        ).getResultList();\n-        return createToken(results);\n+        return createToken(mostRecentToken());\n     }\n \n     @Override\n     public TrackingToken createTokenAt(Instant dateTime) {\n-        List<Long> results = entityManager().createQuery(\n-                \"SELECT MIN(e.globalIndex) - 1 FROM \" + domainEventEntryEntityName()\n-                        + \" e WHERE e.timeStamp >= :dateTime\", Long.class\n-        ).setParameter(\"dateTime\", formatInstant(dateTime))\n-                                            .getResultList();\n-        return createToken(results);\n+        List<Long> results = entityManager()\n+                .createQuery(\n+                        \"SELECT MIN(e.globalIndex) - 1 FROM \" + domainEventEntryEntityName() + \" e \"\n+                                + \"WHERE e.timeStamp >= :dateTime\", Long.class\n+                )\n+                .setParameter(\"dateTime\", formatInstant(dateTime))\n+                .getResultList();\n+\n+        return noTokenFound(results) ? createToken(mostRecentToken()) : createToken(results);\n+    }\n+\n+    private List<Long> mostRecentToken() {", "originalCommit": "343d2e8e30493421d8c2f0b5d2574d9f63ee85d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9d4ba3a5e76e2e41aa8a451db7dc0f0c5910c7a5", "url": "https://github.com/AxonFramework/AxonFramework/commit/9d4ba3a5e76e2e41aa8a451db7dc0f0c5910c7a5", "message": "Process review comments\n\n- Rename method to clarify it generates an index.\n- Adjust indentation", "committedDate": "2020-11-17T11:03:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzU4MjQ1NA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1607#discussion_r527582454", "bodyText": "This construct causes \"createHeadToken\" to be called upon each call of \"createTokenAt\". That may be an expensive operation. Please use orElseGet(this::createHeadToken) instead.", "author": "abuijze", "createdAt": "2020-11-20T10:03:06Z", "path": "eventsourcing/src/main/java/org/axonframework/eventsourcing/eventstore/inmemory/InMemoryEventStorageEngine.java", "diffHunk": "@@ -153,7 +153,8 @@ public TrackingToken createTokenAt(Instant dateTime) {\n                      .map(TrackedEventMessage::trackingToken)\n                      .map(tt -> (GlobalSequenceTrackingToken) tt)\n                      .map(tt -> new GlobalSequenceTrackingToken(tt.getGlobalIndex() - 1))\n-                     .orElse(null);\n+                     .map(tt -> (TrackingToken) tt)\n+                     .orElse(createHeadToken());", "originalCommit": "9d4ba3a5e76e2e41aa8a451db7dc0f0c5910c7a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzU5MTQzMg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1607#discussion_r527591432", "bodyText": "Darn, good point. Resolved.", "author": "smcvb", "createdAt": "2020-11-20T10:18:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzU4MjQ1NA=="}], "type": "inlineReview"}, {"oid": "50d59094414abdf2510d09885535c589fa51be25", "url": "https://github.com/AxonFramework/AxonFramework/commit/50d59094414abdf2510d09885535c589fa51be25", "message": "Do orElseGet i.o. orElse\n\nDo orElseGet to not always invoke createHeadToken on the createTokenAt\nmethod\n\n#1604", "committedDate": "2020-11-20T10:18:33Z", "type": "commit"}]}