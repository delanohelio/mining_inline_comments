{"pr_number": 1634, "pr_title": "Routing Strategy Implementation Adjustments", "pr_createdAt": "2020-12-10T13:48:20Z", "pr_url": "https://github.com/AxonFramework/AxonFramework/pull/1634", "timeline": [{"oid": "8cb4be23c73e60eaae720c7a4f0cd228d530c846", "url": "https://github.com/AxonFramework/AxonFramework/commit/8cb4be23c73e60eaae720c7a4f0cd228d530c846", "message": "Several adjustments around the RoutingStrategy implementations\n\n- Adjust the UnresolvedRoutingKeyPolicy to be a RoutingStrategy\nimplementation, hence implementing getRoutingKey for ERROR, RANDOM_KEY\nand STATIC_KEY\n- Use the UnresolvedRoutingKeyPolicy / fallbackRoutingStrategy instead\nof the switch case\n- Introduce a builder paradigm starting from the\nAbstractRoutingStrategy, using it for annotation and metadata\nimplementation\n- Deprecate constructors in favor of builder paradigm\n- Adjust default of UnresolvedRoutingKeyPolicy#ERROR to\nUnresolvedRoutingKeyPolicy#RANDOM_KEY\n- Adjust the javadoc when applicable\n- Provide (missing) test cases\n\n#routing-strategy-fine-tuning", "committedDate": "2020-12-10T13:36:24Z", "type": "commit"}, {"oid": "303c6ad88e68de395ed1aff32f4bccc18b395013", "url": "https://github.com/AxonFramework/AxonFramework/commit/303c6ad88e68de395ed1aff32f4bccc18b395013", "message": "Remove deprecated constructor usage\n\nRemove deprecated constructor usage of the AnnotationRoutingStrategy\n\n#routing-strategy-fine-tuning", "committedDate": "2020-12-10T13:47:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE4NzI2MA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1634#discussion_r540187260", "bodyText": "Why is the generic parameter here? It doesn't seem to be used anywhere.", "author": "abuijze", "createdAt": "2020-12-10T13:55:37Z", "path": "messaging/src/main/java/org/axonframework/commandhandling/distributed/AbstractRoutingStrategy.java", "diffHunk": "@@ -17,62 +17,99 @@\n package org.axonframework.commandhandling.distributed;\n \n import org.axonframework.commandhandling.CommandMessage;\n-import org.axonframework.common.Assert;\n+import org.axonframework.common.AxonConfigurationException;\n \n-import java.util.concurrent.atomic.AtomicLong;\n-\n-import static java.lang.String.format;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n \n /**\n- * Abstract implementation of the RoutingStrategy interface that uses a policy to prescribe what happens when a routing\n- * cannot be resolved.\n+ * Abstract implementation of the {@link RoutingStrategy} interface that includes a fallback {@code RoutingStrategy}\n+ * which prescribes what happens when routing cannot be resolved by this implementation.\n  *\n  * @author Allard Buijze\n  * @since 2.0\n  */\n-public abstract class AbstractRoutingStrategy implements RoutingStrategy {\n+public abstract class AbstractRoutingStrategy<B extends RoutingStrategy> implements RoutingStrategy {", "originalCommit": "303c6ad88e68de395ed1aff32f4bccc18b395013", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE5Mzg0Mg==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1634#discussion_r540193842", "bodyText": "That's for the protected AbstractRoutingStrategy(Builder<B> builder) { ... } constructor.\nAnd added,I intended to create a public abstract B builder(); method, which I missed.", "author": "smcvb", "createdAt": "2020-12-10T14:04:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE4NzI2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE4ODU0Mw==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1634#discussion_r540188543", "bodyText": "Since this is an abstract class, I doubt whether using the builder pattern here simplifies things.", "author": "abuijze", "createdAt": "2020-12-10T13:57:20Z", "path": "messaging/src/main/java/org/axonframework/commandhandling/distributed/AbstractRoutingStrategy.java", "diffHunk": "@@ -17,62 +17,99 @@\n package org.axonframework.commandhandling.distributed;\n \n import org.axonframework.commandhandling.CommandMessage;\n-import org.axonframework.common.Assert;\n+import org.axonframework.common.AxonConfigurationException;\n \n-import java.util.concurrent.atomic.AtomicLong;\n-\n-import static java.lang.String.format;\n+import static org.axonframework.common.BuilderUtils.assertNonNull;\n \n /**\n- * Abstract implementation of the RoutingStrategy interface that uses a policy to prescribe what happens when a routing\n- * cannot be resolved.\n+ * Abstract implementation of the {@link RoutingStrategy} interface that includes a fallback {@code RoutingStrategy}\n+ * which prescribes what happens when routing cannot be resolved by this implementation.\n  *\n  * @author Allard Buijze\n  * @since 2.0\n  */\n-public abstract class AbstractRoutingStrategy implements RoutingStrategy {\n+public abstract class AbstractRoutingStrategy<B extends RoutingStrategy> implements RoutingStrategy {\n \n-    private static final String STATIC_ROUTING_KEY = \"unresolved\";\n+    private final RoutingStrategy fallbackRoutingStrategy;\n \n-    private final UnresolvedRoutingKeyPolicy unresolvedRoutingKeyPolicy;\n-    private final AtomicLong counter = new AtomicLong(0);\n+    /**\n+     * Instantiate a {@link AbstractRoutingStrategy} based on the fields contained in the given {@code builder}\n+     *\n+     * @param builder the {@link Builder} used to instantiate a {@link AbstractRoutingStrategy} instance\n+     */\n+    protected AbstractRoutingStrategy(Builder<B> builder) {\n+        builder.validate();\n+        this.fallbackRoutingStrategy = builder.fallbackRoutingStrategy;\n+    }\n \n     /**\n-     * Initializes the strategy using given {@code unresolvedRoutingKeyPolicy} prescribing what happens when a\n-     * routing key cannot be resolved.\n+     * Initializes the strategy using given {@link UnresolvedRoutingKeyPolicy} prescribing the fallback approach when\n+     * this implementation cannot resolve a routing key.\n      *\n-     * @param unresolvedRoutingKeyPolicy The policy for unresolved routing keys.\n+     * @param fallbackRoutingStrategy the fallback routing to use whenever this {@link RoutingStrategy} doesn't succeed\n+     * @deprecated in favor of the {@link #AbstractRoutingStrategy(Builder)}\n      */\n-    public AbstractRoutingStrategy(UnresolvedRoutingKeyPolicy unresolvedRoutingKeyPolicy) {\n-        Assert.notNull(unresolvedRoutingKeyPolicy, () -> \"unresolvedRoutingKeyPolicy may not be null\");\n-        this.unresolvedRoutingKeyPolicy = unresolvedRoutingKeyPolicy;\n+    @Deprecated\n+    public AbstractRoutingStrategy(UnresolvedRoutingKeyPolicy fallbackRoutingStrategy) {\n+        assertNonNull(fallbackRoutingStrategy, \"Fallback RoutingStrategy may not be null\");\n+        this.fallbackRoutingStrategy = fallbackRoutingStrategy;\n     }\n \n     @Override\n     public String getRoutingKey(CommandMessage<?> command) {\n         String routingKey = doResolveRoutingKey(command);\n         if (routingKey == null) {\n-            switch (unresolvedRoutingKeyPolicy) {\n-                case ERROR:\n-                    throw new CommandDispatchException(format(\"The command [%s] does not contain a routing key.\",\n-                                                              command.getCommandName()));\n-                case RANDOM_KEY:\n-                    return Long.toHexString(counter.getAndIncrement());\n-                case STATIC_KEY:\n-                    return STATIC_ROUTING_KEY;\n-                default:\n-                    throw new IllegalStateException(\"The configured UnresolvedRoutingPolicy of \"\n-                                                            + unresolvedRoutingKeyPolicy.name() + \" is not supported.\");\n-            }\n+            routingKey = fallbackRoutingStrategy.getRoutingKey(command);\n         }\n         return routingKey;\n     }\n \n     /**\n      * Resolve the Routing Key for the given {@code command}.\n      *\n-     * @param command The command to resolve the routing key for\n-     * @return the String representing the Routing Key, or {@code null} if unresolved.\n+     * @param command the command to resolve the routing key for\n+     * @return the String representing the Routing Key, or {@code null} if unresolved\n      */\n     protected abstract String doResolveRoutingKey(CommandMessage<?> command);\n+", "originalCommit": "303c6ad88e68de395ed1aff32f4bccc18b395013", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE5NDg3OA==", "url": "https://github.com/AxonFramework/AxonFramework/pull/1634#discussion_r540194878", "bodyText": "Not necessarily simplify, no, but giving us the flexibility to change whatever without creating [5/10/N] new constructors. So from the same stance as to why the other infra components have a builder instead of a constructor. Let's chat offline whether we should go this route for components of this size.", "author": "smcvb", "createdAt": "2020-12-10T14:05:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE4ODU0Mw=="}], "type": "inlineReview"}, {"oid": "f23a6b4dacd99d346cd1a8a215dfe61d0d1b640a", "url": "https://github.com/AxonFramework/AxonFramework/commit/f23a6b4dacd99d346cd1a8a215dfe61d0d1b640a", "message": "Drop abstract Builder\n\nDrop the builder from the AbstractRoutingStrategy in favor of placing\nthis logic directly in the implementations. Thus simplifying the\nAbstractRoutingStrategy\n\n#1634", "committedDate": "2020-12-14T10:35:37Z", "type": "commit"}, {"oid": "30770aba7dd89df5150889e1b844259e7d770649", "url": "https://github.com/AxonFramework/AxonFramework/commit/30770aba7dd89df5150889e1b844259e7d770649", "message": "Simplify tests\n\nSimplify tests by extracting the builder as the testee\n\n#1634", "committedDate": "2020-12-14T14:30:22Z", "type": "commit"}]}