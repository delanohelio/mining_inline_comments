{"pr_number": 5463, "pr_title": "Support memory mapped log stream segments in replicated system", "pr_createdAt": "2020-10-02T09:22:15Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/5463", "timeline": [{"oid": "13a6c69d47f69c992975b5f5210b6227d679a4cb", "url": "https://github.com/camunda-cloud/zeebe/commit/13a6c69d47f69c992975b5f5210b6227d679a4cb", "message": "chore(atomix): use separate buffers for readers\n\nThe JournalSegmentReaders re-used the MappedByteBuffer from the\nJournalSegmentWriter. It may have occured that the Writer closes and\nfrees up the buffer, but that is was still in use by a reader. By\nsplitting these up we avoid that.\n\nThis is only possible if we guarantee that all events are flushed\nonAppend on the follower. To be precise, exactly just before the\nfollower acknowledges the append as successful.", "committedDate": "2020-10-06T09:37:51Z", "type": "forcePushed"}, {"oid": "5ae5fbf8c893830c70764ba8d008f7306de6d0f7", "url": "https://github.com/camunda-cloud/zeebe/commit/5ae5fbf8c893830c70764ba8d008f7306de6d0f7", "message": "chore(atomix): use separate buffers for readers\n\nThe JournalSegmentReaders re-used the MappedByteBuffer from the\nJournalSegmentWriter. It may have occured that the Writer closes and\nfrees up the buffer, but that is was still in use by a reader. By\nsplitting these up we avoid that.\n\nThis is only possible if we guarantee that all events are flushed\nonAppend on the follower. To be precise, exactly just before the\nfollower acknowledges the append as successful.", "committedDate": "2020-10-06T11:40:10Z", "type": "forcePushed"}, {"oid": "c6be4027d9909485e461b53a88d9e5e79052ce3e", "url": "https://github.com/camunda-cloud/zeebe/commit/c6be4027d9909485e461b53a88d9e5e79052ce3e", "message": "refactor(atomix): remove MappableJournalSegmentWriter", "committedDate": "2020-10-06T15:40:01Z", "type": "forcePushed"}, {"oid": "682ad80565ec7ec34b6fe244682a7fadf71a948b", "url": "https://github.com/camunda-cloud/zeebe/commit/682ad80565ec7ec34b6fe244682a7fadf71a948b", "message": "chore(atomix): reduce reader channels access", "committedDate": "2020-10-06T15:45:17Z", "type": "forcePushed"}, {"oid": "f29afd9d371b7539f0dcb0936f9cf202320c552d", "url": "https://github.com/camunda-cloud/zeebe/commit/f29afd9d371b7539f0dcb0936f9cf202320c552d", "message": "chore(atomix): use agrona to free mapped buffer", "committedDate": "2020-10-06T16:40:51Z", "type": "forcePushed"}, {"oid": "a2f744b64f5734737ea031d187acbe5ce6256b98", "url": "https://github.com/camunda-cloud/zeebe/commit/a2f744b64f5734737ea031d187acbe5ce6256b98", "message": "docs(config): add mmap config setting to templates", "committedDate": "2020-10-08T15:27:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM4NzE4OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5463#discussion_r502387189", "bodyText": "I don't think this is correct - we flush on commit for the leader because the leader already includes itself in the quorum, so before we can truly commit we need to persist the write.", "author": "npepinpe", "createdAt": "2020-10-09T12:18:26Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/impl/RaftContext.java", "diffHunk": "@@ -350,6 +349,10 @@ public long setCommitIndex(final long commitIndex) {\n     if (commitIndex > previousCommitIndex) {\n       this.commitIndex = commitIndex;\n       logWriter.commit(Math.min(commitIndex, logWriter.getLastIndex()));\n+      if (raftLog.isFlushOnCommit() && isLeader()) {\n+        // writer's buffer is isolated from readers", "originalCommit": "a2f744b64f5734737ea031d187acbe5ce6256b98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ1MjUxNw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5463#discussion_r502452517", "bodyText": "That's true, but the reason why we need to persist the write at all is because the buffer is not shared with the readers, right?", "author": "korthout", "createdAt": "2020-10-09T14:06:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM4NzE4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ1MzY0Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5463#discussion_r502453642", "bodyText": "commits need to be persisted - you should not lose commits otherwise your raft protocol is broken", "author": "Zelldon", "createdAt": "2020-10-09T14:08:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM4NzE4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ1NDU5NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5463#discussion_r502454595", "bodyText": "No, it's because the leader counts itself in the quorum as already persisted. So, let's say your quorum is 2. On a new append, the leader will write (but not flush), and so it starts its count at 1, and only needs a follower to acknowledge before achieving quorum.\nSo the leader is not flushing on append; what if it also didn't flush on commit? Then when the follower acknowledges the append, it would commit. Let's say this happens, and the leader now sends a new request to other nodes with the new commit index, then dies. And let's say as it dies, it hadn't flushed (since we don't know when the OS will flush automatically). Now, only one node had truly persisted the write, so we didn't actually achieve quorum.", "author": "npepinpe", "createdAt": "2020-10-09T14:10:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM4NzE4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ1NTQzNQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5463#discussion_r502455435", "bodyText": "commits need to be persisted - you should not lose commits otherwise your raft protocol is broken\n\nNot quite true - the Raft paper describes that if you also wait for the async flush of the leader before counting it in the quorum, then if you still reach quorum (e.g. the 2 followers acknowledged the write before the leader flushed), then it doesn't matter, you still got quorum, so who cares if it's not flushed on the leader \ud83e\udd37\u200d\u2642\ufe0f", "author": "npepinpe", "createdAt": "2020-10-09T14:11:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM4NzE4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM4NzQwNw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5463#discussion_r502387407", "bodyText": "Just a side note, most screens are probably big enough to put this on a single line ;)\nAlso, it's not because the writer's buffer is isolated from readers, but because for us to truly acknowledge the append to the leader, we need to ensure the write is truly persisted, not just buffered in memory and eventually flushed.", "author": "npepinpe", "createdAt": "2020-10-09T12:18:54Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/roles/PassiveRole.java", "diffHunk": "@@ -609,6 +609,10 @@ protected void appendEntries(\n       raft.notifyCommitListeners(commitIndex);\n     }\n \n+    // Make sure all entries are flushed before ack\n+    // because writer's buffer is isolated from readers", "originalCommit": "a2f744b64f5734737ea031d187acbe5ce6256b98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ1NDg5Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/5463#discussion_r502454896", "bodyText": "Just a side note, most screens are probably big enough to put this on a single line ;)\n\nThat's just like your opinion, man \ud83d\ude0e", "author": "korthout", "createdAt": "2020-10-09T14:10:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM4NzQwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ1NTU3OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5463#discussion_r502455578", "bodyText": "Also, it's not because the writer's buffer is isolated from readers, but because for us to truly acknowledge the append to the leader, we need to ensure the write is truly persisted, not just buffered in memory and eventually flushed.\n\nIt makes sense to explain this better. I'll change the comment ;)", "author": "korthout", "createdAt": "2020-10-09T14:11:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM4NzQwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM4ODM3MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5463#discussion_r502388371", "bodyText": "I'm guessing this was unused?", "author": "npepinpe", "createdAt": "2020-10-09T12:20:47Z", "path": "atomix/storage/src/main/java/io/atomix/storage/journal/FileChannelJournalSegmentWriter.java", "diffHunk": "@@ -325,11 +330,6 @@ public boolean isFull() {\n         || getNextIndex() - firstIndex >= segment.descriptor().maxEntries();\n   }\n \n-  /** Returns the first index written to the segment. */\n-  public long firstIndex() {", "originalCommit": "a2f744b64f5734737ea031d187acbe5ce6256b98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ1NTc0NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5463#discussion_r502455744", "bodyText": "Yup, dead code", "author": "korthout", "createdAt": "2020-10-09T14:12:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM4ODM3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM5MTY1MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5463#discussion_r502391650", "bodyText": "afaik you can close the channel once you've mapped it, no need to keep it around.\nSo you could do:\ntry(final FileChannel channel = file.openChannel(\n            StandardOpenOption.CREATE, StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n  buffer = mapChannel(channel, segment);\n}\nBut verify in case I'm wrong \ud83d\ude42\nOr you can just use org.agrona.IoUtil.mapExistingFile(File, MapMode, String) and forgo opening the channel at all \ud83d\ude42", "author": "npepinpe", "createdAt": "2020-10-09T12:27:07Z", "path": "atomix/storage/src/main/java/io/atomix/storage/journal/MappedJournalSegmentWriter.java", "diffHunk": "@@ -46,38 +49,41 @@\n  */\n class MappedJournalSegmentWriter<E> implements JournalWriter<E> {\n \n-  private final MappedByteBuffer mappedBuffer;\n-  private final ByteBuffer buffer;\n+  private final FileChannel channel;\n+  private final MappedByteBuffer buffer;\n   private final JournalSegment<E> segment;\n   private final int maxEntrySize;\n   private final JournalIndex index;\n   private final Namespace namespace;\n   private final long firstIndex;\n   private Indexed<E> lastEntry;\n+  private boolean isOpen = true;\n \n   MappedJournalSegmentWriter(\n-      final MappedByteBuffer buffer,\n+      final JournalSegmentFile file,\n       final JournalSegment<E> segment,\n       final int maxEntrySize,\n       final JournalIndex index,\n       final Namespace namespace) {\n-    mappedBuffer = buffer;\n-    this.buffer = buffer.slice();\n     this.segment = segment;\n     this.maxEntrySize = maxEntrySize;\n     this.index = index;\n     this.namespace = namespace;\n     firstIndex = segment.index();\n+    channel =\n+        file.openChannel(\n+            StandardOpenOption.CREATE, StandardOpenOption.READ, StandardOpenOption.WRITE);\n+    buffer = mapChannel(channel, segment);", "originalCommit": "a2f744b64f5734737ea031d187acbe5ce6256b98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ1NjA2MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5463#discussion_r502456061", "bodyText": "I'll give this a try \ud83d\udc4d", "author": "korthout", "createdAt": "2020-10-09T14:12:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM5MTY1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM5MjIzMA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5463#discussion_r502392230", "bodyText": "Nit: you can also use org.agrona.IoUtil.unmap(buffer). It just calls BufferUtil, however imo it's a bit more readable in its intention.", "author": "npepinpe", "createdAt": "2020-10-09T12:28:14Z", "path": "atomix/storage/src/main/java/io/atomix/storage/journal/MappedJournalSegmentWriter.java", "diffHunk": "@@ -259,16 +262,20 @@ public void truncate(final long index) {\n \n   @Override\n   public void flush() {\n-    mappedBuffer.force();\n+    buffer.force();\n   }\n \n   @Override\n   public void close() {\n-    flush();\n-    try {\n-      BufferCleaner.freeBuffer(mappedBuffer);\n-    } catch (final IOException e) {\n-      throw new StorageException(e);\n+    if (isOpen) {\n+      isOpen = false;\n+      flush();\n+      BufferUtil.free(buffer);", "originalCommit": "a2f744b64f5734737ea031d187acbe5ce6256b98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ1NjQ3Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5463#discussion_r502456473", "bodyText": "Make sense \ud83d\udc4d  Still learning the agrona api. Thanks for sharing these", "author": "korthout", "createdAt": "2020-10-09T14:13:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM5MjIzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM5MjY0Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5463#discussion_r502392642", "bodyText": "I guess we can also remove the constant MMAP_REPLICATION_ERROR_MSG?", "author": "npepinpe", "createdAt": "2020-10-09T12:29:03Z", "path": "broker/src/main/java/io/zeebe/broker/system/SystemContext.java", "diffHunk": "@@ -76,13 +75,7 @@ private void validateConfiguration() {\n       throw new IllegalArgumentException(String.format(NODE_ID_ERROR_MSG, nodeId, clusterSize));\n     }\n \n-    final StorageLevel storageLevel = data.getAtomixStorageLevel();\n     final int replicationFactor = cluster.getReplicationFactor();\n-\n-    if (storageLevel == StorageLevel.MAPPED && replicationFactor > 1) {\n-      throw new IllegalStateException(MMAP_REPLICATION_ERROR_MSG);", "originalCommit": "a2f744b64f5734737ea031d187acbe5ce6256b98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQ1Njc3NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5463#discussion_r502456775", "bodyText": "Woops, I'll make sure to remove it.", "author": "korthout", "createdAt": "2020-10-09T14:13:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjM5MjY0Mg=="}], "type": "inlineReview"}, {"oid": "1ecb93164946f64cb9d6f45a7086597abfefb521", "url": "https://github.com/camunda-cloud/zeebe/commit/1ecb93164946f64cb9d6f45a7086597abfefb521", "message": "chore(broker): remove replicated mmap restriction", "committedDate": "2020-10-12T11:39:18Z", "type": "commit"}, {"oid": "fe6dc89c815742bffd9dde5b9e5b942050f35614", "url": "https://github.com/camunda-cloud/zeebe/commit/fe6dc89c815742bffd9dde5b9e5b942050f35614", "message": "chore(atomix): only flush on commit on leader", "committedDate": "2020-10-12T11:39:22Z", "type": "commit"}, {"oid": "c1a7e7da4bf34719f342682d220f88833854f1a8", "url": "https://github.com/camunda-cloud/zeebe/commit/c1a7e7da4bf34719f342682d220f88833854f1a8", "message": "chore(atomix): use separate buffers for readers\n\nThe JournalSegmentReaders re-used the MappedByteBuffer from the\nJournalSegmentWriter. It may have occured that the Writer closes and\nfrees up the buffer, but that is was still in use by a reader. By\nsplitting these up we avoid that.\n\nThis is only possible if we guarantee that all events are flushed\nonAppend on the follower. To be precise, exactly just before the\nfollower acknowledges the append as successful.", "committedDate": "2020-10-12T11:39:22Z", "type": "commit"}, {"oid": "785d0fd09791fd5843c52b629f27ebd8f34a1b1b", "url": "https://github.com/camunda-cloud/zeebe/commit/785d0fd09791fd5843c52b629f27ebd8f34a1b1b", "message": "refactor(atomix): remove SegmentReader/Writer indirection\n\nThe MappableJournalSegmentReader and MappableJournalSegmentWriter seemed\nto only exist to allow runtime switching between memory mapped and file\nchannel reader/writers. This brought additional complexity that is\nunnecessary for zeebe.", "committedDate": "2020-10-12T11:39:22Z", "type": "commit"}, {"oid": "4a1a3dda6bb7b7d2f5c54a6f23fb6126d782da84", "url": "https://github.com/camunda-cloud/zeebe/commit/4a1a3dda6bb7b7d2f5c54a6f23fb6126d782da84", "message": "chore(atomix): reduce reader channels access", "committedDate": "2020-10-12T11:39:22Z", "type": "commit"}, {"oid": "4994f99c7d2762474f02cecd5fe0dc961440841f", "url": "https://github.com/camunda-cloud/zeebe/commit/4994f99c7d2762474f02cecd5fe0dc961440841f", "message": "chore(atomix): use agrona to free mapped buffer", "committedDate": "2020-10-12T11:39:22Z", "type": "commit"}, {"oid": "491f08171b1884d7dac7bf0451366d4d298d28b8", "url": "https://github.com/camunda-cloud/zeebe/commit/491f08171b1884d7dac7bf0451366d4d298d28b8", "message": "chore(atomix): document explicit flushes", "committedDate": "2020-10-12T11:39:22Z", "type": "commit"}, {"oid": "7786ee81d33f82c5b7148241b2002af1e3c91334", "url": "https://github.com/camunda-cloud/zeebe/commit/7786ee81d33f82c5b7148241b2002af1e3c91334", "message": "docs(config): add mmap config setting to templates", "committedDate": "2020-10-12T11:39:22Z", "type": "commit"}, {"oid": "7022bc072302a7ef6ccdb431302b10dacb26d233", "url": "https://github.com/camunda-cloud/zeebe/commit/7022bc072302a7ef6ccdb431302b10dacb26d233", "message": "chore(atomix): apply review hints", "committedDate": "2020-10-12T11:40:07Z", "type": "commit"}, {"oid": "7022bc072302a7ef6ccdb431302b10dacb26d233", "url": "https://github.com/camunda-cloud/zeebe/commit/7022bc072302a7ef6ccdb431302b10dacb26d233", "message": "chore(atomix): apply review hints", "committedDate": "2020-10-12T11:40:07Z", "type": "forcePushed"}]}