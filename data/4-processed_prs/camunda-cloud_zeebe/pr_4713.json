{"pr_number": 4713, "pr_title": "fix(engine): check element instance before trigger timer", "pr_createdAt": "2020-06-12T11:35:41Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/4713", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQyNjQ3OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4713#discussion_r439426479", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void shouldTriggerCommandIfTimerIsTriggered() {\n          \n          \n            \n              public void shouldRejectTriggerCommandIfTimerIsTriggered() {", "author": "korthout", "createdAt": "2020-06-12T13:44:06Z", "path": "engine/src/test/java/io/zeebe/engine/processor/workflow/timer/ConcurrentTimerEventTest.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor.workflow.timer;\n+\n+import io.zeebe.engine.util.EngineRule;\n+import io.zeebe.engine.util.RecordToWrite;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.protocol.record.Assertions;\n+import io.zeebe.protocol.record.Record;\n+import io.zeebe.protocol.record.RejectionType;\n+import io.zeebe.protocol.record.intent.TimerIntent;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.protocol.record.value.TimerRecordValue;\n+import io.zeebe.test.util.record.RecordingExporter;\n+import io.zeebe.test.util.record.RecordingExporterTestWatcher;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public final class ConcurrentTimerEventTest {\n+\n+  @ClassRule public static final EngineRule ENGINE = EngineRule.singlePartition();\n+\n+  @Rule\n+  public final RecordingExporterTestWatcher recordingExporterTestWatcher =\n+      new RecordingExporterTestWatcher();\n+\n+  private long workflowInstanceKey;\n+  private Record<TimerRecordValue> timerCreated;\n+\n+  @Before\n+  public void setup() {\n+    ENGINE\n+        .deployment()\n+        .withXmlResource(\n+            Bpmn.createExecutableProcess(\"process\")\n+                .startEvent()\n+                .intermediateCatchEvent(\"timer\", e -> e.timerWithDuration(\"PT10S\"))\n+                .done())\n+        .deploy();\n+\n+    workflowInstanceKey = ENGINE.workflowInstance().ofBpmnProcessId(\"process\").create();\n+\n+    timerCreated =\n+        RecordingExporter.timerRecords(TimerIntent.CREATED)\n+            .withWorkflowInstanceKey(workflowInstanceKey)\n+            .getFirst();\n+\n+    ENGINE.stop();\n+  }\n+\n+  @Test\n+  public void shouldRejectTriggerCommandIfTimerIsCanceled() {\n+    // when\n+    ENGINE.writeRecords(\n+        RecordToWrite.command()\n+            .timer(TimerIntent.CANCEL, timerCreated.getValue())\n+            .key(timerCreated.getKey()),\n+        RecordToWrite.command()\n+            .timer(TimerIntent.TRIGGER, timerCreated.getValue())\n+            .key(timerCreated.getKey()));\n+\n+    ENGINE.start();\n+\n+    // then\n+    final var rejection =\n+        RecordingExporter.timerRecords(TimerIntent.TRIGGER)\n+            .onlyCommandRejections()\n+            .withWorkflowInstanceKey(workflowInstanceKey)\n+            .getFirst();\n+\n+    Assertions.assertThat(rejection).hasRejectionType(RejectionType.NOT_FOUND);\n+  }\n+\n+  @Test\n+  public void shouldTriggerCommandIfTimerIsTriggered() {", "originalCommit": "3be4d0dca9a63899495db56fb1a2099f16475c53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQzMTA3OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4713#discussion_r439431079", "bodyText": "I'm not sure I like this test. It looks like the test binds too much to the implementation. Instead of writing commands and events, I feel it would be better to only write commands and wait for something to have occurred before writing another command. For example, send the cancel command for the process, that in turn terminates the process incl the timer intermediate catch event. We wait for that to happen and then send a trigger timer command.", "author": "korthout", "createdAt": "2020-06-12T13:51:50Z", "path": "engine/src/test/java/io/zeebe/engine/processor/workflow/timer/ConcurrentTimerEventTest.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor.workflow.timer;\n+\n+import io.zeebe.engine.util.EngineRule;\n+import io.zeebe.engine.util.RecordToWrite;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.protocol.record.Assertions;\n+import io.zeebe.protocol.record.Record;\n+import io.zeebe.protocol.record.RejectionType;\n+import io.zeebe.protocol.record.intent.TimerIntent;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.protocol.record.value.TimerRecordValue;\n+import io.zeebe.test.util.record.RecordingExporter;\n+import io.zeebe.test.util.record.RecordingExporterTestWatcher;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public final class ConcurrentTimerEventTest {\n+\n+  @ClassRule public static final EngineRule ENGINE = EngineRule.singlePartition();\n+\n+  @Rule\n+  public final RecordingExporterTestWatcher recordingExporterTestWatcher =\n+      new RecordingExporterTestWatcher();\n+\n+  private long workflowInstanceKey;\n+  private Record<TimerRecordValue> timerCreated;\n+\n+  @Before\n+  public void setup() {\n+    ENGINE\n+        .deployment()\n+        .withXmlResource(\n+            Bpmn.createExecutableProcess(\"process\")\n+                .startEvent()\n+                .intermediateCatchEvent(\"timer\", e -> e.timerWithDuration(\"PT10S\"))\n+                .done())\n+        .deploy();\n+\n+    workflowInstanceKey = ENGINE.workflowInstance().ofBpmnProcessId(\"process\").create();\n+\n+    timerCreated =\n+        RecordingExporter.timerRecords(TimerIntent.CREATED)\n+            .withWorkflowInstanceKey(workflowInstanceKey)\n+            .getFirst();\n+\n+    ENGINE.stop();\n+  }\n+\n+  @Test\n+  public void shouldRejectTriggerCommandIfTimerIsCanceled() {\n+    // when\n+    ENGINE.writeRecords(\n+        RecordToWrite.command()\n+            .timer(TimerIntent.CANCEL, timerCreated.getValue())\n+            .key(timerCreated.getKey()),\n+        RecordToWrite.command()\n+            .timer(TimerIntent.TRIGGER, timerCreated.getValue())\n+            .key(timerCreated.getKey()));\n+\n+    ENGINE.start();\n+\n+    // then\n+    final var rejection =\n+        RecordingExporter.timerRecords(TimerIntent.TRIGGER)\n+            .onlyCommandRejections()\n+            .withWorkflowInstanceKey(workflowInstanceKey)\n+            .getFirst();\n+\n+    Assertions.assertThat(rejection).hasRejectionType(RejectionType.NOT_FOUND);\n+  }\n+\n+  @Test\n+  public void shouldTriggerCommandIfTimerIsTriggered() {\n+    // when\n+    ENGINE.writeRecords(\n+        RecordToWrite.command()\n+            .timer(TimerIntent.TRIGGER, timerCreated.getValue())\n+            .key(timerCreated.getKey()),\n+        RecordToWrite.command()\n+            .timer(TimerIntent.TRIGGER, timerCreated.getValue())\n+            .key(timerCreated.getKey()));\n+\n+    ENGINE.start();\n+\n+    // then\n+    final var rejection =\n+        RecordingExporter.timerRecords(TimerIntent.TRIGGER)\n+            .onlyCommandRejections()\n+            .withWorkflowInstanceKey(workflowInstanceKey)\n+            .getFirst();\n+\n+    Assertions.assertThat(rejection).hasRejectionType(RejectionType.NOT_FOUND);\n+  }\n+\n+  @Test\n+  public void shouldRejectCancelCommandIfTimerIsTriggered() {\n+    // when\n+    ENGINE.writeRecords(\n+        RecordToWrite.command()\n+            .timer(TimerIntent.TRIGGER, timerCreated.getValue())\n+            .key(timerCreated.getKey()),\n+        RecordToWrite.command()\n+            .timer(TimerIntent.CANCEL, timerCreated.getValue())\n+            .key(timerCreated.getKey()));\n+\n+    ENGINE.start();\n+\n+    // then\n+    final var rejection =\n+        RecordingExporter.timerRecords(TimerIntent.CANCEL)\n+            .onlyCommandRejections()\n+            .withWorkflowInstanceKey(workflowInstanceKey)\n+            .getFirst();\n+\n+    Assertions.assertThat(rejection).hasRejectionType(RejectionType.NOT_FOUND);\n+  }\n+\n+  @Test\n+  public void shouldRejectTriggerCommandIfElementInstanceIsLeft() {\n+    // given\n+    final var processActivated =\n+        RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_ACTIVATED)\n+            .withElementType(BpmnElementType.PROCESS)\n+            .getFirst();\n+\n+    final var eventActivated =\n+        RecordingExporter.workflowInstanceRecords(WorkflowInstanceIntent.ELEMENT_ACTIVATED)\n+            .withElementType(BpmnElementType.INTERMEDIATE_CATCH_EVENT)\n+            .getFirst();\n+\n+    // when\n+    ENGINE.writeRecords(\n+        RecordToWrite.command()\n+            .workflowInstance(WorkflowInstanceIntent.CANCEL, processActivated.getValue())\n+            .key(processActivated.getKey()),\n+        RecordToWrite.event()\n+            .workflowInstance(\n+                WorkflowInstanceIntent.ELEMENT_TERMINATING, processActivated.getValue())\n+            .key(processActivated.getKey())\n+            .causedBy(0),\n+        RecordToWrite.event()\n+            .workflowInstance(WorkflowInstanceIntent.ELEMENT_TERMINATING, eventActivated.getValue())\n+            .key(eventActivated.getKey())\n+            .causedBy(1),\n+        RecordToWrite.event()\n+            .workflowInstance(WorkflowInstanceIntent.ELEMENT_TERMINATED, eventActivated.getValue())\n+            .key(eventActivated.getKey())\n+            .causedBy(2),\n+        RecordToWrite.command()\n+            .timer(TimerIntent.TRIGGER, timerCreated.getValue())\n+            .key(timerCreated.getKey()));", "originalCommit": "3be4d0dca9a63899495db56fb1a2099f16475c53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkzNTE1OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4713#discussion_r439935158", "bodyText": "I see your point. This type of tests are more coupled to the implementation (i.e. the records on the stream).\nHowever, I see no other way to test this. We have no way to pause the stream processing and inject commands.\nIf I would write the test like this:\n\nwait until the timer event is activated\nwrite the cancel workflow instance command\nwait until the workflow instance is terminated\nwrite the trigger timer command\n\nthen it wouldn't test the behavior because the timer is canceled when the timer event is terminated. The command would be rejected but it is a different situation.\nLet's discuss it f2f if you want to challenge the approach or have more questions :)", "author": "saig0", "createdAt": "2020-06-15T05:19:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQzMTA3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAwODcwOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4713#discussion_r440008708", "bodyText": "As discussed, this approach was chosen after pausing the stream processing became too complex in other tests.", "author": "korthout", "createdAt": "2020-06-15T08:23:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQzMTA3OQ=="}], "type": "inlineReview"}, {"oid": "449c3be18ef3b7c4c7dd6a5cf057cdca54b25cf4", "url": "https://github.com/camunda-cloud/zeebe/commit/449c3be18ef3b7c4c7dd6a5cf057cdca54b25cf4", "message": "fix(engine): check element instance before trigger timer\n\n* trigger timer only if the related element instance is still activated\n* remove element instance on terminated\n* replace old stream processor test with new record batch style\n\nCo-authored-by: Nico Korthout <korthout@users.noreply.github.com>", "committedDate": "2020-06-15T09:02:21Z", "type": "commit"}, {"oid": "449c3be18ef3b7c4c7dd6a5cf057cdca54b25cf4", "url": "https://github.com/camunda-cloud/zeebe/commit/449c3be18ef3b7c4c7dd6a5cf057cdca54b25cf4", "message": "fix(engine): check element instance before trigger timer\n\n* trigger timer only if the related element instance is still activated\n* remove element instance on terminated\n* replace old stream processor test with new record batch style\n\nCo-authored-by: Nico Korthout <korthout@users.noreply.github.com>", "committedDate": "2020-06-15T09:02:21Z", "type": "forcePushed"}]}