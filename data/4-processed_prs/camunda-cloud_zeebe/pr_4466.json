{"pr_number": 4466, "pr_title": "Refactor Atomix", "pr_createdAt": "2020-05-06T20:54:28Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/4466", "timeline": [{"oid": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "url": "https://github.com/camunda-cloud/zeebe/commit/e920effc9dc7aef5836da9347a22bc7daca5e46f", "message": "chore(atomix): refactor raft tests\n\n Remove all tests which are session related.\n Replace/migrate tests which used sessions/primitives and append\n directly to the log.\n\n Some tests will no longer work if the state machine and snapshot is\n moved into atomix, which means they are removed for now and need to be\n replaced later in a follow up issue.", "committedDate": "2020-05-07T05:54:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk0MjI4MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r422942280", "bodyText": "RaftStateMachineFactory could be simplified to only take one parameter", "author": "pihme", "createdAt": "2020-05-11T10:28:25Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/RaftServer.java", "diffHunk": "@@ -584,13 +571,11 @@ default boolean isLeader() {\n     protected RaftStorage storage;\n     protected Duration electionTimeout = DEFAULT_ELECTION_TIMEOUT;\n     protected Duration heartbeatInterval = DEFAULT_HEARTBEAT_INTERVAL;\n-    protected Duration sessionTimeout = DEFAULT_SESSION_TIMEOUT;\n-    protected PrimitiveTypeRegistry primitiveTypes;\n     protected ThreadModel threadModel = DEFAULT_THREAD_MODEL;\n     protected int threadPoolSize = DEFAULT_THREAD_POOL_SIZE;\n     protected ThreadContextFactory threadContextFactory;\n-    protected RaftStateMachineFactory stateMachineFactory = RaftServiceManager::new;\n-    protected LoadMonitorFactory loadMonitorFactory = LoadMonitor::new;\n+    protected RaftStateMachineFactory stateMachineFactory =", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk1NzczNA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r422957734", "bodyText": "I think the builder should use the SnapshotStoreFactory of the RaftStorageConfig by default, and not hardcode a snapshot store. This would mean that either the factory of the config need to be passed to the builder on construction.", "author": "pihme", "createdAt": "2020-05-11T10:57:43Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/storage/RaftStorage.java", "diffHunk": "@@ -698,7 +698,8 @@ public Builder withSnapshotStore(final SnapshotStore snapshotStore) {\n     @Override\n     public RaftStorage build() {\n       if (snapshotStore == null) {\n-        snapshotStore = new DefaultSnapshotStore(directory.toPath(), prefix);\n+        snapshotStore =", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIyMjkzNQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r424222935", "bodyText": "Thanks for the hint. I will take a look at it when refactoring and merging the snapshot stuff. Probably need to refactor all these cfg and builders, seem like lot of redudancy.", "author": "Zelldon", "createdAt": "2020-05-13T07:20:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk1NzczNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk2MTE3Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r422961173", "bodyText": "Looks like a verbatim copy of io.zeebe.engine.util.StreamProcessingComposite Maybe it was a rename and the commit was incomplete?", "author": "pihme", "createdAt": "2020-05-11T11:04:13Z", "path": "broker/src/test/java/io/zeebe/broker/system/partitions/StreamProcessingComposite.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.broker.system.partitions;", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDIyNDExMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r424224112", "bodyText": "I plan to remove this stuff from then tests.", "author": "Zelldon", "createdAt": "2020-05-13T07:22:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk2MTE3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk2NTcwMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r422965701", "bodyText": "Maybe unit tests here?\n\nsame file should always get the same checksum\ntwo different files get different checksums\nsame files in same order get same checksum\nsame files, but different order gets different checksums", "author": "pihme", "createdAt": "2020-05-11T11:13:22Z", "path": "util/src/main/java/io/zeebe/util/ChecksumUtil.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.util;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.zip.CRC32;\n+\n+public final class ChecksumUtil {\n+\n+  private ChecksumUtil() {}\n+\n+  /** computes a checksum for the files, in the order they're presented */\n+  public static long createCombinedChecksum(final List<Path> paths) throws IOException {", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3NzczOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r422977738", "bodyText": "CLOSED_SESSION is never used and can probably be removed.", "author": "pihme", "createdAt": "2020-05-11T11:37:27Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/RaftError.java", "diffHunk": "@@ -188,7 +188,7 @@ PrimitiveException createException() {\n \n       @Override\n       PrimitiveException createException(final String message) {\n-        return message != null ? new PrimitiveException.ClosedSession(message) : createException();\n+        throw new UnsupportedOperationException(\"Sessions are no longer supported.\");", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI4OTE4OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r424289189", "bodyText": "Removing these enums might break backwards compatibility. I have to investigate that separately.", "author": "Zelldon", "createdAt": "2020-05-13T09:10:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk3NzczOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk4MTE4OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r422981188", "bodyText": "UNKNOWN_SESSIONis still being used in LeaderRole\nI think it is worth investigating, how the removal of sessions impacts the implementation of LeaderRole. Ideally, LeaderRole wouldn't need this enum value anymore, so that it can be removed", "author": "pihme", "createdAt": "2020-05-11T11:44:30Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/RaftError.java", "diffHunk": "@@ -162,7 +162,7 @@ PrimitiveException createException() {\n \n       @Override\n       PrimitiveException createException(final String message) {\n-        return message != null ? new PrimitiveException.UnknownSession(message) : createException();\n+        throw new UnsupportedOperationException(\"Sessions are no longer supported\");", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk4NTYzNg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r422985636", "bodyText": "??? What does this even mean?", "author": "pihme", "createdAt": "2020-05-11T11:53:52Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/RaftServer.java", "diffHunk": "@@ -60,10 +54,8 @@\n  *\n  * <h2>State machines</h2>\n  *\n- * Underlying each server is a {@link PrimitiveService}. The state machine is responsible for\n- * maintaining the state with relation to {@link OperationType#COMMAND}s and {@link\n- * OperationType#QUERY}s submitted to the server by a client. State machines are provided in a\n- * factory to allow servers to transition between stateful and stateless states.\n+ * State machines are provided in a factory to allow servers to transition between stateful and", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ2MzA3Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423463076", "bodyText": "Idk. Just removed the related comment which references session. You should be aware that all of these comments and most of the atomix code is not initially written by us.", "author": "Zelldon", "createdAt": "2020-05-12T05:01:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk4NTYzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk4NzgwNQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r422987805", "bodyText": "Maybe at least log the exception?", "author": "pihme", "createdAt": "2020-05-11T11:58:19Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/partition/RaftPartition.java", "diffHunk": "@@ -185,37 +165,9 @@ public String name() {\n     return String.format(\"%s-partition-%d\", partitionId.group(), partitionId.id());\n   }\n \n-  /** Updates the partition with the given metadata. */\n-  CompletableFuture<Void> update(\n-      final PartitionMetadata metadata, final PartitionManagementService managementService) {\n-    if (server == null\n-        && metadata\n-            .members()\n-            .contains(managementService.getMembershipService().getLocalMember().id())) {\n-      initServer(managementService);\n-      return server.join(metadata.members());\n-    } else if (server != null\n-        && !metadata\n-            .members()\n-            .contains(managementService.getMembershipService().getLocalMember().id())) {\n-      return server.leave().thenRun(() -> server = null);\n-    }\n-    return CompletableFuture.completedFuture(null);\n-  }\n-\n   /** Closes the partition. */\n   CompletableFuture<Void> close() {\n-    return closeClient()\n-        .exceptionally(v -> null)\n-        .thenCompose(v -> closeServer())\n-        .exceptionally(v -> null);\n-  }\n-\n-  private CompletableFuture<Void> closeClient() {\n-    if (client != null) {\n-      return client.stop();\n-    }\n-    return CompletableFuture.completedFuture(null);\n+    return closeServer().exceptionally(v -> null);", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk5MTIwOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r422991209", "bodyText": "could perhaps lead to NPE in ZeebePartition#onRoleChange Not sure whether the lifecycle guarantees that a server is set when onRoleChange() is called", "author": "pihme", "createdAt": "2020-05-11T12:05:03Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/partition/RaftPartition.java", "diffHunk": "@@ -262,25 +213,6 @@ public long term() {\n     return partitionMetadata != null ? partitionMetadata.members() : Collections.emptyList();\n   }\n \n-  @Override\n-  public MemberId primary() {\n-    return client != null ? client.leader() : null;\n-  }\n-\n-  @Override\n-  public Collection<MemberId> backups() {\n-    final MemberId leader = primary();\n-    if (leader == null) {\n-      return members();\n-    }\n-    return members().stream().filter(m -> !m.equals(leader)).collect(Collectors.toSet());\n-  }\n-\n-  @Override\n-  public RaftPartitionClient getClient() {\n-    return client;\n-  }\n-\n   public Role getRole() {\n     return server != null ? server.getRole() : null;", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk5MzAxMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r422993011", "bodyText": "Please add the old types as line comments for the new void lines. Otherwise, this is just way too confusing.", "author": "pihme", "createdAt": "2020-05-11T12:08:51Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/partition/impl/RaftNamespaces.java", "diffHunk": "@@ -117,57 +73,45 @@\n           .register(VoteResponse.class)\n           .register(AppendRequest.class)\n           .register(AppendResponse.class)\n-          .register(PublishRequest.class)\n-          .register(ResetRequest.class)\n           .register(RaftResponse.Status.class)\n           .register(RaftError.class)\n           .register(RaftError.Type.class)\n-          .register(ReadConsistency.class)\n-          .register(SessionMetadata.class)\n-          .register(CloseSessionEntry.class)\n-          .register(CommandEntry.class)\n           .register(ConfigurationEntry.class)\n           .register(InitializeEntry.class)\n-          .register(KeepAliveEntry.class)\n-          .register(MetadataEntry.class)\n-          .register(OpenSessionEntry.class)\n-          .register(QueryEntry.class)\n-          .register(PrimitiveOperation.class)\n-          .register(PrimitiveEvent.class)\n-          .register(DefaultEventType.class)\n-          .register(DefaultOperationId.class)\n-          .register(OperationType.class)\n-          .register(ReadConsistency.class)\n           .register(ArrayList.class)\n           .register(LinkedList.class)\n           .register(Collections.emptyList().getClass())\n           .register(HashSet.class)\n           .register(DefaultRaftMember.class)\n           .register(MemberId.class)\n-          .register(SessionId.class)\n           .register(RaftMember.Type.class)\n           .register(Instant.class)\n           .register(Configuration.class)\n           .register(ZeebeEntry.class)\n           .build(\"RaftProtocol\");\n \n-  /** Raft storage namespace. */\n+  /**\n+   * Raft storage namespace.\n+   *\n+   * <p>*Be aware* we use the Void type for replaced/removed types to keep the id's of used types,\n+   * otherwise we break compatibility.\n+   */\n   public static final Namespace RAFT_STORAGE =\n       Namespace.builder()\n           .register(Namespaces.BASIC)\n           .nextId(Namespaces.BEGIN_USER_CUSTOM_ID + 100)\n-          .register(CloseSessionEntry.class)", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMDczMw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423010733", "bodyText": "Optional: personally I would expect these lines as part of the when section:\nWhen I append an entry and wait for the commit and log, then ..", "author": "pihme", "createdAt": "2020-05-11T12:42:15Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftAppendTest.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.storage.journal.Indexed;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+@RunWith(Parameterized.class)\n+public class RaftAppendTest {\n+\n+  @Rule @Parameter public RaftRule raftRule;\n+\n+  @Parameters(name = \"{index}: {0}\")\n+  public static Object[][] reprocessingTriggers() {\n+    return new Object[][] {\n+      new Object[] {RaftRule.withBootstrappedNodes(2)},\n+      new Object[] {RaftRule.withBootstrappedNodes(3)},\n+      new Object[] {RaftRule.withBootstrappedNodes(4)},\n+      new Object[] {RaftRule.withBootstrappedNodes(5)}\n+    };\n+  }\n+\n+  @Test\n+  public void shouldAppendEntryOnAllNodes() throws Throwable {\n+    // given\n+\n+    // when\n+    raftRule.appendEntry();\n+\n+    // then\n+    raftRule.awaitCommit(2);", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAxMzk2OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423013968", "bodyText": "you could use assertThat(firstMemberEntries).describedAs(\"Enty comparison 1 v \" + member.getId() to give the error message more context", "author": "pihme", "createdAt": "2020-05-11T12:47:55Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftAppendTest.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.storage.journal.Indexed;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+@RunWith(Parameterized.class)\n+public class RaftAppendTest {\n+\n+  @Rule @Parameter public RaftRule raftRule;\n+\n+  @Parameters(name = \"{index}: {0}\")\n+  public static Object[][] reprocessingTriggers() {\n+    return new Object[][] {\n+      new Object[] {RaftRule.withBootstrappedNodes(2)},\n+      new Object[] {RaftRule.withBootstrappedNodes(3)},\n+      new Object[] {RaftRule.withBootstrappedNodes(4)},\n+      new Object[] {RaftRule.withBootstrappedNodes(5)}\n+    };\n+  }\n+\n+  @Test\n+  public void shouldAppendEntryOnAllNodes() throws Throwable {\n+    // given\n+\n+    // when\n+    raftRule.appendEntry();\n+\n+    // then\n+    raftRule.awaitCommit(2);\n+    raftRule.awaitSameLogSizeOnAllNodes();\n+    final var memberLog = raftRule.getMemberLog();\n+\n+    final var logLength = memberLog.values().stream().map(List::size).findFirst().orElseThrow();\n+    assertThat(logLength).withFailMessage(memberLog.toString()).isEqualTo(2);\n+\n+    assertMemberLogs(memberLog);\n+  }\n+\n+  @Test\n+  public void shouldAppendEntriesOnAllNodes() throws Throwable {\n+    // given\n+    final var entryCount = 128;\n+\n+    // when\n+    raftRule.awaitAppendEntries(entryCount);\n+\n+    // then\n+    raftRule.awaitCommit(entryCount + 1);\n+    raftRule.awaitSameLogSizeOnAllNodes();\n+    final var memberLog = raftRule.getMemberLog();\n+\n+    final var logLength = memberLog.values().stream().map(List::size).findFirst().orElseThrow();\n+    assertThat(logLength).isEqualTo(entryCount + 1);\n+    assertMemberLogs(memberLog);\n+  }\n+\n+  private void assertMemberLogs(final Map<String, List<Indexed<?>>> memberLog) {\n+    final var firstMemberEntries = memberLog.get(\"1\");\n+    final var members = memberLog.keySet();\n+    for (final var member : members) {\n+      if (!member.equals(\"1\")) {\n+        final var otherEntries = memberLog.get(member);\n+\n+        assertThat(firstMemberEntries).containsExactly(otherEntries.toArray(new Indexed[0]));", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAyNTgwOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423025809", "bodyText": "Will throw IAE as per line 83. Not sure what this method is for", "author": "pihme", "createdAt": "2020-05-11T13:08:31Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAyODM0Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423028347", "bodyText": "Not sure why there is a timeout. The exception will be ignored anyway. And if this runs sequentially, then each server could take up to 30 seconds. Maybe better collect the futures and wait for all of them. Or just call shutdown without waiting", "author": "pihme", "createdAt": "2020-05-11T13:12:40Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {\n+    return new RaftRule(-1);\n+  }\n+\n+  @Override\n+  public Statement apply(final Statement base, final Description description) {\n+    final var statement = super.apply(base, description);\n+    return temporaryFolder.apply(statement, description);\n+  }\n+\n+  @Override\n+  protected void before() throws Throwable {\n+    directory = temporaryFolder.newFolder().toPath();\n+\n+    position = 0;\n+    members = new ArrayList<>();\n+    memberLog = new ConcurrentHashMap<>();\n+    nextId = 0;\n+    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n+    protocolFactory = new TestRaftProtocolFactory(context);\n+\n+    if (nodeCount > 0) {\n+      createServers(nodeCount);\n+    }\n+  }\n+\n+  @Override\n+  protected void after() {\n+    servers.forEach(\n+        s -> {\n+          try {\n+            if (s.isRunning()) {\n+              s.shutdown().get(30, TimeUnit.SECONDS);", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzMDQyMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423030421", "bodyText": "directory is not reset", "author": "pihme", "createdAt": "2020-05-11T13:15:52Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {\n+    return new RaftRule(-1);\n+  }\n+\n+  @Override\n+  public Statement apply(final Statement base, final Description description) {\n+    final var statement = super.apply(base, description);\n+    return temporaryFolder.apply(statement, description);\n+  }\n+\n+  @Override\n+  protected void before() throws Throwable {\n+    directory = temporaryFolder.newFolder().toPath();\n+\n+    position = 0;\n+    members = new ArrayList<>();\n+    memberLog = new ConcurrentHashMap<>();\n+    nextId = 0;\n+    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n+    protocolFactory = new TestRaftProtocolFactory(context);\n+\n+    if (nodeCount > 0) {\n+      createServers(nodeCount);\n+    }\n+  }\n+\n+  @Override\n+  protected void after() {\n+    servers.forEach(\n+        s -> {\n+          try {\n+            if (s.isRunning()) {\n+              s.shutdown().get(30, TimeUnit.SECONDS);\n+            }\n+          } catch (final Exception e) {\n+            // its fine..\n+          }\n+        });\n+    servers.clear();\n+    context.close();\n+    context = null;\n+    members.clear();\n+    nextId = 0;\n+    protocolFactory = null;\n+    highestCommit = 0;\n+    commitAwaiterRef.set(null);\n+    memberLog.clear();\n+    memberLog = null;\n+    position = 0;", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzMjAzOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423032039", "bodyText": "When can this happen? Lines 166 look they always create active members", "author": "pihme", "createdAt": "2020-05-11T13:18:30Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {\n+    return new RaftRule(-1);\n+  }\n+\n+  @Override\n+  public Statement apply(final Statement base, final Description description) {\n+    final var statement = super.apply(base, description);\n+    return temporaryFolder.apply(statement, description);\n+  }\n+\n+  @Override\n+  protected void before() throws Throwable {\n+    directory = temporaryFolder.newFolder().toPath();\n+\n+    position = 0;\n+    members = new ArrayList<>();\n+    memberLog = new ConcurrentHashMap<>();\n+    nextId = 0;\n+    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n+    protocolFactory = new TestRaftProtocolFactory(context);\n+\n+    if (nodeCount > 0) {\n+      createServers(nodeCount);\n+    }\n+  }\n+\n+  @Override\n+  protected void after() {\n+    servers.forEach(\n+        s -> {\n+          try {\n+            if (s.isRunning()) {\n+              s.shutdown().get(30, TimeUnit.SECONDS);\n+            }\n+          } catch (final Exception e) {\n+            // its fine..\n+          }\n+        });\n+    servers.clear();\n+    context.close();\n+    context = null;\n+    members.clear();\n+    nextId = 0;\n+    protocolFactory = null;\n+    highestCommit = 0;\n+    commitAwaiterRef.set(null);\n+    memberLog.clear();\n+    memberLog = null;\n+    position = 0;\n+  }\n+\n+  /**\n+   * Returns the next server address.\n+   *\n+   * @param type The startup member type.\n+   * @return The next server address.\n+   */\n+  private RaftMember nextMember(final RaftMember.Type type) {\n+    return new TestMember(nextNodeId(), type);\n+  }\n+\n+  /**\n+   * Returns the next unique member identifier.\n+   *\n+   * @return The next unique member identifier.\n+   */\n+  private MemberId nextNodeId() {\n+    return MemberId.from(String.valueOf(++nextId));\n+  }\n+\n+  /** Creates a set of Raft servers. */\n+  private List<RaftServer> createServers(final int nodes) throws Exception {\n+    final List<RaftServer> servers = new ArrayList<>();\n+\n+    for (int i = 0; i < nodes; i++) {\n+      members.add(nextMember(RaftMember.Type.ACTIVE));\n+    }\n+\n+    final CountDownLatch latch = new CountDownLatch(nodes);\n+\n+    for (int i = 0; i < nodes; i++) {\n+      final RaftServer server = createServer(members.get(i).memberId());\n+      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n+        server\n+            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      } else {\n+        server", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM5MjMxNQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r424392315", "bodyText": "this was copied from the previous RaftTests. It is needed when we test with passive nodes. But we can also remove it for now", "author": "Zelldon", "createdAt": "2020-05-13T12:20:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzMjAzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzMjQ3MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423032470", "bodyText": "Why wait longer for more nodes?", "author": "pihme", "createdAt": "2020-05-11T13:19:06Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {\n+    return new RaftRule(-1);\n+  }\n+\n+  @Override\n+  public Statement apply(final Statement base, final Description description) {\n+    final var statement = super.apply(base, description);\n+    return temporaryFolder.apply(statement, description);\n+  }\n+\n+  @Override\n+  protected void before() throws Throwable {\n+    directory = temporaryFolder.newFolder().toPath();\n+\n+    position = 0;\n+    members = new ArrayList<>();\n+    memberLog = new ConcurrentHashMap<>();\n+    nextId = 0;\n+    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n+    protocolFactory = new TestRaftProtocolFactory(context);\n+\n+    if (nodeCount > 0) {\n+      createServers(nodeCount);\n+    }\n+  }\n+\n+  @Override\n+  protected void after() {\n+    servers.forEach(\n+        s -> {\n+          try {\n+            if (s.isRunning()) {\n+              s.shutdown().get(30, TimeUnit.SECONDS);\n+            }\n+          } catch (final Exception e) {\n+            // its fine..\n+          }\n+        });\n+    servers.clear();\n+    context.close();\n+    context = null;\n+    members.clear();\n+    nextId = 0;\n+    protocolFactory = null;\n+    highestCommit = 0;\n+    commitAwaiterRef.set(null);\n+    memberLog.clear();\n+    memberLog = null;\n+    position = 0;\n+  }\n+\n+  /**\n+   * Returns the next server address.\n+   *\n+   * @param type The startup member type.\n+   * @return The next server address.\n+   */\n+  private RaftMember nextMember(final RaftMember.Type type) {\n+    return new TestMember(nextNodeId(), type);\n+  }\n+\n+  /**\n+   * Returns the next unique member identifier.\n+   *\n+   * @return The next unique member identifier.\n+   */\n+  private MemberId nextNodeId() {\n+    return MemberId.from(String.valueOf(++nextId));\n+  }\n+\n+  /** Creates a set of Raft servers. */\n+  private List<RaftServer> createServers(final int nodes) throws Exception {\n+    final List<RaftServer> servers = new ArrayList<>();\n+\n+    for (int i = 0; i < nodes; i++) {\n+      members.add(nextMember(RaftMember.Type.ACTIVE));\n+    }\n+\n+    final CountDownLatch latch = new CountDownLatch(nodes);\n+\n+    for (int i = 0; i < nodes; i++) {\n+      final RaftServer server = createServer(members.get(i).memberId());\n+      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n+        server\n+            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      } else {\n+        server\n+            .listen(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      }\n+      servers.add(server);\n+    }\n+\n+    latch.await(30 * nodes, TimeUnit.SECONDS);", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM5MjcwNw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r424392707", "bodyText": "\ud83e\udd37 this was the way it was used before", "author": "Zelldon", "createdAt": "2020-05-13T12:21:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzMjQ3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzMzg2Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423033866", "bodyText": "This method behaves strange, if members already has entries. Then new members would be added at the end, but the first entries would be used to create the servers.", "author": "pihme", "createdAt": "2020-05-11T13:21:17Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {\n+    return new RaftRule(-1);\n+  }\n+\n+  @Override\n+  public Statement apply(final Statement base, final Description description) {\n+    final var statement = super.apply(base, description);\n+    return temporaryFolder.apply(statement, description);\n+  }\n+\n+  @Override\n+  protected void before() throws Throwable {\n+    directory = temporaryFolder.newFolder().toPath();\n+\n+    position = 0;\n+    members = new ArrayList<>();\n+    memberLog = new ConcurrentHashMap<>();\n+    nextId = 0;\n+    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n+    protocolFactory = new TestRaftProtocolFactory(context);\n+\n+    if (nodeCount > 0) {\n+      createServers(nodeCount);\n+    }\n+  }\n+\n+  @Override\n+  protected void after() {\n+    servers.forEach(\n+        s -> {\n+          try {\n+            if (s.isRunning()) {\n+              s.shutdown().get(30, TimeUnit.SECONDS);\n+            }\n+          } catch (final Exception e) {\n+            // its fine..\n+          }\n+        });\n+    servers.clear();\n+    context.close();\n+    context = null;\n+    members.clear();\n+    nextId = 0;\n+    protocolFactory = null;\n+    highestCommit = 0;\n+    commitAwaiterRef.set(null);\n+    memberLog.clear();\n+    memberLog = null;\n+    position = 0;\n+  }\n+\n+  /**\n+   * Returns the next server address.\n+   *\n+   * @param type The startup member type.\n+   * @return The next server address.\n+   */\n+  private RaftMember nextMember(final RaftMember.Type type) {\n+    return new TestMember(nextNodeId(), type);\n+  }\n+\n+  /**\n+   * Returns the next unique member identifier.\n+   *\n+   * @return The next unique member identifier.\n+   */\n+  private MemberId nextNodeId() {\n+    return MemberId.from(String.valueOf(++nextId));\n+  }\n+\n+  /** Creates a set of Raft servers. */\n+  private List<RaftServer> createServers(final int nodes) throws Exception {", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzNjMxOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423036318", "bodyText": "Maybe call next method to avoid code dpulication", "author": "pihme", "createdAt": "2020-05-11T13:24:59Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {\n+    return new RaftRule(-1);\n+  }\n+\n+  @Override\n+  public Statement apply(final Statement base, final Description description) {\n+    final var statement = super.apply(base, description);\n+    return temporaryFolder.apply(statement, description);\n+  }\n+\n+  @Override\n+  protected void before() throws Throwable {\n+    directory = temporaryFolder.newFolder().toPath();\n+\n+    position = 0;\n+    members = new ArrayList<>();\n+    memberLog = new ConcurrentHashMap<>();\n+    nextId = 0;\n+    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n+    protocolFactory = new TestRaftProtocolFactory(context);\n+\n+    if (nodeCount > 0) {\n+      createServers(nodeCount);\n+    }\n+  }\n+\n+  @Override\n+  protected void after() {\n+    servers.forEach(\n+        s -> {\n+          try {\n+            if (s.isRunning()) {\n+              s.shutdown().get(30, TimeUnit.SECONDS);\n+            }\n+          } catch (final Exception e) {\n+            // its fine..\n+          }\n+        });\n+    servers.clear();\n+    context.close();\n+    context = null;\n+    members.clear();\n+    nextId = 0;\n+    protocolFactory = null;\n+    highestCommit = 0;\n+    commitAwaiterRef.set(null);\n+    memberLog.clear();\n+    memberLog = null;\n+    position = 0;\n+  }\n+\n+  /**\n+   * Returns the next server address.\n+   *\n+   * @param type The startup member type.\n+   * @return The next server address.\n+   */\n+  private RaftMember nextMember(final RaftMember.Type type) {\n+    return new TestMember(nextNodeId(), type);\n+  }\n+\n+  /**\n+   * Returns the next unique member identifier.\n+   *\n+   * @return The next unique member identifier.\n+   */\n+  private MemberId nextNodeId() {\n+    return MemberId.from(String.valueOf(++nextId));\n+  }\n+\n+  /** Creates a set of Raft servers. */\n+  private List<RaftServer> createServers(final int nodes) throws Exception {\n+    final List<RaftServer> servers = new ArrayList<>();\n+\n+    for (int i = 0; i < nodes; i++) {\n+      members.add(nextMember(RaftMember.Type.ACTIVE));\n+    }\n+\n+    final CountDownLatch latch = new CountDownLatch(nodes);\n+\n+    for (int i = 0; i < nodes; i++) {\n+      final RaftServer server = createServer(members.get(i).memberId());\n+      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n+        server\n+            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      } else {\n+        server\n+            .listen(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      }\n+      servers.add(server);\n+    }\n+\n+    latch.await(30 * nodes, TimeUnit.SECONDS);\n+\n+    return servers;\n+  }\n+\n+  public void shutdownFollower() throws Exception {\n+    final var follower = getFollower().orElseThrow();\n+    shutdownServer(follower);\n+  }\n+\n+  public RaftServer shutdownLeader() throws Exception {\n+    final var leader = getLeader().orElseThrow();\n+    shutdownServer(leader);\n+    return leader;\n+  }\n+\n+  public void restartLeader() throws Exception {\n+    awaitNewLeader();\n+    final var leader = shutdownLeader();\n+\n+    final RaftMember leaderMember = getRaftMember(leader.name());\n+    createServer(leaderMember.memberId())\n+        .join(getMemberIds())\n+        .thenAccept(this::addCommitListener)\n+        .get(30, TimeUnit.SECONDS);\n+  }\n+\n+  private List<MemberId> getMemberIds() {\n+    return members.stream().map(RaftMember::memberId).collect(Collectors.toList());\n+  }\n+\n+  public void shutdownServer(final String memberId) throws Exception {\n+    final var raftServer = getRaftServer(memberId);\n+    shutdownServer(raftServer);\n+  }\n+\n+  private RaftServer getRaftServer(final String memberId) {\n+    return servers.stream()\n+        .filter(server -> server.name().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public void shutdownServer(final RaftServer raftServer) throws Exception {\n+    raftServer.shutdown().get(30, TimeUnit.SECONDS);\n+    servers.remove(raftServer);\n+    memberLog.remove(raftServer.name());\n+  }\n+\n+  public CompletableFuture<RaftServer> startServer(final String memberId) {\n+    final RaftMember raftMember = getRaftMember(memberId);\n+    final var server = createServer(raftMember.memberId());\n+    return server.join(getMemberIds());\n+  }\n+\n+  private RaftMember getRaftMember(final String memberId) {\n+    return members.stream()\n+        .filter(member -> member.memberId().id().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogsOnServersExcept(\n+      final String memberId, final long index) {\n+\n+    final var servers =\n+        this.servers.stream()\n+            .filter(server -> !server.name().equals(memberId))\n+            .collect(Collectors.toList());\n+\n+    final List<CompletableFuture<Void>> futures = new ArrayList<>();\n+    for (final RaftServer server : servers) {\n+      futures.add(tryToCompactLogOnServer(server, index));\n+    }\n+\n+    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogOnServer(final String memberId, final long index) {", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzNzU2Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423037566", "bodyText": "getMemberLog->getMemberLogs()", "author": "pihme", "createdAt": "2020-05-11T13:26:47Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {\n+    return new RaftRule(-1);\n+  }\n+\n+  @Override\n+  public Statement apply(final Statement base, final Description description) {\n+    final var statement = super.apply(base, description);\n+    return temporaryFolder.apply(statement, description);\n+  }\n+\n+  @Override\n+  protected void before() throws Throwable {\n+    directory = temporaryFolder.newFolder().toPath();\n+\n+    position = 0;\n+    members = new ArrayList<>();\n+    memberLog = new ConcurrentHashMap<>();\n+    nextId = 0;\n+    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n+    protocolFactory = new TestRaftProtocolFactory(context);\n+\n+    if (nodeCount > 0) {\n+      createServers(nodeCount);\n+    }\n+  }\n+\n+  @Override\n+  protected void after() {\n+    servers.forEach(\n+        s -> {\n+          try {\n+            if (s.isRunning()) {\n+              s.shutdown().get(30, TimeUnit.SECONDS);\n+            }\n+          } catch (final Exception e) {\n+            // its fine..\n+          }\n+        });\n+    servers.clear();\n+    context.close();\n+    context = null;\n+    members.clear();\n+    nextId = 0;\n+    protocolFactory = null;\n+    highestCommit = 0;\n+    commitAwaiterRef.set(null);\n+    memberLog.clear();\n+    memberLog = null;\n+    position = 0;\n+  }\n+\n+  /**\n+   * Returns the next server address.\n+   *\n+   * @param type The startup member type.\n+   * @return The next server address.\n+   */\n+  private RaftMember nextMember(final RaftMember.Type type) {\n+    return new TestMember(nextNodeId(), type);\n+  }\n+\n+  /**\n+   * Returns the next unique member identifier.\n+   *\n+   * @return The next unique member identifier.\n+   */\n+  private MemberId nextNodeId() {\n+    return MemberId.from(String.valueOf(++nextId));\n+  }\n+\n+  /** Creates a set of Raft servers. */\n+  private List<RaftServer> createServers(final int nodes) throws Exception {\n+    final List<RaftServer> servers = new ArrayList<>();\n+\n+    for (int i = 0; i < nodes; i++) {\n+      members.add(nextMember(RaftMember.Type.ACTIVE));\n+    }\n+\n+    final CountDownLatch latch = new CountDownLatch(nodes);\n+\n+    for (int i = 0; i < nodes; i++) {\n+      final RaftServer server = createServer(members.get(i).memberId());\n+      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n+        server\n+            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      } else {\n+        server\n+            .listen(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      }\n+      servers.add(server);\n+    }\n+\n+    latch.await(30 * nodes, TimeUnit.SECONDS);\n+\n+    return servers;\n+  }\n+\n+  public void shutdownFollower() throws Exception {\n+    final var follower = getFollower().orElseThrow();\n+    shutdownServer(follower);\n+  }\n+\n+  public RaftServer shutdownLeader() throws Exception {\n+    final var leader = getLeader().orElseThrow();\n+    shutdownServer(leader);\n+    return leader;\n+  }\n+\n+  public void restartLeader() throws Exception {\n+    awaitNewLeader();\n+    final var leader = shutdownLeader();\n+\n+    final RaftMember leaderMember = getRaftMember(leader.name());\n+    createServer(leaderMember.memberId())\n+        .join(getMemberIds())\n+        .thenAccept(this::addCommitListener)\n+        .get(30, TimeUnit.SECONDS);\n+  }\n+\n+  private List<MemberId> getMemberIds() {\n+    return members.stream().map(RaftMember::memberId).collect(Collectors.toList());\n+  }\n+\n+  public void shutdownServer(final String memberId) throws Exception {\n+    final var raftServer = getRaftServer(memberId);\n+    shutdownServer(raftServer);\n+  }\n+\n+  private RaftServer getRaftServer(final String memberId) {\n+    return servers.stream()\n+        .filter(server -> server.name().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public void shutdownServer(final RaftServer raftServer) throws Exception {\n+    raftServer.shutdown().get(30, TimeUnit.SECONDS);\n+    servers.remove(raftServer);\n+    memberLog.remove(raftServer.name());\n+  }\n+\n+  public CompletableFuture<RaftServer> startServer(final String memberId) {\n+    final RaftMember raftMember = getRaftMember(memberId);\n+    final var server = createServer(raftMember.memberId());\n+    return server.join(getMemberIds());\n+  }\n+\n+  private RaftMember getRaftMember(final String memberId) {\n+    return members.stream()\n+        .filter(member -> member.memberId().id().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogsOnServersExcept(\n+      final String memberId, final long index) {\n+\n+    final var servers =\n+        this.servers.stream()\n+            .filter(server -> !server.name().equals(memberId))\n+            .collect(Collectors.toList());\n+\n+    final List<CompletableFuture<Void>> futures = new ArrayList<>();\n+    for (final RaftServer server : servers) {\n+      futures.add(tryToCompactLogOnServer(server, index));\n+    }\n+\n+    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogOnServer(final String memberId, final long index) {\n+    final var raftServer = getRaftServer(memberId);\n+    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n+    return raftServer.compact();\n+  }\n+\n+  private CompletableFuture<Void> tryToCompactLogOnServer(\n+      final RaftServer raftServer, final long index) {\n+    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n+    return raftServer.compact();\n+  }\n+\n+  public void awaitNewLeader() {\n+    waitUntil(() -> getLeader().isPresent(), 100);\n+  }\n+\n+  private void addCommitListener(final RaftServer raftServer) {\n+    raftServer\n+        .getContext()\n+        .addCommitListener(\n+            new RaftCommitListener() {\n+              @Override\n+              public <T extends RaftLogEntry> void onCommit(final Indexed<T> entry) {\n+                final var index = entry.index();\n+\n+                memberLog.put(raftServer.name(), index);\n+                if (highestCommit < index) {\n+                  highestCommit = index;\n+                }\n+\n+                final var commitAwaiter = commitAwaiterRef.get();\n+                if (commitAwaiter != null && commitAwaiter.reachedCommit(index)) {\n+                  commitAwaiterRef.set(null);\n+                }\n+              }\n+            });\n+  }\n+\n+  public Map<String, List<Indexed<?>>> getMemberLog() {", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzOTQwMw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423039403", "bodyText": "Function<Builder, Builder> -> UnaryOperator<Builder>", "author": "pihme", "createdAt": "2020-05-11T13:29:33Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {\n+    return new RaftRule(-1);\n+  }\n+\n+  @Override\n+  public Statement apply(final Statement base, final Description description) {\n+    final var statement = super.apply(base, description);\n+    return temporaryFolder.apply(statement, description);\n+  }\n+\n+  @Override\n+  protected void before() throws Throwable {\n+    directory = temporaryFolder.newFolder().toPath();\n+\n+    position = 0;\n+    members = new ArrayList<>();\n+    memberLog = new ConcurrentHashMap<>();\n+    nextId = 0;\n+    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n+    protocolFactory = new TestRaftProtocolFactory(context);\n+\n+    if (nodeCount > 0) {\n+      createServers(nodeCount);\n+    }\n+  }\n+\n+  @Override\n+  protected void after() {\n+    servers.forEach(\n+        s -> {\n+          try {\n+            if (s.isRunning()) {\n+              s.shutdown().get(30, TimeUnit.SECONDS);\n+            }\n+          } catch (final Exception e) {\n+            // its fine..\n+          }\n+        });\n+    servers.clear();\n+    context.close();\n+    context = null;\n+    members.clear();\n+    nextId = 0;\n+    protocolFactory = null;\n+    highestCommit = 0;\n+    commitAwaiterRef.set(null);\n+    memberLog.clear();\n+    memberLog = null;\n+    position = 0;\n+  }\n+\n+  /**\n+   * Returns the next server address.\n+   *\n+   * @param type The startup member type.\n+   * @return The next server address.\n+   */\n+  private RaftMember nextMember(final RaftMember.Type type) {\n+    return new TestMember(nextNodeId(), type);\n+  }\n+\n+  /**\n+   * Returns the next unique member identifier.\n+   *\n+   * @return The next unique member identifier.\n+   */\n+  private MemberId nextNodeId() {\n+    return MemberId.from(String.valueOf(++nextId));\n+  }\n+\n+  /** Creates a set of Raft servers. */\n+  private List<RaftServer> createServers(final int nodes) throws Exception {\n+    final List<RaftServer> servers = new ArrayList<>();\n+\n+    for (int i = 0; i < nodes; i++) {\n+      members.add(nextMember(RaftMember.Type.ACTIVE));\n+    }\n+\n+    final CountDownLatch latch = new CountDownLatch(nodes);\n+\n+    for (int i = 0; i < nodes; i++) {\n+      final RaftServer server = createServer(members.get(i).memberId());\n+      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n+        server\n+            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      } else {\n+        server\n+            .listen(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      }\n+      servers.add(server);\n+    }\n+\n+    latch.await(30 * nodes, TimeUnit.SECONDS);\n+\n+    return servers;\n+  }\n+\n+  public void shutdownFollower() throws Exception {\n+    final var follower = getFollower().orElseThrow();\n+    shutdownServer(follower);\n+  }\n+\n+  public RaftServer shutdownLeader() throws Exception {\n+    final var leader = getLeader().orElseThrow();\n+    shutdownServer(leader);\n+    return leader;\n+  }\n+\n+  public void restartLeader() throws Exception {\n+    awaitNewLeader();\n+    final var leader = shutdownLeader();\n+\n+    final RaftMember leaderMember = getRaftMember(leader.name());\n+    createServer(leaderMember.memberId())\n+        .join(getMemberIds())\n+        .thenAccept(this::addCommitListener)\n+        .get(30, TimeUnit.SECONDS);\n+  }\n+\n+  private List<MemberId> getMemberIds() {\n+    return members.stream().map(RaftMember::memberId).collect(Collectors.toList());\n+  }\n+\n+  public void shutdownServer(final String memberId) throws Exception {\n+    final var raftServer = getRaftServer(memberId);\n+    shutdownServer(raftServer);\n+  }\n+\n+  private RaftServer getRaftServer(final String memberId) {\n+    return servers.stream()\n+        .filter(server -> server.name().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public void shutdownServer(final RaftServer raftServer) throws Exception {\n+    raftServer.shutdown().get(30, TimeUnit.SECONDS);\n+    servers.remove(raftServer);\n+    memberLog.remove(raftServer.name());\n+  }\n+\n+  public CompletableFuture<RaftServer> startServer(final String memberId) {\n+    final RaftMember raftMember = getRaftMember(memberId);\n+    final var server = createServer(raftMember.memberId());\n+    return server.join(getMemberIds());\n+  }\n+\n+  private RaftMember getRaftMember(final String memberId) {\n+    return members.stream()\n+        .filter(member -> member.memberId().id().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogsOnServersExcept(\n+      final String memberId, final long index) {\n+\n+    final var servers =\n+        this.servers.stream()\n+            .filter(server -> !server.name().equals(memberId))\n+            .collect(Collectors.toList());\n+\n+    final List<CompletableFuture<Void>> futures = new ArrayList<>();\n+    for (final RaftServer server : servers) {\n+      futures.add(tryToCompactLogOnServer(server, index));\n+    }\n+\n+    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogOnServer(final String memberId, final long index) {\n+    final var raftServer = getRaftServer(memberId);\n+    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n+    return raftServer.compact();\n+  }\n+\n+  private CompletableFuture<Void> tryToCompactLogOnServer(\n+      final RaftServer raftServer, final long index) {\n+    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n+    return raftServer.compact();\n+  }\n+\n+  public void awaitNewLeader() {\n+    waitUntil(() -> getLeader().isPresent(), 100);\n+  }\n+\n+  private void addCommitListener(final RaftServer raftServer) {\n+    raftServer\n+        .getContext()\n+        .addCommitListener(\n+            new RaftCommitListener() {\n+              @Override\n+              public <T extends RaftLogEntry> void onCommit(final Indexed<T> entry) {\n+                final var index = entry.index();\n+\n+                memberLog.put(raftServer.name(), index);\n+                if (highestCommit < index) {\n+                  highestCommit = index;\n+                }\n+\n+                final var commitAwaiter = commitAwaiterRef.get();\n+                if (commitAwaiter != null && commitAwaiter.reachedCommit(index)) {\n+                  commitAwaiterRef.set(null);\n+                }\n+              }\n+            });\n+  }\n+\n+  public Map<String, List<Indexed<?>>> getMemberLog() {\n+\n+    final Map<String, List<Indexed<?>>> memberLogs = new HashMap<>();\n+\n+    for (final var server : servers) {\n+      if (server.isRunning()) {\n+\n+        final var log = server.getContext().getLog();\n+        final List<Indexed<?>> entryList = new ArrayList<>();\n+        try (final var raftLogReader = log.openReader(1, Mode.ALL)) {\n+\n+          while (raftLogReader.hasNext()) {\n+            final var indexedEntry = raftLogReader.next();\n+            entryList.add(indexedEntry);\n+          }\n+        }\n+\n+        memberLogs.put(server.name(), entryList);\n+      }\n+    }\n+\n+    return memberLogs;\n+  }\n+\n+  public void awaitSameLogSizeOnAllNodes() {\n+    waitUntil(\n+        () -> memberLog.values().stream().distinct().count() == 1, () -> memberLog.toString());\n+  }\n+\n+  private void waitUntil(final BooleanSupplier condition, final Supplier<String> errorMessage) {\n+    waitUntil(condition, 100, errorMessage);\n+  }\n+\n+  private void waitUntil(final BooleanSupplier condition, final int retries) {\n+    waitUntil(condition, retries, () -> null);\n+  }\n+\n+  private void waitUntil(\n+      final BooleanSupplier condition, int retries, final Supplier<String> errorMessage) {\n+    try {\n+      while (!condition.getAsBoolean() && retries > 0) {\n+        Thread.sleep(100);\n+        retries--;\n+      }\n+    } catch (final Exception e) {\n+      throw new RuntimeException(e);\n+    }\n+\n+    assertTrue(errorMessage.get(), condition.getAsBoolean());\n+  }\n+\n+  public void awaitCommit(final long commitIndex) throws Exception {\n+    if (highestCommit >= commitIndex) {\n+      return;\n+    }\n+\n+    final var commitAwaiter = new CommitAwaiter(commitIndex);\n+    commitAwaiterRef.set(commitAwaiter);\n+\n+    commitAwaiter.awaitCommit();\n+  }\n+\n+  /** Creates a Raft server. */\n+  private RaftServer createServer(final MemberId memberId) {\n+    return createServer(memberId, b -> b.withStorage(createStorage(memberId)));\n+  }\n+\n+  private RaftServer createServer(\n+      final MemberId memberId, final Function<Builder, Builder> configurator) {", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA0NjAzNA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423046034", "bodyText": "Don't understand this class at all. Has nothing to do with commits. It's just an index comparator. Might make more sense if this class were a RaftCommitListener itself\nEven then the implementation won't work, if the index I am waiting for has already bean reached when the class is constructed, and there are no more commits which trigger the commit listener, and the reachedCommit()method.", "author": "pihme", "createdAt": "2020-05-11T13:39:09Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {\n+    return new RaftRule(-1);\n+  }\n+\n+  @Override\n+  public Statement apply(final Statement base, final Description description) {\n+    final var statement = super.apply(base, description);\n+    return temporaryFolder.apply(statement, description);\n+  }\n+\n+  @Override\n+  protected void before() throws Throwable {\n+    directory = temporaryFolder.newFolder().toPath();\n+\n+    position = 0;\n+    members = new ArrayList<>();\n+    memberLog = new ConcurrentHashMap<>();\n+    nextId = 0;\n+    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n+    protocolFactory = new TestRaftProtocolFactory(context);\n+\n+    if (nodeCount > 0) {\n+      createServers(nodeCount);\n+    }\n+  }\n+\n+  @Override\n+  protected void after() {\n+    servers.forEach(\n+        s -> {\n+          try {\n+            if (s.isRunning()) {\n+              s.shutdown().get(30, TimeUnit.SECONDS);\n+            }\n+          } catch (final Exception e) {\n+            // its fine..\n+          }\n+        });\n+    servers.clear();\n+    context.close();\n+    context = null;\n+    members.clear();\n+    nextId = 0;\n+    protocolFactory = null;\n+    highestCommit = 0;\n+    commitAwaiterRef.set(null);\n+    memberLog.clear();\n+    memberLog = null;\n+    position = 0;\n+  }\n+\n+  /**\n+   * Returns the next server address.\n+   *\n+   * @param type The startup member type.\n+   * @return The next server address.\n+   */\n+  private RaftMember nextMember(final RaftMember.Type type) {\n+    return new TestMember(nextNodeId(), type);\n+  }\n+\n+  /**\n+   * Returns the next unique member identifier.\n+   *\n+   * @return The next unique member identifier.\n+   */\n+  private MemberId nextNodeId() {\n+    return MemberId.from(String.valueOf(++nextId));\n+  }\n+\n+  /** Creates a set of Raft servers. */\n+  private List<RaftServer> createServers(final int nodes) throws Exception {\n+    final List<RaftServer> servers = new ArrayList<>();\n+\n+    for (int i = 0; i < nodes; i++) {\n+      members.add(nextMember(RaftMember.Type.ACTIVE));\n+    }\n+\n+    final CountDownLatch latch = new CountDownLatch(nodes);\n+\n+    for (int i = 0; i < nodes; i++) {\n+      final RaftServer server = createServer(members.get(i).memberId());\n+      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n+        server\n+            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      } else {\n+        server\n+            .listen(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      }\n+      servers.add(server);\n+    }\n+\n+    latch.await(30 * nodes, TimeUnit.SECONDS);\n+\n+    return servers;\n+  }\n+\n+  public void shutdownFollower() throws Exception {\n+    final var follower = getFollower().orElseThrow();\n+    shutdownServer(follower);\n+  }\n+\n+  public RaftServer shutdownLeader() throws Exception {\n+    final var leader = getLeader().orElseThrow();\n+    shutdownServer(leader);\n+    return leader;\n+  }\n+\n+  public void restartLeader() throws Exception {\n+    awaitNewLeader();\n+    final var leader = shutdownLeader();\n+\n+    final RaftMember leaderMember = getRaftMember(leader.name());\n+    createServer(leaderMember.memberId())\n+        .join(getMemberIds())\n+        .thenAccept(this::addCommitListener)\n+        .get(30, TimeUnit.SECONDS);\n+  }\n+\n+  private List<MemberId> getMemberIds() {\n+    return members.stream().map(RaftMember::memberId).collect(Collectors.toList());\n+  }\n+\n+  public void shutdownServer(final String memberId) throws Exception {\n+    final var raftServer = getRaftServer(memberId);\n+    shutdownServer(raftServer);\n+  }\n+\n+  private RaftServer getRaftServer(final String memberId) {\n+    return servers.stream()\n+        .filter(server -> server.name().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public void shutdownServer(final RaftServer raftServer) throws Exception {\n+    raftServer.shutdown().get(30, TimeUnit.SECONDS);\n+    servers.remove(raftServer);\n+    memberLog.remove(raftServer.name());\n+  }\n+\n+  public CompletableFuture<RaftServer> startServer(final String memberId) {\n+    final RaftMember raftMember = getRaftMember(memberId);\n+    final var server = createServer(raftMember.memberId());\n+    return server.join(getMemberIds());\n+  }\n+\n+  private RaftMember getRaftMember(final String memberId) {\n+    return members.stream()\n+        .filter(member -> member.memberId().id().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogsOnServersExcept(\n+      final String memberId, final long index) {\n+\n+    final var servers =\n+        this.servers.stream()\n+            .filter(server -> !server.name().equals(memberId))\n+            .collect(Collectors.toList());\n+\n+    final List<CompletableFuture<Void>> futures = new ArrayList<>();\n+    for (final RaftServer server : servers) {\n+      futures.add(tryToCompactLogOnServer(server, index));\n+    }\n+\n+    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogOnServer(final String memberId, final long index) {\n+    final var raftServer = getRaftServer(memberId);\n+    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n+    return raftServer.compact();\n+  }\n+\n+  private CompletableFuture<Void> tryToCompactLogOnServer(\n+      final RaftServer raftServer, final long index) {\n+    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n+    return raftServer.compact();\n+  }\n+\n+  public void awaitNewLeader() {\n+    waitUntil(() -> getLeader().isPresent(), 100);\n+  }\n+\n+  private void addCommitListener(final RaftServer raftServer) {\n+    raftServer\n+        .getContext()\n+        .addCommitListener(\n+            new RaftCommitListener() {\n+              @Override\n+              public <T extends RaftLogEntry> void onCommit(final Indexed<T> entry) {\n+                final var index = entry.index();\n+\n+                memberLog.put(raftServer.name(), index);\n+                if (highestCommit < index) {\n+                  highestCommit = index;\n+                }\n+\n+                final var commitAwaiter = commitAwaiterRef.get();\n+                if (commitAwaiter != null && commitAwaiter.reachedCommit(index)) {\n+                  commitAwaiterRef.set(null);\n+                }\n+              }\n+            });\n+  }\n+\n+  public Map<String, List<Indexed<?>>> getMemberLog() {\n+\n+    final Map<String, List<Indexed<?>>> memberLogs = new HashMap<>();\n+\n+    for (final var server : servers) {\n+      if (server.isRunning()) {\n+\n+        final var log = server.getContext().getLog();\n+        final List<Indexed<?>> entryList = new ArrayList<>();\n+        try (final var raftLogReader = log.openReader(1, Mode.ALL)) {\n+\n+          while (raftLogReader.hasNext()) {\n+            final var indexedEntry = raftLogReader.next();\n+            entryList.add(indexedEntry);\n+          }\n+        }\n+\n+        memberLogs.put(server.name(), entryList);\n+      }\n+    }\n+\n+    return memberLogs;\n+  }\n+\n+  public void awaitSameLogSizeOnAllNodes() {\n+    waitUntil(\n+        () -> memberLog.values().stream().distinct().count() == 1, () -> memberLog.toString());\n+  }\n+\n+  private void waitUntil(final BooleanSupplier condition, final Supplier<String> errorMessage) {\n+    waitUntil(condition, 100, errorMessage);\n+  }\n+\n+  private void waitUntil(final BooleanSupplier condition, final int retries) {\n+    waitUntil(condition, retries, () -> null);\n+  }\n+\n+  private void waitUntil(\n+      final BooleanSupplier condition, int retries, final Supplier<String> errorMessage) {\n+    try {\n+      while (!condition.getAsBoolean() && retries > 0) {\n+        Thread.sleep(100);\n+        retries--;\n+      }\n+    } catch (final Exception e) {\n+      throw new RuntimeException(e);\n+    }\n+\n+    assertTrue(errorMessage.get(), condition.getAsBoolean());\n+  }\n+\n+  public void awaitCommit(final long commitIndex) throws Exception {\n+    if (highestCommit >= commitIndex) {\n+      return;\n+    }\n+\n+    final var commitAwaiter = new CommitAwaiter(commitIndex);\n+    commitAwaiterRef.set(commitAwaiter);\n+\n+    commitAwaiter.awaitCommit();\n+  }\n+\n+  /** Creates a Raft server. */\n+  private RaftServer createServer(final MemberId memberId) {\n+    return createServer(memberId, b -> b.withStorage(createStorage(memberId)));\n+  }\n+\n+  private RaftServer createServer(\n+      final MemberId memberId, final Function<Builder, Builder> configurator) {\n+    final TestRaftServerProtocol protocol = protocolFactory.newServerProtocol(memberId);\n+    final RaftServer.Builder defaults =\n+        RaftServer.builder(memberId)\n+            .withMembershipService(mock(ClusterMembershipService.class))\n+            .withProtocol(protocol);\n+    final RaftServer server = configurator.apply(defaults).build();\n+\n+    servers.add(server);\n+    return server;\n+  }\n+\n+  private RaftStorage createStorage(final MemberId memberId) {\n+    return createStorage(memberId, Function.identity());\n+  }\n+\n+  private RaftStorage createStorage(\n+      final MemberId memberId,\n+      final Function<RaftStorage.Builder, RaftStorage.Builder> configurator) {\n+    final RaftStorage.Builder defaults =\n+        RaftStorage.builder()\n+            .withStorageLevel(StorageLevel.DISK)\n+            .withDirectory(new File(directory.toFile(), memberId.toString()))\n+            .withMaxEntriesPerSegment(10)\n+            .withMaxSegmentSize(1024 * 10)\n+            .withNamespace(RaftNamespaces.RAFT_STORAGE);\n+    return configurator.apply(defaults).build();\n+  }\n+\n+  private Optional<RaftServer> getLeader() {\n+    return servers.stream().filter(s -> s.getRole() == Role.LEADER).findFirst();\n+  }\n+\n+  private Optional<RaftServer> getFollower() {\n+    return servers.stream().filter(s -> s.getRole() == Role.FOLLOWER).findFirst();\n+  }\n+\n+  public void appendEntries(final int count) {\n+    final var leader = getLeader().orElseThrow();\n+\n+    for (int i = 0; i < count; i++) {\n+      appendEntryAsync(leader, 1024);\n+    }\n+  }\n+\n+  public long appendEntry() throws Exception {\n+    final var leader = getLeader().orElseThrow();\n+\n+    return appendEntry(leader, 1024);\n+  }\n+\n+  private long appendEntry(final RaftServer leader, final int entrySize) throws Exception {\n+    final var raftRole = leader.getContext().getRaftRole();\n+    if (raftRole instanceof LeaderRole) {\n+      final var testAppendListener = appendEntry(entrySize, (LeaderRole) raftRole);\n+      return testAppendListener.awaitCommit();\n+    }\n+    throw new IllegalArgumentException(\n+        \"Expected to append entry on leader, \"\n+            + leader.getContext().getName()\n+            + \" was not the leader!\");\n+  }\n+\n+  private void appendEntryAsync(final RaftServer leader, final int entrySize) {\n+    final var raftRole = leader.getContext().getRaftRole();\n+\n+    if (raftRole instanceof LeaderRole) {\n+      appendEntry(entrySize, (LeaderRole) raftRole);\n+      return;\n+    }\n+\n+    throw new IllegalArgumentException(\n+        \"Expected to append entry on leader, \"\n+            + leader.getContext().getName()\n+            + \" was not the leader!\");\n+  }\n+\n+  private TestAppendListener appendEntry(final int entrySize, final LeaderRole leaderRole) {\n+    final var appendListener = new TestAppendListener();\n+    position += 1;\n+    leaderRole.appendEntry(\n+        position,\n+        position + 10,\n+        ByteBuffer.wrap(RandomStringUtils.random(entrySize).getBytes()),\n+        appendListener);\n+    position += 10;\n+    return appendListener;\n+  }\n+\n+  public void awaitAppendEntries(final int i) throws Exception {\n+    // this call is async\n+    appendEntries(i - 1);\n+\n+    // this awaits the last append\n+    appendEntry();\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"RaftRule with \" + nodeCount + \" nodes.\";\n+  }\n+\n+  private static final class CommitAwaiter {", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA0Njk3Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423046977", "bodyText": "rename to reachedCommit(final long currentIndex) The way it is now it is confusing", "author": "pihme", "createdAt": "2020-05-11T13:40:35Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {\n+    return new RaftRule(-1);\n+  }\n+\n+  @Override\n+  public Statement apply(final Statement base, final Description description) {\n+    final var statement = super.apply(base, description);\n+    return temporaryFolder.apply(statement, description);\n+  }\n+\n+  @Override\n+  protected void before() throws Throwable {\n+    directory = temporaryFolder.newFolder().toPath();\n+\n+    position = 0;\n+    members = new ArrayList<>();\n+    memberLog = new ConcurrentHashMap<>();\n+    nextId = 0;\n+    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n+    protocolFactory = new TestRaftProtocolFactory(context);\n+\n+    if (nodeCount > 0) {\n+      createServers(nodeCount);\n+    }\n+  }\n+\n+  @Override\n+  protected void after() {\n+    servers.forEach(\n+        s -> {\n+          try {\n+            if (s.isRunning()) {\n+              s.shutdown().get(30, TimeUnit.SECONDS);\n+            }\n+          } catch (final Exception e) {\n+            // its fine..\n+          }\n+        });\n+    servers.clear();\n+    context.close();\n+    context = null;\n+    members.clear();\n+    nextId = 0;\n+    protocolFactory = null;\n+    highestCommit = 0;\n+    commitAwaiterRef.set(null);\n+    memberLog.clear();\n+    memberLog = null;\n+    position = 0;\n+  }\n+\n+  /**\n+   * Returns the next server address.\n+   *\n+   * @param type The startup member type.\n+   * @return The next server address.\n+   */\n+  private RaftMember nextMember(final RaftMember.Type type) {\n+    return new TestMember(nextNodeId(), type);\n+  }\n+\n+  /**\n+   * Returns the next unique member identifier.\n+   *\n+   * @return The next unique member identifier.\n+   */\n+  private MemberId nextNodeId() {\n+    return MemberId.from(String.valueOf(++nextId));\n+  }\n+\n+  /** Creates a set of Raft servers. */\n+  private List<RaftServer> createServers(final int nodes) throws Exception {\n+    final List<RaftServer> servers = new ArrayList<>();\n+\n+    for (int i = 0; i < nodes; i++) {\n+      members.add(nextMember(RaftMember.Type.ACTIVE));\n+    }\n+\n+    final CountDownLatch latch = new CountDownLatch(nodes);\n+\n+    for (int i = 0; i < nodes; i++) {\n+      final RaftServer server = createServer(members.get(i).memberId());\n+      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n+        server\n+            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      } else {\n+        server\n+            .listen(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      }\n+      servers.add(server);\n+    }\n+\n+    latch.await(30 * nodes, TimeUnit.SECONDS);\n+\n+    return servers;\n+  }\n+\n+  public void shutdownFollower() throws Exception {\n+    final var follower = getFollower().orElseThrow();\n+    shutdownServer(follower);\n+  }\n+\n+  public RaftServer shutdownLeader() throws Exception {\n+    final var leader = getLeader().orElseThrow();\n+    shutdownServer(leader);\n+    return leader;\n+  }\n+\n+  public void restartLeader() throws Exception {\n+    awaitNewLeader();\n+    final var leader = shutdownLeader();\n+\n+    final RaftMember leaderMember = getRaftMember(leader.name());\n+    createServer(leaderMember.memberId())\n+        .join(getMemberIds())\n+        .thenAccept(this::addCommitListener)\n+        .get(30, TimeUnit.SECONDS);\n+  }\n+\n+  private List<MemberId> getMemberIds() {\n+    return members.stream().map(RaftMember::memberId).collect(Collectors.toList());\n+  }\n+\n+  public void shutdownServer(final String memberId) throws Exception {\n+    final var raftServer = getRaftServer(memberId);\n+    shutdownServer(raftServer);\n+  }\n+\n+  private RaftServer getRaftServer(final String memberId) {\n+    return servers.stream()\n+        .filter(server -> server.name().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public void shutdownServer(final RaftServer raftServer) throws Exception {\n+    raftServer.shutdown().get(30, TimeUnit.SECONDS);\n+    servers.remove(raftServer);\n+    memberLog.remove(raftServer.name());\n+  }\n+\n+  public CompletableFuture<RaftServer> startServer(final String memberId) {\n+    final RaftMember raftMember = getRaftMember(memberId);\n+    final var server = createServer(raftMember.memberId());\n+    return server.join(getMemberIds());\n+  }\n+\n+  private RaftMember getRaftMember(final String memberId) {\n+    return members.stream()\n+        .filter(member -> member.memberId().id().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogsOnServersExcept(\n+      final String memberId, final long index) {\n+\n+    final var servers =\n+        this.servers.stream()\n+            .filter(server -> !server.name().equals(memberId))\n+            .collect(Collectors.toList());\n+\n+    final List<CompletableFuture<Void>> futures = new ArrayList<>();\n+    for (final RaftServer server : servers) {\n+      futures.add(tryToCompactLogOnServer(server, index));\n+    }\n+\n+    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogOnServer(final String memberId, final long index) {\n+    final var raftServer = getRaftServer(memberId);\n+    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n+    return raftServer.compact();\n+  }\n+\n+  private CompletableFuture<Void> tryToCompactLogOnServer(\n+      final RaftServer raftServer, final long index) {\n+    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n+    return raftServer.compact();\n+  }\n+\n+  public void awaitNewLeader() {\n+    waitUntil(() -> getLeader().isPresent(), 100);\n+  }\n+\n+  private void addCommitListener(final RaftServer raftServer) {\n+    raftServer\n+        .getContext()\n+        .addCommitListener(\n+            new RaftCommitListener() {\n+              @Override\n+              public <T extends RaftLogEntry> void onCommit(final Indexed<T> entry) {\n+                final var index = entry.index();\n+\n+                memberLog.put(raftServer.name(), index);\n+                if (highestCommit < index) {\n+                  highestCommit = index;\n+                }\n+\n+                final var commitAwaiter = commitAwaiterRef.get();\n+                if (commitAwaiter != null && commitAwaiter.reachedCommit(index)) {\n+                  commitAwaiterRef.set(null);\n+                }\n+              }\n+            });\n+  }\n+\n+  public Map<String, List<Indexed<?>>> getMemberLog() {\n+\n+    final Map<String, List<Indexed<?>>> memberLogs = new HashMap<>();\n+\n+    for (final var server : servers) {\n+      if (server.isRunning()) {\n+\n+        final var log = server.getContext().getLog();\n+        final List<Indexed<?>> entryList = new ArrayList<>();\n+        try (final var raftLogReader = log.openReader(1, Mode.ALL)) {\n+\n+          while (raftLogReader.hasNext()) {\n+            final var indexedEntry = raftLogReader.next();\n+            entryList.add(indexedEntry);\n+          }\n+        }\n+\n+        memberLogs.put(server.name(), entryList);\n+      }\n+    }\n+\n+    return memberLogs;\n+  }\n+\n+  public void awaitSameLogSizeOnAllNodes() {\n+    waitUntil(\n+        () -> memberLog.values().stream().distinct().count() == 1, () -> memberLog.toString());\n+  }\n+\n+  private void waitUntil(final BooleanSupplier condition, final Supplier<String> errorMessage) {\n+    waitUntil(condition, 100, errorMessage);\n+  }\n+\n+  private void waitUntil(final BooleanSupplier condition, final int retries) {\n+    waitUntil(condition, retries, () -> null);\n+  }\n+\n+  private void waitUntil(\n+      final BooleanSupplier condition, int retries, final Supplier<String> errorMessage) {\n+    try {\n+      while (!condition.getAsBoolean() && retries > 0) {\n+        Thread.sleep(100);\n+        retries--;\n+      }\n+    } catch (final Exception e) {\n+      throw new RuntimeException(e);\n+    }\n+\n+    assertTrue(errorMessage.get(), condition.getAsBoolean());\n+  }\n+\n+  public void awaitCommit(final long commitIndex) throws Exception {\n+    if (highestCommit >= commitIndex) {\n+      return;\n+    }\n+\n+    final var commitAwaiter = new CommitAwaiter(commitIndex);\n+    commitAwaiterRef.set(commitAwaiter);\n+\n+    commitAwaiter.awaitCommit();\n+  }\n+\n+  /** Creates a Raft server. */\n+  private RaftServer createServer(final MemberId memberId) {\n+    return createServer(memberId, b -> b.withStorage(createStorage(memberId)));\n+  }\n+\n+  private RaftServer createServer(\n+      final MemberId memberId, final Function<Builder, Builder> configurator) {\n+    final TestRaftServerProtocol protocol = protocolFactory.newServerProtocol(memberId);\n+    final RaftServer.Builder defaults =\n+        RaftServer.builder(memberId)\n+            .withMembershipService(mock(ClusterMembershipService.class))\n+            .withProtocol(protocol);\n+    final RaftServer server = configurator.apply(defaults).build();\n+\n+    servers.add(server);\n+    return server;\n+  }\n+\n+  private RaftStorage createStorage(final MemberId memberId) {\n+    return createStorage(memberId, Function.identity());\n+  }\n+\n+  private RaftStorage createStorage(\n+      final MemberId memberId,\n+      final Function<RaftStorage.Builder, RaftStorage.Builder> configurator) {\n+    final RaftStorage.Builder defaults =\n+        RaftStorage.builder()\n+            .withStorageLevel(StorageLevel.DISK)\n+            .withDirectory(new File(directory.toFile(), memberId.toString()))\n+            .withMaxEntriesPerSegment(10)\n+            .withMaxSegmentSize(1024 * 10)\n+            .withNamespace(RaftNamespaces.RAFT_STORAGE);\n+    return configurator.apply(defaults).build();\n+  }\n+\n+  private Optional<RaftServer> getLeader() {\n+    return servers.stream().filter(s -> s.getRole() == Role.LEADER).findFirst();\n+  }\n+\n+  private Optional<RaftServer> getFollower() {\n+    return servers.stream().filter(s -> s.getRole() == Role.FOLLOWER).findFirst();\n+  }\n+\n+  public void appendEntries(final int count) {\n+    final var leader = getLeader().orElseThrow();\n+\n+    for (int i = 0; i < count; i++) {\n+      appendEntryAsync(leader, 1024);\n+    }\n+  }\n+\n+  public long appendEntry() throws Exception {\n+    final var leader = getLeader().orElseThrow();\n+\n+    return appendEntry(leader, 1024);\n+  }\n+\n+  private long appendEntry(final RaftServer leader, final int entrySize) throws Exception {\n+    final var raftRole = leader.getContext().getRaftRole();\n+    if (raftRole instanceof LeaderRole) {\n+      final var testAppendListener = appendEntry(entrySize, (LeaderRole) raftRole);\n+      return testAppendListener.awaitCommit();\n+    }\n+    throw new IllegalArgumentException(\n+        \"Expected to append entry on leader, \"\n+            + leader.getContext().getName()\n+            + \" was not the leader!\");\n+  }\n+\n+  private void appendEntryAsync(final RaftServer leader, final int entrySize) {\n+    final var raftRole = leader.getContext().getRaftRole();\n+\n+    if (raftRole instanceof LeaderRole) {\n+      appendEntry(entrySize, (LeaderRole) raftRole);\n+      return;\n+    }\n+\n+    throw new IllegalArgumentException(\n+        \"Expected to append entry on leader, \"\n+            + leader.getContext().getName()\n+            + \" was not the leader!\");\n+  }\n+\n+  private TestAppendListener appendEntry(final int entrySize, final LeaderRole leaderRole) {\n+    final var appendListener = new TestAppendListener();\n+    position += 1;\n+    leaderRole.appendEntry(\n+        position,\n+        position + 10,\n+        ByteBuffer.wrap(RandomStringUtils.random(entrySize).getBytes()),\n+        appendListener);\n+    position += 10;\n+    return appendListener;\n+  }\n+\n+  public void awaitAppendEntries(final int i) throws Exception {\n+    // this call is async\n+    appendEntries(i - 1);\n+\n+    // this awaits the last append\n+    appendEntry();\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"RaftRule with \" + nodeCount + \" nodes.\";\n+  }\n+\n+  private static final class CommitAwaiter {\n+\n+    private final long awaitedIndex;\n+    private final CountDownLatch latch = new CountDownLatch(1);\n+\n+    public CommitAwaiter(final long index) {\n+      this.awaitedIndex = index;\n+    }\n+\n+    public boolean reachedCommit(final long index) {", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjgxODE3OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r422818178", "bodyText": "We probably don't need this anymore. It was used by the clients, right?", "author": "deepthidevaki", "createdAt": "2020-05-11T06:49:56Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/MultiRaftProtocol.java", "diffHunk": "@@ -18,19 +18,8 @@\n \n import static com.google.common.base.Preconditions.checkNotNull;\n \n-import io.atomix.primitive.PrimitiveType;\n-import io.atomix.primitive.partition.PartitionGroup;\n-import io.atomix.primitive.partition.PartitionService;\n import io.atomix.primitive.protocol.PrimitiveProtocol;\n import io.atomix.primitive.protocol.ProxyProtocol;\n-import io.atomix.primitive.proxy.ProxyClient;\n-import io.atomix.primitive.proxy.impl.DefaultProxyClient;\n-import io.atomix.primitive.service.ServiceConfig;\n-import io.atomix.primitive.session.SessionClient;\n-import io.atomix.raft.partition.RaftPartition;\n-import io.atomix.utils.config.ConfigurationException;\n-import java.util.Collection;\n-import java.util.stream.Collectors;\n \n /** Multi-Raft protocol. */\n public class MultiRaftProtocol implements ProxyProtocol {", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ5NjkzNg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423496936", "bodyText": "Can be removed.", "author": "deepthidevaki", "createdAt": "2020-05-12T06:43:57Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/impl/RaftContext.java", "diffHunk": "@@ -94,20 +83,16 @@\n   private static final int HIGH_LOAD_THRESHOLD = 500;", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMDE1Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423500156", "bodyText": "This is required if we want dynamic reconfiguration \ud83d\ude00", "author": "deepthidevaki", "createdAt": "2020-05-12T06:51:02Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/partition/RaftPartition.java", "diffHunk": "@@ -185,37 +165,9 @@ public String name() {\n     return String.format(\"%s-partition-%d\", partitionId.group(), partitionId.id());\n   }\n \n-  /** Updates the partition with the given metadata. */\n-  CompletableFuture<Void> update(", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQwNzMxNg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r424407316", "bodyText": "Which we can re-add if we really need it", "author": "Zelldon", "createdAt": "2020-05-13T12:45:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwMDE1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUxNTIwMA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423515200", "bodyText": "Is it safe to compact without a snapshot? Depending on what we want to test, this might not work.", "author": "deepthidevaki", "createdAt": "2020-05-12T07:21:09Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -0,0 +1,521 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.mock;\n+\n+import io.atomix.cluster.ClusterMembershipService;\n+import io.atomix.cluster.MemberId;\n+import io.atomix.raft.RaftServer.Builder;\n+import io.atomix.raft.RaftServer.Role;\n+import io.atomix.raft.cluster.RaftMember;\n+import io.atomix.raft.partition.impl.RaftNamespaces;\n+import io.atomix.raft.primitive.TestMember;\n+import io.atomix.raft.protocol.TestRaftProtocolFactory;\n+import io.atomix.raft.protocol.TestRaftServerProtocol;\n+import io.atomix.raft.roles.LeaderRole;\n+import io.atomix.raft.storage.RaftStorage;\n+import io.atomix.raft.storage.log.entry.RaftLogEntry;\n+import io.atomix.raft.zeebe.ZeebeEntry;\n+import io.atomix.raft.zeebe.ZeebeLogAppender;\n+import io.atomix.storage.StorageLevel;\n+import io.atomix.storage.journal.Indexed;\n+import io.atomix.storage.journal.JournalReader.Mode;\n+import io.atomix.utils.concurrent.SingleThreadContext;\n+import io.atomix.utils.concurrent.ThreadContext;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.junit.rules.ExternalResource;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.Description;\n+import org.junit.runners.model.Statement;\n+\n+public final class RaftRule extends ExternalResource {\n+\n+  public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+\n+  private volatile int nextId;\n+  private volatile List<RaftMember> members;\n+  private Map<String, Long> memberLog;\n+  private final List<RaftServer> servers = new ArrayList<>();\n+  private volatile TestRaftProtocolFactory protocolFactory;\n+  private volatile ThreadContext context;\n+  private Path directory;\n+  private final int nodeCount;\n+  private volatile long highestCommit;\n+  private final AtomicReference<CommitAwaiter> commitAwaiterRef = new AtomicReference<>();\n+  private long position;\n+\n+  private RaftRule(final int nodeCount) {\n+    this.nodeCount = nodeCount;\n+  }\n+\n+  public static RaftRule withBootstrappedNodes(final int nodeCount) {\n+    if (nodeCount < 1) {\n+      throw new IllegalArgumentException(\"Expected to have at least one node to configure.\");\n+    }\n+    return new RaftRule(nodeCount);\n+  }\n+\n+  public static RaftRule withoutNodes() {\n+    return new RaftRule(-1);\n+  }\n+\n+  @Override\n+  public Statement apply(final Statement base, final Description description) {\n+    final var statement = super.apply(base, description);\n+    return temporaryFolder.apply(statement, description);\n+  }\n+\n+  @Override\n+  protected void before() throws Throwable {\n+    directory = temporaryFolder.newFolder().toPath();\n+\n+    position = 0;\n+    members = new ArrayList<>();\n+    memberLog = new ConcurrentHashMap<>();\n+    nextId = 0;\n+    context = new SingleThreadContext(\"raft-test-messaging-%d\");\n+    protocolFactory = new TestRaftProtocolFactory(context);\n+\n+    if (nodeCount > 0) {\n+      createServers(nodeCount);\n+    }\n+  }\n+\n+  @Override\n+  protected void after() {\n+    servers.forEach(\n+        s -> {\n+          try {\n+            if (s.isRunning()) {\n+              s.shutdown().get(30, TimeUnit.SECONDS);\n+            }\n+          } catch (final Exception e) {\n+            // its fine..\n+          }\n+        });\n+    servers.clear();\n+    context.close();\n+    context = null;\n+    members.clear();\n+    nextId = 0;\n+    protocolFactory = null;\n+    highestCommit = 0;\n+    commitAwaiterRef.set(null);\n+    memberLog.clear();\n+    memberLog = null;\n+    position = 0;\n+  }\n+\n+  /**\n+   * Returns the next server address.\n+   *\n+   * @param type The startup member type.\n+   * @return The next server address.\n+   */\n+  private RaftMember nextMember(final RaftMember.Type type) {\n+    return new TestMember(nextNodeId(), type);\n+  }\n+\n+  /**\n+   * Returns the next unique member identifier.\n+   *\n+   * @return The next unique member identifier.\n+   */\n+  private MemberId nextNodeId() {\n+    return MemberId.from(String.valueOf(++nextId));\n+  }\n+\n+  /** Creates a set of Raft servers. */\n+  private List<RaftServer> createServers(final int nodes) throws Exception {\n+    final List<RaftServer> servers = new ArrayList<>();\n+\n+    for (int i = 0; i < nodes; i++) {\n+      members.add(nextMember(RaftMember.Type.ACTIVE));\n+    }\n+\n+    final CountDownLatch latch = new CountDownLatch(nodes);\n+\n+    for (int i = 0; i < nodes; i++) {\n+      final RaftServer server = createServer(members.get(i).memberId());\n+      if (members.get(i).getType() == RaftMember.Type.ACTIVE) {\n+        server\n+            .bootstrap(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      } else {\n+        server\n+            .listen(members.stream().map(RaftMember::memberId).collect(Collectors.toList()))\n+            .thenAccept(this::addCommitListener)\n+            .thenRun(latch::countDown);\n+      }\n+      servers.add(server);\n+    }\n+\n+    latch.await(30 * nodes, TimeUnit.SECONDS);\n+\n+    return servers;\n+  }\n+\n+  public void shutdownFollower() throws Exception {\n+    final var follower = getFollower().orElseThrow();\n+    shutdownServer(follower);\n+  }\n+\n+  public RaftServer shutdownLeader() throws Exception {\n+    final var leader = getLeader().orElseThrow();\n+    shutdownServer(leader);\n+    return leader;\n+  }\n+\n+  public void restartLeader() throws Exception {\n+    awaitNewLeader();\n+    final var leader = shutdownLeader();\n+\n+    final RaftMember leaderMember = getRaftMember(leader.name());\n+    createServer(leaderMember.memberId())\n+        .join(getMemberIds())\n+        .thenAccept(this::addCommitListener)\n+        .get(30, TimeUnit.SECONDS);\n+  }\n+\n+  private List<MemberId> getMemberIds() {\n+    return members.stream().map(RaftMember::memberId).collect(Collectors.toList());\n+  }\n+\n+  public void shutdownServer(final String memberId) throws Exception {\n+    final var raftServer = getRaftServer(memberId);\n+    shutdownServer(raftServer);\n+  }\n+\n+  private RaftServer getRaftServer(final String memberId) {\n+    return servers.stream()\n+        .filter(server -> server.name().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public void shutdownServer(final RaftServer raftServer) throws Exception {\n+    raftServer.shutdown().get(30, TimeUnit.SECONDS);\n+    servers.remove(raftServer);\n+    memberLog.remove(raftServer.name());\n+  }\n+\n+  public CompletableFuture<RaftServer> startServer(final String memberId) {\n+    final RaftMember raftMember = getRaftMember(memberId);\n+    final var server = createServer(raftMember.memberId());\n+    return server.join(getMemberIds());\n+  }\n+\n+  private RaftMember getRaftMember(final String memberId) {\n+    return members.stream()\n+        .filter(member -> member.memberId().id().equals(memberId))\n+        .findFirst()\n+        .orElseThrow();\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogsOnServersExcept(\n+      final String memberId, final long index) {\n+\n+    final var servers =\n+        this.servers.stream()\n+            .filter(server -> !server.name().equals(memberId))\n+            .collect(Collectors.toList());\n+\n+    final List<CompletableFuture<Void>> futures = new ArrayList<>();\n+    for (final RaftServer server : servers) {\n+      futures.add(tryToCompactLogOnServer(server, index));\n+    }\n+\n+    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n+  }\n+\n+  public CompletableFuture<Void> tryToCompactLogOnServer(final String memberId, final long index) {\n+    final var raftServer = getRaftServer(memberId);\n+    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n+    return raftServer.compact();\n+  }\n+\n+  private CompletableFuture<Void> tryToCompactLogOnServer(\n+      final RaftServer raftServer, final long index) {\n+    raftServer.getContext().getServiceManager().setCompactableIndex(index);", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQxODkwMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r424418901", "bodyText": "I think you're right. I have a follow up issue to investigate this.", "author": "Zelldon", "createdAt": "2020-05-13T13:02:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUxNTIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUxNjAxMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423516012", "bodyText": "Name doesn't match \ud83d\ude42", "author": "deepthidevaki", "createdAt": "2020-05-12T07:22:38Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.storage.journal.Indexed;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+@RunWith(Parameterized.class)\n+public class RaftFailOverTest {\n+\n+  @Rule @Parameter public RaftRule raftRule;\n+\n+  @Parameters(name = \"{index}: {0}\")\n+  public static Object[][] reprocessingTriggers() {", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQwODY2NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r424408665", "bodyText": "great catch \ud83d\udc4d", "author": "Zelldon", "createdAt": "2020-05-13T12:47:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUxNjAxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUxNzA2Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423517066", "bodyText": "We can get the index from appendEntry and use that to await commit, instead of estimating the commit index.", "author": "deepthidevaki", "createdAt": "2020-05-12T07:24:45Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.storage.journal.Indexed;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+@RunWith(Parameterized.class)\n+public class RaftFailOverTest {\n+\n+  @Rule @Parameter public RaftRule raftRule;\n+\n+  @Parameters(name = \"{index}: {0}\")\n+  public static Object[][] reprocessingTriggers() {\n+    return new Object[][] {\n+      new Object[] {RaftRule.withBootstrappedNodes(3)},\n+      new Object[] {RaftRule.withBootstrappedNodes(4)},\n+      new Object[] {RaftRule.withBootstrappedNodes(5)}\n+    };\n+  }\n+\n+  @Test\n+  public void shouldCommitEntriesAfterFollowerShutdown() throws Throwable {\n+    // given\n+    final var entryCount = 20;\n+    raftRule.appendEntries(entryCount);\n+    raftRule.awaitCommit(entryCount);\n+    raftRule.shutdownFollower();\n+\n+    // when\n+    raftRule.appendEntries(entryCount);\n+\n+    // then\n+    // 40 zeebe entries and 1 initial entry", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUxNzc1NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423517755", "bodyText": "Same as above. We cannot guarantee there are only 2 initial entries.", "author": "deepthidevaki", "createdAt": "2020-05-12T07:25:57Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.atomix.storage.journal.Indexed;\n+import java.util.List;\n+import java.util.Map;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameter;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+@RunWith(Parameterized.class)\n+public class RaftFailOverTest {\n+\n+  @Rule @Parameter public RaftRule raftRule;\n+\n+  @Parameters(name = \"{index}: {0}\")\n+  public static Object[][] reprocessingTriggers() {\n+    return new Object[][] {\n+      new Object[] {RaftRule.withBootstrappedNodes(3)},\n+      new Object[] {RaftRule.withBootstrappedNodes(4)},\n+      new Object[] {RaftRule.withBootstrappedNodes(5)}\n+    };\n+  }\n+\n+  @Test\n+  public void shouldCommitEntriesAfterFollowerShutdown() throws Throwable {\n+    // given\n+    final var entryCount = 20;\n+    raftRule.appendEntries(entryCount);\n+    raftRule.awaitCommit(entryCount);\n+    raftRule.shutdownFollower();\n+\n+    // when\n+    raftRule.appendEntries(entryCount);\n+\n+    // then\n+    // 40 zeebe entries and 1 initial entry\n+    final var expectedEntryCount = entryCount * 2 + 1;\n+    raftRule.awaitCommit(expectedEntryCount);\n+    raftRule.awaitSameLogSizeOnAllNodes();\n+    final var memberLog = raftRule.getMemberLog();\n+\n+    final var logLength = memberLog.values().stream().map(List::size).findFirst().orElseThrow();\n+    assertThat(logLength).isEqualTo(expectedEntryCount);\n+    assertMemberLogs(memberLog);\n+  }\n+\n+  @Test\n+  public void shouldCommitEntriesAfterLeaderShutdown() throws Throwable {\n+    // given\n+    final var entryCount = 20;\n+    raftRule.appendEntries(entryCount);\n+    raftRule.awaitCommit(entryCount);\n+    raftRule.shutdownLeader();\n+\n+    // when\n+    raftRule.awaitNewLeader();\n+    raftRule.appendEntries(entryCount);\n+\n+    // then\n+    // 40 zeebe entries and 2 initial entries\n+    final var expectedEntryCount = entryCount * 2 + 2;", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyNDMyOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423524328", "bodyText": "Is it difficult to use RaftRule for this also?", "author": "deepthidevaki", "createdAt": "2020-05-12T07:37:53Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftTest.java", "diffHunk": "@@ -108,21 +75,18 @@\n import org.junit.Test;\n import org.junit.rules.TemporaryFolder;\n import org.mockito.Mockito;\n-import org.slf4j.LoggerFactory;\n \n /** Raft test. */\n public class RaftTest extends ConcurrentTestCase {", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY0ODAxMA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423648010", "bodyText": "Probably not. I used most of the setup code from there, but I wanted to minimize the changes \ud83d\ude05 But yes I can migrated them as well. I had hoped that we can replace most of them step by step.", "author": "Zelldon", "createdAt": "2020-05-12T11:04:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyNDMyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQyNDc2OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r424424769", "bodyText": "I put it on my agenda of my next issues where I also work on the tests.", "author": "Zelldon", "createdAt": "2020-05-13T13:11:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyNDMyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyNTY1OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423525659", "bodyText": "Did you move this test to some where else? This is important to test.", "author": "deepthidevaki", "createdAt": "2020-05-12T07:40:19Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftTest.java", "diffHunk": "@@ -1178,444 +485,24 @@ public void testThreeNodesSequentiallyStart() throws Throwable {\n     await(2000 * 3, 3);\n   }\n \n-  /** Tests submitting linearizable events. */\n-  @Test\n-  public void testFiveNodesManyEventsAfterLeaderShutdown() throws Throwable {\n-    testManyEventsAfterLeaderShutdown(5);\n-  }\n-\n-  /** Tests submitting sequential events. */\n-  @Test\n-  public void testThreeNodesEventsAfterFollowerKill() throws Throwable {\n-    testEventsAfterFollowerKill(3);\n-  }\n-\n-  /** Tests submitting a sequential event that publishes to all sessions. */\n-  private void testEventsAfterFollowerKill(final int nodes) throws Throwable {\n-    final List<RaftServer> servers = createServers(nodes);\n-\n-    final RaftClient client = createClient();\n-    final TestPrimitive primitive = createPrimitive(client);\n-    primitive.onEvent(\n-        event -> {\n-          threadAssertNotNull(event);\n-          resume();\n-        });\n-\n-    for (int i = 0; i < 10; i++) {\n-      primitive.sendEvent(true).thenRun(this::resume);\n-      await(30000, 2);\n-    }\n-\n-    primitive.sendEvent(true).thenRun(this::resume);\n-\n-    final RaftServer follower =\n-        servers.stream().filter(s -> s.getRole() == RaftServer.Role.FOLLOWER).findFirst().get();\n-    follower.shutdown().get(10, TimeUnit.SECONDS);\n-\n-    await(30000, 2);\n-\n-    for (int i = 0; i < 10; i++) {\n-      primitive.sendEvent(true).thenRun(this::resume);\n-      await(30000, 2);\n-    }\n-  }\n-\n-  /** Tests submitting sequential events. */\n-  @Test\n-  public void testFiveNodesEventsAfterFollowerKill() throws Throwable {\n-    testEventsAfterFollowerKill(5);\n-  }\n-\n-  /** Tests submitting events. */\n-  @Test\n-  public void testFiveNodesEventsAfterLeaderKill() throws Throwable {\n-    testEventsAfterLeaderKill(5);\n-  }\n-\n-  /** Tests submitting a linearizable event that publishes to all sessions. */\n-  private void testEventsAfterLeaderKill(final int nodes) throws Throwable {\n-    final List<RaftServer> servers = createServers(nodes);\n-\n-    final RaftClient client = createClient();\n-    final TestPrimitive primitive = createPrimitive(client);\n-    primitive.onEvent(\n-        event -> {\n-          threadAssertNotNull(event);\n-          resume();\n-        });\n-\n-    for (int i = 0; i < 10; i++) {\n-      primitive.sendEvent(true).thenRun(this::resume);\n-      await(30000, 2);\n-    }\n-\n-    primitive.sendEvent(true).thenRun(this::resume);\n-\n-    final RaftServer leader = getLeader(servers).get();\n-    leader.shutdown().get(10, TimeUnit.SECONDS);\n-\n-    await(30000);\n-\n-    for (int i = 0; i < 10; i++) {\n-      primitive.sendEvent(true).thenRun(this::resume);\n-      await(30000, 2);\n-    }\n-  }\n-\n-  /** Tests submitting linearizable events. */\n-  @Test\n-  public void testFiveNodeManySessionsManyEvents() throws Throwable {\n-    testManySessionsManyEvents(5);\n-  }\n-\n-  /** Tests submitting a linearizable event that publishes to all sessions. */\n-  private void testManySessionsManyEvents(final int nodes) throws Throwable {\n-    createServers(nodes);\n-\n-    final RaftClient client = createClient();\n-    final TestPrimitive primitive = createPrimitive(client);\n-    primitive.onEvent(\n-        event -> {\n-          threadAssertNotNull(event);\n-          resume();\n-        });\n-\n-    createPrimitive(createClient())\n-        .onEvent(\n-            event -> {\n-              threadAssertNotNull(event);\n-              resume();\n-            });\n-\n-    createPrimitive(createClient())\n-        .onEvent(\n-            event -> {\n-              threadAssertNotNull(event);\n-              resume();\n-            });\n-\n-    for (int i = 0; i < 10; i++) {\n-      primitive.sendEvent(false).thenRun(this::resume);\n-      await(10000, 4);\n-    }\n-  }\n-\n-  /** Tests session expiring events. */\n-  @Test\n-  public void testOneNodeExpireEvent() throws Throwable {\n-    testSessionExpire(1);\n-  }\n-\n-  /** Tests a session expiring. */\n-  private void testSessionExpire(final int nodes) throws Throwable {\n-    createServers(nodes);\n-\n-    final RaftClient client1 = createClient();\n-    final TestPrimitive primitive1 = createPrimitive(client1);\n-    final RaftClient client2 = createClient();\n-    createSession(client2);\n-    primitive1.onExpire(event -> resume()).thenRun(this::resume);\n-    client2.close().thenRun(this::resume);\n-    await(Duration.ofSeconds(10).toMillis(), 3);\n-  }\n-\n-  /** Tests session expiring events. */\n-  @Test\n-  public void testThreeNodeExpireEvent() throws Throwable {\n-    testSessionExpire(3);\n-  }\n-\n-  /** Tests session expiring events. */\n-  @Test\n-  public void testFiveNodeExpireEvent() throws Throwable {\n-    testSessionExpire(5);\n-  }\n-\n-  /** Tests session close events. */\n-  @Test\n-  public void testOneNodeCloseEvent() throws Throwable {\n-    testSessionClose(1);\n-  }\n-\n-  /** Tests a session closing. */\n-  private void testSessionClose(final int nodes) throws Throwable {\n-    createServers(nodes);\n-\n-    final RaftClient client1 = createClient();\n-    final TestPrimitive primitive1 = createPrimitive(client1);\n-    final RaftClient client2 = createClient();\n-    primitive1.onClose(event -> resume()).thenRun(this::resume);\n-    await(Duration.ofSeconds(10).toMillis(), 1);\n-    createSession(client2).close().thenRun(this::resume);\n-    await(Duration.ofSeconds(10).toMillis(), 2);\n-  }\n-\n-  /** Tests session close events. */\n-  @Test\n-  public void testThreeNodeCloseEvent() throws Throwable {\n-    testSessionClose(3);\n-  }\n-\n-  /** Tests session close events. */\n-  @Test\n-  public void testFiveNodeCloseEvent() throws Throwable {\n-    testSessionClose(5);\n-  }\n-\n   @Test\n   public void testThreeNodeManyEventsDoNotMissHeartbeats() throws Throwable {\n     // given\n     createServers(3);\n+    final var leader = getLeader(servers).orElseThrow();\n \n-    final RaftClient client = createClient();\n-    final TestPrimitive primitive = createPrimitive(client);\n-    primitive.onEvent(\n-        message -> {\n-          threadAssertNotNull(message);\n-          resume();\n-        });\n+    appendEntry(leader);\n \n     final double startMissedHeartBeats = RaftRoleMetrics.getHeartbeatMissCount(\"1\");\n \n     // when\n-    for (int i = 0; i < 1_000; i++) {\n-      primitive.sendEvent(true);\n-    }\n-    await(10000, 1_000);\n+    appendEntries(leader, 1000);\n \n     // then\n     final double missedHeartBeats = RaftRoleMetrics.getHeartbeatMissCount(\"1\");\n     assertThat(0.0, is(missedHeartBeats - startMissedHeartBeats));\n   }\n \n-  @Test\n-  public void testSnapshotSentOnDataLoss() throws Throwable {", "originalCommit": "e920effc9dc7aef5836da9347a22bc7daca5e46f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY0NzY0OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r423647648", "bodyText": "As I explained, this tests doesn't make sense with the ZeebeRaftStateMachine. This test can't be done in the Raft module, since we are not able to create normal snapshot here. I created a follow up issue #4468 to investigate them. Maybe it is possible to create fake snapshots otherwise we have to test it elsewhere. Furthermore I thought that we have such a test already in QA.", "author": "Zelldon", "createdAt": "2020-05-12T11:03:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUyNTY1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk1NDY3Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4466#discussion_r424954676", "bodyText": "Nit: I'd be fine collapsing this and the interface type, or at least renaming to something more descriptive than Zeebe \ud83d\ude05", "author": "npepinpe", "createdAt": "2020-05-14T08:20:32Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/RaftServer.java", "diffHunk": "@@ -22,20 +22,14 @@\n \n import io.atomix.cluster.ClusterMembershipService;\n import io.atomix.cluster.MemberId;\n-import io.atomix.primitive.PrimitiveTypeRegistry;\n-import io.atomix.primitive.operation.OperationType;\n-import io.atomix.primitive.service.PrimitiveService;\n import io.atomix.raft.cluster.RaftCluster;\n import io.atomix.raft.cluster.RaftMember;\n import io.atomix.raft.impl.DefaultRaftServer;\n import io.atomix.raft.impl.RaftContext;\n-import io.atomix.raft.impl.RaftServiceManager;\n+import io.atomix.raft.impl.zeebe.ZeebeRaftStateMachine;", "originalCommit": "e58ce0574d49cd8b689c47a15d019b6c434cc037", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "url": "https://github.com/camunda-cloud/zeebe/commit/26343ad7fc095e5a8b0433108b2ec381fc1a09bc", "message": "chore(atomix): migrate zeebe state machine to atomix", "committedDate": "2020-05-14T12:25:15Z", "type": "commit"}, {"oid": "3d1d9dbbdc85fcc4ae0bc4384abfd02af3f04b9c", "url": "https://github.com/camunda-cloud/zeebe/commit/3d1d9dbbdc85fcc4ae0bc4384abfd02af3f04b9c", "message": "chore(atomix): move snapshotting and statemachine to atomix\n\n We add some implementations which are only used in atomix and for there tests, but have been replaced on broker side.\n This means we haven't tested our code completely with the other tests and had duplicate logic. We still have for replicate\n but this migration makes it now easier to move and merge the related classes.\n\n The engine doesn't know anymore about snapshoting, since it doesnt need to.", "committedDate": "2020-05-14T12:26:09Z", "type": "commit"}, {"oid": "d34a70ac0ead5ff927ea939d695576da626412a0", "url": "https://github.com/camunda-cloud/zeebe/commit/d34a70ac0ead5ff927ea939d695576da626412a0", "message": "chore(atomix): remove sessions and primitives\n\nWe no longer need everything session related nor primitives.", "committedDate": "2020-05-14T12:26:48Z", "type": "commit"}, {"oid": "eeb0980056cf4880562d356b0f637edf5c32d895", "url": "https://github.com/camunda-cloud/zeebe/commit/eeb0980056cf4880562d356b0f637edf5c32d895", "message": "chore(atomix): refactor raft tests\n\n Remove all tests which are session related.\n Replace/migrate tests which used sessions/primitives and append\n directly to the log.\n\n Some tests will no longer work if the state machine and snapshot is\n moved into atomix, which means they are removed for now and need to be\n replaced later in a follow up issue.", "committedDate": "2020-05-14T12:26:48Z", "type": "commit"}, {"oid": "f425fa37685cc34221c6a265f9c23341ad16afac", "url": "https://github.com/camunda-cloud/zeebe/commit/f425fa37685cc34221c6a265f9c23341ad16afac", "message": "chore(atomix): rename annotated parameters method", "committedDate": "2020-05-14T12:26:48Z", "type": "commit"}, {"oid": "bdd49e38a8e5d02b94a959367e920b735bf52ebd", "url": "https://github.com/camunda-cloud/zeebe/commit/bdd49e38a8e5d02b94a959367e920b735bf52ebd", "message": "chore(atomix): log errors on closing server", "committedDate": "2020-05-14T12:26:48Z", "type": "commit"}, {"oid": "bdd49e38a8e5d02b94a959367e920b735bf52ebd", "url": "https://github.com/camunda-cloud/zeebe/commit/bdd49e38a8e5d02b94a959367e920b735bf52ebd", "message": "chore(atomix): log errors on closing server", "committedDate": "2020-05-14T12:26:48Z", "type": "forcePushed"}]}