{"pr_number": 4070, "pr_title": "chore(engine): add streamprocessor health check", "pr_createdAt": "2020-03-18T12:19:48Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/4070", "timeline": [{"oid": "dff6c0da99099701a7c687bae6b62a7493d2c02c", "url": "https://github.com/camunda-cloud/zeebe/commit/dff6c0da99099701a7c687bae6b62a7493d2c02c", "message": "chore(engine): add streamprocessor health check", "committedDate": "2020-03-18T12:20:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgwNTc2MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r394805760", "bodyText": "Hmm not sure if this is sufficient, since exceptions in the nextStep already catched. So say we have an error on write. You call onError, then try again onWrite this fails again. This will again call onError. But you will not get this in the onError method.", "author": "Zelldon", "createdAt": "2020-03-19T05:58:29Z", "path": "engine/src/main/java/io/zeebe/engine/processor/ProcessingStateMachine.java", "diffHunk": "@@ -298,12 +299,24 @@ private void onError(final Throwable processingException, final Runnable nextSte\n \n             onErrorHandling = true;\n             nextStep.run();\n+\n+            if (onErrorHandlingLoop) {\n+              onErrorHandlingLoop = false;\n+            }\n           } catch (final Exception ex) {\n+            errorHandlingFailed(ex);\n             onError(ex, nextStep);\n           }\n         });\n   }\n \n+  private void errorHandlingFailed(final Exception ex) {\n+    if (!onErrorHandlingLoop) {\n+      LOG.error(\"Encountered an exception during processing. Retrying.\", ex);", "originalCommit": "dff6c0da99099701a7c687bae6b62a7493d2c02c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAwODM0Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395008342", "bodyText": "Thanks @Zelldon for this pointer.  I think I fixed it now. I have also added more test cases for this.", "author": "deepthidevaki", "createdAt": "2020-03-19T13:03:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgwNTc2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgwNjE2OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r394806168", "bodyText": "We should probably also close the other resources right? \ud83d\ude05", "author": "Zelldon", "createdAt": "2020-03-19T05:59:52Z", "path": "engine/src/main/java/io/zeebe/engine/processor/StreamProcessor.java", "diffHunk": "@@ -154,6 +162,26 @@ protected void onActorCloseRequested() {\n     return closeFuture;\n   }\n \n+  @Override\n+  protected void handleFailure(final Exception failure) {\n+    if (this.failureListener != null) {\n+      this.failureListener.onFailure();\n+    }\n+    actor.fail();\n+  }\n+\n+  @Override\n+  public void onActorFailed() {\n+    phase = Phase.FAILED;", "originalCommit": "dff6c0da99099701a7c687bae6b62a7493d2c02c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAwODU3NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395008574", "bodyText": "Which other resources?", "author": "deepthidevaki", "createdAt": "2020-03-19T13:03:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgwNjE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA0NDgyOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395044829", "bodyText": "Idk things like this:\n  @Override\n  protected void onActorClosing() {\n    processingContext.getLogStreamReader().close();\n\n    if (onCommitPositionUpdatedCondition != null) {\n      logStream.removeOnCommitPositionUpdatedCondition(onCommitPositionUpdatedCondition);\n      onCommitPositionUpdatedCondition = null;\n    }\n  }\n\n  @Override\n  protected void onActorClosed() {\n    closeFuture.complete(null);\n    LOG.debug(\"Closed stream processor controller {}.\", getName());\n  }\n\n  @Override\n  protected void onActorCloseRequested() {\n    if (!isFailed()) {\n      lifecycleAwareListeners.forEach(StreamProcessorLifecycleAware::onClose);\n    }\n  }\n\nAlso should we introduce a new listener methods for the lifecycle listeners?", "author": "Zelldon", "createdAt": "2020-03-19T13:58:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgwNjE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA1MDk5Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395050996", "bodyText": "\ud83d\ude48 my bad. Doing cleanup onActorFailed is always same as the steps in normal close. Let me see if we can do it any better here to avoid such mistakes in future.", "author": "deepthidevaki", "createdAt": "2020-03-19T14:06:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgwNjE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA1MTg4Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395051886", "bodyText": "Also should we introduce a new listener methods for the lifecycle listeners?\n\nMay be. But is it useful? We can treat \"FAILED\" phase similar to closed, as we are doing now.", "author": "deepthidevaki", "createdAt": "2020-03-19T14:08:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgwNjE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA2MTA0Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395061046", "bodyText": "Ya. It would make sense to add a new listener method, or atleast make sure that onClose listener is invoked when failed. But adding a new listener method would be meaningful.", "author": "deepthidevaki", "createdAt": "2020-03-19T14:20:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgwNjE2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgwODI4NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r394808285", "bodyText": "This is actually the reason why your test works with the onError loop but this doesn't reflect the real production setting. A this will never fail normally b as I wrote above your logic doesn't detect real loops between write and error or processing and error etc.", "author": "Zelldon", "createdAt": "2020-03-19T06:07:32Z", "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorHealthTest.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor;\n+\n+import static io.zeebe.engine.processor.StreamProcessor.HEALTH_CHECK_TICK_DURATION;\n+import static io.zeebe.engine.processor.TypedRecordProcessors.processors;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATING;\n+import static io.zeebe.test.util.TestUtil.waitUntil;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+\n+import io.zeebe.engine.state.ZeebeState;\n+import io.zeebe.engine.util.StreamProcessorRule;\n+import io.zeebe.protocol.impl.record.UnifiedRecordValue;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.util.health.HealthStatus;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+public class StreamProcessorHealthTest {\n+\n+  @Rule public final StreamProcessorRule streamProcessorRule = new StreamProcessorRule();\n+\n+  private ZeebeState mockedZeebeState;\n+  private StreamProcessor streamProcessor;\n+  private final AtomicBoolean shouldThrowException = new AtomicBoolean(true);\n+  private final AtomicInteger invocation = new AtomicInteger();\n+\n+  @After\n+  public void after() {\n+    // To exit the processing error loop\n+    shouldThrowException.set(false);\n+  }\n+\n+  @Test\n+  public void shouldBeHealthyOnStart() {\n+    // when\n+    streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.onEvent(\n+                    ValueType.WORKFLOW_INSTANCE,\n+                    ELEMENT_ACTIVATING,\n+                    mock(TypedRecordProcessor.class)));\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenReprocessingRetryLoop() {\n+    // given\n+    final long firstPosition =\n+        streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(ELEMENT_ACTIVATED, 1, firstPosition);\n+\n+    streamProcessor = getErrorProneStreamProcessor();\n+\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+    waitUntil(() -> invocation.get() > 1);\n+\n+    // when\n+    streamProcessorRule.getClock().addTime(HEALTH_CHECK_TICK_DURATION.multipliedBy(1));\n+    // give some time for scheduled timers to get executed\n+    final int retried = invocation.get();\n+    waitUntil(() -> retried < invocation.get());\n+    streamProcessorRule.getClock().addTime(HEALTH_CHECK_TICK_DURATION.multipliedBy(1));\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenInErrorLoop() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldBecomeHealthyWhenErrorIsResolved() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+\n+    // when\n+    shouldThrowException.set(false);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+  }\n+\n+  private StreamProcessor getErrorProneStreamProcessor() {\n+    streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            processingContext -> {\n+              mockedZeebeState = spy(processingContext.getZeebeState());\n+              processingContext.zeebeState(mockedZeebeState);\n+              return processors(mockedZeebeState.getKeyGenerator())\n+                  .onEvent(\n+                      ValueType.WORKFLOW_INSTANCE,\n+                      ELEMENT_ACTIVATING,\n+                      new TypedRecordProcessor<>() {\n+                        @Override\n+                        public void processRecord(\n+                            final long position,\n+                            final TypedRecord<UnifiedRecordValue> record,\n+                            final TypedResponseWriter responseWriter,\n+                            final TypedStreamWriter streamWriter,\n+                            final Consumer<SideEffectProducer> sideEffect) {\n+\n+                          invocation.getAndIncrement();\n+                          if (shouldThrowException.get()) {\n+                            throw new RuntimeException(\"expected\");\n+                          }\n+                        }\n+                      });\n+            });\n+\n+    Mockito.doAnswer(", "originalCommit": "dff6c0da99099701a7c687bae6b62a7493d2c02c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAwOTgxNw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395009817", "bodyText": "Yes. I have now added test to cause exception in writeEvent. I couldn't find an easy way to mock failures in updateState though which can also cause an error loop.", "author": "deepthidevaki", "createdAt": "2020-03-19T13:05:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDgwODI4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAxNzAxNw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395017017", "bodyText": "Is there a reason why in this method it is done before calling the write in the method above after calling?", "author": "Zelldon", "createdAt": "2020-03-19T13:17:52Z", "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorHealthTest.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor;\n+\n+import static io.zeebe.engine.processor.StreamProcessor.HEALTH_CHECK_TICK_DURATION;\n+import static io.zeebe.engine.processor.TypedRecordProcessors.processors;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATING;\n+import static io.zeebe.test.util.TestUtil.waitUntil;\n+import static org.mockito.Mockito.mock;\n+\n+import io.zeebe.engine.state.ZeebeState;\n+import io.zeebe.engine.util.StreamProcessorRule;\n+import io.zeebe.msgpack.UnpackedObject;\n+import io.zeebe.protocol.impl.record.RecordMetadata;\n+import io.zeebe.protocol.impl.record.UnifiedRecordValue;\n+import io.zeebe.protocol.record.RejectionType;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.protocol.record.intent.Intent;\n+import io.zeebe.util.health.HealthStatus;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class StreamProcessorHealthTest {\n+\n+  @Rule public final StreamProcessorRule streamProcessorRule = new StreamProcessorRule();\n+\n+  private StreamProcessor streamProcessor;\n+  private TypedStreamWriter mockedLogStreamWriter;\n+  private final AtomicBoolean shouldFlushThrowException = new AtomicBoolean();\n+  private final AtomicInteger invocation = new AtomicInteger();\n+  private final AtomicBoolean shouldFailErrorHandlingInTransaction = new AtomicBoolean();\n+  private final AtomicBoolean shouldProcessingThrowException = new AtomicBoolean(true);\n+\n+  @After\n+  public void after() {\n+    // To exit the processing error loop\n+    shouldProcessingThrowException.set(false);\n+    shouldFlushThrowException.set(false);\n+    shouldFailErrorHandlingInTransaction.set(false);\n+  }\n+\n+  @Test\n+  public void shouldBeHealthyOnStart() {\n+    // when\n+    streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.onEvent(\n+                    ValueType.WORKFLOW_INSTANCE,\n+                    ELEMENT_ACTIVATING,\n+                    mock(TypedRecordProcessor.class)));\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenReprocessingRetryLoop() {\n+    // given\n+    final long firstPosition =\n+        streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(ELEMENT_ACTIVATED, 1, firstPosition);\n+\n+    streamProcessor = getErrorProneStreamProcessor();\n+\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+    waitUntil(() -> invocation.get() > 1);\n+\n+    // when\n+    streamProcessorRule.getClock().addTime(HEALTH_CHECK_TICK_DURATION.multipliedBy(1));\n+    // give some time for scheduled timers to get executed\n+    final int retried = invocation.get();\n+    waitUntil(() -> retried < invocation.get());\n+    streamProcessorRule.getClock().addTime(HEALTH_CHECK_TICK_DURATION.multipliedBy(1));\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenOnErrorHandlingWriteEventFails() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    shouldFlushThrowException.set(true);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenProcessingOkWriteEventFails() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    shouldProcessingThrowException.set(false);\n+    shouldFlushThrowException.set(true);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenExceptionErrorHandlingInTransaction() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    shouldFailErrorHandlingInTransaction.set(true);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldBecomeHealthyWhenErrorIsResolved() {\n+    // given\n+    shouldFlushThrowException.set(true);\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+\n+    // when\n+    shouldFlushThrowException.set(false);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+  }\n+\n+  private StreamProcessor getErrorProneStreamProcessor() {\n+    streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            processingContext -> {\n+              final ZeebeState zeebeState = processingContext.getZeebeState();\n+              mockedLogStreamWriter =\n+                  new WrappedStreamWriter(processingContext.getLogStreamWriter());\n+              processingContext.zeebeState(zeebeState);\n+              processingContext.logStreamWriter(mockedLogStreamWriter);\n+              return processors(zeebeState.getKeyGenerator())\n+                  .onEvent(\n+                      ValueType.WORKFLOW_INSTANCE,\n+                      ELEMENT_ACTIVATING,\n+                      new TypedRecordProcessor<>() {\n+                        @Override\n+                        public void processRecord(\n+                            final long position,\n+                            final TypedRecord<UnifiedRecordValue> record,\n+                            final TypedResponseWriter responseWriter,\n+                            final TypedStreamWriter streamWriter,\n+                            final Consumer<SideEffectProducer> sideEffect) {\n+\n+                          invocation.getAndIncrement();\n+                          if (shouldProcessingThrowException.get()) {\n+                            throw new RuntimeException(\"processing failed\");\n+                          }\n+                        }\n+                      });\n+            });\n+\n+    return streamProcessor;\n+  }\n+\n+  private final class WrappedStreamWriter implements TypedStreamWriter {\n+\n+    private final TypedStreamWriter wrappedWriter;\n+\n+    private WrappedStreamWriter(final TypedStreamWriter wrappedWriter) {\n+      this.wrappedWriter = wrappedWriter;\n+    }\n+\n+    @Override\n+    public void appendRejection(\n+        final TypedRecord<? extends UnpackedObject> command,\n+        final RejectionType type,\n+        final String reason) {\n+      wrappedWriter.appendRejection(command, type, reason);\n+    }\n+\n+    @Override\n+    public void appendRejection(\n+        final TypedRecord<? extends UnpackedObject> command,\n+        final RejectionType type,\n+        final String reason,\n+        final Consumer<RecordMetadata> metadata) {\n+      wrappedWriter.appendRejection(command, type, reason, metadata);\n+    }\n+\n+    @Override\n+    public void appendNewEvent(final long key, final Intent intent, final UnpackedObject value) {\n+      wrappedWriter.appendNewEvent(key, intent, value);\n+    }\n+\n+    @Override\n+    public void appendFollowUpEvent(\n+        final long key, final Intent intent, final UnpackedObject value) {\n+      wrappedWriter.appendFollowUpEvent(key, intent, value);\n+      if (shouldFailErrorHandlingInTransaction.get()) {\n+        throw new RuntimeException(\"append followup event failed\");\n+      }\n+    }\n+\n+    @Override\n+    public void appendFollowUpEvent(\n+        final long key,\n+        final Intent intent,\n+        final UnpackedObject value,\n+        final Consumer<RecordMetadata> metadata) {\n+      if (shouldFailErrorHandlingInTransaction.get()) {", "originalCommit": "8722c7edb96180c509779d23d4c158ecac6e4dcb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAyODE0OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395028149", "bodyText": "No. Just copy paste error \ud83d\ude01 It should throw exception with out invoking the actual method.", "author": "deepthidevaki", "createdAt": "2020-03-19T13:35:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAxNzAxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAxNzY4OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395017688", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void shouldMarkUnhealthyWhenProcessingOkWriteEventFails() {\n          \n          \n            \n              public void shouldMarkUnhealthyWhenProcessingOnWriteEventFails() {", "author": "Zelldon", "createdAt": "2020-03-19T13:19:01Z", "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorHealthTest.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor;\n+\n+import static io.zeebe.engine.processor.StreamProcessor.HEALTH_CHECK_TICK_DURATION;\n+import static io.zeebe.engine.processor.TypedRecordProcessors.processors;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATING;\n+import static io.zeebe.test.util.TestUtil.waitUntil;\n+import static org.mockito.Mockito.mock;\n+\n+import io.zeebe.engine.state.ZeebeState;\n+import io.zeebe.engine.util.StreamProcessorRule;\n+import io.zeebe.msgpack.UnpackedObject;\n+import io.zeebe.protocol.impl.record.RecordMetadata;\n+import io.zeebe.protocol.impl.record.UnifiedRecordValue;\n+import io.zeebe.protocol.record.RejectionType;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.protocol.record.intent.Intent;\n+import io.zeebe.util.health.HealthStatus;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class StreamProcessorHealthTest {\n+\n+  @Rule public final StreamProcessorRule streamProcessorRule = new StreamProcessorRule();\n+\n+  private StreamProcessor streamProcessor;\n+  private TypedStreamWriter mockedLogStreamWriter;\n+  private final AtomicBoolean shouldFlushThrowException = new AtomicBoolean();\n+  private final AtomicInteger invocation = new AtomicInteger();\n+  private final AtomicBoolean shouldFailErrorHandlingInTransaction = new AtomicBoolean();\n+  private final AtomicBoolean shouldProcessingThrowException = new AtomicBoolean(true);\n+\n+  @After\n+  public void after() {\n+    // To exit the processing error loop\n+    shouldProcessingThrowException.set(false);\n+    shouldFlushThrowException.set(false);\n+    shouldFailErrorHandlingInTransaction.set(false);\n+  }\n+\n+  @Test\n+  public void shouldBeHealthyOnStart() {\n+    // when\n+    streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.onEvent(\n+                    ValueType.WORKFLOW_INSTANCE,\n+                    ELEMENT_ACTIVATING,\n+                    mock(TypedRecordProcessor.class)));\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenReprocessingRetryLoop() {\n+    // given\n+    final long firstPosition =\n+        streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(ELEMENT_ACTIVATED, 1, firstPosition);\n+\n+    streamProcessor = getErrorProneStreamProcessor();\n+\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+    waitUntil(() -> invocation.get() > 1);\n+\n+    // when\n+    streamProcessorRule.getClock().addTime(HEALTH_CHECK_TICK_DURATION.multipliedBy(1));\n+    // give some time for scheduled timers to get executed\n+    final int retried = invocation.get();\n+    waitUntil(() -> retried < invocation.get());\n+    streamProcessorRule.getClock().addTime(HEALTH_CHECK_TICK_DURATION.multipliedBy(1));\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenOnErrorHandlingWriteEventFails() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    shouldFlushThrowException.set(true);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenProcessingOkWriteEventFails() {", "originalCommit": "8722c7edb96180c509779d23d4c158ecac6e4dcb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAxODg1OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395018859", "bodyText": "i think this is not different to the other processing exception or?", "author": "Zelldon", "createdAt": "2020-03-19T13:20:52Z", "path": "engine/src/test/java/io/zeebe/engine/processor/StreamProcessorHealthTest.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processor;\n+\n+import static io.zeebe.engine.processor.StreamProcessor.HEALTH_CHECK_TICK_DURATION;\n+import static io.zeebe.engine.processor.TypedRecordProcessors.processors;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATING;\n+import static io.zeebe.test.util.TestUtil.waitUntil;\n+import static org.mockito.Mockito.mock;\n+\n+import io.zeebe.engine.state.ZeebeState;\n+import io.zeebe.engine.util.StreamProcessorRule;\n+import io.zeebe.msgpack.UnpackedObject;\n+import io.zeebe.protocol.impl.record.RecordMetadata;\n+import io.zeebe.protocol.impl.record.UnifiedRecordValue;\n+import io.zeebe.protocol.record.RejectionType;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.protocol.record.intent.Intent;\n+import io.zeebe.util.health.HealthStatus;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class StreamProcessorHealthTest {\n+\n+  @Rule public final StreamProcessorRule streamProcessorRule = new StreamProcessorRule();\n+\n+  private StreamProcessor streamProcessor;\n+  private TypedStreamWriter mockedLogStreamWriter;\n+  private final AtomicBoolean shouldFlushThrowException = new AtomicBoolean();\n+  private final AtomicInteger invocation = new AtomicInteger();\n+  private final AtomicBoolean shouldFailErrorHandlingInTransaction = new AtomicBoolean();\n+  private final AtomicBoolean shouldProcessingThrowException = new AtomicBoolean(true);\n+\n+  @After\n+  public void after() {\n+    // To exit the processing error loop\n+    shouldProcessingThrowException.set(false);\n+    shouldFlushThrowException.set(false);\n+    shouldFailErrorHandlingInTransaction.set(false);\n+  }\n+\n+  @Test\n+  public void shouldBeHealthyOnStart() {\n+    // when\n+    streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.onEvent(\n+                    ValueType.WORKFLOW_INSTANCE,\n+                    ELEMENT_ACTIVATING,\n+                    mock(TypedRecordProcessor.class)));\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenReprocessingRetryLoop() {\n+    // given\n+    final long firstPosition =\n+        streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(ELEMENT_ACTIVATED, 1, firstPosition);\n+\n+    streamProcessor = getErrorProneStreamProcessor();\n+\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+    waitUntil(() -> invocation.get() > 1);\n+\n+    // when\n+    streamProcessorRule.getClock().addTime(HEALTH_CHECK_TICK_DURATION.multipliedBy(1));\n+    // give some time for scheduled timers to get executed\n+    final int retried = invocation.get();\n+    waitUntil(() -> retried < invocation.get());\n+    streamProcessorRule.getClock().addTime(HEALTH_CHECK_TICK_DURATION.multipliedBy(1));\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenOnErrorHandlingWriteEventFails() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    shouldFlushThrowException.set(true);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenProcessingOkWriteEventFails() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    shouldProcessingThrowException.set(false);\n+    shouldFlushThrowException.set(true);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+\n+    // then\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.UNHEALTHY);\n+  }\n+\n+  @Test\n+  public void shouldMarkUnhealthyWhenExceptionErrorHandlingInTransaction() {\n+    // given\n+    streamProcessor = getErrorProneStreamProcessor();\n+    waitUntil(() -> streamProcessor.getHealthStatus() == HealthStatus.HEALTHY);\n+\n+    // when\n+    shouldFailErrorHandlingInTransaction.set(true);", "originalCommit": "8722c7edb96180c509779d23d4c158ecac6e4dcb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAzMTA2NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395031064", "bodyText": "When processing fails, it goes to error handling. It should fail again in errorHandlingInTransaction. This test checks that particular error path. The other test tests when 'errorHandlingInTransaction' succeeds, but the next step writeEvent fails.", "author": "deepthidevaki", "createdAt": "2020-03-19T13:39:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAxODg1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAzNTU5NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395035595", "bodyText": "aaah get it - since error events also appended ok makes sense", "author": "Zelldon", "createdAt": "2020-03-19T13:45:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAxODg1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MDgwNg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395640806", "bodyText": "shouldnt this log be a level higher in the actor class?", "author": "Zelldon", "createdAt": "2020-03-20T13:38:02Z", "path": "engine/src/main/java/io/zeebe/engine/processor/StreamProcessor.java", "diffHunk": "@@ -164,6 +159,7 @@ protected void onActorCloseRequested() {\n \n   @Override\n   protected void handleFailure(final Exception failure) {\n+    LOG.error(\"Actor {} failed in phase {}.\", actorName, actor.getLifecyclePhase(), failure);", "originalCommit": "084ce625721e46e77929aaec33275814f5a0df65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0OTQ0Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395649446", "bodyText": "We have a log in the actor class. But it says, \"actor continue with the next job.\" But here we are not continuing with next jobs, but want to log that it failed.", "author": "deepthidevaki", "createdAt": "2020-03-20T13:51:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MDgwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY1MjQyNg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395652426", "bodyText": "I thought we don't want to continue anymore \ud83e\udd14", "author": "Zelldon", "createdAt": "2020-03-20T13:56:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MDgwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY1MzcwMA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395653700", "bodyText": "Default behavior is we continue, unless the actor decides to fail by overriding 'handleFailure()`", "author": "deepthidevaki", "createdAt": "2020-03-20T13:58:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MDgwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY1NDYyMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395654622", "bodyText": "#4009 (comment)", "author": "deepthidevaki", "createdAt": "2020-03-20T13:59:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MDgwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY3MzgyMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395673821", "bodyText": "sorry", "author": "Zelldon", "createdAt": "2020-03-20T14:29:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MDgwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MTMxMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4070#discussion_r395641311", "bodyText": "\ud83d\udc4d", "author": "Zelldon", "createdAt": "2020-03-20T13:38:48Z", "path": "engine/src/main/java/io/zeebe/engine/processor/StreamProcessor.java", "diffHunk": "@@ -269,12 +275,13 @@ private void onRecovered() {\n   }\n \n   private void onFailure(final Throwable throwable) {\n-    phase = Phase.FAILED;\n-    openFuture.completeExceptionally(throwable);\n-    closeFuture = new CompletableActorFuture<>();\n-    isOpened.set(false);\n-    failureListener.onFailure();\n-    actor.close();\n+    actor.fail();", "originalCommit": "084ce625721e46e77929aaec33275814f5a0df65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dff6c0da99099701a7c687bae6b62a7493d2c02c", "url": "https://github.com/camunda-cloud/zeebe/commit/dff6c0da99099701a7c687bae6b62a7493d2c02c", "message": "chore(engine): add streamprocessor health check", "committedDate": "2020-03-18T12:20:11Z", "type": "forcePushed"}, {"oid": "bd110fa1cdfc4293eb81eb4fe7e158f3cc24b913", "url": "https://github.com/camunda-cloud/zeebe/commit/bd110fa1cdfc4293eb81eb4fe7e158f3cc24b913", "message": "chore(engine): add streamprocessor health check", "committedDate": "2020-03-20T15:55:35Z", "type": "commit"}, {"oid": "bd110fa1cdfc4293eb81eb4fe7e158f3cc24b913", "url": "https://github.com/camunda-cloud/zeebe/commit/bd110fa1cdfc4293eb81eb4fe7e158f3cc24b913", "message": "chore(engine): add streamprocessor health check", "committedDate": "2020-03-20T15:55:35Z", "type": "forcePushed"}]}