{"pr_number": 4979, "pr_title": "docs(forks): add concurrency considerations", "pr_createdAt": "2020-07-15T14:51:51Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/4979", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI0MTc2Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4979#discussion_r456241763", "bodyText": "Clarify why it is important.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This is especially important in the case of a call activity in a parallel flow (e.g. marked as\n          \n          \n            \n            [parallel multi-instance](/bpmn-workflows/multi-instance/multi-instance.html#concurrency-considerations)).\n          \n          \n            \n            This is especially important in the case of a call activity in a parallel flow to avoid overriding variables (e.g. when it is marked as\n          \n          \n            \n            [parallel multi-instance](/bpmn-workflows/multi-instance/multi-instance.html#concurrency-considerations)).", "author": "saig0", "createdAt": "2020-07-17T06:21:37Z", "path": "docs/src/bpmn-workflows/call-activities/call-activities.md", "diffHunk": "@@ -33,6 +33,8 @@ When the call activity is activated then **all variables** of the call activity\n Input mappings can be used to create new local variables in the scope of the call activity. These variables are also copied to the created workflow instance.\n \n By default, all variables of the created workflow instance are propagated to the call activity. This behavior can be customized by defining output mappings at the call activity. The output mappings are applied on completing the call activity.\n+This is especially important in the case of a call activity in a parallel flow (e.g. marked as\n+[parallel multi-instance](/bpmn-workflows/multi-instance/multi-instance.html#concurrency-considerations)).", "originalCommit": "f38610f4fe3df574f87410c624a7f701fa1bf2bc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI0MzgzNQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4979#discussion_r456243835", "bodyText": "The part with the unique name is not true. Only the BPMN element id is unique in the BPMN workflow. Maybe we can remove it.", "author": "saig0", "createdAt": "2020-07-17T06:27:36Z", "path": "docs/src/glossary.md", "diffHunk": "@@ -63,15 +63,20 @@ An incident represents an error condition which prevents Zeebe from advancing an\n * [Incident](reference/incidents.md)\n \n ### Job\n-A job represents a distinct unit of work within a business process. Jobs are represented by steps in your workflow and are identified by a unique name.\n+A job represents a distinct unit of work within a business process. Jobs are represented by service tasks in your workflow and are identified by a unique name and type.", "originalCommit": "f38610f4fe3df574f87410c624a7f701fa1bf2bc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI1NjE2Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4979#discussion_r456256163", "bodyText": "The term \"complete/fail message\" could be confusing. I would suggest using the term \"complete/fail command\" or the present tense (e.g. \"a job worker completes/fails ...\").", "author": "saig0", "createdAt": "2020-07-17T07:00:43Z", "path": "docs/src/basics/job-workers.md", "diffHunk": "@@ -59,3 +62,20 @@ It is enabled by default.\n Zeebe decouples creation of jobs from performing the work on them. It is always possible to create jobs at the highest possible rate, regardless of whether or not there's a worker available to work on them. This is possible because Zeebe queues jobs until workers request them. If no job worker is currently requesting jobs, jobs remain queued. Because workers request jobs from the broker, the workers have control over the rate at which they take on new jobs.\n \n This allows the broker to handle bursts of traffic and effectively act as a _buffer_ in front of the job workers.\n+\n+## Completing and failing jobs\n+After working on an activated job, a job worker should send a complete or fail message to the\n+broker. If the job is not completed within the configured job activation timeout then the broker\n+will make the job available again to other job workers.\n+\n+Sometimes a job worker may wish to alter workflow variables when completing a job. A complete job\n+message containing variables will result in the broker writing those variables to the workflow\n+instance. Note that this will overwrite existing variables and may lead to race conditions in\n+parallel flows. We recommend completing parallelized jobs with only those variables that need to be\n+changed.\n+\n+If the job worker could not successfully complete its work, it can inform the broker of this failure\n+by sending a fail job message. Fail job messages can be sent including a retries number. If this is\n+a positive number then the job will be immediately activatable again, and a worker could try to\n+process it again. If it is zero or negative however, an incident will be raised and the job will not\n+be activatable until the incident is resolved.", "originalCommit": "f38610f4fe3df574f87410c624a7f701fa1bf2bc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI1NzUzMA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4979#discussion_r456257530", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ## Completing and failing jobs\n          \n          \n            \n            ## Completing and Failing Jobs", "author": "saig0", "createdAt": "2020-07-17T07:04:26Z", "path": "docs/src/basics/job-workers.md", "diffHunk": "@@ -59,3 +62,20 @@ It is enabled by default.\n Zeebe decouples creation of jobs from performing the work on them. It is always possible to create jobs at the highest possible rate, regardless of whether or not there's a worker available to work on them. This is possible because Zeebe queues jobs until workers request them. If no job worker is currently requesting jobs, jobs remain queued. Because workers request jobs from the broker, the workers have control over the rate at which they take on new jobs.\n \n This allows the broker to handle bursts of traffic and effectively act as a _buffer_ in front of the job workers.\n+\n+## Completing and failing jobs", "originalCommit": "f38610f4fe3df574f87410c624a7f701fa1bf2bc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI2NzcyMw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4979#discussion_r456267723", "bodyText": "The retries number of the fail command is required.", "author": "saig0", "createdAt": "2020-07-17T07:28:27Z", "path": "docs/src/basics/job-workers.md", "diffHunk": "@@ -59,3 +62,20 @@ It is enabled by default.\n Zeebe decouples creation of jobs from performing the work on them. It is always possible to create jobs at the highest possible rate, regardless of whether or not there's a worker available to work on them. This is possible because Zeebe queues jobs until workers request them. If no job worker is currently requesting jobs, jobs remain queued. Because workers request jobs from the broker, the workers have control over the rate at which they take on new jobs.\n \n This allows the broker to handle bursts of traffic and effectively act as a _buffer_ in front of the job workers.\n+\n+## Completing and failing jobs\n+After working on an activated job, a job worker should send a complete or fail message to the\n+broker. If the job is not completed within the configured job activation timeout then the broker\n+will make the job available again to other job workers.\n+\n+Sometimes a job worker may wish to alter workflow variables when completing a job. A complete job\n+message containing variables will result in the broker writing those variables to the workflow\n+instance. Note that this will overwrite existing variables and may lead to race conditions in\n+parallel flows. We recommend completing parallelized jobs with only those variables that need to be\n+changed.\n+\n+If the job worker could not successfully complete its work, it can inform the broker of this failure\n+by sending a fail job message. Fail job messages can be sent including a retries number. If this is", "originalCommit": "f38610f4fe3df574f87410c624a7f701fa1bf2bc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ2MDIwMw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4979#discussion_r456460203", "bodyText": "Rephrase a bit to express that passing variables is a common thing.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Sometimes a job worker may wish to alter workflow variables when completing a job. A complete job\n          \n          \n            \n            message containing variables will result in the broker writing those variables to the workflow\n          \n          \n            \n            instance. Note that this will overwrite existing variables and may lead to race conditions in\n          \n          \n            \n            parallel flows. We recommend completing parallelized jobs with only those variables that need to be\n          \n          \n            \n            changed.\n          \n          \n            \n            In order to expose the results of the job, the job worker can pass variables with the complete command. These variables will be merged into the workflow instance depending on the output variable mapping. \n          \n          \n            \n            Note that this may overwrite existing variables and can lead to race conditions in\n          \n          \n            \n            parallel flows. We recommend completing jobs with only those variables that need to be\n          \n          \n            \n            changed.", "author": "saig0", "createdAt": "2020-07-17T13:59:13Z", "path": "docs/src/basics/job-workers.md", "diffHunk": "@@ -59,3 +62,20 @@ It is enabled by default.\n Zeebe decouples creation of jobs from performing the work on them. It is always possible to create jobs at the highest possible rate, regardless of whether or not there's a worker available to work on them. This is possible because Zeebe queues jobs until workers request them. If no job worker is currently requesting jobs, jobs remain queued. Because workers request jobs from the broker, the workers have control over the rate at which they take on new jobs.\n \n This allows the broker to handle bursts of traffic and effectively act as a _buffer_ in front of the job workers.\n+\n+## Completing and failing jobs\n+After working on an activated job, a job worker should send a complete or fail message to the\n+broker. If the job is not completed within the configured job activation timeout then the broker\n+will make the job available again to other job workers.\n+\n+Sometimes a job worker may wish to alter workflow variables when completing a job. A complete job\n+message containing variables will result in the broker writing those variables to the workflow\n+instance. Note that this will overwrite existing variables and may lead to race conditions in\n+parallel flows. We recommend completing parallelized jobs with only those variables that need to be\n+changed.", "originalCommit": "f38610f4fe3df574f87410c624a7f701fa1bf2bc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA2NTgxOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4979#discussion_r457065818", "bodyText": "This part overlaps a bit with the previous section about variable mappings.\nSince these considerations are true for all parallel flows (e.g. also parallel gateways), it would be nice to move this to a central place and link to it from here the other places. It might fit to the data flow section. What do you think?", "author": "saig0", "createdAt": "2020-07-20T05:31:49Z", "path": "docs/src/bpmn-workflows/multi-instance/multi-instance.md", "diffHunk": "@@ -71,6 +71,29 @@ The input mappings can access the local variables of the instance (e.g. `inputEl\n \n The output mappings can be used to update the `outputElement` variable. For example, to extract a part of the job variables.\n \n+## Concurrency considerations\n+When using parallel multi-instance activities you may need to take extra care in dealing with\n+variables. Inner activity instances may alter variables that are accessed by other inner activity\n+instances such that race conditions can occur.\n+\n+For instance, say we have a service task that is marked as a parallel multi-instance. Job workers\n+receive all variables belonging to the job they're working on (incl. the output collection variable\n+at that time). The job workers complete the jobs and provide all received variables in the complete\n+job message. As a result the broker will write (and overwrite) all of those variables. When the\n+service task completes, its result is collected in the output collection variable, but this has\n+become a race condition where each completed job again overwrites this same variable. We end up with\n+a corrupted output collection.\n+\n+We recommend taking care when writing variables in a parallel flow. Make sure the variables are\n+written to the correct [variable scope](/reference/variables.html#variable-scopes) using variable\n+mappings and make sure to complete jobs and publish messages only with the minimum required\n+variables.\n+\n+Finally, note that a created workflow instance propagates all variables to its call activity.\n+Similar to job completion and message publication, this can lead to race conditions. This behavior\n+can be customized by defining output mappings at the call activity. The output mappings are applied\n+on completing the call activity.\n+", "originalCommit": "f38610f4fe3df574f87410c624a7f701fa1bf2bc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA3MTc2NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4979#discussion_r457071764", "bodyText": "I think we can highlight the solutions a bit more by listing them. For example:\n[...] these problems can be avoided by:\n* passing only updated variables  \n* using output variable mappings to customize the variable propagation\n* using an embedded subprocess and input variable mappings to limit the visibility and propagation of variables", "author": "saig0", "createdAt": "2020-07-20T05:44:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA2NTgxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0NjQzOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4979#discussion_r467046438", "bodyText": "I've tried to rewrite some parts to fit this request, but I'm having some trouble with it. Please let me know if you have any suggestions to improve it.", "author": "korthout", "createdAt": "2020-08-07T13:39:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA2NTgxOA=="}], "type": "inlineReview"}, {"oid": "e5773b87f0ae2575bf4ebbd0f5cbc7207a2e414a", "url": "https://github.com/camunda-cloud/zeebe/commit/e5773b87f0ae2575bf4ebbd0f5cbc7207a2e414a", "message": "docs(variables): apply reviews hints on race conditions", "committedDate": "2020-08-07T13:38:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg0NzczMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4979#discussion_r467847731", "bodyText": "Usually, I try to avoid talking about tokens \ud83d\ude05 We don't explain the concept of tokens in a central place. It is more a way of imaging the workflow execution than a real part of it.\nInstead of \"tokens\", you can use the term (active) \"activities\".", "author": "saig0", "createdAt": "2020-08-10T11:43:06Z", "path": "docs/src/bpmn-workflows/data-flow.md", "diffHunk": "@@ -1,29 +1,52 @@\n # Data Flow\n \n-Every BPMN workflow instance can have one or more variables. Variables are key-value-pairs and hold the contextual data of the workflow instance that is required by job workers to do their work. They can be provided when a workflow instance is created, when a job is completed, and when a message is correlated.\n+Every BPMN workflow instance can have one or more variables. Variables are key-value-pairs and hold\n+the contextual data of the workflow instance that is required by job workers to do their work or to\n+decide which sequence flows to take. They can be provided when a workflow instance is created, when\n+a job is completed, and when a message is correlated.\n \n ![data-flow](/bpmn-workflows/data-flow.png)\n \n ## Job Workers\n \n-By default, a job worker gets all variables of a workflow instance. It can limit the data by providing a list of required variables as *fetchVariables*.\n+By default, a job worker gets all variables of a workflow instance. It can limit the data by\n+providing a list of required variables as *fetchVariables*.\n \n-The worker uses the variables to do its work. When the work is done, it completes the job. If the result of the work is needed by follow-up tasks, then the worker set the variables while completing the job. These variables are merged into the workflow instance.\n+The worker uses the variables to do its work. When the work is done, it completes the job. If the\n+result of the work is needed by follow-up tasks, then the worker sets the variables while completing\n+the job. These variables are [merged](/reference/variables.html#variable-propagation) into the\n+workflow instance.\n \n ![job-worker](/bpmn-workflows/data-flow-job-worker.png)\n \n If the job worker expects the variables in a different format or under different names then the variables can be transformed by defining *input mappings* in the workflow. *Output mappings* can be used to transform the job variables before merging them into the workflow instance.\n \n ## Variable Scopes vs. Token-Based Data\n \n-A workflow can have concurrent paths, for example, when using a parallel gateway. When the execution reaches the parallel gateway then new tokens are spawned which executes the following paths concurrently.\n+A workflow can have concurrent paths, for example, when using a parallel gateway. When the execution reaches the parallel gateway then new tokens are spawned which execute the following paths concurrently.\n \n-Since the variables are part of the workflow instance and not of the token, they can be read globally from any token. If a token adds a variable or modifies the value of a variable then the changes are also visible to concurrent tokens.  \n+Since the variables are part of the workflow instance and not of the token, they can be read globally from any token. If a token adds a variable or modifies the value of a variable then the changes are also visible to concurrent tokens.\n \n ![variable-scopes](/bpmn-workflows/variable-scopes.png)\n \n The visibility of variables is defined by the *variable scopes* of the workflow.\n \n+## Concurrency considerations\n+When multiple tokens exist in a workflow instance (i.e. there is a form of concurrent execution,", "originalCommit": "e5773b87f0ae2575bf4ebbd0f5cbc7207a2e414a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg0OTgyMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4979#discussion_r467849822", "bodyText": "Foud one more message \ud83d\ude1c\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            by sending a fail job command. Fail job messages include a retries number. If this is a positive\n          \n          \n            \n            by sending a fail job command. Fail job commands include the number of remaining retries. If this is a positive", "author": "saig0", "createdAt": "2020-08-10T11:47:58Z", "path": "docs/src/basics/job-workers.md", "diffHunk": "@@ -64,17 +64,19 @@ Zeebe decouples creation of jobs from performing the work on them. It is always\n This allows the broker to handle bursts of traffic and effectively act as a _buffer_ in front of the job workers.\n \n ## Completing and Failing Jobs\n-After working on an activated job, a job worker should send a complete or fail message to the\n-broker. If the job is not completed within the configured job activation timeout then the broker\n-will make the job available again to other job workers.\n+After working on an activated job, a job worker can inform the broker that the job has either been\n+completed or failed. If the job worker could successfully complete its work, it can inform the\n+broker of this success by sending a complete job command. If the job could not be completed within\n+the configured job activation timeout, then the broker will make the job available again to other\n+job workers.\n \n-In order to expose the results of the job, the job worker can pass variables with the complete command. These variables will be merged into the workflow instance depending on the output variable mapping. \n-Note that this may overwrite existing variables and can lead to race conditions in\n-parallel flows. We recommend completing jobs with only those variables that need to be\n-changed.\n+In order to expose the results of the job, the job worker can pass variables with the complete job\n+command. These variables will be merged into the workflow instance depending on the output variable\n+mapping. Note that this may overwrite existing variables and can lead to race conditions in\n+parallel flows. We recommend completing jobs with only those variables that need to be changed.\n \n If the job worker could not successfully complete its work, it can inform the broker of this failure\n-by sending a fail job message. Fail job messages can be sent including a retries number. If this is\n-a positive number then the job will be immediately activatable again, and a worker could try to\n-process it again. If it is zero or negative however, an incident will be raised and the job will not\n-be activatable until the incident is resolved.\n+by sending a fail job command. Fail job messages include a retries number. If this is a positive", "originalCommit": "ad83a6c0288d3ed8e5d5d173011f70690fd8c534", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f7bc6cb723d0ef222ac2df953d6f4e3c2fd7b1f7", "url": "https://github.com/camunda-cloud/zeebe/commit/f7bc6cb723d0ef222ac2df953d6f4e3c2fd7b1f7", "message": "docs(forks): add concurrency considerations\n\nThis commit adds additional descriptions on how to deal with parallel\nflows in workflows, considering race conditions. These are especially\nimportant when dealing with call-activities, because they merge all\nvariables the child instance contains into the parent instance (but the\nchild also starts with all variables the parent has, so if the parent\nmakes changes this is a race condition), so always make sure to use\noutput mapping on a parallelised call activity.", "committedDate": "2020-08-17T07:37:09Z", "type": "forcePushed"}, {"oid": "9bb3ad3ff36c7131afeaf34d5ebe087070709153", "url": "https://github.com/camunda-cloud/zeebe/commit/9bb3ad3ff36c7131afeaf34d5ebe087070709153", "message": "docs(forks): add concurrency considerations\n\nThis commit adds additional descriptions on how to deal with parallel\nflows in workflows, considering race conditions. These are especially\nimportant when dealing with call-activities, because they merge all\nvariables the child instance contains into the parent instance (but the\nchild also starts with all variables the parent has, so if the parent\nmakes changes this is a race condition), so always make sure to use\noutput mapping on a parallelised call activity.", "committedDate": "2020-08-17T07:43:14Z", "type": "commit"}, {"oid": "9bb3ad3ff36c7131afeaf34d5ebe087070709153", "url": "https://github.com/camunda-cloud/zeebe/commit/9bb3ad3ff36c7131afeaf34d5ebe087070709153", "message": "docs(forks): add concurrency considerations\n\nThis commit adds additional descriptions on how to deal with parallel\nflows in workflows, considering race conditions. These are especially\nimportant when dealing with call-activities, because they merge all\nvariables the child instance contains into the parent instance (but the\nchild also starts with all variables the parent has, so if the parent\nmakes changes this is a race condition), so always make sure to use\noutput mapping on a parallelised call activity.", "committedDate": "2020-08-17T07:43:14Z", "type": "forcePushed"}]}