{"pr_number": 4603, "pr_title": "Migrate intermediate catch event processor", "pr_createdAt": "2020-05-26T13:20:21Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/4603", "timeline": [{"oid": "c8e4057fd06d7629f122c32148fd789e33e81c0a", "url": "https://github.com/camunda-cloud/zeebe/commit/c8e4057fd06d7629f122c32148fd789e33e81c0a", "message": "chore(engine): refactor message name extraction move incident raising\n\nThis commit moves incident raising away from the expression processor\nand into the place where the the expression processor is being used.", "committedDate": "2020-05-26T14:31:58Z", "type": "commit"}, {"oid": "98af34f729c3908e0aef300ef278f5313c58f2bd", "url": "https://github.com/camunda-cloud/zeebe/commit/98af34f729c3908e0aef300ef278f5313c58f2bd", "message": "chore(engine): migrate intermediate catch event processor", "committedDate": "2020-05-26T14:32:46Z", "type": "forcePushed"}, {"oid": "701f0a5934d3a56b5886e2582d5e93877aa887d7", "url": "https://github.com/camunda-cloud/zeebe/commit/701f0a5934d3a56b5886e2582d5e93877aa887d7", "message": "chore(engine): migrate intermediate catch event processor", "committedDate": "2020-05-26T14:45:21Z", "type": "forcePushed"}, {"oid": "98a3d8e4378fba7267305520ef12a7c910cab0cf", "url": "https://github.com/camunda-cloud/zeebe/commit/98a3d8e4378fba7267305520ef12a7c910cab0cf", "message": "chore(engine): migrate intermediate catch event processor", "committedDate": "2020-05-26T14:45:42Z", "type": "commit"}, {"oid": "98a3d8e4378fba7267305520ef12a7c910cab0cf", "url": "https://github.com/camunda-cloud/zeebe/commit/98a3d8e4378fba7267305520ef12a7c910cab0cf", "message": "chore(engine): migrate intermediate catch event processor", "committedDate": "2020-05-26T14:45:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg2MjkxOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4603#discussion_r430862918", "bodyText": "Should we discuss this point? Or, is everything clear? :)", "author": "saig0", "createdAt": "2020-05-27T05:21:24Z", "path": "engine/src/main/java/io/zeebe/engine/processor/workflow/handlers/CatchEventSubscriber.java", "diffHunk": "@@ -35,9 +35,10 @@ public CatchEventSubscriber(final CatchEventBehavior catchEventBehavior) {\n       context.raiseIncident(ErrorType.EXTRACT_VALUE_ERROR, e.getMessage());\n       return false;\n     } catch (final MessageNameException e) {\n-      // incident was already raised internally; processing was interrupted at the point the\n-      // exception was thrown; no further processing shall take place, that's why we return false\n-      // here\n+      // processing was interrupted at the point the exception was thrown; no further processing\n+      // shall take place, that's why we return false here\n+      // todo verify that this is the correct level to raise the incident at", "originalCommit": "98a3d8e4378fba7267305520ef12a7c910cab0cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAzNjM5MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4603#discussion_r431036391", "bodyText": "It's not clear for me yet. The current implementation uses the 'normal' elementInstanceKey as scopeKey, but the MessageCorrelationKeyException is raising an incident at the variablesScopeKey level. Why is this is different?", "author": "korthout", "createdAt": "2020-05-27T11:07:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg2MjkxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA0OTM2OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4603#discussion_r431049369", "bodyText": "Good question. I guess that we should have the same logic for every expression. Maybe, we forgot something.", "author": "saig0", "createdAt": "2020-05-27T11:33:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg2MjkxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg2NzcwMA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4603#discussion_r430867700", "bodyText": "Nope. An intermediate catch event may not have a boundary event attached to it \ud83d\ude01", "author": "saig0", "createdAt": "2020-05-27T05:38:15Z", "path": "engine/src/main/java/io/zeebe/engine/nwe/event/IntermediateCatchEventProcessor.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe.event;\n+\n+import io.zeebe.engine.nwe.BpmnElementContext;\n+import io.zeebe.engine.nwe.BpmnElementProcessor;\n+import io.zeebe.engine.nwe.behavior.BpmnBehaviors;\n+import io.zeebe.engine.nwe.behavior.BpmnEventSubscriptionBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnIncidentBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnStateBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnStateTransitionBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnVariableMappingBehavior;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableCatchEventElement;\n+\n+public class IntermediateCatchEventProcessor\n+    implements BpmnElementProcessor<ExecutableCatchEventElement> {\n+\n+  private final BpmnEventSubscriptionBehavior eventSubscriptionBehavior;\n+  private final BpmnIncidentBehavior incidentBehavior;\n+  private final BpmnStateBehavior stateBehavior;\n+  private final BpmnStateTransitionBehavior stateTransitionBehavior;\n+  private final BpmnVariableMappingBehavior variableMappingBehavior;\n+\n+  public IntermediateCatchEventProcessor(final BpmnBehaviors bpmnBehaviors) {\n+    eventSubscriptionBehavior = bpmnBehaviors.eventSubscriptionBehavior();\n+    incidentBehavior = bpmnBehaviors.incidentBehavior();\n+    stateBehavior = bpmnBehaviors.stateBehavior();\n+    stateTransitionBehavior = bpmnBehaviors.stateTransitionBehavior();\n+    variableMappingBehavior = bpmnBehaviors.variableMappingBehavior();\n+  }\n+\n+  @Override\n+  public Class<ExecutableCatchEventElement> getType() {\n+    return ExecutableCatchEventElement.class;\n+  }\n+\n+  @Override\n+  public void onActivating(\n+      final ExecutableCatchEventElement element, final BpmnElementContext context) {\n+    variableMappingBehavior\n+        .applyInputMappings(context, element)\n+        .flatMap(ok -> eventSubscriptionBehavior.subscribeToEvents(element, context))\n+        .ifRightOrLeft(\n+            ok -> stateTransitionBehavior.transitionToActivated(context),\n+            failure -> incidentBehavior.createIncident(failure, context));\n+  }\n+\n+  @Override\n+  public void onActivated(\n+      final ExecutableCatchEventElement element, final BpmnElementContext context) {\n+    if (element.isNone()) {\n+      stateTransitionBehavior.transitionToCompleting(context);\n+    }\n+  }\n+\n+  @Override\n+  public void onCompleting(\n+      final ExecutableCatchEventElement element, final BpmnElementContext context) {\n+    variableMappingBehavior\n+        .applyOutputMappings(context, element)\n+        .ifRightOrLeft(\n+            ok -> {\n+              eventSubscriptionBehavior.unsubscribeFromEvents(context);\n+              stateTransitionBehavior.transitionToCompleted(context);\n+            },\n+            failure -> incidentBehavior.createIncident(failure, context));\n+  }\n+\n+  @Override\n+  public void onCompleted(\n+      final ExecutableCatchEventElement element, final BpmnElementContext context) {\n+    stateTransitionBehavior.takeOutgoingSequenceFlows(element, context);\n+    stateBehavior.consumeToken(context);\n+    stateBehavior.removeElementInstance(context);\n+  }\n+\n+  @Override\n+  public void onTerminating(\n+      final ExecutableCatchEventElement element, final BpmnElementContext context) {\n+    eventSubscriptionBehavior.unsubscribeFromEvents(context);\n+    stateTransitionBehavior.transitionToTerminated(context);\n+  }\n+\n+  @Override\n+  public void onTerminated(\n+      final ExecutableCatchEventElement element, final BpmnElementContext context) {\n+    eventSubscriptionBehavior.publishTriggeredBoundaryEvent(context);", "originalCommit": "98a3d8e4378fba7267305520ef12a7c910cab0cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg2OTYzNQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4603#discussion_r430869635", "bodyText": "I think we should take the transition to completing only if the event was triggered (i.e. the event trigger was found in triggerIntermediateEvent).", "author": "saig0", "createdAt": "2020-05-27T05:44:39Z", "path": "engine/src/main/java/io/zeebe/engine/nwe/event/IntermediateCatchEventProcessor.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe.event;\n+\n+import io.zeebe.engine.nwe.BpmnElementContext;\n+import io.zeebe.engine.nwe.BpmnElementProcessor;\n+import io.zeebe.engine.nwe.behavior.BpmnBehaviors;\n+import io.zeebe.engine.nwe.behavior.BpmnEventSubscriptionBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnIncidentBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnStateBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnStateTransitionBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnVariableMappingBehavior;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableCatchEventElement;\n+\n+public class IntermediateCatchEventProcessor\n+    implements BpmnElementProcessor<ExecutableCatchEventElement> {\n+\n+  private final BpmnEventSubscriptionBehavior eventSubscriptionBehavior;\n+  private final BpmnIncidentBehavior incidentBehavior;\n+  private final BpmnStateBehavior stateBehavior;\n+  private final BpmnStateTransitionBehavior stateTransitionBehavior;\n+  private final BpmnVariableMappingBehavior variableMappingBehavior;\n+\n+  public IntermediateCatchEventProcessor(final BpmnBehaviors bpmnBehaviors) {\n+    eventSubscriptionBehavior = bpmnBehaviors.eventSubscriptionBehavior();\n+    incidentBehavior = bpmnBehaviors.incidentBehavior();\n+    stateBehavior = bpmnBehaviors.stateBehavior();\n+    stateTransitionBehavior = bpmnBehaviors.stateTransitionBehavior();\n+    variableMappingBehavior = bpmnBehaviors.variableMappingBehavior();\n+  }\n+\n+  @Override\n+  public Class<ExecutableCatchEventElement> getType() {\n+    return ExecutableCatchEventElement.class;\n+  }\n+\n+  @Override\n+  public void onActivating(\n+      final ExecutableCatchEventElement element, final BpmnElementContext context) {\n+    variableMappingBehavior\n+        .applyInputMappings(context, element)\n+        .flatMap(ok -> eventSubscriptionBehavior.subscribeToEvents(element, context))\n+        .ifRightOrLeft(\n+            ok -> stateTransitionBehavior.transitionToActivated(context),\n+            failure -> incidentBehavior.createIncident(failure, context));\n+  }\n+\n+  @Override\n+  public void onActivated(\n+      final ExecutableCatchEventElement element, final BpmnElementContext context) {\n+    if (element.isNone()) {\n+      stateTransitionBehavior.transitionToCompleting(context);\n+    }\n+  }\n+\n+  @Override\n+  public void onCompleting(\n+      final ExecutableCatchEventElement element, final BpmnElementContext context) {\n+    variableMappingBehavior\n+        .applyOutputMappings(context, element)\n+        .ifRightOrLeft(\n+            ok -> {\n+              eventSubscriptionBehavior.unsubscribeFromEvents(context);\n+              stateTransitionBehavior.transitionToCompleted(context);\n+            },\n+            failure -> incidentBehavior.createIncident(failure, context));\n+  }\n+\n+  @Override\n+  public void onCompleted(\n+      final ExecutableCatchEventElement element, final BpmnElementContext context) {\n+    stateTransitionBehavior.takeOutgoingSequenceFlows(element, context);\n+    stateBehavior.consumeToken(context);\n+    stateBehavior.removeElementInstance(context);\n+  }\n+\n+  @Override\n+  public void onTerminating(\n+      final ExecutableCatchEventElement element, final BpmnElementContext context) {\n+    eventSubscriptionBehavior.unsubscribeFromEvents(context);\n+    stateTransitionBehavior.transitionToTerminated(context);\n+  }\n+\n+  @Override\n+  public void onTerminated(\n+      final ExecutableCatchEventElement element, final BpmnElementContext context) {\n+    eventSubscriptionBehavior.publishTriggeredBoundaryEvent(context);\n+    incidentBehavior.resolveIncidents(context);\n+    stateTransitionBehavior.onElementTerminated(element, context);\n+    stateBehavior.consumeToken(context);\n+  }\n+\n+  @Override\n+  public void onEventOccurred(\n+      final ExecutableCatchEventElement element, final BpmnElementContext context) {\n+    eventSubscriptionBehavior.triggerIntermediateEvent(context);\n+    stateTransitionBehavior.transitionToCompleting(context);", "originalCommit": "98a3d8e4378fba7267305520ef12a7c910cab0cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg3MTE1OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4603#discussion_r430871159", "bodyText": "An intermediate catch event must have an event definition. I don't see a case when it has no event definition and we complete it immediately. I know it comes from the existing code but I have no idea why \ud83d\ude05\nLet's remove it if you agree.", "author": "saig0", "createdAt": "2020-05-27T05:49:41Z", "path": "engine/src/main/java/io/zeebe/engine/nwe/event/IntermediateCatchEventProcessor.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe.event;\n+\n+import io.zeebe.engine.nwe.BpmnElementContext;\n+import io.zeebe.engine.nwe.BpmnElementProcessor;\n+import io.zeebe.engine.nwe.behavior.BpmnBehaviors;\n+import io.zeebe.engine.nwe.behavior.BpmnEventSubscriptionBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnIncidentBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnStateBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnStateTransitionBehavior;\n+import io.zeebe.engine.nwe.behavior.BpmnVariableMappingBehavior;\n+import io.zeebe.engine.processor.workflow.deployment.model.element.ExecutableCatchEventElement;\n+\n+public class IntermediateCatchEventProcessor\n+    implements BpmnElementProcessor<ExecutableCatchEventElement> {\n+\n+  private final BpmnEventSubscriptionBehavior eventSubscriptionBehavior;\n+  private final BpmnIncidentBehavior incidentBehavior;\n+  private final BpmnStateBehavior stateBehavior;\n+  private final BpmnStateTransitionBehavior stateTransitionBehavior;\n+  private final BpmnVariableMappingBehavior variableMappingBehavior;\n+\n+  public IntermediateCatchEventProcessor(final BpmnBehaviors bpmnBehaviors) {\n+    eventSubscriptionBehavior = bpmnBehaviors.eventSubscriptionBehavior();\n+    incidentBehavior = bpmnBehaviors.incidentBehavior();\n+    stateBehavior = bpmnBehaviors.stateBehavior();\n+    stateTransitionBehavior = bpmnBehaviors.stateTransitionBehavior();\n+    variableMappingBehavior = bpmnBehaviors.variableMappingBehavior();\n+  }\n+\n+  @Override\n+  public Class<ExecutableCatchEventElement> getType() {\n+    return ExecutableCatchEventElement.class;\n+  }\n+\n+  @Override\n+  public void onActivating(\n+      final ExecutableCatchEventElement element, final BpmnElementContext context) {\n+    variableMappingBehavior\n+        .applyInputMappings(context, element)\n+        .flatMap(ok -> eventSubscriptionBehavior.subscribeToEvents(element, context))\n+        .ifRightOrLeft(\n+            ok -> stateTransitionBehavior.transitionToActivated(context),\n+            failure -> incidentBehavior.createIncident(failure, context));\n+  }\n+\n+  @Override\n+  public void onActivated(\n+      final ExecutableCatchEventElement element, final BpmnElementContext context) {\n+    if (element.isNone()) {\n+      stateTransitionBehavior.transitionToCompleting(context);\n+    }\n+  }", "originalCommit": "98a3d8e4378fba7267305520ef12a7c910cab0cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4NTQ0OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4603#discussion_r430985448", "bodyText": "Ah, I was unaware we didn't allow these. I'd argue that there are use cases for a none intermediate catch event (e.g. milestone events). But allowing those is out of the scope of these changes. Should I create a new issue for this or is there a clear reason why we don't allow none intermediate catch events? I was unable to find GH issues about this topic.", "author": "korthout", "createdAt": "2020-05-27T09:33:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg3MTE1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA0ODI5MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4603#discussion_r431048290", "bodyText": "I guess you mean the none throw event \ud83d\ude1c\nI see no reason why we should not implement it. I guess that nobody asked for it yet.", "author": "saig0", "createdAt": "2020-05-27T11:31:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg3MTE1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg3MzEwOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4603#discussion_r430873109", "bodyText": "Good catch \ud83d\udc4d", "author": "saig0", "createdAt": "2020-05-27T05:55:43Z", "path": "engine/src/main/java/io/zeebe/engine/nwe/behavior/BpmnEventSubscriptionBehavior.java", "diffHunk": "@@ -238,6 +256,8 @@ private void activateBoundaryEvent(\n       return Either.left(\n           new Failure(\n               e.getMessage(), ErrorType.EXTRACT_VALUE_ERROR, context.getElementInstanceKey()));\n+    } catch (final MessageNameException e) {\n+      return Either.left(e.getFailure());", "originalCommit": "98a3d8e4378fba7267305520ef12a7c910cab0cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "721d6f5e0a2b706962d41ca1792dab06c00ade8e", "url": "https://github.com/camunda-cloud/zeebe/commit/721d6f5e0a2b706962d41ca1792dab06c00ade8e", "message": "chore(engine): apply review comments", "committedDate": "2020-05-27T11:04:58Z", "type": "commit"}, {"oid": "98d84ce2c77d89d582450ce031b5db2c83ca67d5", "url": "https://github.com/camunda-cloud/zeebe/commit/98d84ce2c77d89d582450ce031b5db2c83ca67d5", "message": "chore(engine): apply another review comment", "committedDate": "2020-05-27T14:31:16Z", "type": "commit"}]}