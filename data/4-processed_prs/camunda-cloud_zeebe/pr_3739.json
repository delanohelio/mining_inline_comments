{"pr_number": 3739, "pr_title": "chore(broker): distribute broker version in topology", "pr_createdAt": "2020-01-27T13:58:18Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/3739", "timeline": [{"oid": "14388190ad289364d9cc48b879ef43772617ed28", "url": "https://github.com/camunda-cloud/zeebe/commit/14388190ad289364d9cc48b879ef43772617ed28", "message": "chore(broker): distribute broker version in topology", "committedDate": "2020-01-27T14:26:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc1NTA0MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/3739#discussion_r371755040", "bodyText": "Hm, feels strange to have side effects of putting things in other objects as part of the compute if absent, no? Seems a little unexpected.", "author": "npepinpe", "createdAt": "2020-01-28T11:46:30Z", "path": "gateway/src/main/java/io/zeebe/gateway/impl/broker/cluster/BrokerClusterStateImpl.java", "diffHunk": "@@ -76,20 +79,26 @@ public void addPartitionIfAbsent(final int partitionId) {\n   }\n \n   public void addBrokerIfAbsent(final int nodeId) {\n-    if (brokerAddresses.get(nodeId) == null) {\n-      brokerAddresses.put(nodeId, \"\");\n-      brokers.addInt(nodeId);\n-    }\n+    brokerAddresses.computeIfAbsent(", "originalCommit": "14388190ad289364d9cc48b879ef43772617ed28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgwMjcyNw==", "url": "https://github.com/camunda-cloud/zeebe/pull/3739#discussion_r371802727", "bodyText": "I get what you mean. It doesn't bother me too much, but maybe it's because I'm the one who did it. I'll revert it", "author": "MiguelPires", "createdAt": "2020-01-28T13:32:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc1NTA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc5MDg2OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/3739#discussion_r371790868", "bodyText": "I think with bodyDecoder.wrapVersion() we don't need to keep track of the offset. The whole method can be replaced by:\n@Override\n  public void wrap(final DirectBuffer buffer, int offset, final int length) {\n    reset();\n\n    final int frameEnd = offset + length;\n\n    headerDecoder.wrap(buffer, offset);\n    bodyDecoder.wrap(\n        buffer,\n        offset + headerDecoder.encodedLength(),\n        headerDecoder.blockLength(),\n        headerDecoder.version());\n\n    nodeId = bodyDecoder.nodeId();\n    partitionsCount = bodyDecoder.partitionsCount();\n    clusterSize = bodyDecoder.clusterSize();\n    replicationFactor = bodyDecoder.replicationFactor();\n\n    final AddressesDecoder addressesDecoder = bodyDecoder.addresses();\n    while (addressesDecoder.hasNext()) {\n      addressesDecoder.next();\n      final int apiNameLength = addressesDecoder.apiNameLength();\n      final byte[] apiNameBytes = new byte[apiNameLength];\n      addressesDecoder.getApiName(apiNameBytes, 0, apiNameLength);\n\n      final int addressLength = addressesDecoder.addressLength();\n      final byte[] addressBytes = new byte[addressLength];\n      addressesDecoder.getAddress(addressBytes, 0, addressLength);\n\n      this.addAddress(new UnsafeBuffer(apiNameBytes), new UnsafeBuffer(addressBytes));\n    }\n\n    final PartitionRolesDecoder partitionRolesDecoder = bodyDecoder.partitionRoles();\n    while (partitionRolesDecoder.hasNext()) {\n      partitionRolesDecoder.next();\n      this.addPartitionRole(partitionRolesDecoder.partitionId(), partitionRolesDecoder.role());\n    }\n\n    final PartitionLeaderTermsDecoder partitionLeaderTermsDecoder =\n        bodyDecoder.partitionLeaderTerms();\n    while (partitionLeaderTermsDecoder.hasNext()) {\n      partitionLeaderTermsDecoder.next();\n      this.partitionLeaderTerms.put(\n          partitionLeaderTermsDecoder.partitionId(), partitionLeaderTermsDecoder.term());\n    }\n\n    if (bodyDecoder.versionLength() > 0) {\n      bodyDecoder.wrapVersion(version);\n    } else {\n      bodyDecoder.skipVersion();\n    }\n\n    assert bodyDecoder.limit() == frameEnd\n        : \"Decoder read only to position \"\n            + bodyDecoder.limit()\n            + \" but expected \"\n            + frameEnd\n            + \" as final position\";\n  }", "author": "npepinpe", "createdAt": "2020-01-28T13:08:50Z", "path": "protocol-impl/src/main/java/io/zeebe/protocol/impl/encoding/BrokerInfo.java", "diffHunk": "@@ -209,22 +227,40 @@ public void wrap(final DirectBuffer buffer, int offset, final int length) {\n       addressesDecoder.getAddress(addressBytes, 0, addressLength);\n \n       this.addAddress(new UnsafeBuffer(apiNameBytes), new UnsafeBuffer(addressBytes));\n+      offset +=\n+          AddressesDecoder.apiNameHeaderLength()\n+              + apiNameLength\n+              + AddressesDecoder.addressHeaderLength()\n+              + addressLength;\n     }\n \n+    offset += PartitionRolesDecoder.sbeHeaderSize();\n     final PartitionRolesDecoder partitionRolesDecoder = bodyDecoder.partitionRoles();\n     while (partitionRolesDecoder.hasNext()) {\n       partitionRolesDecoder.next();\n       this.addPartitionRole(partitionRolesDecoder.partitionId(), partitionRolesDecoder.role());\n+      offset += 4 + 1;\n     }\n \n+    offset += PartitionLeaderTermsDecoder.sbeHeaderSize();\n     final PartitionLeaderTermsDecoder partitionLeaderTermsDecoder =\n         bodyDecoder.partitionLeaderTerms();\n     while (partitionLeaderTermsDecoder.hasNext()) {\n       partitionLeaderTermsDecoder.next();\n       this.partitionLeaderTerms.put(\n           partitionLeaderTermsDecoder.partitionId(), partitionLeaderTermsDecoder.term());\n+      offset += 4 + 8;\n     }\n \n+    final int versionLength = bodyDecoder.versionLength();", "originalCommit": "14388190ad289364d9cc48b879ef43772617ed28", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgwNjE2NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/3739#discussion_r371806165", "bodyText": "Missing brokerVersions.put(nodeId, \"\")?", "author": "npepinpe", "createdAt": "2020-01-28T13:39:10Z", "path": "gateway/src/main/java/io/zeebe/gateway/impl/broker/cluster/BrokerClusterStateImpl.java", "diffHunk": "@@ -79,13 +79,10 @@ public void addPartitionIfAbsent(final int partitionId) {\n   }\n \n   public void addBrokerIfAbsent(final int nodeId) {\n-    brokerAddresses.computeIfAbsent(\n-        nodeId,\n-        k -> {\n-          brokerVersions.put(nodeId, \"\");\n-          brokers.addInt(nodeId);\n-          return \"\";\n-        });\n+    if (brokerAddresses.get(nodeId) == null) {\n+      brokerAddresses.put(nodeId, \"\");\n+      brokers.addInt(nodeId);", "originalCommit": "4f20325d48eddce5493013b861d281059bfe8d7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgwODc5OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/3739#discussion_r371808798", "bodyText": "Yup, missed it when rolling back. Thanks", "author": "MiguelPires", "createdAt": "2020-01-28T13:44:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgwNjE2NQ=="}], "type": "inlineReview"}, {"oid": "ceeea9bdadff934000365d539e8350147f8dd453", "url": "https://github.com/camunda-cloud/zeebe/commit/ceeea9bdadff934000365d539e8350147f8dd453", "message": "chore(broker): distribute broker version in topology", "committedDate": "2020-01-28T13:44:28Z", "type": "commit"}, {"oid": "ceeea9bdadff934000365d539e8350147f8dd453", "url": "https://github.com/camunda-cloud/zeebe/commit/ceeea9bdadff934000365d539e8350147f8dd453", "message": "chore(broker): distribute broker version in topology", "committedDate": "2020-01-28T13:44:28Z", "type": "forcePushed"}]}