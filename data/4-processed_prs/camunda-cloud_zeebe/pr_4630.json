{"pr_number": 4630, "pr_title": "chore(engine): migrate process processor", "pr_createdAt": "2020-05-29T05:42:08Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/4630", "timeline": [{"oid": "3e3b2cb22fa776e673e40d86b27f4afad8d6b6f3", "url": "https://github.com/camunda-cloud/zeebe/commit/3e3b2cb22fa776e673e40d86b27f4afad8d6b6f3", "message": "chore(engine): migrate process processor\n\n* migrate workflow result sender behavior\n* migrate message start event correlation behavior\n* remove unused handlers\n* introduce new exception type for workflow processing", "committedDate": "2020-05-29T08:01:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc0ODc1Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4630#discussion_r433748753", "bodyText": "Is messageCorrelation here truly something \"Optional\"? Even if, this is not a recommended use case for Optional. I suggest to unravel this to some imperative construct and returning the corresponding Optional in the if-else branches.", "author": "korthout", "createdAt": "2020-06-02T09:37:29Z", "path": "engine/src/main/java/io/zeebe/engine/nwe/behavior/BpmnBufferedMessageStartEventBehavior.java", "diffHunk": "@@ -111,21 +109,15 @@ private Correlation findNextMessageToCorrelate(\n       }\n     }\n \n-    return messageCorrelation.elementId != null ? messageCorrelation : null;\n+    return Optional.of(messageCorrelation).filter(correlation -> correlation.elementId != null);", "originalCommit": "3e3b2cb22fa776e673e40d86b27f4afad8d6b6f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc1MjM1OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4630#discussion_r433752358", "bodyText": "I like it \ud83e\udd47", "author": "korthout", "createdAt": "2020-06-02T09:43:37Z", "path": "engine/src/main/java/io/zeebe/engine/nwe/behavior/BpmnStateTransitionBehavior.java", "diffHunk": "@@ -109,18 +91,30 @@ public void transitionToTerminated(final BpmnElementContext context) {\n     metrics.elementInstanceTerminated(context.getBpmnElementType());\n   }\n \n-  private void transitionTo(final BpmnElementContext context, final WorkflowInstanceIntent intent) {\n+  private void transitionTo(\n+      final BpmnElementContext context, final WorkflowInstanceIntent transition) {\n+\n+    verifyTransition(context, transition);\n+\n     streamWriter.appendFollowUpEvent(\n-        context.getElementInstanceKey(), intent, context.getRecordValue());\n+        context.getElementInstanceKey(), transition, context.getRecordValue());\n+  }\n+\n+  private void verifyTransition(\n+      final BpmnElementContext context, final WorkflowInstanceIntent transition) {\n+\n+    if (!WorkflowInstanceLifecycle.canTransition(context.getIntent(), transition)) {", "originalCommit": "3e3b2cb22fa776e673e40d86b27f4afad8d6b6f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc1NDIyNQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4630#discussion_r433754225", "bodyText": "Do we still need to flush? I saw some flushes defined in some lambda's during this review. Perhaps they are different, but it was not immediately clear to me.", "author": "korthout", "createdAt": "2020-06-02T09:46:58Z", "path": "engine/src/main/java/io/zeebe/engine/nwe/behavior/BpmnWorkflowResultSenderBehavior.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe.behavior;\n+\n+import io.zeebe.engine.nwe.BpmnElementContext;\n+import io.zeebe.engine.nwe.BpmnProcessingException;\n+import io.zeebe.engine.processor.TypedResponseWriter;\n+import io.zeebe.engine.state.ZeebeState;\n+import io.zeebe.engine.state.instance.AwaitWorkflowInstanceResultMetadata;\n+import io.zeebe.engine.state.instance.ElementInstanceState;\n+import io.zeebe.engine.state.instance.VariablesState;\n+import io.zeebe.protocol.impl.record.value.workflowinstance.WorkflowInstanceResultRecord;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceResultIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.util.buffer.BufferUtil;\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.agrona.DirectBuffer;\n+\n+public final class BpmnWorkflowResultSenderBehavior {\n+\n+  private final WorkflowInstanceResultRecord resultRecord = new WorkflowInstanceResultRecord();\n+\n+  private final ElementInstanceState elementInstanceState;\n+  private final VariablesState variablesState;\n+  private final TypedResponseWriter responseWriter;\n+\n+  public BpmnWorkflowResultSenderBehavior(\n+      final ZeebeState zeebeState, final TypedResponseWriter responseWriter) {\n+    elementInstanceState = zeebeState.getWorkflowState().getElementInstanceState();\n+    variablesState = elementInstanceState.getVariablesState();\n+    this.responseWriter = responseWriter;\n+  }\n+\n+  public void sendResult(final BpmnElementContext context) {\n+\n+    if (context.getBpmnElementType() != BpmnElementType.PROCESS) {\n+      throw new BpmnProcessingException(\n+          context,\n+          \"Expected to send the result of the workflow instance but was not called from the process element\");\n+    }\n+\n+    final AwaitWorkflowInstanceResultMetadata requestMetadata =\n+        elementInstanceState.getAwaitResultRequestMetadata(context.getWorkflowInstanceKey());\n+\n+    if (requestMetadata != null) {\n+      sendResult(context, requestMetadata);\n+    }\n+  }\n+\n+  private void sendResult(\n+      final BpmnElementContext context, final AwaitWorkflowInstanceResultMetadata requestMetadata) {\n+\n+    final DirectBuffer variablesAsDocument = collectVariables(context, requestMetadata);\n+\n+    resultRecord\n+        .setWorkflowInstanceKey(context.getWorkflowInstanceKey())\n+        .setWorkflowKey(context.getWorkflowKey())\n+        .setBpmnProcessId(context.getBpmnProcessId())\n+        .setVersion(context.getWorkflowVersion())\n+        .setVariables(variablesAsDocument);\n+\n+    responseWriter.writeResponse(\n+        context.getWorkflowInstanceKey(),\n+        WorkflowInstanceResultIntent.COMPLETED,\n+        resultRecord,\n+        ValueType.WORKFLOW_INSTANCE_RESULT,\n+        requestMetadata.getRequestId(),\n+        requestMetadata.getRequestStreamId());\n+\n+    responseWriter.flush();", "originalCommit": "3e3b2cb22fa776e673e40d86b27f4afad8d6b6f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMxMDg0OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4630#discussion_r434310848", "bodyText": "This is currently the way. But we could do the flush also implicitly every time. \ud83e\udd14", "author": "saig0", "createdAt": "2020-06-03T05:09:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc1NDIyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM0NTA1MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4630#discussion_r434345050", "bodyText": "I prefer explicit over implicit", "author": "korthout", "createdAt": "2020-06-03T06:52:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc1NDIyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc1ODQ0MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4630#discussion_r433758440", "bodyText": "Does this fetch the variables twice? If so, I think it would be more performant and readable to just iterate with forEach and afterwards check if the result (variablesToCollect) is empty.", "author": "korthout", "createdAt": "2020-06-02T09:54:20Z", "path": "engine/src/main/java/io/zeebe/engine/nwe/behavior/BpmnWorkflowResultSenderBehavior.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe.behavior;\n+\n+import io.zeebe.engine.nwe.BpmnElementContext;\n+import io.zeebe.engine.nwe.BpmnProcessingException;\n+import io.zeebe.engine.processor.TypedResponseWriter;\n+import io.zeebe.engine.state.ZeebeState;\n+import io.zeebe.engine.state.instance.AwaitWorkflowInstanceResultMetadata;\n+import io.zeebe.engine.state.instance.ElementInstanceState;\n+import io.zeebe.engine.state.instance.VariablesState;\n+import io.zeebe.protocol.impl.record.value.workflowinstance.WorkflowInstanceResultRecord;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceResultIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.util.buffer.BufferUtil;\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.agrona.DirectBuffer;\n+\n+public final class BpmnWorkflowResultSenderBehavior {\n+\n+  private final WorkflowInstanceResultRecord resultRecord = new WorkflowInstanceResultRecord();\n+\n+  private final ElementInstanceState elementInstanceState;\n+  private final VariablesState variablesState;\n+  private final TypedResponseWriter responseWriter;\n+\n+  public BpmnWorkflowResultSenderBehavior(\n+      final ZeebeState zeebeState, final TypedResponseWriter responseWriter) {\n+    elementInstanceState = zeebeState.getWorkflowState().getElementInstanceState();\n+    variablesState = elementInstanceState.getVariablesState();\n+    this.responseWriter = responseWriter;\n+  }\n+\n+  public void sendResult(final BpmnElementContext context) {\n+\n+    if (context.getBpmnElementType() != BpmnElementType.PROCESS) {\n+      throw new BpmnProcessingException(\n+          context,\n+          \"Expected to send the result of the workflow instance but was not called from the process element\");\n+    }\n+\n+    final AwaitWorkflowInstanceResultMetadata requestMetadata =\n+        elementInstanceState.getAwaitResultRequestMetadata(context.getWorkflowInstanceKey());\n+\n+    if (requestMetadata != null) {\n+      sendResult(context, requestMetadata);\n+    }\n+  }\n+\n+  private void sendResult(\n+      final BpmnElementContext context, final AwaitWorkflowInstanceResultMetadata requestMetadata) {\n+\n+    final DirectBuffer variablesAsDocument = collectVariables(context, requestMetadata);\n+\n+    resultRecord\n+        .setWorkflowInstanceKey(context.getWorkflowInstanceKey())\n+        .setWorkflowKey(context.getWorkflowKey())\n+        .setBpmnProcessId(context.getBpmnProcessId())\n+        .setVersion(context.getWorkflowVersion())\n+        .setVariables(variablesAsDocument);\n+\n+    responseWriter.writeResponse(\n+        context.getWorkflowInstanceKey(),\n+        WorkflowInstanceResultIntent.COMPLETED,\n+        resultRecord,\n+        ValueType.WORKFLOW_INSTANCE_RESULT,\n+        requestMetadata.getRequestId(),\n+        requestMetadata.getRequestStreamId());\n+\n+    responseWriter.flush();\n+  }\n+\n+  private DirectBuffer collectVariables(\n+      final BpmnElementContext context, final AwaitWorkflowInstanceResultMetadata requestMetadata) {\n+\n+    final Set<DirectBuffer> variablesToCollect = new HashSet<>();\n+    if (requestMetadata.fetchVariables().iterator().hasNext()) {\n+      requestMetadata\n+          .fetchVariables()", "originalCommit": "3e3b2cb22fa776e673e40d86b27f4afad8d6b6f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMxMjY3MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4630#discussion_r434312670", "bodyText": "No, it loads the variables just once. However, following your suggestion looks more readable :)", "author": "saig0", "createdAt": "2020-06-03T05:16:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc1ODQ0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkwMzI4MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4630#discussion_r433903281", "bodyText": "Apart from calling this flush callback, should the writer itself be flushed here too?", "author": "korthout", "createdAt": "2020-06-02T14:05:38Z", "path": "engine/src/main/java/io/zeebe/engine/nwe/behavior/TypedResponseWriterProxy.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe.behavior;\n+\n+import io.zeebe.engine.processor.TypedRecord;\n+import io.zeebe.engine.processor.TypedResponseWriter;\n+import io.zeebe.msgpack.UnpackedObject;\n+import io.zeebe.protocol.record.RejectionType;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.protocol.record.intent.Intent;\n+import java.util.function.Consumer;\n+\n+public final class TypedResponseWriterProxy implements TypedResponseWriter {\n+\n+  private TypedResponseWriter writer;\n+  private Consumer<TypedResponseWriter> flushCallback;\n+\n+  public void wrap(\n+      final TypedResponseWriter writer, final Consumer<TypedResponseWriter> flushCallback) {\n+    this.writer = writer;\n+    this.flushCallback = flushCallback;\n+  }\n+\n+  @Override\n+  public void writeRejectionOnCommand(\n+      final TypedRecord<?> command, final RejectionType type, final String reason) {\n+    writer.writeRejectionOnCommand(command, type, reason);\n+  }\n+\n+  @Override\n+  public void writeEvent(final TypedRecord<?> event) {\n+    writer.writeEvent(event);\n+  }\n+\n+  @Override\n+  public void writeEventOnCommand(\n+      final long eventKey,\n+      final Intent eventState,\n+      final UnpackedObject eventValue,\n+      final TypedRecord<?> command) {\n+    writer.writeEventOnCommand(eventKey, eventState, eventValue, command);\n+  }\n+\n+  @Override\n+  public void writeResponse(\n+      final long eventKey,\n+      final Intent eventState,\n+      final UnpackedObject eventValue,\n+      final ValueType valueType,\n+      final long requestId,\n+      final int requestStreamId) {\n+    writer.writeResponse(eventKey, eventState, eventValue, valueType, requestId, requestStreamId);\n+  }\n+\n+  @Override\n+  public boolean flush() {\n+    flushCallback.accept(writer);", "originalCommit": "3e3b2cb22fa776e673e40d86b27f4afad8d6b6f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMxMzQzNA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4630#discussion_r434313434", "bodyText": "No. The response writer must be flushed as part of the side effects. This is a separate phase in the processing state machine: https://github.com/zeebe-io/zeebe/blob/develop/engine/src/main/java/io/zeebe/engine/processor/ProcessingStateMachine.java#L41-L71", "author": "saig0", "createdAt": "2020-06-03T05:19:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkwMzI4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxNDM2Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4630#discussion_r433914363", "bodyText": "Should we maybe log a warning or throw an exception when parent is not ACTIVATED?", "author": "korthout", "createdAt": "2020-06-02T14:19:40Z", "path": "engine/src/main/java/io/zeebe/engine/nwe/container/ProcessProcessor.java", "diffHunk": "@@ -22,69 +26,173 @@\n   private final BpmnStateBehavior stateBehavior;\n   private final BpmnStateTransitionBehavior stateTransitionBehavior;\n   private final BpmnEventSubscriptionBehavior eventSubscriptionBehavior;\n+  private final BpmnIncidentBehavior incidentBehavior;\n+  private final BpmnWorkflowResultSenderBehavior workflowResultSenderBehavior;\n+  private final BpmnBufferedMessageStartEventBehavior bufferedMessageStartEventBehavior;\n \n   public ProcessProcessor(final BpmnBehaviors bpmnBehaviors) {\n     stateBehavior = bpmnBehaviors.stateBehavior();\n     stateTransitionBehavior = bpmnBehaviors.stateTransitionBehavior();\n     eventSubscriptionBehavior = bpmnBehaviors.eventSubscriptionBehavior();\n+    incidentBehavior = bpmnBehaviors.incidentBehavior();\n+    workflowResultSenderBehavior = bpmnBehaviors.workflowResultSenderBehavior();\n+    bufferedMessageStartEventBehavior = bpmnBehaviors.bufferedMessageStartEventBehavior();\n   }\n \n   @Override\n-  public void onChildCompleted(\n-      final ExecutableFlowElementContainer element,\n-      final BpmnElementContext flowScopeContext,\n-      final BpmnElementContext childContext) {\n+  public Class<ExecutableFlowElementContainer> getType() {\n+    return ExecutableFlowElementContainer.class;\n+  }\n \n-    if (stateBehavior.isLastActiveExecutionPathInScope(childContext)) {\n-      stateTransitionBehavior.transitionToCompleting(flowScopeContext);\n-    }\n+  @Override\n+  public void onActivating(\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n+\n+    eventSubscriptionBehavior\n+        .subscribeToEvents(element, context)\n+        .ifRightOrLeft(\n+            ok -> stateTransitionBehavior.transitionToActivated(context),\n+            failure -> incidentBehavior.createIncident(failure, context));\n   }\n \n   @Override\n-  public void onChildTerminated(\n-      final ExecutableFlowElementContainer element,\n-      final BpmnElementContext flowScopeContext,\n-      final BpmnElementContext childContext) {\n+  public void onActivated(\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n \n-    if (flowScopeContext.getIntent() == WorkflowInstanceIntent.ELEMENT_TERMINATING\n-        && stateBehavior.isLastActiveExecutionPathInScope(childContext)) {\n-      stateTransitionBehavior.transitionToTerminated(flowScopeContext);\n+    boolean triggeredByEvent = false;\n+    if (element.hasMessageStartEvent() || element.hasTimerStartEvent()) {\n \n-    } else {\n-      eventSubscriptionBehavior.publishTriggeredEventSubProcess(flowScopeContext);\n+      triggeredByEvent = eventSubscriptionBehavior.publishTriggeredStartEvent(context);\n     }\n-  }\n \n-  @Override\n-  public Class<ExecutableFlowElementContainer> getType() {\n-    return ExecutableFlowElementContainer.class;\n-  }\n+    if (!triggeredByEvent) {\n \n-  @Override\n-  public void onActivating(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      final var noneStartEvent = element.getNoneStartEvent();\n+      if (noneStartEvent == null) {\n+        throw new BpmnProcessingException(\n+            context, \"Expected to activate the none start event of the process but not found.\");\n+      }\n \n-  @Override\n-  public void onActivated(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      stateTransitionBehavior.activateChildInstance(context, noneStartEvent);\n+    }\n+  }\n \n   @Override\n   public void onCompleting(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n+\n+    eventSubscriptionBehavior.unsubscribeFromEvents(context);\n+    stateTransitionBehavior.transitionToCompleted(context);\n+  }\n \n   @Override\n   public void onCompleted(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n+\n+    final var parentWorkflowInstanceKey = context.getParentWorkflowInstanceKey();\n+    final var parentElementInstanceKey = context.getParentElementInstanceKey();\n+\n+    if (parentWorkflowInstanceKey > 0) {\n+      // workflow instance is created by a call activity\n+\n+      // TODO (saig0): move responsibility to call activity (#4473)\n+      final var parentElementInstance = stateBehavior.getParentElementInstanceContext(context);\n+\n+      if (parentElementInstance != null\n+          && parentElementInstance.getIntent() == WorkflowInstanceIntent.ELEMENT_ACTIVATED) {", "originalCommit": "3e3b2cb22fa776e673e40d86b27f4afad8d6b6f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyMTA0MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4630#discussion_r434321040", "bodyText": "No, I don't think so. I can happen that the call activity is in state terminating or terminated (e.g. if a boundary event is triggered).", "author": "saig0", "createdAt": "2020-06-03T05:45:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxNDM2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxNTY5MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4630#discussion_r433915690", "bodyText": "Is this check really enough to know that it was started as such?", "author": "korthout", "createdAt": "2020-06-02T14:21:30Z", "path": "engine/src/main/java/io/zeebe/engine/nwe/container/ProcessProcessor.java", "diffHunk": "@@ -22,69 +26,173 @@\n   private final BpmnStateBehavior stateBehavior;\n   private final BpmnStateTransitionBehavior stateTransitionBehavior;\n   private final BpmnEventSubscriptionBehavior eventSubscriptionBehavior;\n+  private final BpmnIncidentBehavior incidentBehavior;\n+  private final BpmnWorkflowResultSenderBehavior workflowResultSenderBehavior;\n+  private final BpmnBufferedMessageStartEventBehavior bufferedMessageStartEventBehavior;\n \n   public ProcessProcessor(final BpmnBehaviors bpmnBehaviors) {\n     stateBehavior = bpmnBehaviors.stateBehavior();\n     stateTransitionBehavior = bpmnBehaviors.stateTransitionBehavior();\n     eventSubscriptionBehavior = bpmnBehaviors.eventSubscriptionBehavior();\n+    incidentBehavior = bpmnBehaviors.incidentBehavior();\n+    workflowResultSenderBehavior = bpmnBehaviors.workflowResultSenderBehavior();\n+    bufferedMessageStartEventBehavior = bpmnBehaviors.bufferedMessageStartEventBehavior();\n   }\n \n   @Override\n-  public void onChildCompleted(\n-      final ExecutableFlowElementContainer element,\n-      final BpmnElementContext flowScopeContext,\n-      final BpmnElementContext childContext) {\n+  public Class<ExecutableFlowElementContainer> getType() {\n+    return ExecutableFlowElementContainer.class;\n+  }\n \n-    if (stateBehavior.isLastActiveExecutionPathInScope(childContext)) {\n-      stateTransitionBehavior.transitionToCompleting(flowScopeContext);\n-    }\n+  @Override\n+  public void onActivating(\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n+\n+    eventSubscriptionBehavior\n+        .subscribeToEvents(element, context)\n+        .ifRightOrLeft(\n+            ok -> stateTransitionBehavior.transitionToActivated(context),\n+            failure -> incidentBehavior.createIncident(failure, context));\n   }\n \n   @Override\n-  public void onChildTerminated(\n-      final ExecutableFlowElementContainer element,\n-      final BpmnElementContext flowScopeContext,\n-      final BpmnElementContext childContext) {\n+  public void onActivated(\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n \n-    if (flowScopeContext.getIntent() == WorkflowInstanceIntent.ELEMENT_TERMINATING\n-        && stateBehavior.isLastActiveExecutionPathInScope(childContext)) {\n-      stateTransitionBehavior.transitionToTerminated(flowScopeContext);\n+    boolean triggeredByEvent = false;\n+    if (element.hasMessageStartEvent() || element.hasTimerStartEvent()) {\n \n-    } else {\n-      eventSubscriptionBehavior.publishTriggeredEventSubProcess(flowScopeContext);\n+      triggeredByEvent = eventSubscriptionBehavior.publishTriggeredStartEvent(context);\n     }\n-  }\n \n-  @Override\n-  public Class<ExecutableFlowElementContainer> getType() {\n-    return ExecutableFlowElementContainer.class;\n-  }\n+    if (!triggeredByEvent) {\n \n-  @Override\n-  public void onActivating(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      final var noneStartEvent = element.getNoneStartEvent();\n+      if (noneStartEvent == null) {\n+        throw new BpmnProcessingException(\n+            context, \"Expected to activate the none start event of the process but not found.\");\n+      }\n \n-  @Override\n-  public void onActivated(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      stateTransitionBehavior.activateChildInstance(context, noneStartEvent);\n+    }\n+  }\n \n   @Override\n   public void onCompleting(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n+\n+    eventSubscriptionBehavior.unsubscribeFromEvents(context);\n+    stateTransitionBehavior.transitionToCompleted(context);\n+  }\n \n   @Override\n   public void onCompleted(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n+\n+    final var parentWorkflowInstanceKey = context.getParentWorkflowInstanceKey();\n+    final var parentElementInstanceKey = context.getParentElementInstanceKey();\n+\n+    if (parentWorkflowInstanceKey > 0) {\n+      // workflow instance is created by a call activity\n+\n+      // TODO (saig0): move responsibility to call activity (#4473)\n+      final var parentElementInstance = stateBehavior.getParentElementInstanceContext(context);\n+\n+      if (parentElementInstance != null\n+          && parentElementInstance.getIntent() == WorkflowInstanceIntent.ELEMENT_ACTIVATED) {\n+        // complete the corresponding call activity\n+\n+        stateTransitionBehavior.transitionToCompleting(parentElementInstance);\n+\n+        // propagate the variables to the parent\n+        final var variablesState = stateBehavior.getVariablesState();\n+\n+        final var variables =\n+            variablesState.getVariablesAsDocument(context.getElementInstanceKey());\n+        variablesState.setTemporaryVariables(parentElementInstanceKey, variables);\n+      }\n+    }\n+\n+    if (element.hasNoneStartEvent()) {", "originalCommit": "3e3b2cb22fa776e673e40d86b27f4afad8d6b6f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyMjc1Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4630#discussion_r434322757", "bodyText": "No, it just checks that the workflow has a none start event. The result sender itself checks if there is a pending request. This check prevents a state access for workflows that have only message/timer start events.", "author": "saig0", "createdAt": "2020-06-03T05:51:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxNTY5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxNjA0Ng==", "url": "https://github.com/camunda-cloud/zeebe/pull/4630#discussion_r433916046", "bodyText": "Can't the process have multiple message start events?", "author": "korthout", "createdAt": "2020-06-02T14:22:01Z", "path": "engine/src/main/java/io/zeebe/engine/nwe/container/ProcessProcessor.java", "diffHunk": "@@ -22,69 +26,173 @@\n   private final BpmnStateBehavior stateBehavior;\n   private final BpmnStateTransitionBehavior stateTransitionBehavior;\n   private final BpmnEventSubscriptionBehavior eventSubscriptionBehavior;\n+  private final BpmnIncidentBehavior incidentBehavior;\n+  private final BpmnWorkflowResultSenderBehavior workflowResultSenderBehavior;\n+  private final BpmnBufferedMessageStartEventBehavior bufferedMessageStartEventBehavior;\n \n   public ProcessProcessor(final BpmnBehaviors bpmnBehaviors) {\n     stateBehavior = bpmnBehaviors.stateBehavior();\n     stateTransitionBehavior = bpmnBehaviors.stateTransitionBehavior();\n     eventSubscriptionBehavior = bpmnBehaviors.eventSubscriptionBehavior();\n+    incidentBehavior = bpmnBehaviors.incidentBehavior();\n+    workflowResultSenderBehavior = bpmnBehaviors.workflowResultSenderBehavior();\n+    bufferedMessageStartEventBehavior = bpmnBehaviors.bufferedMessageStartEventBehavior();\n   }\n \n   @Override\n-  public void onChildCompleted(\n-      final ExecutableFlowElementContainer element,\n-      final BpmnElementContext flowScopeContext,\n-      final BpmnElementContext childContext) {\n+  public Class<ExecutableFlowElementContainer> getType() {\n+    return ExecutableFlowElementContainer.class;\n+  }\n \n-    if (stateBehavior.isLastActiveExecutionPathInScope(childContext)) {\n-      stateTransitionBehavior.transitionToCompleting(flowScopeContext);\n-    }\n+  @Override\n+  public void onActivating(\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n+\n+    eventSubscriptionBehavior\n+        .subscribeToEvents(element, context)\n+        .ifRightOrLeft(\n+            ok -> stateTransitionBehavior.transitionToActivated(context),\n+            failure -> incidentBehavior.createIncident(failure, context));\n   }\n \n   @Override\n-  public void onChildTerminated(\n-      final ExecutableFlowElementContainer element,\n-      final BpmnElementContext flowScopeContext,\n-      final BpmnElementContext childContext) {\n+  public void onActivated(\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n \n-    if (flowScopeContext.getIntent() == WorkflowInstanceIntent.ELEMENT_TERMINATING\n-        && stateBehavior.isLastActiveExecutionPathInScope(childContext)) {\n-      stateTransitionBehavior.transitionToTerminated(flowScopeContext);\n+    boolean triggeredByEvent = false;\n+    if (element.hasMessageStartEvent() || element.hasTimerStartEvent()) {\n \n-    } else {\n-      eventSubscriptionBehavior.publishTriggeredEventSubProcess(flowScopeContext);\n+      triggeredByEvent = eventSubscriptionBehavior.publishTriggeredStartEvent(context);\n     }\n-  }\n \n-  @Override\n-  public Class<ExecutableFlowElementContainer> getType() {\n-    return ExecutableFlowElementContainer.class;\n-  }\n+    if (!triggeredByEvent) {\n \n-  @Override\n-  public void onActivating(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      final var noneStartEvent = element.getNoneStartEvent();\n+      if (noneStartEvent == null) {\n+        throw new BpmnProcessingException(\n+            context, \"Expected to activate the none start event of the process but not found.\");\n+      }\n \n-  @Override\n-  public void onActivated(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      stateTransitionBehavior.activateChildInstance(context, noneStartEvent);\n+    }\n+  }\n \n   @Override\n   public void onCompleting(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n+\n+    eventSubscriptionBehavior.unsubscribeFromEvents(context);\n+    stateTransitionBehavior.transitionToCompleted(context);\n+  }\n \n   @Override\n   public void onCompleted(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n+\n+    final var parentWorkflowInstanceKey = context.getParentWorkflowInstanceKey();\n+    final var parentElementInstanceKey = context.getParentElementInstanceKey();\n+\n+    if (parentWorkflowInstanceKey > 0) {\n+      // workflow instance is created by a call activity\n+\n+      // TODO (saig0): move responsibility to call activity (#4473)\n+      final var parentElementInstance = stateBehavior.getParentElementInstanceContext(context);\n+\n+      if (parentElementInstance != null\n+          && parentElementInstance.getIntent() == WorkflowInstanceIntent.ELEMENT_ACTIVATED) {\n+        // complete the corresponding call activity\n+\n+        stateTransitionBehavior.transitionToCompleting(parentElementInstance);\n+\n+        // propagate the variables to the parent\n+        final var variablesState = stateBehavior.getVariablesState();\n+\n+        final var variables =\n+            variablesState.getVariablesAsDocument(context.getElementInstanceKey());\n+        variablesState.setTemporaryVariables(parentElementInstanceKey, variables);\n+      }\n+    }\n+\n+    if (element.hasNoneStartEvent()) {\n+      workflowResultSenderBehavior.sendResult(context);\n+    }\n+\n+    if (element.hasMessageStartEvent()) {", "originalCommit": "3e3b2cb22fa776e673e40d86b27f4afad8d6b6f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyMzQ1Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4630#discussion_r434323457", "bodyText": "Yes, it can. This check prevents a state access for workflows that don't have a message start event.", "author": "saig0", "createdAt": "2020-06-03T05:54:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxNjA0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxNjc0NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4630#discussion_r433916745", "bodyText": "Does termination not have to be communicated as a workflow result?", "author": "korthout", "createdAt": "2020-06-02T14:23:00Z", "path": "engine/src/main/java/io/zeebe/engine/nwe/container/ProcessProcessor.java", "diffHunk": "@@ -22,69 +26,173 @@\n   private final BpmnStateBehavior stateBehavior;\n   private final BpmnStateTransitionBehavior stateTransitionBehavior;\n   private final BpmnEventSubscriptionBehavior eventSubscriptionBehavior;\n+  private final BpmnIncidentBehavior incidentBehavior;\n+  private final BpmnWorkflowResultSenderBehavior workflowResultSenderBehavior;\n+  private final BpmnBufferedMessageStartEventBehavior bufferedMessageStartEventBehavior;\n \n   public ProcessProcessor(final BpmnBehaviors bpmnBehaviors) {\n     stateBehavior = bpmnBehaviors.stateBehavior();\n     stateTransitionBehavior = bpmnBehaviors.stateTransitionBehavior();\n     eventSubscriptionBehavior = bpmnBehaviors.eventSubscriptionBehavior();\n+    incidentBehavior = bpmnBehaviors.incidentBehavior();\n+    workflowResultSenderBehavior = bpmnBehaviors.workflowResultSenderBehavior();\n+    bufferedMessageStartEventBehavior = bpmnBehaviors.bufferedMessageStartEventBehavior();\n   }\n \n   @Override\n-  public void onChildCompleted(\n-      final ExecutableFlowElementContainer element,\n-      final BpmnElementContext flowScopeContext,\n-      final BpmnElementContext childContext) {\n+  public Class<ExecutableFlowElementContainer> getType() {\n+    return ExecutableFlowElementContainer.class;\n+  }\n \n-    if (stateBehavior.isLastActiveExecutionPathInScope(childContext)) {\n-      stateTransitionBehavior.transitionToCompleting(flowScopeContext);\n-    }\n+  @Override\n+  public void onActivating(\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n+\n+    eventSubscriptionBehavior\n+        .subscribeToEvents(element, context)\n+        .ifRightOrLeft(\n+            ok -> stateTransitionBehavior.transitionToActivated(context),\n+            failure -> incidentBehavior.createIncident(failure, context));\n   }\n \n   @Override\n-  public void onChildTerminated(\n-      final ExecutableFlowElementContainer element,\n-      final BpmnElementContext flowScopeContext,\n-      final BpmnElementContext childContext) {\n+  public void onActivated(\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n \n-    if (flowScopeContext.getIntent() == WorkflowInstanceIntent.ELEMENT_TERMINATING\n-        && stateBehavior.isLastActiveExecutionPathInScope(childContext)) {\n-      stateTransitionBehavior.transitionToTerminated(flowScopeContext);\n+    boolean triggeredByEvent = false;\n+    if (element.hasMessageStartEvent() || element.hasTimerStartEvent()) {\n \n-    } else {\n-      eventSubscriptionBehavior.publishTriggeredEventSubProcess(flowScopeContext);\n+      triggeredByEvent = eventSubscriptionBehavior.publishTriggeredStartEvent(context);\n     }\n-  }\n \n-  @Override\n-  public Class<ExecutableFlowElementContainer> getType() {\n-    return ExecutableFlowElementContainer.class;\n-  }\n+    if (!triggeredByEvent) {\n \n-  @Override\n-  public void onActivating(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      final var noneStartEvent = element.getNoneStartEvent();\n+      if (noneStartEvent == null) {\n+        throw new BpmnProcessingException(\n+            context, \"Expected to activate the none start event of the process but not found.\");\n+      }\n \n-  @Override\n-  public void onActivated(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      stateTransitionBehavior.activateChildInstance(context, noneStartEvent);\n+    }\n+  }\n \n   @Override\n   public void onCompleting(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n+\n+    eventSubscriptionBehavior.unsubscribeFromEvents(context);\n+    stateTransitionBehavior.transitionToCompleted(context);\n+  }\n \n   @Override\n   public void onCompleted(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n+\n+    final var parentWorkflowInstanceKey = context.getParentWorkflowInstanceKey();\n+    final var parentElementInstanceKey = context.getParentElementInstanceKey();\n+\n+    if (parentWorkflowInstanceKey > 0) {\n+      // workflow instance is created by a call activity\n+\n+      // TODO (saig0): move responsibility to call activity (#4473)\n+      final var parentElementInstance = stateBehavior.getParentElementInstanceContext(context);\n+\n+      if (parentElementInstance != null\n+          && parentElementInstance.getIntent() == WorkflowInstanceIntent.ELEMENT_ACTIVATED) {\n+        // complete the corresponding call activity\n+\n+        stateTransitionBehavior.transitionToCompleting(parentElementInstance);\n+\n+        // propagate the variables to the parent\n+        final var variablesState = stateBehavior.getVariablesState();\n+\n+        final var variables =\n+            variablesState.getVariablesAsDocument(context.getElementInstanceKey());\n+        variablesState.setTemporaryVariables(parentElementInstanceKey, variables);\n+      }\n+    }\n+\n+    if (element.hasNoneStartEvent()) {\n+      workflowResultSenderBehavior.sendResult(context);\n+    }\n+\n+    if (element.hasMessageStartEvent()) {\n+      bufferedMessageStartEventBehavior.correlateMessage(context);\n+    }\n+\n+    stateBehavior.removeElementInstance(context);\n+  }\n \n   @Override\n   public void onTerminating(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n+\n+    eventSubscriptionBehavior.unsubscribeFromEvents(context);\n+\n+    stateTransitionBehavior.terminateChildInstances(context);\n+  }\n \n   @Override\n   public void onTerminated(\n-      final ExecutableFlowElementContainer element, final BpmnElementContext context) {}\n+      final ExecutableFlowElementContainer element, final BpmnElementContext context) {\n+\n+    incidentBehavior.resolveIncidents(context);\n+\n+    final var parentWorkflowInstanceKey = context.getParentWorkflowInstanceKey();\n+\n+    if (parentWorkflowInstanceKey > 0) {\n+      // workflow instance is created by a call activity\n+\n+      // TODO (saig0): move responsibility to call activity (#4473)\n+      final var parentElementInstance = stateBehavior.getParentElementInstanceContext(context);\n+\n+      if (parentElementInstance != null\n+          && parentElementInstance.getIntent() == WorkflowInstanceIntent.ELEMENT_TERMINATING) {\n+        // terminate the corresponding call activity\n+\n+        stateTransitionBehavior.transitionToTerminated(parentElementInstance);\n+      }\n+    }\n+\n+    if (element.hasMessageStartEvent()) {\n+      bufferedMessageStartEventBehavior.correlateMessage(context);\n+    }\n+\n+    stateBehavior.removeElementInstance(context);", "originalCommit": "3e3b2cb22fa776e673e40d86b27f4afad8d6b6f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyNTU1MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4630#discussion_r434325551", "bodyText": "No. Currently, the result is only sent when the workflow instance is completed.\nIt is interesting to think about it but not as part of this issue.", "author": "saig0", "createdAt": "2020-06-03T06:00:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxNjc0NQ=="}], "type": "inlineReview"}, {"oid": "161a2aa1e1495332e1cdc98ce82756a9e87cd4ef", "url": "https://github.com/camunda-cloud/zeebe/commit/161a2aa1e1495332e1cdc98ce82756a9e87cd4ef", "message": "chore(engine): rebasing", "committedDate": "2020-06-03T08:47:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ4OTQyOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4630#discussion_r434489429", "bodyText": "I now notice theres mapping happening before the add, which can be moved to a map(variable -> cloneBuffer(variable.getValue())) before the foreach. It would even be possible to collect(toSet) instead of the forEach(variablesToCollect::add).", "author": "korthout", "createdAt": "2020-06-03T11:11:47Z", "path": "engine/src/main/java/io/zeebe/engine/nwe/behavior/BpmnWorkflowResultSenderBehavior.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.nwe.behavior;\n+\n+import static io.zeebe.util.buffer.BufferUtil.cloneBuffer;\n+\n+import io.zeebe.engine.nwe.BpmnElementContext;\n+import io.zeebe.engine.nwe.BpmnProcessingException;\n+import io.zeebe.engine.processor.TypedResponseWriter;\n+import io.zeebe.engine.state.ZeebeState;\n+import io.zeebe.engine.state.instance.AwaitWorkflowInstanceResultMetadata;\n+import io.zeebe.engine.state.instance.ElementInstanceState;\n+import io.zeebe.engine.state.instance.VariablesState;\n+import io.zeebe.protocol.impl.record.value.workflowinstance.WorkflowInstanceResultRecord;\n+import io.zeebe.protocol.record.ValueType;\n+import io.zeebe.protocol.record.intent.WorkflowInstanceResultIntent;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.agrona.DirectBuffer;\n+\n+public final class BpmnWorkflowResultSenderBehavior {\n+\n+  private final WorkflowInstanceResultRecord resultRecord = new WorkflowInstanceResultRecord();\n+\n+  private final ElementInstanceState elementInstanceState;\n+  private final VariablesState variablesState;\n+  private final TypedResponseWriter responseWriter;\n+\n+  public BpmnWorkflowResultSenderBehavior(\n+      final ZeebeState zeebeState, final TypedResponseWriter responseWriter) {\n+    elementInstanceState = zeebeState.getWorkflowState().getElementInstanceState();\n+    variablesState = elementInstanceState.getVariablesState();\n+    this.responseWriter = responseWriter;\n+  }\n+\n+  public void sendResult(final BpmnElementContext context) {\n+\n+    if (context.getBpmnElementType() != BpmnElementType.PROCESS) {\n+      throw new BpmnProcessingException(\n+          context,\n+          \"Expected to send the result of the workflow instance but was not called from the process element\");\n+    }\n+\n+    final AwaitWorkflowInstanceResultMetadata requestMetadata =\n+        elementInstanceState.getAwaitResultRequestMetadata(context.getWorkflowInstanceKey());\n+\n+    if (requestMetadata != null) {\n+      sendResult(context, requestMetadata);\n+    }\n+  }\n+\n+  private void sendResult(\n+      final BpmnElementContext context, final AwaitWorkflowInstanceResultMetadata requestMetadata) {\n+\n+    final DirectBuffer variablesAsDocument = collectVariables(context, requestMetadata);\n+\n+    resultRecord\n+        .setWorkflowInstanceKey(context.getWorkflowInstanceKey())\n+        .setWorkflowKey(context.getWorkflowKey())\n+        .setBpmnProcessId(context.getBpmnProcessId())\n+        .setVersion(context.getWorkflowVersion())\n+        .setVariables(variablesAsDocument);\n+\n+    responseWriter.writeResponse(\n+        context.getWorkflowInstanceKey(),\n+        WorkflowInstanceResultIntent.COMPLETED,\n+        resultRecord,\n+        ValueType.WORKFLOW_INSTANCE_RESULT,\n+        requestMetadata.getRequestId(),\n+        requestMetadata.getRequestStreamId());\n+\n+    responseWriter.flush();\n+  }\n+\n+  private DirectBuffer collectVariables(\n+      final BpmnElementContext context, final AwaitWorkflowInstanceResultMetadata requestMetadata) {\n+\n+    final Set<DirectBuffer> variablesToCollect = new HashSet<>();\n+    requestMetadata\n+        .fetchVariables()\n+        .forEach(\n+            variable -> {\n+              final var variableName = cloneBuffer(variable.getValue());\n+              variablesToCollect.add(variableName);", "originalCommit": "161a2aa1e1495332e1cdc98ce82756a9e87cd4ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ5NjE2Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4630#discussion_r434496162", "bodyText": "Unfortunately not so easy \ud83d\ude05\nfetchVariables() returns ArrayProperty<StringValue> and ArrayProperty implements only Iterable. I would need to use StreamSupport to create a stream of it. This seems a bit too much for it.", "author": "saig0", "createdAt": "2020-06-03T11:26:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ4OTQyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUwMDMwNQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4630#discussion_r434500305", "bodyText": "Ah oops, I forgot about that.", "author": "korthout", "createdAt": "2020-06-03T11:34:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ4OTQyOQ=="}], "type": "inlineReview"}, {"oid": "de44b88258658e0630a46147e8588211e7622839", "url": "https://github.com/camunda-cloud/zeebe/commit/de44b88258658e0630a46147e8588211e7622839", "message": "chore(engine): migrate process processor\n\n* migrate workflow result sender behavior\n* migrate message start event correlation behavior\n* remove unused handlers\n* introduce new exception type for workflow processing", "committedDate": "2020-06-03T12:16:29Z", "type": "commit"}, {"oid": "de44b88258658e0630a46147e8588211e7622839", "url": "https://github.com/camunda-cloud/zeebe/commit/de44b88258658e0630a46147e8588211e7622839", "message": "chore(engine): migrate process processor\n\n* migrate workflow result sender behavior\n* migrate message start event correlation behavior\n* remove unused handlers\n* introduce new exception type for workflow processing", "committedDate": "2020-06-03T12:16:29Z", "type": "forcePushed"}]}