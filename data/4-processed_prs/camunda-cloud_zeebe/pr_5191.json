{"pr_number": 5191, "pr_title": "Fix race condition between reprocessing and pausing stream processor", "pr_createdAt": "2020-08-18T11:38:33Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/5191", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY3OTM4MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472679380", "bodyText": "This constant is used inside the class only.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public static final String SNAPSHOT_FOLDER = \"snapshot\";\n          \n          \n            \n              private static final String SNAPSHOT_FOLDER = \"snapshot\";", "author": "saig0", "createdAt": "2020-08-19T04:32:03Z", "path": "engine/src/test/java/io/zeebe/engine/util/TestStreams.java", "diffHunk": "@@ -54,6 +55,9 @@\n import org.junit.rules.TemporaryFolder;\n \n public final class TestStreams {\n+\n+  public static final String SNAPSHOT_FOLDER = \"snapshot\";", "originalCommit": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY5NzE4OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472697188", "bodyText": "Replace magic number 1 with a constant.", "author": "saig0", "createdAt": "2020-08-19T05:01:05Z", "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/EngineReprocessingTest.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processing.streamprocessor;\n+\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+\n+import io.zeebe.engine.util.EngineRule;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.model.bpmn.BpmnModelInstance;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.test.util.record.RecordingExporter;\n+import io.zeebe.test.util.stream.StreamWrapperException;\n+import java.util.stream.IntStream;\n+import org.assertj.core.internal.bytebuddy.utility.RandomString;\n+import org.awaitility.Awaitility;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class EngineReprocessingTest {\n+\n+  private static final String PROCESS_ID = \"process\";\n+  private static final String ELEMENT_ID = \"task\";\n+  private static final String JOB_TYPE = \"test\";\n+  private static final String INPUT_COLLECTION_VARIABLE = \"items\";\n+\n+  private static final BpmnModelInstance SIMPLE_FLOW =\n+      Bpmn.createExecutableProcess(PROCESS_ID).startEvent().endEvent().done();\n+  @Rule public EngineRule engineRule = EngineRule.singlePartition();\n+\n+  @Before\n+  public void init() {\n+    engineRule.deployment().withXmlResource(SIMPLE_FLOW).deploy();\n+    IntStream.range(0, 100)\n+        .forEach(\n+            i ->\n+                engineRule\n+                    .workflowInstance()\n+                    .ofBpmnProcessId(PROCESS_ID)\n+                    .withVariable(\"data\", RandomString.make(1024))\n+                    .create());\n+\n+    Awaitility.await()\n+        .until(\n+            () ->\n+                RecordingExporter.workflowInstanceRecords()\n+                    .withElementType(BpmnElementType.PROCESS)\n+                    .withIntent(ELEMENT_ACTIVATED)\n+                    .count(),\n+            (count) -> count == 100);\n+\n+    engineRule.stop();\n+  }\n+\n+  @Test\n+  public void shouldReprocess() {\n+    // given - reprocess\n+    final int lastSize = RecordingExporter.getRecords().size();\n+    // we need to reset the record exporter\n+    RecordingExporter.reset();\n+    engineRule.start();\n+\n+    // when - then\n+    Awaitility.await(\"Await reprocessing of \" + lastSize)\n+        .until(() -> RecordingExporter.getRecords().size(), (size) -> size >= lastSize);\n+  }\n+\n+  @Test\n+  public void shouldContinueProcessingAfterReprocessing() {\n+    // given - reprocess\n+    final int lastSize = RecordingExporter.getRecords().size();\n+    // we need to reset the record exporter\n+    RecordingExporter.reset();\n+    engineRule.start();\n+\n+    Awaitility.await(\"Await reprocessing of \" + lastSize)\n+        .until(() -> RecordingExporter.getRecords().size(), (size) -> size >= lastSize);\n+\n+    // when - then\n+    engineRule.workflowInstance().ofBpmnProcessId(PROCESS_ID).create();\n+  }\n+\n+  @Test\n+  public void shouldNotContinueProcessingWhenPausedDuringReprocessing() {\n+    // given - reprocess\n+    final int lastSize = RecordingExporter.getRecords().size();\n+    // we need to reset the record exporter\n+    RecordingExporter.reset();\n+    engineRule.start();\n+    engineRule.pauseProcessing(1);\n+\n+    // when\n+    Awaitility.await(\"Await reprocessing of \" + lastSize)\n+        .until(() -> RecordingExporter.getRecords().size(), (size) -> size >= lastSize);\n+\n+    // then\n+    Assert.assertThrows(\n+        StreamWrapperException.class,\n+        () -> engineRule.workflowInstance().ofBpmnProcessId(PROCESS_ID).create());\n+  }\n+\n+  @Test\n+  public void shouldContinueAfterReprocessWhenProcessingWasResumed() {\n+    // given\n+    final int lastSize = RecordingExporter.getRecords().size();\n+    // we need to reset the record exporter\n+    RecordingExporter.reset();\n+    engineRule.start();\n+    engineRule.pauseProcessing(1);\n+    engineRule.resumeProcessing(1);", "originalCommit": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcwMTg5Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472701897", "bodyText": "Unused fields.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static final String ELEMENT_ID = \"task\";\n          \n          \n            \n              private static final String JOB_TYPE = \"test\";\n          \n          \n            \n              private static final String INPUT_COLLECTION_VARIABLE = \"items\";", "author": "saig0", "createdAt": "2020-08-19T05:08:53Z", "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/EngineReprocessingTest.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processing.streamprocessor;\n+\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+\n+import io.zeebe.engine.util.EngineRule;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.model.bpmn.BpmnModelInstance;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.test.util.record.RecordingExporter;\n+import io.zeebe.test.util.stream.StreamWrapperException;\n+import java.util.stream.IntStream;\n+import org.assertj.core.internal.bytebuddy.utility.RandomString;\n+import org.awaitility.Awaitility;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class EngineReprocessingTest {\n+\n+  private static final String PROCESS_ID = \"process\";\n+  private static final String ELEMENT_ID = \"task\";\n+  private static final String JOB_TYPE = \"test\";\n+  private static final String INPUT_COLLECTION_VARIABLE = \"items\";", "originalCommit": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcwMzYzMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472703631", "bodyText": "We need to limit the stream to avoid waiting for new records.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                .count(),\n          \n          \n            \n                                .limit(100)\n          \n          \n            \n                                .count(),", "author": "saig0", "createdAt": "2020-08-19T05:11:30Z", "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/EngineReprocessingTest.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processing.streamprocessor;\n+\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+\n+import io.zeebe.engine.util.EngineRule;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.model.bpmn.BpmnModelInstance;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.test.util.record.RecordingExporter;\n+import io.zeebe.test.util.stream.StreamWrapperException;\n+import java.util.stream.IntStream;\n+import org.assertj.core.internal.bytebuddy.utility.RandomString;\n+import org.awaitility.Awaitility;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class EngineReprocessingTest {\n+\n+  private static final String PROCESS_ID = \"process\";\n+  private static final String ELEMENT_ID = \"task\";\n+  private static final String JOB_TYPE = \"test\";\n+  private static final String INPUT_COLLECTION_VARIABLE = \"items\";\n+\n+  private static final BpmnModelInstance SIMPLE_FLOW =\n+      Bpmn.createExecutableProcess(PROCESS_ID).startEvent().endEvent().done();\n+  @Rule public EngineRule engineRule = EngineRule.singlePartition();\n+\n+  @Before\n+  public void init() {\n+    engineRule.deployment().withXmlResource(SIMPLE_FLOW).deploy();\n+    IntStream.range(0, 100)\n+        .forEach(\n+            i ->\n+                engineRule\n+                    .workflowInstance()\n+                    .ofBpmnProcessId(PROCESS_ID)\n+                    .withVariable(\"data\", RandomString.make(1024))\n+                    .create());\n+\n+    Awaitility.await()\n+        .until(\n+            () ->\n+                RecordingExporter.workflowInstanceRecords()\n+                    .withElementType(BpmnElementType.PROCESS)\n+                    .withIntent(ELEMENT_ACTIVATED)\n+                    .count(),", "originalCommit": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkxMDQ3NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472910474", "bodyText": "ah thanks", "author": "Zelldon", "createdAt": "2020-08-19T09:59:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcwMzYzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcwNTE0Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472705143", "bodyText": "Why do we need random variables for the test?", "author": "saig0", "createdAt": "2020-08-19T05:13:57Z", "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/EngineReprocessingTest.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processing.streamprocessor;\n+\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+\n+import io.zeebe.engine.util.EngineRule;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.model.bpmn.BpmnModelInstance;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.test.util.record.RecordingExporter;\n+import io.zeebe.test.util.stream.StreamWrapperException;\n+import java.util.stream.IntStream;\n+import org.assertj.core.internal.bytebuddy.utility.RandomString;\n+import org.awaitility.Awaitility;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class EngineReprocessingTest {\n+\n+  private static final String PROCESS_ID = \"process\";\n+  private static final String ELEMENT_ID = \"task\";\n+  private static final String JOB_TYPE = \"test\";\n+  private static final String INPUT_COLLECTION_VARIABLE = \"items\";\n+\n+  private static final BpmnModelInstance SIMPLE_FLOW =\n+      Bpmn.createExecutableProcess(PROCESS_ID).startEvent().endEvent().done();\n+  @Rule public EngineRule engineRule = EngineRule.singlePartition();\n+\n+  @Before\n+  public void init() {\n+    engineRule.deployment().withXmlResource(SIMPLE_FLOW).deploy();\n+    IntStream.range(0, 100)\n+        .forEach(\n+            i ->\n+                engineRule\n+                    .workflowInstance()\n+                    .ofBpmnProcessId(PROCESS_ID)\n+                    .withVariable(\"data\", RandomString.make(1024))", "originalCommit": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkxMDkwOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472910908", "bodyText": "Tbh I just played a bit around to make the reprocessing take a bit longer. What is your concern? Actually we can build it once.", "author": "Zelldon", "createdAt": "2020-08-19T09:59:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcwNTE0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcyMDc2MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472720761", "bodyText": "This test takes ~6 seconds. It waits until the instance is created which will not happen. It would be nice to avoid this waiting time.", "author": "saig0", "createdAt": "2020-08-19T05:38:26Z", "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/EngineReprocessingTest.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.engine.processing.streamprocessor;\n+\n+import static io.zeebe.protocol.record.intent.WorkflowInstanceIntent.ELEMENT_ACTIVATED;\n+\n+import io.zeebe.engine.util.EngineRule;\n+import io.zeebe.model.bpmn.Bpmn;\n+import io.zeebe.model.bpmn.BpmnModelInstance;\n+import io.zeebe.protocol.record.value.BpmnElementType;\n+import io.zeebe.test.util.record.RecordingExporter;\n+import io.zeebe.test.util.stream.StreamWrapperException;\n+import java.util.stream.IntStream;\n+import org.assertj.core.internal.bytebuddy.utility.RandomString;\n+import org.awaitility.Awaitility;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class EngineReprocessingTest {\n+\n+  private static final String PROCESS_ID = \"process\";\n+  private static final String ELEMENT_ID = \"task\";\n+  private static final String JOB_TYPE = \"test\";\n+  private static final String INPUT_COLLECTION_VARIABLE = \"items\";\n+\n+  private static final BpmnModelInstance SIMPLE_FLOW =\n+      Bpmn.createExecutableProcess(PROCESS_ID).startEvent().endEvent().done();\n+  @Rule public EngineRule engineRule = EngineRule.singlePartition();\n+\n+  @Before\n+  public void init() {\n+    engineRule.deployment().withXmlResource(SIMPLE_FLOW).deploy();\n+    IntStream.range(0, 100)\n+        .forEach(\n+            i ->\n+                engineRule\n+                    .workflowInstance()\n+                    .ofBpmnProcessId(PROCESS_ID)\n+                    .withVariable(\"data\", RandomString.make(1024))\n+                    .create());\n+\n+    Awaitility.await()\n+        .until(\n+            () ->\n+                RecordingExporter.workflowInstanceRecords()\n+                    .withElementType(BpmnElementType.PROCESS)\n+                    .withIntent(ELEMENT_ACTIVATED)\n+                    .count(),\n+            (count) -> count == 100);\n+\n+    engineRule.stop();\n+  }\n+\n+  @Test\n+  public void shouldReprocess() {\n+    // given - reprocess\n+    final int lastSize = RecordingExporter.getRecords().size();\n+    // we need to reset the record exporter\n+    RecordingExporter.reset();\n+    engineRule.start();\n+\n+    // when - then\n+    Awaitility.await(\"Await reprocessing of \" + lastSize)\n+        .until(() -> RecordingExporter.getRecords().size(), (size) -> size >= lastSize);\n+  }\n+\n+  @Test\n+  public void shouldContinueProcessingAfterReprocessing() {\n+    // given - reprocess\n+    final int lastSize = RecordingExporter.getRecords().size();\n+    // we need to reset the record exporter\n+    RecordingExporter.reset();\n+    engineRule.start();\n+\n+    Awaitility.await(\"Await reprocessing of \" + lastSize)\n+        .until(() -> RecordingExporter.getRecords().size(), (size) -> size >= lastSize);\n+\n+    // when - then\n+    engineRule.workflowInstance().ofBpmnProcessId(PROCESS_ID).create();\n+  }\n+\n+  @Test\n+  public void shouldNotContinueProcessingWhenPausedDuringReprocessing() {", "originalCommit": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkxMTAxNg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472911016", "bodyText": "How?", "author": "Zelldon", "createdAt": "2020-08-19T10:00:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcyMDc2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjk2MTY2NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472961665", "bodyText": "I don't know \ud83d\ude48", "author": "saig0", "createdAt": "2020-08-19T11:35:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcyMDc2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg4Nzg5OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472887899", "bodyText": "Please add some visual separation. I oversaw the statement \ud83d\ude05", "author": "saig0", "createdAt": "2020-08-19T09:20:55Z", "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/StreamProcessorReprocessingTest.java", "diffHunk": "@@ -87,6 +92,85 @@ public void shouldCallRecordProcessorLifecycle() {\n     inOrder.verifyNoMoreInteractions();\n   }\n \n+  @Test\n+  public void shouldNotSwitchToProcessingAfterReprocessingWhenPaused() throws Exception {\n+    // given - bunch of events to reprocess\n+    IntStream.range(0, 5000)\n+        .forEach(i -> streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, i));\n+    final long sourceEvent = streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(\n+        WorkflowInstanceIntent.ELEMENT_ACTIVATED, 1, sourceEvent);\n+\n+    Awaitility.await()\n+        .until(\n+            () ->\n+                streamProcessorRule\n+                    .events()\n+                    .onlyWorkflowInstanceRecords()\n+                    .withIntent(ELEMENT_ACTIVATED),\n+            StreamWrapper::exists);\n+\n+    // when\n+    final var countDownLatch = new CountDownLatch(1);\n+    final var streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.withListener(\n+                    new StreamProcessorLifecycleAware() {\n+                      @Override\n+                      public void onRecovered(final ReadonlyProcessingContext context) {\n+                        countDownLatch.countDown();\n+                      }\n+                    }));\n+    streamProcessor.pauseProcessing();", "originalCommit": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkyMjE2MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472922161", "bodyText": "valid point :D", "author": "Zelldon", "createdAt": "2020-08-19T10:20:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg4Nzg5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5MTcwOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472891709", "bodyText": "I don't like to verify the behavior by exposing an internal state. Maybe, the currentPhase is set correctly but the processor behaves wrong.\nCan we test the behavior instead? Like in the other test, write a record and verify that it is not read by the stream processor.", "author": "saig0", "createdAt": "2020-08-19T09:26:39Z", "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/StreamProcessorReprocessingTest.java", "diffHunk": "@@ -87,6 +92,85 @@ public void shouldCallRecordProcessorLifecycle() {\n     inOrder.verifyNoMoreInteractions();\n   }\n \n+  @Test\n+  public void shouldNotSwitchToProcessingAfterReprocessingWhenPaused() throws Exception {\n+    // given - bunch of events to reprocess\n+    IntStream.range(0, 5000)\n+        .forEach(i -> streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, i));\n+    final long sourceEvent = streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(\n+        WorkflowInstanceIntent.ELEMENT_ACTIVATED, 1, sourceEvent);\n+\n+    Awaitility.await()\n+        .until(\n+            () ->\n+                streamProcessorRule\n+                    .events()\n+                    .onlyWorkflowInstanceRecords()\n+                    .withIntent(ELEMENT_ACTIVATED),\n+            StreamWrapper::exists);\n+\n+    // when\n+    final var countDownLatch = new CountDownLatch(1);\n+    final var streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.withListener(\n+                    new StreamProcessorLifecycleAware() {\n+                      @Override\n+                      public void onRecovered(final ReadonlyProcessingContext context) {\n+                        countDownLatch.countDown();\n+                      }\n+                    }));\n+    streamProcessor.pauseProcessing();\n+    final var success = countDownLatch.await(15, TimeUnit.SECONDS);\n+\n+    // then\n+    assertThat(success).isTrue();\n+    final var currentPhase = streamProcessor.getCurrentPhase().join();\n+    assertThat(currentPhase).isEqualTo(Phase.PAUSED);", "originalCommit": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkxMTYzMw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472911633", "bodyText": "Then we have the same issue as above right long timeout? \ud83d\ude05", "author": "Zelldon", "createdAt": "2020-08-19T10:01:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5MTcwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjk2MTM1MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472961351", "bodyText": "\ud83d\ude48", "author": "saig0", "createdAt": "2020-08-19T11:34:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5MTcwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NDQ1Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472894453", "bodyText": "Can we add a test to verify that the StreamProcessorLifecycleAware is not invoked before reprocessing is done?", "author": "saig0", "createdAt": "2020-08-19T09:30:55Z", "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/StreamProcessorReprocessingTest.java", "diffHunk": "@@ -87,6 +92,85 @@ public void shouldCallRecordProcessorLifecycle() {\n     inOrder.verifyNoMoreInteractions();\n   }\n \n+  @Test\n+  public void shouldNotSwitchToProcessingAfterReprocessingWhenPaused() throws Exception {\n+    // given - bunch of events to reprocess\n+    IntStream.range(0, 5000)\n+        .forEach(i -> streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, i));\n+    final long sourceEvent = streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(\n+        WorkflowInstanceIntent.ELEMENT_ACTIVATED, 1, sourceEvent);\n+\n+    Awaitility.await()\n+        .until(\n+            () ->\n+                streamProcessorRule\n+                    .events()\n+                    .onlyWorkflowInstanceRecords()\n+                    .withIntent(ELEMENT_ACTIVATED),\n+            StreamWrapper::exists);\n+\n+    // when\n+    final var countDownLatch = new CountDownLatch(1);\n+    final var streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.withListener(\n+                    new StreamProcessorLifecycleAware() {\n+                      @Override\n+                      public void onRecovered(final ReadonlyProcessingContext context) {\n+                        countDownLatch.countDown();\n+                      }\n+                    }));\n+    streamProcessor.pauseProcessing();\n+    final var success = countDownLatch.await(15, TimeUnit.SECONDS);\n+\n+    // then\n+    assertThat(success).isTrue();\n+    final var currentPhase = streamProcessor.getCurrentPhase().join();\n+    assertThat(currentPhase).isEqualTo(Phase.PAUSED);\n+  }\n+\n+  @Test\n+  public void shouldSwitchToProcessingAfterReprocessingWhenResumed() throws Exception {\n+    // given - bunch of events to reprocess\n+    IntStream.range(0, 5000)\n+        .forEach(i -> streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, i));\n+    final long sourceEvent = streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(\n+        WorkflowInstanceIntent.ELEMENT_ACTIVATED, 1, sourceEvent);\n+\n+    Awaitility.await()\n+        .until(\n+            () ->\n+                streamProcessorRule\n+                    .events()\n+                    .onlyWorkflowInstanceRecords()\n+                    .withIntent(ELEMENT_ACTIVATED),\n+            StreamWrapper::exists);\n+\n+    // when\n+    final var countDownLatch = new CountDownLatch(1);\n+    final var streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors.withListener(\n+                    new StreamProcessorLifecycleAware() {\n+                      @Override\n+                      public void onRecovered(final ReadonlyProcessingContext context) {\n+                        countDownLatch.countDown();\n+                      }\n+                    }));\n+    streamProcessor.pauseProcessing();\n+    streamProcessor.resumeProcessing();\n+    final var success = countDownLatch.await(15, TimeUnit.SECONDS);\n+\n+    // then\n+    assertThat(success).isTrue();\n+    final var currentPhase = streamProcessor.getCurrentPhase().join();\n+    assertThat(currentPhase).isEqualTo(Phase.PROCESSING);", "originalCommit": "3b16e27fb0c70f17fda2d31c750296aaa7a1f768", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkyMTk4NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472921985", "bodyText": "Via Mockito? Or how you would do that?", "author": "Zelldon", "createdAt": "2020-08-19T10:19:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NDQ1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjk2MDg5Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r472960893", "bodyText": "Yes. Or, using a simple list and add the invocations in the list.", "author": "saig0", "createdAt": "2020-08-19T11:33:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NDQ1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU3NzA4NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r474577085", "bodyText": "You can use never() instead of times(0).", "author": "saig0", "createdAt": "2020-08-21T09:31:32Z", "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/StreamProcessorReprocessingTest.java", "diffHunk": "@@ -111,28 +111,37 @@ public void shouldNotSwitchToProcessingAfterReprocessingWhenPaused() throws Exce\n             StreamWrapper::exists);\n \n     final var onRecoveredLatch = new CountDownLatch(1);\n+    final var typedRecordProcessor = mock(TypedRecordProcessor.class);\n     final var streamProcessor =\n         streamProcessorRule.startTypedStreamProcessor(\n             (processors, context) ->\n-                processors.withListener(\n-                    new StreamProcessorLifecycleAware() {\n-                      @Override\n-                      public void onRecovered(final ReadonlyProcessingContext context) {\n-                        onRecoveredLatch.countDown();\n-                      }\n-                    }));\n+                processors\n+                    .onEvent(ValueType.WORKFLOW_INSTANCE, ELEMENT_ACTIVATING, typedRecordProcessor)\n+                    .withListener(\n+                        new StreamProcessorLifecycleAware() {\n+                          @Override\n+                          public void onRecovered(final ReadonlyProcessingContext context) {\n+                            onRecoveredLatch.countDown();\n+                          }\n+                        }));\n+\n     // when\n     streamProcessor.pauseProcessing();\n     final var success = onRecoveredLatch.await(15, TimeUnit.SECONDS);\n \n     // then\n     assertThat(success).isTrue();\n-    final var currentPhase = streamProcessor.getCurrentPhase().join();\n-    assertThat(currentPhase).isEqualTo(Phase.PAUSED);\n+    Mockito.clearInvocations(typedRecordProcessor);\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 0xcafe);\n+\n+    verify(typedRecordProcessor, TIMEOUT.times(0))\n+        .processRecord(anyLong(), any(), any(), any(), any());\n+    verify(typedRecordProcessor, TIMEOUT.times(0)).processRecord(any(), any(), any(), any());\n+    verify(typedRecordProcessor, TIMEOUT.times(0)).processRecord(any(), any(), any());", "originalCommit": "7d876e2570c4007c19f4f57c4c308c895d63481e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU4MjMzNA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5191#discussion_r474582334", "bodyText": "Unfortunately not if you use Timeout before :D", "author": "Zelldon", "createdAt": "2020-08-21T09:37:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU3NzA4NQ=="}], "type": "inlineReview"}, {"oid": "a95301864f98f044857cb9e925da1d1410bed180", "url": "https://github.com/camunda-cloud/zeebe/commit/a95301864f98f044857cb9e925da1d1410bed180", "message": "fix(engine): fix race condition between reprocessing and pausing\n\n The issue happened during reprocessing, when the stream processor was\n paused. It happend that after reprocessing the state was reset to\n processing, instead of paused. Resuming before reprocessing was done,\n caused NPE's, since processors/listeners haven't been initialized yet.\n\n Changed lifecycle aware guarantees, it is now guaranteed that\n onRecovered is called as first method. After that onPaused can happen and\n onResume.", "committedDate": "2020-08-21T10:04:01Z", "type": "forcePushed"}, {"oid": "275146fc78a76922d350fd5a5752200d32953691", "url": "https://github.com/camunda-cloud/zeebe/commit/275146fc78a76922d350fd5a5752200d32953691", "message": "chore(engine): create new reprocessing tests\n\n New reprocessing tests to reproduce two bugs, which happen during\n reprocessing and pausing/resuming the stream processor.\n\n Changed default, after closing stream processor runtime is deleted.\n Deletion of runtime actually causes reprocessing, before it hasn't\n happened.\n\n Add new method to take snapshot explicitly in test, to test recovery\n with snapshot.", "committedDate": "2020-08-21T10:07:18Z", "type": "commit"}, {"oid": "7fd20dff6d7aebc3c168b982307621a968086027", "url": "https://github.com/camunda-cloud/zeebe/commit/7fd20dff6d7aebc3c168b982307621a968086027", "message": "fix(engine): fix race condition between reprocessing and pausing\n\n The issue happened during reprocessing, when the stream processor was\n paused. It happend that after reprocessing the state was reset to\n processing, instead of paused. Resuming before reprocessing was done,\n caused NPE's, since processors/listeners haven't been initialized yet.\n\n Changed lifecycle aware guarantees, it is now guaranteed that\n onRecovered is called as first method. After that onPaused can happen and\n onResume.", "committedDate": "2020-08-21T10:07:18Z", "type": "commit"}, {"oid": "7fd20dff6d7aebc3c168b982307621a968086027", "url": "https://github.com/camunda-cloud/zeebe/commit/7fd20dff6d7aebc3c168b982307621a968086027", "message": "fix(engine): fix race condition between reprocessing and pausing\n\n The issue happened during reprocessing, when the stream processor was\n paused. It happend that after reprocessing the state was reset to\n processing, instead of paused. Resuming before reprocessing was done,\n caused NPE's, since processors/listeners haven't been initialized yet.\n\n Changed lifecycle aware guarantees, it is now guaranteed that\n onRecovered is called as first method. After that onPaused can happen and\n onResume.", "committedDate": "2020-08-21T10:07:18Z", "type": "forcePushed"}]}