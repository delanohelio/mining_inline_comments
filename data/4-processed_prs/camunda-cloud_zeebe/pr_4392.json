{"pr_number": 4392, "pr_title": "chore(atomix): prevent log inconsistencies", "pr_createdAt": "2020-04-27T17:26:21Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/4392", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2NDEwMA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4392#discussion_r417064100", "bodyText": "I don't think this reader is advanced to the last entry if you are in LeaderRole.", "author": "deepthidevaki", "createdAt": "2020-04-29T04:45:21Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/roles/LeaderRole.java", "diffHunk": "@@ -1441,6 +1448,16 @@ private void safeAppendEntry(\n             });\n   }\n \n+  private boolean isEntryInconsistent(long newEntryPosition) {\n+    final Indexed<RaftLogEntry> indexedEntry = raft.getLogReader().getCurrentEntry();", "originalCommit": "d09bbe1688d2ed2fc33ef7bfe9d9472fe586a967", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2NDYyOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4392#discussion_r417064629", "bodyText": "This is probably why the test passes. We should find a better way to test it without mocking all of it.", "author": "deepthidevaki", "createdAt": "2020-04-29T04:47:40Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/roles/LeaderRoleTest.java", "diffHunk": "@@ -400,4 +405,46 @@ public void onCommitError(final Indexed<ZeebeEntry> indexed, final Throwable err\n     assertEquals(1, entries.get(0).highestPosition());\n     assertEquals(2, entries.get(1).highestPosition());\n   }\n+\n+  @Test\n+  public void shouldNotAppendInconsistentEntry() throws InterruptedException {\n+    // given\n+    when(writer.append(any(ZeebeEntry.class)))\n+        .then(\n+            i -> {\n+              final ZeebeEntry zeebeEntry = i.getArgument(0);\n+              final Indexed<RaftLogEntry> indexedEntry = new Indexed<>(1, zeebeEntry, 45);\n+              when(reader.getCurrentEntry()).thenReturn(indexedEntry);", "originalCommit": "d09bbe1688d2ed2fc33ef7bfe9d9472fe586a967", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc5NDc5NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4392#discussion_r417794794", "bodyText": "I think this would be testable in io.atomix.raft.zeebe.ZeebeTest, no? Just append an event with lower position a second time and \ud83d\udca5?", "author": "npepinpe", "createdAt": "2020-04-30T06:58:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2NDYyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzgxODkzNQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4392#discussion_r417818935", "bodyText": "Yes, that was added in the last commit bf6b987", "author": "MiguelPires", "createdAt": "2020-04-30T07:46:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2NDYyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMyNTMxNA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4392#discussion_r419325314", "bodyText": "Just to be safe, should we also compare the error to expected message or type? It can be that first entry was appended, but fail to commit resulting in an error.", "author": "deepthidevaki", "createdAt": "2020-05-04T09:51:47Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/zeebe/ZeebeLogAppenderTest.java", "diffHunk": "@@ -103,6 +103,23 @@ public void shouldNotifyOnError() {\n     assertEquals(0L, appenderListener.getCommitted().size());\n   }\n \n+  @Test(timeout = 5000)\n+  public void shouldNotAppendInconsistent() {\n+    // given\n+    final ZeebeLogAppender appender = helper.awaitLeaderAppender(1);\n+    final ByteBuffer data = ByteBuffer.allocate(Integer.BYTES).putInt(0, 1);\n+    final Indexed<ZeebeEntry> first = appenderListener.append(appender, 4, 5, data);\n+\n+    // when\n+    appender.appendEntry(5, 5, data, appenderListener);\n+    final Throwable error = appenderListener.pollError();\n+\n+    // then\n+    assertEquals(4, (first.entry().lowestPosition()));\n+    assertEquals(5, (first.entry().highestPosition()));\n+    assertNotNull(error);", "originalCommit": "bf6b9877beb7f4f8c296531b2a8d343a3e22150c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMzNDM0MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4392#discussion_r419334341", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  long index = raft.getLogWriter().getLastIndex();\n          \n          \n            \n                  long index = raft.getLogWriter().getLastIndex() - 1;", "author": "deepthidevaki", "createdAt": "2020-05-04T10:10:19Z", "path": "atomix/cluster/src/main/java/io/atomix/raft/roles/LeaderRole.java", "diffHunk": "@@ -1441,6 +1448,28 @@ private void safeAppendEntry(\n             });\n   }\n \n+  /**\n+   * Returns true if the supplied position is higher than the last ZeebeEntry in the log or if no\n+   * ZeebeEntry was found at all.\n+   */\n+  private boolean isEntryConsistent(long newEntryPosition) {\n+    Indexed<RaftLogEntry> lastEntry = raft.getLogWriter().getLastEntry();\n+\n+    if (lastEntry == null || lastEntry.type() != ZeebeEntry.class) {\n+      long index = raft.getLogWriter().getLastIndex();", "originalCommit": "bf6b9877beb7f4f8c296531b2a8d343a3e22150c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM3NDgzNg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4392#discussion_r419374836", "bodyText": "Can you explain? If the last entry is null then getLastIndex() will already return the segment's starting index minus 1:\nhttps://github.com/zeebe-io/zeebe/blob/66a4acab1cbee3eeeb2fd56675add9535cfd846e/atomix/storage/src/main/java/io/atomix/storage/journal/MappedJournalSegmentWriter.java#L85\nSo it seemed safer to just start there since at worst we check an index twice which is safer than skipping what might be the actual last zeebe entry. But I'm not an expert on the entry/log structure so this might not make sense though", "author": "MiguelPires", "createdAt": "2020-05-04T11:39:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMzNDM0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM4MzUwOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4392#discussion_r419383508", "bodyText": "When can lastEntry be null?\nAs far as I know reader reset operation is not very efficient. It re-reads all entries in a segment from the beginning. So it would be good if we can avoid that extra reset that reads the same last entry.", "author": "deepthidevaki", "createdAt": "2020-05-04T11:58:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMzNDM0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM1NzM2OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4392#discussion_r419357369", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                latch.await(2, TimeUnit.SECONDS);\n          \n          \n            \n               assertTrue(latch.await(2, TimeUnit.SECONDS));", "author": "deepthidevaki", "createdAt": "2020-05-04T11:00:17Z", "path": "atomix/cluster/src/test/java/io/atomix/raft/zeebe/ZeebeTest.java", "diffHunk": "@@ -258,6 +260,78 @@ public void shouldNotifyCommitListeners() {\n     }\n   }\n \n+  @Test\n+  public void shouldBeConsistentAfterFailOver() {\n+    assumeTrue(nodes.size() > 1);\n+\n+    // given\n+    final int partitionId = 1;\n+    final ZeebeTestNode oldLeader = helper.awaitLeader(partitionId);\n+    final Collection<ZeebeTestNode> followers = new ArrayList<>(nodes);\n+    followers.remove(oldLeader);\n+\n+    // when\n+    final ZeebeLogAppender oldAppender =\n+        oldLeader.getPartitionServer(partitionId).getAppender().orElseThrow();\n+    appenderWrapper.append(oldAppender, 0, 0, ByteBuffer.allocate(Integer.BYTES).putInt(0, 1));\n+\n+    oldLeader.stop().join();\n+    final ZeebeTestNode newLeader = helper.awaitLeader(partitionId, followers);\n+    oldLeader.start(nodes).join();\n+\n+    // then\n+    final ZeebeLogAppender newAppender =\n+        newLeader.getPartitionServer(partitionId).getAppender().orElseThrow();\n+    appenderWrapper.append(newAppender, 1, 1, ByteBuffer.allocate(Integer.BYTES).putInt(0, 1));\n+  }\n+\n+  @Test\n+  public void shouldDetectInconsistencyAfterFailOver() throws InterruptedException {\n+    assumeTrue(nodes.size() > 1);\n+\n+    // given\n+    final int partitionId = 1;\n+    final ZeebeTestNode oldLeader = helper.awaitLeader(partitionId);\n+    final Collection<ZeebeTestNode> followers = new ArrayList<>(nodes);\n+    followers.remove(oldLeader);\n+\n+    // when\n+    final ZeebeLogAppender oldAppender =\n+        oldLeader.getPartitionServer(partitionId).getAppender().orElseThrow();\n+    appenderWrapper.append(oldAppender, 0, 0, ByteBuffer.allocate(Integer.BYTES).putInt(0, 1));\n+\n+    oldLeader.stop().join();\n+    final ZeebeTestNode newLeader = helper.awaitLeader(partitionId, followers);\n+    oldLeader.start(nodes).join();\n+\n+    // then\n+    final ZeebeLogAppender newAppender =\n+        newLeader.getPartitionServer(partitionId).getAppender().orElseThrow();\n+\n+    final CountDownLatch latch = new CountDownLatch(1);\n+    newAppender.appendEntry(\n+        0,\n+        0,\n+        ByteBuffer.allocate(Integer.BYTES).putInt(0, 1),\n+        new AppendListener() {\n+          @Override\n+          public void onWrite(Indexed<ZeebeEntry> indexed) {}\n+\n+          @Override\n+          public void onWriteError(Throwable error) {\n+            latch.countDown();\n+          }\n+\n+          @Override\n+          public void onCommit(Indexed<ZeebeEntry> indexed) {}\n+\n+          @Override\n+          public void onCommitError(Indexed<ZeebeEntry> indexed, Throwable error) {}\n+        });\n+\n+    latch.await(2, TimeUnit.SECONDS);", "originalCommit": "bf6b9877beb7f4f8c296531b2a8d343a3e22150c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b5bb1c711cfae8e8598a87dce1d731b7a086cdf3", "url": "https://github.com/camunda-cloud/zeebe/commit/b5bb1c711cfae8e8598a87dce1d731b7a086cdf3", "message": "chore(atomix): minor test adjustments", "committedDate": "2020-05-04T11:45:55Z", "type": "forcePushed"}, {"oid": "6604afd4fa24f67b5169a8a8f5823ec27a1e6c30", "url": "https://github.com/camunda-cloud/zeebe/commit/6604afd4fa24f67b5169a8a8f5823ec27a1e6c30", "message": "chore(atomix): prevent log inconsistencies", "committedDate": "2020-05-05T16:20:56Z", "type": "commit"}, {"oid": "6604afd4fa24f67b5169a8a8f5823ec27a1e6c30", "url": "https://github.com/camunda-cloud/zeebe/commit/6604afd4fa24f67b5169a8a8f5823ec27a1e6c30", "message": "chore(atomix): prevent log inconsistencies", "committedDate": "2020-05-05T16:20:56Z", "type": "forcePushed"}]}