{"pr_number": 4387, "pr_title": "Refactor cluster event service", "pr_createdAt": "2020-04-27T12:34:03Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/4387", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxNTkxNw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4387#discussion_r416315917", "bodyText": "These properties are always send via gossip? Can it happen that we have an different update like our broker address or something similar, which doesn't contain the subscription name and then we remove all subscriptions here?", "author": "Zelldon", "createdAt": "2020-04-28T04:22:56Z", "path": "atomix/cluster/src/main/java/io/atomix/cluster/messaging/impl/DefaultClusterEventService.java", "diffHunk": "@@ -354,77 +202,64 @@ public boolean isRunning() {\n   @Override\n   public CompletableFuture<Void> stop() {\n     if (started.compareAndSet(true, false)) {\n-      if (gossipExecutor != null) {\n-        gossipExecutor.shutdown();\n+      if (eventServiceExecutor != null) {\n+        eventServiceExecutor.shutdown();\n       }\n       LOGGER.info(\"Stopped\");\n     }\n     return CompletableFuture.completedFuture(null);\n   }\n \n-  /** Internal message. */\n-  private static class InternalMessage {\n-    private final Type type;\n-    private final byte[] payload;\n-\n-    InternalMessage(final Type type, final byte[] payload) {\n-      this.type = type;\n-      this.payload = payload;\n-    }\n-\n-    /**\n-     * Returns the message type.\n-     *\n-     * @return the message type\n-     */\n-    public Type type() {\n-      return type;\n-    }\n-\n-    /**\n-     * Returns the payload.\n-     *\n-     * @return the payload\n-     */\n-    public byte[] payload() {\n-      return payload;\n-    }\n-\n-    private enum Type {\n-      DIRECT,\n-      ALL,\n-    }\n+  @Override\n+  public void event(final ClusterMembershipEvent event) {\n+    eventServiceExecutor.execute(\n+        () -> {\n+          switch (event.type()) {\n+            case MEMBER_ADDED:\n+              updateRemoteSubscription(event);\n+              break;\n+            case METADATA_CHANGED:\n+              updateRemoteSubscription(event);\n+              break;\n+            case REACHABILITY_CHANGED:\n+              break;\n+            case MEMBER_REMOVED:\n+              removeAllSubscription(event.subject().id());\n+              break;\n+            default:\n+              LOGGER.warn(\n+                  \"Unexpected membership event type {} from {}\", event.type(), event.subject());\n+          }\n+        });\n   }\n \n-  /** Subscriber iterator that iterates subscribers in a loop. */\n-  private static class TopicIterator implements Iterator<InternalSubscriptionInfo> {\n-    private final AtomicInteger counter = new AtomicInteger();\n-    private final InternalSubscriptionInfo[] subscribers;\n-\n-    TopicIterator(final List<InternalSubscriptionInfo> subscribers) {\n-      final List<InternalSubscriptionInfo> filteredSubscribers =\n-          subscribers.stream().filter(s -> !s.isTombstone()).collect(Collectors.toList());\n-      Collections.reverse(filteredSubscribers);\n-      this.subscribers =\n-          filteredSubscribers.toArray(new InternalSubscriptionInfo[filteredSubscribers.size()]);\n-    }\n-\n-    @Override\n-    public boolean hasNext() {\n-      return subscribers.length > 0;\n+  private void removeAllSubscription(final MemberId id) {\n+    final Set<String> prevSubscriptions = remoteMemberSubscriptions.remove(id);\n+    if (prevSubscriptions != null) {\n+      prevSubscriptions.forEach(s -> topics.get(s).removeRemoteSubscription(id));\n     }\n+  }\n \n-    @Override\n-    public InternalSubscriptionInfo next() {\n-      return subscribers[Math.abs(counter.incrementAndGet() % subscribers.length)];\n+  private void updateRemoteSubscription(final ClusterMembershipEvent event) {\n+    final String topicSubscribedAsString =\n+        event.subject().properties().getProperty(SUBSCRIPTION_PROPERTY_NAME);\n+    if (topicSubscribedAsString != null) {\n+      final Set<String> topicsSubscribed = topicsFromString(topicSubscribedAsString);\n+      topicsSubscribed.forEach(\n+          topic ->\n+              topics\n+                  .computeIfAbsent(topic, t -> new InternalTopic(topic))\n+                  .addRemoteSubscription(event.subject().id()));\n+      remoteMemberSubscriptions.put(event.subject().id(), topicsSubscribed);\n+    } else {\n+      removeAllSubscription(event.subject().id());", "originalCommit": "ee87cca00b00b957df4e9a0d08f087727ec47925", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM5MjgxNQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4387#discussion_r416392815", "bodyText": "I don't think it happens since Swim gossip versions the update and guarantees that we always see the latest one even if it is received out of order. Other option is to add tombstones to deleted subscriptions and purge them periodically. But I think it is unnecessary here.", "author": "deepthidevaki", "createdAt": "2020-04-28T07:31:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxNTkxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM5MzM2MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4387#discussion_r416393361", "bodyText": "Also gossip update contains the whole Property. It wouldn't propagate only address or only topology info.", "author": "deepthidevaki", "createdAt": "2020-04-28T07:32:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxNTkxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM5MzY2Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4387#discussion_r416393662", "bodyText": "The question was more do we send always all details? If so then it is probably fine.", "author": "Zelldon", "createdAt": "2020-04-28T07:33:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxNTkxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQwOTAzNw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4387#discussion_r416409037", "bodyText": "Yes. It sends the whole member Properties.", "author": "deepthidevaki", "createdAt": "2020-04-28T07:58:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxNTkxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxNjM2MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4387#discussion_r416316360", "bodyText": "Do we really need here a concurrent data structure?", "author": "Zelldon", "createdAt": "2020-04-28T04:24:26Z", "path": "atomix/cluster/src/main/java/io/atomix/cluster/messaging/impl/DefaultClusterEventService.java", "diffHunk": "@@ -354,77 +202,64 @@ public boolean isRunning() {\n   @Override\n   public CompletableFuture<Void> stop() {\n     if (started.compareAndSet(true, false)) {\n-      if (gossipExecutor != null) {\n-        gossipExecutor.shutdown();\n+      if (eventServiceExecutor != null) {\n+        eventServiceExecutor.shutdown();\n       }\n       LOGGER.info(\"Stopped\");\n     }\n     return CompletableFuture.completedFuture(null);\n   }\n \n-  /** Internal message. */\n-  private static class InternalMessage {\n-    private final Type type;\n-    private final byte[] payload;\n-\n-    InternalMessage(final Type type, final byte[] payload) {\n-      this.type = type;\n-      this.payload = payload;\n-    }\n-\n-    /**\n-     * Returns the message type.\n-     *\n-     * @return the message type\n-     */\n-    public Type type() {\n-      return type;\n-    }\n-\n-    /**\n-     * Returns the payload.\n-     *\n-     * @return the payload\n-     */\n-    public byte[] payload() {\n-      return payload;\n-    }\n-\n-    private enum Type {\n-      DIRECT,\n-      ALL,\n-    }\n+  @Override\n+  public void event(final ClusterMembershipEvent event) {\n+    eventServiceExecutor.execute(\n+        () -> {\n+          switch (event.type()) {\n+            case MEMBER_ADDED:\n+              updateRemoteSubscription(event);\n+              break;\n+            case METADATA_CHANGED:\n+              updateRemoteSubscription(event);\n+              break;\n+            case REACHABILITY_CHANGED:\n+              break;\n+            case MEMBER_REMOVED:\n+              removeAllSubscription(event.subject().id());\n+              break;\n+            default:\n+              LOGGER.warn(\n+                  \"Unexpected membership event type {} from {}\", event.type(), event.subject());\n+          }\n+        });\n   }\n \n-  /** Subscriber iterator that iterates subscribers in a loop. */\n-  private static class TopicIterator implements Iterator<InternalSubscriptionInfo> {\n-    private final AtomicInteger counter = new AtomicInteger();\n-    private final InternalSubscriptionInfo[] subscribers;\n-\n-    TopicIterator(final List<InternalSubscriptionInfo> subscribers) {\n-      final List<InternalSubscriptionInfo> filteredSubscribers =\n-          subscribers.stream().filter(s -> !s.isTombstone()).collect(Collectors.toList());\n-      Collections.reverse(filteredSubscribers);\n-      this.subscribers =\n-          filteredSubscribers.toArray(new InternalSubscriptionInfo[filteredSubscribers.size()]);\n-    }\n-\n-    @Override\n-    public boolean hasNext() {\n-      return subscribers.length > 0;\n+  private void removeAllSubscription(final MemberId id) {\n+    final Set<String> prevSubscriptions = remoteMemberSubscriptions.remove(id);\n+    if (prevSubscriptions != null) {\n+      prevSubscriptions.forEach(s -> topics.get(s).removeRemoteSubscription(id));\n     }\n+  }\n \n-    @Override\n-    public InternalSubscriptionInfo next() {\n-      return subscribers[Math.abs(counter.incrementAndGet() % subscribers.length)];\n+  private void updateRemoteSubscription(final ClusterMembershipEvent event) {\n+    final String topicSubscribedAsString =\n+        event.subject().properties().getProperty(SUBSCRIPTION_PROPERTY_NAME);\n+    if (topicSubscribedAsString != null) {\n+      final Set<String> topicsSubscribed = topicsFromString(topicSubscribedAsString);\n+      topicsSubscribed.forEach(\n+          topic ->\n+              topics\n+                  .computeIfAbsent(topic, t -> new InternalTopic(topic))\n+                  .addRemoteSubscription(event.subject().id()));\n+      remoteMemberSubscriptions.put(event.subject().id(), topicsSubscribed);\n+    } else {\n+      removeAllSubscription(event.subject().id());\n     }\n   }\n \n   /** Internal subscriber. */\n   private static class InternalSubscriber\n       implements BiFunction<Address, byte[], CompletableFuture<byte[]>> {\n-    private final AtomicInteger counter = new AtomicInteger();\n-    private InternalSubscription[] subscriptions = new InternalSubscription[0];\n+    private final List<InternalSubscription> subscriptions = new CopyOnWriteArrayList<>();", "originalCommit": "ee87cca00b00b957df4e9a0d08f087727ec47925", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQwMDAyMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4387#discussion_r416400022", "bodyText": "Yes. add a subscription to a topic, broadcast to that topic, removing a subscription can all happen concurrently.", "author": "deepthidevaki", "createdAt": "2020-04-28T07:44:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxNjM2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQwMzc3OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4387#discussion_r416403778", "bodyText": "thanks", "author": "Zelldon", "createdAt": "2020-04-28T07:50:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxNjM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxNzEzNg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4387#discussion_r416317136", "bodyText": "Do you know why this is synchronized? Is this really necessary?", "author": "Zelldon", "createdAt": "2020-04-28T04:27:00Z", "path": "atomix/cluster/src/main/java/io/atomix/cluster/messaging/impl/DefaultClusterEventService.java", "diffHunk": "@@ -702,58 +418,34 @@ TopicIterator iterator() {\n      *\n      * @param subscription the subscription to add\n      */\n-    synchronized void addRemoteSubscription(final InternalSubscriptionInfo subscription) {\n+    synchronized void addRemoteSubscription(final MemberId subscription) {", "originalCommit": "ee87cca00b00b957df4e9a0d08f087727ec47925", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxNzM2OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/4387#discussion_r416317368", "bodyText": "I would assume not, since we are using here a concurrent hash set.", "author": "Zelldon", "createdAt": "2020-04-28T04:27:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxNzEzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQwMDY0OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4387#discussion_r416400649", "bodyText": "You are right. Before it was not a concurrent set.", "author": "deepthidevaki", "createdAt": "2020-04-28T07:44:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxNzEzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxODMyNg==", "url": "https://github.com/camunda-cloud/zeebe/pull/4387#discussion_r416318326", "bodyText": "I think distinct is not necessary here, since you're using a set.", "author": "Zelldon", "createdAt": "2020-04-28T04:30:56Z", "path": "atomix/cluster/src/main/java/io/atomix/cluster/messaging/impl/DefaultClusterEventService.java", "diffHunk": "@@ -193,154 +142,53 @@ public DefaultClusterEventService(\n     return ImmutableList.copyOf(topic.localSubscriber().subscriptions());\n   }\n \n-  /**\n-   * Returns a collection of nodes that subscribe to the given topic.\n-   *\n-   * @param topicName the topic for which to return the collection of subscriber nodes\n-   * @return the collection of subscribers for the given topic\n-   */\n-  private Stream<MemberId> getSubscriberNodes(final String topicName) {\n-    final InternalTopic topic = topics.get(topicName);\n-    if (topic == null) {\n-      return Stream.empty();\n-    }\n-    return topic.remoteSubscriptions().stream()\n-        .filter(s -> !s.isTombstone())\n-        .map(s -> s.memberId())\n-        .distinct();\n-  }\n-\n-  /**\n-   * Returns the next node ID for the given message topic.\n-   *\n-   * @param topicName the topic for which to return the next node ID\n-   * @return the next node ID for the given message topic\n-   */\n-  private MemberId getNextMemberId(final String topicName) {\n+  @Override\n+  public Set<MemberId> getSubscribers(final String topicName) {\n     final InternalTopic topic = topics.get(topicName);\n     if (topic == null) {\n-      return null;\n-    }\n-\n-    final TopicIterator iterator = topic.iterator();\n-    if (iterator.hasNext()) {\n-      return iterator.next().memberId();\n+      return Set.of();\n     }\n-    return null;\n+    return topic.remoteSubscriptions();\n   }\n \n   /**\n-   * Handles a collection of subscription updates received via the gossip protocol.\n+   * Returns a collection of nodes that subscribe to the given topic.\n    *\n-   * @param subscriptions a collection of subscriptions provided by the sender\n+   * @param topicName the topic for which to return the collection of subscriber nodes\n+   * @return the collection of subscribers for the given topic\n    */\n-  private void update(final Collection<InternalSubscriptionInfo> subscriptions) {\n-    for (final InternalSubscriptionInfo subscription : subscriptions) {\n-      final InternalTopic topic = topics.computeIfAbsent(subscription.topic, InternalTopic::new);\n-      final InternalSubscriptionInfo matchingSubscription =\n-          topic.remoteSubscriptions().stream()\n-              .filter(\n-                  s ->\n-                      s.memberId().equals(subscription.memberId())\n-                          && s.logicalTimestamp().equals(subscription.logicalTimestamp()))\n-              .findFirst()\n-              .orElse(null);\n-      if (matchingSubscription == null) {\n-        topic.addRemoteSubscription(subscription);\n-      } else if (subscription.isTombstone()) {\n-        topic.removeRemoteSubscription(subscription);\n-      }\n-    }\n-  }\n-\n-  /** Sends a gossip message to an active peer. */\n-  private void gossip() {\n-    final List<Member> members =\n-        membershipService.getMembers().stream()\n-            .filter(node -> !localMemberId.equals(node.id()))\n-            .filter(node -> node.isReachable())\n-            .collect(Collectors.toList());\n-\n-    if (!members.isEmpty()) {\n-      Collections.shuffle(members);\n-      final Member member = members.get(0);\n-      updateNode(member);\n-    }\n+  private Stream<MemberId> getSubscriberNodes(final String topicName) {\n+    return getSubscribers(topicName).stream().distinct();", "originalCommit": "ee87cca00b00b957df4e9a0d08f087727ec47925", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMyMTUwNw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4387#discussion_r416321507", "bodyText": "This is not used anymore or?", "author": "Zelldon", "createdAt": "2020-04-28T04:41:19Z", "path": "atomix/cluster/src/test/java/io/atomix/cluster/messaging/impl/DefaultClusterEventServiceTest.java", "diffHunk": "@@ -54,6 +59,16 @@\n public class DefaultClusterEventServiceTest {\n   private static final Serializer SERIALIZER = Serializer.using(Namespaces.BASIC);\n \n+  private final TestMessagingServiceFactory messagingServiceFactory =\n+      new TestMessagingServiceFactory();\n+  private final TestUnicastServiceFactory unicastServiceFactory = new TestUnicastServiceFactory();", "originalCommit": "ee87cca00b00b957df4e9a0d08f087727ec47925", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQwNjA4MQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4387#discussion_r416406081", "bodyText": "It is needed to create TestBootstrapService", "author": "deepthidevaki", "createdAt": "2020-04-28T07:53:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMyMTUwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ1NjkxOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4387#discussion_r416456919", "bodyText": "On the local things I'm a bit unsure to remove that. This means it can happen that we remove one and concurrently add one; could this be a problem? That I end in a state where I actually subscribed but I'm not registered correctly?\nBut actually adding only happens on starting and removing on closing phase right? So probably this will never happen concurrently? \ud83e\udd37", "author": "Zelldon", "createdAt": "2020-04-28T09:12:00Z", "path": "atomix/cluster/src/main/java/io/atomix/cluster/messaging/impl/DefaultClusterEventService.java", "diffHunk": "@@ -403,7 +403,7 @@ InternalSubscriber localSubscriber() {\n      *\n      * @param subscription the subscription to unregister\n      */\n-    private synchronized CompletableFuture<Void> removeLocalSubscription(\n+    private CompletableFuture<Void> removeLocalSubscription(", "originalCommit": "68df3812c9a636ef82355f86ae6dca528ec62c88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3NjAzMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4387#discussion_r417076031", "bodyText": "You are right. They have to be synchronized.", "author": "deepthidevaki", "createdAt": "2020-04-29T05:34:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ1NjkxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3NjIxNQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/4387#discussion_r417076215", "bodyText": "I am also wondering if it would be better to remove all concurrent data structures and execute all public methods on an eventServiceExecutor. broadcast might be called frequently and it is now accessing two concurrent data structures - topics and remote subscribers. What do you think? I can do it in a different PR.", "author": "deepthidevaki", "createdAt": "2020-04-29T05:35:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ1NjkxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3Njk2Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/4387#discussion_r417076967", "bodyText": "Yes, I thought about that as well yesterday. That we normally do that with our actors, but since we have here also a single thread we probably could easily rebuild this kind of stuff. Or maybe we switch to our actor scheduler? Yes, would be fine if we do it on a follow up, just re-add the synchronize on the two methods for now.", "author": "Zelldon", "createdAt": "2020-04-29T05:37:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ1NjkxOQ=="}], "type": "inlineReview"}, {"oid": "81636dfa97a93178c3c611d9d0e205d19c9e2941", "url": "https://github.com/camunda-cloud/zeebe/commit/81636dfa97a93178c3c611d9d0e205d19c9e2941", "message": "chore(atomix): refactor DefaultClusterEventService\n\n * use member properties to propogate event subscription info instead of custom gossip", "committedDate": "2020-04-29T11:09:16Z", "type": "commit"}, {"oid": "81636dfa97a93178c3c611d9d0e205d19c9e2941", "url": "https://github.com/camunda-cloud/zeebe/commit/81636dfa97a93178c3c611d9d0e205d19c9e2941", "message": "chore(atomix): refactor DefaultClusterEventService\n\n * use member properties to propogate event subscription info instead of custom gossip", "committedDate": "2020-04-29T11:09:16Z", "type": "forcePushed"}]}