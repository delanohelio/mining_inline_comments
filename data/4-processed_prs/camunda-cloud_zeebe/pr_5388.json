{"pr_number": 5388, "pr_title": "Update acknowledged position of up to date exporters when skipping records", "pr_createdAt": "2020-09-21T13:28:39Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/5388", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA0NzMzMA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5388#discussion_r492047330", "bodyText": "If you remember why we're catching throwable and not exception then I'll gladly revert, otherwise this is just strange to me.", "author": "npepinpe", "createdAt": "2020-09-21T13:33:02Z", "path": "broker/src/main/java/io/zeebe/broker/exporter/stream/ExporterDirector.java", "diffHunk": "@@ -129,7 +132,7 @@ protected void onActorStarted() {\n       eventFilter = createEventFilter(containers);\n       LOG.debug(\"Set event filter for exporters: {}\", eventFilter);\n \n-    } catch (final Throwable e) {", "originalCommit": "0dd4291d68a8b3d453a00135707462390469437a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ3ODM4OA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5388#discussion_r492478388", "bodyText": "No. I see no reason why we should catch Throwable \ud83d\ude05", "author": "saig0", "createdAt": "2020-09-22T05:16:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA0NzMzMA=="}], "type": "inlineReview"}, {"oid": "b5d9909bb2054a860d439e928ee8aeb4be53b776", "url": "https://github.com/camunda-cloud/zeebe/commit/b5d9909bb2054a860d439e928ee8aeb4be53b776", "message": "fix(broker): update position of exporter on skip\n\n- allows compaction to occur even when an exporter skips all records iff\n  it is up to date\n- keeps track of last acknowledged and unacknowledged position of\n  exporters in ExporterContainer\n- when skipping a record (whether for all, or a single exporter), if the\n  exporter is up to date (meaning its last acknowledged position is\n  greater than or equal to its last unacknowledged position), then\n  automatically acknowledge that position", "committedDate": "2020-09-21T14:35:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjUxNzk0Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5388#discussion_r492517943", "bodyText": "Using the first exporter may lead to a flaky test because the second exporter may haven't seen the record yet.", "author": "saig0", "createdAt": "2020-09-22T07:13:16Z", "path": "broker/src/test/java/io/zeebe/broker/exporter/stream/ExporterDirectorTest.java", "diffHunk": "@@ -84,6 +84,134 @@ private void startExporterDirector(final List<ExporterDescriptor> exporterDescri\n     rule.startExporterDirector(exporterDescriptors);\n   }\n \n+  @Test\n+  public void shouldUpdatePositionWhenInitialRecordsAreSkipped() {\n+    // given\n+    final ControlledTestExporter tailingExporter = exporters.get(0);", "originalCommit": "b5d9909bb2054a860d439e928ee8aeb4be53b776", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUzNDM2Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5388#discussion_r493534367", "bodyText": "True - it highlights that the director is difficult to test, since now we're relying that the order in which the record is exported will be the same, which is implementation details. Let's go with that now, but in the not too distant future we probably need to refactor the director to make it more testable.", "author": "npepinpe", "createdAt": "2020-09-23T12:33:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjUxNzk0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjUxOTkzOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5388#discussion_r492519938", "bodyText": "I think it would be more readable and realistic to wait until the exporter saw the record before updating its position. To wait until the exporter is opened looks a bit confusing.", "author": "saig0", "createdAt": "2020-09-22T07:17:28Z", "path": "broker/src/test/java/io/zeebe/broker/exporter/stream/ExporterDirectorTest.java", "diffHunk": "@@ -84,6 +84,134 @@ private void startExporterDirector(final List<ExporterDescriptor> exporterDescri\n     rule.startExporterDirector(exporterDescriptors);\n   }\n \n+  @Test\n+  public void shouldUpdatePositionWhenInitialRecordsAreSkipped() {\n+    // given\n+    final ControlledTestExporter tailingExporter = exporters.get(0);\n+    exporters.forEach(\n+        e ->\n+            e.onConfigure(withFilter(List.of(RecordType.COMMAND), List.of(ValueType.DEPLOYMENT)))\n+                .shouldAutoUpdatePosition(false));\n+\n+    // when\n+    startExporterDirector(exporterDescriptors);\n+    final ExportersState state = rule.getExportersState();\n+    final long skippedRecordPosition =\n+        rule.writeEvent(DeploymentIntent.CREATED, new DeploymentRecord());\n+    rule.writeCommand(DeploymentIntent.CREATE, new DeploymentRecord());\n+\n+    // then\n+    Awaitility.await(\"director has read all records until now\")\n+        .atMost(Duration.ofSeconds(5))\n+        .untilAsserted(() -> assertThat(tailingExporter.getExportedRecords()).hasSize(1));\n+    assertThat(state.getPosition(EXPORTER_ID_1)).isEqualTo(skippedRecordPosition);\n+    assertThat(state.getPosition(EXPORTER_ID_2)).isEqualTo(skippedRecordPosition);\n+  }\n+\n+  @Test\n+  public void shouldUpdatePositionOfUpToDateExportersOnSkipRecord() throws InterruptedException {\n+    // given\n+    final ControlledTestExporter tailingExporter = exporters.get(0);\n+    final ControlledTestExporter filteringExporter = exporters.get(1);\n+    final CountDownLatch isOpened = new CountDownLatch(1);\n+    tailingExporter\n+        .onConfigure(withFilter(List.of(RecordType.COMMAND), List.of(ValueType.DEPLOYMENT)))\n+        .shouldAutoUpdatePosition(false);\n+    filteringExporter\n+        .onConfigure(withFilter(List.of(RecordType.COMMAND), List.of(ValueType.DEPLOYMENT)))\n+        .onOpen(c -> isOpened.countDown())\n+        .shouldAutoUpdatePosition(false);\n+\n+    // when\n+    startExporterDirector(exporterDescriptors);\n+    final ExportersState state = rule.getExportersState();\n+    isOpened.await(5, TimeUnit.SECONDS);\n+\n+    // accepted by both\n+    final long firstRecordPosition =\n+        rule.writeCommand(DeploymentIntent.CREATE, new DeploymentRecord());\n+    filteringExporter.getController().updateLastExportedRecordPosition(firstRecordPosition);", "originalCommit": "b5d9909bb2054a860d439e928ee8aeb4be53b776", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUzNTIxNg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5388#discussion_r493535216", "bodyText": "Good point - we wait until it's opened just for the controller to be set, but yes it does look strange. Let's go with that \ud83d\udc4d", "author": "npepinpe", "createdAt": "2020-09-23T12:34:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjUxOTkzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjUyNDcxMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5388#discussion_r492524712", "bodyText": "Again, using the first exporter may lead to a flaky test because the second exporter may haven't seen the record yet.", "author": "saig0", "createdAt": "2020-09-22T07:26:59Z", "path": "broker/src/test/java/io/zeebe/broker/exporter/stream/ExporterDirectorTest.java", "diffHunk": "@@ -84,6 +84,134 @@ private void startExporterDirector(final List<ExporterDescriptor> exporterDescri\n     rule.startExporterDirector(exporterDescriptors);\n   }\n \n+  @Test\n+  public void shouldUpdatePositionWhenInitialRecordsAreSkipped() {\n+    // given\n+    final ControlledTestExporter tailingExporter = exporters.get(0);\n+    exporters.forEach(\n+        e ->\n+            e.onConfigure(withFilter(List.of(RecordType.COMMAND), List.of(ValueType.DEPLOYMENT)))\n+                .shouldAutoUpdatePosition(false));\n+\n+    // when\n+    startExporterDirector(exporterDescriptors);\n+    final ExportersState state = rule.getExportersState();\n+    final long skippedRecordPosition =\n+        rule.writeEvent(DeploymentIntent.CREATED, new DeploymentRecord());\n+    rule.writeCommand(DeploymentIntent.CREATE, new DeploymentRecord());\n+\n+    // then\n+    Awaitility.await(\"director has read all records until now\")\n+        .atMost(Duration.ofSeconds(5))\n+        .untilAsserted(() -> assertThat(tailingExporter.getExportedRecords()).hasSize(1));\n+    assertThat(state.getPosition(EXPORTER_ID_1)).isEqualTo(skippedRecordPosition);\n+    assertThat(state.getPosition(EXPORTER_ID_2)).isEqualTo(skippedRecordPosition);\n+  }\n+\n+  @Test\n+  public void shouldUpdatePositionOfUpToDateExportersOnSkipRecord() throws InterruptedException {\n+    // given\n+    final ControlledTestExporter tailingExporter = exporters.get(0);\n+    final ControlledTestExporter filteringExporter = exporters.get(1);\n+    final CountDownLatch isOpened = new CountDownLatch(1);\n+    tailingExporter\n+        .onConfigure(withFilter(List.of(RecordType.COMMAND), List.of(ValueType.DEPLOYMENT)))\n+        .shouldAutoUpdatePosition(false);\n+    filteringExporter\n+        .onConfigure(withFilter(List.of(RecordType.COMMAND), List.of(ValueType.DEPLOYMENT)))\n+        .onOpen(c -> isOpened.countDown())\n+        .shouldAutoUpdatePosition(false);\n+\n+    // when\n+    startExporterDirector(exporterDescriptors);\n+    final ExportersState state = rule.getExportersState();\n+    isOpened.await(5, TimeUnit.SECONDS);\n+\n+    // accepted by both\n+    final long firstRecordPosition =\n+        rule.writeCommand(DeploymentIntent.CREATE, new DeploymentRecord());\n+    filteringExporter.getController().updateLastExportedRecordPosition(firstRecordPosition);\n+    // skipped entirely\n+    final long skippedRecordPosition =\n+        rule.writeCommand(IncidentIntent.CREATE, new IncidentRecord());\n+    // accepted by both again\n+    rule.writeCommand(DeploymentIntent.CREATE, new DeploymentRecord());\n+\n+    // then\n+    Awaitility.await(\"director has read all records until now\")\n+        .atMost(Duration.ofSeconds(5))\n+        .untilAsserted(() -> assertThat(tailingExporter.getExportedRecords()).hasSize(2));\n+    assertThat(state.getPosition(EXPORTER_ID_1)).isEqualTo(-1L);\n+    assertThat(state.getPosition(EXPORTER_ID_2)).isEqualTo(skippedRecordPosition);\n+  }\n+\n+  @Test\n+  public void shouldUpdateIfSkippingInitialRecordForSingleExporter() {\n+    final ControlledTestExporter tailingExporter = exporters.get(0);\n+    final ControlledTestExporter filteringExporter = exporters.get(1);\n+    tailingExporter\n+        .onConfigure(\n+            withFilter(\n+                List.of(RecordType.COMMAND, RecordType.EVENT), List.of(ValueType.DEPLOYMENT)))\n+        .shouldAutoUpdatePosition(false);\n+    filteringExporter\n+        .onConfigure(withFilter(List.of(RecordType.COMMAND), List.of(ValueType.DEPLOYMENT)))\n+        .shouldAutoUpdatePosition(false);\n+\n+    // when\n+    startExporterDirector(exporterDescriptors);\n+    final ExportersState state = rule.getExportersState();\n+\n+    // skipped only by filteringExporter\n+    final long skippedRecordPosition =\n+        rule.writeEvent(DeploymentIntent.CREATED, new DeploymentRecord());\n+    // accepted by both\n+    rule.writeCommand(DeploymentIntent.CREATE, new DeploymentRecord());\n+\n+    // then\n+    Awaitility.await(\"director has read all records until now\")\n+        .atMost(Duration.ofSeconds(5))\n+        .untilAsserted(() -> assertThat(tailingExporter.getExportedRecords()).hasSize(2));\n+    assertThat(state.getPosition(EXPORTER_ID_1)).isEqualTo(-1L);\n+    assertThat(state.getPosition(EXPORTER_ID_2)).isEqualTo(skippedRecordPosition);", "originalCommit": "b5d9909bb2054a860d439e928ee8aeb4be53b776", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjUyODIxNw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5388#discussion_r492528217", "bodyText": "Same as before, I would prefer to wait until the record is read before updating the position.", "author": "saig0", "createdAt": "2020-09-22T07:34:12Z", "path": "broker/src/test/java/io/zeebe/broker/exporter/stream/ExporterDirectorTest.java", "diffHunk": "@@ -84,6 +84,134 @@ private void startExporterDirector(final List<ExporterDescriptor> exporterDescri\n     rule.startExporterDirector(exporterDescriptors);\n   }\n \n+  @Test\n+  public void shouldUpdatePositionWhenInitialRecordsAreSkipped() {\n+    // given\n+    final ControlledTestExporter tailingExporter = exporters.get(0);\n+    exporters.forEach(\n+        e ->\n+            e.onConfigure(withFilter(List.of(RecordType.COMMAND), List.of(ValueType.DEPLOYMENT)))\n+                .shouldAutoUpdatePosition(false));\n+\n+    // when\n+    startExporterDirector(exporterDescriptors);\n+    final ExportersState state = rule.getExportersState();\n+    final long skippedRecordPosition =\n+        rule.writeEvent(DeploymentIntent.CREATED, new DeploymentRecord());\n+    rule.writeCommand(DeploymentIntent.CREATE, new DeploymentRecord());\n+\n+    // then\n+    Awaitility.await(\"director has read all records until now\")\n+        .atMost(Duration.ofSeconds(5))\n+        .untilAsserted(() -> assertThat(tailingExporter.getExportedRecords()).hasSize(1));\n+    assertThat(state.getPosition(EXPORTER_ID_1)).isEqualTo(skippedRecordPosition);\n+    assertThat(state.getPosition(EXPORTER_ID_2)).isEqualTo(skippedRecordPosition);\n+  }\n+\n+  @Test\n+  public void shouldUpdatePositionOfUpToDateExportersOnSkipRecord() throws InterruptedException {\n+    // given\n+    final ControlledTestExporter tailingExporter = exporters.get(0);\n+    final ControlledTestExporter filteringExporter = exporters.get(1);\n+    final CountDownLatch isOpened = new CountDownLatch(1);\n+    tailingExporter\n+        .onConfigure(withFilter(List.of(RecordType.COMMAND), List.of(ValueType.DEPLOYMENT)))\n+        .shouldAutoUpdatePosition(false);\n+    filteringExporter\n+        .onConfigure(withFilter(List.of(RecordType.COMMAND), List.of(ValueType.DEPLOYMENT)))\n+        .onOpen(c -> isOpened.countDown())\n+        .shouldAutoUpdatePosition(false);\n+\n+    // when\n+    startExporterDirector(exporterDescriptors);\n+    final ExportersState state = rule.getExportersState();\n+    isOpened.await(5, TimeUnit.SECONDS);\n+\n+    // accepted by both\n+    final long firstRecordPosition =\n+        rule.writeCommand(DeploymentIntent.CREATE, new DeploymentRecord());\n+    filteringExporter.getController().updateLastExportedRecordPosition(firstRecordPosition);\n+    // skipped entirely\n+    final long skippedRecordPosition =\n+        rule.writeCommand(IncidentIntent.CREATE, new IncidentRecord());\n+    // accepted by both again\n+    rule.writeCommand(DeploymentIntent.CREATE, new DeploymentRecord());\n+\n+    // then\n+    Awaitility.await(\"director has read all records until now\")\n+        .atMost(Duration.ofSeconds(5))\n+        .untilAsserted(() -> assertThat(tailingExporter.getExportedRecords()).hasSize(2));\n+    assertThat(state.getPosition(EXPORTER_ID_1)).isEqualTo(-1L);\n+    assertThat(state.getPosition(EXPORTER_ID_2)).isEqualTo(skippedRecordPosition);\n+  }\n+\n+  @Test\n+  public void shouldUpdateIfSkippingInitialRecordForSingleExporter() {\n+    final ControlledTestExporter tailingExporter = exporters.get(0);\n+    final ControlledTestExporter filteringExporter = exporters.get(1);\n+    tailingExporter\n+        .onConfigure(\n+            withFilter(\n+                List.of(RecordType.COMMAND, RecordType.EVENT), List.of(ValueType.DEPLOYMENT)))\n+        .shouldAutoUpdatePosition(false);\n+    filteringExporter\n+        .onConfigure(withFilter(List.of(RecordType.COMMAND), List.of(ValueType.DEPLOYMENT)))\n+        .shouldAutoUpdatePosition(false);\n+\n+    // when\n+    startExporterDirector(exporterDescriptors);\n+    final ExportersState state = rule.getExportersState();\n+\n+    // skipped only by filteringExporter\n+    final long skippedRecordPosition =\n+        rule.writeEvent(DeploymentIntent.CREATED, new DeploymentRecord());\n+    // accepted by both\n+    rule.writeCommand(DeploymentIntent.CREATE, new DeploymentRecord());\n+\n+    // then\n+    Awaitility.await(\"director has read all records until now\")\n+        .atMost(Duration.ofSeconds(5))\n+        .untilAsserted(() -> assertThat(tailingExporter.getExportedRecords()).hasSize(2));\n+    assertThat(state.getPosition(EXPORTER_ID_1)).isEqualTo(-1L);\n+    assertThat(state.getPosition(EXPORTER_ID_2)).isEqualTo(skippedRecordPosition);\n+  }\n+\n+  @Test\n+  public void shouldUpdateIfRecordSkipsSingleUpToDateExporter() throws InterruptedException {\n+    final ControlledTestExporter tailingExporter = exporters.get(0);\n+    final ControlledTestExporter filteringExporter = exporters.get(1);\n+    final CountDownLatch isOpened = new CountDownLatch(1);\n+    tailingExporter\n+        .onConfigure(\n+            withFilter(\n+                List.of(RecordType.COMMAND, RecordType.EVENT), List.of(ValueType.DEPLOYMENT)))\n+        .shouldAutoUpdatePosition(false);\n+    filteringExporter\n+        .onConfigure(withFilter(List.of(RecordType.COMMAND), List.of(ValueType.DEPLOYMENT)))\n+        .onOpen(c -> isOpened.countDown())\n+        .shouldAutoUpdatePosition(false);\n+\n+    // when\n+    startExporterDirector(exporterDescriptors);\n+    final ExportersState state = rule.getExportersState();\n+    isOpened.await(5, TimeUnit.SECONDS);\n+\n+    // accepted by both\n+    final long firstRecordPosition =\n+        rule.writeCommand(DeploymentIntent.CREATE, new DeploymentRecord());\n+    filteringExporter.getController().updateLastExportedRecordPosition(firstRecordPosition);", "originalCommit": "b5d9909bb2054a860d439e928ee8aeb4be53b776", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU0NDAzNA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5388#discussion_r492544034", "bodyText": "These IT tests look complicated and just not right \ud83d\ude48\nHowever, I don't have a better idea for now.", "author": "saig0", "createdAt": "2020-09-22T08:02:56Z", "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/SingleBrokerDataDeletionTest.java", "diffHunk": "@@ -58,6 +67,100 @@ private void configureCustomExporter(final BrokerCfg brokerCfg) {\n     brokerCfg.setExporters(Collections.singletonMap(\"snapshot-test-exporter\", exporterCfg));\n   }\n \n+  @Test\n+  public void shouldCompactEvenIfSkippingAllRecords() {\n+    // given\n+    final Broker broker = clusteringRule.getBroker(0);\n+\n+    // when\n+    ControllableExporter.updatePosition(false);\n+    ControllableExporter.RECORD_TYPE_FILTER.set(r -> r == RecordType.COMMAND);\n+    ControllableExporter.VALUE_TYPE_FILTER.set(r -> r == ValueType.DEPLOYMENT);\n+    writeSegments(broker, 2);\n+    clusteringRule\n+        .getClient()\n+        .newDeployCommand()\n+        .addWorkflowModel(\n+            Bpmn.createExecutableProcess(\"process\").startEvent().done(), \"process.bpmn\")\n+        .send()\n+        .join();\n+    await(\"until at least one record is exported\")\n+        .atMost(Duration.ofSeconds(5))\n+        .untilAsserted(\n+            () -> assertThat(ControllableExporter.EXPORTED_RECORDS).hasValueGreaterThan(0));\n+\n+    // enforce compaction\n+    final var segmentsBeforeSnapshot = getSegmentsCount(broker);\n+    clusteringRule.getClock().addTime(SNAPSHOT_PERIOD);\n+\n+    // then\n+    assertThat(clusteringRule.waitForSnapshotAtBroker(broker)).isNotNull();\n+    await()\n+        .untilAsserted(\n+            () ->\n+                assertThat(getSegmentsCount(broker))\n+                    .describedAs(\"Expected less segments after a snapshot is taken\")\n+                    .isLessThan(segmentsBeforeSnapshot));\n+  }\n+\n+  @Test\n+  public void shouldNotCompactUnacknowledgedEventsEvenIfSkipping() {", "originalCommit": "b5d9909bb2054a860d439e928ee8aeb4be53b776", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU2Mzc2Mg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5388#discussion_r493563762", "bodyText": "Agreed, and they know too much implementation details (e.g. where to find snapshots, how to count segments, etc.) \ud83d\ude05 I'll give another hour to see if I can't come up with something else", "author": "npepinpe", "createdAt": "2020-09-23T13:04:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU0NDAzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTAzMTYyMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5388#discussion_r495031621", "bodyText": "I think I have a concept which could help make these tests better - it's kind of two parter. I have an idea how to make tests more maintainable and less coupled to implementation details, but that requires more refactoring. In the meantime I have another idea to make it more maintainable with a bit less refactoring, and I'll explore that in a different PR to avoid the burden here.", "author": "npepinpe", "createdAt": "2020-09-25T14:35:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU0NDAzNA=="}], "type": "inlineReview"}, {"oid": "119c5c8cf1185bfb29a6488a6d19cbacf97c6ddd", "url": "https://github.com/camunda-cloud/zeebe/commit/119c5c8cf1185bfb29a6488a6d19cbacf97c6ddd", "message": "fix(broker): update position of exporter on skip\n\n- allows compaction to occur even when an exporter skips all records iff\n  it is up to date\n- keeps track of last acknowledged and unacknowledged position of\n  exporters in ExporterContainer\n- when skipping a record (whether for all, or a single exporter), if the\n  exporter is up to date (meaning its last acknowledged position is\n  greater than or equal to its last unacknowledged position), then\n  automatically acknowledge that position", "committedDate": "2020-09-25T14:33:47Z", "type": "commit"}, {"oid": "119c5c8cf1185bfb29a6488a6d19cbacf97c6ddd", "url": "https://github.com/camunda-cloud/zeebe/commit/119c5c8cf1185bfb29a6488a6d19cbacf97c6ddd", "message": "fix(broker): update position of exporter on skip\n\n- allows compaction to occur even when an exporter skips all records iff\n  it is up to date\n- keeps track of last acknowledged and unacknowledged position of\n  exporters in ExporterContainer\n- when skipping a record (whether for all, or a single exporter), if the\n  exporter is up to date (meaning its last acknowledged position is\n  greater than or equal to its last unacknowledged position), then\n  automatically acknowledge that position", "committedDate": "2020-09-25T14:33:47Z", "type": "forcePushed"}]}