{"pr_number": 3939, "pr_title": "Improve upgradability test coverage", "pr_createdAt": "2020-02-27T11:47:07Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/3939", "timeline": [{"oid": "731af01f6e3a1e355fc3f71bb677499727c3cd0a", "url": "https://github.com/camunda-cloud/zeebe/commit/731af01f6e3a1e355fc3f71bb677499727c3cd0a", "message": "chore(upgrade-tests): cover call activity", "committedDate": "2020-03-02T10:51:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIyNDU1NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/3939#discussion_r388224554", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public static final String PROCESS_ID = \"process\";\n          \n          \n            \n              public static final String CHILD_PROCESS_ID = \"childProc\";\n          \n          \n            \n              private static final String PROCESS_ID = \"process\";\n          \n          \n            \n              private static final String CHILD_PROCESS_ID = \"childProc\";", "author": "saig0", "createdAt": "2020-03-05T11:05:57Z", "path": "upgrade-tests/src/test/java/io/zeebe/test/UpgradeTest.java", "diffHunk": "@@ -39,9 +39,11 @@\n @RunWith(Parameterized.class)\n public class UpgradeTest {\n \n+  public static final String PROCESS_ID = \"process\";\n+  public static final String CHILD_PROCESS_ID = \"childProc\";", "originalCommit": "731af01f6e3a1e355fc3f71bb677499727c3cd0a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIyNDcxMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/3939#discussion_r388224711", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              long getIncidentKey() {\n          \n          \n            \n              public long getIncidentKey() {", "author": "saig0", "createdAt": "2020-03-05T11:06:17Z", "path": "upgrade-tests/src/test/java/io/zeebe/test/ContainerStateRule.java", "diffHunk": "@@ -99,16 +107,51 @@ private void log(final String type, final String log) {\n    *     false\n    */\n   public boolean hasElementInState(final String elementId, final String intent) {\n+    return hasLogContaining(\n+        String.format(\"\\\"elementId\\\":\\\"%s\\\"\", elementId),\n+        String.format(\"\\\"intent\\\":\\\"%s\\\"\", intent));\n+  }\n+\n+  /** @return true if the message was found in the specified intent. Otherwise, returns false */\n+  public boolean hasMessageInState(final String name, final String intent) {\n+    return hasLogContaining(\n+        String.format(\"\\\"name\\\":\\\"%s\\\"\", name), String.format(\"\\\"intent\\\":\\\"%s\\\"\", intent));\n+  }\n+\n+  // returns true if it finds a line that contains every piece.\n+  boolean hasLogContaining(final String... piece) {\n+    return getLogContaining(piece) != null;\n+  }\n+\n+  String getLogContaining(final String... piece) {\n     final String[] lines = broker.getLogs().split(\"\\n\");\n \n     for (int i = lines.length - 1; i >= 0; --i) {\n-      if (lines[i].contains(String.format(\"\\\"elementId\\\":\\\"%s\\\"\", elementId))\n-          && lines[i].contains(String.format(\"\\\"intent\\\":\\\"%s\\\"\", intent))) {\n-        return true;\n+      final int finalI = i;\n+      if (Arrays.stream(piece).allMatch(p -> lines[finalI].contains(p))) {\n+        return lines[i];\n+      }\n+    }\n+\n+    return null;\n+  }\n+\n+  long getIncidentKey() {", "originalCommit": "731af01f6e3a1e355fc3f71bb677499727c3cd0a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIyNDc3OQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/3939#discussion_r388224779", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              String getLogContaining(final String... piece) {\n          \n          \n            \n              private String getLogContaining(final String... piece) {", "author": "saig0", "createdAt": "2020-03-05T11:06:26Z", "path": "upgrade-tests/src/test/java/io/zeebe/test/ContainerStateRule.java", "diffHunk": "@@ -99,16 +107,51 @@ private void log(final String type, final String log) {\n    *     false\n    */\n   public boolean hasElementInState(final String elementId, final String intent) {\n+    return hasLogContaining(\n+        String.format(\"\\\"elementId\\\":\\\"%s\\\"\", elementId),\n+        String.format(\"\\\"intent\\\":\\\"%s\\\"\", intent));\n+  }\n+\n+  /** @return true if the message was found in the specified intent. Otherwise, returns false */\n+  public boolean hasMessageInState(final String name, final String intent) {\n+    return hasLogContaining(\n+        String.format(\"\\\"name\\\":\\\"%s\\\"\", name), String.format(\"\\\"intent\\\":\\\"%s\\\"\", intent));\n+  }\n+\n+  // returns true if it finds a line that contains every piece.\n+  boolean hasLogContaining(final String... piece) {\n+    return getLogContaining(piece) != null;\n+  }\n+\n+  String getLogContaining(final String... piece) {", "originalCommit": "731af01f6e3a1e355fc3f71bb677499727c3cd0a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI0NjMzMQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/3939#discussion_r388246331", "bodyText": "This case seems to be the same as \"message subscription\". I guess the message should be published before, right?", "author": "saig0", "createdAt": "2020-03-05T11:52:56Z", "path": "upgrade-tests/src/test/java/io/zeebe/test/UpgradeTest.java", "diffHunk": "@@ -73,10 +75,74 @@\n           {\n             \"job\",\n             scenario()\n-                .createInstance(jobWorkflow())\n-                .beforeUpgrade(activateJob())\n-                .afterUpgrade(completeJob())\n+                .deployWorkflow(jobWorkflow())\n+                .createInstance()\n+                .beforeUpgrade(UpgradeTest::activateJob)\n+                .afterUpgrade(UpgradeTest::completeJob)\n+                .done()\n           },\n+          {\n+            \"message subscription\",\n+            scenario()\n+                .deployWorkflow(msgWorkflow())\n+                .createInstance()\n+                .beforeUpgrade(UpgradeTest::messageSubscription)\n+                .afterUpgrade(UpgradeTest::publishMessage)\n+                .done()\n+          },\n+          {\n+            \"message start event\",\n+            scenario()\n+                .deployWorkflow(msgStartWorkflow())\n+                .beforeUpgrade(UpgradeTest::startMsgSubscription)\n+                .afterUpgrade(UpgradeTest::publishMessage)\n+                .done()\n+          },\n+          {\n+            \"timer\",\n+            scenario()\n+                .deployWorkflow(timerWorkflow())\n+                .beforeUpgrade(UpgradeTest::timerCreated)\n+                .afterUpgrade(UpgradeTest::timerTriggered)\n+                .done()\n+          },\n+          {\n+            \"incident\",\n+            scenario()\n+                .deployWorkflow(incidentWorkflow())\n+                .createInstance()\n+                .beforeUpgrade(UpgradeTest::createIncident)\n+                .afterUpgrade(UpgradeTest::resolveIncident)\n+                .done()\n+          },\n+          {\n+            \"publish message\",\n+            scenario()\n+                .deployWorkflow(msgWorkflow())\n+                .createInstance()\n+                .beforeUpgrade(UpgradeTest::messageSubscription)\n+                .afterUpgrade(UpgradeTest::publishMessage)\n+                .done()", "originalCommit": "731af01f6e3a1e355fc3f71bb677499727c3cd0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI5ODM0NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/3939#discussion_r388298344", "bodyText": "That's right, my mistake. Thanks", "author": "MiguelPires", "createdAt": "2020-03-05T13:40:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI0NjMzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI0OTQ1NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/3939#discussion_r388249454", "bodyText": "This test is a bit different from the others as there is no beforeUpgrade() step. Maybe, it makes sense to create the instance before and it waits in the child instance (e.g. via service task). On afterUpgrade(), the child instance can be completed and the parent should also be completed. This way, we can cover more paths.", "author": "saig0", "createdAt": "2020-03-05T11:59:49Z", "path": "upgrade-tests/src/test/java/io/zeebe/test/UpgradeTest.java", "diffHunk": "@@ -73,10 +75,74 @@\n           {\n             \"job\",\n             scenario()\n-                .createInstance(jobWorkflow())\n-                .beforeUpgrade(activateJob())\n-                .afterUpgrade(completeJob())\n+                .deployWorkflow(jobWorkflow())\n+                .createInstance()\n+                .beforeUpgrade(UpgradeTest::activateJob)\n+                .afterUpgrade(UpgradeTest::completeJob)\n+                .done()\n           },\n+          {\n+            \"message subscription\",\n+            scenario()\n+                .deployWorkflow(msgWorkflow())\n+                .createInstance()\n+                .beforeUpgrade(UpgradeTest::messageSubscription)\n+                .afterUpgrade(UpgradeTest::publishMessage)\n+                .done()\n+          },\n+          {\n+            \"message start event\",\n+            scenario()\n+                .deployWorkflow(msgStartWorkflow())\n+                .beforeUpgrade(UpgradeTest::startMsgSubscription)\n+                .afterUpgrade(UpgradeTest::publishMessage)\n+                .done()\n+          },\n+          {\n+            \"timer\",\n+            scenario()\n+                .deployWorkflow(timerWorkflow())\n+                .beforeUpgrade(UpgradeTest::timerCreated)\n+                .afterUpgrade(UpgradeTest::timerTriggered)\n+                .done()\n+          },\n+          {\n+            \"incident\",\n+            scenario()\n+                .deployWorkflow(incidentWorkflow())\n+                .createInstance()\n+                .beforeUpgrade(UpgradeTest::createIncident)\n+                .afterUpgrade(UpgradeTest::resolveIncident)\n+                .done()\n+          },\n+          {\n+            \"publish message\",\n+            scenario()\n+                .deployWorkflow(msgWorkflow())\n+                .createInstance()\n+                .beforeUpgrade(UpgradeTest::messageSubscription)\n+                .afterUpgrade(UpgradeTest::publishMessage)\n+                .done()\n+          },\n+          {\n+            \"call activity\",\n+            scenario()\n+                .deployWorkflow(\n+                    new Tuple<>(parentWorkflow(), PROCESS_ID),\n+                    new Tuple<>(childWorkflow(), CHILD_PROCESS_ID))\n+                .afterUpgrade(\n+                    (state, wfKey, key) ->\n+                        state\n+                            .client()\n+                            .newCreateInstanceCommand()\n+                            .bpmnProcessId(PROCESS_ID)\n+                            .latestVersion()\n+                            .variables(Map.of(\"key\", \"123\"))\n+                            .send()\n+                            .join()\n+                            .getWorkflowInstanceKey())", "originalCommit": "731af01f6e3a1e355fc3f71bb677499727c3cd0a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI0OTgwMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/3939#discussion_r388249802", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static BpmnModelInstance msgStartWorkflow() {\n          \n          \n            \n              private static BpmnModelInstance messageStartEventWorkflow() {", "author": "saig0", "createdAt": "2020-03-05T12:00:31Z", "path": "upgrade-tests/src/test/java/io/zeebe/test/UpgradeTest.java", "diffHunk": "@@ -137,73 +203,118 @@ private static BpmnModelInstance jobWorkflow() {\n         .done();\n   }\n \n-  private static Function<ContainerStateRule, Long> activateJob() {\n-    return (ContainerStateRule state) -> {\n-      final ActivateJobsResponse jobsResponse =\n-          state.client().newActivateJobsCommand().jobType(TASK).maxJobsToActivate(1).send().join();\n+  private static long activateJob(final ContainerStateRule state) {\n+    final ActivateJobsResponse jobsResponse =\n+        state.client().newActivateJobsCommand().jobType(TASK).maxJobsToActivate(1).send().join();\n \n-      TestUtil.waitUntil(() -> state.hasElementInState(TASK, \"ACTIVATED\"));\n-      return jobsResponse.getJobs().get(0).getKey();\n-    };\n+    TestUtil.waitUntil(() -> state.hasElementInState(TASK, \"ACTIVATED\"));\n+    return jobsResponse.getJobs().get(0).getKey();\n   }\n \n-  private static BiConsumer<ContainerStateRule, Long> completeJob() {\n-    return (ContainerStateRule state, Long key) ->\n-        state.client().newCompleteCommand(key).send().join();\n+  private static void completeJob(\n+      final ContainerStateRule state, final long wfInstanceKey, final long key) {\n+    state.client().newCompleteCommand(key).send().join();\n   }\n \n-  private static TestCase scenario() {\n-    return new TestCase();\n+  private static BpmnModelInstance msgWorkflow() {\n+    return Bpmn.createExecutableProcess(PROCESS_ID)\n+        .startEvent()\n+        .intermediateCatchEvent(\n+            \"catch\", b -> b.message(m -> m.name(MSG).zeebeCorrelationKey(\"key\")))\n+        .endEvent()\n+        .done();\n   }\n \n-  private static class TestCase {\n-    private Consumer<ZeebeClient> createInstance;\n-    private Function<ContainerStateRule, Long> before;\n-    private BiConsumer<ContainerStateRule, Long> after;\n+  private static long messageSubscription(final ContainerStateRule state) {\n+    TestUtil.waitUntil(() -> state.hasLogContaining(\"WORKFLOW_INSTANCE_SUBSCRIPTION\", \"OPENED\"));\n+    return -1L;\n+  }\n \n-    TestCase createInstance(final BpmnModelInstance model) {\n-      this.createInstance =\n-          client -> {\n-            client.newDeployCommand().addWorkflowModel(model, PROCESS_ID + \".bpmn\").send().join();\n-            client\n-                .newCreateInstanceCommand()\n-                .bpmnProcessId(PROCESS_ID)\n-                .latestVersion()\n-                .send()\n-                .join();\n-          };\n-      return this;\n-    }\n+  private static void publishMessage(\n+      final ContainerStateRule state, final long wfInstanceKey, final long key) {\n+    state\n+        .client()\n+        .newPublishMessageCommand()\n+        .messageName(MSG)\n+        .correlationKey(\"123\")\n+        .timeToLive(Duration.ofMinutes(5))\n+        .send()\n+        .join();\n \n-    /**\n-     * Should make zeebe write records and write to state of the feature being tested (e.g., jobs,\n-     * messages). The workflow should be left in a waiting state so Zeebe can be restarted and\n-     * execution can be continued after. Takes the container rule as input and outputs a long which\n-     * can be used after the upgrade to continue the execution.\n-     */\n-    TestCase beforeUpgrade(final Function<ContainerStateRule, Long> func) {\n-      this.before = func;\n-      return this;\n-    }\n-    /**\n-     * Should continue the instance after the upgrade in a way that will complete the workflow.\n-     * Takes the container rule and a long (e.g., a key) as input.\n-     */\n-    TestCase afterUpgrade(final BiConsumer<ContainerStateRule, Long> func) {\n-      this.after = func;\n-      return this;\n-    }\n+    TestUtil.waitUntil(() -> state.hasMessageInState(MSG, \"PUBLISHED\"));\n+  }\n \n-    public Consumer<ZeebeClient> createInstance() {\n-      return createInstance;\n-    }\n+  private static BpmnModelInstance msgStartWorkflow() {", "originalCommit": "731af01f6e3a1e355fc3f71bb677499727c3cd0a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1MDA5NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/3939#discussion_r388250095", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static long startMsgSubscription(final ContainerStateRule state) {\n          \n          \n            \n              private static long awaitStartEventMessageSubscriptionOpened(final ContainerStateRule state) {", "author": "saig0", "createdAt": "2020-03-05T12:01:07Z", "path": "upgrade-tests/src/test/java/io/zeebe/test/UpgradeTest.java", "diffHunk": "@@ -137,73 +203,118 @@ private static BpmnModelInstance jobWorkflow() {\n         .done();\n   }\n \n-  private static Function<ContainerStateRule, Long> activateJob() {\n-    return (ContainerStateRule state) -> {\n-      final ActivateJobsResponse jobsResponse =\n-          state.client().newActivateJobsCommand().jobType(TASK).maxJobsToActivate(1).send().join();\n+  private static long activateJob(final ContainerStateRule state) {\n+    final ActivateJobsResponse jobsResponse =\n+        state.client().newActivateJobsCommand().jobType(TASK).maxJobsToActivate(1).send().join();\n \n-      TestUtil.waitUntil(() -> state.hasElementInState(TASK, \"ACTIVATED\"));\n-      return jobsResponse.getJobs().get(0).getKey();\n-    };\n+    TestUtil.waitUntil(() -> state.hasElementInState(TASK, \"ACTIVATED\"));\n+    return jobsResponse.getJobs().get(0).getKey();\n   }\n \n-  private static BiConsumer<ContainerStateRule, Long> completeJob() {\n-    return (ContainerStateRule state, Long key) ->\n-        state.client().newCompleteCommand(key).send().join();\n+  private static void completeJob(\n+      final ContainerStateRule state, final long wfInstanceKey, final long key) {\n+    state.client().newCompleteCommand(key).send().join();\n   }\n \n-  private static TestCase scenario() {\n-    return new TestCase();\n+  private static BpmnModelInstance msgWorkflow() {\n+    return Bpmn.createExecutableProcess(PROCESS_ID)\n+        .startEvent()\n+        .intermediateCatchEvent(\n+            \"catch\", b -> b.message(m -> m.name(MSG).zeebeCorrelationKey(\"key\")))\n+        .endEvent()\n+        .done();\n   }\n \n-  private static class TestCase {\n-    private Consumer<ZeebeClient> createInstance;\n-    private Function<ContainerStateRule, Long> before;\n-    private BiConsumer<ContainerStateRule, Long> after;\n+  private static long messageSubscription(final ContainerStateRule state) {\n+    TestUtil.waitUntil(() -> state.hasLogContaining(\"WORKFLOW_INSTANCE_SUBSCRIPTION\", \"OPENED\"));\n+    return -1L;\n+  }\n \n-    TestCase createInstance(final BpmnModelInstance model) {\n-      this.createInstance =\n-          client -> {\n-            client.newDeployCommand().addWorkflowModel(model, PROCESS_ID + \".bpmn\").send().join();\n-            client\n-                .newCreateInstanceCommand()\n-                .bpmnProcessId(PROCESS_ID)\n-                .latestVersion()\n-                .send()\n-                .join();\n-          };\n-      return this;\n-    }\n+  private static void publishMessage(\n+      final ContainerStateRule state, final long wfInstanceKey, final long key) {\n+    state\n+        .client()\n+        .newPublishMessageCommand()\n+        .messageName(MSG)\n+        .correlationKey(\"123\")\n+        .timeToLive(Duration.ofMinutes(5))\n+        .send()\n+        .join();\n \n-    /**\n-     * Should make zeebe write records and write to state of the feature being tested (e.g., jobs,\n-     * messages). The workflow should be left in a waiting state so Zeebe can be restarted and\n-     * execution can be continued after. Takes the container rule as input and outputs a long which\n-     * can be used after the upgrade to continue the execution.\n-     */\n-    TestCase beforeUpgrade(final Function<ContainerStateRule, Long> func) {\n-      this.before = func;\n-      return this;\n-    }\n-    /**\n-     * Should continue the instance after the upgrade in a way that will complete the workflow.\n-     * Takes the container rule and a long (e.g., a key) as input.\n-     */\n-    TestCase afterUpgrade(final BiConsumer<ContainerStateRule, Long> func) {\n-      this.after = func;\n-      return this;\n-    }\n+    TestUtil.waitUntil(() -> state.hasMessageInState(MSG, \"PUBLISHED\"));\n+  }\n \n-    public Consumer<ZeebeClient> createInstance() {\n-      return createInstance;\n-    }\n+  private static BpmnModelInstance msgStartWorkflow() {\n+    return Bpmn.createExecutableProcess(PROCESS_ID)\n+        .startEvent()\n+        .message(b -> b.zeebeCorrelationKey(\"key\").name(MSG))\n+        .endEvent()\n+        .done();\n+  }\n \n-    public Function<ContainerStateRule, Long> before() {\n-      return before;\n-    }\n+  private static long startMsgSubscription(final ContainerStateRule state) {", "originalCommit": "731af01f6e3a1e355fc3f71bb677499727c3cd0a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1MDMxOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/3939#discussion_r388250319", "bodyText": "Trying to aline the names.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static long timerCreated(final ContainerStateRule state) {\n          \n          \n            \n              private static long awaitTimerCreated(final ContainerStateRule state) {", "author": "saig0", "createdAt": "2020-03-05T12:01:37Z", "path": "upgrade-tests/src/test/java/io/zeebe/test/UpgradeTest.java", "diffHunk": "@@ -137,73 +203,118 @@ private static BpmnModelInstance jobWorkflow() {\n         .done();\n   }\n \n-  private static Function<ContainerStateRule, Long> activateJob() {\n-    return (ContainerStateRule state) -> {\n-      final ActivateJobsResponse jobsResponse =\n-          state.client().newActivateJobsCommand().jobType(TASK).maxJobsToActivate(1).send().join();\n+  private static long activateJob(final ContainerStateRule state) {\n+    final ActivateJobsResponse jobsResponse =\n+        state.client().newActivateJobsCommand().jobType(TASK).maxJobsToActivate(1).send().join();\n \n-      TestUtil.waitUntil(() -> state.hasElementInState(TASK, \"ACTIVATED\"));\n-      return jobsResponse.getJobs().get(0).getKey();\n-    };\n+    TestUtil.waitUntil(() -> state.hasElementInState(TASK, \"ACTIVATED\"));\n+    return jobsResponse.getJobs().get(0).getKey();\n   }\n \n-  private static BiConsumer<ContainerStateRule, Long> completeJob() {\n-    return (ContainerStateRule state, Long key) ->\n-        state.client().newCompleteCommand(key).send().join();\n+  private static void completeJob(\n+      final ContainerStateRule state, final long wfInstanceKey, final long key) {\n+    state.client().newCompleteCommand(key).send().join();\n   }\n \n-  private static TestCase scenario() {\n-    return new TestCase();\n+  private static BpmnModelInstance msgWorkflow() {\n+    return Bpmn.createExecutableProcess(PROCESS_ID)\n+        .startEvent()\n+        .intermediateCatchEvent(\n+            \"catch\", b -> b.message(m -> m.name(MSG).zeebeCorrelationKey(\"key\")))\n+        .endEvent()\n+        .done();\n   }\n \n-  private static class TestCase {\n-    private Consumer<ZeebeClient> createInstance;\n-    private Function<ContainerStateRule, Long> before;\n-    private BiConsumer<ContainerStateRule, Long> after;\n+  private static long messageSubscription(final ContainerStateRule state) {\n+    TestUtil.waitUntil(() -> state.hasLogContaining(\"WORKFLOW_INSTANCE_SUBSCRIPTION\", \"OPENED\"));\n+    return -1L;\n+  }\n \n-    TestCase createInstance(final BpmnModelInstance model) {\n-      this.createInstance =\n-          client -> {\n-            client.newDeployCommand().addWorkflowModel(model, PROCESS_ID + \".bpmn\").send().join();\n-            client\n-                .newCreateInstanceCommand()\n-                .bpmnProcessId(PROCESS_ID)\n-                .latestVersion()\n-                .send()\n-                .join();\n-          };\n-      return this;\n-    }\n+  private static void publishMessage(\n+      final ContainerStateRule state, final long wfInstanceKey, final long key) {\n+    state\n+        .client()\n+        .newPublishMessageCommand()\n+        .messageName(MSG)\n+        .correlationKey(\"123\")\n+        .timeToLive(Duration.ofMinutes(5))\n+        .send()\n+        .join();\n \n-    /**\n-     * Should make zeebe write records and write to state of the feature being tested (e.g., jobs,\n-     * messages). The workflow should be left in a waiting state so Zeebe can be restarted and\n-     * execution can be continued after. Takes the container rule as input and outputs a long which\n-     * can be used after the upgrade to continue the execution.\n-     */\n-    TestCase beforeUpgrade(final Function<ContainerStateRule, Long> func) {\n-      this.before = func;\n-      return this;\n-    }\n-    /**\n-     * Should continue the instance after the upgrade in a way that will complete the workflow.\n-     * Takes the container rule and a long (e.g., a key) as input.\n-     */\n-    TestCase afterUpgrade(final BiConsumer<ContainerStateRule, Long> func) {\n-      this.after = func;\n-      return this;\n-    }\n+    TestUtil.waitUntil(() -> state.hasMessageInState(MSG, \"PUBLISHED\"));\n+  }\n \n-    public Consumer<ZeebeClient> createInstance() {\n-      return createInstance;\n-    }\n+  private static BpmnModelInstance msgStartWorkflow() {\n+    return Bpmn.createExecutableProcess(PROCESS_ID)\n+        .startEvent()\n+        .message(b -> b.zeebeCorrelationKey(\"key\").name(MSG))\n+        .endEvent()\n+        .done();\n+  }\n \n-    public Function<ContainerStateRule, Long> before() {\n-      return before;\n-    }\n+  private static long startMsgSubscription(final ContainerStateRule state) {\n+    TestUtil.waitUntil(() -> state.hasLogContaining(\"MESSAGE_START_EVENT_SUBSCRIPTION\", \"OPENED\"));\n+    return -1L;\n+  }\n \n-    public BiConsumer<ContainerStateRule, Long> after() {\n-      return after;\n-    }\n+  private static BpmnModelInstance timerWorkflow() {\n+    return Bpmn.createExecutableProcess(PROCESS_ID)\n+        .startEvent()\n+        .timerWithCycle(\"R/PT1S\")\n+        .endEvent()\n+        .done();\n+  }\n+\n+  private static long timerCreated(final ContainerStateRule state) {", "originalCommit": "731af01f6e3a1e355fc3f71bb677499727c3cd0a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1MTEwNg==", "url": "https://github.com/camunda-cloud/zeebe/pull/3939#discussion_r388251106", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static long createIncident(final ContainerStateRule state) {\n          \n          \n            \n              private static long awaitIncidentCreated(final ContainerStateRule state) {", "author": "saig0", "createdAt": "2020-03-05T12:03:19Z", "path": "upgrade-tests/src/test/java/io/zeebe/test/UpgradeTest.java", "diffHunk": "@@ -137,73 +203,118 @@ private static BpmnModelInstance jobWorkflow() {\n         .done();\n   }\n \n-  private static Function<ContainerStateRule, Long> activateJob() {\n-    return (ContainerStateRule state) -> {\n-      final ActivateJobsResponse jobsResponse =\n-          state.client().newActivateJobsCommand().jobType(TASK).maxJobsToActivate(1).send().join();\n+  private static long activateJob(final ContainerStateRule state) {\n+    final ActivateJobsResponse jobsResponse =\n+        state.client().newActivateJobsCommand().jobType(TASK).maxJobsToActivate(1).send().join();\n \n-      TestUtil.waitUntil(() -> state.hasElementInState(TASK, \"ACTIVATED\"));\n-      return jobsResponse.getJobs().get(0).getKey();\n-    };\n+    TestUtil.waitUntil(() -> state.hasElementInState(TASK, \"ACTIVATED\"));\n+    return jobsResponse.getJobs().get(0).getKey();\n   }\n \n-  private static BiConsumer<ContainerStateRule, Long> completeJob() {\n-    return (ContainerStateRule state, Long key) ->\n-        state.client().newCompleteCommand(key).send().join();\n+  private static void completeJob(\n+      final ContainerStateRule state, final long wfInstanceKey, final long key) {\n+    state.client().newCompleteCommand(key).send().join();\n   }\n \n-  private static TestCase scenario() {\n-    return new TestCase();\n+  private static BpmnModelInstance msgWorkflow() {\n+    return Bpmn.createExecutableProcess(PROCESS_ID)\n+        .startEvent()\n+        .intermediateCatchEvent(\n+            \"catch\", b -> b.message(m -> m.name(MSG).zeebeCorrelationKey(\"key\")))\n+        .endEvent()\n+        .done();\n   }\n \n-  private static class TestCase {\n-    private Consumer<ZeebeClient> createInstance;\n-    private Function<ContainerStateRule, Long> before;\n-    private BiConsumer<ContainerStateRule, Long> after;\n+  private static long messageSubscription(final ContainerStateRule state) {\n+    TestUtil.waitUntil(() -> state.hasLogContaining(\"WORKFLOW_INSTANCE_SUBSCRIPTION\", \"OPENED\"));\n+    return -1L;\n+  }\n \n-    TestCase createInstance(final BpmnModelInstance model) {\n-      this.createInstance =\n-          client -> {\n-            client.newDeployCommand().addWorkflowModel(model, PROCESS_ID + \".bpmn\").send().join();\n-            client\n-                .newCreateInstanceCommand()\n-                .bpmnProcessId(PROCESS_ID)\n-                .latestVersion()\n-                .send()\n-                .join();\n-          };\n-      return this;\n-    }\n+  private static void publishMessage(\n+      final ContainerStateRule state, final long wfInstanceKey, final long key) {\n+    state\n+        .client()\n+        .newPublishMessageCommand()\n+        .messageName(MSG)\n+        .correlationKey(\"123\")\n+        .timeToLive(Duration.ofMinutes(5))\n+        .send()\n+        .join();\n \n-    /**\n-     * Should make zeebe write records and write to state of the feature being tested (e.g., jobs,\n-     * messages). The workflow should be left in a waiting state so Zeebe can be restarted and\n-     * execution can be continued after. Takes the container rule as input and outputs a long which\n-     * can be used after the upgrade to continue the execution.\n-     */\n-    TestCase beforeUpgrade(final Function<ContainerStateRule, Long> func) {\n-      this.before = func;\n-      return this;\n-    }\n-    /**\n-     * Should continue the instance after the upgrade in a way that will complete the workflow.\n-     * Takes the container rule and a long (e.g., a key) as input.\n-     */\n-    TestCase afterUpgrade(final BiConsumer<ContainerStateRule, Long> func) {\n-      this.after = func;\n-      return this;\n-    }\n+    TestUtil.waitUntil(() -> state.hasMessageInState(MSG, \"PUBLISHED\"));\n+  }\n \n-    public Consumer<ZeebeClient> createInstance() {\n-      return createInstance;\n-    }\n+  private static BpmnModelInstance msgStartWorkflow() {\n+    return Bpmn.createExecutableProcess(PROCESS_ID)\n+        .startEvent()\n+        .message(b -> b.zeebeCorrelationKey(\"key\").name(MSG))\n+        .endEvent()\n+        .done();\n+  }\n \n-    public Function<ContainerStateRule, Long> before() {\n-      return before;\n-    }\n+  private static long startMsgSubscription(final ContainerStateRule state) {\n+    TestUtil.waitUntil(() -> state.hasLogContaining(\"MESSAGE_START_EVENT_SUBSCRIPTION\", \"OPENED\"));\n+    return -1L;\n+  }\n \n-    public BiConsumer<ContainerStateRule, Long> after() {\n-      return after;\n-    }\n+  private static BpmnModelInstance timerWorkflow() {\n+    return Bpmn.createExecutableProcess(PROCESS_ID)\n+        .startEvent()\n+        .timerWithCycle(\"R/PT1S\")\n+        .endEvent()\n+        .done();\n+  }\n+\n+  private static long timerCreated(final ContainerStateRule state) {\n+    TestUtil.waitUntil(() -> state.hasLogContaining(\"TIMER\", \"CREATED\"));\n+    return -1L;\n+  }\n+\n+  private static void timerTriggered(\n+      final ContainerStateRule state, final long wfInstanceKey, final long key) {\n+    TestUtil.waitUntil(() -> state.hasLogContaining(\"TIMER\", \"TRIGGERED\"));\n+  }\n+\n+  private static BpmnModelInstance incidentWorkflow() {\n+    return Bpmn.createExecutableProcess(\"process\")\n+        .startEvent()\n+        .serviceTask(\"failingTask\", t -> t.zeebeTaskType(TASK).zeebeInput(\"foo\", \"foo\"))\n+        .done();\n+  }\n+\n+  private static long createIncident(final ContainerStateRule state) {", "originalCommit": "731af01f6e3a1e355fc3f71bb677499727c3cd0a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1ODk0MA==", "url": "https://github.com/camunda-cloud/zeebe/pull/3939#discussion_r388258940", "bodyText": "Is there a reason why you don't use visibility modifiers (private/public) anymore?", "author": "saig0", "createdAt": "2020-03-05T12:20:46Z", "path": "upgrade-tests/src/test/java/io/zeebe/test/UpgradeTestCase.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.test;\n+\n+import io.zeebe.client.ZeebeClient;\n+import io.zeebe.model.bpmn.BpmnModelInstance;\n+import io.zeebe.util.collection.Tuple;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+final class UpgradeTestCase {", "originalCommit": "731af01f6e3a1e355fc3f71bb677499727c3cd0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI5NTc3NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/3939#discussion_r388295774", "bodyText": "This class is pretty much tied to the upgrade test in the same package so I didn't think it was important since it's unlikely other tests will use it. But I can change it", "author": "MiguelPires", "createdAt": "2020-03-05T13:35:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI1ODk0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI2MTk5Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/3939#discussion_r388261997", "bodyText": "Without any comment, it is not clear that these variables are required by the message correlation tests. We could pass the variables from the test (where they are needed) or add at least a comment.", "author": "saig0", "createdAt": "2020-03-05T12:27:48Z", "path": "upgrade-tests/src/test/java/io/zeebe/test/UpgradeTestCase.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.test;\n+\n+import io.zeebe.client.ZeebeClient;\n+import io.zeebe.model.bpmn.BpmnModelInstance;\n+import io.zeebe.util.collection.Tuple;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+final class UpgradeTestCase {\n+  private TestCaseBuilder builder;\n+\n+  private UpgradeTestCase(final TestCaseBuilder builder) {\n+    this.builder = builder;\n+  }\n+\n+  static TestCaseBuilder builder() {\n+    return new TestCaseBuilder();\n+  }\n+\n+  long setUp(final ZeebeClient client) {\n+    builder.deployWorkflow.accept(client);\n+    return builder.createInstance.apply(client);\n+  }\n+\n+  Long runBefore(final ContainerStateRule state) {\n+    return builder.before.apply(state);\n+  }\n+\n+  void runAfter(final ContainerStateRule state, final long wfInstanceKey, final long key) {\n+    builder.after.accept(state, wfInstanceKey, key);\n+  }\n+\n+  static class TestCaseBuilder {\n+    private Consumer<ZeebeClient> deployWorkflow = c -> {};\n+    private Function<ZeebeClient, Long> createInstance = c -> -1L;\n+    private Function<ContainerStateRule, Long> before = r -> -1L;\n+    private TriConsumer<ContainerStateRule, Long, Long> after = (r, wfKey, k) -> {};\n+\n+    TestCaseBuilder deployWorkflow(final BpmnModelInstance model) {\n+      return deployWorkflow(new Tuple<>(model, UpgradeTest.PROCESS_ID));\n+    }\n+\n+    @SafeVarargs\n+    final TestCaseBuilder deployWorkflow(final Tuple<BpmnModelInstance, String>... models) {\n+      for (final Tuple<BpmnModelInstance, String> model : models) {\n+        deployWorkflow =\n+            deployWorkflow.andThen(\n+                client ->\n+                    client\n+                        .newDeployCommand()\n+                        .addWorkflowModel(model.getLeft(), model.getRight() + \".bpmn\")\n+                        .send()\n+                        .join());\n+      }\n+      return this;\n+    }\n+\n+    TestCaseBuilder createInstance() {\n+      createInstance =\n+          client ->\n+              client\n+                  .newCreateInstanceCommand()\n+                  .bpmnProcessId(UpgradeTest.PROCESS_ID)\n+                  .latestVersion()\n+                  .variables(Map.of(\"key\", \"123\"))", "originalCommit": "731af01f6e3a1e355fc3f71bb677499727c3cd0a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b6d555ec0f24b3b1389fdbbc15b77327fe3a8a30", "url": "https://github.com/camunda-cloud/zeebe/commit/b6d555ec0f24b3b1389fdbbc15b77327fe3a8a30", "message": "chore(upgrade-tests): review feedback", "committedDate": "2020-03-05T13:47:02Z", "type": "forcePushed"}, {"oid": "8b3e9be050b665a2acb7b49a6fddd7b0c185e457", "url": "https://github.com/camunda-cloud/zeebe/commit/8b3e9be050b665a2acb7b49a6fddd7b0c185e457", "message": "chore(upgrade-tests): review feedback", "committedDate": "2020-03-05T13:53:19Z", "type": "forcePushed"}, {"oid": "7ef32f4a2b3826743341fe84b35e36aa274cf366", "url": "https://github.com/camunda-cloud/zeebe/commit/7ef32f4a2b3826743341fe84b35e36aa274cf366", "message": "chore(upgrade-tests): review feedback", "committedDate": "2020-03-05T13:57:57Z", "type": "forcePushed"}, {"oid": "250255fcce6eaba705c0609d0d3baa195352396f", "url": "https://github.com/camunda-cloud/zeebe/commit/250255fcce6eaba705c0609d0d3baa195352396f", "message": "chore(upgrade-tests): review feedback", "committedDate": "2020-03-05T14:03:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODMxNTAyOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/3939#discussion_r388315028", "bodyText": "We should verify that the child and parent instances are completed.", "author": "saig0", "createdAt": "2020-03-05T14:08:41Z", "path": "upgrade-tests/src/test/java/io/zeebe/test/UpgradeTest.java", "diffHunk": "@@ -130,17 +135,23 @@\n                 .deployWorkflow(\n                     new Tuple<>(parentWorkflow(), PROCESS_ID),\n                     new Tuple<>(childWorkflow(), CHILD_PROCESS_ID))\n+                .createInstance()\n                 .afterUpgrade(\n-                    (state, wfKey, key) ->\n-                        state\n-                            .client()\n-                            .newCreateInstanceCommand()\n-                            .bpmnProcessId(PROCESS_ID)\n-                            .latestVersion()\n-                            .variables(Map.of(\"key\", \"123\"))\n-                            .send()\n-                            .join()\n-                            .getWorkflowInstanceKey())\n+                    (state, wfKey, key) -> {\n+                      final ActivatedJob job =\n+                          state\n+                              .client()\n+                              .newActivateJobsCommand()\n+                              .jobType(TASK)\n+                              .maxJobsToActivate(1)\n+                              .send()\n+                              .join()\n+                              .getJobs()\n+                              .iterator()\n+                              .next();\n+\n+                      state.client().newCompleteCommand(job.getKey()).send().join();", "originalCommit": "250255fcce6eaba705c0609d0d3baa195352396f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODMyNTYzOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/3939#discussion_r388325638", "bodyText": "The tests always check that the PROCESS_ID instance completes and that can't complete without the child process completing first right?\nEdit: But I can add a check for the child process anyway", "author": "MiguelPires", "createdAt": "2020-03-05T14:25:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODMxNTAyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODMxNTU5Mw==", "url": "https://github.com/camunda-cloud/zeebe/pull/3939#discussion_r388315593", "bodyText": "Not exactly. We should create the instance after the upgrade and verify that the previously published message is correlated.", "author": "saig0", "createdAt": "2020-03-05T14:09:41Z", "path": "upgrade-tests/src/test/java/io/zeebe/test/UpgradeTest.java", "diffHunk": "@@ -111,17 +112,21 @@\n             scenario()\n                 .deployWorkflow(incidentWorkflow())\n                 .createInstance()\n-                .beforeUpgrade(UpgradeTest::createIncident)\n+                .beforeUpgrade(UpgradeTest::awaitIncidentCreation)\n                 .afterUpgrade(UpgradeTest::resolveIncident)\n                 .done()\n           },\n           {\n             \"publish message\",\n             scenario()\n                 .deployWorkflow(messageWorkflow())\n-                .createInstance()\n-                .beforeUpgrade(UpgradeTest::awaitOpenMessageSubscription)\n-                .afterUpgrade(UpgradeTest::publishMessage)\n+                .createInstance(Map.of(\"key\", \"123\"))\n+                .beforeUpgrade(\n+                    state -> {\n+                      publishMessage(state, -1L, -1L);\n+                      return -1L;\n+                    })\n+                .afterUpgrade((state, k1, k2) -> awaitOpenMessageSubscription(state))", "originalCommit": "250255fcce6eaba705c0609d0d3baa195352396f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e9c0062c21bcba3f2899e5da2b7951a0280d6a85", "url": "https://github.com/camunda-cloud/zeebe/commit/e9c0062c21bcba3f2899e5da2b7951a0280d6a85", "message": "chore(upgrade-tests): refactor upgrade test case", "committedDate": "2020-03-06T09:04:56Z", "type": "commit"}, {"oid": "eec8602baf18d7c5ffad52f532ce2b18fb2568bd", "url": "https://github.com/camunda-cloud/zeebe/commit/eec8602baf18d7c5ffad52f532ce2b18fb2568bd", "message": "chore(upgrade-tests): cover start message event", "committedDate": "2020-03-06T09:04:56Z", "type": "commit"}, {"oid": "5e74e2ddc9c70139df46f2cd6462a139a7af1a88", "url": "https://github.com/camunda-cloud/zeebe/commit/5e74e2ddc9c70139df46f2cd6462a139a7af1a88", "message": "chore(upgrade-tests): cover timer upgradability", "committedDate": "2020-03-06T09:04:56Z", "type": "commit"}, {"oid": "311155492ce381802bb99b3e2765bbc3a67db693", "url": "https://github.com/camunda-cloud/zeebe/commit/311155492ce381802bb99b3e2765bbc3a67db693", "message": "chore(upgrade-tests): cover incident upgradability", "committedDate": "2020-03-06T09:04:56Z", "type": "commit"}, {"oid": "9cdfbd7673c04bc993bab6ab55a83ed79c3e407b", "url": "https://github.com/camunda-cloud/zeebe/commit/9cdfbd7673c04bc993bab6ab55a83ed79c3e407b", "message": "chore(upgrade-tests): cover message records", "committedDate": "2020-03-06T09:04:56Z", "type": "commit"}, {"oid": "dea3ea7481ea4c7796f4ff69b275e6f49ba86e98", "url": "https://github.com/camunda-cloud/zeebe/commit/dea3ea7481ea4c7796f4ff69b275e6f49ba86e98", "message": "chore(upgrade-tests): cover call activity", "committedDate": "2020-03-06T09:04:56Z", "type": "commit"}, {"oid": "dea3ea7481ea4c7796f4ff69b275e6f49ba86e98", "url": "https://github.com/camunda-cloud/zeebe/commit/dea3ea7481ea4c7796f4ff69b275e6f49ba86e98", "message": "chore(upgrade-tests): cover call activity", "committedDate": "2020-03-06T09:04:56Z", "type": "forcePushed"}]}