{"pr_number": 5348, "pr_title": "chore(engine): update last processed position after reprocessing", "pr_createdAt": "2020-09-15T07:14:45Z", "pr_url": "https://github.com/camunda-cloud/zeebe/pull/5348", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE4Njg3NQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5348#discussion_r489186875", "bodyText": "It looks a bit odd to set the last processed position from outside.\nIf it is important to update the metrics with the position then I recommend creating a new method for starting the processing that takes the position as an argument. This makes it more clear that the position should be set only when the processing is started.\nOtherwise, we could implement this logic also in StreamProcessor.getLastProcessedPositionAsync().\nWhat do you think?", "author": "saig0", "createdAt": "2020-09-16T06:13:05Z", "path": "engine/src/main/java/io/zeebe/engine/processing/streamprocessor/ProcessingStateMachine.java", "diffHunk": "@@ -443,4 +443,11 @@ public long getLastWrittenEventPosition() {\n   public boolean isMakingProgress() {\n     return !onErrorHandlingLoop;\n   }\n+\n+  public void initLastProcessedPosition(final long lastReprocessedPosition) {\n+    if (lastSuccessfulProcessedEventPosition == StreamProcessor.UNSET_POSITION) {\n+      lastSuccessfulProcessedEventPosition = lastReprocessedPosition;\n+      metrics.setLastProcessedPosition(lastSuccessfulProcessedEventPosition);\n+    }", "originalCommit": "e8415ebfe5362292297b6a9404f31219d8d3e900", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDExNTUwOA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5348#discussion_r490115508", "bodyText": "I created a new method for starting the processing. I think we should not update the metrics. If we update it, it gives the wrong information that something is processed even though we have only reprocessed it. So I removed the metrics update.", "author": "deepthidevaki", "createdAt": "2020-09-17T09:48:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE4Njg3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE4NzAyOQ==", "url": "https://github.com/camunda-cloud/zeebe/pull/5348#discussion_r489187029", "bodyText": "It seems that the event handlers are not required for the test. Can we remove them?", "author": "saig0", "createdAt": "2020-09-16T06:13:30Z", "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/StreamProcessorReprocessingTest.java", "diffHunk": "@@ -601,4 +601,130 @@ public void processRecord(\n     assertThat(processedPositions).doesNotContain(snapshotPosition);\n     assertThat(processedPositions).endsWith(lastSourceEvent, lastEvent);\n   }\n+\n+  @Test\n+  public void shouldUpdateLastProcessedPositionAfterReprocessing() throws Exception {\n+    // given\n+    final long firstPosition =\n+        streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(ELEMENT_ACTIVATED, 1, firstPosition);\n+\n+    waitUntil(\n+        () ->\n+            streamProcessorRule\n+                .events()\n+                .onlyWorkflowInstanceRecords()\n+                .withIntent(ELEMENT_ACTIVATED)\n+                .exists());\n+\n+    // when\n+    final CountDownLatch recoveredLatch = new CountDownLatch(1);\n+    final var streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors\n+                    .onEvent(\n+                        ValueType.WORKFLOW_INSTANCE,\n+                        ELEMENT_ACTIVATING,\n+                        new TypedRecordProcessor<>() {\n+                          @Override\n+                          public void processRecord(\n+                              final long position,\n+                              final TypedRecord<UnifiedRecordValue> record,\n+                              final TypedResponseWriter responseWriter,\n+                              final TypedStreamWriter streamWriter,\n+                              final Consumer<SideEffectProducer> sideEffect) {\n+                            streamWriter.appendFollowUpEvent(\n+                                record.getKey(),\n+                                WorkflowInstanceIntent.ELEMENT_ACTIVATED,\n+                                record.getValue());\n+                          }\n+                        })\n+                    .onEvent(\n+                        ValueType.WORKFLOW_INSTANCE,\n+                        ELEMENT_ACTIVATED,\n+                        new TypedRecordProcessor<UnifiedRecordValue>() {\n+                          @Override\n+                          public void processRecord(\n+                              final long position,\n+                              final TypedRecord<UnifiedRecordValue> record,\n+                              final TypedResponseWriter responseWriter,\n+                              final TypedStreamWriter streamWriter,\n+                              final Consumer<SideEffectProducer> sideEffect) {}\n+                        })", "originalCommit": "e8415ebfe5362292297b6a9404f31219d8d3e900", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE4ODUwMg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5348#discussion_r489188502", "bodyText": "It seems that the event handler is not required for the test. Can we remove it?", "author": "saig0", "createdAt": "2020-09-16T06:17:32Z", "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/StreamProcessorReprocessingTest.java", "diffHunk": "@@ -601,4 +601,130 @@ public void processRecord(\n     assertThat(processedPositions).doesNotContain(snapshotPosition);\n     assertThat(processedPositions).endsWith(lastSourceEvent, lastEvent);\n   }\n+\n+  @Test\n+  public void shouldUpdateLastProcessedPositionAfterReprocessing() throws Exception {\n+    // given\n+    final long firstPosition =\n+        streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(ELEMENT_ACTIVATED, 1, firstPosition);\n+\n+    waitUntil(\n+        () ->\n+            streamProcessorRule\n+                .events()\n+                .onlyWorkflowInstanceRecords()\n+                .withIntent(ELEMENT_ACTIVATED)\n+                .exists());\n+\n+    // when\n+    final CountDownLatch recoveredLatch = new CountDownLatch(1);\n+    final var streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors\n+                    .onEvent(\n+                        ValueType.WORKFLOW_INSTANCE,\n+                        ELEMENT_ACTIVATING,\n+                        new TypedRecordProcessor<>() {\n+                          @Override\n+                          public void processRecord(\n+                              final long position,\n+                              final TypedRecord<UnifiedRecordValue> record,\n+                              final TypedResponseWriter responseWriter,\n+                              final TypedStreamWriter streamWriter,\n+                              final Consumer<SideEffectProducer> sideEffect) {\n+                            streamWriter.appendFollowUpEvent(\n+                                record.getKey(),\n+                                WorkflowInstanceIntent.ELEMENT_ACTIVATED,\n+                                record.getValue());\n+                          }\n+                        })\n+                    .onEvent(\n+                        ValueType.WORKFLOW_INSTANCE,\n+                        ELEMENT_ACTIVATED,\n+                        new TypedRecordProcessor<UnifiedRecordValue>() {\n+                          @Override\n+                          public void processRecord(\n+                              final long position,\n+                              final TypedRecord<UnifiedRecordValue> record,\n+                              final TypedResponseWriter responseWriter,\n+                              final TypedStreamWriter streamWriter,\n+                              final Consumer<SideEffectProducer> sideEffect) {}\n+                        })\n+                    .withListener(\n+                        new StreamProcessorLifecycleAware() {\n+                          @Override\n+                          public void onRecovered(final ReadonlyProcessingContext context) {\n+                            recoveredLatch.countDown();\n+                          }\n+                        }));\n+\n+    // then\n+    recoveredLatch.await();\n+\n+    assertThat(streamProcessor.getLastProcessedPositionAsync().get()).isEqualTo(firstPosition);\n+  }\n+\n+  @Test\n+  public void shouldUpdateLastProcessedEventWhenSnapshot() throws Exception {\n+    // given\n+    final CountDownLatch onProcessedListenerLatch = new CountDownLatch(2);\n+    streamProcessorRule.startTypedStreamProcessor(\n+        (processors, context) ->\n+            processors.onEvent(\n+                ValueType.WORKFLOW_INSTANCE,\n+                ELEMENT_ACTIVATING,\n+                new TypedRecordProcessor<UnifiedRecordValue>() {\n+                  @Override\n+                  public void processRecord(\n+                      final long position,\n+                      final TypedRecord<UnifiedRecordValue> record,\n+                      final TypedResponseWriter responseWriter,\n+                      final TypedStreamWriter streamWriter,\n+                      final Consumer<SideEffectProducer> sideEffect) {}\n+                }),\n+        (t) -> onProcessedListenerLatch.countDown());\n+\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING);\n+    final var snapshotPosition =\n+        streamProcessorRule.writeWorkflowInstanceEvent(\n+            ELEMENT_ACTIVATING); // should be processed and included in the snapshot\n+    onProcessedListenerLatch.await();\n+    streamProcessorRule.snapshot();\n+    streamProcessorRule.closeStreamProcessor();\n+\n+    // when\n+    // The processor restarts with a snapshot that was the state of the processor before it\n+    // was closed.\n+    final var recoveredLatch = new CountDownLatch(1);\n+    final var streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors\n+                    .onEvent(\n+                        ValueType.WORKFLOW_INSTANCE,\n+                        ELEMENT_ACTIVATING,\n+                        new TypedRecordProcessor<UnifiedRecordValue>() {\n+                          @Override\n+                          public void processRecord(\n+                              final long position,\n+                              final TypedRecord<UnifiedRecordValue> record,\n+                              final TypedResponseWriter responseWriter,\n+                              final TypedStreamWriter streamWriter,\n+                              final Consumer<SideEffectProducer> sideEffect) {}\n+                        })", "originalCommit": "e8415ebfe5362292297b6a9404f31219d8d3e900", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE4ODk1Nw==", "url": "https://github.com/camunda-cloud/zeebe/pull/5348#discussion_r489188957", "bodyText": "These tests verify the fix but not the actual problem behind it. Can we write a test to verify that we can take a snapshot after reprocessing if no new record was processed?", "author": "saig0", "createdAt": "2020-09-16T06:18:42Z", "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/StreamProcessorReprocessingTest.java", "diffHunk": "@@ -601,4 +601,130 @@ public void processRecord(\n     assertThat(processedPositions).doesNotContain(snapshotPosition);\n     assertThat(processedPositions).endsWith(lastSourceEvent, lastEvent);\n   }\n+\n+  @Test\n+  public void shouldUpdateLastProcessedPositionAfterReprocessing() throws Exception {", "originalCommit": "e8415ebfe5362292297b6a9404f31219d8d3e900", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDExNzA3NA==", "url": "https://github.com/camunda-cloud/zeebe/pull/5348#discussion_r490117074", "bodyText": "As we discussed already we can't write a deterministic test because we cannot ensure that streamprocessor is paused after reprocessing.", "author": "deepthidevaki", "createdAt": "2020-09-17T09:51:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE4ODk1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIwNzEzNg==", "url": "https://github.com/camunda-cloud/zeebe/pull/5348#discussion_r489207136", "bodyText": "This part of the test is a bit hard to read. Please try to improve it. For example, by adding a new line :)", "author": "saig0", "createdAt": "2020-09-16T07:00:04Z", "path": "engine/src/test/java/io/zeebe/engine/processing/streamprocessor/StreamProcessorReprocessingTest.java", "diffHunk": "@@ -601,4 +601,130 @@ public void processRecord(\n     assertThat(processedPositions).doesNotContain(snapshotPosition);\n     assertThat(processedPositions).endsWith(lastSourceEvent, lastEvent);\n   }\n+\n+  @Test\n+  public void shouldUpdateLastProcessedPositionAfterReprocessing() throws Exception {\n+    // given\n+    final long firstPosition =\n+        streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING, 1);\n+    streamProcessorRule.writeWorkflowInstanceEventWithSource(ELEMENT_ACTIVATED, 1, firstPosition);\n+\n+    waitUntil(\n+        () ->\n+            streamProcessorRule\n+                .events()\n+                .onlyWorkflowInstanceRecords()\n+                .withIntent(ELEMENT_ACTIVATED)\n+                .exists());\n+\n+    // when\n+    final CountDownLatch recoveredLatch = new CountDownLatch(1);\n+    final var streamProcessor =\n+        streamProcessorRule.startTypedStreamProcessor(\n+            (processors, context) ->\n+                processors\n+                    .onEvent(\n+                        ValueType.WORKFLOW_INSTANCE,\n+                        ELEMENT_ACTIVATING,\n+                        new TypedRecordProcessor<>() {\n+                          @Override\n+                          public void processRecord(\n+                              final long position,\n+                              final TypedRecord<UnifiedRecordValue> record,\n+                              final TypedResponseWriter responseWriter,\n+                              final TypedStreamWriter streamWriter,\n+                              final Consumer<SideEffectProducer> sideEffect) {\n+                            streamWriter.appendFollowUpEvent(\n+                                record.getKey(),\n+                                WorkflowInstanceIntent.ELEMENT_ACTIVATED,\n+                                record.getValue());\n+                          }\n+                        })\n+                    .onEvent(\n+                        ValueType.WORKFLOW_INSTANCE,\n+                        ELEMENT_ACTIVATED,\n+                        new TypedRecordProcessor<UnifiedRecordValue>() {\n+                          @Override\n+                          public void processRecord(\n+                              final long position,\n+                              final TypedRecord<UnifiedRecordValue> record,\n+                              final TypedResponseWriter responseWriter,\n+                              final TypedStreamWriter streamWriter,\n+                              final Consumer<SideEffectProducer> sideEffect) {}\n+                        })\n+                    .withListener(\n+                        new StreamProcessorLifecycleAware() {\n+                          @Override\n+                          public void onRecovered(final ReadonlyProcessingContext context) {\n+                            recoveredLatch.countDown();\n+                          }\n+                        }));\n+\n+    // then\n+    recoveredLatch.await();\n+\n+    assertThat(streamProcessor.getLastProcessedPositionAsync().get()).isEqualTo(firstPosition);\n+  }\n+\n+  @Test\n+  public void shouldUpdateLastProcessedEventWhenSnapshot() throws Exception {\n+    // given\n+    final CountDownLatch onProcessedListenerLatch = new CountDownLatch(2);\n+    streamProcessorRule.startTypedStreamProcessor(\n+        (processors, context) ->\n+            processors.onEvent(\n+                ValueType.WORKFLOW_INSTANCE,\n+                ELEMENT_ACTIVATING,\n+                new TypedRecordProcessor<UnifiedRecordValue>() {\n+                  @Override\n+                  public void processRecord(\n+                      final long position,\n+                      final TypedRecord<UnifiedRecordValue> record,\n+                      final TypedResponseWriter responseWriter,\n+                      final TypedStreamWriter streamWriter,\n+                      final Consumer<SideEffectProducer> sideEffect) {}\n+                }),\n+        (t) -> onProcessedListenerLatch.countDown());\n+\n+    streamProcessorRule.writeWorkflowInstanceEvent(ELEMENT_ACTIVATING);\n+    final var snapshotPosition =\n+        streamProcessorRule.writeWorkflowInstanceEvent(\n+            ELEMENT_ACTIVATING); // should be processed and included in the snapshot\n+    onProcessedListenerLatch.await();\n+    streamProcessorRule.snapshot();\n+    streamProcessorRule.closeStreamProcessor();", "originalCommit": "e8415ebfe5362292297b6a9404f31219d8d3e900", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "24f774f46dc637bdeadb45b35372744a6eb760db", "url": "https://github.com/camunda-cloud/zeebe/commit/24f774f46dc637bdeadb45b35372744a6eb760db", "message": "chore(engine): update last processed position after reprocessing", "committedDate": "2020-09-17T11:24:53Z", "type": "commit"}, {"oid": "24f774f46dc637bdeadb45b35372744a6eb760db", "url": "https://github.com/camunda-cloud/zeebe/commit/24f774f46dc637bdeadb45b35372744a6eb760db", "message": "chore(engine): update last processed position after reprocessing", "committedDate": "2020-09-17T11:24:53Z", "type": "forcePushed"}]}