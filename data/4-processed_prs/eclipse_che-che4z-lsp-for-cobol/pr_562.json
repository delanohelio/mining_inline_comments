{"pr_number": 562, "pr_title": "refactor: refactor Databus copybook caching", "pr_createdAt": "2020-10-16T08:11:05Z", "pr_url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE2OTAzMw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r506169033", "bodyText": "Seems like this Javadoc belongs to the previous implementation of the interface", "author": "temanbrcom", "createdAt": "2020-10-16T08:29:53Z", "path": "server/src/main/java/com/broadcom/lsp/cobol/service/CopybookService.java", "diffHunk": "@@ -14,14 +14,32 @@\n  */\n package com.broadcom.lsp.cobol.service;\n \n+import com.broadcom.lsp.cobol.core.model.CopybookModel;\n import com.broadcom.lsp.cobol.domain.event.api.EventObserver;\n import com.broadcom.lsp.cobol.domain.event.model.DataEvent;\n \n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n /**\n  * Provide API definition to search for copybooks files and define the workspace folder opened in\n  * the client when the LSP server triggered.\n  */\n public interface CopybookService extends EventObserver<DataEvent> {\n   /** Remove all the stored copybook names and URIs. */", "originalCommit": "8db1519ff0ced6cb100ab0b7bd80e250c0631121", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjM1MzIzNQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r506353235", "bodyText": "You are right.", "author": "grianbrcom", "createdAt": "2020-10-16T12:14:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE2OTAzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE3Mjg4OQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r506172889", "bodyText": "Isn't it replaceable with an arrow notation?", "author": "temanbrcom", "createdAt": "2020-10-16T08:34:12Z", "path": "server/src/test/java/com/broadcom/lsp/cobol/service/delegates/validations/UseCaseUtils.java", "diffHunk": "@@ -198,12 +197,14 @@ public static AnalysisResult analyze(\n       String text,\n       List<CobolText> copybooks,\n       CopybookProcessingMode copybookProcessingMode) {\n-    Injector injector = Guice.createInjector(new EngineModule(), new DatabusModule());\n-\n-    DataBusBroker<FetchedCopybookEvent, RequiredCopybookEvent> broker =\n-        injector.getInstance(DataBusBroker.class);\n-\n-    MockCopybookService mockCopybookService = new MockCopybookServiceImpl(broker);\n+    Injector injector = Guice.createInjector(new EngineModule(), new DatabusModule(), new AbstractModule() {\n+      @Override\n+      protected void configure() {\n+        bind(CopybookService.class).to(MockCopybookServiceImpl.class);\n+      }", "originalCommit": "8db1519ff0ced6cb100ab0b7bd80e250c0631121", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjM1NDU1Mg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r506354552", "bodyText": "I would love to but looks like there is no way to do it.", "author": "grianbrcom", "createdAt": "2020-10-16T12:16:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE3Mjg4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE4OTA5Mg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r506189092", "bodyText": "Isn't it checked in the GrammarPreprocessorListenerImpl?", "author": "temanbrcom", "createdAt": "2020-10-16T08:56:30Z", "path": "server/src/main/java/com/broadcom/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -47,77 +47,110 @@\n   private final SettingsService settingsService;\n   private final FileSystemService files;\n \n-  private final Map<String, Path> copybookPaths = new ConcurrentHashMap<>(8, 0.9f, 1);\n   private final Map<String, Set<String>> copybooksForDownloading =\n       new ConcurrentHashMap<>(8, 0.9f, 1);\n \n+  private final Cache<String, CompletableFuture<CopybookModel>> copybookCache;\n+\n   @Inject\n   public CopybookServiceImpl(\n-      DataBusBroker dataBus, SettingsService settingsService, FileSystemService files) {\n+      DataBusBroker dataBus,\n+      SettingsService settingsService,\n+      FileSystemService files,\n+      @Named(\"CACHE-MAX-SIZE\") int cacheSize,\n+      @Named(\"CACHE-DURATION\") int duration,\n+      @Named(\"CACHE-TIME-UNIT\") String timeUnitName) {\n     this.dataBus = dataBus;\n     this.settingsService = settingsService;\n     this.files = files;\n-\n-    dataBus.subscribe(REQUIRED_COPYBOOK_EVENT, this);\n+    copybookCache = CacheBuilder.newBuilder()\n+        .expireAfterWrite(duration, TimeUnit.valueOf(timeUnitName))\n+        .maximumSize(cacheSize)\n+        .build();\n     dataBus.subscribe(ANALYSIS_FINISHED_EVENT, this);\n   }\n \n   @Override\n-  public void invalidateURICache() {\n-    copybookPaths.clear();\n+  public void invalidateCache() {\n     copybooksForDownloading.clear();\n+    copybookCache.invalidateAll();\n   }\n \n   /**\n-   * Depends on DataEvent type it will be handled with appropriate handler: {@link\n-   * #handleRequiredCopybookEvent} or {@link #handleAnalysisFinishedEvent}.\n+   * Retrieve and return the copybook by its name. Copybook may cached to limit interactions with\n+   * the file system.\n    *\n-   * @param event the instance of {@link RequiredCopybookEvent} or {@link AnalysisFinishedEvent}\n+   * Resolving works in synchronous way. Resolutions with different copybook names will not block each other.\n+   *\n+   * @param copybookName - the name of the copybook to be retrieved\n+   * @param documentUri - the currently processing document that contains the copy statement\n+   * @param copybookProcessingMode - text document synchronization type\n+   * @return a CopybookModel that contains copybook name, its URI and the content\n    */\n-  @Override\n-  public void observerCallback(DataEvent event) {\n-    if (event instanceof RequiredCopybookEvent) {\n-      handleRequiredCopybookEvent((RequiredCopybookEvent) event);\n-    } else if (event instanceof AnalysisFinishedEvent) {\n-      handleAnalysisFinishedEvent((AnalysisFinishedEvent) event);\n+  @Nullable\n+  public CopybookModel resolve(\n+      @Nonnull String copybookName,\n+      @Nonnull String documentUri,\n+      @Nonnull CopybookProcessingMode copybookProcessingMode) {\n+    if (!copybookProcessingMode.analyze) {", "originalCommit": "8db1519ff0ced6cb100ab0b7bd80e250c0631121", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjM1OTM0NA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r506359344", "bodyText": "Agree. Analyze flag has nothing to do with the resolve process.", "author": "grianbrcom", "createdAt": "2020-10-16T12:23:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE4OTA5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjI1MzM1NQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r506253355", "bodyText": "is it possible to return return new CopybookModel(copybookName, null, null); instead of null as like other places?\nOtherwise Optional object", "author": "asatklichov", "createdAt": "2020-10-16T10:07:48Z", "path": "server/src/main/java/com/broadcom/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -47,77 +47,110 @@\n   private final SettingsService settingsService;\n   private final FileSystemService files;\n \n-  private final Map<String, Path> copybookPaths = new ConcurrentHashMap<>(8, 0.9f, 1);\n   private final Map<String, Set<String>> copybooksForDownloading =\n       new ConcurrentHashMap<>(8, 0.9f, 1);\n \n+  private final Cache<String, CompletableFuture<CopybookModel>> copybookCache;\n+\n   @Inject\n   public CopybookServiceImpl(\n-      DataBusBroker dataBus, SettingsService settingsService, FileSystemService files) {\n+      DataBusBroker dataBus,\n+      SettingsService settingsService,\n+      FileSystemService files,\n+      @Named(\"CACHE-MAX-SIZE\") int cacheSize,\n+      @Named(\"CACHE-DURATION\") int duration,\n+      @Named(\"CACHE-TIME-UNIT\") String timeUnitName) {\n     this.dataBus = dataBus;\n     this.settingsService = settingsService;\n     this.files = files;\n-\n-    dataBus.subscribe(REQUIRED_COPYBOOK_EVENT, this);\n+    copybookCache = CacheBuilder.newBuilder()\n+        .expireAfterWrite(duration, TimeUnit.valueOf(timeUnitName))\n+        .maximumSize(cacheSize)\n+        .build();\n     dataBus.subscribe(ANALYSIS_FINISHED_EVENT, this);\n   }\n \n   @Override\n-  public void invalidateURICache() {\n-    copybookPaths.clear();\n+  public void invalidateCache() {\n     copybooksForDownloading.clear();\n+    copybookCache.invalidateAll();\n   }\n \n   /**\n-   * Depends on DataEvent type it will be handled with appropriate handler: {@link\n-   * #handleRequiredCopybookEvent} or {@link #handleAnalysisFinishedEvent}.\n+   * Retrieve and return the copybook by its name. Copybook may cached to limit interactions with\n+   * the file system.\n    *\n-   * @param event the instance of {@link RequiredCopybookEvent} or {@link AnalysisFinishedEvent}\n+   * Resolving works in synchronous way. Resolutions with different copybook names will not block each other.\n+   *\n+   * @param copybookName - the name of the copybook to be retrieved\n+   * @param documentUri - the currently processing document that contains the copy statement\n+   * @param copybookProcessingMode - text document synchronization type\n+   * @return a CopybookModel that contains copybook name, its URI and the content\n    */\n-  @Override\n-  public void observerCallback(DataEvent event) {\n-    if (event instanceof RequiredCopybookEvent) {\n-      handleRequiredCopybookEvent((RequiredCopybookEvent) event);\n-    } else if (event instanceof AnalysisFinishedEvent) {\n-      handleAnalysisFinishedEvent((AnalysisFinishedEvent) event);\n+  @Nullable\n+  public CopybookModel resolve(\n+      @Nonnull String copybookName,\n+      @Nonnull String documentUri,\n+      @Nonnull CopybookProcessingMode copybookProcessingMode) {\n+    if (!copybookProcessingMode.analyze) {\n+      return new CopybookModel(copybookName, null, null);\n+    }\n+    boolean firstRequest = false;\n+    CompletableFuture<CopybookModel> futureModel;\n+    synchronized (this) {\n+      futureModel = copybookCache.getIfPresent(copybookName);\n+      if (futureModel == null) {\n+        futureModel = new CompletableFuture<>();\n+        firstRequest = true;\n+        copybookCache.put(copybookName, futureModel);\n+      }\n+    }\n+    try {\n+      if (firstRequest) {\n+        CopybookModel copybookModel = resolveSync(copybookName, documentUri, copybookProcessingMode);\n+        futureModel.complete(copybookModel);\n+        return copybookModel;\n+      } else {\n+        return futureModel.get(30, TimeUnit.SECONDS);\n+      }\n+    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+      LOG.error(\"Can't resolve copybook '{}'.\", copybookName, e);\n+      return null;", "originalCommit": "8db1519ff0ced6cb100ab0b7bd80e250c0631121", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjI2MzkwNg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r506263906", "bodyText": "I agree, returning optional would be a good idea here", "author": "temanbrcom", "createdAt": "2020-10-16T10:22:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjI1MzM1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjM2NDgxOA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r506364818", "bodyText": "Yes, makes sense.", "author": "grianbrcom", "createdAt": "2020-10-16T12:30:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjI1MzM1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjI1NTY2Mw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r506255663", "bodyText": "Can we define a meaningful const for why we are waiting,  5000 is hardcoded multiple times as well. I know old code ;)", "author": "asatklichov", "createdAt": "2020-10-16T10:11:34Z", "path": "server/src/test/java/com/broadcom/lsp/cobol/domain/databus/impl/DataBusUnSubscribeTest.java", "diffHunk": "@@ -52,14 +50,12 @@ void subscribe() {\n         TimeoutException.class,\n         () -> {\n           // Subscribe\n-          Object subscriber = databus.subscribe(DataEventType.REQUIRED_COPYBOOK_EVENT, this);\n-          databus.postData(\n-              RequiredCopybookEvent.builder().name(\"CPYBUILD_SUBSCRIPTION TEST\").build());\n+          Object subscriber = databus.subscribe(DataEventType.RUN_ANALYSIS_EVENT, this);\n+          databus.postData(new RunAnalysisEvent());\n           waiter.await(5000);", "originalCommit": "8db1519ff0ced6cb100ab0b7bd80e250c0631121", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjM3MDU5MA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r506370590", "bodyText": "Why not? It is refactoring!", "author": "grianbrcom", "createdAt": "2020-10-16T12:38:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjI1NTY2Mw=="}], "type": "inlineReview"}, {"oid": "b89cf53ccc0e22ad82276d08ebb02c14ff60d48a", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/b89cf53ccc0e22ad82276d08ebb02c14ff60d48a", "message": "refactor: refactor Databus copybook caching\n\nextract copybook caching from databus to the separate service.\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>", "committedDate": "2020-10-16T12:55:50Z", "type": "forcePushed"}, {"oid": "627377db960b7e555c7861207d73b69f5aa8bfb5", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/627377db960b7e555c7861207d73b69f5aa8bfb5", "message": "refactor: refactor Databus copybook caching\n\nextract copybook caching from databus to the separate service.\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>", "committedDate": "2020-10-16T13:49:16Z", "type": "commit"}, {"oid": "627377db960b7e555c7861207d73b69f5aa8bfb5", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/627377db960b7e555c7861207d73b69f5aa8bfb5", "message": "refactor: refactor Databus copybook caching\n\nextract copybook caching from databus to the separate service.\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>", "committedDate": "2020-10-16T13:49:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU4MzM4Ng==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r507583386", "bodyText": "Seems like now EventObserver is not a necessary part of CopybookService anymore. I think you may implement this interface directly in the CopybookServiceImpl", "author": "temanbrcom", "createdAt": "2020-10-19T08:57:40Z", "path": "server/src/main/java/com/broadcom/lsp/cobol/service/CopybookService.java", "diffHunk": "@@ -14,14 +14,38 @@\n  */\n package com.broadcom.lsp.cobol.service;\n \n+import com.broadcom.lsp.cobol.core.model.CopybookModel;\n import com.broadcom.lsp.cobol.domain.event.api.EventObserver;\n import com.broadcom.lsp.cobol.domain.event.model.DataEvent;\n \n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n /**\n- * Provide API definition to search for copybooks files and define the workspace folder opened in\n- * the client when the LSP server triggered.\n+ * Provide API definition to search for copybooks files.\n+ * The service also caches copybook to reduce filesystem load.\n  */\n public interface CopybookService extends EventObserver<DataEvent> {", "originalCommit": "627377db960b7e555c7861207d73b69f5aa8bfb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY0MTk0MQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r507641941", "bodyText": "Sorry, not. We still need an observer because CopybookService waits for AnalysisFinishedEvent for sending downloading request to middleware.\nI leave EventObserver<DataEvent> as is because in Databus refactoring I plan to get rid of EventObserver.", "author": "grianbrcom", "createdAt": "2020-10-19T10:32:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU4MzM4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY0NjI0Nw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r507646247", "bodyText": "Ok, makes sense", "author": "temanbrcom", "createdAt": "2020-10-19T10:40:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU4MzM4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU4ODkxNg==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r507588916", "bodyText": "Seems like it may be collapsed", "author": "temanbrcom", "createdAt": "2020-10-19T09:06:14Z", "path": "server/src/main/java/com/broadcom/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -47,77 +51,95 @@\n   private final SettingsService settingsService;\n   private final FileSystemService files;\n \n-  private final Map<String, Path> copybookPaths = new ConcurrentHashMap<>(8, 0.9f, 1);\n   private final Map<String, Set<String>> copybooksForDownloading =\n       new ConcurrentHashMap<>(8, 0.9f, 1);\n \n+  private final Cache<String, CopybookModel> copybookCache;\n+\n   @Inject\n   public CopybookServiceImpl(\n-      DataBusBroker dataBus, SettingsService settingsService, FileSystemService files) {\n+      DataBusBroker dataBus,\n+      SettingsService settingsService,\n+      FileSystemService files,\n+      @Named(\"CACHE-MAX-SIZE\") int cacheSize,\n+      @Named(\"CACHE-DURATION\") int duration,\n+      @Named(\"CACHE-TIME-UNIT\") String timeUnitName) {\n     this.dataBus = dataBus;\n     this.settingsService = settingsService;\n     this.files = files;\n-\n-    dataBus.subscribe(REQUIRED_COPYBOOK_EVENT, this);\n+    copybookCache = CacheBuilder.newBuilder()\n+        .expireAfterWrite(duration, TimeUnit.valueOf(timeUnitName))\n+        .maximumSize(cacheSize)\n+        .build();\n     dataBus.subscribe(ANALYSIS_FINISHED_EVENT, this);\n   }\n \n   @Override\n-  public void invalidateURICache() {\n-    copybookPaths.clear();\n+  public void invalidateCache() {\n     copybooksForDownloading.clear();\n+    copybookCache.invalidateAll();\n   }\n \n   /**\n-   * Depends on DataEvent type it will be handled with appropriate handler: {@link\n-   * #handleRequiredCopybookEvent} or {@link #handleAnalysisFinishedEvent}.\n+   * Retrieve and return the copybook by its name. Copybook may cached to limit interactions with\n+   * the file system.\n+   *\n+   * Resolving works in synchronous way. Resolutions with different copybook names will not block each other.\n    *\n-   * @param event the instance of {@link RequiredCopybookEvent} or {@link AnalysisFinishedEvent}\n+   * @param copybookName - the name of the copybook to be retrieved\n+   * @param documentUri - the currently processing document that contains the copy statement\n+   * @param copybookProcessingMode - text document synchronization type\n+   * @return a CopybookModel that contains copybook name, its URI and the content\n    */\n+  public CopybookModel resolve(\n+      @Nonnull String copybookName,\n+      @Nonnull String documentUri,\n+      @Nonnull CopybookProcessingMode copybookProcessingMode) {\n+    try {\n+      return copybookCache.get(copybookName, () -> resolveSync(copybookName, documentUri, copybookProcessingMode));\n+    } catch (ExecutionException e) {\n+      LOG.error(\"Can't resolve copybook '{}'.\", copybookName, e);\n+      return new CopybookModel(copybookName, null, null);\n+    }\n+  }\n+\n   @Override\n-  public void observerCallback(DataEvent event) {\n-    if (event instanceof RequiredCopybookEvent) {\n-      handleRequiredCopybookEvent((RequiredCopybookEvent) event);\n-    } else if (event instanceof AnalysisFinishedEvent) {\n-      handleAnalysisFinishedEvent((AnalysisFinishedEvent) event);\n+  public void store(CopybookModel copybookModel) {\n+    copybookCache.put(copybookModel.getName(), copybookModel);\n+  }\n+\n+  private CopybookModel resolveSync(\n+      @Nonnull String copybookName,\n+      @Nonnull String documentUri,\n+      @Nonnull CopybookProcessingMode copybookProcessingMode) throws ExecutionException, InterruptedException {\n+    String cobolFileName = files.getNameFromURI(documentUri);\n+    String uri = retrieveURI(\n+        settingsService.getConfiguration(COPYBOOK_RESOLVE.label, cobolFileName, copybookName).get());\n+    if (uri.isEmpty()) {\n+      if (copybookProcessingMode.download) {", "originalCommit": "627377db960b7e555c7861207d73b69f5aa8bfb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY0NDgwNw==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r507644807", "bodyText": "I can't collapse it. Here I need to manage three cases:\nURI is present => read copybook from filesystem\nURI is empty and we downloading (DidOpen case) => add copybook for downloading, return stub.\nURI is empty and we don't download (DidChange case) => just return stub.", "author": "grianbrcom", "createdAt": "2020-10-19T10:37:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU4ODkxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY0ODk5Ng==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r507648996", "bodyText": "Yeah, you are right", "author": "temanbrcom", "createdAt": "2020-10-19T10:45:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU4ODkxNg=="}], "type": "inlineReview"}]}