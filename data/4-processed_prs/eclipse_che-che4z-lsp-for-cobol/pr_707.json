{"pr_number": 707, "pr_title": "Fix semantic analysis stop after XML query", "pr_createdAt": "2020-12-18T12:42:35Z", "pr_url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/707", "timeline": [{"oid": "d26b8481111bb3ade6eb40f89e8282383583aea3", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/d26b8481111bb3ade6eb40f89e8282383583aea3", "message": "fix: Fix semantic analysis stop after XML query\n\nFix #706\nChange the grammar to process the string literals the same way on the\npreprocessor and parser. Add a new rule that accepts incorrect\nidentifiers on the main lexer to make the mapping find all the required\ntokens.\nIt fixed the semantic analysis by allowing the CobolVisitor to find the\nrequired position after the mapping. Possibly fixes NPE and exceptions\non mapping that could not be reproduced.", "committedDate": "2020-12-18T12:38:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgwOTk4MA==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/707#discussion_r545809980", "bodyText": "Is this intended?", "author": "ap891843", "createdAt": "2020-12-18T12:48:43Z", "path": "server/src/main/antlr4/com/broadcom/lsp/cobol/core/parser/CICSLexer.g4", "diffHunk": "@@ -837,6 +837,7 @@ NUMERICLITERAL : (PLUSCHAR | MINUSCHAR)? DIGIT* (DOT | COMMACHAR) DIGIT+ (('e' |\n NONNUMERICLITERAL : UNTRMSTRINGLITERAL | STRINGLITERAL | DBCSLITERAL | HEXNUMBER | NULLTERMINATED;\n \n IDENTIFIER : ([a-zA-Z0-9]+ ([-_]+ [a-zA-Z0-9]+)*);\n+INVALID_IDENTIFIER : [a-zA-Z0-9#@$]+ ([-_]+ [a-zA-Z0-9#@$]+)*;", "originalCommit": "d26b8481111bb3ade6eb40f89e8282383583aea3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgxNTcwOQ==", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/707#discussion_r545815709", "bodyText": "Yes, it is to catch the identifiers that contain #@$ and there missed by the preprocessor.\nThe logic here is this: copybook names may contain #@$ as a part of a valid name when identifiers may not. With the previous implementation, e.g. variable name VARNAME$ was treated as a possible copybook name by the preprocessor, and as VARNAME and $ (two different tokens) by the main lexer. In this case, the mapper could not map the token one to one and the mapping might miss some tokens.\nWith this change, all the identifiers, even incorrect, will be mapped correctly.", "author": "temanbrcom", "createdAt": "2020-12-18T13:00:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgwOTk4MA=="}], "type": "inlineReview"}]}