{"pr_number": 1723, "pr_title": "[cache] Added 'ByteArrayFileCache'", "pr_createdAt": "2020-10-16T19:32:28Z", "pr_url": "https://github.com/openhab/openhab-core/pull/1723", "timeline": [{"oid": "232eb0b07afb9f867f3b9adc6ebee3a9d2437328", "url": "https://github.com/openhab/openhab-core/commit/232eb0b07afb9f867f3b9adc6ebee3a9d2437328", "message": "Added ByteArrayFileCache\n\nSigned-off-by: Christoph Weitkamp <github@christophweitkamp.de>", "committedDate": "2020-10-16T19:30:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc4OTQ0OQ==", "url": "https://github.com/openhab/openhab-core/pull/1723#discussion_r506789449", "bodyText": "Why not use File.separator instead?", "author": "cpmeister", "createdAt": "2020-10-17T03:47:11Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/cache/ByteArrayFileCache.java", "diffHunk": "@@ -0,0 +1,305 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.cache;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a simple file based cache implementation.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ByteArrayFileCache {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ByteArrayFileCache.class);\n+\n+    private static final String MD5_ALGORITHM = \"MD5\";\n+\n+    static final String CACHE_FOLDER_NAME = \"cache\";\n+    private static final char EXTENSION_SEPARATOR = '.';\n+    private static final char UNIX_SEPARATOR = '/';\n+    private static final char WINDOWS_SEPARATOR = '\\\\';", "originalCommit": "232eb0b07afb9f867f3b9adc6ebee3a9d2437328", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MDQwOA==", "url": "https://github.com/openhab/openhab-core/pull/1723#discussion_r506790408", "bodyText": "I think the MD5 algorithm is a bit overkill here. Why not just use key.hashCode() instead? It is a lot faster and 4 billion different values should be unique enough right?", "author": "cpmeister", "createdAt": "2020-10-17T04:01:05Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/cache/ByteArrayFileCache.java", "diffHunk": "@@ -0,0 +1,305 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.cache;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a simple file based cache implementation.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ByteArrayFileCache {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ByteArrayFileCache.class);\n+\n+    private static final String MD5_ALGORITHM = \"MD5\";\n+\n+    static final String CACHE_FOLDER_NAME = \"cache\";\n+    private static final char EXTENSION_SEPARATOR = '.';\n+    private static final char UNIX_SEPARATOR = '/';\n+    private static final char WINDOWS_SEPARATOR = '\\\\';\n+\n+    private final File cacheFolder;\n+\n+    static final long ONE_DAY_IN_MILLIS = TimeUnit.DAYS.toMillis(1);\n+    private int expiry = 0;\n+\n+    private static final Map<String, File> FILES_IN_CACHE = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$OPENHAB_USERDATA/cache/$servicePID</code>.\n+     *\n+     * @param servicePID PID of the service\n+     */\n+    public ByteArrayFileCache(String servicePID) {\n+        // TODO track and limit folder size\n+        // TODO support user specific folder\n+        cacheFolder = new File(new File(OpenHAB.getUserDataFolder(), CACHE_FOLDER_NAME), servicePID);\n+        if (!cacheFolder.exists()) {\n+            logger.debug(\"Creating cache folder '{}'\", cacheFolder.getAbsolutePath());\n+            cacheFolder.mkdirs();\n+        }\n+        logger.debug(\"Using cache folder '{}'\", cacheFolder.getAbsolutePath());\n+    }\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$OPENHAB_USERDATA/cache/$servicePID/</code>.\n+     *\n+     * @param servicePID PID of the service\n+     * @param int the days for how long the files stay in the cache valid. Must be positive. 0 to\n+     *            disables this functionality.\n+     */\n+    public ByteArrayFileCache(String servicePID, int expiry) {\n+        this(servicePID);\n+        if (expiry < 0) {\n+            throw new IllegalArgumentException(\"Cache expiration time must be greater than or equal to 0\");\n+        }\n+        this.expiry = expiry;\n+    }\n+\n+    /**\n+     * Adds a file to the cache. If the cache previously contained a file for the key, the old file is replaced by the\n+     * new content.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     */\n+    public void put(String key, byte[] content) {\n+        writeFile(getUniqueFile(key), content);\n+    }\n+\n+    /**\n+     * Adds a file to the cache.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     */\n+    public void putIfAbsent(String key, byte[] content) {\n+        File fileInCache = getUniqueFile(key);\n+        if (fileInCache.exists()) {\n+            logger.debug(\"File '{}' present in cache\", fileInCache.getName());\n+            // update time of last use\n+            fileInCache.setLastModified(System.currentTimeMillis());\n+        } else {\n+            writeFile(fileInCache, content);\n+        }\n+    }\n+\n+    /**\n+     * Adds a file to the cache and returns the content of the file.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     * @return the content of the file associated with the given key\n+     */\n+    public byte[] putIfAbsentAndGet(String key, byte[] content) {\n+        putIfAbsent(key, content);\n+\n+        return content;\n+    }\n+\n+    /**\n+     * Writes the given content to the given {@link File}.\n+     *\n+     * @param fileInCache the {@link File}\n+     * @param content the content to be written\n+     */\n+    private void writeFile(File fileInCache, byte[] content) {\n+        logger.debug(\"Caching file '{}'\", fileInCache.getName());\n+        try {\n+            Files.write(fileInCache.toPath(), content);\n+        } catch (IOException e) {\n+            logger.warn(\"Could not write file '{}'\u00a0to cache\", fileInCache.getName(), e);\n+        }\n+    }\n+\n+    /**\n+     * Checks if the key is present in the cache.\n+     *\n+     * @param key the key whose presence in the cache is to be tested\n+     * @return true if the cache contains a file for the specified key\n+     */\n+    public boolean containsKey(String key) {\n+        return getUniqueFile(key).exists();\n+    }\n+\n+    /**\n+     * Removes the file associated with the given key from the cache.\n+     *\n+     * @param key the key whose associated file is to be removed\n+     */\n+    public void remove(String key) {\n+        deleteFile(getUniqueFile(key));\n+    }\n+\n+    /**\n+     * Deletes the given {@link File}.\n+     *\n+     * @param fileInCache the {@link File}\n+     */\n+    private void deleteFile(File fileInCache) {\n+        if (fileInCache.exists()) {\n+            logger.debug(\"Deleting file '{}' from cache\", fileInCache.getName());\n+            fileInCache.delete();\n+        } else {\n+            logger.debug(\"File '{}' not found in cache\", fileInCache.getName());\n+        }\n+    }\n+\n+    /**\n+     * Removes all files from the cache.\n+     */\n+    public void clear() {\n+        File[] filesInCache = cacheFolder.listFiles();\n+        if (filesInCache != null && filesInCache.length > 0) {\n+            logger.debug(\"Deleting all files from cache\");\n+            Arrays.stream(filesInCache).forEach(File::delete);\n+        }\n+    }\n+\n+    /**\n+     * Removes expired files from the cache.\n+     */\n+    public void clearExpired() {\n+        // exit if expiry is set to 0 (disabled)\n+        if (expiry <= 0) {\n+            return;\n+        }\n+        File[] filesInCache = cacheFolder.listFiles();\n+        if (filesInCache != null && filesInCache.length > 0) {\n+            logger.debug(\"Deleting expired files from cache\");\n+            Arrays.stream(filesInCache).filter(file -> isExpired(file)).forEach(File::delete);\n+        }\n+    }\n+\n+    /**\n+     * Checks if the given {@link File} is expired.\n+     *\n+     * @param fileInCache the {@link File}\n+     * @return <code>true</code> if the file is expired, <code>false</code> otherwise\n+     */\n+    private boolean isExpired(File fileInCache) {\n+        // exit if expiry is set to 0 (disabled)\n+        if (expiry <= 0) {\n+            return false;\n+        }\n+        return expiry * ONE_DAY_IN_MILLIS < System.currentTimeMillis() - fileInCache.lastModified();\n+    }\n+\n+    /**\n+     * Returns the content of the file associated with the given key, if it is present.\n+     *\n+     * @param key the key whose associated file is to be returned\n+     * @return the content of the file associated with the given key\n+     * @throws FileNotFoundException if the given file could not be found in cache\n+     * @throws IOException if an I/O error occurs reading the given file\n+     */\n+    public byte[] get(String key) throws FileNotFoundException, IOException {\n+        return readFile(getUniqueFile(key));\n+    }\n+\n+    /**\n+     * Reads the content from the given {@link File}, if it is present.\n+     *\n+     * @param fileInCache the {@link File}\n+     * @return the content of the file\n+     * @throws FileNotFoundException if the given file could not be found in cache\n+     * @throws IOException if an I/O error occurs reading the given file\n+     */\n+    private byte[] readFile(File fileInCache) throws FileNotFoundException, IOException {\n+        if (fileInCache.exists()) {\n+            logger.debug(\"Reading file '{}' from cache\", fileInCache.getName());\n+            // update time of last use\n+            fileInCache.setLastModified(System.currentTimeMillis());\n+            try {\n+                return Files.readAllBytes(fileInCache.toPath());\n+            } catch (IOException e) {\n+                logger.warn(\"Could not read file '{}'\u00a0from cache\", fileInCache.getName(), e);\n+                throw new IOException(String.format(\"Could not read file '%s'\u00a0from cache\", fileInCache.getName()));\n+            }\n+        } else {\n+            logger.debug(\"File '{}' not found in cache\", fileInCache.getName());\n+            throw new FileNotFoundException(String.format(\"File '%s' not found in cache\", fileInCache.getName()));\n+        }\n+    }\n+\n+    /**\n+     * Creates a unique {@link File} from the key with which the file is to be associated.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @return unique file for the file associated with the given key\n+     */\n+    File getUniqueFile(String key) {\n+        String uniqueFileName = getUniqueFileName(key);\n+        if (FILES_IN_CACHE.containsKey(uniqueFileName)) {\n+            return FILES_IN_CACHE.get(uniqueFileName);\n+        } else {\n+            String fileExtension = getFileExtension(key);\n+            File fileInCache = new File(cacheFolder,\n+                    uniqueFileName + (fileExtension == null ? \"\" : EXTENSION_SEPARATOR + fileExtension));\n+            FILES_IN_CACHE.put(uniqueFileName, fileInCache);\n+            return fileInCache;\n+        }\n+    }\n+\n+    /**\n+     * Gets the extension of a file name.\n+     *\n+     * @param fileName the file name to retrieve the extension of\n+     * @return the extension of the file or null if none exists\n+     */\n+    @Nullable\n+    String getFileExtension(String fileName) {\n+        int extensionPos = fileName.lastIndexOf(EXTENSION_SEPARATOR);\n+        int lastSeparatorPos = Math.max(fileName.lastIndexOf(UNIX_SEPARATOR), fileName.lastIndexOf(WINDOWS_SEPARATOR));\n+        return lastSeparatorPos > extensionPos ? null : fileName.substring(extensionPos + 1).replaceFirst(\"\\\\?.*$\", \"\");\n+    }\n+\n+    /**\n+     * Creates a unique file name from the key with which the file is to be associated.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @return unique file name for the file associated with the given key\n+     */\n+    String getUniqueFileName(String key) {\n+        try {\n+            final MessageDigest md = MessageDigest.getInstance(MD5_ALGORITHM);\n+            return String.format(\"%032x\", new BigInteger(1, md.digest(key.getBytes(StandardCharsets.UTF_8))));", "originalCommit": "232eb0b07afb9f867f3b9adc6ebee3a9d2437328", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "357a5c5c12483e529a8eb98991a4adecb3841dff", "url": "https://github.com/openhab/openhab-core/commit/357a5c5c12483e529a8eb98991a4adecb3841dff", "message": "Incorporated review comments\n\nSigned-off-by: Christoph Weitkamp <github@christophweitkamp.de>", "committedDate": "2020-10-18T10:26:31Z", "type": "commit"}, {"oid": "202cefaf6c783fb3af08a698ceb018847567fb19", "url": "https://github.com/openhab/openhab-core/commit/202cefaf6c783fb3af08a698ceb018847567fb19", "message": "Removed file\n\nSigned-off-by: Christoph Weitkamp <github@christophweitkamp.de>", "committedDate": "2020-10-18T14:35:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE4MTUxMw==", "url": "https://github.com/openhab/openhab-core/pull/1723#discussion_r507181513", "bodyText": "Could this be final if we rearrange the contructors and do all the work in the one with String and Duration?", "author": "jochen314", "createdAt": "2020-10-18T16:11:49Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/cache/ByteArrayFileCache.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.cache;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.file.Files;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a simple file based cache implementation.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ByteArrayFileCache {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ByteArrayFileCache.class);\n+\n+    static final String CACHE_FOLDER_NAME = \"cache\";\n+    private static final char EXTENSION_SEPARATOR = '.';\n+\n+    private final File cacheFolder;\n+\n+    static final long ONE_DAY_IN_MILLIS = TimeUnit.DAYS.toMillis(1);\n+    private long expiry;", "originalCommit": "202cefaf6c783fb3af08a698ceb018847567fb19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE4MTY4Nw==", "url": "https://github.com/openhab/openhab-core/pull/1723#discussion_r507181687", "bodyText": "If we do a expiry.toMillis(), then we do not need to do the multiplication each time we check the expiry of a file.\nAnd duration could be anything, not just days.", "author": "jochen314", "createdAt": "2020-10-18T16:13:54Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/cache/ByteArrayFileCache.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.cache;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.file.Files;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a simple file based cache implementation.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ByteArrayFileCache {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ByteArrayFileCache.class);\n+\n+    static final String CACHE_FOLDER_NAME = \"cache\";\n+    private static final char EXTENSION_SEPARATOR = '.';\n+\n+    private final File cacheFolder;\n+\n+    static final long ONE_DAY_IN_MILLIS = TimeUnit.DAYS.toMillis(1);\n+    private long expiry;\n+\n+    private static final Map<String, File> FILES_IN_CACHE = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$OPENHAB_USERDATA/cache/$servicePID</code>.\n+     *\n+     * @param servicePID PID of the service\n+     */\n+    public ByteArrayFileCache(String servicePID) {\n+        // TODO track and limit folder size\n+        // TODO support user specific folder\n+        cacheFolder = new File(new File(OpenHAB.getUserDataFolder(), CACHE_FOLDER_NAME), servicePID);\n+        if (!cacheFolder.exists()) {\n+            logger.debug(\"Creating cache folder '{}'\", cacheFolder.getAbsolutePath());\n+            cacheFolder.mkdirs();\n+        }\n+        logger.debug(\"Using cache folder '{}'\", cacheFolder.getAbsolutePath());\n+    }\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$OPENHAB_USERDATA/cache/$servicePID/</code>.\n+     *\n+     * @param servicePID PID of the service\n+     * @param long the days for how long the files stay in the cache valid. Must be positive. 0 to\n+     *            disable this functionality.\n+     */\n+    public ByteArrayFileCache(String servicePID, long expiry) {\n+        this(servicePID, Duration.ofDays(expiry));\n+    }\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$OPENHAB_USERDATA/cache/$servicePID/</code>.\n+     *\n+     * @param servicePID PID of the service\n+     * @param Duration the days for how long the files stay in the cache valid. Must be positive. 0 to\n+     *            disable this functionality.\n+     */\n+    public ByteArrayFileCache(String servicePID, Duration expiry) {\n+        this(servicePID);\n+        if (expiry.isNegative()) {\n+            throw new IllegalArgumentException(\"Cache expiration time must be greater than or equal to 0\");\n+        }\n+        this.expiry = expiry.toDays();", "originalCommit": "202cefaf6c783fb3af08a698ceb018847567fb19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE4MjA1Nw==", "url": "https://github.com/openhab/openhab-core/pull/1723#discussion_r507182057", "bodyText": "...filter(this::isExpired).....", "author": "jochen314", "createdAt": "2020-10-18T16:17:21Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/cache/ByteArrayFileCache.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.cache;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.file.Files;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a simple file based cache implementation.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ByteArrayFileCache {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ByteArrayFileCache.class);\n+\n+    static final String CACHE_FOLDER_NAME = \"cache\";\n+    private static final char EXTENSION_SEPARATOR = '.';\n+\n+    private final File cacheFolder;\n+\n+    static final long ONE_DAY_IN_MILLIS = TimeUnit.DAYS.toMillis(1);\n+    private long expiry;\n+\n+    private static final Map<String, File> FILES_IN_CACHE = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$OPENHAB_USERDATA/cache/$servicePID</code>.\n+     *\n+     * @param servicePID PID of the service\n+     */\n+    public ByteArrayFileCache(String servicePID) {\n+        // TODO track and limit folder size\n+        // TODO support user specific folder\n+        cacheFolder = new File(new File(OpenHAB.getUserDataFolder(), CACHE_FOLDER_NAME), servicePID);\n+        if (!cacheFolder.exists()) {\n+            logger.debug(\"Creating cache folder '{}'\", cacheFolder.getAbsolutePath());\n+            cacheFolder.mkdirs();\n+        }\n+        logger.debug(\"Using cache folder '{}'\", cacheFolder.getAbsolutePath());\n+    }\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$OPENHAB_USERDATA/cache/$servicePID/</code>.\n+     *\n+     * @param servicePID PID of the service\n+     * @param long the days for how long the files stay in the cache valid. Must be positive. 0 to\n+     *            disable this functionality.\n+     */\n+    public ByteArrayFileCache(String servicePID, long expiry) {\n+        this(servicePID, Duration.ofDays(expiry));\n+    }\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$OPENHAB_USERDATA/cache/$servicePID/</code>.\n+     *\n+     * @param servicePID PID of the service\n+     * @param Duration the days for how long the files stay in the cache valid. Must be positive. 0 to\n+     *            disable this functionality.\n+     */\n+    public ByteArrayFileCache(String servicePID, Duration expiry) {\n+        this(servicePID);\n+        if (expiry.isNegative()) {\n+            throw new IllegalArgumentException(\"Cache expiration time must be greater than or equal to 0\");\n+        }\n+        this.expiry = expiry.toDays();\n+    }\n+\n+    /**\n+     * Adds a file to the cache. If the cache previously contained a file for the key, the old file is replaced by the\n+     * new content.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     */\n+    public void put(String key, byte[] content) {\n+        writeFile(getUniqueFile(key), content);\n+    }\n+\n+    /**\n+     * Adds a file to the cache.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     */\n+    public void putIfAbsent(String key, byte[] content) {\n+        File fileInCache = getUniqueFile(key);\n+        if (fileInCache.exists()) {\n+            logger.debug(\"File '{}' present in cache\", fileInCache.getName());\n+            // update time of last use\n+            fileInCache.setLastModified(System.currentTimeMillis());\n+        } else {\n+            writeFile(fileInCache, content);\n+        }\n+    }\n+\n+    /**\n+     * Adds a file to the cache and returns the content of the file.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     * @return the content of the file associated with the given key\n+     */\n+    public byte[] putIfAbsentAndGet(String key, byte[] content) {\n+        putIfAbsent(key, content);\n+\n+        return content;\n+    }\n+\n+    /**\n+     * Writes the given content to the given {@link File}.\n+     *\n+     * @param fileInCache the {@link File}\n+     * @param content the content to be written\n+     */\n+    private void writeFile(File fileInCache, byte[] content) {\n+        logger.debug(\"Caching file '{}'\", fileInCache.getName());\n+        try {\n+            Files.write(fileInCache.toPath(), content);\n+        } catch (IOException e) {\n+            logger.warn(\"Could not write file '{}'\u00a0to cache\", fileInCache.getName(), e);\n+        }\n+    }\n+\n+    /**\n+     * Checks if the key is present in the cache.\n+     *\n+     * @param key the key whose presence in the cache is to be tested\n+     * @return true if the cache contains a file for the specified key\n+     */\n+    public boolean containsKey(String key) {\n+        return getUniqueFile(key).exists();\n+    }\n+\n+    /**\n+     * Removes the file associated with the given key from the cache.\n+     *\n+     * @param key the key whose associated file is to be removed\n+     */\n+    public void remove(String key) {\n+        deleteFile(getUniqueFile(key));\n+    }\n+\n+    /**\n+     * Deletes the given {@link File}.\n+     *\n+     * @param fileInCache the {@link File}\n+     */\n+    private void deleteFile(File fileInCache) {\n+        if (fileInCache.exists()) {\n+            logger.debug(\"Deleting file '{}' from cache\", fileInCache.getName());\n+            fileInCache.delete();\n+        } else {\n+            logger.debug(\"File '{}' not found in cache\", fileInCache.getName());\n+        }\n+    }\n+\n+    /**\n+     * Removes all files from the cache.\n+     */\n+    public void clear() {\n+        File[] filesInCache = cacheFolder.listFiles();\n+        if (filesInCache != null && filesInCache.length > 0) {\n+            logger.debug(\"Deleting all files from cache\");\n+            Arrays.stream(filesInCache).forEach(File::delete);\n+        }\n+    }\n+\n+    /**\n+     * Removes expired files from the cache.\n+     */\n+    public void clearExpired() {\n+        // exit if expiry is set to 0 (disabled)\n+        if (expiry <= 0) {\n+            return;\n+        }\n+        File[] filesInCache = cacheFolder.listFiles();\n+        if (filesInCache != null && filesInCache.length > 0) {\n+            logger.debug(\"Deleting expired files from cache\");\n+            Arrays.stream(filesInCache).filter(file -> isExpired(file)).forEach(File::delete);", "originalCommit": "202cefaf6c783fb3af08a698ceb018847567fb19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE4MzIzOA==", "url": "https://github.com/openhab/openhab-core/pull/1723#discussion_r507183238", "bodyText": "Is this testing, what is implemented? None of the tests go into the branch to remove the ? at the end of the extension.\nWhat about:\n\nhttps://www.youtube.com/watch?v=Test.With.Dots\nhttps://host/test.xlsx?cache=false", "author": "jochen314", "createdAt": "2020-10-18T16:28:21Z", "path": "bundles/org.openhab.core/src/test/java/org/openhab/core/cache/ByteArrayFileCacheTest.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.cache;\n+\n+import static org.hamcrest.CoreMatchers.*;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.openhab.core.OpenHAB;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Test class for the {@link ByteArrayFileCache} class.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ByteArrayFileCacheTest {\n+\n+    private static final String SERVICE_PID = \"org.openhab.core.test\";\n+\n+    private static final File USERDATA_FOLDER = new File(OpenHAB.getUserDataFolder());\n+    private static final File CACHE_FOLDER = new File(USERDATA_FOLDER, ByteArrayFileCache.CACHE_FOLDER_NAME);\n+    private static final File SERVICE_CACHE_FOLDER = new File(CACHE_FOLDER, SERVICE_PID);\n+\n+    private static final String MP3_FILE_NAME = SERVICE_CACHE_FOLDER.getAbsolutePath() + \"doorbell.mp3\";\n+    private static final String TXT_FILE_NAME = SERVICE_CACHE_FOLDER.getAbsolutePath() + \"doorbell.txt\";\n+\n+    private static @Nullable File txt_file;\n+\n+    private final Logger logger = LoggerFactory.getLogger(ByteArrayFileCacheTest.class);\n+\n+    private @NonNullByDefault({}) ByteArrayFileCache subject;\n+\n+    @BeforeAll\n+    public static void init() throws IOException {\n+        // create temporary file\n+        txt_file = createTempFile();\n+    }\n+\n+    @BeforeEach\n+    public void setUp() {\n+        subject = new ByteArrayFileCache(SERVICE_PID);\n+    }\n+\n+    @AfterEach\n+    public void tearDown() {\n+        // delete all files\n+        subject.clear();\n+    }\n+\n+    @AfterAll\n+    public static void cleanUp() {\n+        // delete all folders\n+        SERVICE_CACHE_FOLDER.delete();\n+        CACHE_FOLDER.delete();\n+        USERDATA_FOLDER.delete();\n+    }\n+\n+    @Test\n+    public void testGetFileExtension() {\n+        assertThat(subject.getFileExtension(\"/var/log/openhab2/\"), is(nullValue()));\n+        assertThat(subject.getFileExtension(\"/var/log/foo.bar/\"), is(nullValue()));\n+        assertThat(subject.getFileExtension(\"doorbell.mp3\"), is(equalTo(\"mp3\")));\n+        assertThat(subject.getFileExtension(\"/tmp/doorbell.mp3\"), is(equalTo(\"mp3\")));\n+        assertThat(subject.getFileExtension(MP3_FILE_NAME), is(equalTo(\"mp3\")));\n+        assertThat(subject.getFileExtension(TXT_FILE_NAME), is(equalTo(\"txt\")));\n+        assertThat(subject.getFileExtension(\"/var/log/openhab2/..\"), is(\"\"));\n+        assertThat(subject.getFileExtension(\".hidden\"), is(equalTo(\"hidden\")));\n+        assertThat(subject.getFileExtension(\"C:\\\\Program Files (x86)\\\\java\\\\bin\\\\javaw.exe\"), is(equalTo(\"exe\")));\n+        assertThat(subject.getFileExtension(\"https://www.youtube.com/watch?v=qYrpPrLY868\"), is(nullValue()));", "originalCommit": "202cefaf6c783fb3af08a698ceb018847567fb19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM0MzAxMw==", "url": "https://github.com/openhab/openhab-core/pull/1723#discussion_r510343013", "bodyText": "\ud83d\udc4d Good point.\nFirst one fails:\nassertThat(subject.getFileExtension(\"https://www.youtube.com/watch?v=Test.With.Dots\"), is(nullValue()));\n\nTo got it sorted I think I have to strip the ? and the content after it from the file name first.\nSecond one is working:\nassertThat(subject.getFileExtension(\"https://host/test.xlsx?cache=false\"), is(\"xlsx\"));\n\nI can remember a situation where someone who uses Kodi (player) combined with Plex (media server) in a local network sent me an error in which an url like the following got interpreted wrong because of the local ip address:\n\nhttp://127.0.0.1:8080/image/image%3A%2F%2Fhttp%253a%252f%252f127.0.0.1%253a32400%252fphoto%252f%253a%252ftranscode%253fwidth%253d1920%2526height%253d1920%2526minSize%253d1%2526upscale%253d0%2526url%253d%252flibrary%252fmetadata%252f1896%252fthumb%252f1569782004%2526X-Plex-Token%253dXScJLJbUdcybNXFyHLuv\n\nI never found a solution for it. The extension will result in 1%253a32400%252fphoto%252f%253a%252ftranscode%253fwidth%253d1920%2526height%253d1920%2526minSize%253d1%2526upscale%253d0%2526url%253d%252flibrary%252fmetadata%252f1896%252fthumb%252f1569782004%2526X-Plex-Token%253dXScJLJbUdcybNXFyHLuv. But I think it is a very rare situation.", "author": "cweitkamp", "createdAt": "2020-10-22T17:39:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE4MzIzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM0NzI1Mg==", "url": "https://github.com/openhab/openhab-core/pull/1723#discussion_r510347252", "bodyText": "I saw a problem with the first one.\nBut we should add the tests to be sure, that it keeps working even after firther development :-)", "author": "jochen314", "createdAt": "2020-10-22T17:46:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE4MzIzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM0OTU5MQ==", "url": "https://github.com/openhab/openhab-core/pull/1723#discussion_r510349591", "bodyText": "Already done in 9769174.", "author": "cweitkamp", "createdAt": "2020-10-22T17:50:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE4MzIzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE4MzY5Ng==", "url": "https://github.com/openhab/openhab-core/pull/1723#discussion_r507183696", "bodyText": "Should there be a test, that putIfAbsent  does not overwrite an existing file?\nSo\n\ndo a put with contentA\ndo a putIfAbsent with contentB\ndo a get and assert contentA", "author": "jochen314", "createdAt": "2020-10-18T16:32:30Z", "path": "bundles/org.openhab.core/src/test/java/org/openhab/core/cache/ByteArrayFileCacheTest.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.cache;\n+\n+import static org.hamcrest.CoreMatchers.*;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.openhab.core.OpenHAB;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Test class for the {@link ByteArrayFileCache} class.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ByteArrayFileCacheTest {\n+\n+    private static final String SERVICE_PID = \"org.openhab.core.test\";\n+\n+    private static final File USERDATA_FOLDER = new File(OpenHAB.getUserDataFolder());\n+    private static final File CACHE_FOLDER = new File(USERDATA_FOLDER, ByteArrayFileCache.CACHE_FOLDER_NAME);\n+    private static final File SERVICE_CACHE_FOLDER = new File(CACHE_FOLDER, SERVICE_PID);\n+\n+    private static final String MP3_FILE_NAME = SERVICE_CACHE_FOLDER.getAbsolutePath() + \"doorbell.mp3\";\n+    private static final String TXT_FILE_NAME = SERVICE_CACHE_FOLDER.getAbsolutePath() + \"doorbell.txt\";\n+\n+    private static @Nullable File txt_file;\n+\n+    private final Logger logger = LoggerFactory.getLogger(ByteArrayFileCacheTest.class);\n+\n+    private @NonNullByDefault({}) ByteArrayFileCache subject;\n+\n+    @BeforeAll\n+    public static void init() throws IOException {\n+        // create temporary file\n+        txt_file = createTempFile();\n+    }\n+\n+    @BeforeEach\n+    public void setUp() {\n+        subject = new ByteArrayFileCache(SERVICE_PID);\n+    }\n+\n+    @AfterEach\n+    public void tearDown() {\n+        // delete all files\n+        subject.clear();\n+    }\n+\n+    @AfterAll\n+    public static void cleanUp() {\n+        // delete all folders\n+        SERVICE_CACHE_FOLDER.delete();\n+        CACHE_FOLDER.delete();\n+        USERDATA_FOLDER.delete();\n+    }\n+\n+    @Test\n+    public void testGetFileExtension() {\n+        assertThat(subject.getFileExtension(\"/var/log/openhab2/\"), is(nullValue()));\n+        assertThat(subject.getFileExtension(\"/var/log/foo.bar/\"), is(nullValue()));\n+        assertThat(subject.getFileExtension(\"doorbell.mp3\"), is(equalTo(\"mp3\")));\n+        assertThat(subject.getFileExtension(\"/tmp/doorbell.mp3\"), is(equalTo(\"mp3\")));\n+        assertThat(subject.getFileExtension(MP3_FILE_NAME), is(equalTo(\"mp3\")));\n+        assertThat(subject.getFileExtension(TXT_FILE_NAME), is(equalTo(\"txt\")));\n+        assertThat(subject.getFileExtension(\"/var/log/openhab2/..\"), is(\"\"));\n+        assertThat(subject.getFileExtension(\".hidden\"), is(equalTo(\"hidden\")));\n+        assertThat(subject.getFileExtension(\"C:\\\\Program Files (x86)\\\\java\\\\bin\\\\javaw.exe\"), is(equalTo(\"exe\")));\n+        assertThat(subject.getFileExtension(\"https://www.youtube.com/watch?v=qYrpPrLY868\"), is(nullValue()));\n+    }\n+\n+    @Test\n+    public void testGetUniqueFileName() {\n+        String mp3UniqueFileName = subject.getUniqueFileName(MP3_FILE_NAME);\n+        assertThat(mp3UniqueFileName, is(equalTo(subject.getUniqueFileName(MP3_FILE_NAME))));\n+\n+        String txtUniqueFileName = subject.getUniqueFileName(TXT_FILE_NAME);\n+        assertThat(txtUniqueFileName, is(equalTo(subject.getUniqueFileName(TXT_FILE_NAME))));\n+\n+        assertThat(mp3UniqueFileName, is(not(equalTo(txtUniqueFileName))));\n+    }\n+\n+    @Test\n+    public void testGet() {\n+        assertThrows(FileNotFoundException.class, () -> subject.get(TXT_FILE_NAME));\n+    }\n+\n+    @Test\n+    public void testPut() throws IOException {\n+        byte[] buffer = readTempFile();\n+        subject.put(TXT_FILE_NAME, buffer);\n+\n+        assertThat(subject.get(TXT_FILE_NAME), is(equalTo(buffer)));\n+    }\n+\n+    @Test\n+    public void testPutIfAbsent() throws IOException {", "originalCommit": "202cefaf6c783fb3af08a698ceb018847567fb19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE4Mzk2OA==", "url": "https://github.com/openhab/openhab-core/pull/1723#discussion_r507183968", "bodyText": "This is returning the wrong value.\nIf putIfAbsent does not change the value, then this function should return the old value, not the parameter.", "author": "jochen314", "createdAt": "2020-10-18T16:35:01Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/cache/ByteArrayFileCache.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.cache;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.file.Files;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a simple file based cache implementation.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ByteArrayFileCache {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ByteArrayFileCache.class);\n+\n+    static final String CACHE_FOLDER_NAME = \"cache\";\n+    private static final char EXTENSION_SEPARATOR = '.';\n+\n+    private final File cacheFolder;\n+\n+    static final long ONE_DAY_IN_MILLIS = TimeUnit.DAYS.toMillis(1);\n+    private long expiry;\n+\n+    private static final Map<String, File> FILES_IN_CACHE = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$OPENHAB_USERDATA/cache/$servicePID</code>.\n+     *\n+     * @param servicePID PID of the service\n+     */\n+    public ByteArrayFileCache(String servicePID) {\n+        // TODO track and limit folder size\n+        // TODO support user specific folder\n+        cacheFolder = new File(new File(OpenHAB.getUserDataFolder(), CACHE_FOLDER_NAME), servicePID);\n+        if (!cacheFolder.exists()) {\n+            logger.debug(\"Creating cache folder '{}'\", cacheFolder.getAbsolutePath());\n+            cacheFolder.mkdirs();\n+        }\n+        logger.debug(\"Using cache folder '{}'\", cacheFolder.getAbsolutePath());\n+    }\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$OPENHAB_USERDATA/cache/$servicePID/</code>.\n+     *\n+     * @param servicePID PID of the service\n+     * @param long the days for how long the files stay in the cache valid. Must be positive. 0 to\n+     *            disable this functionality.\n+     */\n+    public ByteArrayFileCache(String servicePID, long expiry) {\n+        this(servicePID, Duration.ofDays(expiry));\n+    }\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$OPENHAB_USERDATA/cache/$servicePID/</code>.\n+     *\n+     * @param servicePID PID of the service\n+     * @param Duration the days for how long the files stay in the cache valid. Must be positive. 0 to\n+     *            disable this functionality.\n+     */\n+    public ByteArrayFileCache(String servicePID, Duration expiry) {\n+        this(servicePID);\n+        if (expiry.isNegative()) {\n+            throw new IllegalArgumentException(\"Cache expiration time must be greater than or equal to 0\");\n+        }\n+        this.expiry = expiry.toDays();\n+    }\n+\n+    /**\n+     * Adds a file to the cache. If the cache previously contained a file for the key, the old file is replaced by the\n+     * new content.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     */\n+    public void put(String key, byte[] content) {\n+        writeFile(getUniqueFile(key), content);\n+    }\n+\n+    /**\n+     * Adds a file to the cache.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     */\n+    public void putIfAbsent(String key, byte[] content) {\n+        File fileInCache = getUniqueFile(key);\n+        if (fileInCache.exists()) {\n+            logger.debug(\"File '{}' present in cache\", fileInCache.getName());\n+            // update time of last use\n+            fileInCache.setLastModified(System.currentTimeMillis());\n+        } else {\n+            writeFile(fileInCache, content);\n+        }\n+    }\n+\n+    /**\n+     * Adds a file to the cache and returns the content of the file.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     * @return the content of the file associated with the given key\n+     */\n+    public byte[] putIfAbsentAndGet(String key, byte[] content) {", "originalCommit": "202cefaf6c783fb3af08a698ceb018847567fb19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE4NDEyMg==", "url": "https://github.com/openhab/openhab-core/pull/1723#discussion_r507184122", "bodyText": "Maybe, this function should return a boolean:\n\nreturn true, iff the file was changed\nThat would make implementing putIfAbsentAndGet easier.", "author": "jochen314", "createdAt": "2020-10-18T16:36:41Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/cache/ByteArrayFileCache.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.cache;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.file.Files;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a simple file based cache implementation.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ByteArrayFileCache {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ByteArrayFileCache.class);\n+\n+    static final String CACHE_FOLDER_NAME = \"cache\";\n+    private static final char EXTENSION_SEPARATOR = '.';\n+\n+    private final File cacheFolder;\n+\n+    static final long ONE_DAY_IN_MILLIS = TimeUnit.DAYS.toMillis(1);\n+    private long expiry;\n+\n+    private static final Map<String, File> FILES_IN_CACHE = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$OPENHAB_USERDATA/cache/$servicePID</code>.\n+     *\n+     * @param servicePID PID of the service\n+     */\n+    public ByteArrayFileCache(String servicePID) {\n+        // TODO track and limit folder size\n+        // TODO support user specific folder\n+        cacheFolder = new File(new File(OpenHAB.getUserDataFolder(), CACHE_FOLDER_NAME), servicePID);\n+        if (!cacheFolder.exists()) {\n+            logger.debug(\"Creating cache folder '{}'\", cacheFolder.getAbsolutePath());\n+            cacheFolder.mkdirs();\n+        }\n+        logger.debug(\"Using cache folder '{}'\", cacheFolder.getAbsolutePath());\n+    }\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$OPENHAB_USERDATA/cache/$servicePID/</code>.\n+     *\n+     * @param servicePID PID of the service\n+     * @param long the days for how long the files stay in the cache valid. Must be positive. 0 to\n+     *            disable this functionality.\n+     */\n+    public ByteArrayFileCache(String servicePID, long expiry) {\n+        this(servicePID, Duration.ofDays(expiry));\n+    }\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$OPENHAB_USERDATA/cache/$servicePID/</code>.\n+     *\n+     * @param servicePID PID of the service\n+     * @param Duration the days for how long the files stay in the cache valid. Must be positive. 0 to\n+     *            disable this functionality.\n+     */\n+    public ByteArrayFileCache(String servicePID, Duration expiry) {\n+        this(servicePID);\n+        if (expiry.isNegative()) {\n+            throw new IllegalArgumentException(\"Cache expiration time must be greater than or equal to 0\");\n+        }\n+        this.expiry = expiry.toDays();\n+    }\n+\n+    /**\n+     * Adds a file to the cache. If the cache previously contained a file for the key, the old file is replaced by the\n+     * new content.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     */\n+    public void put(String key, byte[] content) {\n+        writeFile(getUniqueFile(key), content);\n+    }\n+\n+    /**\n+     * Adds a file to the cache.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     */\n+    public void putIfAbsent(String key, byte[] content) {", "originalCommit": "202cefaf6c783fb3af08a698ceb018847567fb19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM0MTg3Ng==", "url": "https://github.com/openhab/openhab-core/pull/1723#discussion_r510341876", "bodyText": "The idea behind of this method follows the ExpiringCacheMap implementation. That is why we have a void putIfAbsent(...) and a byte[] putIfAbsentAndGet(...) method.", "author": "cweitkamp", "createdAt": "2020-10-22T17:38:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE4NDEyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM0NzI1OQ==", "url": "https://github.com/openhab/openhab-core/pull/1723#discussion_r510347259", "bodyText": "But then the signature should be:\nbyte[] putIfAbsentAndGet(String key, Supplier<byte[]> action)\n\nand the action should only be called, if the value is absent.", "author": "jochen314", "createdAt": "2020-10-22T17:46:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE4NDEyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM1MjUxNw==", "url": "https://github.com/openhab/openhab-core/pull/1723#discussion_r510352517", "bodyText": "public void putIfAbsent(String key, byte[] content) {\n\t\tputIfAbsentAndGet(key, () -> content);\n\t}\n\tpublic byte[] putIfAbsentAndGet(String key, Supplier<byte[]> action) {\n\t\tFile fileInCache = getUniqueFile(key);\n\t\tif (fileInCache.exists()) {\n\t\t\tlogger.debug(\"File '{}' present in cache\", fileInCache.getName());\n\t\t\t// update time of last use\n\t\t\tfileInCache.setLastModified(System.currentTimeMillis());\n\t\t} else {\n\t\t\twriteFile(fileInCache, action.get());\n\t\t}\n\t}", "author": "jochen314", "createdAt": "2020-10-22T17:55:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE4NDEyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM1MzUwMg==", "url": "https://github.com/openhab/openhab-core/pull/1723#discussion_r510353502", "bodyText": "sorry, getting thing mixed up ....", "author": "jochen314", "createdAt": "2020-10-22T17:57:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE4NDEyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4NTcwMA==", "url": "https://github.com/openhab/openhab-core/pull/1723#discussion_r510385700", "bodyText": "Alright. Then we are done here?", "author": "cweitkamp", "createdAt": "2020-10-22T18:53:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE4NDEyMg=="}], "type": "inlineReview"}, {"oid": "5b96eab86183aa7c962bdbbaf0a389c16c8dd4db", "url": "https://github.com/openhab/openhab-core/commit/5b96eab86183aa7c962bdbbaf0a389c16c8dd4db", "message": "Incorporated review comment\n\nSigned-off-by: Christoph Weitkamp <github@christophweitkamp.de>", "committedDate": "2020-10-22T17:16:17Z", "type": "commit"}, {"oid": "9769174086818da34834ad4d8a575d2a0622f689", "url": "https://github.com/openhab/openhab-core/commit/9769174086818da34834ad4d8a575d2a0622f689", "message": "Fixed URL stripping\n\nSigned-off-by: Christoph Weitkamp <github@christophweitkamp.de>", "committedDate": "2020-10-22T17:41:15Z", "type": "commit"}, {"oid": "79045875f8ef9f582b0b8d1a8e3a1cc08f4611e3", "url": "https://github.com/openhab/openhab-core/commit/79045875f8ef9f582b0b8d1a8e3a1cc08f4611e3", "message": "Epiry as millis\n\nSigned-off-by: Christoph Weitkamp <github@christophweitkamp.de>", "committedDate": "2020-10-22T18:53:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxMzg5OQ==", "url": "https://github.com/openhab/openhab-core/pull/1723#discussion_r511513899", "bodyText": "I would remove this method and only support a method taking a Duration parameter (i.e. the method below). The issue with long/int values is always that you do not know the unit so you have to document it in either the variable name or JavaDoc. If you don't do any (like this method) you have to inspect the code. With the Duration type you never have to worry about this.", "author": "wborn", "createdAt": "2020-10-24T21:00:38Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/cache/ByteArrayFileCache.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.cache;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.file.Files;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a simple file based cache implementation.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ByteArrayFileCache {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ByteArrayFileCache.class);\n+\n+    static final String CACHE_FOLDER_NAME = \"cache\";\n+    private static final char EXTENSION_SEPARATOR = '.';\n+\n+    private final File cacheFolder;\n+\n+    private final long expiry;\n+    private final Map<String, File> filesInCache = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$OPENHAB_USERDATA/cache/$servicePID</code>.\n+     *\n+     * @param servicePID PID of the service\n+     */\n+    public ByteArrayFileCache(String servicePID) {\n+        this(servicePID, Duration.ZERO);\n+    }\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$OPENHAB_USERDATA/cache/$servicePID/</code>.\n+     *\n+     * @param servicePID PID of the service\n+     * @param expiry the duration for how long the files stay valid in the cache. Must be positive. 0 to\n+     *            disable this functionality.\n+     */\n+    public ByteArrayFileCache(String servicePID, long expiry) {", "originalCommit": "79045875f8ef9f582b0b8d1a8e3a1cc08f4611e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNDE4OQ==", "url": "https://github.com/openhab/openhab-core/pull/1723#discussion_r511514189", "bodyText": "Is there a good reason for not making this a Duration?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final long expiry;\n          \n          \n            \n                private final Duration expiry;", "author": "wborn", "createdAt": "2020-10-24T21:04:09Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/cache/ByteArrayFileCache.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.cache;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.file.Files;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a simple file based cache implementation.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ByteArrayFileCache {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ByteArrayFileCache.class);\n+\n+    static final String CACHE_FOLDER_NAME = \"cache\";\n+    private static final char EXTENSION_SEPARATOR = '.';\n+\n+    private final File cacheFolder;\n+\n+    private final long expiry;", "originalCommit": "79045875f8ef9f582b0b8d1a8e3a1cc08f4611e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNDI3OA==", "url": "https://github.com/openhab/openhab-core/pull/1723#discussion_r511514278", "bodyText": "The class doesn't look thread safe. So you may want to mention this here.", "author": "wborn", "createdAt": "2020-10-24T21:04:57Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/cache/ByteArrayFileCache.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.cache;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.file.Files;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a simple file based cache implementation.", "originalCommit": "79045875f8ef9f582b0b8d1a8e3a1cc08f4611e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNDU1Nw==", "url": "https://github.com/openhab/openhab-core/pull/1723#discussion_r511514557", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (expiry <= 0) {\n          \n          \n            \n                        return false;\n          \n          \n            \n                    }\n          \n          \n            \n                    return expiry < System.currentTimeMillis() - fileInCache.lastModified();\n          \n          \n            \n                    return 0 < expiry && expiry < System.currentTimeMillis() - fileInCache.lastModified();", "author": "wborn", "createdAt": "2020-10-24T21:07:45Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/cache/ByteArrayFileCache.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.cache;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.file.Files;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.OpenHAB;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a simple file based cache implementation.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ByteArrayFileCache {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ByteArrayFileCache.class);\n+\n+    static final String CACHE_FOLDER_NAME = \"cache\";\n+    private static final char EXTENSION_SEPARATOR = '.';\n+\n+    private final File cacheFolder;\n+\n+    private final long expiry;\n+    private final Map<String, File> filesInCache = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$OPENHAB_USERDATA/cache/$servicePID</code>.\n+     *\n+     * @param servicePID PID of the service\n+     */\n+    public ByteArrayFileCache(String servicePID) {\n+        this(servicePID, Duration.ZERO);\n+    }\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$OPENHAB_USERDATA/cache/$servicePID/</code>.\n+     *\n+     * @param servicePID PID of the service\n+     * @param expiry the duration for how long the files stay valid in the cache. Must be positive. 0 to\n+     *            disable this functionality.\n+     */\n+    public ByteArrayFileCache(String servicePID, long expiry) {\n+        this(servicePID, Duration.ofDays(expiry));\n+    }\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$OPENHAB_USERDATA/cache/$servicePID/</code>.\n+     *\n+     * @param servicePID PID of the service\n+     * @param expiry the duration for how long the files stay valid in the cache. Must be positive. 0 to\n+     *            disable this functionality.\n+     */\n+    public ByteArrayFileCache(String servicePID, Duration expiry) {\n+        // TODO track and limit folder size\n+        // TODO support user specific folder\n+        cacheFolder = new File(new File(OpenHAB.getUserDataFolder(), CACHE_FOLDER_NAME), servicePID);\n+        if (!cacheFolder.exists()) {\n+            logger.debug(\"Creating cache folder '{}'\", cacheFolder.getAbsolutePath());\n+            cacheFolder.mkdirs();\n+        }\n+        logger.debug(\"Using cache folder '{}'\", cacheFolder.getAbsolutePath());\n+\n+        if (expiry.isNegative()) {\n+            throw new IllegalArgumentException(\"Cache expiration time must be greater than or equal to 0\");\n+        }\n+        this.expiry = expiry.toMillis();\n+    }\n+\n+    /**\n+     * Adds a file to the cache. If the cache previously contained a file for the key, the old file is replaced by the\n+     * new content.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     */\n+    public void put(String key, byte[] content) {\n+        writeFile(getUniqueFile(key), content);\n+    }\n+\n+    /**\n+     * Adds a file to the cache.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     */\n+    public void putIfAbsent(String key, byte[] content) {\n+        File fileInCache = getUniqueFile(key);\n+        if (fileInCache.exists()) {\n+            logger.debug(\"File '{}' present in cache\", fileInCache.getName());\n+            // update time of last use\n+            fileInCache.setLastModified(System.currentTimeMillis());\n+        } else {\n+            writeFile(fileInCache, content);\n+        }\n+    }\n+\n+    /**\n+     * Adds a file to the cache and returns the content of the file.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     * @return the content of the file associated with the given key\n+     * @throws IOException if an I/O error occurs reading the given file\n+     */\n+    public byte[] putIfAbsentAndGet(String key, byte[] content) throws IOException {\n+        putIfAbsent(key, content);\n+\n+        return get(key);\n+    }\n+\n+    /**\n+     * Writes the given content to the given {@link File}.\n+     *\n+     * @param fileInCache the {@link File}\n+     * @param content the content to be written\n+     */\n+    private void writeFile(File fileInCache, byte[] content) {\n+        logger.debug(\"Caching file '{}'\", fileInCache.getName());\n+        try {\n+            Files.write(fileInCache.toPath(), content);\n+        } catch (IOException e) {\n+            logger.warn(\"Could not write file '{}'\u00a0to cache\", fileInCache.getName(), e);\n+        }\n+    }\n+\n+    /**\n+     * Checks if the key is present in the cache.\n+     *\n+     * @param key the key whose presence in the cache is to be tested\n+     * @return true if the cache contains a file for the specified key\n+     */\n+    public boolean containsKey(String key) {\n+        return getUniqueFile(key).exists();\n+    }\n+\n+    /**\n+     * Removes the file associated with the given key from the cache.\n+     *\n+     * @param key the key whose associated file is to be removed\n+     */\n+    public void remove(String key) {\n+        deleteFile(getUniqueFile(key));\n+    }\n+\n+    /**\n+     * Deletes the given {@link File}.\n+     *\n+     * @param fileInCache the {@link File}\n+     */\n+    private void deleteFile(File fileInCache) {\n+        if (fileInCache.exists()) {\n+            logger.debug(\"Deleting file '{}' from cache\", fileInCache.getName());\n+            fileInCache.delete();\n+        } else {\n+            logger.debug(\"File '{}' not found in cache\", fileInCache.getName());\n+        }\n+    }\n+\n+    /**\n+     * Removes all files from the cache.\n+     */\n+    public void clear() {\n+        File[] filesInCache = cacheFolder.listFiles();\n+        if (filesInCache != null && filesInCache.length > 0) {\n+            logger.debug(\"Deleting all files from cache\");\n+            Arrays.stream(filesInCache).forEach(File::delete);\n+        }\n+    }\n+\n+    /**\n+     * Removes expired files from the cache.\n+     */\n+    public void clearExpired() {\n+        // exit if expiry is set to 0 (disabled)\n+        if (expiry <= 0) {\n+            return;\n+        }\n+        File[] filesInCache = cacheFolder.listFiles();\n+        if (filesInCache != null && filesInCache.length > 0) {\n+            logger.debug(\"Deleting expired files from cache\");\n+            Arrays.stream(filesInCache).filter(this::isExpired).forEach(File::delete);\n+        }\n+    }\n+\n+    /**\n+     * Checks if the given {@link File} is expired.\n+     *\n+     * @param fileInCache the {@link File}\n+     * @return <code>true</code> if the file is expired, <code>false</code> otherwise\n+     */\n+    private boolean isExpired(File fileInCache) {\n+        // exit if expiry is set to 0 (disabled)\n+        if (expiry <= 0) {\n+            return false;\n+        }\n+        return expiry < System.currentTimeMillis() - fileInCache.lastModified();", "originalCommit": "79045875f8ef9f582b0b8d1a8e3a1cc08f4611e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUxNDc2MA==", "url": "https://github.com/openhab/openhab-core/pull/1723#discussion_r511514760", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static @Nullable File txt_file;\n          \n          \n            \n                private static @Nullable File txtFile;", "author": "wborn", "createdAt": "2020-10-24T21:09:45Z", "path": "bundles/org.openhab.core/src/test/java/org/openhab/core/cache/ByteArrayFileCacheTest.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.cache;\n+\n+import static org.hamcrest.CoreMatchers.*;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.time.Duration;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.openhab.core.OpenHAB;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Test class for the {@link ByteArrayFileCache} class.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ByteArrayFileCacheTest {\n+\n+    private static final String SERVICE_PID = \"org.openhab.core.test\";\n+\n+    private static final File USERDATA_FOLDER = new File(OpenHAB.getUserDataFolder());\n+    private static final File CACHE_FOLDER = new File(USERDATA_FOLDER, ByteArrayFileCache.CACHE_FOLDER_NAME);\n+    private static final File SERVICE_CACHE_FOLDER = new File(CACHE_FOLDER, SERVICE_PID);\n+\n+    private static final String MP3_FILE_NAME = SERVICE_CACHE_FOLDER.getAbsolutePath() + \"doorbell.mp3\";\n+    private static final String TXT_FILE_NAME = SERVICE_CACHE_FOLDER.getAbsolutePath() + \"doorbell.txt\";\n+\n+    private static @Nullable File txt_file;", "originalCommit": "79045875f8ef9f582b0b8d1a8e3a1cc08f4611e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cbd59fdda83494adf5c624b55608c89b7b876150", "url": "https://github.com/openhab/openhab-core/commit/cbd59fdda83494adf5c624b55608c89b7b876150", "message": "Incorporated review comments\n\nSigned-off-by: Christoph Weitkamp <github@christophweitkamp.de>", "committedDate": "2020-10-25T10:27:03Z", "type": "commit"}]}