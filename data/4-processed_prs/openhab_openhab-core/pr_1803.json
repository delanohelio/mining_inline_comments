{"pr_number": 1803, "pr_title": "Added expire functionality as core framework feature", "pr_createdAt": "2020-11-08T22:33:04Z", "pr_url": "https://github.com/openhab/openhab-core/pull/1803", "timeline": [{"oid": "798dabe9c09d4afcc8e9aaa8106d6205c807ded2", "url": "https://github.com/openhab/openhab-core/commit/798dabe9c09d4afcc8e9aaa8106d6205c807ded2", "message": "added expire functionality\n\nSigned-off-by: Kai Kreuzer <kai@openhab.org>", "committedDate": "2020-11-08T22:26:51Z", "type": "commit"}, {"oid": "c50ab78f7000690f215673e3616f71b2c7af2184", "url": "https://github.com/openhab/openhab-core/commit/c50ab78f7000690f215673e3616f71b2c7af2184", "message": "added unit tests\n\nSigned-off-by: Kai Kreuzer <kai@openhab.org>", "committedDate": "2020-11-14T20:13:58Z", "type": "commit"}, {"oid": "0644e0dc28c5cf8655f2e16c1c9623fd29e80dda", "url": "https://github.com/openhab/openhab-core/commit/0644e0dc28c5cf8655f2e16c1c9623fd29e80dda", "message": "fixed spotless problem\n\nSigned-off-by: Kai Kreuzer <kai@openhab.org>", "committedDate": "2020-11-15T09:55:03Z", "type": "commit"}, {"oid": "93a8510508b32c0a0ee65699b7ec26192f7c3a99", "url": "https://github.com/openhab/openhab-core/commit/93a8510508b32c0a0ee65699b7ec26192f7c3a99", "message": "Allow NULL and UNDEF as strings\n\nSigned-off-by: Kai Kreuzer <kai@openhab.org>", "committedDate": "2020-11-15T20:44:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3Nzc4Mg==", "url": "https://github.com/openhab/openhab-core/pull/1803#discussion_r524477782", "bodyText": "I do not understand this comment. Where do we add a null value to the itemExpireConfig map? I guess your idea was to prevent repeated interaction with the metadata registry but currently it looks like we are trying to get and parse the metadata all the time unless an item has the new namespace.", "author": "cweitkamp", "createdAt": "2020-11-16T18:19:07Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/items/ExpireManager.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.internal.items;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.common.registry.RegistryChangeListener;\n+import org.openhab.core.events.Event;\n+import org.openhab.core.events.EventFilter;\n+import org.openhab.core.events.EventPublisher;\n+import org.openhab.core.events.EventSubscriber;\n+import org.openhab.core.items.Item;\n+import org.openhab.core.items.ItemNotFoundException;\n+import org.openhab.core.items.ItemRegistry;\n+import org.openhab.core.items.Metadata;\n+import org.openhab.core.items.MetadataKey;\n+import org.openhab.core.items.MetadataRegistry;\n+import org.openhab.core.items.events.ItemCommandEvent;\n+import org.openhab.core.items.events.ItemEventFactory;\n+import org.openhab.core.items.events.ItemStateEvent;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.ConfigurationPolicy;\n+import org.osgi.service.component.annotations.Modified;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Component which takes care of sending item state expiry events.\n+ *\n+ * @author Kai Kreuzer - Initial contribution\n+ * @author Michael Wyraz - Author of the 1.x expire binding, which this class is based on\n+ */\n+@NonNullByDefault\n+@Component(immediate = true, service = { ExpireManager.class,\n+        EventSubscriber.class }, configurationPid = \"org.openhab.expire\", configurationPolicy = ConfigurationPolicy.OPTIONAL)\n+public class ExpireManager implements EventSubscriber, RegistryChangeListener<Item> {\n+\n+    protected static final String EVENT_SOURCE = \"org.openhab.core.expire\";\n+    protected static final String METADATA_NAMESPACE = \"expire\";\n+    protected static final String PROPERTY_ENABLED = \"enabled\";\n+\n+    private static final Set<String> SUBSCRIBED_EVENT_TYPES = Set.of(ItemStateEvent.TYPE, ItemCommandEvent.TYPE);\n+\n+    private final Logger logger = LoggerFactory.getLogger(ExpireManager.class);\n+\n+    private Map<String, ExpireConfig> itemExpireConfig = new ConcurrentHashMap<>();\n+    private Map<String, Instant> itemExpireMap = new ConcurrentHashMap<>();\n+\n+    private ScheduledExecutorService threadPool = ThreadPoolManager\n+            .getScheduledPool(ThreadPoolManager.THREAD_POOL_NAME_COMMON);\n+\n+    private final EventPublisher eventPublisher;\n+    private final MetadataRegistry metadataRegistry;\n+    private final ItemRegistry itemRegistry;\n+\n+    private boolean enabled = true;\n+\n+    private @Nullable ScheduledFuture<?> expireJob;\n+\n+    @Activate\n+    public ExpireManager(Map<String, @Nullable Object> configuration, final @Reference EventPublisher eventPublisher,\n+            final @Reference MetadataRegistry metadataRegistry, final @Reference ItemRegistry itemRegistry) {\n+        this.eventPublisher = eventPublisher;\n+        this.metadataRegistry = metadataRegistry;\n+        this.itemRegistry = itemRegistry;\n+\n+        modified(configuration);\n+    }\n+\n+    @Modified\n+    protected void modified(Map<String, @Nullable Object> configuration) {\n+        Object valueEnabled = configuration.get(PROPERTY_ENABLED);\n+        if (valueEnabled != null) {\n+            enabled = Boolean.parseBoolean(valueEnabled.toString());\n+        }\n+        if (enabled) {\n+            if (expireJob == null) {\n+                expireJob = threadPool.scheduleWithFixedDelay(() -> {\n+                    if (!itemExpireMap.isEmpty()) {\n+                        for (String itemName : itemExpireConfig.keySet()) {\n+                            if (isReadyToExpire(itemName)) {\n+                                expire(itemName);\n+                            }\n+                        }\n+                    }\n+                }, 1, 1, TimeUnit.SECONDS);\n+            }\n+            itemRegistry.addRegistryChangeListener(this);\n+        } else {\n+            itemRegistry.removeRegistryChangeListener(this);\n+            if (expireJob != null) {\n+                expireJob.cancel(true);\n+                expireJob = null;\n+            }\n+        }\n+    }\n+\n+    public void receiveCommand(ItemCommandEvent commandEvent) {\n+        Command command = commandEvent.getItemCommand();\n+        String itemName = commandEvent.getItemName();\n+        logger.trace(\"Received command '{}' for item {}\", command, itemName);\n+        ExpireConfig expireConfig = getExpireConfig(itemName);\n+        if (expireConfig != null) {\n+            Command expireCommand = expireConfig.expireCommand;\n+            State expireState = expireConfig.expireState;\n+\n+            if ((expireCommand != null && expireCommand.equals(command))\n+                    || (expireState != null && expireState.equals(command))) {\n+                // New command is expired command or state -> no further action needed\n+                itemExpireMap.remove(itemName); // remove expire trigger until next update or command\n+                logger.debug(\"Item {} received command '{}'; stopping any future expiration.\", itemName, command);\n+            } else {\n+                // New command is not the expired command or state, so add the trigger to the map\n+                Duration duration = expireConfig.duration;\n+                itemExpireMap.put(itemName, Instant.now().plus(duration));\n+                logger.debug(\"Item {} will expire (with '{}' {}) in {} ms\", itemName,\n+                        expireCommand == null ? expireState : expireCommand,\n+                        expireCommand == null ? \"state\" : \"command\", duration);\n+            }\n+        }\n+    }\n+\n+    protected void receiveUpdate(ItemStateEvent stateEvent) {\n+        State state = stateEvent.getItemState();\n+        String itemName = stateEvent.getItemName();\n+        logger.trace(\"Received update '{}' for item {}\", state, itemName);\n+        ExpireConfig expireConfig = getExpireConfig(itemName);\n+        if (expireConfig != null) {\n+            Command expireCommand = expireConfig.expireCommand;\n+            State expireState = expireConfig.expireState;\n+\n+            if ((expireCommand != null && expireCommand.equals(state))\n+                    || (expireState != null && expireState.equals(state))) {\n+                // New state is expired command or state -> no further action needed\n+                itemExpireMap.remove(itemName); // remove expire trigger until next update or command\n+                logger.debug(\"Item {} received update '{}'; stopping any future expiration.\", itemName, state);\n+            } else {\n+                // New state is not the expired command or state, so add the trigger to the map\n+                Duration duration = expireConfig.duration;\n+                itemExpireMap.put(itemName, Instant.now().plus(duration));\n+                logger.debug(\"Item {} will expire (with '{}' {}) in {} ms\", itemName,\n+                        expireCommand == null ? expireState : expireCommand,\n+                        expireCommand == null ? \"state\" : \"command\", duration);\n+            }\n+        }\n+    }\n+\n+    private @Nullable ExpireConfig getExpireConfig(String itemName) {\n+        // the value might be null, so we explicitly check if an entry for that key exists", "originalCommit": "93a8510508b32c0a0ee65699b7ec26192f7c3a99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDUwMDI4NQ==", "url": "https://github.com/openhab/openhab-core/pull/1803#discussion_r524500285", "bodyText": "Good catch, this was indeed the intention.\nWith 79c256b in place, it should now indeed work as planned.", "author": "kaikreuzer", "createdAt": "2020-11-16T18:56:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3Nzc4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDUzMjEzMA==", "url": "https://github.com/openhab/openhab-core/pull/1803#discussion_r524532130", "bodyText": "That is good. A follow-up question. metadata can be added, edited or removed during runtime e.g. via console or REST API. Will it be taken I to account too?", "author": "cweitkamp", "createdAt": "2020-11-16T19:51:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3Nzc4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDYyNDgxMw==", "url": "https://github.com/openhab/openhab-core/pull/1803#discussion_r524624813", "bodyText": "You're always posing the right question... Indeed it wasn't taken into account, but it now is with d7d71fb.", "author": "kaikreuzer", "createdAt": "2020-11-16T21:46:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ3Nzc4Mg=="}], "type": "inlineReview"}, {"oid": "d8a6a14867be51a9b908198d84eea4064a58f8e9", "url": "https://github.com/openhab/openhab-core/commit/d8a6a14867be51a9b908198d84eea4064a58f8e9", "message": "directly return when being disabled\n\nSigned-off-by: Kai Kreuzer <kai@openhab.org>", "committedDate": "2020-11-16T18:42:01Z", "type": "commit"}, {"oid": "79c256be3779703d783cae5a6afe597dd24b1752", "url": "https://github.com/openhab/openhab-core/commit/79c256be3779703d783cae5a6afe597dd24b1752", "message": "do not retry config parsing\n\nSigned-off-by: Kai Kreuzer <kai@openhab.org>", "committedDate": "2020-11-16T18:55:12Z", "type": "commit"}, {"oid": "073a2e4245e4813dcb2a95c626a677b6b5514b39", "url": "https://github.com/openhab/openhab-core/commit/073a2e4245e4813dcb2a95c626a677b6b5514b39", "message": "fixed potential NPE when no metadata is available in cache\n\nSigned-off-by: Kai Kreuzer <kai@openhab.org>", "committedDate": "2020-11-16T21:43:46Z", "type": "commit"}, {"oid": "d7d71fbc903b4570d85d986573ba89c79cc08b18", "url": "https://github.com/openhab/openhab-core/commit/d7d71fbc903b4570d85d986573ba89c79cc08b18", "message": "listen to changes in metadata registry\n\nSigned-off-by: Kai Kreuzer <kai@openhab.org>", "committedDate": "2020-11-16T21:44:09Z", "type": "commit"}, {"oid": "0570b8407ef159e4747ebbe03f2b65e450a2527d", "url": "https://github.com/openhab/openhab-core/commit/0570b8407ef159e4747ebbe03f2b65e450a2527d", "message": "spotless fix\n\nSigned-off-by: Kai Kreuzer <kai@openhab.org>", "committedDate": "2020-11-17T07:15:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE5ODg2OA==", "url": "https://github.com/openhab/openhab-core/pull/1803#discussion_r525198868", "bodyText": "I think we should clear the itemExpireMap on disabling. This will prevent unexpected expire triggers the next time the manager will be enabled again.", "author": "cweitkamp", "createdAt": "2020-11-17T14:31:49Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/items/ExpireManager.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.internal.items;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.common.registry.RegistryChangeListener;\n+import org.openhab.core.events.Event;\n+import org.openhab.core.events.EventFilter;\n+import org.openhab.core.events.EventPublisher;\n+import org.openhab.core.events.EventSubscriber;\n+import org.openhab.core.items.Item;\n+import org.openhab.core.items.ItemNotFoundException;\n+import org.openhab.core.items.ItemRegistry;\n+import org.openhab.core.items.Metadata;\n+import org.openhab.core.items.MetadataKey;\n+import org.openhab.core.items.MetadataRegistry;\n+import org.openhab.core.items.events.ItemCommandEvent;\n+import org.openhab.core.items.events.ItemEventFactory;\n+import org.openhab.core.items.events.ItemStateEvent;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.ConfigurationPolicy;\n+import org.osgi.service.component.annotations.Modified;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Component which takes care of sending item state expiry events.\n+ *\n+ * @author Kai Kreuzer - Initial contribution\n+ * @author Michael Wyraz - Author of the 1.x expire binding, which this class is based on\n+ */\n+@NonNullByDefault\n+@Component(immediate = true, service = { ExpireManager.class,\n+        EventSubscriber.class }, configurationPid = \"org.openhab.expire\", configurationPolicy = ConfigurationPolicy.OPTIONAL)\n+public class ExpireManager implements EventSubscriber, RegistryChangeListener<Item> {\n+\n+    protected static final String EVENT_SOURCE = \"org.openhab.core.expire\";\n+    protected static final String METADATA_NAMESPACE = \"expire\";\n+    protected static final String PROPERTY_ENABLED = \"enabled\";\n+\n+    private static final Set<String> SUBSCRIBED_EVENT_TYPES = Set.of(ItemStateEvent.TYPE, ItemCommandEvent.TYPE);\n+\n+    private final Logger logger = LoggerFactory.getLogger(ExpireManager.class);\n+\n+    private Map<String, @Nullable Optional<ExpireConfig>> itemExpireConfig = new ConcurrentHashMap<>();\n+    private Map<String, Instant> itemExpireMap = new ConcurrentHashMap<>();\n+\n+    private ScheduledExecutorService threadPool = ThreadPoolManager\n+            .getScheduledPool(ThreadPoolManager.THREAD_POOL_NAME_COMMON);\n+\n+    private final EventPublisher eventPublisher;\n+    private final MetadataRegistry metadataRegistry;\n+    private final ItemRegistry itemRegistry;\n+    /* default */ final MetadataChangeListener metadataChangeListener = new MetadataChangeListener();\n+\n+    private boolean enabled = true;\n+\n+    private @Nullable ScheduledFuture<?> expireJob;\n+\n+    @Activate\n+    public ExpireManager(Map<String, @Nullable Object> configuration, final @Reference EventPublisher eventPublisher,\n+            final @Reference MetadataRegistry metadataRegistry, final @Reference ItemRegistry itemRegistry) {\n+        this.eventPublisher = eventPublisher;\n+        this.metadataRegistry = metadataRegistry;\n+        this.itemRegistry = itemRegistry;\n+\n+        modified(configuration);\n+    }\n+\n+    @Modified\n+    protected void modified(Map<String, @Nullable Object> configuration) {\n+        Object valueEnabled = configuration.get(PROPERTY_ENABLED);\n+        if (valueEnabled != null) {\n+            enabled = Boolean.parseBoolean(valueEnabled.toString());\n+        }\n+        if (enabled) {\n+            if (expireJob == null) {\n+                expireJob = threadPool.scheduleWithFixedDelay(() -> {\n+                    if (!itemExpireMap.isEmpty()) {\n+                        for (String itemName : itemExpireConfig.keySet()) {\n+                            if (isReadyToExpire(itemName)) {\n+                                expire(itemName);\n+                            }\n+                        }\n+                    }\n+                }, 1, 1, TimeUnit.SECONDS);\n+            }\n+            itemRegistry.addRegistryChangeListener(this);\n+            metadataRegistry.addRegistryChangeListener(metadataChangeListener);\n+        } else {", "originalCommit": "0570b8407ef159e4747ebbe03f2b65e450a2527d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTIwMDc5Mg==", "url": "https://github.com/openhab/openhab-core/pull/1803#discussion_r525200792", "bodyText": "For thread-safty we should use a local variable here.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (expireJob != null) {\n          \n          \n            \n                            expireJob.cancel(true);\n          \n          \n            \n                            expireJob = null;\n          \n          \n            \n                        }\n          \n          \n            \n                        ScheduledFuture<?> localExpireJob = expireJob;\n          \n          \n            \n                        if (localExpireJob != null) {\n          \n          \n            \n                            localExpireJob.cancel(true);\n          \n          \n            \n                            expireJob = null;\n          \n          \n            \n                        }", "author": "cweitkamp", "createdAt": "2020-11-17T14:34:22Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/items/ExpireManager.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.internal.items;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.common.registry.RegistryChangeListener;\n+import org.openhab.core.events.Event;\n+import org.openhab.core.events.EventFilter;\n+import org.openhab.core.events.EventPublisher;\n+import org.openhab.core.events.EventSubscriber;\n+import org.openhab.core.items.Item;\n+import org.openhab.core.items.ItemNotFoundException;\n+import org.openhab.core.items.ItemRegistry;\n+import org.openhab.core.items.Metadata;\n+import org.openhab.core.items.MetadataKey;\n+import org.openhab.core.items.MetadataRegistry;\n+import org.openhab.core.items.events.ItemCommandEvent;\n+import org.openhab.core.items.events.ItemEventFactory;\n+import org.openhab.core.items.events.ItemStateEvent;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.ConfigurationPolicy;\n+import org.osgi.service.component.annotations.Modified;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Component which takes care of sending item state expiry events.\n+ *\n+ * @author Kai Kreuzer - Initial contribution\n+ * @author Michael Wyraz - Author of the 1.x expire binding, which this class is based on\n+ */\n+@NonNullByDefault\n+@Component(immediate = true, service = { ExpireManager.class,\n+        EventSubscriber.class }, configurationPid = \"org.openhab.expire\", configurationPolicy = ConfigurationPolicy.OPTIONAL)\n+public class ExpireManager implements EventSubscriber, RegistryChangeListener<Item> {\n+\n+    protected static final String EVENT_SOURCE = \"org.openhab.core.expire\";\n+    protected static final String METADATA_NAMESPACE = \"expire\";\n+    protected static final String PROPERTY_ENABLED = \"enabled\";\n+\n+    private static final Set<String> SUBSCRIBED_EVENT_TYPES = Set.of(ItemStateEvent.TYPE, ItemCommandEvent.TYPE);\n+\n+    private final Logger logger = LoggerFactory.getLogger(ExpireManager.class);\n+\n+    private Map<String, @Nullable Optional<ExpireConfig>> itemExpireConfig = new ConcurrentHashMap<>();\n+    private Map<String, Instant> itemExpireMap = new ConcurrentHashMap<>();\n+\n+    private ScheduledExecutorService threadPool = ThreadPoolManager\n+            .getScheduledPool(ThreadPoolManager.THREAD_POOL_NAME_COMMON);\n+\n+    private final EventPublisher eventPublisher;\n+    private final MetadataRegistry metadataRegistry;\n+    private final ItemRegistry itemRegistry;\n+    /* default */ final MetadataChangeListener metadataChangeListener = new MetadataChangeListener();\n+\n+    private boolean enabled = true;\n+\n+    private @Nullable ScheduledFuture<?> expireJob;\n+\n+    @Activate\n+    public ExpireManager(Map<String, @Nullable Object> configuration, final @Reference EventPublisher eventPublisher,\n+            final @Reference MetadataRegistry metadataRegistry, final @Reference ItemRegistry itemRegistry) {\n+        this.eventPublisher = eventPublisher;\n+        this.metadataRegistry = metadataRegistry;\n+        this.itemRegistry = itemRegistry;\n+\n+        modified(configuration);\n+    }\n+\n+    @Modified\n+    protected void modified(Map<String, @Nullable Object> configuration) {\n+        Object valueEnabled = configuration.get(PROPERTY_ENABLED);\n+        if (valueEnabled != null) {\n+            enabled = Boolean.parseBoolean(valueEnabled.toString());\n+        }\n+        if (enabled) {\n+            if (expireJob == null) {\n+                expireJob = threadPool.scheduleWithFixedDelay(() -> {\n+                    if (!itemExpireMap.isEmpty()) {\n+                        for (String itemName : itemExpireConfig.keySet()) {\n+                            if (isReadyToExpire(itemName)) {\n+                                expire(itemName);\n+                            }\n+                        }\n+                    }\n+                }, 1, 1, TimeUnit.SECONDS);\n+            }\n+            itemRegistry.addRegistryChangeListener(this);\n+            metadataRegistry.addRegistryChangeListener(metadataChangeListener);\n+        } else {\n+            itemRegistry.removeRegistryChangeListener(this);\n+            metadataRegistry.removeRegistryChangeListener(metadataChangeListener);\n+            if (expireJob != null) {\n+                expireJob.cancel(true);\n+                expireJob = null;\n+            }", "originalCommit": "0570b8407ef159e4747ebbe03f2b65e450a2527d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTIwMTE1MA==", "url": "https://github.com/openhab/openhab-core/pull/1803#discussion_r525201150", "bodyText": "For thread-safty we should use a local variable (localExpireJob) here.", "author": "cweitkamp", "createdAt": "2020-11-17T14:34:53Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/items/ExpireManager.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.internal.items;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.common.registry.RegistryChangeListener;\n+import org.openhab.core.events.Event;\n+import org.openhab.core.events.EventFilter;\n+import org.openhab.core.events.EventPublisher;\n+import org.openhab.core.events.EventSubscriber;\n+import org.openhab.core.items.Item;\n+import org.openhab.core.items.ItemNotFoundException;\n+import org.openhab.core.items.ItemRegistry;\n+import org.openhab.core.items.Metadata;\n+import org.openhab.core.items.MetadataKey;\n+import org.openhab.core.items.MetadataRegistry;\n+import org.openhab.core.items.events.ItemCommandEvent;\n+import org.openhab.core.items.events.ItemEventFactory;\n+import org.openhab.core.items.events.ItemStateEvent;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.ConfigurationPolicy;\n+import org.osgi.service.component.annotations.Modified;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Component which takes care of sending item state expiry events.\n+ *\n+ * @author Kai Kreuzer - Initial contribution\n+ * @author Michael Wyraz - Author of the 1.x expire binding, which this class is based on\n+ */\n+@NonNullByDefault\n+@Component(immediate = true, service = { ExpireManager.class,\n+        EventSubscriber.class }, configurationPid = \"org.openhab.expire\", configurationPolicy = ConfigurationPolicy.OPTIONAL)\n+public class ExpireManager implements EventSubscriber, RegistryChangeListener<Item> {\n+\n+    protected static final String EVENT_SOURCE = \"org.openhab.core.expire\";\n+    protected static final String METADATA_NAMESPACE = \"expire\";\n+    protected static final String PROPERTY_ENABLED = \"enabled\";\n+\n+    private static final Set<String> SUBSCRIBED_EVENT_TYPES = Set.of(ItemStateEvent.TYPE, ItemCommandEvent.TYPE);\n+\n+    private final Logger logger = LoggerFactory.getLogger(ExpireManager.class);\n+\n+    private Map<String, @Nullable Optional<ExpireConfig>> itemExpireConfig = new ConcurrentHashMap<>();\n+    private Map<String, Instant> itemExpireMap = new ConcurrentHashMap<>();\n+\n+    private ScheduledExecutorService threadPool = ThreadPoolManager\n+            .getScheduledPool(ThreadPoolManager.THREAD_POOL_NAME_COMMON);\n+\n+    private final EventPublisher eventPublisher;\n+    private final MetadataRegistry metadataRegistry;\n+    private final ItemRegistry itemRegistry;\n+    /* default */ final MetadataChangeListener metadataChangeListener = new MetadataChangeListener();\n+\n+    private boolean enabled = true;\n+\n+    private @Nullable ScheduledFuture<?> expireJob;\n+\n+    @Activate\n+    public ExpireManager(Map<String, @Nullable Object> configuration, final @Reference EventPublisher eventPublisher,\n+            final @Reference MetadataRegistry metadataRegistry, final @Reference ItemRegistry itemRegistry) {\n+        this.eventPublisher = eventPublisher;\n+        this.metadataRegistry = metadataRegistry;\n+        this.itemRegistry = itemRegistry;\n+\n+        modified(configuration);\n+    }\n+\n+    @Modified\n+    protected void modified(Map<String, @Nullable Object> configuration) {\n+        Object valueEnabled = configuration.get(PROPERTY_ENABLED);\n+        if (valueEnabled != null) {\n+            enabled = Boolean.parseBoolean(valueEnabled.toString());\n+        }\n+        if (enabled) {\n+            if (expireJob == null) {", "originalCommit": "0570b8407ef159e4747ebbe03f2b65e450a2527d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTIwNDIyNA==", "url": "https://github.com/openhab/openhab-core/pull/1803#discussion_r525204224", "bodyText": "This can be static final.", "author": "cweitkamp", "createdAt": "2020-11-17T14:38:59Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/items/ExpireManager.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.internal.items;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.common.registry.RegistryChangeListener;\n+import org.openhab.core.events.Event;\n+import org.openhab.core.events.EventFilter;\n+import org.openhab.core.events.EventPublisher;\n+import org.openhab.core.events.EventSubscriber;\n+import org.openhab.core.items.Item;\n+import org.openhab.core.items.ItemNotFoundException;\n+import org.openhab.core.items.ItemRegistry;\n+import org.openhab.core.items.Metadata;\n+import org.openhab.core.items.MetadataKey;\n+import org.openhab.core.items.MetadataRegistry;\n+import org.openhab.core.items.events.ItemCommandEvent;\n+import org.openhab.core.items.events.ItemEventFactory;\n+import org.openhab.core.items.events.ItemStateEvent;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.ConfigurationPolicy;\n+import org.osgi.service.component.annotations.Modified;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Component which takes care of sending item state expiry events.\n+ *\n+ * @author Kai Kreuzer - Initial contribution\n+ * @author Michael Wyraz - Author of the 1.x expire binding, which this class is based on\n+ */\n+@NonNullByDefault\n+@Component(immediate = true, service = { ExpireManager.class,\n+        EventSubscriber.class }, configurationPid = \"org.openhab.expire\", configurationPolicy = ConfigurationPolicy.OPTIONAL)\n+public class ExpireManager implements EventSubscriber, RegistryChangeListener<Item> {\n+\n+    protected static final String EVENT_SOURCE = \"org.openhab.core.expire\";\n+    protected static final String METADATA_NAMESPACE = \"expire\";\n+    protected static final String PROPERTY_ENABLED = \"enabled\";\n+\n+    private static final Set<String> SUBSCRIBED_EVENT_TYPES = Set.of(ItemStateEvent.TYPE, ItemCommandEvent.TYPE);\n+\n+    private final Logger logger = LoggerFactory.getLogger(ExpireManager.class);\n+\n+    private Map<String, @Nullable Optional<ExpireConfig>> itemExpireConfig = new ConcurrentHashMap<>();\n+    private Map<String, Instant> itemExpireMap = new ConcurrentHashMap<>();\n+\n+    private ScheduledExecutorService threadPool = ThreadPoolManager\n+            .getScheduledPool(ThreadPoolManager.THREAD_POOL_NAME_COMMON);\n+\n+    private final EventPublisher eventPublisher;\n+    private final MetadataRegistry metadataRegistry;\n+    private final ItemRegistry itemRegistry;\n+    /* default */ final MetadataChangeListener metadataChangeListener = new MetadataChangeListener();\n+\n+    private boolean enabled = true;\n+\n+    private @Nullable ScheduledFuture<?> expireJob;\n+\n+    @Activate\n+    public ExpireManager(Map<String, @Nullable Object> configuration, final @Reference EventPublisher eventPublisher,\n+            final @Reference MetadataRegistry metadataRegistry, final @Reference ItemRegistry itemRegistry) {\n+        this.eventPublisher = eventPublisher;\n+        this.metadataRegistry = metadataRegistry;\n+        this.itemRegistry = itemRegistry;\n+\n+        modified(configuration);\n+    }\n+\n+    @Modified\n+    protected void modified(Map<String, @Nullable Object> configuration) {\n+        Object valueEnabled = configuration.get(PROPERTY_ENABLED);\n+        if (valueEnabled != null) {\n+            enabled = Boolean.parseBoolean(valueEnabled.toString());\n+        }\n+        if (enabled) {\n+            if (expireJob == null) {\n+                expireJob = threadPool.scheduleWithFixedDelay(() -> {\n+                    if (!itemExpireMap.isEmpty()) {\n+                        for (String itemName : itemExpireConfig.keySet()) {\n+                            if (isReadyToExpire(itemName)) {\n+                                expire(itemName);\n+                            }\n+                        }\n+                    }\n+                }, 1, 1, TimeUnit.SECONDS);\n+            }\n+            itemRegistry.addRegistryChangeListener(this);\n+            metadataRegistry.addRegistryChangeListener(metadataChangeListener);\n+        } else {\n+            itemRegistry.removeRegistryChangeListener(this);\n+            metadataRegistry.removeRegistryChangeListener(metadataChangeListener);\n+            if (expireJob != null) {\n+                expireJob.cancel(true);\n+                expireJob = null;\n+            }\n+        }\n+    }\n+\n+    public void receiveCommand(ItemCommandEvent commandEvent) {\n+        Command command = commandEvent.getItemCommand();\n+        String itemName = commandEvent.getItemName();\n+        logger.trace(\"Received command '{}' for item {}\", command, itemName);\n+        ExpireConfig expireConfig = getExpireConfig(itemName);\n+        if (expireConfig != null) {\n+            Command expireCommand = expireConfig.expireCommand;\n+            State expireState = expireConfig.expireState;\n+\n+            if ((expireCommand != null && expireCommand.equals(command))\n+                    || (expireState != null && expireState.equals(command))) {\n+                // New command is expired command or state -> no further action needed\n+                itemExpireMap.remove(itemName); // remove expire trigger until next update or command\n+                logger.debug(\"Item {} received command '{}'; stopping any future expiration.\", itemName, command);\n+            } else {\n+                // New command is not the expired command or state, so add the trigger to the map\n+                Duration duration = expireConfig.duration;\n+                itemExpireMap.put(itemName, Instant.now().plus(duration));\n+                logger.debug(\"Item {} will expire (with '{}' {}) in {} ms\", itemName,\n+                        expireCommand == null ? expireState : expireCommand,\n+                        expireCommand == null ? \"state\" : \"command\", duration);\n+            }\n+        }\n+    }\n+\n+    protected void receiveUpdate(ItemStateEvent stateEvent) {\n+        State state = stateEvent.getItemState();\n+        String itemName = stateEvent.getItemName();\n+        logger.trace(\"Received update '{}' for item {}\", state, itemName);\n+        ExpireConfig expireConfig = getExpireConfig(itemName);\n+        if (expireConfig != null) {\n+            Command expireCommand = expireConfig.expireCommand;\n+            State expireState = expireConfig.expireState;\n+\n+            if ((expireCommand != null && expireCommand.equals(state))\n+                    || (expireState != null && expireState.equals(state))) {\n+                // New state is expired command or state -> no further action needed\n+                itemExpireMap.remove(itemName); // remove expire trigger until next update or command\n+                logger.debug(\"Item {} received update '{}'; stopping any future expiration.\", itemName, state);\n+            } else {\n+                // New state is not the expired command or state, so add the trigger to the map\n+                Duration duration = expireConfig.duration;\n+                itemExpireMap.put(itemName, Instant.now().plus(duration));\n+                logger.debug(\"Item {} will expire (with '{}' {}) in {} ms\", itemName,\n+                        expireCommand == null ? expireState : expireCommand,\n+                        expireCommand == null ? \"state\" : \"command\", duration);\n+            }\n+        }\n+    }\n+\n+    private @Nullable ExpireConfig getExpireConfig(String itemName) {\n+        Optional<ExpireConfig> itemConfig = itemExpireConfig.get(itemName);\n+        if (itemConfig != null) {\n+            return itemConfig.isPresent() ? itemConfig.get() : null;\n+        } else {\n+            Metadata metadata = metadataRegistry.get(new MetadataKey(METADATA_NAMESPACE, itemName));\n+            if (metadata != null) {\n+                try {\n+                    Item item = itemRegistry.getItem(itemName);\n+                    try {\n+                        ExpireConfig cfg = new ExpireConfig(item, metadata.getValue());\n+                        itemExpireConfig.put(itemName, Optional.of(cfg));\n+                        return cfg;\n+                    } catch (IllegalArgumentException e) {\n+                        logger.warn(\"Expire config '{}' of item '{}' is invalid: {}\", metadata.getValue(), itemName,\n+                                e.getMessage());\n+                    }\n+                } catch (ItemNotFoundException e) {\n+                    logger.debug(\"Item '{}' does not exist.\", itemName);\n+                }\n+            }\n+            // also fill the map when there is no config, so that we do not retry to find one\n+            itemExpireConfig.put(itemName, Optional.empty());\n+            return null;\n+        }\n+    }\n+\n+    private void postCommand(String itemName, Command command) {\n+        eventPublisher.post(ItemEventFactory.createCommandEvent(itemName, command, EVENT_SOURCE));\n+    }\n+\n+    private void postUpdate(String itemName, State state) {\n+        eventPublisher.post(ItemEventFactory.createStateEvent(itemName, state, EVENT_SOURCE));\n+    }\n+\n+    private boolean isReadyToExpire(String itemName) {\n+        Instant nextExpiry = itemExpireMap.get(itemName);\n+        return (nextExpiry != null) && Instant.now().isAfter(nextExpiry);\n+    }\n+\n+    private void expire(String itemName) {\n+        itemExpireMap.remove(itemName); // disable expire trigger until next update or command\n+        Optional<ExpireConfig> expireConfig = itemExpireConfig.get(itemName);\n+\n+        if (expireConfig != null && expireConfig.isPresent()) {\n+            Command expireCommand = expireConfig.get().expireCommand;\n+            State expireState = expireConfig.get().expireState;\n+\n+            if (expireCommand != null) {\n+                logger.debug(\"Item {} received no command or update for {} - posting command '{}'\", itemName,\n+                        expireConfig.get().duration, expireCommand);\n+                postCommand(itemName, expireCommand);\n+            } else if (expireState != null) {\n+                logger.debug(\"Item {} received no command or update for {} - posting state '{}'\", itemName,\n+                        expireConfig.get().duration, expireState);\n+                postUpdate(itemName, expireState);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public Set<String> getSubscribedEventTypes() {\n+        return SUBSCRIBED_EVENT_TYPES;\n+    }\n+\n+    @Override\n+    public @Nullable EventFilter getEventFilter() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void receive(Event event) {\n+        if (!enabled) {\n+            return;\n+        }\n+        if (event instanceof ItemStateEvent) {\n+            receiveUpdate((ItemStateEvent) event);\n+        } else if (event instanceof ItemCommandEvent) {\n+            receiveCommand((ItemCommandEvent) event);\n+        }\n+    }\n+\n+    @Override\n+    public void added(Item item) {\n+        itemExpireConfig.remove(item.getName());\n+    }\n+\n+    @Override\n+    public void removed(Item item) {\n+        itemExpireConfig.remove(item.getName());\n+    }\n+\n+    @Override\n+    public void updated(Item oldItem, Item item) {\n+        itemExpireConfig.remove(item.getName());\n+    }\n+\n+    class MetadataChangeListener implements RegistryChangeListener<Metadata> {\n+\n+        @Override\n+        public void added(Metadata element) {\n+            itemExpireConfig.remove(element.getUID().getItemName());\n+        }\n+\n+        @Override\n+        public void removed(Metadata element) {\n+            itemExpireConfig.remove(element.getUID().getItemName());\n+        }\n+\n+        @Override\n+        public void updated(Metadata oldElement, Metadata element) {\n+            itemExpireConfig.remove(element.getUID().getItemName());\n+        }\n+    }\n+\n+    class ExpireConfig {\n+\n+        protected static final String COMMAND_PREFIX = \"command=\";\n+        protected static final String STATE_PREFIX = \"state=\";\n+\n+        protected final Pattern durationPattern = Pattern.compile(\"(?:([0-9]+)H)?\\\\s*(?:([0-9]+)M)?\\\\s*(?:([0-9]+)S)?\",", "originalCommit": "0570b8407ef159e4747ebbe03f2b65e450a2527d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTIwNzkwMA==", "url": "https://github.com/openhab/openhab-core/pull/1803#discussion_r525207900", "bodyText": "Only minor stuff: These four StringTypes can be defined as constants.", "author": "cweitkamp", "createdAt": "2020-11-17T14:43:42Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/items/ExpireManager.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.internal.items;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.common.registry.RegistryChangeListener;\n+import org.openhab.core.events.Event;\n+import org.openhab.core.events.EventFilter;\n+import org.openhab.core.events.EventPublisher;\n+import org.openhab.core.events.EventSubscriber;\n+import org.openhab.core.items.Item;\n+import org.openhab.core.items.ItemNotFoundException;\n+import org.openhab.core.items.ItemRegistry;\n+import org.openhab.core.items.Metadata;\n+import org.openhab.core.items.MetadataKey;\n+import org.openhab.core.items.MetadataRegistry;\n+import org.openhab.core.items.events.ItemCommandEvent;\n+import org.openhab.core.items.events.ItemEventFactory;\n+import org.openhab.core.items.events.ItemStateEvent;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.ConfigurationPolicy;\n+import org.osgi.service.component.annotations.Modified;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Component which takes care of sending item state expiry events.\n+ *\n+ * @author Kai Kreuzer - Initial contribution\n+ * @author Michael Wyraz - Author of the 1.x expire binding, which this class is based on\n+ */\n+@NonNullByDefault\n+@Component(immediate = true, service = { ExpireManager.class,\n+        EventSubscriber.class }, configurationPid = \"org.openhab.expire\", configurationPolicy = ConfigurationPolicy.OPTIONAL)\n+public class ExpireManager implements EventSubscriber, RegistryChangeListener<Item> {\n+\n+    protected static final String EVENT_SOURCE = \"org.openhab.core.expire\";\n+    protected static final String METADATA_NAMESPACE = \"expire\";\n+    protected static final String PROPERTY_ENABLED = \"enabled\";\n+\n+    private static final Set<String> SUBSCRIBED_EVENT_TYPES = Set.of(ItemStateEvent.TYPE, ItemCommandEvent.TYPE);\n+\n+    private final Logger logger = LoggerFactory.getLogger(ExpireManager.class);\n+\n+    private Map<String, @Nullable Optional<ExpireConfig>> itemExpireConfig = new ConcurrentHashMap<>();\n+    private Map<String, Instant> itemExpireMap = new ConcurrentHashMap<>();\n+\n+    private ScheduledExecutorService threadPool = ThreadPoolManager\n+            .getScheduledPool(ThreadPoolManager.THREAD_POOL_NAME_COMMON);\n+\n+    private final EventPublisher eventPublisher;\n+    private final MetadataRegistry metadataRegistry;\n+    private final ItemRegistry itemRegistry;\n+    /* default */ final MetadataChangeListener metadataChangeListener = new MetadataChangeListener();\n+\n+    private boolean enabled = true;\n+\n+    private @Nullable ScheduledFuture<?> expireJob;\n+\n+    @Activate\n+    public ExpireManager(Map<String, @Nullable Object> configuration, final @Reference EventPublisher eventPublisher,\n+            final @Reference MetadataRegistry metadataRegistry, final @Reference ItemRegistry itemRegistry) {\n+        this.eventPublisher = eventPublisher;\n+        this.metadataRegistry = metadataRegistry;\n+        this.itemRegistry = itemRegistry;\n+\n+        modified(configuration);\n+    }\n+\n+    @Modified\n+    protected void modified(Map<String, @Nullable Object> configuration) {\n+        Object valueEnabled = configuration.get(PROPERTY_ENABLED);\n+        if (valueEnabled != null) {\n+            enabled = Boolean.parseBoolean(valueEnabled.toString());\n+        }\n+        if (enabled) {\n+            if (expireJob == null) {\n+                expireJob = threadPool.scheduleWithFixedDelay(() -> {\n+                    if (!itemExpireMap.isEmpty()) {\n+                        for (String itemName : itemExpireConfig.keySet()) {\n+                            if (isReadyToExpire(itemName)) {\n+                                expire(itemName);\n+                            }\n+                        }\n+                    }\n+                }, 1, 1, TimeUnit.SECONDS);\n+            }\n+            itemRegistry.addRegistryChangeListener(this);\n+            metadataRegistry.addRegistryChangeListener(metadataChangeListener);\n+        } else {\n+            itemRegistry.removeRegistryChangeListener(this);\n+            metadataRegistry.removeRegistryChangeListener(metadataChangeListener);\n+            if (expireJob != null) {\n+                expireJob.cancel(true);\n+                expireJob = null;\n+            }\n+        }\n+    }\n+\n+    public void receiveCommand(ItemCommandEvent commandEvent) {\n+        Command command = commandEvent.getItemCommand();\n+        String itemName = commandEvent.getItemName();\n+        logger.trace(\"Received command '{}' for item {}\", command, itemName);\n+        ExpireConfig expireConfig = getExpireConfig(itemName);\n+        if (expireConfig != null) {\n+            Command expireCommand = expireConfig.expireCommand;\n+            State expireState = expireConfig.expireState;\n+\n+            if ((expireCommand != null && expireCommand.equals(command))\n+                    || (expireState != null && expireState.equals(command))) {\n+                // New command is expired command or state -> no further action needed\n+                itemExpireMap.remove(itemName); // remove expire trigger until next update or command\n+                logger.debug(\"Item {} received command '{}'; stopping any future expiration.\", itemName, command);\n+            } else {\n+                // New command is not the expired command or state, so add the trigger to the map\n+                Duration duration = expireConfig.duration;\n+                itemExpireMap.put(itemName, Instant.now().plus(duration));\n+                logger.debug(\"Item {} will expire (with '{}' {}) in {} ms\", itemName,\n+                        expireCommand == null ? expireState : expireCommand,\n+                        expireCommand == null ? \"state\" : \"command\", duration);\n+            }\n+        }\n+    }\n+\n+    protected void receiveUpdate(ItemStateEvent stateEvent) {\n+        State state = stateEvent.getItemState();\n+        String itemName = stateEvent.getItemName();\n+        logger.trace(\"Received update '{}' for item {}\", state, itemName);\n+        ExpireConfig expireConfig = getExpireConfig(itemName);\n+        if (expireConfig != null) {\n+            Command expireCommand = expireConfig.expireCommand;\n+            State expireState = expireConfig.expireState;\n+\n+            if ((expireCommand != null && expireCommand.equals(state))\n+                    || (expireState != null && expireState.equals(state))) {\n+                // New state is expired command or state -> no further action needed\n+                itemExpireMap.remove(itemName); // remove expire trigger until next update or command\n+                logger.debug(\"Item {} received update '{}'; stopping any future expiration.\", itemName, state);\n+            } else {\n+                // New state is not the expired command or state, so add the trigger to the map\n+                Duration duration = expireConfig.duration;\n+                itemExpireMap.put(itemName, Instant.now().plus(duration));\n+                logger.debug(\"Item {} will expire (with '{}' {}) in {} ms\", itemName,\n+                        expireCommand == null ? expireState : expireCommand,\n+                        expireCommand == null ? \"state\" : \"command\", duration);\n+            }\n+        }\n+    }\n+\n+    private @Nullable ExpireConfig getExpireConfig(String itemName) {\n+        Optional<ExpireConfig> itemConfig = itemExpireConfig.get(itemName);\n+        if (itemConfig != null) {\n+            return itemConfig.isPresent() ? itemConfig.get() : null;\n+        } else {\n+            Metadata metadata = metadataRegistry.get(new MetadataKey(METADATA_NAMESPACE, itemName));\n+            if (metadata != null) {\n+                try {\n+                    Item item = itemRegistry.getItem(itemName);\n+                    try {\n+                        ExpireConfig cfg = new ExpireConfig(item, metadata.getValue());\n+                        itemExpireConfig.put(itemName, Optional.of(cfg));\n+                        return cfg;\n+                    } catch (IllegalArgumentException e) {\n+                        logger.warn(\"Expire config '{}' of item '{}' is invalid: {}\", metadata.getValue(), itemName,\n+                                e.getMessage());\n+                    }\n+                } catch (ItemNotFoundException e) {\n+                    logger.debug(\"Item '{}' does not exist.\", itemName);\n+                }\n+            }\n+            // also fill the map when there is no config, so that we do not retry to find one\n+            itemExpireConfig.put(itemName, Optional.empty());\n+            return null;\n+        }\n+    }\n+\n+    private void postCommand(String itemName, Command command) {\n+        eventPublisher.post(ItemEventFactory.createCommandEvent(itemName, command, EVENT_SOURCE));\n+    }\n+\n+    private void postUpdate(String itemName, State state) {\n+        eventPublisher.post(ItemEventFactory.createStateEvent(itemName, state, EVENT_SOURCE));\n+    }\n+\n+    private boolean isReadyToExpire(String itemName) {\n+        Instant nextExpiry = itemExpireMap.get(itemName);\n+        return (nextExpiry != null) && Instant.now().isAfter(nextExpiry);\n+    }\n+\n+    private void expire(String itemName) {\n+        itemExpireMap.remove(itemName); // disable expire trigger until next update or command\n+        Optional<ExpireConfig> expireConfig = itemExpireConfig.get(itemName);\n+\n+        if (expireConfig != null && expireConfig.isPresent()) {\n+            Command expireCommand = expireConfig.get().expireCommand;\n+            State expireState = expireConfig.get().expireState;\n+\n+            if (expireCommand != null) {\n+                logger.debug(\"Item {} received no command or update for {} - posting command '{}'\", itemName,\n+                        expireConfig.get().duration, expireCommand);\n+                postCommand(itemName, expireCommand);\n+            } else if (expireState != null) {\n+                logger.debug(\"Item {} received no command or update for {} - posting state '{}'\", itemName,\n+                        expireConfig.get().duration, expireState);\n+                postUpdate(itemName, expireState);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public Set<String> getSubscribedEventTypes() {\n+        return SUBSCRIBED_EVENT_TYPES;\n+    }\n+\n+    @Override\n+    public @Nullable EventFilter getEventFilter() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void receive(Event event) {\n+        if (!enabled) {\n+            return;\n+        }\n+        if (event instanceof ItemStateEvent) {\n+            receiveUpdate((ItemStateEvent) event);\n+        } else if (event instanceof ItemCommandEvent) {\n+            receiveCommand((ItemCommandEvent) event);\n+        }\n+    }\n+\n+    @Override\n+    public void added(Item item) {\n+        itemExpireConfig.remove(item.getName());\n+    }\n+\n+    @Override\n+    public void removed(Item item) {\n+        itemExpireConfig.remove(item.getName());\n+    }\n+\n+    @Override\n+    public void updated(Item oldItem, Item item) {\n+        itemExpireConfig.remove(item.getName());\n+    }\n+\n+    class MetadataChangeListener implements RegistryChangeListener<Metadata> {\n+\n+        @Override\n+        public void added(Metadata element) {\n+            itemExpireConfig.remove(element.getUID().getItemName());\n+        }\n+\n+        @Override\n+        public void removed(Metadata element) {\n+            itemExpireConfig.remove(element.getUID().getItemName());\n+        }\n+\n+        @Override\n+        public void updated(Metadata oldElement, Metadata element) {\n+            itemExpireConfig.remove(element.getUID().getItemName());\n+        }\n+    }\n+\n+    class ExpireConfig {\n+\n+        protected static final String COMMAND_PREFIX = \"command=\";\n+        protected static final String STATE_PREFIX = \"state=\";\n+\n+        protected final Pattern durationPattern = Pattern.compile(\"(?:([0-9]+)H)?\\\\s*(?:([0-9]+)M)?\\\\s*(?:([0-9]+)S)?\",\n+                Pattern.CASE_INSENSITIVE);\n+\n+        @Nullable\n+        final Command expireCommand;\n+        @Nullable\n+        final State expireState;\n+        final String durationString;\n+        final Duration duration;\n+\n+        /**\n+         * Construct an ExpireConfig from the config string.\n+         *\n+         * Valid syntax:\n+         *\n+         * {@code &lt;duration&gt;[,[state=|command=|]&lt;stateOrCommand&gt;]}<br>\n+         * if neither state= or command= is present, assume state\n+         *\n+         * @param item the item to which we are bound\n+         * @param configString the string that the user specified in the metadate\n+         * @throws IllegalArgumentException if it is ill-formatted\n+         */\n+        public ExpireConfig(Item item, String configString) throws IllegalArgumentException {\n+            int commaPos = configString.indexOf(',');\n+\n+            durationString = (commaPos >= 0) ? configString.substring(0, commaPos).trim() : configString.trim();\n+            duration = parseDuration(durationString);\n+\n+            String stateOrCommand = ((commaPos >= 0) && (configString.length() - 1) > commaPos)\n+                    ? configString.substring(commaPos + 1).trim()\n+                    : null;\n+\n+            if ((stateOrCommand != null) && (stateOrCommand.length() > 0)) {\n+                if (stateOrCommand.startsWith(COMMAND_PREFIX)) {\n+                    String commandString = stateOrCommand.substring(COMMAND_PREFIX.length());\n+                    expireCommand = TypeParser.parseCommand(item.getAcceptedCommandTypes(), commandString);\n+                    expireState = null;\n+                    if (expireCommand == null) {\n+                        throw new IllegalArgumentException(\"The string '\" + commandString\n+                                + \"' does not represent a valid command for item \" + item.getName());\n+                    }\n+                } else {\n+                    if (stateOrCommand.startsWith(STATE_PREFIX)) {\n+                        stateOrCommand = stateOrCommand.substring(STATE_PREFIX.length());\n+                    }\n+                    String stateString = stateOrCommand;\n+                    State state = TypeParser.parseState(item.getAcceptedDataTypes(), stateString);\n+                    // do special handling to allow NULL and UNDEF as strings when being put in single quotes\n+                    if (new StringType(\"'NULL'\").equals(state)) {", "originalCommit": "0570b8407ef159e4747ebbe03f2b65e450a2527d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTIxMDM1Nw==", "url": "https://github.com/openhab/openhab-core/pull/1803#discussion_r525210357", "bodyText": "Just wondering f we can simplify the code of methods receiveCommand(ItemCommandEvent) and receiveUpdate(ItemStateEvent) because the are nearly identical. Just for the record - currently one is public, the other one is protected. That can be aligned too.", "author": "cweitkamp", "createdAt": "2020-11-17T14:46:39Z", "path": "bundles/org.openhab.core/src/main/java/org/openhab/core/internal/items/ExpireManager.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.internal.items;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.common.registry.RegistryChangeListener;\n+import org.openhab.core.events.Event;\n+import org.openhab.core.events.EventFilter;\n+import org.openhab.core.events.EventPublisher;\n+import org.openhab.core.events.EventSubscriber;\n+import org.openhab.core.items.Item;\n+import org.openhab.core.items.ItemNotFoundException;\n+import org.openhab.core.items.ItemRegistry;\n+import org.openhab.core.items.Metadata;\n+import org.openhab.core.items.MetadataKey;\n+import org.openhab.core.items.MetadataRegistry;\n+import org.openhab.core.items.events.ItemCommandEvent;\n+import org.openhab.core.items.events.ItemEventFactory;\n+import org.openhab.core.items.events.ItemStateEvent;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.TypeParser;\n+import org.openhab.core.types.UnDefType;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.ConfigurationPolicy;\n+import org.osgi.service.component.annotations.Modified;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Component which takes care of sending item state expiry events.\n+ *\n+ * @author Kai Kreuzer - Initial contribution\n+ * @author Michael Wyraz - Author of the 1.x expire binding, which this class is based on\n+ */\n+@NonNullByDefault\n+@Component(immediate = true, service = { ExpireManager.class,\n+        EventSubscriber.class }, configurationPid = \"org.openhab.expire\", configurationPolicy = ConfigurationPolicy.OPTIONAL)\n+public class ExpireManager implements EventSubscriber, RegistryChangeListener<Item> {\n+\n+    protected static final String EVENT_SOURCE = \"org.openhab.core.expire\";\n+    protected static final String METADATA_NAMESPACE = \"expire\";\n+    protected static final String PROPERTY_ENABLED = \"enabled\";\n+\n+    private static final Set<String> SUBSCRIBED_EVENT_TYPES = Set.of(ItemStateEvent.TYPE, ItemCommandEvent.TYPE);\n+\n+    private final Logger logger = LoggerFactory.getLogger(ExpireManager.class);\n+\n+    private Map<String, @Nullable Optional<ExpireConfig>> itemExpireConfig = new ConcurrentHashMap<>();\n+    private Map<String, Instant> itemExpireMap = new ConcurrentHashMap<>();\n+\n+    private ScheduledExecutorService threadPool = ThreadPoolManager\n+            .getScheduledPool(ThreadPoolManager.THREAD_POOL_NAME_COMMON);\n+\n+    private final EventPublisher eventPublisher;\n+    private final MetadataRegistry metadataRegistry;\n+    private final ItemRegistry itemRegistry;\n+    /* default */ final MetadataChangeListener metadataChangeListener = new MetadataChangeListener();\n+\n+    private boolean enabled = true;\n+\n+    private @Nullable ScheduledFuture<?> expireJob;\n+\n+    @Activate\n+    public ExpireManager(Map<String, @Nullable Object> configuration, final @Reference EventPublisher eventPublisher,\n+            final @Reference MetadataRegistry metadataRegistry, final @Reference ItemRegistry itemRegistry) {\n+        this.eventPublisher = eventPublisher;\n+        this.metadataRegistry = metadataRegistry;\n+        this.itemRegistry = itemRegistry;\n+\n+        modified(configuration);\n+    }\n+\n+    @Modified\n+    protected void modified(Map<String, @Nullable Object> configuration) {\n+        Object valueEnabled = configuration.get(PROPERTY_ENABLED);\n+        if (valueEnabled != null) {\n+            enabled = Boolean.parseBoolean(valueEnabled.toString());\n+        }\n+        if (enabled) {\n+            if (expireJob == null) {\n+                expireJob = threadPool.scheduleWithFixedDelay(() -> {\n+                    if (!itemExpireMap.isEmpty()) {\n+                        for (String itemName : itemExpireConfig.keySet()) {\n+                            if (isReadyToExpire(itemName)) {\n+                                expire(itemName);\n+                            }\n+                        }\n+                    }\n+                }, 1, 1, TimeUnit.SECONDS);\n+            }\n+            itemRegistry.addRegistryChangeListener(this);\n+            metadataRegistry.addRegistryChangeListener(metadataChangeListener);\n+        } else {\n+            itemRegistry.removeRegistryChangeListener(this);\n+            metadataRegistry.removeRegistryChangeListener(metadataChangeListener);\n+            if (expireJob != null) {\n+                expireJob.cancel(true);\n+                expireJob = null;\n+            }\n+        }\n+    }\n+\n+    public void receiveCommand(ItemCommandEvent commandEvent) {", "originalCommit": "0570b8407ef159e4747ebbe03f2b65e450a2527d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "eb88b0e2f5746b2081046cbccd194157125ed4c6", "url": "https://github.com/openhab/openhab-core/commit/eb88b0e2f5746b2081046cbccd194157125ed4c6", "message": "addressed review comments\n\nSigned-off-by: Kai Kreuzer <kai@openhab.org>", "committedDate": "2020-11-17T20:33:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA4MjUwMQ==", "url": "https://github.com/openhab/openhab-core/pull/1803#discussion_r527082501", "bodyText": "Hm, ... I immediately ran into an NPE. I did not yet figure why.\njava.lang.NullPointerException: null\n\tat java.util.Objects.requireNonNull(Unknown Source) ~[?:?]\n\tat org.openhab.core.items.ItemUtil.getMainItemType(ItemUtil.java:91) ~[?:?]\n\tat org.openhab.core.model.item.internal.GenericItemProvider.dispatchBindingsPerItemType(GenericItemProvider.java:303) ~[?:?]\n\tat org.openhab.core.model.item.internal.GenericItemProvider.addItemFactory(GenericItemProvider.java:134) ~[?:?]\n\tat jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:?]\n\tat jdk.internal.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) ~[?:?]\n\tat jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) ~[?:?]\n\tat java.lang.reflect.Method.invoke(Unknown Source) ~[?:?]\n\tat org.apache.felix.scr.impl.inject.methods.BaseMethod.invokeMethod(BaseMethod.java:228) ~[bundleFile:?]\n\tat org.apache.felix.scr.impl.inject.methods.BaseMethod.access$500(BaseMethod.java:41) ~[bundleFile:?]\n\tat org.apache.felix.scr.impl.inject.methods.BaseMethod$Resolved.invoke(BaseMethod.java:664) ~[bundleFile:?]\n\tat org.apache.felix.scr.impl.inject.methods.BaseMethod.invoke(BaseMethod.java:510) [bundleFile:?]\n\tat org.apache.felix.scr.impl.inject.methods.BindMethod.invoke(BindMethod.java:42) [bundleFile:?]\n\tat org.apache.felix.scr.impl.manager.DependencyManager.doInvokeBindMethod(DependencyManager.java:1813) [bundleFile:?]\n\tat org.apache.felix.scr.impl.manager.DependencyManager.bindDependency(DependencyManager.java:1637) [bundleFile:?]\n\tat org.apache.felix.scr.impl.manager.DependencyManager.bind(DependencyManager.java:1624) [bundleFile:?]\n\tat org.apache.felix.scr.impl.manager.SingleComponentManager.createImplementationObject(SingleComponentManager.java:307) [bundleFile:?]\n\tat org.apache.felix.scr.impl.manager.SingleComponentManager.createComponent(SingleComponentManager.java:114) [bundleFile:?]\n\tat org.apache.felix.scr.impl.manager.SingleComponentManager.getService(SingleComponentManager.java:982) [bundleFile:?]\n\tat org.apache.felix.scr.impl.manager.SingleComponentManager.getServiceInternal(SingleComponentManager.java:955) [bundleFile:?]\n\tat org.apache.felix.scr.impl.manager.SingleComponentManager.getService(SingleComponentManager.java:900) [bundleFile:?]\n\tat org.eclipse.osgi.internal.serviceregistry.ServiceFactoryUse$1.run(ServiceFactoryUse.java:212) [org.eclipse.osgi-3.12.100.jar:?]\n\tat java.security.AccessController.doPrivileged(Native Method) [?:?]\n\tat org.eclipse.osgi.internal.serviceregistry.ServiceFactoryUse.factoryGetService(ServiceFactoryUse.java:210) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.eclipse.osgi.internal.serviceregistry.ServiceFactoryUse.getService(ServiceFactoryUse.java:111) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.eclipse.osgi.internal.serviceregistry.ServiceConsumer$2.getService(ServiceConsumer.java:45) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.eclipse.osgi.internal.serviceregistry.ServiceRegistrationImpl.getService(ServiceRegistrationImpl.java:508) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.eclipse.osgi.internal.serviceregistry.ServiceRegistry.getService(ServiceRegistry.java:461) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.eclipse.osgi.internal.framework.BundleContextImpl.getService(BundleContextImpl.java:624) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.openhab.core.common.registry.AbstractRegistry$ProviderTracker.addingService(AbstractRegistry.java:145) [bundleFile:?]\n\tat org.openhab.core.common.registry.AbstractRegistry$ProviderTracker.addingService(AbstractRegistry.java:1) [bundleFile:?]\n\tat org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:941) [osgi.core-6.0.0.jar:?]\n\tat org.osgi.util.tracker.ServiceTracker$Tracked.customizerAdding(ServiceTracker.java:870) [osgi.core-6.0.0.jar:?]\n\tat org.osgi.util.tracker.AbstractTracked.trackAdding(AbstractTracked.java:256) [osgi.core-6.0.0.jar:?]\n\tat org.osgi.util.tracker.AbstractTracked.track(AbstractTracked.java:229) [osgi.core-6.0.0.jar:?]\n\tat org.osgi.util.tracker.ServiceTracker$Tracked.serviceChanged(ServiceTracker.java:901) [osgi.core-6.0.0.jar:?]\n\tat org.eclipse.osgi.internal.serviceregistry.FilteredServiceListener.serviceChanged(FilteredServiceListener.java:109) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.eclipse.osgi.internal.framework.BundleContextImpl.dispatchEvent(BundleContextImpl.java:920) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.eclipse.osgi.internal.serviceregistry.ServiceRegistry.publishServiceEventPrivileged(ServiceRegistry.java:862) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.eclipse.osgi.internal.serviceregistry.ServiceRegistry.publishServiceEvent(ServiceRegistry.java:801) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.eclipse.osgi.internal.serviceregistry.ServiceRegistrationImpl.register(ServiceRegistrationImpl.java:127) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.eclipse.osgi.internal.serviceregistry.ServiceRegistry.registerService(ServiceRegistry.java:225) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.eclipse.osgi.internal.framework.BundleContextImpl.registerService(BundleContextImpl.java:469) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.apache.felix.scr.impl.manager.AbstractComponentManager$3.register(AbstractComponentManager.java:906) [bundleFile:?]\n\tat org.apache.felix.scr.impl.manager.AbstractComponentManager$3.register(AbstractComponentManager.java:892) [bundleFile:?]\n\tat org.apache.felix.scr.impl.manager.RegistrationManager.changeRegistration(RegistrationManager.java:128) [bundleFile:?]\n\tat org.apache.felix.scr.impl.manager.AbstractComponentManager.registerService(AbstractComponentManager.java:959) [bundleFile:?]\n\tat org.apache.felix.scr.impl.manager.AbstractComponentManager.activateInternal(AbstractComponentManager.java:732) [bundleFile:?]\n\tat org.apache.felix.scr.impl.manager.DependencyManager$MultipleDynamicCustomizer.addedService(DependencyManager.java:338) [bundleFile:?]\n\tat org.apache.felix.scr.impl.manager.DependencyManager$MultipleDynamicCustomizer.addedService(DependencyManager.java:294) [bundleFile:?]\n\tat org.apache.felix.scr.impl.manager.ServiceTracker$Tracked.customizerAdded(ServiceTracker.java:1216) [bundleFile:?]\n\tat org.apache.felix.scr.impl.manager.ServiceTracker$Tracked.customizerAdded(ServiceTracker.java:1137) [bundleFile:?]\n\tat org.apache.felix.scr.impl.manager.ServiceTracker$AbstractTracked.trackAdding(ServiceTracker.java:944) [bundleFile:?]\n\tat org.apache.felix.scr.impl.manager.ServiceTracker$AbstractTracked.track(ServiceTracker.java:880) [bundleFile:?]\n\tat org.apache.felix.scr.impl.manager.ServiceTracker$Tracked.serviceChanged(ServiceTracker.java:1168) [bundleFile:?]\n\tat org.apache.felix.scr.impl.BundleComponentActivator$ListenerInfo.serviceChanged(BundleComponentActivator.java:125) [bundleFile:?]\n\tat org.eclipse.osgi.internal.serviceregistry.FilteredServiceListener.serviceChanged(FilteredServiceListener.java:109) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.eclipse.osgi.internal.framework.BundleContextImpl.dispatchEvent(BundleContextImpl.java:920) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.eclipse.osgi.internal.serviceregistry.ServiceRegistry.publishServiceEventPrivileged(ServiceRegistry.java:862) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.eclipse.osgi.internal.serviceregistry.ServiceRegistry.publishServiceEvent(ServiceRegistry.java:801) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.eclipse.osgi.internal.serviceregistry.ServiceRegistrationImpl.register(ServiceRegistrationImpl.java:127) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.eclipse.osgi.internal.serviceregistry.ServiceRegistry.registerService(ServiceRegistry.java:225) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.eclipse.osgi.internal.framework.BundleContextImpl.registerService(BundleContextImpl.java:469) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.apache.felix.scr.impl.manager.AbstractComponentManager$3.register(AbstractComponentManager.java:906) [bundleFile:?]\n\tat org.apache.felix.scr.impl.manager.AbstractComponentManager$3.register(AbstractComponentManager.java:892) [bundleFile:?]\n\tat org.apache.felix.scr.impl.manager.RegistrationManager.changeRegistration(RegistrationManager.java:128) [bundleFile:?]\n\tat org.apache.felix.scr.impl.manager.AbstractComponentManager.registerService(AbstractComponentManager.java:959) [bundleFile:?]\n\tat org.apache.felix.scr.impl.manager.AbstractComponentManager.activateInternal(AbstractComponentManager.java:732) [bundleFile:?]\n\tat org.apache.felix.scr.impl.manager.AbstractComponentManager.enableInternal(AbstractComponentManager.java:666) [bundleFile:?]\n\tat org.apache.felix.scr.impl.manager.AbstractComponentManager.enable(AbstractComponentManager.java:432) [bundleFile:?]\n\tat org.apache.felix.scr.impl.manager.ConfigurableComponentHolder.enableComponents(ConfigurableComponentHolder.java:665) [bundleFile:?]\n\tat org.apache.felix.scr.impl.BundleComponentActivator.initialEnable(BundleComponentActivator.java:338) [bundleFile:?]\n\tat org.apache.felix.scr.impl.Activator.loadComponents(Activator.java:382) [bundleFile:?]\n\tat org.apache.felix.scr.impl.Activator.access$200(Activator.java:49) [bundleFile:?]\n\tat org.apache.felix.scr.impl.Activator$ScrExtension.start(Activator.java:264) [bundleFile:?]\n\tat org.apache.felix.scr.impl.AbstractExtender.createExtension(AbstractExtender.java:196) [bundleFile:?]\n\tat org.apache.felix.scr.impl.AbstractExtender.modifiedBundle(AbstractExtender.java:169) [bundleFile:?]\n\tat org.apache.felix.scr.impl.AbstractExtender.modifiedBundle(AbstractExtender.java:49) [bundleFile:?]\n\tat org.osgi.util.tracker.BundleTracker$Tracked.customizerModified(BundleTracker.java:482) [osgi.core-6.0.0.jar:?]\n\tat org.osgi.util.tracker.BundleTracker$Tracked.customizerModified(BundleTracker.java:415) [osgi.core-6.0.0.jar:?]\n\tat org.osgi.util.tracker.AbstractTracked.track(AbstractTracked.java:232) [osgi.core-6.0.0.jar:?]\n\tat org.osgi.util.tracker.BundleTracker$Tracked.bundleChanged(BundleTracker.java:444) [osgi.core-6.0.0.jar:?]\n\tat org.eclipse.osgi.internal.framework.BundleContextImpl.dispatchEvent(BundleContextImpl.java:908) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:230) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:148) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.eclipse.osgi.internal.framework.EquinoxEventPublisher.publishBundleEventPrivileged(EquinoxEventPublisher.java:213) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.eclipse.osgi.internal.framework.EquinoxEventPublisher.publishBundleEvent(EquinoxEventPublisher.java:120) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.eclipse.osgi.internal.framework.EquinoxEventPublisher.publishBundleEvent(EquinoxEventPublisher.java:112) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor.publishModuleEvent(EquinoxContainerAdaptor.java:168) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.eclipse.osgi.container.Module.publishEvent(Module.java:476) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.eclipse.osgi.container.Module.start(Module.java:467) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.eclipse.osgi.internal.framework.EquinoxBundle.start(EquinoxBundle.java:383) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.eclipse.osgi.internal.framework.EquinoxBundle.start(EquinoxBundle.java:402) [org.eclipse.osgi-3.12.100.jar:?]\n\tat org.apache.karaf.features.internal.service.BundleInstallSupportImpl.startBundle(BundleInstallSupportImpl.java:165) [bundleFile:?]\n\tat org.apache.karaf.features.internal.service.FeaturesServiceImpl.startBundle(FeaturesServiceImpl.java:1153) [bundleFile:?]\n\tat org.apache.karaf.features.internal.service.Deployer.deploy(Deployer.java:1036) [bundleFile:?]\n\tat org.apache.karaf.features.internal.service.FeaturesServiceImpl.doProvision(FeaturesServiceImpl.java:1062) [bundleFile:?]\n\tat org.apache.karaf.features.internal.service.FeaturesServiceImpl.lambda$doProvisionInThread$13(FeaturesServiceImpl.java:998) [bundleFile:?]\n\tat java.util.concurrent.FutureTask.run(Unknown Source) [?:?]\n\tat java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source) [?:?]\n\tat java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source) [?:?]\n\tat java.lang.Thread.run(Unknown Source) [?:?]", "author": "cweitkamp", "createdAt": "2020-11-19T17:50:02Z", "path": "bundles/org.openhab.core.model.item/src/org/openhab/core/model/item/internal/GenericItemProvider.java", "diffHunk": "@@ -299,7 +300,7 @@ private void dispatchBindingsPerItemType(@Nullable BindingConfigReader reader, S\n             if (model != null) {\n                 for (ModelItem modelItem : model.getItems()) {\n                     for (String itemType : itemTypes) {\n-                        if (itemType.equals(modelItem.getType())) {\n+                        if (itemType.equals(ItemUtil.getMainItemType(modelItem.getType()))) {", "originalCommit": "eb88b0e2f5746b2081046cbccd194157125ed4c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEwMTQ2MA==", "url": "https://github.com/openhab/openhab-core/pull/1803#discussion_r527101460", "bodyText": "That's weird indeed. I have already upgraded my system and didn't have any such issues.\nCan you run in debug mode and remotely connect to see what this modelItem without a type is?", "author": "kaikreuzer", "createdAt": "2020-11-19T18:19:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA4MjUwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEwMzgxMA==", "url": "https://github.com/openhab/openhab-core/pull/1803#discussion_r527103810", "bodyText": "In any case, I have created #1839, which should solve the issue.", "author": "kaikreuzer", "createdAt": "2020-11-19T18:23:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA4MjUwMQ=="}], "type": "inlineReview"}]}