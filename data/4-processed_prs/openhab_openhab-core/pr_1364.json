{"pr_number": 1364, "pr_title": "Simple dynamic item state updates SSE endpoint & API.", "pr_createdAt": "2020-02-12T16:10:53Z", "pr_url": "https://github.com/openhab/openhab-core/pull/1364", "timeline": [{"oid": "e619fcaa2cbe5eb2b31a613fd1f0c0fdb446bb85", "url": "https://github.com/openhab/openhab-core/commit/e619fcaa2cbe5eb2b31a613fd1f0c0fdb446bb85", "message": "Consider transformation\n\nSigned-off-by: Yannick Schaus <github@schaus.net>", "committedDate": "2020-02-12T17:10:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg2MTMxNw==", "url": "https://github.com/openhab/openhab-core/pull/1364#discussion_r379861317", "bodyText": "As mentioned in the issue, I am pretty sure that you will additionally require the raw state as well in the UI, e.g. for being able to request the correct item for the state, apply ui-based logic on visibility or colors, etc. So the current item->state map might be too simplistic after all.\nAlso, we might add further metadata to the ItemStateChangedEvent in future, such as the reason why it changed (manual command, rule triggered, or whatever). Serializing the whole content of ItemStateChangedEvent would somehow feel more future-proof, wdyt?", "author": "kaikreuzer", "createdAt": "2020-02-15T22:56:15Z", "path": "bundles/org.openhab.core.io.rest.sse/src/main/java/org/openhab/core/io/rest/sse/SseStatesResource.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.rest.sse;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import javax.annotation.security.RolesAllowed;\n+import javax.inject.Singleton;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+import javax.ws.rs.core.UriInfo;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.glassfish.jersey.media.sse.EventOutput;\n+import org.glassfish.jersey.media.sse.OutboundEvent;\n+import org.glassfish.jersey.media.sse.SseFeature;\n+import org.openhab.core.auth.Role;\n+import org.openhab.core.io.rest.sse.internal.ItemStateChangesSseBroadcaster;\n+import org.openhab.core.io.rest.sse.internal.SseActivator;\n+import org.openhab.core.io.rest.sse.internal.SseStateEventOutput;\n+import org.openhab.core.items.Item;\n+import org.openhab.core.items.ItemRegistry;\n+import org.openhab.core.items.events.ItemStateChangedEvent;\n+import org.openhab.core.transform.TransformationException;\n+import org.openhab.core.transform.TransformationHelper;\n+import org.openhab.core.types.StateDescription;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+import io.swagger.annotations.ApiParam;\n+import io.swagger.annotations.ApiResponse;\n+import io.swagger.annotations.ApiResponses;\n+\n+/**\n+ * SSE Resource for pushing selected item state updates to clients.\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Component(service = SseStatesResource.class)\n+@Path(SseStatesResource.PATH_EVENTS)\n+@RolesAllowed({ Role.USER })\n+@Singleton\n+@Api(value = SseStatesResource.PATH_EVENTS, hidden = true)\n+public class SseStatesResource {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SseStatesResource.class);\n+\n+    public static final String PATH_EVENTS = \"events/states\";\n+\n+    private static final String X_ACCEL_BUFFERING_HEADER = \"X-Accel-Buffering\";\n+\n+    private final ItemStateChangesSseBroadcaster broadcaster;\n+\n+    private final ExecutorService executorService;\n+\n+    private ItemRegistry itemRegistry;\n+\n+    @Reference\n+    protected void setItemRegistry(ItemRegistry itemRegistry) {\n+        this.itemRegistry = itemRegistry;\n+    }\n+\n+    protected void unsetItemRegistry(ItemRegistry itemRegistry) {\n+        this.itemRegistry = itemRegistry;\n+    }\n+\n+    @Context\n+    private UriInfo uriInfo;\n+\n+    @Context\n+    private HttpServletResponse response;\n+\n+    @Context\n+    private HttpServletRequest request;\n+\n+    public SseStatesResource() {\n+        this.executorService = Executors.newSingleThreadExecutor();\n+        this.broadcaster = new ItemStateChangesSseBroadcaster(itemRegistry);\n+    }\n+\n+    /**\n+     * Subscribes the connecting client for state updates. It will initially only send a \"ready\" event with an unique\n+     * connectionId that the client can use to dynamically alter the list of tracked items.\n+     *\n+     * @return {@link EventOutput} object associated with the incoming\n+     *         connection.\n+     * @throws IOException\n+     * @throws InterruptedException\n+     */\n+    @GET\n+    @Produces(SseFeature.SERVER_SENT_EVENTS)\n+    @ApiOperation(value = \"Initiates a new item state tracker connection\", response = EventOutput.class)\n+    @ApiResponses(value = { @ApiResponse(code = 200, message = \"OK\") })\n+    public Object getStateEvents() throws IOException, InterruptedException {\n+\n+        final SseStateEventOutput eventOutput = new SseStateEventOutput();\n+        broadcaster.add(eventOutput);\n+\n+        // Disables proxy buffering when using an nginx http server proxy for this response.\n+        // This allows you to not disable proxy buffering in nginx and still have working sse\n+        response.addHeader(X_ACCEL_BUFFERING_HEADER, \"no\");\n+\n+        // We want to make sure that the response is not compressed and buffered so that the client receives server sent\n+        // events at the moment of sending them.\n+        response.addHeader(HttpHeaders.CONTENT_ENCODING, \"identity\");\n+\n+        return eventOutput;\n+    }\n+\n+    /**\n+     * Alters the list of tracked items for a given state update connection\n+     *\n+     * @param connectionId the connection Id to change\n+     * @param itemNames the list of items to track\n+     */\n+    @POST\n+    @Path(\"{connectionId}\")\n+    @ApiOperation(value = \"Changes the list of items a SSE connection will receive state updates to.\")\n+    @ApiResponses(value = { @ApiResponse(code = 200, message = \"OK\"),\n+            @ApiResponse(code = 404, message = \"Unknown connectionId\") })\n+    public Object updateTrackedItems(@PathParam(\"connectionId\") String connectionId,\n+            @ApiParam(\"items\") Collection<String> itemNames) {\n+\n+        // Send the current states of the new tracked items on the SSE connection\n+        Map<String, String> newTrackedItems = new HashMap<>();\n+        itemNames.stream().forEach(i -> {\n+            Item item = itemRegistry.get(i);\n+            if (item != null) {\n+                String transformedState = considerTransformation(item.getState().toString(), item, null);\n+                newTrackedItems.put(item.getName(), transformedState);\n+            }\n+        });\n+\n+        try {\n+            broadcaster.updateTrackedItems(connectionId, newTrackedItems);\n+        } catch (IllegalArgumentException e) {\n+            return Response.status(Status.NOT_FOUND).build();\n+        }\n+\n+        return Response.ok().build();\n+    }\n+\n+    /**\n+     * Broadcasts a state event to all currently listening clients, after transforming it to a simple map.\n+     *\n+     * @param stateChangeEvent the {@link ItemStateChangedEvent} containing the new state\n+     */\n+    public void broadcastEvent(final ItemStateChangedEvent stateChangeEvent) {\n+        executorService.execute(new Runnable() {\n+            @Override\n+            public void run() {\n+                OutboundEvent.Builder builder = new OutboundEvent.Builder();\n+                Map<String, String> payload = new HashMap<>();\n+                Item item = itemRegistry.get(stateChangeEvent.getItemName());\n+                if (item != null) {\n+                    String transformedState = considerTransformation(item.getState().toString(), item, null);\n+                    payload.put(item.getName(), transformedState);", "originalCommit": "e619fcaa2cbe5eb2b31a613fd1f0c0fdb446bb85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkwMDk0Ng==", "url": "https://github.com/openhab/openhab-core/pull/1364#discussion_r379900946", "bodyText": "I am pretty sure that you will additionally require the raw state as well in the UI\n\nTrue.\n\nSerializing the whole content of ItemStateChangedEvent would somehow feel more future-proof\n\nThe idea with this is not actually to expose events from the event bus, but only to make it as easy as possible for clients to keep track of the state of a predetermined set of items. So: 1) you open the SSE connection, 2) you send the list of items whose state you want to track, 3) you receive the current states of all your tracking list over the SSE connection, 4) you also receive any individual updates until you close the connection or change the tracking list.\nThe benefit with item-state maps is that for 3) and 4) the client-side code is pretty simple and actually the same in both cases: basically, just merge the map you received with the one you currently have. 3) is also useful because with this feature you might not even need to call /rest/items to initialize your client-side map if all you need are the current states. However, 3) doesn't correspond to any event on the event bus. That's why I wanted to abstract the event bus away from this API. Maybe the state could be an 2-element array or simple object ({\"state\": \"CLOSED\", \"transformedState\": \"zu\"}) in case there's a transformation involved.\nMoreover it was asked a few years ago (IIRC by me) over in ESH to include the transformed state in ItemStateChangedEvents but it wasn't accepted, because the transformation is possibly costly to compute (e.g. exec or JS) and blocking so it's not a good idea to do it on every change if it's not useful. Therefore, there's indeed a problem with this code here - it should first determine whether the item is being tracked or not.", "author": "ghys", "createdAt": "2020-02-16T12:50:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg2MTMxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkzNjU3OA==", "url": "https://github.com/openhab/openhab-core/pull/1364#discussion_r379936578", "bodyText": "If we'd drop transformation support and thus would only have patterns, which you can render on client side, we could merely pass the raw state in your item state map. Would that solve all our issues?", "author": "kaikreuzer", "createdAt": "2020-02-16T21:55:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg2MTMxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDYwNjMxMA==", "url": "https://github.com/openhab/openhab-core/pull/1364#discussion_r380606310", "bodyText": "If we'd drop transformation support and thus would only have patterns, which you can render on client side, we could merely pass the raw state in your item state map. Would that solve all our issues?\n\nTurns out, even formatting the state using a pattern is no trivial problem (dates, quantity types unit conversions...), and it requires the client to know about the state description, which might not be always the case... so I figured making the server do the heavy lifting was the best option after all, and introduced in 1d11fa4 a \"displayState\" in the map value.\nSo with items like this:\nDateTime DemoDateTime { stateDescription=\"N/A\" [ pattern=\"%1$tA, %1$td.%1$tm.%1$tY\" ] }\nNumber:Temperature DemoTemperature \"Info [%.5f %unit%]\"\nNumber DemoFormat \"Info [%.5f kWh]\"\nContact DemoOptions \"Options\" { stateDescription=\"N/A\" [ options=\"OPEN=unlocked,CLOSED=locked\" ] }\n\nIt gives (line breaks added for clarity):\ndata: {\n\"DemoFormat\":{\"state\":\"500\",\"displayState\":\"500.00000 kWh\"},\n\"DemoContact\":{\"state\":\"OPEN\"},\n\"DemoOptions\":{\"state\":\"CLOSED\",\"displayState\":\"locked\"},\n\"MetadataString\":{\"state\":\"1\",\"displayState\":\"HDMI1\"},\n\"DemoTemperature\":{\"state\":\"23.00 \u00b0F\",\"displayState\":\"-5.00000 \u00b0C\"},\n\"DemoDateTime\":{\"state\":\"2020-02-18T11:37:29.782672+0100\",\"displayState\":\"Tuesday, 18.02.2020\"}\n}\n\nSo the UI can happily use the displayState for display purposes if it exists (or fall back to the actual state) and also have the raw version at hand.", "author": "ghys", "createdAt": "2020-02-18T11:10:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg2MTMxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzNjA0Ng==", "url": "https://github.com/openhab/openhab-core/pull/1364#discussion_r383036046", "bodyText": "Sounds sensible then, thanks.", "author": "kaikreuzer", "createdAt": "2020-02-23T20:31:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTg2MTMxNw=="}], "type": "inlineReview"}, {"oid": "e806c8f340d4378bbda472354f5ae1113468316b", "url": "https://github.com/openhab/openhab-core/commit/e806c8f340d4378bbda472354f5ae1113468316b", "message": "Simple dynamic item state updates SSE endpoint & API.\n\nImplements #1363.\n\nSigned-off-by: Yannick Schaus <github@schaus.net>", "committedDate": "2020-02-18T10:24:14Z", "type": "commit"}, {"oid": "5f92f6d9b897b3c07339bd91f491934e2b38cf00", "url": "https://github.com/openhab/openhab-core/commit/5f92f6d9b897b3c07339bd91f491934e2b38cf00", "message": "Consider transformation\n\nSigned-off-by: Yannick Schaus <github@schaus.net>", "committedDate": "2020-02-18T10:24:14Z", "type": "commit"}, {"oid": "1d11fa4e8076410e9dde8e3eb3243b944c041d09", "url": "https://github.com/openhab/openhab-core/commit/1d11fa4e8076410e9dde8e3eb3243b944c041d09", "message": "Provide reliable displayStates using the state description\n\nSigned-off-by: Yannick Schaus <github@schaus.net>", "committedDate": "2020-02-18T10:58:29Z", "type": "commit"}, {"oid": "1d11fa4e8076410e9dde8e3eb3243b944c041d09", "url": "https://github.com/openhab/openhab-core/commit/1d11fa4e8076410e9dde8e3eb3243b944c041d09", "message": "Provide reliable displayStates using the state description\n\nSigned-off-by: Yannick Schaus <github@schaus.net>", "committedDate": "2020-02-18T10:58:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzNjA5Mw==", "url": "https://github.com/openhab/openhab-core/pull/1364#discussion_r383036093", "bodyText": "again, this annotation can be put on the field and the setter and getter removed.", "author": "kaikreuzer", "createdAt": "2020-02-23T20:32:35Z", "path": "bundles/org.openhab.core.io.rest.sse/src/main/java/org/openhab/core/io/rest/sse/SseStatesResource.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.rest.sse;\n+\n+import java.io.IOException;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import javax.annotation.security.RolesAllowed;\n+import javax.inject.Singleton;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+import javax.ws.rs.core.UriInfo;\n+\n+import org.glassfish.jersey.media.sse.EventOutput;\n+import org.glassfish.jersey.media.sse.OutboundEvent;\n+import org.glassfish.jersey.media.sse.SseFeature;\n+import org.openhab.core.auth.Role;\n+import org.openhab.core.io.rest.sse.internal.ItemStateChangesSseBroadcaster;\n+import org.openhab.core.io.rest.sse.internal.SseStateEventOutput;\n+import org.openhab.core.items.ItemRegistry;\n+import org.openhab.core.items.events.ItemStateChangedEvent;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+import io.swagger.annotations.ApiParam;\n+import io.swagger.annotations.ApiResponse;\n+import io.swagger.annotations.ApiResponses;\n+\n+/**\n+ * SSE Resource for pushing selected item state updates to clients.\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Component(service = SseStatesResource.class)\n+@Path(SseStatesResource.PATH_EVENTS)\n+@RolesAllowed({ Role.USER })\n+@Singleton\n+@Api(value = SseStatesResource.PATH_EVENTS, hidden = true)\n+public class SseStatesResource {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SseStatesResource.class);\n+\n+    public static final String PATH_EVENTS = \"events/states\";\n+\n+    private static final String X_ACCEL_BUFFERING_HEADER = \"X-Accel-Buffering\";\n+\n+    private final ItemStateChangesSseBroadcaster broadcaster;\n+\n+    private final ExecutorService executorService;\n+\n+    private ItemRegistry itemRegistry;\n+\n+    @Reference", "originalCommit": "1d11fa4e8076410e9dde8e3eb3243b944c041d09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzNjI1Mg==", "url": "https://github.com/openhab/openhab-core/pull/1364#discussion_r383036252", "bodyText": "How about using () -> {} syntax instead of the Runnable?", "author": "kaikreuzer", "createdAt": "2020-02-23T20:34:53Z", "path": "bundles/org.openhab.core.io.rest.sse/src/main/java/org/openhab/core/io/rest/sse/SseStatesResource.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.rest.sse;\n+\n+import java.io.IOException;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import javax.annotation.security.RolesAllowed;\n+import javax.inject.Singleton;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+import javax.ws.rs.core.UriInfo;\n+\n+import org.glassfish.jersey.media.sse.EventOutput;\n+import org.glassfish.jersey.media.sse.OutboundEvent;\n+import org.glassfish.jersey.media.sse.SseFeature;\n+import org.openhab.core.auth.Role;\n+import org.openhab.core.io.rest.sse.internal.ItemStateChangesSseBroadcaster;\n+import org.openhab.core.io.rest.sse.internal.SseStateEventOutput;\n+import org.openhab.core.items.ItemRegistry;\n+import org.openhab.core.items.events.ItemStateChangedEvent;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+import io.swagger.annotations.ApiParam;\n+import io.swagger.annotations.ApiResponse;\n+import io.swagger.annotations.ApiResponses;\n+\n+/**\n+ * SSE Resource for pushing selected item state updates to clients.\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Component(service = SseStatesResource.class)\n+@Path(SseStatesResource.PATH_EVENTS)\n+@RolesAllowed({ Role.USER })\n+@Singleton\n+@Api(value = SseStatesResource.PATH_EVENTS, hidden = true)\n+public class SseStatesResource {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SseStatesResource.class);\n+\n+    public static final String PATH_EVENTS = \"events/states\";\n+\n+    private static final String X_ACCEL_BUFFERING_HEADER = \"X-Accel-Buffering\";\n+\n+    private final ItemStateChangesSseBroadcaster broadcaster;\n+\n+    private final ExecutorService executorService;\n+\n+    private ItemRegistry itemRegistry;\n+\n+    @Reference\n+    protected void setItemRegistry(ItemRegistry itemRegistry) {\n+        this.itemRegistry = itemRegistry;\n+        this.broadcaster.setItemRegistry(itemRegistry);\n+    }\n+\n+    protected void unsetItemRegistry(ItemRegistry itemRegistry) {\n+        this.itemRegistry = itemRegistry;\n+    }\n+\n+    @Context\n+    private UriInfo uriInfo;\n+\n+    @Context\n+    private HttpServletResponse response;\n+\n+    @Context\n+    private HttpServletRequest request;\n+\n+    public SseStatesResource() {\n+        this.executorService = Executors.newSingleThreadExecutor();\n+        this.broadcaster = new ItemStateChangesSseBroadcaster();\n+    }\n+\n+    /**\n+     * Subscribes the connecting client for state updates. It will initially only send a \"ready\" event with an unique\n+     * connectionId that the client can use to dynamically alter the list of tracked items.\n+     *\n+     * @return {@link EventOutput} object associated with the incoming\n+     *         connection.\n+     * @throws IOException\n+     * @throws InterruptedException\n+     */\n+    @GET\n+    @Produces(SseFeature.SERVER_SENT_EVENTS)\n+    @ApiOperation(value = \"Initiates a new item state tracker connection\", response = EventOutput.class)\n+    @ApiResponses(value = { @ApiResponse(code = 200, message = \"OK\") })\n+    public Object getStateEvents() throws IOException, InterruptedException {\n+\n+        final SseStateEventOutput eventOutput = new SseStateEventOutput();\n+        broadcaster.add(eventOutput);\n+\n+        // Disables proxy buffering when using an nginx http server proxy for this response.\n+        // This allows you to not disable proxy buffering in nginx and still have working sse\n+        response.addHeader(X_ACCEL_BUFFERING_HEADER, \"no\");\n+\n+        // We want to make sure that the response is not compressed and buffered so that the client receives server sent\n+        // events at the moment of sending them.\n+        response.addHeader(HttpHeaders.CONTENT_ENCODING, \"identity\");\n+\n+        return eventOutput;\n+    }\n+\n+    /**\n+     * Alters the list of tracked items for a given state update connection\n+     *\n+     * @param connectionId the connection Id to change\n+     * @param itemNames the list of items to track\n+     */\n+    @POST\n+    @Path(\"{connectionId}\")\n+    @ApiOperation(value = \"Changes the list of items a SSE connection will receive state updates to.\")\n+    @ApiResponses(value = { @ApiResponse(code = 200, message = \"OK\"),\n+            @ApiResponse(code = 404, message = \"Unknown connectionId\") })\n+    public Object updateTrackedItems(@PathParam(\"connectionId\") String connectionId,\n+            @ApiParam(\"items\") Set<String> itemNames) {\n+\n+        try {\n+            broadcaster.updateTrackedItems(connectionId, itemNames);\n+        } catch (IllegalArgumentException e) {\n+            return Response.status(Status.NOT_FOUND).build();\n+        }\n+\n+        return Response.ok().build();\n+    }\n+\n+    /**\n+     * Broadcasts a state event to all currently listening clients, after transforming it to a simple map.\n+     *\n+     * @param stateChangeEvent the {@link ItemStateChangedEvent} containing the new state\n+     */\n+    public void broadcastEvent(final ItemStateChangedEvent stateChangeEvent) {\n+        executorService.execute(new Runnable() {", "originalCommit": "1d11fa4e8076410e9dde8e3eb3243b944c041d09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI3MjM5Nw==", "url": "https://github.com/openhab/openhab-core/pull/1364#discussion_r383272397", "bodyText": "Same comment as above\n\n  \n    \n      openhab-core/bundles/org.openhab.core.io.rest.sse/src/main/java/org/openhab/core/io/rest/sse/SseResource.java\n    \n    \n        Lines 126 to 129\n      in\n      730a8e1\n    \n    \n    \n    \n\n        \n          \n                */ \n        \n\n        \n          \n               public void broadcastEvent(final Event event) { \n        \n\n        \n          \n                   executorService.execute(new Runnable() { \n        \n\n        \n          \n                       @Override", "author": "ghys", "createdAt": "2020-02-24T13:45:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzNjI1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzNjQyMA==", "url": "https://github.com/openhab/openhab-core/pull/1364#discussion_r383036420", "bodyText": "remove empty line", "author": "kaikreuzer", "createdAt": "2020-02-23T20:36:57Z", "path": "bundles/org.openhab.core.io.rest.sse/src/main/java/org/openhab/core/io/rest/sse/internal/ItemStateChangesSseBroadcaster.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.rest.sse.internal;\n+\n+import java.io.IOException;\n+import java.time.DateTimeException;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.measure.Unit;\n+import javax.ws.rs.core.MediaType;\n+\n+import org.glassfish.jersey.media.sse.OutboundEvent;\n+import org.glassfish.jersey.media.sse.SseBroadcaster;\n+import org.glassfish.jersey.server.ChunkedOutput;\n+import org.openhab.core.items.Item;\n+import org.openhab.core.items.ItemNotFoundException;\n+import org.openhab.core.items.ItemRegistry;\n+import org.openhab.core.library.types.DateTimeType;\n+import org.openhab.core.library.types.QuantityType;\n+import org.openhab.core.transform.TransformationException;\n+import org.openhab.core.transform.TransformationHelper;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.StateDescription;\n+import org.openhab.core.types.StateOption;\n+import org.openhab.core.types.UnDefType;\n+import org.openhab.core.types.util.UnitUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This {@link SseBroadcaster} keeps track of the {@link SseStateEventOutput} listeners to state changes and tracks them\n+ * by their connectionId.\n+ *\n+ * @author Yannick Schaus - initial contribution\n+ */\n+public class ItemStateChangesSseBroadcaster extends SseBroadcaster {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ItemStateChangesSseBroadcaster.class);\n+\n+    private Map<String, SseStateEventOutput> eventOutputs = new HashMap<>();\n+\n+    private ItemRegistry itemRegistry;\n+\n+    public ItemStateChangesSseBroadcaster() {\n+        super();\n+    }\n+\n+    @Override\n+    public <OUT extends ChunkedOutput<OutboundEvent>> boolean add(OUT chunkedOutput) {\n+        if (chunkedOutput instanceof SseStateEventOutput) {\n+            SseStateEventOutput eventOutput = (SseStateEventOutput) chunkedOutput;\n+            OutboundEvent.Builder builder = new OutboundEvent.Builder();\n+            String connectionId = eventOutput.getConnectionId();\n+            try {\n+                eventOutputs.put(connectionId, eventOutput);\n+                eventOutput.writeDirect(builder.id(\"0\").name(\"ready\").data(connectionId).build());\n+            } catch (IOException e) {\n+                logger.error(\"Cannot write initial ready event to {}, discarding connection\", connectionId);\n+                return false;\n+            }\n+        }\n+\n+        return super.add(chunkedOutput);\n+    }\n+\n+    @Override\n+    public <OUT extends ChunkedOutput<OutboundEvent>> boolean remove(OUT chunkedOutput) {\n+        eventOutputs.values().remove(chunkedOutput);\n+        return super.remove(chunkedOutput);\n+    }\n+\n+    @Override\n+    public void onClose(ChunkedOutput<OutboundEvent> chunkedOutput) {\n+        remove(chunkedOutput);\n+    }\n+\n+    @Override\n+    public void onException(ChunkedOutput<OutboundEvent> chunkedOutput, Exception exception) {\n+        remove(chunkedOutput);\n+    }\n+\n+    /**\n+     * Updates the list of tracked items for a connection\n+     *\n+     * @param connectionId the connection id\n+     * @param newTrackedItems the list of items and their current state to send to the client\n+     */\n+    public void updateTrackedItems(String connectionId, Set<String> newTrackedItems) {\n+        SseStateEventOutput eventOutput = eventOutputs.get(connectionId);\n+\n+        if (eventOutput == null) {\n+            throw new IllegalArgumentException(\"ConnectionId not found\");\n+        }\n+\n+        eventOutput.setTrackedItems(newTrackedItems);\n+\n+        try {\n+            if (!eventOutput.isClosed()) {\n+                OutboundEvent event = buildStateEvent(newTrackedItems);\n+                if (event != null) {\n+                    eventOutput.writeDirect(event);\n+                }\n+            }\n+            if (eventOutput.isClosed()) {\n+                onClose(eventOutput);\n+            }\n+        } catch (IOException e) {\n+            onException(eventOutput, e);\n+        }\n+    }\n+\n+    public OutboundEvent buildStateEvent(Set<String> itemNames) {\n+        Map<String, StateDTO> payload = new HashMap<>();\n+        for (String itemName : itemNames) {\n+            try {\n+                // Check that the item is tracked by at least one connection\n+                if (itemRegistry != null\n+                        && eventOutputs.values().stream().anyMatch(c -> c.getTrackedItems().contains(itemName))) {\n+                    Item item = itemRegistry.getItem(itemName);\n+                    StateDTO stateDto = new StateDTO();\n+                    stateDto.state = item.getState().toString();\n+                    String displayState = getDisplayState(item, Locale.getDefault());\n+                    // Only include the display state if it's different than the raw state\n+                    if (stateDto.state != null && !stateDto.state.equals(displayState)) {\n+                        stateDto.displayState = displayState;\n+                    }\n+                    payload.put(itemName, stateDto);\n+                }\n+            } catch (ItemNotFoundException e) {\n+                logger.warn(\"Attempting to send a state update of an item which doesn't exist: {}\", itemName);\n+            }\n+        }\n+\n+        if (!payload.isEmpty()) {\n+            OutboundEvent.Builder builder = new OutboundEvent.Builder();\n+            OutboundEvent event = builder.mediaType(MediaType.APPLICATION_JSON_TYPE).data(payload).build();\n+            return event;\n+        }\n+\n+        return null;\n+    }\n+\n+    protected String getDisplayState(Item item, Locale locale) {\n+        StateDescription stateDescription = item.getStateDescription(locale);\n+        State state = item.getState();\n+        String displayState = state.toString();\n+\n+        if (!(state instanceof UnDefType)) {\n+            if (stateDescription != null) {\n+                if (!stateDescription.getOptions().isEmpty()) {\n+                    // Look for a state option with a label corresponding to the state\n+                    for (StateOption option : stateDescription.getOptions()) {\n+                        if (option.getValue().equals(state.toString()) && option.getLabel() != null) {\n+                            displayState = option.getLabel();\n+                            break;\n+                        }\n+                    }\n+                } else {\n+                    // If there's a pattern, first check if it's a transformation\n+                    String pattern = stateDescription.getPattern();\n+                    if (pattern != null) {\n+                        if (TransformationHelper.isTransform(pattern)) {\n+                            try {\n+                                displayState = TransformationHelper.transform(SseActivator.getContext(), pattern,\n+                                        state.toString());\n+                            } catch (NoClassDefFoundError ex) {\n+                                // TransformationHelper is optional dependency, so ignore if class not found\n+                                // return state as it is without transformation\n+                            } catch (TransformationException e) {\n+                                logger.warn(\"Failed transforming the state '{}' on item '{}' with pattern '{}': {}\",\n+                                        state, item.getName(), pattern, e.getMessage());\n+                            }\n+                        } else {\n+                            // if it's not a transformation pattern, then it must be a format string\n+\n+                            if (state instanceof QuantityType) {\n+                                QuantityType<?> quantityState = (QuantityType<?>) state;\n+                                // sanity convert current state to the item state description unit in case it was\n+                                // updated in the meantime. The item state is still in the \"original\" unit while the\n+                                // state description will display the new unit:\n+                                Unit<?> patternUnit = UnitUtils.parseUnit(pattern);\n+                                if (patternUnit != null && !quantityState.getUnit().equals(patternUnit)) {\n+                                    quantityState = quantityState.toUnit(patternUnit);\n+                                }\n+\n+                                if (quantityState != null) {\n+                                    state = quantityState;\n+                                }\n+                            } else if (state instanceof DateTimeType) {\n+                                // Translate a DateTimeType state to the local time zone\n+                                try {\n+                                    state = ((DateTimeType) state).toLocaleZone();\n+                                } catch (DateTimeException e) {\n+                                }\n+                            }\n+\n+                            // The following exception handling has been added to work around a Java bug with formatting\n+                            // numbers. See http://bugs.sun.com/view_bug.do?bug_id=6476425\n+                            // This also handles IllegalFormatConversionException, which is a subclass of\n+                            // IllegalArgument.\n+                            try {\n+                                displayState = state.format(pattern);\n+                            } catch (IllegalArgumentException e) {\n+                                logger.warn(\"Exception while formatting value '{}' of item {} with format '{}': {}\",\n+                                        state, item.getName(), pattern, e.getMessage());\n+                                displayState = new String(\"Err\");\n+                            }\n+", "originalCommit": "1d11fa4e8076410e9dde8e3eb3243b944c041d09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzNjYzNA==", "url": "https://github.com/openhab/openhab-core/pull/1364#discussion_r383036634", "bodyText": "for symmetry reasons it would be good to unset the item registry in the broadcaster here as well.", "author": "kaikreuzer", "createdAt": "2020-02-23T20:39:40Z", "path": "bundles/org.openhab.core.io.rest.sse/src/main/java/org/openhab/core/io/rest/sse/SseStatesResource.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.rest.sse;\n+\n+import java.io.IOException;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import javax.annotation.security.RolesAllowed;\n+import javax.inject.Singleton;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+import javax.ws.rs.core.UriInfo;\n+\n+import org.glassfish.jersey.media.sse.EventOutput;\n+import org.glassfish.jersey.media.sse.OutboundEvent;\n+import org.glassfish.jersey.media.sse.SseFeature;\n+import org.openhab.core.auth.Role;\n+import org.openhab.core.io.rest.sse.internal.ItemStateChangesSseBroadcaster;\n+import org.openhab.core.io.rest.sse.internal.SseStateEventOutput;\n+import org.openhab.core.items.ItemRegistry;\n+import org.openhab.core.items.events.ItemStateChangedEvent;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+import io.swagger.annotations.ApiParam;\n+import io.swagger.annotations.ApiResponse;\n+import io.swagger.annotations.ApiResponses;\n+\n+/**\n+ * SSE Resource for pushing selected item state updates to clients.\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Component(service = SseStatesResource.class)\n+@Path(SseStatesResource.PATH_EVENTS)\n+@RolesAllowed({ Role.USER })\n+@Singleton\n+@Api(value = SseStatesResource.PATH_EVENTS, hidden = true)\n+public class SseStatesResource {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SseStatesResource.class);\n+\n+    public static final String PATH_EVENTS = \"events/states\";\n+\n+    private static final String X_ACCEL_BUFFERING_HEADER = \"X-Accel-Buffering\";\n+\n+    private final ItemStateChangesSseBroadcaster broadcaster;\n+\n+    private final ExecutorService executorService;\n+\n+    private ItemRegistry itemRegistry;\n+\n+    @Reference\n+    protected void setItemRegistry(ItemRegistry itemRegistry) {\n+        this.itemRegistry = itemRegistry;\n+        this.broadcaster.setItemRegistry(itemRegistry);\n+    }\n+\n+    protected void unsetItemRegistry(ItemRegistry itemRegistry) {\n+        this.itemRegistry = itemRegistry;", "originalCommit": "1d11fa4e8076410e9dde8e3eb3243b944c041d09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzNzAzNA==", "url": "https://github.com/openhab/openhab-core/pull/1364#discussion_r383037034", "bodyText": "Better to have named threads, so that we can identify them when debugging:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.executorService = Executors.newSingleThreadExecutor();\n          \n          \n            \n                    this.executorService = Executors.newSingleThreadExecutor(new NamedThreadFactory(\"SseStatesResource\"));", "author": "kaikreuzer", "createdAt": "2020-02-23T20:45:40Z", "path": "bundles/org.openhab.core.io.rest.sse/src/main/java/org/openhab/core/io/rest/sse/SseStatesResource.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.core.io.rest.sse;\n+\n+import java.io.IOException;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+import javax.annotation.security.RolesAllowed;\n+import javax.inject.Singleton;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+import javax.ws.rs.core.UriInfo;\n+\n+import org.glassfish.jersey.media.sse.EventOutput;\n+import org.glassfish.jersey.media.sse.OutboundEvent;\n+import org.glassfish.jersey.media.sse.SseFeature;\n+import org.openhab.core.auth.Role;\n+import org.openhab.core.io.rest.sse.internal.ItemStateChangesSseBroadcaster;\n+import org.openhab.core.io.rest.sse.internal.SseStateEventOutput;\n+import org.openhab.core.items.ItemRegistry;\n+import org.openhab.core.items.events.ItemStateChangedEvent;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+import io.swagger.annotations.ApiParam;\n+import io.swagger.annotations.ApiResponse;\n+import io.swagger.annotations.ApiResponses;\n+\n+/**\n+ * SSE Resource for pushing selected item state updates to clients.\n+ *\n+ * @author Yannick Schaus - Initial contribution\n+ */\n+@Component(service = SseStatesResource.class)\n+@Path(SseStatesResource.PATH_EVENTS)\n+@RolesAllowed({ Role.USER })\n+@Singleton\n+@Api(value = SseStatesResource.PATH_EVENTS, hidden = true)\n+public class SseStatesResource {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SseStatesResource.class);\n+\n+    public static final String PATH_EVENTS = \"events/states\";\n+\n+    private static final String X_ACCEL_BUFFERING_HEADER = \"X-Accel-Buffering\";\n+\n+    private final ItemStateChangesSseBroadcaster broadcaster;\n+\n+    private final ExecutorService executorService;\n+\n+    private ItemRegistry itemRegistry;\n+\n+    @Reference\n+    protected void setItemRegistry(ItemRegistry itemRegistry) {\n+        this.itemRegistry = itemRegistry;\n+        this.broadcaster.setItemRegistry(itemRegistry);\n+    }\n+\n+    protected void unsetItemRegistry(ItemRegistry itemRegistry) {\n+        this.itemRegistry = itemRegistry;\n+    }\n+\n+    @Context\n+    private UriInfo uriInfo;\n+\n+    @Context\n+    private HttpServletResponse response;\n+\n+    @Context\n+    private HttpServletRequest request;\n+\n+    public SseStatesResource() {\n+        this.executorService = Executors.newSingleThreadExecutor();", "originalCommit": "1d11fa4e8076410e9dde8e3eb3243b944c041d09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzNzE3MQ==", "url": "https://github.com/openhab/openhab-core/pull/1364#discussion_r383037171", "bodyText": "The executor creation should be move to an activate method and it should be terminated in deactivated again to ensure we do not have any zombie threads when the bundle is shut down.", "author": "kaikreuzer", "createdAt": "2020-02-23T20:48:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzNzAzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI3MTk3Ng==", "url": "https://github.com/openhab/openhab-core/pull/1364#discussion_r383271976", "bodyText": "I copied and adapted the code from the original SSE resource:\n\n  \n    \n      openhab-core/bundles/org.openhab.core.io.rest.sse/src/main/java/org/openhab/core/io/rest/sse/SseResource.java\n    \n    \n        Lines 77 to 82\n      in\n      730a8e1\n    \n    \n    \n    \n\n        \n          \n            \n        \n\n        \n          \n           public SseResource() { \n        \n\n        \n          \n               this.executorService = Executors.newSingleThreadExecutor(); \n        \n\n        \n          \n               this.broadcaster = new SseBroadcaster(); \n        \n\n        \n          \n           } \n        \n\n        \n          \n            \n        \n    \n  \n\n\nDo you want me to make the same changes there as well? Or maybe merge the two resources (even if it's a different broadcaster though).", "author": "ghys", "createdAt": "2020-02-24T13:45:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzNzAzNA=="}], "type": "inlineReview"}, {"oid": "647b0ca730b3e2735e8f3b478423c1ff4a273ba0", "url": "https://github.com/openhab/openhab-core/commit/647b0ca730b3e2735e8f3b478423c1ff4a273ba0", "message": "Merge state tracking into main SSE resource\n\nAddress review comments.\n\nSigned-off-by: Yannick Schaus <github@schaus.net>", "committedDate": "2020-02-24T14:28:15Z", "type": "commit"}]}