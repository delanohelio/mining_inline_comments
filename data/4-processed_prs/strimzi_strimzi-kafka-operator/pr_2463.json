{"pr_number": 2463, "pr_title": "Deal with conflict between Connect and Connect S2I", "pr_createdAt": "2020-01-27T20:37:58Z", "pr_url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2463", "timeline": [{"oid": "674b86def70c9f8480e83fc667a3ff2cf9626c6f", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/674b86def70c9f8480e83fc667a3ff2cf9626c6f", "message": "Deal with conflict between Connect and Connect S2I\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-01-27T21:10:28Z", "type": "commit"}, {"oid": "ba8ad7388a9467a882e24bc63bd680156503dc71", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/ba8ad7388a9467a882e24bc63bd680156503dc71", "message": "Fix unused import\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-01-27T21:10:28Z", "type": "commit"}, {"oid": "eece63785e65bd29eec403c3d76080130e5e0687", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/eece63785e65bd29eec403c3d76080130e5e0687", "message": "Fix errors caused by PRs merged in the meantime\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-01-27T21:43:13Z", "type": "commit"}, {"oid": "eece63785e65bd29eec403c3d76080130e5e0687", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/eece63785e65bd29eec403c3d76080130e5e0687", "message": "Fix errors caused by PRs merged in the meantime\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-01-27T21:43:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY4NTcwNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2463#discussion_r371685704", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                            \"KafkaConnectS2I seems to exists longer and will be used while this custom resource will be ignored.\");\n          \n          \n            \n                                            \"KafkaConnectS2I is older and will be used while this custom resource will be ignored.\");", "author": "tombentley", "createdAt": "2020-01-28T09:21:57Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java", "diffHunk": "@@ -100,7 +107,26 @@ public KafkaConnectAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pf\n         annotations.put(ANNO_STRIMZI_IO_LOGGING, logAndMetricsConfigMap.getData().get(connect.ANCILLARY_CM_KEY_LOG_CONFIG));\n \n         log.debug(\"{}: Updating Kafka Connect cluster\", reconciliation, name, namespace);\n-        connectServiceAccount(namespace, connect)\n+\n+        Future<KafkaConnectS2I> connectS2ICheck;\n+        if (connectS2IOperations != null)   {\n+            connectS2ICheck = connectS2IOperations.getAsync(kafkaConnect.getMetadata().getNamespace(), kafkaConnect.getMetadata().getName());\n+        } else {\n+            connectS2ICheck = Future.succeededFuture(null);\n+        }\n+\n+        connectS2ICheck\n+                .compose(otherConnect -> {\n+                    if (otherConnect != null\n+                            // There is a KafkaConnectS2I with the same name which is older than this KafkaConnect\n+                            && kafkaConnect.getMetadata().getCreationTimestamp().compareTo(otherConnect.getMetadata().getCreationTimestamp()) > 0)    {\n+                        return Future.failedFuture(\"Both KafkaConnect and KafkaConnectS2I exist with the same name. \" +\n+                                \"KafkaConnectS2I seems to exists longer and will be used while this custom resource will be ignored.\");", "originalCommit": "eece63785e65bd29eec403c3d76080130e5e0687", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY4NjE2NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2463#discussion_r371686164", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                            \"KafkaConnect seems to exists longer and will be used while this custom resource will be ignored.\");\n          \n          \n            \n                                            \"KafkaConnect is older and will be used while this custom resource will be ignored.\");", "author": "tombentley", "createdAt": "2020-01-28T09:22:52Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectS2IAssemblyOperator.java", "diffHunk": "@@ -91,75 +92,84 @@ public KafkaConnectS2IAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability\n \n     @Override\n     public Future<Void> createOrUpdate(Reconciliation reconciliation, KafkaConnectS2I kafkaConnectS2I) {\n+        Promise<Void> createOrUpdatePromise = Promise.promise();\n+        String name = reconciliation.name();\n         String namespace = reconciliation.namespace();\n-        if (kafkaConnectS2I.getSpec() == null) {\n-            log.error(\"{} spec cannot be null\", kafkaConnectS2I.getMetadata().getName());\n-            return Future.failedFuture(\"Spec cannot be null\");\n-        }\n-        if (pfa.hasImages() && pfa.hasApps() && pfa.hasBuilds()) {\n-            Promise<Void> createOrUpdatePromise = Promise.promise();\n-            KafkaConnectS2ICluster connect;\n-            KafkaConnectS2Istatus kafkaConnectS2Istatus = new KafkaConnectS2Istatus();\n-            try {\n-                connect = KafkaConnectS2ICluster.fromCrd(kafkaConnectS2I, versions);\n-            } catch (Exception e) {\n-                StatusUtils.setStatusConditionAndObservedGeneration(kafkaConnectS2I, kafkaConnectS2Istatus, Future.failedFuture(e));\n-                return updateStatus(kafkaConnectS2I, reconciliation, kafkaConnectS2Istatus);\n+        KafkaConnectS2ICluster connect;\n+        KafkaConnectS2IStatus kafkaConnectS2Istatus = new KafkaConnectS2IStatus();\n+\n+        try {\n+            if (kafkaConnectS2I.getSpec() == null) {\n+                log.error(\"{}: Resource lacks spec property\", reconciliation, kafkaConnectS2I.getMetadata().getName());\n+                throw new InvalidResourceException(\"spec property is required\");\n             }\n-            connect.generateBuildConfig();\n-            ConfigMap logAndMetricsConfigMap = connect.generateMetricsAndLogConfigMap(connect.getLogging() instanceof ExternalLogging ?\n-                    configMapOperations.get(namespace, ((ExternalLogging) connect.getLogging()).getName()) :\n-                    null);\n-\n-            HashMap<String, String> annotations = new HashMap<>();\n-            annotations.put(ANNO_STRIMZI_IO_LOGGING, logAndMetricsConfigMap.getData().get(connect.ANCILLARY_CM_KEY_LOG_CONFIG));\n-            connectServiceAccount(namespace, connect)\n-                    .compose(i -> deploymentConfigOperations.scaleDown(namespace, connect.getName(), connect.getReplicas()))\n-                    .compose(scale -> serviceOperations.reconcile(namespace, connect.getServiceName(), connect.generateService()))\n-                    .compose(i -> configMapOperations.reconcile(namespace, connect.getAncillaryConfigName(), logAndMetricsConfigMap))\n-                    .compose(i -> deploymentConfigOperations.reconcile(namespace, connect.getName(), connect.generateDeploymentConfig(annotations, pfa.isOpenshift(), imagePullPolicy, imagePullSecrets)))\n-                    .compose(i -> imagesStreamOperations.reconcile(namespace, KafkaConnectS2IResources.sourceImageStreamName(connect.getCluster()), connect.generateSourceImageStream()))\n-                    .compose(i -> imagesStreamOperations.reconcile(namespace, KafkaConnectS2IResources.targetImageStreamName(connect.getCluster()), connect.generateTargetImageStream()))\n-                    .compose(i -> podDisruptionBudgetOperator.reconcile(namespace, connect.getName(), connect.generatePodDisruptionBudget()))\n-                    .compose(i -> buildConfigOperations.reconcile(namespace, KafkaConnectS2IResources.buildConfigName(connect.getCluster()), connect.generateBuildConfig()))\n-                    .compose(i -> deploymentConfigOperations.scaleUp(namespace, connect.getName(), connect.getReplicas()))\n-                    .compose(i -> deploymentConfigOperations.waitForObserved(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                    .compose(i -> deploymentConfigOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                    .compose(i -> reconcileConnectors(reconciliation, kafkaConnectS2I, kafkaConnectS2Istatus))\n-                    .setHandler(reconciliationResult -> {\n-                        StatusUtils.setStatusConditionAndObservedGeneration(kafkaConnectS2I, kafkaConnectS2Istatus, reconciliationResult);\n-                        kafkaConnectS2Istatus.setUrl(KafkaConnectS2IResources.url(connect.getCluster(), namespace, KafkaConnectS2ICluster.REST_API_PORT));\n-                        kafkaConnectS2Istatus.setBuildConfigName(KafkaConnectS2IResources.buildConfigName(connect.getCluster()));\n-\n-                        updateStatus(kafkaConnectS2I, reconciliation, kafkaConnectS2Istatus).setHandler(statusResult -> {\n-                            // If both features succeeded, createOrUpdate succeeded as well\n-                            // If one or both of them failed, we prefer the reconciliation failure as the main error\n-                            if (reconciliationResult.succeeded() && statusResult.succeeded()) {\n-                                createOrUpdatePromise.complete();\n-                            } else if (reconciliationResult.failed()) {\n-                                createOrUpdatePromise.fail(reconciliationResult.cause());\n-                            } else {\n-                                createOrUpdatePromise.fail(statusResult.cause());\n-                            }\n-                        });\n-                    });\n-            return createOrUpdatePromise.future();\n \n-        } else {\n-            return Future.failedFuture(\"The OpenShift build, image or apps APIs are not available in this Kubernetes cluster. Kafka Connect S2I deployment cannot be enabled.\");\n+            connect = KafkaConnectS2ICluster.fromCrd(kafkaConnectS2I, versions);\n+        } catch (Exception e) {\n+            StatusUtils.setStatusConditionAndObservedGeneration(kafkaConnectS2I, kafkaConnectS2Istatus, Future.failedFuture(e));\n+            return updateStatus(kafkaConnectS2I, reconciliation, kafkaConnectS2Istatus);\n         }\n-    }\n \n-    @Override\n-    protected Future<Void> reconcileConnectors(Reconciliation reconciliation, KafkaConnectS2I connects2i, KafkaConnectS2Istatus connects2istatus) {\n-        return connectOperations.getAsync(connects2i.getMetadata().getNamespace(), connects2i.getMetadata().getName()).compose(connect -> {\n-            // If there's a non-s2i of the same name then do nothing, since that takes precedence\n-            if (connect != null) {\n-                return Future.succeededFuture();\n-            } else {\n-                return super.reconcileConnectors(reconciliation, connects2i, connects2istatus);\n-            }\n-        });\n+        connect.generateBuildConfig();\n+        ConfigMap logAndMetricsConfigMap = connect.generateMetricsAndLogConfigMap(connect.getLogging() instanceof ExternalLogging ?\n+                configMapOperations.get(namespace, ((ExternalLogging) connect.getLogging()).getName()) :\n+                null);\n+\n+        HashMap<String, String> annotations = new HashMap<>();\n+        annotations.put(ANNO_STRIMZI_IO_LOGGING, logAndMetricsConfigMap.getData().get(connect.ANCILLARY_CM_KEY_LOG_CONFIG));\n+\n+        log.debug(\"{}: Updating Kafka Connect S2I cluster\", reconciliation, name, namespace);\n+\n+        connectOperations.getAsync(kafkaConnectS2I.getMetadata().getNamespace(), kafkaConnectS2I.getMetadata().getName())\n+                .compose(otherConnect -> {\n+                    if (otherConnect != null\n+                            // There is a KafkaConnect with the same name which is older than  or equally old as this KafkaConnectS2I\n+                            && kafkaConnectS2I.getMetadata().getCreationTimestamp().compareTo(otherConnect.getMetadata().getCreationTimestamp()) >= 0)    {\n+                        return Future.failedFuture(\"Both KafkaConnect and KafkaConnectS2I exist with the same name. \" +\n+                                \"KafkaConnect seems to exists longer and will be used while this custom resource will be ignored.\");", "originalCommit": "eece63785e65bd29eec403c3d76080130e5e0687", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ff285f513968f36b8b9c104643d0a36f372e1fb4", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/ff285f513968f36b8b9c104643d0a36f372e1fb4", "message": "Make handling cleaner in the connector watch\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-01-28T13:03:06Z", "type": "commit"}]}