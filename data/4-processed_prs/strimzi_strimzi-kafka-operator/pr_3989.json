{"pr_number": 3989, "pr_title": "Additional 'keycloak' authorization documentation", "pr_createdAt": "2020-11-20T15:45:13Z", "pr_url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ1MDkyMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531450922", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            == Starting Up the Pods\n          \n          \n            \n            == Starting the pods", "author": "PaulRMellor", "createdAt": "2020-11-27T08:33:58Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,462 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods", "originalCommit": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ1MTA2MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531451060", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For this example we're using the kubernetes deployment scripts available at https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n          \n          \n            \n            For this example, we use the kubernetes deployment scripts available at https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes:", "author": "PaulRMellor", "createdAt": "2020-11-27T08:34:15Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,462 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes", "originalCommit": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ1MTc4NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531451785", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n          \n          \n            \n            Here we assume that the Strimzi Cluster Operator has already been installed on the Kubernetes cluster.", "author": "PaulRMellor", "createdAt": "2020-11-27T08:35:41Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,462 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.", "originalCommit": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ4MDIyMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531480223", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n          \n          \n            \n            Use your browser to connect to `\\http://localhost:8080/auth/admin` and use `admin` as username and password.", "author": "PaulRMellor", "createdAt": "2020-11-27T09:29:03Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,462 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.", "originalCommit": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTUwNzcxMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531507711", "bodyText": "I suppose this backslash becomes invisible when rendered but prevents some unwanted rendering that would otherwise occur?", "author": "mstruk", "createdAt": "2020-11-27T10:17:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ4MDIyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ4MDUzNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531480537", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Initially the *Realm Settings* section is selected, but you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n          \n          \n            \n            Initially, the *Realm Settings* section is selected, but you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.", "author": "PaulRMellor", "createdAt": "2020-11-27T09:29:34Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,462 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+The default view usually displays the *Master* realm.\n+For this example we are interested in the `kafka-authz` realm, which you can select in the upper left corner.\n+\n+Initially the *Realm Settings* section is selected, but you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.", "originalCommit": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ4MDc0Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531480743", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n          \n          \n            \n            We login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:", "author": "PaulRMellor", "createdAt": "2020-11-27T09:29:58Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,462 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:", "originalCommit": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ4MDk5OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531480998", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n          \n          \n            \n            Then we use a browser to connect to `http://localhost:8080/auth/admin` using `admin` as username and password.", "author": "PaulRMellor", "createdAt": "2020-11-27T09:30:24Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,462 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.", "originalCommit": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ4MTI4Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531481287", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In Keycloak the groups can be stored in an LDAP identity provider.\n          \n          \n            \n            In Keycloak, groups can be stored in an LDAP identity provider.", "author": "PaulRMellor", "createdAt": "2020-11-27T09:30:59Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,462 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+The default view usually displays the *Master* realm.\n+For this example we are interested in the `kafka-authz` realm, which you can select in the upper left corner.\n+\n+Initially the *Realm Settings* section is selected, but you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.", "originalCommit": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ4MjM2NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531482365", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n          \n          \n            \n            Under *Users*, you can view all defined users. For this example, `alice` and `bob` are defined. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.", "author": "PaulRMellor", "createdAt": "2020-11-27T09:33:02Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,462 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+The default view usually displays the *Master* realm.\n+For this example we are interested in the `kafka-authz` realm, which you can select in the upper left corner.\n+\n+Initially the *Realm Settings* section is selected, but you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.", "originalCommit": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ4MjY0MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531482641", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In Keycloak the users can be stored in an LDAP identity provider.\n          \n          \n            \n            In Keycloak, users can be stored in an LDAP identity provider.", "author": "PaulRMellor", "createdAt": "2020-11-27T09:33:36Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,462 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+The default view usually displays the *Master* realm.\n+For this example we are interested in the `kafka-authz` realm, which you can select in the upper left corner.\n+\n+Initially the *Realm Settings* section is selected, but you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.", "originalCommit": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ4MzUzMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531483530", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n          \n          \n            \n            Under *Clients*, you can view the additional client configurations. For this eaxmple,  `kafka`, `kafka-cli`, `team-a-client`, `team-b-client` are configured.", "author": "PaulRMellor", "createdAt": "2020-11-27T09:35:10Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,462 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+The default view usually displays the *Master* realm.\n+For this example we are interested in the `kafka-authz` realm, which you can select in the upper left corner.\n+\n+Initially the *Realm Settings* section is selected, but you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.", "originalCommit": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ4NDYzOQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531484639", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources as explained in xref:keycloak_authorization_services_model_for_managing_permissions(one of the previous chapters).\n          \n          \n            \n            Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources, as explained in xref:keycloak_authorization_services_model_for_managing_permissions[Keycloak Authorization Services model for managing permissions].", "author": "PaulRMellor", "createdAt": "2020-11-27T09:37:08Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,462 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+The default view usually displays the *Master* realm.\n+For this example we are interested in the `kafka-authz` realm, which you can select in the upper left corner.\n+\n+Initially the *Realm Settings* section is selected, but you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources as explained in xref:keycloak_authorization_services_model_for_managing_permissions(one of the previous chapters).", "originalCommit": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ5MTk3Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531491977", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Under *Authorization* / *Permissions* of `kafka` client you can see already granted permissions that make use of *Resources* and *Policies* defined under the other tabs:\n          \n          \n            \n            From *Authorization* / *Permissions* you can see the granted permissions that use resources and policies defined from other *Resources* and *Policies* tabs. For example, the `kafka` client has the following permissions:", "author": "PaulRMellor", "createdAt": "2020-11-27T09:50:07Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,462 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+The default view usually displays the *Master* realm.\n+For this example we are interested in the `kafka-authz` realm, which you can select in the upper left corner.\n+\n+Initially the *Realm Settings* section is selected, but you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources as explained in xref:keycloak_authorization_services_model_for_managing_permissions(one of the previous chapters).\n+\n+Under *Authorization* / *Permissions* of `kafka` client you can see already granted permissions that make use of *Resources* and *Policies* defined under the other tabs:", "originalCommit": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ5MzA1OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531493058", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            == Authorization in Action Using CLI Clients\n          \n          \n            \n            == Authorization in action using CLI clients", "author": "PaulRMellor", "createdAt": "2020-11-27T09:52:01Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,462 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+The default view usually displays the *Master* realm.\n+For this example we are interested in the `kafka-authz` realm, which you can select in the upper left corner.\n+\n+Initially the *Realm Settings* section is selected, but you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources as explained in xref:keycloak_authorization_services_model_for_managing_permissions(one of the previous chapters).\n+\n+Under *Authorization* / *Permissions* of `kafka` client you can see already granted permissions that make use of *Resources* and *Policies* defined under the other tabs:\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+`Dev Team A can write to topics that start with x_ on any cluster` combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team A`.\n+\n+`Dev Team B can read from topics that start with x_ on any cluster` combines `Topic:x_*`, and `Group:x_*` resources, scopes `Describe` and `Read`, and `Dev Team B` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team B`. Matching users and clients have the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with `x_`.\n+\n+== Targeting permissions using group or role policies\n+\n+In Keycloak, confidential clients with service accounts enabled can authenticate to the server in their own name using a client ID and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use group policies, and should instead use role policies.\n+Conversely, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the group policies, rather than the role policies.\n+That is what is used for permissions that start with `ClusterManager`.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case, the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients", "originalCommit": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ5NDQ2OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531494469", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The `team-a-client` configuration is then used to produce messages to topic `a_messages`.\n          \n          \n            \n            The `team-a-client` configuration is then used to produce messages to topic `a_messages`:", "author": "PaulRMellor", "createdAt": "2020-11-27T09:54:31Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,462 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+The default view usually displays the *Master* realm.\n+For this example we are interested in the `kafka-authz` realm, which you can select in the upper left corner.\n+\n+Initially the *Realm Settings* section is selected, but you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources as explained in xref:keycloak_authorization_services_model_for_managing_permissions(one of the previous chapters).\n+\n+Under *Authorization* / *Permissions* of `kafka` client you can see already granted permissions that make use of *Resources* and *Policies* defined under the other tabs:\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+`Dev Team A can write to topics that start with x_ on any cluster` combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team A`.\n+\n+`Dev Team B can read from topics that start with x_ on any cluster` combines `Topic:x_*`, and `Group:x_*` resources, scopes `Describe` and `Read`, and `Dev Team B` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team B`. Matching users and clients have the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with `x_`.\n+\n+== Targeting permissions using group or role policies\n+\n+In Keycloak, confidential clients with service accounts enabled can authenticate to the server in their own name using a client ID and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use group policies, and should instead use role policies.\n+Conversely, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the group policies, rather than the role policies.\n+That is what is used for permissions that start with `ClusterManager`.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case, the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+From menu:Clients[kafka>Authorization>Settings] make sure that *Decision Strategy* is set to *Affirmative*, and NOT to *Unanimous*.\n+Navigate in Keycloak to check that the expected resources, authorization claims, policies and permissions are defined.\n+\n+With the configuration in place, we can check access to Kafka by using a producer and consumer to create topics using different user and service accounts.\n+\n+First, a new interactive pod container is run using a Strimzi Kafka image to connect to a running Kafka broker.\n+\n+[source,shell]\n+----\n+kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+----\n+\n+NOTE: If `kubectl` times out waiting on the image download, subsequent attempts may result in an _AlreadyExists_ error. \n+\n+You can attach to the existing pod by running:\n+\n+[source,shell]\n+----\n+kubectl attach -ti kafka-cli\n+----\n+\n+To produce messages as client `team-a-client`, we prepare a Kafka client configuration file with authentication parameters.\n+\n+[source,shell]\n+----\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+----\n+\n+The roles assigned to a client, such as the `Dev Team A` realm role assigned to the `team-a-client` service account, are presented in Keycloak on the  *Service Account Roles* tab from *Clients*.\n+\n+We can use this configuration from the Kafka CLI to produce and consume messages, and perform other administration tasks.\n+\n+\n+.Producing messages with authorized access\n+\n+The `team-a-client` configuration is used to produce messages to topic `my-topic`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+----\n+\n+A `Not authorized to access topics: [my-topic]` error is returned when trying to push the first message.\n+\n+`team-a-client` has a `Dev Team A` role that gives it permission to perform any supported actions on topics that start with `a_`, but can only write to topics that start with `x_`.\n+The topic named `my-topic` matches neither of those rules.\n+\n+The `team-a-client` configuration is then used to produce messages to topic `a_messages`.", "originalCommit": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ5NTI0MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531495241", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            . Using clients with different permissions\n          \n          \n            \n            .Using clients with different permissions", "author": "PaulRMellor", "createdAt": "2020-11-27T09:55:45Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,462 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+The default view usually displays the *Master* realm.\n+For this example we are interested in the `kafka-authz` realm, which you can select in the upper left corner.\n+\n+Initially the *Realm Settings* section is selected, but you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources as explained in xref:keycloak_authorization_services_model_for_managing_permissions(one of the previous chapters).\n+\n+Under *Authorization* / *Permissions* of `kafka` client you can see already granted permissions that make use of *Resources* and *Policies* defined under the other tabs:\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+`Dev Team A can write to topics that start with x_ on any cluster` combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team A`.\n+\n+`Dev Team B can read from topics that start with x_ on any cluster` combines `Topic:x_*`, and `Group:x_*` resources, scopes `Describe` and `Read`, and `Dev Team B` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team B`. Matching users and clients have the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with `x_`.\n+\n+== Targeting permissions using group or role policies\n+\n+In Keycloak, confidential clients with service accounts enabled can authenticate to the server in their own name using a client ID and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use group policies, and should instead use role policies.\n+Conversely, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the group policies, rather than the role policies.\n+That is what is used for permissions that start with `ClusterManager`.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case, the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+From menu:Clients[kafka>Authorization>Settings] make sure that *Decision Strategy* is set to *Affirmative*, and NOT to *Unanimous*.\n+Navigate in Keycloak to check that the expected resources, authorization claims, policies and permissions are defined.\n+\n+With the configuration in place, we can check access to Kafka by using a producer and consumer to create topics using different user and service accounts.\n+\n+First, a new interactive pod container is run using a Strimzi Kafka image to connect to a running Kafka broker.\n+\n+[source,shell]\n+----\n+kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+----\n+\n+NOTE: If `kubectl` times out waiting on the image download, subsequent attempts may result in an _AlreadyExists_ error. \n+\n+You can attach to the existing pod by running:\n+\n+[source,shell]\n+----\n+kubectl attach -ti kafka-cli\n+----\n+\n+To produce messages as client `team-a-client`, we prepare a Kafka client configuration file with authentication parameters.\n+\n+[source,shell]\n+----\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+----\n+\n+The roles assigned to a client, such as the `Dev Team A` realm role assigned to the `team-a-client` service account, are presented in Keycloak on the  *Service Account Roles* tab from *Clients*.\n+\n+We can use this configuration from the Kafka CLI to produce and consume messages, and perform other administration tasks.\n+\n+\n+.Producing messages with authorized access\n+\n+The `team-a-client` configuration is used to produce messages to topic `my-topic`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+----\n+\n+A `Not authorized to access topics: [my-topic]` error is returned when trying to push the first message.\n+\n+`team-a-client` has a `Dev Team A` role that gives it permission to perform any supported actions on topics that start with `a_`, but can only write to topics that start with `x_`.\n+The topic named `my-topic` matches neither of those rules.\n+\n+The `team-a-client` configuration is then used to produce messages to topic `a_messages`.\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+----\n+\n+The messages are pushed out successfully, and in the Kafka container log there is DEBUG level output saying `Authorization GRANTED`.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+[source,shell]\n+kubectl logs my-cluster-kafka-0 -f\n+\n+.Consuming messages with authorized access\n+\n+The `team-a-client` configuration is used to consume messages from topic `a_messages`:\n+\n+[source,shell,subs=+quotes]\n+----\n+bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --from-beginning --consumer.config /tmp/team-a-client.properties\n+----\n+\n+An error is returned as the `Dev Team A` role for `team-a-client` only has access to consumer groups that have names starting with `a_`.\n+The `team-a-client` configuration is then used to consume messages when specifying a custom consumer group with a name that starts with `a_`:\n+\n+[source,shell,subs=+quotes]\n+----\n+bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+----\n+\n+This time the consumer receives all the messages from the `a_messages` topic.\n+\n+\n+.Administering Kafka with authorized access\n+\n+The `team-a-client` configuration is used in administrative operations.\n+\n+Listing topics returns the `a_messages` topic.\n+\n+[source,shell]\n+----\n+bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+----    \n+\n+Listing consumer groups returns the `a_consumer_group_1` consumer group.\n+\n+[source,shell]\n+----\n+bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+----\n+\n+Fetching the default cluster configuration fails cluster authorization, because the operation requires cluster level permissions that `team-a-client` does not have.\n+\n+[source,shell]\n+----\n+bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+  --entity-type brokers --describe --entity-default\n+----\n+\n+\n+. Using clients with different permissions", "originalCommit": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ5NTYxOA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531495618", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Listing topics returns the `a_messages` topic.\n          \n          \n            \n            Listing topics returns the `a_messages` topic:", "author": "PaulRMellor", "createdAt": "2020-11-27T09:56:24Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,462 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+The default view usually displays the *Master* realm.\n+For this example we are interested in the `kafka-authz` realm, which you can select in the upper left corner.\n+\n+Initially the *Realm Settings* section is selected, but you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources as explained in xref:keycloak_authorization_services_model_for_managing_permissions(one of the previous chapters).\n+\n+Under *Authorization* / *Permissions* of `kafka` client you can see already granted permissions that make use of *Resources* and *Policies* defined under the other tabs:\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+`Dev Team A can write to topics that start with x_ on any cluster` combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team A`.\n+\n+`Dev Team B can read from topics that start with x_ on any cluster` combines `Topic:x_*`, and `Group:x_*` resources, scopes `Describe` and `Read`, and `Dev Team B` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team B`. Matching users and clients have the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with `x_`.\n+\n+== Targeting permissions using group or role policies\n+\n+In Keycloak, confidential clients with service accounts enabled can authenticate to the server in their own name using a client ID and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use group policies, and should instead use role policies.\n+Conversely, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the group policies, rather than the role policies.\n+That is what is used for permissions that start with `ClusterManager`.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case, the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+From menu:Clients[kafka>Authorization>Settings] make sure that *Decision Strategy* is set to *Affirmative*, and NOT to *Unanimous*.\n+Navigate in Keycloak to check that the expected resources, authorization claims, policies and permissions are defined.\n+\n+With the configuration in place, we can check access to Kafka by using a producer and consumer to create topics using different user and service accounts.\n+\n+First, a new interactive pod container is run using a Strimzi Kafka image to connect to a running Kafka broker.\n+\n+[source,shell]\n+----\n+kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+----\n+\n+NOTE: If `kubectl` times out waiting on the image download, subsequent attempts may result in an _AlreadyExists_ error. \n+\n+You can attach to the existing pod by running:\n+\n+[source,shell]\n+----\n+kubectl attach -ti kafka-cli\n+----\n+\n+To produce messages as client `team-a-client`, we prepare a Kafka client configuration file with authentication parameters.\n+\n+[source,shell]\n+----\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+----\n+\n+The roles assigned to a client, such as the `Dev Team A` realm role assigned to the `team-a-client` service account, are presented in Keycloak on the  *Service Account Roles* tab from *Clients*.\n+\n+We can use this configuration from the Kafka CLI to produce and consume messages, and perform other administration tasks.\n+\n+\n+.Producing messages with authorized access\n+\n+The `team-a-client` configuration is used to produce messages to topic `my-topic`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+----\n+\n+A `Not authorized to access topics: [my-topic]` error is returned when trying to push the first message.\n+\n+`team-a-client` has a `Dev Team A` role that gives it permission to perform any supported actions on topics that start with `a_`, but can only write to topics that start with `x_`.\n+The topic named `my-topic` matches neither of those rules.\n+\n+The `team-a-client` configuration is then used to produce messages to topic `a_messages`.\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+----\n+\n+The messages are pushed out successfully, and in the Kafka container log there is DEBUG level output saying `Authorization GRANTED`.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+[source,shell]\n+kubectl logs my-cluster-kafka-0 -f\n+\n+.Consuming messages with authorized access\n+\n+The `team-a-client` configuration is used to consume messages from topic `a_messages`:\n+\n+[source,shell,subs=+quotes]\n+----\n+bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --from-beginning --consumer.config /tmp/team-a-client.properties\n+----\n+\n+An error is returned as the `Dev Team A` role for `team-a-client` only has access to consumer groups that have names starting with `a_`.\n+The `team-a-client` configuration is then used to consume messages when specifying a custom consumer group with a name that starts with `a_`:\n+\n+[source,shell,subs=+quotes]\n+----\n+bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+----\n+\n+This time the consumer receives all the messages from the `a_messages` topic.\n+\n+\n+.Administering Kafka with authorized access\n+\n+The `team-a-client` configuration is used in administrative operations.\n+\n+Listing topics returns the `a_messages` topic.", "originalCommit": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ5NTcxNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531495716", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Listing consumer groups returns the `a_consumer_group_1` consumer group.\n          \n          \n            \n            Listing consumer groups returns the `a_consumer_group_1` consumer group:", "author": "PaulRMellor", "createdAt": "2020-11-27T09:56:34Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,462 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+The default view usually displays the *Master* realm.\n+For this example we are interested in the `kafka-authz` realm, which you can select in the upper left corner.\n+\n+Initially the *Realm Settings* section is selected, but you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources as explained in xref:keycloak_authorization_services_model_for_managing_permissions(one of the previous chapters).\n+\n+Under *Authorization* / *Permissions* of `kafka` client you can see already granted permissions that make use of *Resources* and *Policies* defined under the other tabs:\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+`Dev Team A can write to topics that start with x_ on any cluster` combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team A`.\n+\n+`Dev Team B can read from topics that start with x_ on any cluster` combines `Topic:x_*`, and `Group:x_*` resources, scopes `Describe` and `Read`, and `Dev Team B` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team B`. Matching users and clients have the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with `x_`.\n+\n+== Targeting permissions using group or role policies\n+\n+In Keycloak, confidential clients with service accounts enabled can authenticate to the server in their own name using a client ID and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use group policies, and should instead use role policies.\n+Conversely, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the group policies, rather than the role policies.\n+That is what is used for permissions that start with `ClusterManager`.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case, the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+From menu:Clients[kafka>Authorization>Settings] make sure that *Decision Strategy* is set to *Affirmative*, and NOT to *Unanimous*.\n+Navigate in Keycloak to check that the expected resources, authorization claims, policies and permissions are defined.\n+\n+With the configuration in place, we can check access to Kafka by using a producer and consumer to create topics using different user and service accounts.\n+\n+First, a new interactive pod container is run using a Strimzi Kafka image to connect to a running Kafka broker.\n+\n+[source,shell]\n+----\n+kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+----\n+\n+NOTE: If `kubectl` times out waiting on the image download, subsequent attempts may result in an _AlreadyExists_ error. \n+\n+You can attach to the existing pod by running:\n+\n+[source,shell]\n+----\n+kubectl attach -ti kafka-cli\n+----\n+\n+To produce messages as client `team-a-client`, we prepare a Kafka client configuration file with authentication parameters.\n+\n+[source,shell]\n+----\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+----\n+\n+The roles assigned to a client, such as the `Dev Team A` realm role assigned to the `team-a-client` service account, are presented in Keycloak on the  *Service Account Roles* tab from *Clients*.\n+\n+We can use this configuration from the Kafka CLI to produce and consume messages, and perform other administration tasks.\n+\n+\n+.Producing messages with authorized access\n+\n+The `team-a-client` configuration is used to produce messages to topic `my-topic`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+----\n+\n+A `Not authorized to access topics: [my-topic]` error is returned when trying to push the first message.\n+\n+`team-a-client` has a `Dev Team A` role that gives it permission to perform any supported actions on topics that start with `a_`, but can only write to topics that start with `x_`.\n+The topic named `my-topic` matches neither of those rules.\n+\n+The `team-a-client` configuration is then used to produce messages to topic `a_messages`.\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+----\n+\n+The messages are pushed out successfully, and in the Kafka container log there is DEBUG level output saying `Authorization GRANTED`.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+[source,shell]\n+kubectl logs my-cluster-kafka-0 -f\n+\n+.Consuming messages with authorized access\n+\n+The `team-a-client` configuration is used to consume messages from topic `a_messages`:\n+\n+[source,shell,subs=+quotes]\n+----\n+bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --from-beginning --consumer.config /tmp/team-a-client.properties\n+----\n+\n+An error is returned as the `Dev Team A` role for `team-a-client` only has access to consumer groups that have names starting with `a_`.\n+The `team-a-client` configuration is then used to consume messages when specifying a custom consumer group with a name that starts with `a_`:\n+\n+[source,shell,subs=+quotes]\n+----\n+bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+----\n+\n+This time the consumer receives all the messages from the `a_messages` topic.\n+\n+\n+.Administering Kafka with authorized access\n+\n+The `team-a-client` configuration is used in administrative operations.\n+\n+Listing topics returns the `a_messages` topic.\n+\n+[source,shell]\n+----\n+bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+----    \n+\n+Listing consumer groups returns the `a_consumer_group_1` consumer group.", "originalCommit": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ5NjAwOA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531496008", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Fetching the default cluster configuration fails cluster authorization, because the operation requires cluster level permissions that `team-a-client` does not have.\n          \n          \n            \n            Fetching the default cluster configuration fails cluster authorization, because the operation requires cluster level permissions that `team-a-client` does not have:", "author": "PaulRMellor", "createdAt": "2020-11-27T09:57:04Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,462 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+The default view usually displays the *Master* realm.\n+For this example we are interested in the `kafka-authz` realm, which you can select in the upper left corner.\n+\n+Initially the *Realm Settings* section is selected, but you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources as explained in xref:keycloak_authorization_services_model_for_managing_permissions(one of the previous chapters).\n+\n+Under *Authorization* / *Permissions* of `kafka` client you can see already granted permissions that make use of *Resources* and *Policies* defined under the other tabs:\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+`Dev Team A can write to topics that start with x_ on any cluster` combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team A`.\n+\n+`Dev Team B can read from topics that start with x_ on any cluster` combines `Topic:x_*`, and `Group:x_*` resources, scopes `Describe` and `Read`, and `Dev Team B` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team B`. Matching users and clients have the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with `x_`.\n+\n+== Targeting permissions using group or role policies\n+\n+In Keycloak, confidential clients with service accounts enabled can authenticate to the server in their own name using a client ID and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use group policies, and should instead use role policies.\n+Conversely, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the group policies, rather than the role policies.\n+That is what is used for permissions that start with `ClusterManager`.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case, the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+From menu:Clients[kafka>Authorization>Settings] make sure that *Decision Strategy* is set to *Affirmative*, and NOT to *Unanimous*.\n+Navigate in Keycloak to check that the expected resources, authorization claims, policies and permissions are defined.\n+\n+With the configuration in place, we can check access to Kafka by using a producer and consumer to create topics using different user and service accounts.\n+\n+First, a new interactive pod container is run using a Strimzi Kafka image to connect to a running Kafka broker.\n+\n+[source,shell]\n+----\n+kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+----\n+\n+NOTE: If `kubectl` times out waiting on the image download, subsequent attempts may result in an _AlreadyExists_ error. \n+\n+You can attach to the existing pod by running:\n+\n+[source,shell]\n+----\n+kubectl attach -ti kafka-cli\n+----\n+\n+To produce messages as client `team-a-client`, we prepare a Kafka client configuration file with authentication parameters.\n+\n+[source,shell]\n+----\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+----\n+\n+The roles assigned to a client, such as the `Dev Team A` realm role assigned to the `team-a-client` service account, are presented in Keycloak on the  *Service Account Roles* tab from *Clients*.\n+\n+We can use this configuration from the Kafka CLI to produce and consume messages, and perform other administration tasks.\n+\n+\n+.Producing messages with authorized access\n+\n+The `team-a-client` configuration is used to produce messages to topic `my-topic`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+----\n+\n+A `Not authorized to access topics: [my-topic]` error is returned when trying to push the first message.\n+\n+`team-a-client` has a `Dev Team A` role that gives it permission to perform any supported actions on topics that start with `a_`, but can only write to topics that start with `x_`.\n+The topic named `my-topic` matches neither of those rules.\n+\n+The `team-a-client` configuration is then used to produce messages to topic `a_messages`.\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+----\n+\n+The messages are pushed out successfully, and in the Kafka container log there is DEBUG level output saying `Authorization GRANTED`.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+[source,shell]\n+kubectl logs my-cluster-kafka-0 -f\n+\n+.Consuming messages with authorized access\n+\n+The `team-a-client` configuration is used to consume messages from topic `a_messages`:\n+\n+[source,shell,subs=+quotes]\n+----\n+bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --from-beginning --consumer.config /tmp/team-a-client.properties\n+----\n+\n+An error is returned as the `Dev Team A` role for `team-a-client` only has access to consumer groups that have names starting with `a_`.\n+The `team-a-client` configuration is then used to consume messages when specifying a custom consumer group with a name that starts with `a_`:\n+\n+[source,shell,subs=+quotes]\n+----\n+bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+----\n+\n+This time the consumer receives all the messages from the `a_messages` topic.\n+\n+\n+.Administering Kafka with authorized access\n+\n+The `team-a-client` configuration is used in administrative operations.\n+\n+Listing topics returns the `a_messages` topic.\n+\n+[source,shell]\n+----\n+bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+----    \n+\n+Listing consumer groups returns the `a_consumer_group_1` consumer group.\n+\n+[source,shell]\n+----\n+bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+----\n+\n+Fetching the default cluster configuration fails cluster authorization, because the operation requires cluster level permissions that `team-a-client` does not have.", "originalCommit": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ5NjQwMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531496403", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            We switch again, but this time to topic that `team-b-client` can only read from, topic `x_messages`:\n          \n          \n            \n            We switch again, but this time to a topic that `team-b-client` can only read from, topic `x_messages`:", "author": "PaulRMellor", "createdAt": "2020-11-27T09:57:45Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,462 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+The default view usually displays the *Master* realm.\n+For this example we are interested in the `kafka-authz` realm, which you can select in the upper left corner.\n+\n+Initially the *Realm Settings* section is selected, but you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources as explained in xref:keycloak_authorization_services_model_for_managing_permissions(one of the previous chapters).\n+\n+Under *Authorization* / *Permissions* of `kafka` client you can see already granted permissions that make use of *Resources* and *Policies* defined under the other tabs:\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+`Dev Team A can write to topics that start with x_ on any cluster` combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team A`.\n+\n+`Dev Team B can read from topics that start with x_ on any cluster` combines `Topic:x_*`, and `Group:x_*` resources, scopes `Describe` and `Read`, and `Dev Team B` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team B`. Matching users and clients have the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with `x_`.\n+\n+== Targeting permissions using group or role policies\n+\n+In Keycloak, confidential clients with service accounts enabled can authenticate to the server in their own name using a client ID and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use group policies, and should instead use role policies.\n+Conversely, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the group policies, rather than the role policies.\n+That is what is used for permissions that start with `ClusterManager`.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case, the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+From menu:Clients[kafka>Authorization>Settings] make sure that *Decision Strategy* is set to *Affirmative*, and NOT to *Unanimous*.\n+Navigate in Keycloak to check that the expected resources, authorization claims, policies and permissions are defined.\n+\n+With the configuration in place, we can check access to Kafka by using a producer and consumer to create topics using different user and service accounts.\n+\n+First, a new interactive pod container is run using a Strimzi Kafka image to connect to a running Kafka broker.\n+\n+[source,shell]\n+----\n+kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+----\n+\n+NOTE: If `kubectl` times out waiting on the image download, subsequent attempts may result in an _AlreadyExists_ error. \n+\n+You can attach to the existing pod by running:\n+\n+[source,shell]\n+----\n+kubectl attach -ti kafka-cli\n+----\n+\n+To produce messages as client `team-a-client`, we prepare a Kafka client configuration file with authentication parameters.\n+\n+[source,shell]\n+----\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+----\n+\n+The roles assigned to a client, such as the `Dev Team A` realm role assigned to the `team-a-client` service account, are presented in Keycloak on the  *Service Account Roles* tab from *Clients*.\n+\n+We can use this configuration from the Kafka CLI to produce and consume messages, and perform other administration tasks.\n+\n+\n+.Producing messages with authorized access\n+\n+The `team-a-client` configuration is used to produce messages to topic `my-topic`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+----\n+\n+A `Not authorized to access topics: [my-topic]` error is returned when trying to push the first message.\n+\n+`team-a-client` has a `Dev Team A` role that gives it permission to perform any supported actions on topics that start with `a_`, but can only write to topics that start with `x_`.\n+The topic named `my-topic` matches neither of those rules.\n+\n+The `team-a-client` configuration is then used to produce messages to topic `a_messages`.\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+----\n+\n+The messages are pushed out successfully, and in the Kafka container log there is DEBUG level output saying `Authorization GRANTED`.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+[source,shell]\n+kubectl logs my-cluster-kafka-0 -f\n+\n+.Consuming messages with authorized access\n+\n+The `team-a-client` configuration is used to consume messages from topic `a_messages`:\n+\n+[source,shell,subs=+quotes]\n+----\n+bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --from-beginning --consumer.config /tmp/team-a-client.properties\n+----\n+\n+An error is returned as the `Dev Team A` role for `team-a-client` only has access to consumer groups that have names starting with `a_`.\n+The `team-a-client` configuration is then used to consume messages when specifying a custom consumer group with a name that starts with `a_`:\n+\n+[source,shell,subs=+quotes]\n+----\n+bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+----\n+\n+This time the consumer receives all the messages from the `a_messages` topic.\n+\n+\n+.Administering Kafka with authorized access\n+\n+The `team-a-client` configuration is used in administrative operations.\n+\n+Listing topics returns the `a_messages` topic.\n+\n+[source,shell]\n+----\n+bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+----    \n+\n+Listing consumer groups returns the `a_consumer_group_1` consumer group.\n+\n+[source,shell]\n+----\n+bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+----\n+\n+Fetching the default cluster configuration fails cluster authorization, because the operation requires cluster level permissions that `team-a-client` does not have.\n+\n+[source,shell]\n+----\n+bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+  --entity-type brokers --describe --entity-default\n+----\n+\n+\n+. Using clients with different permissions\n+\n+As with `team-a-client`, we prepare a Kafka client configuration file with authentication parameters for `team-b-client`.\n+\n+[source,shell]\n+----\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+----\n+\n+The `team-b-client` client configuration includes a `Dev Team B` realm role and permissions that start with `Dev Team B ...`. These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with `b_` on the Kafka cluster `my-cluster`, the name of the designated cluster, and read access on topics that start with `x_`.\n+\n+The `team-b-client` configuration is used to produce messages to topic `a_messages`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+----\n+\n+A `Not authorized to access topics: [a_messages]` error is returned when trying to push the first message, as expected, so we switch to topic `b_messages`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+Message 2\n+Message 3\n+----\n+\n+Producing messages to topic `b_messages` is authorized and successful.\n+\n+We switch again, but this time to topic that `team-b-client` can only read from, topic `x_messages`:", "originalCommit": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ5Njc4Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531496783", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            User `bob` authenticates to the Keycloak server with his username and password to get a refresh token.\n          \n          \n            \n            User `bob` authenticates to the Keycloak server with his username and password to get a refresh token:", "author": "PaulRMellor", "createdAt": "2020-11-27T09:58:27Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,462 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+The default view usually displays the *Master* realm.\n+For this example we are interested in the `kafka-authz` realm, which you can select in the upper left corner.\n+\n+Initially the *Realm Settings* section is selected, but you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources as explained in xref:keycloak_authorization_services_model_for_managing_permissions(one of the previous chapters).\n+\n+Under *Authorization* / *Permissions* of `kafka` client you can see already granted permissions that make use of *Resources* and *Policies* defined under the other tabs:\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+`Dev Team A can write to topics that start with x_ on any cluster` combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team A`.\n+\n+`Dev Team B can read from topics that start with x_ on any cluster` combines `Topic:x_*`, and `Group:x_*` resources, scopes `Describe` and `Read`, and `Dev Team B` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team B`. Matching users and clients have the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with `x_`.\n+\n+== Targeting permissions using group or role policies\n+\n+In Keycloak, confidential clients with service accounts enabled can authenticate to the server in their own name using a client ID and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use group policies, and should instead use role policies.\n+Conversely, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the group policies, rather than the role policies.\n+That is what is used for permissions that start with `ClusterManager`.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case, the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+From menu:Clients[kafka>Authorization>Settings] make sure that *Decision Strategy* is set to *Affirmative*, and NOT to *Unanimous*.\n+Navigate in Keycloak to check that the expected resources, authorization claims, policies and permissions are defined.\n+\n+With the configuration in place, we can check access to Kafka by using a producer and consumer to create topics using different user and service accounts.\n+\n+First, a new interactive pod container is run using a Strimzi Kafka image to connect to a running Kafka broker.\n+\n+[source,shell]\n+----\n+kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+----\n+\n+NOTE: If `kubectl` times out waiting on the image download, subsequent attempts may result in an _AlreadyExists_ error. \n+\n+You can attach to the existing pod by running:\n+\n+[source,shell]\n+----\n+kubectl attach -ti kafka-cli\n+----\n+\n+To produce messages as client `team-a-client`, we prepare a Kafka client configuration file with authentication parameters.\n+\n+[source,shell]\n+----\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+----\n+\n+The roles assigned to a client, such as the `Dev Team A` realm role assigned to the `team-a-client` service account, are presented in Keycloak on the  *Service Account Roles* tab from *Clients*.\n+\n+We can use this configuration from the Kafka CLI to produce and consume messages, and perform other administration tasks.\n+\n+\n+.Producing messages with authorized access\n+\n+The `team-a-client` configuration is used to produce messages to topic `my-topic`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+----\n+\n+A `Not authorized to access topics: [my-topic]` error is returned when trying to push the first message.\n+\n+`team-a-client` has a `Dev Team A` role that gives it permission to perform any supported actions on topics that start with `a_`, but can only write to topics that start with `x_`.\n+The topic named `my-topic` matches neither of those rules.\n+\n+The `team-a-client` configuration is then used to produce messages to topic `a_messages`.\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+----\n+\n+The messages are pushed out successfully, and in the Kafka container log there is DEBUG level output saying `Authorization GRANTED`.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+[source,shell]\n+kubectl logs my-cluster-kafka-0 -f\n+\n+.Consuming messages with authorized access\n+\n+The `team-a-client` configuration is used to consume messages from topic `a_messages`:\n+\n+[source,shell,subs=+quotes]\n+----\n+bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --from-beginning --consumer.config /tmp/team-a-client.properties\n+----\n+\n+An error is returned as the `Dev Team A` role for `team-a-client` only has access to consumer groups that have names starting with `a_`.\n+The `team-a-client` configuration is then used to consume messages when specifying a custom consumer group with a name that starts with `a_`:\n+\n+[source,shell,subs=+quotes]\n+----\n+bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+----\n+\n+This time the consumer receives all the messages from the `a_messages` topic.\n+\n+\n+.Administering Kafka with authorized access\n+\n+The `team-a-client` configuration is used in administrative operations.\n+\n+Listing topics returns the `a_messages` topic.\n+\n+[source,shell]\n+----\n+bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+----    \n+\n+Listing consumer groups returns the `a_consumer_group_1` consumer group.\n+\n+[source,shell]\n+----\n+bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+----\n+\n+Fetching the default cluster configuration fails cluster authorization, because the operation requires cluster level permissions that `team-a-client` does not have.\n+\n+[source,shell]\n+----\n+bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+  --entity-type brokers --describe --entity-default\n+----\n+\n+\n+. Using clients with different permissions\n+\n+As with `team-a-client`, we prepare a Kafka client configuration file with authentication parameters for `team-b-client`.\n+\n+[source,shell]\n+----\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+----\n+\n+The `team-b-client` client configuration includes a `Dev Team B` realm role and permissions that start with `Dev Team B ...`. These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with `b_` on the Kafka cluster `my-cluster`, the name of the designated cluster, and read access on topics that start with `x_`.\n+\n+The `team-b-client` configuration is used to produce messages to topic `a_messages`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+----\n+\n+A `Not authorized to access topics: [a_messages]` error is returned when trying to push the first message, as expected, so we switch to topic `b_messages`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+Message 2\n+Message 3\n+----\n+\n+Producing messages to topic `b_messages` is authorized and successful.\n+\n+We switch again, but this time to topic that `team-b-client` can only read from, topic `x_messages`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+----\n+\n+A `Not authorized to access topics: [x_messages]` error is returned, as expected, so we switch to `team-a-client`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+----\n+\n+A `Not authorized to access topics: [x_messages]` error is returned again. Though `team-a-client` can write to the `x_messages` topic, it it does not have a permission to create a topic if it does not yet exist. \n+\n+Before `team-a-client` can write to the `x_messages` topic, a admin _power user_ must create it with the correct configuration, such as the number of partitions and replicas.\n+\n+\n+.Managing Kafka with an authorized admin\n+\n+Admin user `bob` is created with full access to manage everything on the Kafka cluster `my-cluster`.\n+\n+Helper scripts are used to authenticate to the `keycloak` instance.\n+\n+The following scripts are downloaded to `/tmp` dir and made executable:\n+\n+[source,shell]\n+----\n+curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/oauth.sh -s > /tmp/oauth.sh\n+   chmod +x /tmp/oauth.sh\n+\n+curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/jwt.sh -s > /tmp/jwt.sh\n+   chmod +x /tmp/jwt.sh\n+----\n+\n+User `bob` authenticates to the Keycloak server with his username and password to get a refresh token.", "originalCommit": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ5NzI3Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531497273", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            User `bob` can list the topic, but `team-a-client` and `team-b-client` cannot.\n          \n          \n            \n            User `bob` can list the topic, but `team-a-client` and `team-b-client` cannot:", "author": "PaulRMellor", "createdAt": "2020-11-27T09:59:14Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,462 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+The default view usually displays the *Master* realm.\n+For this example we are interested in the `kafka-authz` realm, which you can select in the upper left corner.\n+\n+Initially the *Realm Settings* section is selected, but you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources as explained in xref:keycloak_authorization_services_model_for_managing_permissions(one of the previous chapters).\n+\n+Under *Authorization* / *Permissions* of `kafka` client you can see already granted permissions that make use of *Resources* and *Policies* defined under the other tabs:\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+`Dev Team A can write to topics that start with x_ on any cluster` combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team A`.\n+\n+`Dev Team B can read from topics that start with x_ on any cluster` combines `Topic:x_*`, and `Group:x_*` resources, scopes `Describe` and `Read`, and `Dev Team B` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team B`. Matching users and clients have the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with `x_`.\n+\n+== Targeting permissions using group or role policies\n+\n+In Keycloak, confidential clients with service accounts enabled can authenticate to the server in their own name using a client ID and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use group policies, and should instead use role policies.\n+Conversely, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the group policies, rather than the role policies.\n+That is what is used for permissions that start with `ClusterManager`.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case, the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+From menu:Clients[kafka>Authorization>Settings] make sure that *Decision Strategy* is set to *Affirmative*, and NOT to *Unanimous*.\n+Navigate in Keycloak to check that the expected resources, authorization claims, policies and permissions are defined.\n+\n+With the configuration in place, we can check access to Kafka by using a producer and consumer to create topics using different user and service accounts.\n+\n+First, a new interactive pod container is run using a Strimzi Kafka image to connect to a running Kafka broker.\n+\n+[source,shell]\n+----\n+kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+----\n+\n+NOTE: If `kubectl` times out waiting on the image download, subsequent attempts may result in an _AlreadyExists_ error. \n+\n+You can attach to the existing pod by running:\n+\n+[source,shell]\n+----\n+kubectl attach -ti kafka-cli\n+----\n+\n+To produce messages as client `team-a-client`, we prepare a Kafka client configuration file with authentication parameters.\n+\n+[source,shell]\n+----\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+----\n+\n+The roles assigned to a client, such as the `Dev Team A` realm role assigned to the `team-a-client` service account, are presented in Keycloak on the  *Service Account Roles* tab from *Clients*.\n+\n+We can use this configuration from the Kafka CLI to produce and consume messages, and perform other administration tasks.\n+\n+\n+.Producing messages with authorized access\n+\n+The `team-a-client` configuration is used to produce messages to topic `my-topic`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+----\n+\n+A `Not authorized to access topics: [my-topic]` error is returned when trying to push the first message.\n+\n+`team-a-client` has a `Dev Team A` role that gives it permission to perform any supported actions on topics that start with `a_`, but can only write to topics that start with `x_`.\n+The topic named `my-topic` matches neither of those rules.\n+\n+The `team-a-client` configuration is then used to produce messages to topic `a_messages`.\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+----\n+\n+The messages are pushed out successfully, and in the Kafka container log there is DEBUG level output saying `Authorization GRANTED`.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+[source,shell]\n+kubectl logs my-cluster-kafka-0 -f\n+\n+.Consuming messages with authorized access\n+\n+The `team-a-client` configuration is used to consume messages from topic `a_messages`:\n+\n+[source,shell,subs=+quotes]\n+----\n+bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --from-beginning --consumer.config /tmp/team-a-client.properties\n+----\n+\n+An error is returned as the `Dev Team A` role for `team-a-client` only has access to consumer groups that have names starting with `a_`.\n+The `team-a-client` configuration is then used to consume messages when specifying a custom consumer group with a name that starts with `a_`:\n+\n+[source,shell,subs=+quotes]\n+----\n+bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+----\n+\n+This time the consumer receives all the messages from the `a_messages` topic.\n+\n+\n+.Administering Kafka with authorized access\n+\n+The `team-a-client` configuration is used in administrative operations.\n+\n+Listing topics returns the `a_messages` topic.\n+\n+[source,shell]\n+----\n+bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+----    \n+\n+Listing consumer groups returns the `a_consumer_group_1` consumer group.\n+\n+[source,shell]\n+----\n+bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+----\n+\n+Fetching the default cluster configuration fails cluster authorization, because the operation requires cluster level permissions that `team-a-client` does not have.\n+\n+[source,shell]\n+----\n+bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+  --entity-type brokers --describe --entity-default\n+----\n+\n+\n+. Using clients with different permissions\n+\n+As with `team-a-client`, we prepare a Kafka client configuration file with authentication parameters for `team-b-client`.\n+\n+[source,shell]\n+----\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+----\n+\n+The `team-b-client` client configuration includes a `Dev Team B` realm role and permissions that start with `Dev Team B ...`. These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with `b_` on the Kafka cluster `my-cluster`, the name of the designated cluster, and read access on topics that start with `x_`.\n+\n+The `team-b-client` configuration is used to produce messages to topic `a_messages`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+----\n+\n+A `Not authorized to access topics: [a_messages]` error is returned when trying to push the first message, as expected, so we switch to topic `b_messages`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+Message 2\n+Message 3\n+----\n+\n+Producing messages to topic `b_messages` is authorized and successful.\n+\n+We switch again, but this time to topic that `team-b-client` can only read from, topic `x_messages`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+----\n+\n+A `Not authorized to access topics: [x_messages]` error is returned, as expected, so we switch to `team-a-client`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+----\n+\n+A `Not authorized to access topics: [x_messages]` error is returned again. Though `team-a-client` can write to the `x_messages` topic, it it does not have a permission to create a topic if it does not yet exist. \n+\n+Before `team-a-client` can write to the `x_messages` topic, a admin _power user_ must create it with the correct configuration, such as the number of partitions and replicas.\n+\n+\n+.Managing Kafka with an authorized admin\n+\n+Admin user `bob` is created with full access to manage everything on the Kafka cluster `my-cluster`.\n+\n+Helper scripts are used to authenticate to the `keycloak` instance.\n+\n+The following scripts are downloaded to `/tmp` dir and made executable:\n+\n+[source,shell]\n+----\n+curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/oauth.sh -s > /tmp/oauth.sh\n+   chmod +x /tmp/oauth.sh\n+\n+curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/jwt.sh -s > /tmp/jwt.sh\n+   chmod +x /tmp/jwt.sh\n+----\n+\n+User `bob` authenticates to the Keycloak server with his username and password to get a refresh token.\n+\n+[source,shell]\n+----\n+export TOKEN_ENDPOINT=http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\n+REFRESH_TOKEN=$(/tmp/oauth.sh -q bob)\n+----\n+\n+When prompted for a password, 'bob-password' is used.\n+\n+The refresh token in this case is an offline token which is a long-lived refresh token that does not expire:\n+\n+----\n+ /tmp/jwt.sh $REFRESH_TOKEN\n+----\n+\n+A configuration file is created for `bob`:\n+\n+[source,shell]\n+----\n+cat > /tmp/bob.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.refresh.token=\"$REFRESH_TOKEN\" \\\n+  oauth.client.id=\"kafka-cli\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+----\n+\n+The `kafka-cli` public client is used for the `oauth.client.id` in the `sasl.jaas.config`.\n+Since that is a public client it does not require a Secret.\n+We can use this because we authenticate with a token directly. In this case, the refresh token requests an access token behind the scenes, which is then sent to the Kafka broker for authentication. The refresh token has already been authenticated.\n+\n+\n+User `bob` has permission to create the `x_messages` topic:\n+\n+[source,shell]\n+----\n+bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/bob.properties \\\n+  --topic x_messages --create --replication-factor 1 --partitions 1\n+----\n+\n+\n+User `bob` can list the topic, but `team-a-client` and `team-b-client` cannot.", "originalCommit": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ5NzU2Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531497562", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            To produce messages as client `team-a-client`, we prepare a Kafka client configuration file with authentication parameters.\n          \n          \n            \n            To produce messages as client `team-a-client`, we prepare a Kafka client configuration file with authentication parameters:", "author": "PaulRMellor", "createdAt": "2020-11-27T09:59:44Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,462 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+The default view usually displays the *Master* realm.\n+For this example we are interested in the `kafka-authz` realm, which you can select in the upper left corner.\n+\n+Initially the *Realm Settings* section is selected, but you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources as explained in xref:keycloak_authorization_services_model_for_managing_permissions(one of the previous chapters).\n+\n+Under *Authorization* / *Permissions* of `kafka` client you can see already granted permissions that make use of *Resources* and *Policies* defined under the other tabs:\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+`Dev Team A can write to topics that start with x_ on any cluster` combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team A`.\n+\n+`Dev Team B can read from topics that start with x_ on any cluster` combines `Topic:x_*`, and `Group:x_*` resources, scopes `Describe` and `Read`, and `Dev Team B` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team B`. Matching users and clients have the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with `x_`.\n+\n+== Targeting permissions using group or role policies\n+\n+In Keycloak, confidential clients with service accounts enabled can authenticate to the server in their own name using a client ID and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use group policies, and should instead use role policies.\n+Conversely, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the group policies, rather than the role policies.\n+That is what is used for permissions that start with `ClusterManager`.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case, the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+From menu:Clients[kafka>Authorization>Settings] make sure that *Decision Strategy* is set to *Affirmative*, and NOT to *Unanimous*.\n+Navigate in Keycloak to check that the expected resources, authorization claims, policies and permissions are defined.\n+\n+With the configuration in place, we can check access to Kafka by using a producer and consumer to create topics using different user and service accounts.\n+\n+First, a new interactive pod container is run using a Strimzi Kafka image to connect to a running Kafka broker.\n+\n+[source,shell]\n+----\n+kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+----\n+\n+NOTE: If `kubectl` times out waiting on the image download, subsequent attempts may result in an _AlreadyExists_ error. \n+\n+You can attach to the existing pod by running:\n+\n+[source,shell]\n+----\n+kubectl attach -ti kafka-cli\n+----\n+\n+To produce messages as client `team-a-client`, we prepare a Kafka client configuration file with authentication parameters.", "originalCommit": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ5Nzc1NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531497754", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            As with `team-a-client`, we prepare a Kafka client configuration file with authentication parameters for `team-b-client`.\n          \n          \n            \n            As with `team-a-client`, we prepare a Kafka client configuration file with authentication parameters for `team-b-client`:", "author": "PaulRMellor", "createdAt": "2020-11-27T10:00:04Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,462 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+The default view usually displays the *Master* realm.\n+For this example we are interested in the `kafka-authz` realm, which you can select in the upper left corner.\n+\n+Initially the *Realm Settings* section is selected, but you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources as explained in xref:keycloak_authorization_services_model_for_managing_permissions(one of the previous chapters).\n+\n+Under *Authorization* / *Permissions* of `kafka` client you can see already granted permissions that make use of *Resources* and *Policies* defined under the other tabs:\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+`Dev Team A can write to topics that start with x_ on any cluster` combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team A`.\n+\n+`Dev Team B can read from topics that start with x_ on any cluster` combines `Topic:x_*`, and `Group:x_*` resources, scopes `Describe` and `Read`, and `Dev Team B` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team B`. Matching users and clients have the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with `x_`.\n+\n+== Targeting permissions using group or role policies\n+\n+In Keycloak, confidential clients with service accounts enabled can authenticate to the server in their own name using a client ID and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use group policies, and should instead use role policies.\n+Conversely, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the group policies, rather than the role policies.\n+That is what is used for permissions that start with `ClusterManager`.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case, the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+From menu:Clients[kafka>Authorization>Settings] make sure that *Decision Strategy* is set to *Affirmative*, and NOT to *Unanimous*.\n+Navigate in Keycloak to check that the expected resources, authorization claims, policies and permissions are defined.\n+\n+With the configuration in place, we can check access to Kafka by using a producer and consumer to create topics using different user and service accounts.\n+\n+First, a new interactive pod container is run using a Strimzi Kafka image to connect to a running Kafka broker.\n+\n+[source,shell]\n+----\n+kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+----\n+\n+NOTE: If `kubectl` times out waiting on the image download, subsequent attempts may result in an _AlreadyExists_ error. \n+\n+You can attach to the existing pod by running:\n+\n+[source,shell]\n+----\n+kubectl attach -ti kafka-cli\n+----\n+\n+To produce messages as client `team-a-client`, we prepare a Kafka client configuration file with authentication parameters.\n+\n+[source,shell]\n+----\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+----\n+\n+The roles assigned to a client, such as the `Dev Team A` realm role assigned to the `team-a-client` service account, are presented in Keycloak on the  *Service Account Roles* tab from *Clients*.\n+\n+We can use this configuration from the Kafka CLI to produce and consume messages, and perform other administration tasks.\n+\n+\n+.Producing messages with authorized access\n+\n+The `team-a-client` configuration is used to produce messages to topic `my-topic`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+----\n+\n+A `Not authorized to access topics: [my-topic]` error is returned when trying to push the first message.\n+\n+`team-a-client` has a `Dev Team A` role that gives it permission to perform any supported actions on topics that start with `a_`, but can only write to topics that start with `x_`.\n+The topic named `my-topic` matches neither of those rules.\n+\n+The `team-a-client` configuration is then used to produce messages to topic `a_messages`.\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+----\n+\n+The messages are pushed out successfully, and in the Kafka container log there is DEBUG level output saying `Authorization GRANTED`.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+[source,shell]\n+kubectl logs my-cluster-kafka-0 -f\n+\n+.Consuming messages with authorized access\n+\n+The `team-a-client` configuration is used to consume messages from topic `a_messages`:\n+\n+[source,shell,subs=+quotes]\n+----\n+bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --from-beginning --consumer.config /tmp/team-a-client.properties\n+----\n+\n+An error is returned as the `Dev Team A` role for `team-a-client` only has access to consumer groups that have names starting with `a_`.\n+The `team-a-client` configuration is then used to consume messages when specifying a custom consumer group with a name that starts with `a_`:\n+\n+[source,shell,subs=+quotes]\n+----\n+bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+----\n+\n+This time the consumer receives all the messages from the `a_messages` topic.\n+\n+\n+.Administering Kafka with authorized access\n+\n+The `team-a-client` configuration is used in administrative operations.\n+\n+Listing topics returns the `a_messages` topic.\n+\n+[source,shell]\n+----\n+bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+----    \n+\n+Listing consumer groups returns the `a_consumer_group_1` consumer group.\n+\n+[source,shell]\n+----\n+bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+----\n+\n+Fetching the default cluster configuration fails cluster authorization, because the operation requires cluster level permissions that `team-a-client` does not have.\n+\n+[source,shell]\n+----\n+bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+  --entity-type brokers --describe --entity-default\n+----\n+\n+\n+. Using clients with different permissions\n+\n+As with `team-a-client`, we prepare a Kafka client configuration file with authentication parameters for `team-b-client`.", "originalCommit": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ5ODY1OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531498659", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            == Mapping Keycloak Authorization Services to Kafka Model\n          \n          \n            \n            == Mapping Keycloak Authorization Services to the Kafka authorization model", "author": "PaulRMellor", "createdAt": "2020-11-27T10:01:39Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,317 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Managing policies and permissions in Keycloak Authorization Services\n+\n+== Kafka authorization model for resources\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and the permissions available for each type.\n+When an action is performed by a Kafka client on a broker, the broker uses a configured authorizer to check permissions, depending on the action performed and the resource type.\n+\n+Kafka has five resource types for controlling access: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+Each resource type has different permissions:\n+\n+Topic:\n+\n+* `Create`\n+* `Write`\n+* `Read`\n+* `Delete`\n+* `Describe`\n+* `DescribeConfigs`\n+* `Alter`\n+* `AlterConfigs`\n+\n+Group:\n+\n+* `Read`\n+* `Describe`\n+* `Delete`\n+\n+Cluster:\n+\n+*  `Create`\n+*  `Describe`\n+*  `Alter`\n+*  `DescribeConfigs`\n+*  `AlterConfigs`\n+*  `IdempotentWrite`\n+*  `ClusterAction`\n+\n+TransactionalId:\n+\n+*  `Describe`\n+*  `Write`\n+\n+DelegationToken:\n+\n+* `Describe`\n+\n+== Keycloak Authorization Services model for managing permissions\n+\n+Keycloak Authorization Services use four concepts to define and grant permissions: _resources_, _authorization scopes_, _policies_, and _permissions_.\n+\n+Resources:: Resources are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with the same prefix.\n+The resource definition has a set of available authorization scopes associated with it, which represent a set of all actions available on the particular resource.\n+Often, only a subset of these actions is actually permitted.\n+\n+Authorization scopes:: Authorization scopes is simply a set of all available actions on all the different resource types. When defining a new resource,  scopes are added from the set of all scopes.\n+\n+Policies:: Policies are rules that use criteria to match a list of accounts. Policies can match service accounts based on client id or roles, or user accounts based on username, groups, or roles.\n+\n+Permissions:: Permissions grant a subset of authorization scopes on a specific resource definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model", "originalCommit": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ5OTM2NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531499364", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            .Deleting the topic\n          \n          \n            \n            .Deleting a topic", "author": "PaulRMellor", "createdAt": "2020-11-27T10:02:55Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,317 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Managing policies and permissions in Keycloak Authorization Services\n+\n+== Kafka authorization model for resources\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and the permissions available for each type.\n+When an action is performed by a Kafka client on a broker, the broker uses a configured authorizer to check permissions, depending on the action performed and the resource type.\n+\n+Kafka has five resource types for controlling access: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+Each resource type has different permissions:\n+\n+Topic:\n+\n+* `Create`\n+* `Write`\n+* `Read`\n+* `Delete`\n+* `Describe`\n+* `DescribeConfigs`\n+* `Alter`\n+* `AlterConfigs`\n+\n+Group:\n+\n+* `Read`\n+* `Describe`\n+* `Delete`\n+\n+Cluster:\n+\n+*  `Create`\n+*  `Describe`\n+*  `Alter`\n+*  `DescribeConfigs`\n+*  `AlterConfigs`\n+*  `IdempotentWrite`\n+*  `ClusterAction`\n+\n+TransactionalId:\n+\n+*  `Describe`\n+*  `Write`\n+\n+DelegationToken:\n+\n+* `Describe`\n+\n+== Keycloak Authorization Services model for managing permissions\n+\n+Keycloak Authorization Services use four concepts to define and grant permissions: _resources_, _authorization scopes_, _policies_, and _permissions_.\n+\n+Resources:: Resources are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with the same prefix.\n+The resource definition has a set of available authorization scopes associated with it, which represent a set of all actions available on the particular resource.\n+Often, only a subset of these actions is actually permitted.\n+\n+Authorization scopes:: Authorization scopes is simply a set of all available actions on all the different resource types. When defining a new resource,  scopes are added from the set of all scopes.\n+\n+Policies:: Policies are rules that use criteria to match a list of accounts. Policies can match service accounts based on client id or roles, or user accounts based on username, groups, or roles.\n+\n+Permissions:: Permissions grant a subset of authorization scopes on a specific resource definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+Use Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker to grant Kafka permissions to users or service accounts. Typically, the OAuth client has `kafka` as its client id.\n+\n+The OAuth 2.0 client definition must have the _Authorization Enabled_ option activated.\n+\n+All permissions exist within the scope of this OAuth 2.0 client, which means that if you have different Kafka clusters configured with different OAuth 2.0 client IDs they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client use the _SASL OAUTHBEARER_ mechanism, the Keycloak authorizer (`KeycloakRBACAuthorizer`) retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Introducing authorization scopes\n+\n+Typically, an initial configuration involves uploading the authorization scopes to create a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, you can add authorization scopes manually.\n+\n+The authorization scopes should contain all the possible Kafka permissions regardless of the resource type:\n+\n+* `Create`\n+* `Write`\n+* `Read`\n+* `Delete`\n+* `Describe`\n+* `Alter`\n+* `DescribeConfig`\n+* `AlterConfig`\n+* `ClusterAction`\n+* `IdempotentWrite`\n+\n+.Defining resource patterns for permission checks\n+\n+The resources use pattern names for pattern matching against the targeted resources when performing permission checks.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+.Example patterns for resources\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by `kafka-cluster:CLUSTER_NAME` followed by a comma, where the cluster name refers to the `metadata.name` in the Kafka custom resource.\n+\n+.Example patterns for resources with cluster prefix\n+    kafka-cluster:my-cluster,Topic:*\n+    kafka-cluster:*,Group:b_*\n+\n+When the `kafka-cluster` prefix is not present it is assumed to be `kafka-cluster:*`.\n+\n+When defining a resource, you can associate a list of possible authorization scopes relevant to the resource.\n+Set whatever actions make sense for the targeted resource type.\n+\n+While you may add any authorization scope to any resource, only the scopes supported by the resource type are considered for access control.\n+\n+.Policies\n+\n+Policies are used to target permissions to one or more accounts.\n+Targeting can refer to:\n+* Specific user or service accounts\n+* Realm roles or client roles\n+* User groups\n+* JS rule to match a client IP address\n+\n+A policy is given a unique name, and can be reused to target multiple permissions to multiple resources.\n+\n+.Defining permissions based on scopes, resources and policies \n+\n+Use fine-grained permissions to pull together the policies, resources, and authorization scopes that grant access to users.\n+\n+\n+The name of the each permission should should clearly define what permissions it grants to which users.\n+\n+For more information on how to configure permissions through Keycloak Authorization Services, see xref:con-oauth-authorization-keycloak-example_str[the authorization example].\n+\n+\n+== Example permissions required for operations on Kafka\n+\n+The following  examples demonstrate the permissions required for performing common operations on Kafka.\n+\n+.Creating a topic\n+\n+To create a topic the `Create` permission is required for the specific topic or for `Cluster:kafka-cluster`.\n+\n+[source,shell]\n+----\n+bin/kafka-topics.sh --create --topic my-topic \\\n+  --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config=/tmp/config.properties\n+----\n+\n+.Listing the topic\n+\n+If user has `Describe` permission on the topic, the topic will be listed, otherwise not.\n+\n+[source,shell]\n+----\n+bin/kafka-topics.sh --list \\\n+  --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config=/tmp/config.properties\n+----\n+\n+.Displaying the topic details\n+\n+To display the topic details the `Describe`, and `DescribeConfigs` permissions are required on the topic.\n+\n+[source,shell]\n+----\n+bin/kafka-topics.sh --describe --topic my-topic \\\n+  --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config=/tmp/config.properties\n+----\n+\n+.Producing to the topic\n+\n+To produce to the topic the user needs `Describe` and `Write` permissions on the topic.\n+If topic has not yet been created, and autocreation is enabled, the permissions to create the topic are required.\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh  --topic my-topic \\\n+  --broker-list my-cluster-kafka-bootstrap:9092 --producer.config=/tmp/config.properties\n+----\n+\n+.Consuming from the topic\n+\n+To consume from the topic the user needs `Describe` and `Read` permissions on the topic.\n+Consuming from the topic normally relies on storing the consumer offsets in a consumer group.\n+That requires additional `Describe` and `Read` permissions on the consumer group.\n+\n+Two `resources` are needed for matching. For example:\n+\n+----\n+Topic:my-topic\n+Group:my-group-*\n+----    \n+\n+[source,shell]\n+----\n+bin/kafka-console-consumer.sh --topic my-topic --group my-group-1 --from-beginning \\\n+  --bootstrap-server my-cluster-kafka-bootstrap:9092 --consumer.config /tmp/config.properties\n+----\n+\n+.Producing to the topic using an idempotent producer\n+\n+Besides needing the permissions for ordinary producing to the topic, an additional `IdempotentWrite` permission is required on the `Cluster` resource.\n+\n+Two `resources` are needed for matching. For example:\n+\n+    Topic:my-topic\n+    Cluster:kafka-cluster\n+\n+\n+.Listing consumer groups\n+\n+When listing consumer groups, only the groups on which the user has `Describe` permissions are returned.\n+Alternatively, if the user has `Describe` permission on the `Cluster:kafka-cluster`, all the consumer groups are returned.\n+\n+[source,shell]\n+----\n+bin/kafka-consumer-groups.sh --list \\\n+  --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config=/tmp/config.properties\n+----\n+\n+.Displaying the consumer group details\n+\n+To display the consumer group details the `Describe` permission is required on the group, and on the topic associated with the group.\n+\n+[source,shell]\n+----\n+bin/kafka-consumer-groups.sh --describe --group my-group-1 \\\n+  --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config=/tmp/config.properties\n+----\n+\n+.Changing the topic configuration\n+\n+To change the topic configuration the `Describe` and `Alter` permissions are required on the topic.\n+\n+[source,shell]\n+----\n+bin/kafka-topics.sh --alter --topic my-topic --partitions 2 \\\n+  --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config=/tmp/config.properties\n+----\n+\n+.Displaying the Kafka broker configuration\n+\n+To be able to use `kafka-configs.sh` to get the broker configuration, `DescribeConfigs` permission is required on the `Cluster:kafka-cluster`.\n+\n+[source,shell]\n+----\n+bin/kafka-configs.sh --entity-type brokers --entity-name 0 --describe --all \\\n+  --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config=/tmp/config.properties\n+----\n+\n+.Changing the Kafka broker configuration\n+\n+To change the Kafka broker configuration the 'DescribeConfigs', and `AlterConfigs` permissions are required on `Cluster:kafka-cluster`.\n+\n+[source,shell]\n+----\n+bin/kafka-configs --entity-type brokers --entity-name 0 --alter --add-config log.cleaner.threads=2 \\\n+  --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config=/tmp/config.properties\n+----\n+\n+.Deleting the topic", "originalCommit": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ5OTY4OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531499688", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            .Selecting the leader\n          \n          \n            \n            .Selecting a leader partition", "author": "PaulRMellor", "createdAt": "2020-11-27T10:03:32Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,317 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Managing policies and permissions in Keycloak Authorization Services\n+\n+== Kafka authorization model for resources\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and the permissions available for each type.\n+When an action is performed by a Kafka client on a broker, the broker uses a configured authorizer to check permissions, depending on the action performed and the resource type.\n+\n+Kafka has five resource types for controlling access: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+Each resource type has different permissions:\n+\n+Topic:\n+\n+* `Create`\n+* `Write`\n+* `Read`\n+* `Delete`\n+* `Describe`\n+* `DescribeConfigs`\n+* `Alter`\n+* `AlterConfigs`\n+\n+Group:\n+\n+* `Read`\n+* `Describe`\n+* `Delete`\n+\n+Cluster:\n+\n+*  `Create`\n+*  `Describe`\n+*  `Alter`\n+*  `DescribeConfigs`\n+*  `AlterConfigs`\n+*  `IdempotentWrite`\n+*  `ClusterAction`\n+\n+TransactionalId:\n+\n+*  `Describe`\n+*  `Write`\n+\n+DelegationToken:\n+\n+* `Describe`\n+\n+== Keycloak Authorization Services model for managing permissions\n+\n+Keycloak Authorization Services use four concepts to define and grant permissions: _resources_, _authorization scopes_, _policies_, and _permissions_.\n+\n+Resources:: Resources are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with the same prefix.\n+The resource definition has a set of available authorization scopes associated with it, which represent a set of all actions available on the particular resource.\n+Often, only a subset of these actions is actually permitted.\n+\n+Authorization scopes:: Authorization scopes is simply a set of all available actions on all the different resource types. When defining a new resource,  scopes are added from the set of all scopes.\n+\n+Policies:: Policies are rules that use criteria to match a list of accounts. Policies can match service accounts based on client id or roles, or user accounts based on username, groups, or roles.\n+\n+Permissions:: Permissions grant a subset of authorization scopes on a specific resource definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+Use Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker to grant Kafka permissions to users or service accounts. Typically, the OAuth client has `kafka` as its client id.\n+\n+The OAuth 2.0 client definition must have the _Authorization Enabled_ option activated.\n+\n+All permissions exist within the scope of this OAuth 2.0 client, which means that if you have different Kafka clusters configured with different OAuth 2.0 client IDs they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client use the _SASL OAUTHBEARER_ mechanism, the Keycloak authorizer (`KeycloakRBACAuthorizer`) retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Introducing authorization scopes\n+\n+Typically, an initial configuration involves uploading the authorization scopes to create a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, you can add authorization scopes manually.\n+\n+The authorization scopes should contain all the possible Kafka permissions regardless of the resource type:\n+\n+* `Create`\n+* `Write`\n+* `Read`\n+* `Delete`\n+* `Describe`\n+* `Alter`\n+* `DescribeConfig`\n+* `AlterConfig`\n+* `ClusterAction`\n+* `IdempotentWrite`\n+\n+.Defining resource patterns for permission checks\n+\n+The resources use pattern names for pattern matching against the targeted resources when performing permission checks.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+.Example patterns for resources\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by `kafka-cluster:CLUSTER_NAME` followed by a comma, where the cluster name refers to the `metadata.name` in the Kafka custom resource.\n+\n+.Example patterns for resources with cluster prefix\n+    kafka-cluster:my-cluster,Topic:*\n+    kafka-cluster:*,Group:b_*\n+\n+When the `kafka-cluster` prefix is not present it is assumed to be `kafka-cluster:*`.\n+\n+When defining a resource, you can associate a list of possible authorization scopes relevant to the resource.\n+Set whatever actions make sense for the targeted resource type.\n+\n+While you may add any authorization scope to any resource, only the scopes supported by the resource type are considered for access control.\n+\n+.Policies\n+\n+Policies are used to target permissions to one or more accounts.\n+Targeting can refer to:\n+* Specific user or service accounts\n+* Realm roles or client roles\n+* User groups\n+* JS rule to match a client IP address\n+\n+A policy is given a unique name, and can be reused to target multiple permissions to multiple resources.\n+\n+.Defining permissions based on scopes, resources and policies \n+\n+Use fine-grained permissions to pull together the policies, resources, and authorization scopes that grant access to users.\n+\n+\n+The name of the each permission should should clearly define what permissions it grants to which users.\n+\n+For more information on how to configure permissions through Keycloak Authorization Services, see xref:con-oauth-authorization-keycloak-example_str[the authorization example].\n+\n+\n+== Example permissions required for operations on Kafka\n+\n+The following  examples demonstrate the permissions required for performing common operations on Kafka.\n+\n+.Creating a topic\n+\n+To create a topic the `Create` permission is required for the specific topic or for `Cluster:kafka-cluster`.\n+\n+[source,shell]\n+----\n+bin/kafka-topics.sh --create --topic my-topic \\\n+  --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config=/tmp/config.properties\n+----\n+\n+.Listing the topic\n+\n+If user has `Describe` permission on the topic, the topic will be listed, otherwise not.\n+\n+[source,shell]\n+----\n+bin/kafka-topics.sh --list \\\n+  --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config=/tmp/config.properties\n+----\n+\n+.Displaying the topic details\n+\n+To display the topic details the `Describe`, and `DescribeConfigs` permissions are required on the topic.\n+\n+[source,shell]\n+----\n+bin/kafka-topics.sh --describe --topic my-topic \\\n+  --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config=/tmp/config.properties\n+----\n+\n+.Producing to the topic\n+\n+To produce to the topic the user needs `Describe` and `Write` permissions on the topic.\n+If topic has not yet been created, and autocreation is enabled, the permissions to create the topic are required.\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh  --topic my-topic \\\n+  --broker-list my-cluster-kafka-bootstrap:9092 --producer.config=/tmp/config.properties\n+----\n+\n+.Consuming from the topic\n+\n+To consume from the topic the user needs `Describe` and `Read` permissions on the topic.\n+Consuming from the topic normally relies on storing the consumer offsets in a consumer group.\n+That requires additional `Describe` and `Read` permissions on the consumer group.\n+\n+Two `resources` are needed for matching. For example:\n+\n+----\n+Topic:my-topic\n+Group:my-group-*\n+----    \n+\n+[source,shell]\n+----\n+bin/kafka-console-consumer.sh --topic my-topic --group my-group-1 --from-beginning \\\n+  --bootstrap-server my-cluster-kafka-bootstrap:9092 --consumer.config /tmp/config.properties\n+----\n+\n+.Producing to the topic using an idempotent producer\n+\n+Besides needing the permissions for ordinary producing to the topic, an additional `IdempotentWrite` permission is required on the `Cluster` resource.\n+\n+Two `resources` are needed for matching. For example:\n+\n+    Topic:my-topic\n+    Cluster:kafka-cluster\n+\n+\n+.Listing consumer groups\n+\n+When listing consumer groups, only the groups on which the user has `Describe` permissions are returned.\n+Alternatively, if the user has `Describe` permission on the `Cluster:kafka-cluster`, all the consumer groups are returned.\n+\n+[source,shell]\n+----\n+bin/kafka-consumer-groups.sh --list \\\n+  --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config=/tmp/config.properties\n+----\n+\n+.Displaying the consumer group details\n+\n+To display the consumer group details the `Describe` permission is required on the group, and on the topic associated with the group.\n+\n+[source,shell]\n+----\n+bin/kafka-consumer-groups.sh --describe --group my-group-1 \\\n+  --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config=/tmp/config.properties\n+----\n+\n+.Changing the topic configuration\n+\n+To change the topic configuration the `Describe` and `Alter` permissions are required on the topic.\n+\n+[source,shell]\n+----\n+bin/kafka-topics.sh --alter --topic my-topic --partitions 2 \\\n+  --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config=/tmp/config.properties\n+----\n+\n+.Displaying the Kafka broker configuration\n+\n+To be able to use `kafka-configs.sh` to get the broker configuration, `DescribeConfigs` permission is required on the `Cluster:kafka-cluster`.\n+\n+[source,shell]\n+----\n+bin/kafka-configs.sh --entity-type brokers --entity-name 0 --describe --all \\\n+  --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config=/tmp/config.properties\n+----\n+\n+.Changing the Kafka broker configuration\n+\n+To change the Kafka broker configuration the 'DescribeConfigs', and `AlterConfigs` permissions are required on `Cluster:kafka-cluster`.\n+\n+[source,shell]\n+----\n+bin/kafka-configs --entity-type brokers --entity-name 0 --alter --add-config log.cleaner.threads=2 \\\n+  --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config=/tmp/config.properties\n+----\n+\n+.Deleting the topic\n+\n+To delete the topic the `Describe`, and `Delete` permissions are required on the topic.\n+\n+[source,shell]\n+----\n+bin/kafka-topics.sh --delete --topic my-topic \\\n+  --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config=/tmp/config.properties\n+----\n+\n+.Selecting the leader", "originalCommit": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTUwMDM2MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531500360", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n          \n          \n            \n            We then connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.", "author": "PaulRMellor", "createdAt": "2020-11-27T10:04:44Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,462 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.", "originalCommit": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTUwMDU1NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531500555", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n          \n          \n            \n            Finally, we connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.", "author": "PaulRMellor", "createdAt": "2020-11-27T10:05:06Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,462 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.", "originalCommit": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTUwMDczNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531500736", "bodyText": "These might work better as bullets", "author": "PaulRMellor", "createdAt": "2020-11-27T10:05:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTUwMDU1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTUyMjQ5MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531522491", "bodyText": "I leave that to you :)", "author": "mstruk", "createdAt": "2020-11-27T10:42:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTUwMDU1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTUxNDE0OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531514148", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            User `bob` should can read from or write to any topic:\n          \n          \n            \n            User `bob` can read from or write to any topic:", "author": "mstruk", "createdAt": "2020-11-27T10:29:53Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,462 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+The default view usually displays the *Master* realm.\n+For this example we are interested in the `kafka-authz` realm, which you can select in the upper left corner.\n+\n+Initially the *Realm Settings* section is selected, but you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources as explained in xref:keycloak_authorization_services_model_for_managing_permissions(one of the previous chapters).\n+\n+Under *Authorization* / *Permissions* of `kafka` client you can see already granted permissions that make use of *Resources* and *Policies* defined under the other tabs:\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+`Dev Team A can write to topics that start with x_ on any cluster` combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team A`.\n+\n+`Dev Team B can read from topics that start with x_ on any cluster` combines `Topic:x_*`, and `Group:x_*` resources, scopes `Describe` and `Read`, and `Dev Team B` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team B`. Matching users and clients have the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with `x_`.\n+\n+== Targeting permissions using group or role policies\n+\n+In Keycloak, confidential clients with service accounts enabled can authenticate to the server in their own name using a client ID and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use group policies, and should instead use role policies.\n+Conversely, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the group policies, rather than the role policies.\n+That is what is used for permissions that start with `ClusterManager`.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case, the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+From menu:Clients[kafka>Authorization>Settings] make sure that *Decision Strategy* is set to *Affirmative*, and NOT to *Unanimous*.\n+Navigate in Keycloak to check that the expected resources, authorization claims, policies and permissions are defined.\n+\n+With the configuration in place, we can check access to Kafka by using a producer and consumer to create topics using different user and service accounts.\n+\n+First, a new interactive pod container is run using a Strimzi Kafka image to connect to a running Kafka broker.\n+\n+[source,shell]\n+----\n+kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+----\n+\n+NOTE: If `kubectl` times out waiting on the image download, subsequent attempts may result in an _AlreadyExists_ error. \n+\n+You can attach to the existing pod by running:\n+\n+[source,shell]\n+----\n+kubectl attach -ti kafka-cli\n+----\n+\n+To produce messages as client `team-a-client`, we prepare a Kafka client configuration file with authentication parameters.\n+\n+[source,shell]\n+----\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+----\n+\n+The roles assigned to a client, such as the `Dev Team A` realm role assigned to the `team-a-client` service account, are presented in Keycloak on the  *Service Account Roles* tab from *Clients*.\n+\n+We can use this configuration from the Kafka CLI to produce and consume messages, and perform other administration tasks.\n+\n+\n+.Producing messages with authorized access\n+\n+The `team-a-client` configuration is used to produce messages to topic `my-topic`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+----\n+\n+A `Not authorized to access topics: [my-topic]` error is returned when trying to push the first message.\n+\n+`team-a-client` has a `Dev Team A` role that gives it permission to perform any supported actions on topics that start with `a_`, but can only write to topics that start with `x_`.\n+The topic named `my-topic` matches neither of those rules.\n+\n+The `team-a-client` configuration is then used to produce messages to topic `a_messages`.\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+----\n+\n+The messages are pushed out successfully, and in the Kafka container log there is DEBUG level output saying `Authorization GRANTED`.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+[source,shell]\n+kubectl logs my-cluster-kafka-0 -f\n+\n+.Consuming messages with authorized access\n+\n+The `team-a-client` configuration is used to consume messages from topic `a_messages`:\n+\n+[source,shell,subs=+quotes]\n+----\n+bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --from-beginning --consumer.config /tmp/team-a-client.properties\n+----\n+\n+An error is returned as the `Dev Team A` role for `team-a-client` only has access to consumer groups that have names starting with `a_`.\n+The `team-a-client` configuration is then used to consume messages when specifying a custom consumer group with a name that starts with `a_`:\n+\n+[source,shell,subs=+quotes]\n+----\n+bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+----\n+\n+This time the consumer receives all the messages from the `a_messages` topic.\n+\n+\n+.Administering Kafka with authorized access\n+\n+The `team-a-client` configuration is used in administrative operations.\n+\n+Listing topics returns the `a_messages` topic.\n+\n+[source,shell]\n+----\n+bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+----    \n+\n+Listing consumer groups returns the `a_consumer_group_1` consumer group.\n+\n+[source,shell]\n+----\n+bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+----\n+\n+Fetching the default cluster configuration fails cluster authorization, because the operation requires cluster level permissions that `team-a-client` does not have.\n+\n+[source,shell]\n+----\n+bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+  --entity-type brokers --describe --entity-default\n+----\n+\n+\n+. Using clients with different permissions\n+\n+As with `team-a-client`, we prepare a Kafka client configuration file with authentication parameters for `team-b-client`.\n+\n+[source,shell]\n+----\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+----\n+\n+The `team-b-client` client configuration includes a `Dev Team B` realm role and permissions that start with `Dev Team B ...`. These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with `b_` on the Kafka cluster `my-cluster`, the name of the designated cluster, and read access on topics that start with `x_`.\n+\n+The `team-b-client` configuration is used to produce messages to topic `a_messages`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+----\n+\n+A `Not authorized to access topics: [a_messages]` error is returned when trying to push the first message, as expected, so we switch to topic `b_messages`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+Message 2\n+Message 3\n+----\n+\n+Producing messages to topic `b_messages` is authorized and successful.\n+\n+We switch again, but this time to topic that `team-b-client` can only read from, topic `x_messages`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+----\n+\n+A `Not authorized to access topics: [x_messages]` error is returned, as expected, so we switch to `team-a-client`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+----\n+\n+A `Not authorized to access topics: [x_messages]` error is returned again. Though `team-a-client` can write to the `x_messages` topic, it it does not have a permission to create a topic if it does not yet exist. \n+\n+Before `team-a-client` can write to the `x_messages` topic, a admin _power user_ must create it with the correct configuration, such as the number of partitions and replicas.\n+\n+\n+.Managing Kafka with an authorized admin\n+\n+Admin user `bob` is created with full access to manage everything on the Kafka cluster `my-cluster`.\n+\n+Helper scripts are used to authenticate to the `keycloak` instance.\n+\n+The following scripts are downloaded to `/tmp` dir and made executable:\n+\n+[source,shell]\n+----\n+curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/oauth.sh -s > /tmp/oauth.sh\n+   chmod +x /tmp/oauth.sh\n+\n+curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/jwt.sh -s > /tmp/jwt.sh\n+   chmod +x /tmp/jwt.sh\n+----\n+\n+User `bob` authenticates to the Keycloak server with his username and password to get a refresh token.\n+\n+[source,shell]\n+----\n+export TOKEN_ENDPOINT=http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\n+REFRESH_TOKEN=$(/tmp/oauth.sh -q bob)\n+----\n+\n+When prompted for a password, 'bob-password' is used.\n+\n+The refresh token in this case is an offline token which is a long-lived refresh token that does not expire:\n+\n+----\n+ /tmp/jwt.sh $REFRESH_TOKEN\n+----\n+\n+A configuration file is created for `bob`:\n+\n+[source,shell]\n+----\n+cat > /tmp/bob.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.refresh.token=\"$REFRESH_TOKEN\" \\\n+  oauth.client.id=\"kafka-cli\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+----\n+\n+The `kafka-cli` public client is used for the `oauth.client.id` in the `sasl.jaas.config`.\n+Since that is a public client it does not require a Secret.\n+We can use this because we authenticate with a token directly. In this case, the refresh token requests an access token behind the scenes, which is then sent to the Kafka broker for authentication. The refresh token has already been authenticated.\n+\n+\n+User `bob` has permission to create the `x_messages` topic:\n+\n+[source,shell]\n+----\n+bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/bob.properties \\\n+  --topic x_messages --create --replication-factor 1 --partitions 1\n+----\n+\n+\n+User `bob` can list the topic, but `team-a-client` and `team-b-client` cannot.\n+\n+[source,shell]\n+----\n+bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/bob.properties --list\n+bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-b-client.properties --list\n+----\n+\n+The `Dev Team A`, and `Dev Team B` roles both have `Describe` permission on topics that start with `x_`, but they cannot see the other team's topics as they do not have `Describe` permissions on them.\n+\n+The `team-a-client` can now successfully produce to the `x_messages` topic:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+Message 2\n+Message 3\n+----\n+\n+As expected, `team-b-client` still cannot produce to the `x_messages` topic, and the following operation returns an error:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 4\n+Message 5\n+----\n+\n+However, due to its Keycloak settings `team-b-client` can consume messages from the `x_messages` topic:\n+\n+[source,shell]\n+----\n+bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --from-beginning --consumer.config /tmp/team-b-client.properties --group x_consumer_group_b\n+----\n+Conversely, even though `team-a-client` can write to topic `x_messages`, the following read request returns a `Not authorized to access group: x_consumer_group_a` error:\n+\n+[source,shell]\n+----\n+bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --from-beginning --consumer.config /tmp/team-a-client.properties --group x_consumer_group_a\n+----\n+\n+A consumer group that begins with `a_` is used in the next read request:\n+\n+[source,shell]\n+----\n+bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_a\n+----\n+\n+An error is still returned, but this time it is `Not authorized to access topics: [x_messages]`.\n+\n+`Dev Team A` has no `Read` access on topics that start with 'x_'.\n+\n+User `bob` should can read from or write to any topic:", "originalCommit": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d1561e8e0c1484ffcf85978873369348f2b4f92c", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/d1561e8e0c1484ffcf85978873369348f2b4f92c", "message": "Apply suggestions from code review\n\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2020-12-08T22:23:47Z", "type": "forcePushed"}, {"oid": "147eb37597a702d2d77ee065e4bc7da8d40600ce", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/147eb37597a702d2d77ee065e4bc7da8d40600ce", "message": "Update documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc\n\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2020-12-08T22:31:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIxNjk4MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r539216980", "bodyText": "Is this change still needed? I think the issue was fixed in #3988 in the meantime.", "author": "scholzj", "createdAt": "2020-12-09T11:11:05Z", "path": ".azure/scripts/check_docs.sh", "diffHunk": "@@ -25,7 +25,7 @@ function grep_check {\n # Check for latin abbrevs\n grep_check '[^[:alpha:]](e\\.g\\.|eg)[^[:alpha:]]' \"Replace 'e.g'. with 'for example, '\"\n grep_check '[^[:alpha:]](i\\.e\\.|ie)[^[:alpha:]]' \"Replace 'i.e'. with 'that is, '\"\n-grep_check '[^[:alpha:]]etc\\.[^[:alpha:]]?' \"Replace 'etc.'. with ' and so on.'\"\n+grep_check '[^[:alpha:]]etc[\\.\\n\\r\\s]' \"Replace 'etc.'. with ' and so on.'\"", "originalCommit": "147eb37597a702d2d77ee065e4bc7da8d40600ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQxMjU4Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r539412582", "bodyText": "Looks like with #3988 it's not needed. I'll rebase the PR ...", "author": "mstruk", "createdAt": "2020-12-09T15:39:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIxNjk4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIyMDMxMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r539220310", "bodyText": "I'm not sure we want to have this in the documentation. The installation should just link to Keycloak docs. That makes it clear that it is their responsibility. I think this docs should just start from the assumption that the user installed Keycloak with whatever their preferred method is.\nAnd even if others think it should be here, it should definitely:\n\nnot point to master but needs to point to a tag with the release used in given Strimzi release.\nHave a clear warning that this is not any secure production deployment.", "author": "scholzj", "createdAt": "2020-12-09T11:16:18Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,461 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We then connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token-based authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization, a custom authorizer is configured on the Kafka broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting the pods", "originalCommit": "147eb37597a702d2d77ee065e4bc7da8d40600ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQyNDA5Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r539424093", "bodyText": "This is an example of integration of Kafka with Keycloak, and the yamls are specifically configured to automatically import example realms that the example needs in order to work. These yamls are part of strimzi-kafka-oauth examples. If you have no ready-made way to set up the example as it was intended, then this whole chapter is quite useless. And Strimzi example is not a concern of the Keycloak project. Also, the example chapter is really the reason for this PR. There is no Kubernetes based example anywhere else.\nPointing to a release tag is a great idea. Is there a mechanism in place that allows this, or is it something we have to develop?\nWe can also add a warning about this being just an insecure example, sure.", "author": "mstruk", "createdAt": "2020-12-09T15:52:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIyMDMxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwMTYyMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r539601622", "bodyText": "This is an example of integration of Kafka with Keycloak, and the yamls are specifically configured to automatically import example realms that the example needs in order to work.\n\nI'm not sure this helps to be honest. Because you give them ready to use environment to play with it, but then you tell them that this is for nothing else then playing. So they would need to deploy it differently and then they would not know how to import the things?\n\nPointing to a release tag is a great idea. Is there a mechanism in place that allows this, or is it something we have to develop?\n\nThere is variable oauth-artifact-version which should have the OAuth library version (which is the same as GitHub tag).\n\nWe can also add a warning about this being just an insecure example, sure.\n\nNot just insecure, but mainly not production ready. So I guess the warning should be for both.", "author": "scholzj", "createdAt": "2020-12-09T19:53:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIyMDMxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ0MjE2OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r554442168", "bodyText": "@mstruk Can you look at this so that we can merge this?", "author": "scholzj", "createdAt": "2021-01-09T16:01:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIyMDMxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTA0MTk5MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r555041990", "bodyText": "There's several issues mentioned here:\n\nthis content should in your opinion not be here - there should be a pointer to Keycloak documentation and then just instructions on how to import the realms. Problem: Importing the realm is only possible by mounting the realm file in yaml and deploying a new pod definition - it can not be done through UI on the existing running Keycloak instance because all the passwords, and secrets are lost in that case. But then the existing instructions do just that.\nneed to use the oauth-artifact-version variable\nadd warnings\n\nWould addressing the last two issues be good enough?", "author": "mstruk", "createdAt": "2021-01-11T13:22:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIyMDMxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTA0OTkyMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r555049920", "bodyText": "I guess I gave up on the first point I guess. WDYT @strimzi/maintainers?\nThe second and third point should be fixed.", "author": "scholzj", "createdAt": "2021-01-11T13:35:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIyMDMxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjcyMzQ5NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r556723495", "bodyText": "Added the variables, and a caution note.", "author": "mstruk", "createdAt": "2021-01-13T18:00:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIyMDMxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIyMjYxMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r539222613", "bodyText": "Is this replaced with the right tag at release time? I think it needs to enable replacing variables in the snipper and use some variable which is fixed at release time to create stabel documentation.", "author": "scholzj", "createdAt": "2020-12-09T11:20:00Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,461 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We then connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token-based authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization, a custom authorizer is configured on the Kafka broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting the pods\n+\n+For this example, we use the kubernetes deployment scripts available at https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes:\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on the Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+We login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Then we use a browser to connect to `http://localhost:8080/auth/admin` using `admin` as username and password.\n+\n+The default view usually displays the *Master* realm.\n+For this example we are interested in the `kafka-authz` realm, which you can select in the upper left corner.\n+\n+Initially, the *Realm Settings* section is selected, but you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak, groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, you can view all defined users. For this example, `alice` and `bob` are defined. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak, users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations. For this eaxmple,  `kafka`, `kafka-cli`, `team-a-client`, `team-b-client` are configured.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources, as explained in xref:keycloak_authorization_services_model_for_managing_permissions[Keycloak Authorization Services model for managing permissions].\n+\n+From *Authorization* / *Permissions* you can see the granted permissions that use resources and policies defined from other *Resources* and *Policies* tabs. For example, the `kafka` client has the following permissions:\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+`Dev Team A can write to topics that start with x_ on any cluster` combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team A`.\n+\n+`Dev Team B can read from topics that start with x_ on any cluster` combines `Topic:x_*`, and `Group:x_*` resources, scopes `Describe` and `Read`, and `Dev Team B` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team B`. Matching users and clients have the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with `x_`.\n+\n+== Targeting permissions using group or role policies\n+\n+In Keycloak, confidential clients with service accounts enabled can authenticate to the server in their own name using a client ID and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use group policies, and should instead use role policies.\n+Conversely, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the group policies, rather than the role policies.\n+That is what is used for permissions that start with `ClusterManager`.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case, the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in action using CLI clients\n+\n+Make sure that authorization rules have been properly imported.\n+\n+From menu:Clients[kafka>Authorization>Settings] make sure that *Decision Strategy* is set to *Affirmative*, and NOT to *Unanimous*.\n+Navigate in Keycloak to check that the expected resources, authorization claims, policies and permissions are defined.\n+\n+With the configuration in place, we can check access to Kafka by using a producer and consumer to create topics using different user and service accounts.\n+\n+First, a new interactive pod container is run using a Strimzi Kafka image to connect to a running Kafka broker.\n+\n+[source,shell]\n+----\n+kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh", "originalCommit": "147eb37597a702d2d77ee065e4bc7da8d40600ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQyNTAxNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r539425017", "bodyText": "Do we have a mechanism like that for the docs?", "author": "mstruk", "createdAt": "2020-12-09T15:53:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIyMjYxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5OTEyNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r539599126", "bodyText": "There is variable DockerKafkaImageCurrent which this. So you need to enable the variable substitution and use something like this:\nkubectl run -ti --rm --restart=Never --image={DockerKafkaImageCurrent}", "author": "scholzj", "createdAt": "2020-12-09T19:49:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIyMjYxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ0MjE1Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r554442157", "bodyText": "@mstruk Can you look at this so that we can merge this?", "author": "scholzj", "createdAt": "2021-01-09T16:01:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIyMjYxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTA0Mjk0MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r555042941", "bodyText": "Ok, here it's just replacing the constants with a variable.", "author": "mstruk", "createdAt": "2021-01-11T13:24:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIyMjYxMw=="}], "type": "inlineReview"}, {"oid": "eb4ee27a918ec58e34926c6aaaf034bbf74ab422", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/eb4ee27a918ec58e34926c6aaaf034bbf74ab422", "message": "Fixed by #3988\n\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2020-12-09T15:54:43Z", "type": "forcePushed"}, {"oid": "e623d3efb2084485faaba00e3796ac23ed2d0e26", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/e623d3efb2084485faaba00e3796ac23ed2d0e26", "message": "Additional 'keycloak' authorization docs\n\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T16:03:30Z", "type": "commit"}, {"oid": "cf32b72a4c95bbd597c6773a0d75059085d8f1eb", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/cf32b72a4c95bbd597c6773a0d75059085d8f1eb", "message": "Fixes and improvements\n\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T16:03:30Z", "type": "commit"}, {"oid": "894aa7de4cabeb671cfa2ba83959157f4857c987", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/894aa7de4cabeb671cfa2ba83959157f4857c987", "message": "Fixes and improvements\n\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T16:03:31Z", "type": "commit"}, {"oid": "8ecd4e048095bf71111b364df69a7715f909066f", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/8ecd4e048095bf71111b364df69a7715f909066f", "message": "Fixes and improvements\n\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T16:03:31Z", "type": "commit"}, {"oid": "92b80ccc4f72cd8acba7e7aa84fcb367188d5220", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/92b80ccc4f72cd8acba7e7aa84fcb367188d5220", "message": "Fixes and improvements\n\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T16:03:31Z", "type": "commit"}, {"oid": "311d1f17e57f1db19da26a4a24d2d2d335418162", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/311d1f17e57f1db19da26a4a24d2d2d335418162", "message": "Apply suggestions from code review\n\nCo-authored-by: PaulRMellor <47596553+PaulRMellor@users.noreply.github.com>\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T16:03:31Z", "type": "commit"}, {"oid": "b816d864f2afad5cb0e69931f66d9399ce296b9d", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/b816d864f2afad5cb0e69931f66d9399ce296b9d", "message": "Update documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc\n\nCo-authored-by: PaulRMellor <47596553+PaulRMellor@users.noreply.github.com>\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T16:03:31Z", "type": "commit"}, {"oid": "33266bb3cd0b74a069de7e3718fa1a6f8d87bc5f", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/33266bb3cd0b74a069de7e3718fa1a6f8d87bc5f", "message": "Apply suggestions from code review\n\nCo-authored-by: PaulRMellor <47596553+PaulRMellor@users.noreply.github.com>\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T16:03:31Z", "type": "commit"}, {"oid": "ab3180528dd6df5ddaf92424f88483a98e3fce09", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/ab3180528dd6df5ddaf92424f88483a98e3fce09", "message": "Apply suggestions from code review\n\nCo-authored-by: PaulRMellor <47596553+PaulRMellor@users.noreply.github.com>\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T16:03:31Z", "type": "commit"}, {"oid": "7b044179abdd904c8938330492f52aeea192f42c", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/7b044179abdd904c8938330492f52aeea192f42c", "message": "Fixes and improvements\n\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T16:03:31Z", "type": "commit"}, {"oid": "994408d41d07b924ca2180b4ad9ae27b70b34228", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/994408d41d07b924ca2180b4ad9ae27b70b34228", "message": "Apply suggestions from code review\n\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T16:03:31Z", "type": "commit"}, {"oid": "14d9fde57beed501943f1f6cc5161d5b8ab9a25e", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/14d9fde57beed501943f1f6cc5161d5b8ab9a25e", "message": "Fixes and improvements\n\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T16:03:31Z", "type": "commit"}, {"oid": "91f1e23c73460491e0de3b5951bad15e1662c5ec", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/91f1e23c73460491e0de3b5951bad15e1662c5ec", "message": "Apply suggestions from code review\n\nCo-authored-by: PaulRMellor <47596553+PaulRMellor@users.noreply.github.com>\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T16:03:31Z", "type": "commit"}, {"oid": "0689b99f97efdb254cd679283e127c56700aa87a", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/0689b99f97efdb254cd679283e127c56700aa87a", "message": "Apply suggestions from code review\n\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T16:03:31Z", "type": "commit"}, {"oid": "2e3bd9dfc51b42498f0d00fa644f9ffc1bd4adea", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/2e3bd9dfc51b42498f0d00fa644f9ffc1bd4adea", "message": "Update documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc\n\nCo-authored-by: PaulRMellor <47596553+PaulRMellor@users.noreply.github.com>\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T16:03:31Z", "type": "commit"}, {"oid": "53926bb5f2542354ddc0e3e68990643ae466651a", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/53926bb5f2542354ddc0e3e68990643ae466651a", "message": "Apply suggestions from code review\n\nCo-authored-by: PaulRMellor <47596553+PaulRMellor@users.noreply.github.com>\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T16:03:31Z", "type": "commit"}, {"oid": "2c89afe3b065edee37221e30dda28f19cda028ba", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/2c89afe3b065edee37221e30dda28f19cda028ba", "message": "Apply suggestions from code review\n\nCo-authored-by: PaulRMellor <47596553+PaulRMellor@users.noreply.github.com>\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T16:03:31Z", "type": "commit"}, {"oid": "4a4879611715e9fb73fb387265906feedc8992b7", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/4a4879611715e9fb73fb387265906feedc8992b7", "message": "Apply suggestions from code review\n\nCo-authored-by: PaulRMellor <47596553+PaulRMellor@users.noreply.github.com>\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T16:03:31Z", "type": "commit"}, {"oid": "5205226d31c0f0439da67cfe092ce071d9f11658", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/5205226d31c0f0439da67cfe092ce071d9f11658", "message": "Apply suggestions from code review\n\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T16:03:31Z", "type": "commit"}, {"oid": "8aa11da6f0bf9e5b09174200b6f87c22b103f03c", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/8aa11da6f0bf9e5b09174200b6f87c22b103f03c", "message": "Apply suggestions from code review\n\nCo-authored-by: PaulRMellor <47596553+PaulRMellor@users.noreply.github.com>\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T16:03:32Z", "type": "commit"}, {"oid": "ac1b042290b73ea8bafb6d1f0f309be3ec0f2094", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/ac1b042290b73ea8bafb6d1f0f309be3ec0f2094", "message": "Fixes and improvements\n\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T16:03:32Z", "type": "commit"}, {"oid": "44813f02fbca07272793619a931440add9da4736", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/44813f02fbca07272793619a931440add9da4736", "message": "Apply suggestions from code review\n\nCo-authored-by: PaulRMellor <47596553+PaulRMellor@users.noreply.github.com>\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T16:03:32Z", "type": "commit"}, {"oid": "0fe32e69331c0a991243bd2094b0630bcc6cb7c6", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/0fe32e69331c0a991243bd2094b0630bcc6cb7c6", "message": "Update documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc\n\nCo-authored-by: PaulRMellor <47596553+PaulRMellor@users.noreply.github.com>\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T16:03:32Z", "type": "commit"}, {"oid": "3a4d82bf283f34b065e824deffb980a1c37627be", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/3a4d82bf283f34b065e824deffb980a1c37627be", "message": "Update documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc\n\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T16:03:32Z", "type": "commit"}, {"oid": "7941001e382a6a1ae2856fe66d66b7df03c462c2", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/7941001e382a6a1ae2856fe66d66b7df03c462c2", "message": "Fix missing end-of-codeblock\n\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T16:03:32Z", "type": "commit"}, {"oid": "a6c727288f146e6b058ca7433ab62f3495c4a915", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/a6c727288f146e6b058ca7433ab62f3495c4a915", "message": "Add more permissions examples\n\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T16:03:32Z", "type": "commit"}, {"oid": "f1876f5fc6d2f7157adb6dbb619550efa7ae8e2b", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/f1876f5fc6d2f7157adb6dbb619550efa7ae8e2b", "message": "Address the last TODOs\n\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T16:03:32Z", "type": "commit"}, {"oid": "76626dae2c4aa390e39d0f87d8256405247bdd9f", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/76626dae2c4aa390e39d0f87d8256405247bdd9f", "message": "Apply suggestions from code review\n\nCo-authored-by: PaulRMellor <47596553+PaulRMellor@users.noreply.github.com>\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T16:03:32Z", "type": "commit"}, {"oid": "5c6ea4ff9821d07400e7a732d4b2ef416d57ea87", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/5c6ea4ff9821d07400e7a732d4b2ef416d57ea87", "message": "Apply suggestions from code review\n\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T16:03:32Z", "type": "commit"}, {"oid": "3c449e9bc3d5e26d89ee1562ab5d35eb54ed94f9", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/3c449e9bc3d5e26d89ee1562ab5d35eb54ed94f9", "message": "Update documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc\n\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T16:03:32Z", "type": "commit"}, {"oid": "23ccb4d7ba7bcc54e46e2e981907a7496a601895", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/23ccb4d7ba7bcc54e46e2e981907a7496a601895", "message": "Fixed by #3988\n\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T16:03:32Z", "type": "commit"}, {"oid": "67a4788b4021a888ea3b46edeea10ba1da2b516d", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/67a4788b4021a888ea3b46edeea10ba1da2b516d", "message": "Add variables, and variable expansion to point to the latest released versions\n\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T17:09:02Z", "type": "commit"}, {"oid": "67a4788b4021a888ea3b46edeea10ba1da2b516d", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/67a4788b4021a888ea3b46edeea10ba1da2b516d", "message": "Add variables, and variable expansion to point to the latest released versions\n\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T17:09:02Z", "type": "forcePushed"}, {"oid": "15c2c4fab69163c88c23e61f131ea16b953be9d1", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/15c2c4fab69163c88c23e61f131ea16b953be9d1", "message": "Add a warning about the example not being production-level secure\n\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2021-01-13T17:51:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQyNjEyMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529426121", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `Resources` define _what_ we are protecting from unauthorized access.\n          \n          \n            \n            Resources define _what_ we are protecting from unauthorized access.", "author": "PaulRMellor", "createdAt": "2020-11-24T10:34:13Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQyNjg3NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529426875", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n          \n          \n            \n            Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.", "author": "PaulRMellor", "createdAt": "2020-11-24T10:34:48Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQyNzM2MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529427361", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n          \n          \n            \n            Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.", "author": "PaulRMellor", "createdAt": "2020-11-24T10:35:13Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQyOTYwMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529429603", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n          \n          \n            \n            Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.", "author": "PaulRMellor", "createdAt": "2020-11-24T10:37:11Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQzNTI5OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529435298", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n          \n          \n            \n            For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.", "author": "PaulRMellor", "createdAt": "2020-11-24T10:41:52Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQzNTc1OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529435758", "bodyText": "We have an attribute for this link.", "author": "PaulRMellor", "createdAt": "2020-11-24T10:42:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQzNTI5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQzOTQyNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529439426", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n          \n          \n            \n            These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n          \n          \n            \n            The format is quite simple. For example:\n          \n          \n            \n            When viewing resources from the Keycloak user interface you will see a list of resource definitions.\n          \n          \n            \n            These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.\n          \n          \n            \n            For example, this pattern targets only topics in kafka cluster `cluster-1` with names starting with `a_`:", "author": "PaulRMellor", "createdAt": "2020-11-24T10:45:19Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQ0OTc3Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529449772", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Topic:my-topic\n          \n          \n            \n                Group:my-group-*\n          \n          \n            \n            ----\n          \n          \n            \n            Topic:my-topic\n          \n          \n            \n            Group:my-group-*\n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-24T10:53:54Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,204 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Managing policies and permissions in Keycloak Authorization Services\n+\n+== Kafka authorization model for resources\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and the permissions available for each type.\n+When an action is performed by a Kafka client on a broker, the broker uses a configured authorizer to check permissions, depending on the action performed and the resource type.\n+\n+Kafka has five resource types for controlling access: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+Each resource type has different permissions:\n+\n+Topic:\n+\n+* `Create`\n+* `Write`\n+* `Read`\n+* `Delete`\n+* `Describe`\n+* `DescribeConfigs`\n+* `Alter`\n+* `AlterConfigs`\n+\n+Group:\n+\n+* `Read`\n+* `Describe`\n+* `Delete`\n+\n+Cluster:\n+\n+*  `Create`\n+*  `Describe`\n+*  `Alter`\n+*  `DescribeConfigs`\n+*  `AlterConfigs`\n+*  `IdempotentWrite`\n+*  `ClusterAction`\n+\n+TransactionalId:\n+\n+*  `Describe`\n+*  `Write`\n+\n+DelegationToken:\n+\n+* `Describe`\n+\n+== Keycloak Authorization Services model for managing permissions\n+\n+Keycloak Authorization Services use four concepts to define and grant permissions: _resources_, _authorization scopes_, _policies_, and _permissions_.\n+\n+Resources:: Resources are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with the same prefix.\n+The resource definition has a set of available authorization scopes associated with it, which represent a set of all actions available on the particular resource.\n+Often, only a subset of these actions is actually permitted.\n+\n+Authorization scopes:: Authorization scopes is simply a set of all available actions on all the different resource types. When defining a new resource,  scopes are added from the set of all scopes.\n+\n+Policies:: Policies are rules that use criteria to match a list of accounts. Policies can match service accounts based on client id or roles, or user accounts based on username, groups, or roles.\n+\n+Permissions:: Permissions grant a subset of authorization scopes on a specific resource definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+Use Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker to grant Kafka permissions to users or service accounts. Typically, the OAuth client has `kafka` as its client id.\n+\n+The OAuth 2.0 client definition must have the _Authorization Enabled_ option activated.\n+\n+All permissions exist within the scope of this OAuth 2.0 client, which means that if you have different Kafka clusters configured with different OAuth 2.0 client IDs they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client use the _SASL OAUTHBEARER_ mechanism, the Keycloak authorizer (`KeycloakRBACAuthorizer`) retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Introducing authorization scopes\n+\n+Typically, an initial configuration involves uploading the authorization scopes to create a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, you can add authorization scopes manually.\n+\n+The authorization scopes should contain all the possible Kafka permissions regardless of the resource type:\n+\n+* `Create`\n+* `Write`\n+* `Read`\n+* `Delete`\n+* `Describe`\n+* `Alter`\n+* `DescribeConfig`\n+* `AlterConfig`\n+* `ClusterAction`\n+* `IdempotentWrite`\n+\n+.Defining resource patterns for permission checks\n+\n+The resources use pattern names for pattern matching against the targeted resources when performing permission checks.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+.Example patterns for resources\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by `kafka-cluster:CLUSTER_NAME` followed by a comma, where the cluster name refers to the `metadata.name` in the Kafka custom resource.\n+\n+.Example patterns for resources with cluster prefix\n+    kafka-cluster:my-cluster,Topic:*\n+    kafka-cluster:*,Group:b_*\n+\n+When the `kafka-cluster` prefix is not present it is assumed to be `kafka-cluster:*`.\n+\n+When defining a resource, you can associate a list of possible authorization scopes relevant to the resource.\n+Set whatever actions make sense for the targeted resource type.\n+\n+While you may add any authorization scope to any resource, only the scopes supported by the resource type are considered for access control.\n+\n+.Policies\n+\n+Policies are used to target permissions to one or more accounts.\n+Targeting can refer to:\n+* Specific user or service accounts\n+* Realm roles or client roles\n+* User groups\n+* JS rule to match a client IP address\n+\n+A policy is given a unique name, and can be reused to target multiple permissions to multiple resources.\n+\n+.Defining permissions based on scopes, resources and policies \n+\n+Use fine-grained permissions to pull together the policies, resources, and authorization scopes that grant access to users.\n+\n+\n+The name of the each permission should should clearly define what permissions it grants to which users.\n+\n+For more information on how to configure permissions through Keycloak Authorization Services, see xref:con-oauth-authorization-keycloak-example_str[the authorization example].\n+\n+\n+== Example permissions required for operations on Kafka\n+\n+The following  examples demonstrate the permissions required for performing common operations on Kafka.\n+\n+.Creating a topic\n+\n+To create a topic the `Create` permission is required for the specific topic or `Cluster:kafka-cluster`.\n+\n+.Displaying the topic info\n+\n+To display the info on the topic the `Describe` permission is required for the specific topic.\n+\n+.Producing to the topic\n+\n+To produce to the topic the user needs `Describe` and `Write` permissions on the topic.\n+If topic has not yet been created, and autocreation is enabled, the permissions to create the topic are required.\n+\n+.Consuming from the topic\n+\n+To consume from the topic the user needs `Describe` and `Read` permissions on the topic.\n+Consuming from the topic normally relies on storing the consumer offsets in a consumer group.\n+That requires additional `Describe` and `Read` permissions on the consumer group.\n+\n+Two `resources` are needed for matching. For example:\n+\n+    Topic:my-topic\n+    Group:my-group-*", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQ4NTM5Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529485392", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n          \n          \n            \n            ----\n          \n          \n            \n            kafka-cluster:cluster-1,Topic:a_*  \n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-24T11:48:05Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQ4Njg0Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529486846", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n          \n          \n            \n            \n          \n          \n            \n            - `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n          \n          \n            \n            If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  `x_`:\n          \n          \n            \n            ----\n          \n          \n            \n            Group:x_* \n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-24T11:50:36Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQ4ODM5NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529488395", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n          \n          \n            \n            The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].", "author": "PaulRMellor", "createdAt": "2020-11-24T11:53:24Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQ4OTEzMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529489131", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n          \n          \n            \n            *Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.", "author": "PaulRMellor", "createdAt": "2020-11-24T11:54:41Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQ4OTY1Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529489656", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This list mirrors Kafka permissions and should be the same for any deployment.\n          \n          \n            \n            The list of actions mirrors Kafka permissions and is the same for any deployment.", "author": "PaulRMellor", "createdAt": "2020-11-24T11:55:37Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYxOTM4MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529619380", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n          \n          \n            \n            In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n          \n          \n            \n            For this example the authorization scopes have already been imported as part of the realm import.\n          \n          \n            \n            Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.\n          \n          \n            \n            \n          \n          \n            \n            You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.\n          \n          \n            \n            \n          \n          \n            \n            For this example the authorization scopes have already been imported as part of the realm import.", "author": "PaulRMellor", "createdAt": "2020-11-24T15:10:58Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYyMTAyNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529621025", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Under the `Policies` sub-tab there are filters that match sets of users.\n          \n          \n            \n            The *Policies* tab has filters that match sets of users.", "author": "PaulRMellor", "createdAt": "2020-11-24T15:13:04Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYyMTQ4NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529621484", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n          \n          \n            \n            Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.", "author": "PaulRMellor", "createdAt": "2020-11-24T15:13:45Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYyNzM4NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529627384", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n          \n          \n            \n            Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.", "author": "PaulRMellor", "createdAt": "2020-11-24T15:20:50Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYyOTk4MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529629980", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n          \n          \n            \n            The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.", "author": "PaulRMellor", "createdAt": "2020-11-24T15:24:11Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYzMTM4Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529631386", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n          \n          \n            \n            Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.", "author": "PaulRMellor", "createdAt": "2020-11-24T15:25:31Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYzMzM5Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529633392", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Dev Team A can write to topics that start with x_ on any cluster\n          \n          \n            \n            \n          \n          \n            \n                Dev Team B can read from topics that start with x_ on any cluster\n          \n          \n            \n                Dev Team B can update consumer group offsets that start with x_ on any cluster\n          \n          \n            \n            \n          \n          \n            \n                ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n          \n          \n            \n                ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n          \n          \n            \n                ClusterManager of my-cluster Group has full access to topics on my-cluster\n          \n          \n            \n            ----\n          \n          \n            \n            Dev Team A can write to topics that start with x_ on any cluster\n          \n          \n            \n            Dev Team B can read from topics that start with x_ on any cluster\n          \n          \n            \n            Dev Team B can update consumer group offsets that start with x_ on any cluster\n          \n          \n            \n            ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n          \n          \n            \n            ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n          \n          \n            \n            ClusterManager of my-cluster Group has full access to topics on my-cluster\n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-24T15:27:00Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTYzNDc2NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529634764", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ## Authorization in Action Using CLI Clients\n          \n          \n            \n            == Authorization in action using CLI clients", "author": "PaulRMellor", "createdAt": "2020-11-24T15:27:53Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+## Authorization in Action Using CLI Clients", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY2OTMwNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529669304", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n          \n          \n            \n            If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n          \n          \n            \n            \n          \n          \n            \n            Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n          \n          \n            \n            The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n          \n          \n            \n            `Dev Team A can write to topics that start with x_ on any cluster` combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team A`.\n          \n          \n            \n            \n          \n          \n            \n            `Dev Team B can read from topics that start with x_ on any cluster` combines `Topic:x_*`, and `Group:x_*` resources, scopes `Describe` and `Read`, and `Dev Team B` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team B`. Matching users and clients have the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with `x_`.", "author": "PaulRMellor", "createdAt": "2020-11-24T15:52:15Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY3MDAzMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529670030", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ## Targeting Permissions - Clients and Roles vs. Users and Groups\n          \n          \n            \n            == Targeting permissions using group or role policies", "author": "PaulRMellor", "createdAt": "2020-11-24T15:52:46Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY3NTI1NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529675254", "bodyText": "Maybe start the section with:\nWhether you use group or role policies to control access is dependent on the type of access. Generally, you will use roles for client access, and groups for user access.", "author": "PaulRMellor", "createdAt": "2020-11-24T15:56:22Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI2MjUwMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530262501", "bodyText": "I don't think this is quite true. Users may easily decide to not use groups at all, and to only use roles for all types of accounts.", "author": "mstruk", "createdAt": "2020-11-25T10:23:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY3NTI1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY3Njc0NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529676744", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n          \n          \n            \n            In Keycloak, confidential clients with service accounts enabled can authenticate to the server in their own name using a client ID and a secret.", "author": "PaulRMellor", "createdAt": "2020-11-24T15:57:21Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY3NzM5Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529677393", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n          \n          \n            \n            As a consequence, if you want to target permissions to microservices using service accounts, you cannot use group policies, and should instead use role policies.", "author": "PaulRMellor", "createdAt": "2020-11-24T15:57:48Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY3ODI3MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529678271", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n          \n          \n            \n            Conversely, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the group policies, rather than the role policies.", "author": "PaulRMellor", "createdAt": "2020-11-24T15:58:26Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY3OTYyNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529679625", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            That's what we see used in `permissions` that start with 'ClusterManager'.\n          \n          \n            \n            That is what is used for permissions that start with `ClusterManager`.", "author": "PaulRMellor", "createdAt": "2020-11-24T15:59:20Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY4MTAyNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529681026", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n          \n          \n            \n            It makes sense to require the user to log in, before using the resulting access token to authenticate to the Kafka Broker.", "author": "PaulRMellor", "createdAt": "2020-11-24T16:00:15Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY4MjE1OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529682158", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In this case the access token represents the specific user, rather than the client application.\n          \n          \n            \n            In this case, the access token represents the specific user, rather than the client application.", "author": "PaulRMellor", "createdAt": "2020-11-24T16:01:03Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY4NjY4Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529686682", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n          \n          \n            \n            Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n          \n          \n            \n            Before trying any new authorization configuration, make sure that authorization rules have been properly imported when Keycloak starts.", "author": "PaulRMellor", "createdAt": "2020-11-24T16:04:02Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+## Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI2ODAxNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530268016", "bodyText": "This doesn't sound right to me. The check here in the example refers to a particular bug that should already be gone. I wouldn't add this check as a regular procedure each time you import the authorization rules.", "author": "mstruk", "createdAt": "2020-11-25T10:31:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY4NjY4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA0OTQzNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531049434", "bodyText": "Can we drop this section then? Concerned about future-proofing the content", "author": "PaulRMellor", "createdAt": "2020-11-26T14:02:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY4NjY4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTUxMDg5Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531510893", "bodyText": "Ok. Let's drop it then.", "author": "mstruk", "createdAt": "2020-11-27T10:23:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY4NjY4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTUyNjUzMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531526530", "bodyText": "Or what if we just do it like this:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n          \n          \n            \n            Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n          \n          \n            \n            Make sure that authorization rules have been properly imported.", "author": "mstruk", "createdAt": "2020-11-27T10:49:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY4NjY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY4ODI2Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529688262", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Once the Kafka Broker has obtained an access token by using [Strimzi Kafka OAuth](https://github.com/strimzi/strimzi-kafka-oauth) for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n          \n          \n            \n            Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.", "author": "mstruk", "createdAt": "2020-11-24T16:05:12Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using [Strimzi Kafka OAuth](https://github.com/strimzi/strimzi-kafka-oauth) for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.", "originalCommit": "eed9f30862feae58fc655d04a36186853b4df38d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY5MTQ4OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529691489", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For this, Strimzi Kafka OAuth supports the use of Keycloak Authorization Services.\n          \n          \n            \n            For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.", "author": "mstruk", "createdAt": "2020-11-24T16:07:54Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using [Strimzi Kafka OAuth](https://github.com/strimzi/strimzi-kafka-oauth) for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka OAuth supports the use of Keycloak Authorization Services.", "originalCommit": "eed9f30862feae58fc655d04a36186853b4df38d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY5MzMzNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529693337", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            A custom authorizer has to be configured on the Kafka Broker to take advantage of the Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n          \n          \n            \n            When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.", "author": "mstruk", "createdAt": "2020-11-24T16:09:24Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using [Strimzi Kafka OAuth](https://github.com/strimzi/strimzi-kafka-oauth) for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka OAuth supports the use of Keycloak Authorization Services.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of the Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.", "originalCommit": "eed9f30862feae58fc655d04a36186853b4df38d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcwMzYyMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529703623", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n          \n          \n            \n            From menu:Clients[kafka>Authorization>Settings] make sure that *Decision Strategy* is set to *Affirmative*, and NOT to *Unanimous*.", "author": "PaulRMellor", "createdAt": "2020-11-24T16:19:04Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+## Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcwNDI4NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529704284", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n          \n          \n            \n            Navigate in Keycloak to check that the expected resources, authorization claims, policies and permissions are defined.", "author": "PaulRMellor", "createdAt": "2020-11-24T16:19:56Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+## Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcwNTg5OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529705898", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n          \n          \n            \n            With the configuration in place, we can check access to Kafka by using a producer and consumer to create topics using different user and service accounts.", "author": "PaulRMellor", "createdAt": "2020-11-24T16:22:04Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+## Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcxMzk5MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529713991", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n          \n          \n            \n            \n          \n          \n            \n                kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n          \n          \n            \n            First, a new interactive pod container is run using a Strimzi Kafka image to connect to a running Kafka broker.\n          \n          \n            \n            \n          \n          \n            \n            [source,shell]\n          \n          \n            \n            ----\n          \n          \n            \n            kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-24T16:33:06Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+## Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcxNTkwNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529715904", "bodyText": "Would this section be okay for a downstream doc? Are we expecting people to step through the example or is it intended for reference? Impact on testing.", "author": "PaulRMellor", "createdAt": "2020-11-24T16:35:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcxMzk5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI2OTA2OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530269069", "bodyText": "AFAIC it should be fine.", "author": "mstruk", "createdAt": "2020-11-25T10:33:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcxMzk5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcxNzMyOQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529717329", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n          \n          \n            \n            NOTE: If `kubectl` times out waiting on the image download, subsequent attempts may result in an _AlreadyExists_ error.", "author": "PaulRMellor", "createdAt": "2020-11-24T16:37:41Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+## Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcxNzc4Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529717787", "bodyText": "Maybe we should say whether the error can be ignored or what is the workaround.", "author": "PaulRMellor", "createdAt": "2020-11-24T16:38:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcxNzMyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI2OTQ5MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530269490", "bodyText": "The next line below is the workaround.", "author": "mstruk", "createdAt": "2020-11-25T10:34:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcxNzMyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcxODM3Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529718377", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You can attach to the existing pod by running:\n          \n          \n            \n            \n          \n          \n            \n                kubectl attach -ti kafka-cli\n          \n          \n            \n            You can attach to the existing pod by running:\n          \n          \n            \n            \n          \n          \n            \n            [source,shell]\n          \n          \n            \n            ----\n          \n          \n            \n            kubectl attach -ti kafka-cli\n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-24T16:39:09Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+## Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcxOTE4MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529719180", "bodyText": "Are we linking to the new sections instead?", "author": "PaulRMellor", "createdAt": "2020-11-24T16:40:11Z", "path": "documentation/modules/oauth/proc-oauth-authorization-broker-config.adoc", "diffHunk": "@@ -24,7 +24,6 @@ NOTE: xref:property-simple-authorization-superusers-reference[Super users] alway\n * Strimzi must be configured to use OAuth 2.0 with Keycloak for xref:assembly-oauth-authentication_str[token-based authentication].\n You use the same Keycloak server endpoint when you set up authorization.\n * OAuth 2.0 authentication must be configured with the `maxSecondsWithoutReauthentication` option to enable re-authentication.\n-* You need to understand how to manage policies and permissions for Keycloak Authorization Services, as described in the {keycloak-server-doc}.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQxNTA0Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530415042", "bodyText": "The new thing comes right after this chapter, and is not required for configuring the authorization in Strimzi, but for configuring the authorization rules in Keycloak. It's not a precondition / requirement for the steps that follow.", "author": "mstruk", "createdAt": "2020-11-25T14:30:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcxOTE4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA1MDgyMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531050820", "bodyText": "Okay", "author": "PaulRMellor", "createdAt": "2020-11-26T14:05:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcxOTE4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcxOTc2OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529719769", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Let's try to produce some messages as client `team-a-client`.\n          \n          \n            \n            \n          \n          \n            \n            First, we prepare a Kafka client configuration file with authentication parameters.\n          \n          \n            \n            To produce messages as client `team-a-client`, we prepare a Kafka client configuration file with authentication parameters.", "author": "PaulRMellor", "createdAt": "2020-11-24T16:40:59Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+## Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyMjk5Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529722993", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ```\n          \n          \n            \n            cat > /tmp/team-a-client.properties << EOF\n          \n          \n            \n            security.protocol=SASL_PLAINTEXT\n          \n          \n            \n            sasl.mechanism=OAUTHBEARER\n          \n          \n            \n            sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n          \n          \n            \n              oauth.client.id=\"team-a-client\" \\\n          \n          \n            \n              oauth.client.secret=\"team-a-client-secret\" \\\n          \n          \n            \n              oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n          \n          \n            \n            sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n          \n          \n            \n            EOF\n          \n          \n            \n            ```\n          \n          \n            \n            [source,shell]\n          \n          \n            \n            ----\n          \n          \n            \n            cat > /tmp/team-a-client.properties << EOF\n          \n          \n            \n            security.protocol=SASL_PLAINTEXT\n          \n          \n            \n            sasl.mechanism=OAUTHBEARER\n          \n          \n            \n            sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n          \n          \n            \n              oauth.client.id=\"team-a-client\" \\\n          \n          \n            \n              oauth.client.secret=\"team-a-client-secret\" \\\n          \n          \n            \n              oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n          \n          \n            \n            sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n          \n          \n            \n            EOF\n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-24T16:45:29Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+## Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyNjQyMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529726423", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n          \n          \n            \n            and then opening the `Service Account Roles` tab for the client.\n          \n          \n            \n            You should see the `Dev Team A` realm role assigned.\n          \n          \n            \n            The roles assigned to a client, such as the `Dev Team A` realm role assigned to the `team-a-client` service account, are presented in Keycloak on the  *Service Account Roles* tab from *Clients*.", "author": "PaulRMellor", "createdAt": "2020-11-24T16:50:23Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+## Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTczMDM5NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529730394", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            We can now use this configuration with Kafka's CLI tools.\n          \n          \n            \n            We can use this configuration from the Kafka CLI to produce and consume messages, and perform other administration tasks.", "author": "PaulRMellor", "createdAt": "2020-11-24T16:55:45Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+## Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTczMTI0OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529731249", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ### Producing the Messages\n          \n          \n            \n            .Producing messages with authorized access", "author": "PaulRMellor", "createdAt": "2020-11-24T16:56:52Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+## Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTczMzE5MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529733191", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Let's try to produce some messages to topic 'my-topic':\n          \n          \n            \n            \n          \n          \n            \n            ```\n          \n          \n            \n            bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n          \n          \n            \n              --producer.config=/tmp/team-a-client.properties\n          \n          \n            \n            First message\n          \n          \n            \n            ```\n          \n          \n            \n            The `team-a-client` configuration is used to produce messages to topic `my-topic`:\n          \n          \n            \n            \n          \n          \n            \n            [source,shell]\n          \n          \n            \n            ----\n          \n          \n            \n            bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n          \n          \n            \n              --producer.config=/tmp/team-a-client.properties\n          \n          \n            \n            First message\n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-24T16:59:34Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+## Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTczMzc2MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529733761", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n          \n          \n            \n            A `Not authorized to access topics: [my-topic]` error is returned when trying to push the first message.", "author": "PaulRMellor", "createdAt": "2020-11-24T17:00:21Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+## Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTczNDkwMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529734903", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n          \n          \n            \n            `team-a-client` has a `Dev Team A` role that gives it permission to perform any supported actions on topics that start with `a_`, but can only write to topics that start with `x_`.", "author": "PaulRMellor", "createdAt": "2020-11-24T17:01:59Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+## Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTczNTIwMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529735200", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The topic named `my-topic` matches neither of those.\n          \n          \n            \n            The topic named `my-topic` matches neither of those rules.", "author": "PaulRMellor", "createdAt": "2020-11-24T17:02:22Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+## Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTczNjc3Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529736772", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n          \n          \n            \n            \n          \n          \n            \n            ```\n          \n          \n            \n            bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n          \n          \n            \n              --producer.config /tmp/team-a-client.properties\n          \n          \n            \n            First message\n          \n          \n            \n            Second message\n          \n          \n            \n            ```\n          \n          \n            \n            The `team-a-client` configuration is then used to produce messages to topic `a_messages`.\n          \n          \n            \n            \n          \n          \n            \n            [source,shell]\n          \n          \n            \n            ----\n          \n          \n            \n            bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n          \n          \n            \n              --producer.config /tmp/team-a-client.properties\n          \n          \n            \n            First message\n          \n          \n            \n            Second message\n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-24T17:04:48Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+## Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTczNzU2Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529737567", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n          \n          \n            \n            The messages are pushed out successfully, and in the Kafka container log there is DEBUG level output saying `Authorization GRANTED`.", "author": "PaulRMellor", "createdAt": "2020-11-24T17:05:56Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+## Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTczNzY4NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529737684", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Use CTRL-C to exit the CLI application.", "author": "PaulRMellor", "createdAt": "2020-11-24T17:06:08Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+## Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI3MTYyNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530271626", "bodyText": "Why would you remove this? Exiting the current CLI releases the shell for the next steps in this tutorial.", "author": "mstruk", "createdAt": "2020-11-25T10:37:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTczNzY4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTA1MDYyMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531050620", "bodyText": "Let's return it then. I assumed we'd be doing this between steps", "author": "PaulRMellor", "createdAt": "2020-11-26T14:04:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTczNzY4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTczODIxNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529738216", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            You can see the Kafka container log by running:\n          \n          \n            \n            \n          \n          \n            \n                kubectl logs my-cluster-kafka-0 -f\n          \n          \n            \n            You can see the Kafka container log by running:\n          \n          \n            \n            \n          \n          \n            \n            [source,shell]\n          \n          \n            \n            kubectl logs my-cluster-kafka-0 -f", "author": "PaulRMellor", "createdAt": "2020-11-24T17:06:54Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+## Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTczOTE0Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529739142", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ### Consuming the Messages\n          \n          \n            \n            .Consuming messages with authorized access", "author": "PaulRMellor", "createdAt": "2020-11-24T17:08:17Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+## Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc0MTk0MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529741941", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Let's now try to consume the messages we have produced.\n          \n          \n            \n            \n          \n          \n            \n                bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n          \n          \n            \n                  --from-beginning --consumer.config /tmp/team-a-client.properties\n          \n          \n            \n            The `team-a-client` configuration is used to consume messages from topic `a_messages`:\n          \n          \n            \n            \n          \n          \n            \n            [source,shell,subs=+quotes]\n          \n          \n            \n            ----\n          \n          \n            \n            bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n          \n          \n            \n              --from-beginning --consumer.config /tmp/team-a-client.properties\n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-24T17:12:29Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+## Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc0NTAxMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529745011", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n          \n          \n            \n            \n          \n          \n            \n            The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n          \n          \n            \n            An error is returned as the `Dev Team A` role for `team-a-client` only has access to consumer groups that have names starting with `a_`.", "author": "PaulRMellor", "createdAt": "2020-11-24T17:17:05Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+## Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc0OTcyMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529749721", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Let's set custom consumer group name that starts with 'a_'\n          \n          \n            \n            \n          \n          \n            \n                bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n          \n          \n            \n                  --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n          \n          \n            \n            \n          \n          \n            \n            We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n          \n          \n            \n            \n          \n          \n            \n            Use CTRL-C to exit.\n          \n          \n            \n            The `team-a-client` configuration is then used to consume messages when specifying a custom consumer group with a name that starts with `a_`:\n          \n          \n            \n            \n          \n          \n            \n            [source,shell,subs=+quotes]\n          \n          \n            \n            ----\n          \n          \n            \n            bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n          \n          \n            \n              --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n          \n          \n            \n            ----\n          \n          \n            \n            \n          \n          \n            \n            This time the consumer receives all the messages from the `a_messages` topic.", "author": "PaulRMellor", "createdAt": "2020-11-24T17:24:07Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+## Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc1MTYyMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529751621", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ### Using Kafka's CLI Administration Tools\n          \n          \n            \n            .Administering Kafka with authorized access", "author": "PaulRMellor", "createdAt": "2020-11-24T17:26:47Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+## Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc1MjYxNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529752614", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Let's now list the topics:\n          \n          \n            \n            The `team-a-client` configuration is used in administrative operations.", "author": "PaulRMellor", "createdAt": "2020-11-24T17:28:13Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+## Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc1MzgwNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529753804", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n          \n          \n            \n            \n          \n          \n            \n            We get one topic listed: `a_messages`.\n          \n          \n            \n            Listing topics returns the `a_messages` topic.\n          \n          \n            \n            \n          \n          \n            \n            [source,shell]\n          \n          \n            \n            ----\n          \n          \n            \n            bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-24T17:29:57Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+## Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc1NDg3OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529754878", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Let's try and list the consumer groups:\n          \n          \n            \n            \n          \n          \n            \n                bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n          \n          \n            \n            \n          \n          \n            \n            Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n          \n          \n            \n            Listing consumer groups returns the `a_consumer_group_1` consumer group.\n          \n          \n            \n            \n          \n          \n            \n            [source,shell]\n          \n          \n            \n            ----\n          \n          \n            \n            bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-24T17:31:29Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+## Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc1NjI3Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529756276", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n          \n          \n            \n            \n          \n          \n            \n                bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n          \n          \n            \n                  --entity-type brokers --describe --entity-default\n          \n          \n            \n            \n          \n          \n            \n            But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.\n          \n          \n            \n            Fetching the default cluster configuration fails cluster authorization, because the operation requires cluster level permissions that `team-a-client` does not have.\n          \n          \n            \n            \n          \n          \n            \n            [source,shell]\n          \n          \n            \n            ----\n          \n          \n            \n            bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n          \n          \n            \n              --entity-type brokers --describe --entity-default\n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-24T17:33:46Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n+\n+`Resources` define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of `authorization scopes` - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+`Policies` define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, the `permissions` tie together specific `resources`, `action scopes` and `policies` to define that 'specific users U can perform certain actions A on the resource R'.\n+\n+You can read more about `Keycloak Authorization Services` on link:https://www.keycloak.org/docs/latest/authorization_services/index.html[project's web site], but note that the documentation there is focused primarily on using the Authorization Services to protect web resources, whereas here we're using it to protect access to Kafka.\n+\n+If we take a look under the `Resources` sub-tab of `Authorization` tab, we'll see the list of resource definitions.\n+These are resource specifiers - patterns in a specific format, that are used to target policies to specific resources.\n+The format is quite simple. For example:\n+\n+- `kafka-cluster:cluster-1,Topic:a_*`  ... targets only topics in kafka cluster 'cluster-1' with names starting with 'a_'\n+\n+If `kafka-cluster:XXX` segment is not present, the specifier targets any cluster.\n+\n+- `Group:x_*` ... targets all consumer groups on any cluster with names starting with 'x_'\n+\n+The possible resource types mirror the xref:kafka_authorization_model[Kafka authorization model] (`Topic`, `Group`, `Cluster`, ...).\n+\n+Under `Authorization Scopes` we can see a list of all the possible actions (Kafka permissions) that can be granted on resources of different types.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+This list mirrors Kafka permissions and should be the same for any deployment.\n+\n+There is an link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file containing the authorization scopes that can be imported, so that they do not have to be manually entered for every new `Authorization Services` enabled client.\n+In order to import `authorization-scopes.json` into a new client, first make sure the new client is `Authorization Enabled` and saved. Then, click on the `Authorization` tab and use the `Import` to import the file. Afterwards, if you select the `Authorization Scopes` you will see the loaded scopes.\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+Under the `Policies` sub-tab there are filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the Roles, or Groups they are assigned.\n+Policies can even be programmatically defined using JavaScript where logic can take into account the context of the client session - for example, client ip (that is client ip of the Kafka client).\n+\n+Then, finally, there is the `Permissions` sub-tab, which defines 'role bindings' where `resources`, `authorization scopes` and `policies` are tied together to apply a set of permissions on specific resources for certain users.\n+\n+Each `permission` definition can have a nice descriptive name which can make it very clear what kind of access is granted to which users.\n+For example:\n+\n+    Dev Team A can write to topics that start with x_ on any cluster\n+\n+    Dev Team B can read from topics that start with x_ on any cluster\n+    Dev Team B can update consumer group offsets that start with x_ on any cluster\n+\n+    ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+    ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+    ClusterManager of my-cluster Group has full access to topics on my-cluster\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+## Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n+\n+There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n+\n+    bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+      --entity-type brokers --describe --entity-default\n+\n+But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE3ODIyMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530178220", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ### Client with Different Permissions\n          \n          \n            \n            . Using clients with different permissions", "author": "PaulRMellor", "createdAt": "2020-11-25T08:13:41Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.\n+\n+Resources define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.\n+\n+For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.\n+\n+When viewing resources from the Keycloak user interface you will see a list of resource definitions.\n+These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.\n+For example, this pattern targets only topics in kafka cluster 'cluster-1' with names starting with 'a_':\n+\n+----\n+kafka-cluster:cluster-1,Topic:a_*  \n+---- \n+\n+If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  'x_':\n+----\n+Group:x_* \n+----\n+\n+\n+The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].\n+\n+*Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+The list of actions mirrors Kafka permissions and is the same for any deployment.\n+\n+Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.\n+\n+You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.\n+\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+The *Policies* tab has filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.\n+Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.\n+\n+The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.\n+\n+Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.\n+For example:\n+\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n+\n+There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n+\n+    bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+      --entity-type brokers --describe --entity-default\n+\n+But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.\n+\n+\n+### Client with Different Permissions", "originalCommit": "230db92e0f4d880e8d667eef9353cc2ceaa999f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE4MDczNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530180736", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Let's prepare a configuration for `team-b-client`:\n          \n          \n            \n            As with `team-a-client`, we prepare a Kafka client configuration file with authentication parameters for `team-b-client`.", "author": "PaulRMellor", "createdAt": "2020-11-25T08:18:31Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.\n+\n+Resources define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.\n+\n+For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.\n+\n+When viewing resources from the Keycloak user interface you will see a list of resource definitions.\n+These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.\n+For example, this pattern targets only topics in kafka cluster 'cluster-1' with names starting with 'a_':\n+\n+----\n+kafka-cluster:cluster-1,Topic:a_*  \n+---- \n+\n+If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  'x_':\n+----\n+Group:x_* \n+----\n+\n+\n+The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].\n+\n+*Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+The list of actions mirrors Kafka permissions and is the same for any deployment.\n+\n+Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.\n+\n+You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.\n+\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+The *Policies* tab has filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.\n+Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.\n+\n+The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.\n+\n+Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.\n+For example:\n+\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n+\n+There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n+\n+    bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+      --entity-type brokers --describe --entity-default\n+\n+But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.\n+\n+\n+### Client with Different Permissions\n+\n+Let's prepare a configuration for `team-b-client`:", "originalCommit": "230db92e0f4d880e8d667eef9353cc2ceaa999f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE4MTU1NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530181555", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ```\n          \n          \n            \n            cat > /tmp/team-b-client.properties << EOF\n          \n          \n            \n            security.protocol=SASL_PLAINTEXT\n          \n          \n            \n            sasl.mechanism=OAUTHBEARER\n          \n          \n            \n            sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n          \n          \n            \n              oauth.client.id=\"team-b-client\" \\\n          \n          \n            \n              oauth.client.secret=\"team-b-client-secret\" \\\n          \n          \n            \n              oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n          \n          \n            \n            sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n          \n          \n            \n            EOF\n          \n          \n            \n            ```\n          \n          \n            \n            [source,shell]\n          \n          \n            \n            ----\n          \n          \n            \n            cat > /tmp/team-b-client.properties << EOF\n          \n          \n            \n            security.protocol=SASL_PLAINTEXT\n          \n          \n            \n            sasl.mechanism=OAUTHBEARER\n          \n          \n            \n            sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n          \n          \n            \n              oauth.client.id=\"team-b-client\" \\\n          \n          \n            \n              oauth.client.secret=\"team-b-client-secret\" \\\n          \n          \n            \n              oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n          \n          \n            \n            sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n          \n          \n            \n            EOF\n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-25T08:19:55Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.\n+\n+Resources define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.\n+\n+For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.\n+\n+When viewing resources from the Keycloak user interface you will see a list of resource definitions.\n+These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.\n+For example, this pattern targets only topics in kafka cluster 'cluster-1' with names starting with 'a_':\n+\n+----\n+kafka-cluster:cluster-1,Topic:a_*  \n+---- \n+\n+If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  'x_':\n+----\n+Group:x_* \n+----\n+\n+\n+The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].\n+\n+*Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+The list of actions mirrors Kafka permissions and is the same for any deployment.\n+\n+Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.\n+\n+You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.\n+\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+The *Policies* tab has filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.\n+Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.\n+\n+The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.\n+\n+Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.\n+For example:\n+\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n+\n+There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n+\n+    bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+      --entity-type brokers --describe --entity-default\n+\n+But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.\n+\n+\n+### Client with Different Permissions\n+\n+Let's prepare a configuration for `team-b-client`:\n+\n+```\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```", "originalCommit": "230db92e0f4d880e8d667eef9353cc2ceaa999f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE4NjAwNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530186006", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If we look at `team-b-client` client configuration in Keycloak, under `Service Account Roles` we can see that it has `Dev Team B` realm role assigned.\n          \n          \n            \n            Looking in Keycloak Console at the `kafka` client's `Authorization` tab where `Permissions` are listed, we can see the permissions that start with 'Dev Team B ...'.\n          \n          \n            \n            These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n          \n          \n            \n            The `Dev Team B` users have full access to topics beginning with 'b_' on Kafka cluster `my-cluster` (which is the designated cluster name of the demo cluster we brought up), and read access on topics that start with 'x_'.\n          \n          \n            \n            The `team-b-client` client configuration includes a `Dev Team B` realm role and permissions that start with `Dev Team B ...`. These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n          \n          \n            \n            The `Dev Team B` users have full access to topics beginning with `b_` on the Kafka cluster `my-cluster`, the name of the designated cluster, and read access on topics that start with `x_`.", "author": "PaulRMellor", "createdAt": "2020-11-25T08:27:44Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.\n+\n+Resources define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.\n+\n+For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.\n+\n+When viewing resources from the Keycloak user interface you will see a list of resource definitions.\n+These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.\n+For example, this pattern targets only topics in kafka cluster 'cluster-1' with names starting with 'a_':\n+\n+----\n+kafka-cluster:cluster-1,Topic:a_*  \n+---- \n+\n+If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  'x_':\n+----\n+Group:x_* \n+----\n+\n+\n+The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].\n+\n+*Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+The list of actions mirrors Kafka permissions and is the same for any deployment.\n+\n+Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.\n+\n+You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.\n+\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+The *Policies* tab has filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.\n+Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.\n+\n+The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.\n+\n+Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.\n+For example:\n+\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n+\n+There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n+\n+    bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+      --entity-type brokers --describe --entity-default\n+\n+But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.\n+\n+\n+### Client with Different Permissions\n+\n+Let's prepare a configuration for `team-b-client`:\n+\n+```\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+If we look at `team-b-client` client configuration in Keycloak, under `Service Account Roles` we can see that it has `Dev Team B` realm role assigned.\n+Looking in Keycloak Console at the `kafka` client's `Authorization` tab where `Permissions` are listed, we can see the permissions that start with 'Dev Team B ...'.\n+These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with 'b_' on Kafka cluster `my-cluster` (which is the designated cluster name of the demo cluster we brought up), and read access on topics that start with 'x_'.", "originalCommit": "230db92e0f4d880e8d667eef9353cc2ceaa999f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE4NzQwMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530187400", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Let's try produce some messages to topic `a_messages` as `team-b-client`:\n          \n          \n            \n            \n          \n          \n            \n            ```\n          \n          \n            \n            bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n          \n          \n            \n              --producer.config /tmp/team-b-client.properties\n          \n          \n            \n            Message 1\n          \n          \n            \n            ```\n          \n          \n            \n            The `team-b-client` configuration is used to produce messages to topic `a_messages`:\n          \n          \n            \n            \n          \n          \n            \n            [source,shell]\n          \n          \n            \n            ----\n          \n          \n            \n            bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n          \n          \n            \n              --producer.config /tmp/team-b-client.properties\n          \n          \n            \n            Message 1\n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-25T08:30:10Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.\n+\n+Resources define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.\n+\n+For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.\n+\n+When viewing resources from the Keycloak user interface you will see a list of resource definitions.\n+These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.\n+For example, this pattern targets only topics in kafka cluster 'cluster-1' with names starting with 'a_':\n+\n+----\n+kafka-cluster:cluster-1,Topic:a_*  \n+---- \n+\n+If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  'x_':\n+----\n+Group:x_* \n+----\n+\n+\n+The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].\n+\n+*Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+The list of actions mirrors Kafka permissions and is the same for any deployment.\n+\n+Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.\n+\n+You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.\n+\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+The *Policies* tab has filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.\n+Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.\n+\n+The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.\n+\n+Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.\n+For example:\n+\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n+\n+There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n+\n+    bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+      --entity-type brokers --describe --entity-default\n+\n+But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.\n+\n+\n+### Client with Different Permissions\n+\n+Let's prepare a configuration for `team-b-client`:\n+\n+```\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+If we look at `team-b-client` client configuration in Keycloak, under `Service Account Roles` we can see that it has `Dev Team B` realm role assigned.\n+Looking in Keycloak Console at the `kafka` client's `Authorization` tab where `Permissions` are listed, we can see the permissions that start with 'Dev Team B ...'.\n+These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with 'b_' on Kafka cluster `my-cluster` (which is the designated cluster name of the demo cluster we brought up), and read access on topics that start with 'x_'.\n+\n+Let's try produce some messages to topic `a_messages` as `team-b-client`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```", "originalCommit": "230db92e0f4d880e8d667eef9353cc2ceaa999f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE5MDU3Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530190576", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            We get `Not authorized to access topics: [a_messages]` error as we expected. Let's try to produce to topic `b_messages`:\n          \n          \n            \n            A `Not authorized to access topics: [a_messages]` error is returned when trying to push the first message, as expected, so we switch to topic `b_messages`:", "author": "PaulRMellor", "createdAt": "2020-11-25T08:35:40Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.\n+\n+Resources define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.\n+\n+For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.\n+\n+When viewing resources from the Keycloak user interface you will see a list of resource definitions.\n+These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.\n+For example, this pattern targets only topics in kafka cluster 'cluster-1' with names starting with 'a_':\n+\n+----\n+kafka-cluster:cluster-1,Topic:a_*  \n+---- \n+\n+If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  'x_':\n+----\n+Group:x_* \n+----\n+\n+\n+The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].\n+\n+*Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+The list of actions mirrors Kafka permissions and is the same for any deployment.\n+\n+Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.\n+\n+You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.\n+\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+The *Policies* tab has filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.\n+Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.\n+\n+The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.\n+\n+Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.\n+For example:\n+\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n+\n+There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n+\n+    bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+      --entity-type brokers --describe --entity-default\n+\n+But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.\n+\n+\n+### Client with Different Permissions\n+\n+Let's prepare a configuration for `team-b-client`:\n+\n+```\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+If we look at `team-b-client` client configuration in Keycloak, under `Service Account Roles` we can see that it has `Dev Team B` realm role assigned.\n+Looking in Keycloak Console at the `kafka` client's `Authorization` tab where `Permissions` are listed, we can see the permissions that start with 'Dev Team B ...'.\n+These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with 'b_' on Kafka cluster `my-cluster` (which is the designated cluster name of the demo cluster we brought up), and read access on topics that start with 'x_'.\n+\n+Let's try produce some messages to topic `a_messages` as `team-b-client`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get `Not authorized to access topics: [a_messages]` error as we expected. Let's try to produce to topic `b_messages`:", "originalCommit": "230db92e0f4d880e8d667eef9353cc2ceaa999f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE5MTAwMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530191000", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ```\n          \n          \n            \n            bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n          \n          \n            \n              --producer.config /tmp/team-b-client.properties\n          \n          \n            \n            Message 1\n          \n          \n            \n            Message 2\n          \n          \n            \n            Message 3\n          \n          \n            \n            ```\n          \n          \n            \n            [source,shell]\n          \n          \n            \n            ----\n          \n          \n            \n            bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n          \n          \n            \n              --producer.config /tmp/team-b-client.properties\n          \n          \n            \n            Message 1\n          \n          \n            \n            Message 2\n          \n          \n            \n            Message 3\n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-25T08:36:24Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.\n+\n+Resources define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.\n+\n+For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.\n+\n+When viewing resources from the Keycloak user interface you will see a list of resource definitions.\n+These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.\n+For example, this pattern targets only topics in kafka cluster 'cluster-1' with names starting with 'a_':\n+\n+----\n+kafka-cluster:cluster-1,Topic:a_*  \n+---- \n+\n+If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  'x_':\n+----\n+Group:x_* \n+----\n+\n+\n+The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].\n+\n+*Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+The list of actions mirrors Kafka permissions and is the same for any deployment.\n+\n+Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.\n+\n+You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.\n+\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+The *Policies* tab has filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.\n+Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.\n+\n+The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.\n+\n+Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.\n+For example:\n+\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n+\n+There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n+\n+    bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+      --entity-type brokers --describe --entity-default\n+\n+But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.\n+\n+\n+### Client with Different Permissions\n+\n+Let's prepare a configuration for `team-b-client`:\n+\n+```\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+If we look at `team-b-client` client configuration in Keycloak, under `Service Account Roles` we can see that it has `Dev Team B` realm role assigned.\n+Looking in Keycloak Console at the `kafka` client's `Authorization` tab where `Permissions` are listed, we can see the permissions that start with 'Dev Team B ...'.\n+These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with 'b_' on Kafka cluster `my-cluster` (which is the designated cluster name of the demo cluster we brought up), and read access on topics that start with 'x_'.\n+\n+Let's try produce some messages to topic `a_messages` as `team-b-client`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get `Not authorized to access topics: [a_messages]` error as we expected. Let's try to produce to topic `b_messages`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+Message 2\n+Message 3\n+```", "originalCommit": "230db92e0f4d880e8d667eef9353cc2ceaa999f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE5MTY3Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530191677", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This should work fine.\n          \n          \n            \n            Producing messages to topic `b_messages` is authorized and successful.", "author": "PaulRMellor", "createdAt": "2020-11-25T08:37:33Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.\n+\n+Resources define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.\n+\n+For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.\n+\n+When viewing resources from the Keycloak user interface you will see a list of resource definitions.\n+These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.\n+For example, this pattern targets only topics in kafka cluster 'cluster-1' with names starting with 'a_':\n+\n+----\n+kafka-cluster:cluster-1,Topic:a_*  \n+---- \n+\n+If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  'x_':\n+----\n+Group:x_* \n+----\n+\n+\n+The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].\n+\n+*Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+The list of actions mirrors Kafka permissions and is the same for any deployment.\n+\n+Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.\n+\n+You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.\n+\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+The *Policies* tab has filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.\n+Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.\n+\n+The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.\n+\n+Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.\n+For example:\n+\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n+\n+There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n+\n+    bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+      --entity-type brokers --describe --entity-default\n+\n+But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.\n+\n+\n+### Client with Different Permissions\n+\n+Let's prepare a configuration for `team-b-client`:\n+\n+```\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+If we look at `team-b-client` client configuration in Keycloak, under `Service Account Roles` we can see that it has `Dev Team B` realm role assigned.\n+Looking in Keycloak Console at the `kafka` client's `Authorization` tab where `Permissions` are listed, we can see the permissions that start with 'Dev Team B ...'.\n+These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with 'b_' on Kafka cluster `my-cluster` (which is the designated cluster name of the demo cluster we brought up), and read access on topics that start with 'x_'.\n+\n+Let's try produce some messages to topic `a_messages` as `team-b-client`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get `Not authorized to access topics: [a_messages]` error as we expected. Let's try to produce to topic `b_messages`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+Message 2\n+Message 3\n+```\n+\n+This should work fine.", "originalCommit": "230db92e0f4d880e8d667eef9353cc2ceaa999f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDE5NDk2Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530194967", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            What about producing to topic `x_messages`. `team-b-client` is only supposed to be able to read from such a topic.\n          \n          \n            \n            \n          \n          \n            \n            ```\n          \n          \n            \n            bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n          \n          \n            \n              --producer.config /tmp/team-b-client.properties\n          \n          \n            \n            Message 1\n          \n          \n            \n            ```\n          \n          \n            \n            We switch again, but this time to topic that `team-b-client` can only read from, topic `x_messages`:\n          \n          \n            \n            \n          \n          \n            \n            [source,shell]\n          \n          \n            \n            ----\n          \n          \n            \n            bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n          \n          \n            \n              --producer.config /tmp/team-b-client.properties\n          \n          \n            \n            Message 1\n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-25T08:42:57Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.\n+\n+Resources define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.\n+\n+For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.\n+\n+When viewing resources from the Keycloak user interface you will see a list of resource definitions.\n+These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.\n+For example, this pattern targets only topics in kafka cluster 'cluster-1' with names starting with 'a_':\n+\n+----\n+kafka-cluster:cluster-1,Topic:a_*  \n+---- \n+\n+If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  'x_':\n+----\n+Group:x_* \n+----\n+\n+\n+The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].\n+\n+*Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+The list of actions mirrors Kafka permissions and is the same for any deployment.\n+\n+Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.\n+\n+You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.\n+\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+The *Policies* tab has filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.\n+Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.\n+\n+The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.\n+\n+Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.\n+For example:\n+\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n+\n+There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n+\n+    bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+      --entity-type brokers --describe --entity-default\n+\n+But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.\n+\n+\n+### Client with Different Permissions\n+\n+Let's prepare a configuration for `team-b-client`:\n+\n+```\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+If we look at `team-b-client` client configuration in Keycloak, under `Service Account Roles` we can see that it has `Dev Team B` realm role assigned.\n+Looking in Keycloak Console at the `kafka` client's `Authorization` tab where `Permissions` are listed, we can see the permissions that start with 'Dev Team B ...'.\n+These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with 'b_' on Kafka cluster `my-cluster` (which is the designated cluster name of the demo cluster we brought up), and read access on topics that start with 'x_'.\n+\n+Let's try produce some messages to topic `a_messages` as `team-b-client`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get `Not authorized to access topics: [a_messages]` error as we expected. Let's try to produce to topic `b_messages`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+Message 2\n+Message 3\n+```\n+\n+This should work fine.\n+\n+What about producing to topic `x_messages`. `team-b-client` is only supposed to be able to read from such a topic.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```", "originalCommit": "230db92e0f4d880e8d667eef9353cc2ceaa999f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDIxNzk4Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530217987", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            We get a `Not authorized to access topics: [x_messages]` error as we expected.\n          \n          \n            \n            Client `team-a-client`, on the other hand, should be able to write to such a topic:\n          \n          \n            \n            A `Not authorized to access topics: [x_messages]` error is returned, as expected, so we switch to `team-a-client`:", "author": "PaulRMellor", "createdAt": "2020-11-25T09:18:42Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.\n+\n+Resources define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.\n+\n+For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.\n+\n+When viewing resources from the Keycloak user interface you will see a list of resource definitions.\n+These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.\n+For example, this pattern targets only topics in kafka cluster 'cluster-1' with names starting with 'a_':\n+\n+----\n+kafka-cluster:cluster-1,Topic:a_*  \n+---- \n+\n+If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  'x_':\n+----\n+Group:x_* \n+----\n+\n+\n+The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].\n+\n+*Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+The list of actions mirrors Kafka permissions and is the same for any deployment.\n+\n+Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.\n+\n+You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.\n+\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+The *Policies* tab has filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.\n+Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.\n+\n+The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.\n+\n+Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.\n+For example:\n+\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n+\n+There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n+\n+    bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+      --entity-type brokers --describe --entity-default\n+\n+But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.\n+\n+\n+### Client with Different Permissions\n+\n+Let's prepare a configuration for `team-b-client`:\n+\n+```\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+If we look at `team-b-client` client configuration in Keycloak, under `Service Account Roles` we can see that it has `Dev Team B` realm role assigned.\n+Looking in Keycloak Console at the `kafka` client's `Authorization` tab where `Permissions` are listed, we can see the permissions that start with 'Dev Team B ...'.\n+These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with 'b_' on Kafka cluster `my-cluster` (which is the designated cluster name of the demo cluster we brought up), and read access on topics that start with 'x_'.\n+\n+Let's try produce some messages to topic `a_messages` as `team-b-client`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get `Not authorized to access topics: [a_messages]` error as we expected. Let's try to produce to topic `b_messages`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+Message 2\n+Message 3\n+```\n+\n+This should work fine.\n+\n+What about producing to topic `x_messages`. `team-b-client` is only supposed to be able to read from such a topic.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get a `Not authorized to access topics: [x_messages]` error as we expected.\n+Client `team-a-client`, on the other hand, should be able to write to such a topic:", "originalCommit": "230db92e0f4d880e8d667eef9353cc2ceaa999f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDIyMjQ2MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530222461", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n            ```\n          \n          \n            \n            bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n          \n          \n            \n              --producer.config /tmp/team-a-client.properties\n          \n          \n            \n            Message 1\n          \n          \n            \n            ```\n          \n          \n            \n            \n          \n          \n            \n            [source,shell]\n          \n          \n            \n            ----\n          \n          \n            \n            bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n          \n          \n            \n              --producer.config /tmp/team-a-client.properties\n          \n          \n            \n            Message 1\n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-25T09:25:06Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.\n+\n+Resources define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.\n+\n+For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.\n+\n+When viewing resources from the Keycloak user interface you will see a list of resource definitions.\n+These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.\n+For example, this pattern targets only topics in kafka cluster 'cluster-1' with names starting with 'a_':\n+\n+----\n+kafka-cluster:cluster-1,Topic:a_*  \n+---- \n+\n+If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  'x_':\n+----\n+Group:x_* \n+----\n+\n+\n+The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].\n+\n+*Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+The list of actions mirrors Kafka permissions and is the same for any deployment.\n+\n+Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.\n+\n+You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.\n+\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+The *Policies* tab has filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.\n+Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.\n+\n+The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.\n+\n+Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.\n+For example:\n+\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n+\n+There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n+\n+    bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+      --entity-type brokers --describe --entity-default\n+\n+But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.\n+\n+\n+### Client with Different Permissions\n+\n+Let's prepare a configuration for `team-b-client`:\n+\n+```\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+If we look at `team-b-client` client configuration in Keycloak, under `Service Account Roles` we can see that it has `Dev Team B` realm role assigned.\n+Looking in Keycloak Console at the `kafka` client's `Authorization` tab where `Permissions` are listed, we can see the permissions that start with 'Dev Team B ...'.\n+These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with 'b_' on Kafka cluster `my-cluster` (which is the designated cluster name of the demo cluster we brought up), and read access on topics that start with 'x_'.\n+\n+Let's try produce some messages to topic `a_messages` as `team-b-client`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get `Not authorized to access topics: [a_messages]` error as we expected. Let's try to produce to topic `b_messages`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+Message 2\n+Message 3\n+```\n+\n+This should work fine.\n+\n+What about producing to topic `x_messages`. `team-b-client` is only supposed to be able to read from such a topic.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get a `Not authorized to access topics: [x_messages]` error as we expected.\n+Client `team-a-client`, on the other hand, should be able to write to such a topic:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+```", "originalCommit": "230db92e0f4d880e8d667eef9353cc2ceaa999f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDIyNTIyMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530225222", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            However, we again receive `Not authorized to access topics: [x_messages]`. What's going on?\n          \n          \n            \n            The reason for failure is that while `team-a-client` can write to `x_messages` topic, it does not have a permission to create a topic if it does not yet exist.\n          \n          \n            \n            A `Not authorized to access topics: [x_messages]` error is returned again. Though `team-a-client` can write to the `x_messages` topic, it it does not have a permission to create a topic if it does not yet exist.", "author": "PaulRMellor", "createdAt": "2020-11-25T09:29:11Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.\n+\n+Resources define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.\n+\n+For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.\n+\n+When viewing resources from the Keycloak user interface you will see a list of resource definitions.\n+These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.\n+For example, this pattern targets only topics in kafka cluster 'cluster-1' with names starting with 'a_':\n+\n+----\n+kafka-cluster:cluster-1,Topic:a_*  \n+---- \n+\n+If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  'x_':\n+----\n+Group:x_* \n+----\n+\n+\n+The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].\n+\n+*Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+The list of actions mirrors Kafka permissions and is the same for any deployment.\n+\n+Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.\n+\n+You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.\n+\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+The *Policies* tab has filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.\n+Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.\n+\n+The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.\n+\n+Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.\n+For example:\n+\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n+\n+There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n+\n+    bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+      --entity-type brokers --describe --entity-default\n+\n+But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.\n+\n+\n+### Client with Different Permissions\n+\n+Let's prepare a configuration for `team-b-client`:\n+\n+```\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+If we look at `team-b-client` client configuration in Keycloak, under `Service Account Roles` we can see that it has `Dev Team B` realm role assigned.\n+Looking in Keycloak Console at the `kafka` client's `Authorization` tab where `Permissions` are listed, we can see the permissions that start with 'Dev Team B ...'.\n+These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with 'b_' on Kafka cluster `my-cluster` (which is the designated cluster name of the demo cluster we brought up), and read access on topics that start with 'x_'.\n+\n+Let's try produce some messages to topic `a_messages` as `team-b-client`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get `Not authorized to access topics: [a_messages]` error as we expected. Let's try to produce to topic `b_messages`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+Message 2\n+Message 3\n+```\n+\n+This should work fine.\n+\n+What about producing to topic `x_messages`. `team-b-client` is only supposed to be able to read from such a topic.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get a `Not authorized to access topics: [x_messages]` error as we expected.\n+Client `team-a-client`, on the other hand, should be able to write to such a topic:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+```\n+\n+However, we again receive `Not authorized to access topics: [x_messages]`. What's going on?\n+The reason for failure is that while `team-a-client` can write to `x_messages` topic, it does not have a permission to create a topic if it does not yet exist.", "originalCommit": "230db92e0f4d880e8d667eef9353cc2ceaa999f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDIyNzU1Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530227556", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            We now need a power user that can create a topic with all the proper settings - like the right number of partitions and replicas.\n          \n          \n            \n            Before `team-a-client` can write to the `x_messages` topic, a admin _power user_ must create it with the correct configuration, such as the number of partitions and replicas.", "author": "PaulRMellor", "createdAt": "2020-11-25T09:32:24Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.\n+\n+Resources define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.\n+\n+For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.\n+\n+When viewing resources from the Keycloak user interface you will see a list of resource definitions.\n+These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.\n+For example, this pattern targets only topics in kafka cluster 'cluster-1' with names starting with 'a_':\n+\n+----\n+kafka-cluster:cluster-1,Topic:a_*  \n+---- \n+\n+If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  'x_':\n+----\n+Group:x_* \n+----\n+\n+\n+The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].\n+\n+*Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+The list of actions mirrors Kafka permissions and is the same for any deployment.\n+\n+Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.\n+\n+You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.\n+\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+The *Policies* tab has filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.\n+Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.\n+\n+The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.\n+\n+Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.\n+For example:\n+\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n+\n+There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n+\n+    bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+      --entity-type brokers --describe --entity-default\n+\n+But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.\n+\n+\n+### Client with Different Permissions\n+\n+Let's prepare a configuration for `team-b-client`:\n+\n+```\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+If we look at `team-b-client` client configuration in Keycloak, under `Service Account Roles` we can see that it has `Dev Team B` realm role assigned.\n+Looking in Keycloak Console at the `kafka` client's `Authorization` tab where `Permissions` are listed, we can see the permissions that start with 'Dev Team B ...'.\n+These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with 'b_' on Kafka cluster `my-cluster` (which is the designated cluster name of the demo cluster we brought up), and read access on topics that start with 'x_'.\n+\n+Let's try produce some messages to topic `a_messages` as `team-b-client`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get `Not authorized to access topics: [a_messages]` error as we expected. Let's try to produce to topic `b_messages`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+Message 2\n+Message 3\n+```\n+\n+This should work fine.\n+\n+What about producing to topic `x_messages`. `team-b-client` is only supposed to be able to read from such a topic.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get a `Not authorized to access topics: [x_messages]` error as we expected.\n+Client `team-a-client`, on the other hand, should be able to write to such a topic:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+```\n+\n+However, we again receive `Not authorized to access topics: [x_messages]`. What's going on?\n+The reason for failure is that while `team-a-client` can write to `x_messages` topic, it does not have a permission to create a topic if it does not yet exist.\n+\n+We now need a power user that can create a topic with all the proper settings - like the right number of partitions and replicas.", "originalCommit": "230db92e0f4d880e8d667eef9353cc2ceaa999f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDIzMjI1Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530232257", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ### Power User Can Do Anything\n          \n          \n            \n            .Managing Kafka with an authorized admin", "author": "PaulRMellor", "createdAt": "2020-11-25T09:39:20Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.\n+\n+Resources define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.\n+\n+For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.\n+\n+When viewing resources from the Keycloak user interface you will see a list of resource definitions.\n+These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.\n+For example, this pattern targets only topics in kafka cluster 'cluster-1' with names starting with 'a_':\n+\n+----\n+kafka-cluster:cluster-1,Topic:a_*  \n+---- \n+\n+If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  'x_':\n+----\n+Group:x_* \n+----\n+\n+\n+The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].\n+\n+*Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+The list of actions mirrors Kafka permissions and is the same for any deployment.\n+\n+Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.\n+\n+You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.\n+\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+The *Policies* tab has filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.\n+Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.\n+\n+The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.\n+\n+Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.\n+For example:\n+\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n+\n+There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n+\n+    bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+      --entity-type brokers --describe --entity-default\n+\n+But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.\n+\n+\n+### Client with Different Permissions\n+\n+Let's prepare a configuration for `team-b-client`:\n+\n+```\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+If we look at `team-b-client` client configuration in Keycloak, under `Service Account Roles` we can see that it has `Dev Team B` realm role assigned.\n+Looking in Keycloak Console at the `kafka` client's `Authorization` tab where `Permissions` are listed, we can see the permissions that start with 'Dev Team B ...'.\n+These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with 'b_' on Kafka cluster `my-cluster` (which is the designated cluster name of the demo cluster we brought up), and read access on topics that start with 'x_'.\n+\n+Let's try produce some messages to topic `a_messages` as `team-b-client`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get `Not authorized to access topics: [a_messages]` error as we expected. Let's try to produce to topic `b_messages`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+Message 2\n+Message 3\n+```\n+\n+This should work fine.\n+\n+What about producing to topic `x_messages`. `team-b-client` is only supposed to be able to read from such a topic.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get a `Not authorized to access topics: [x_messages]` error as we expected.\n+Client `team-a-client`, on the other hand, should be able to write to such a topic:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+```\n+\n+However, we again receive `Not authorized to access topics: [x_messages]`. What's going on?\n+The reason for failure is that while `team-a-client` can write to `x_messages` topic, it does not have a permission to create a topic if it does not yet exist.\n+\n+We now need a power user that can create a topic with all the proper settings - like the right number of partitions and replicas.\n+\n+\n+### Power User Can Do Anything", "originalCommit": "230db92e0f4d880e8d667eef9353cc2ceaa999f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDIzNTY1OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530235659", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Let's create a configuration for user `bob` who has full ability to manage everything on Kafka cluster `my-cluster`.\n          \n          \n            \n            \n          \n          \n            \n            We'll need some helper scripts so we can authenticate to the `keycloak` instance.\n          \n          \n            \n            Admin user `bob` is created with full access to manage everything on the Kafka cluster `my-cluster`.\n          \n          \n            \n            \n          \n          \n            \n            Helper scripts are used to authenticate to the `keycloak` instance.", "author": "PaulRMellor", "createdAt": "2020-11-25T09:44:13Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.\n+\n+Resources define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.\n+\n+For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.\n+\n+When viewing resources from the Keycloak user interface you will see a list of resource definitions.\n+These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.\n+For example, this pattern targets only topics in kafka cluster 'cluster-1' with names starting with 'a_':\n+\n+----\n+kafka-cluster:cluster-1,Topic:a_*  \n+---- \n+\n+If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  'x_':\n+----\n+Group:x_* \n+----\n+\n+\n+The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].\n+\n+*Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+The list of actions mirrors Kafka permissions and is the same for any deployment.\n+\n+Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.\n+\n+You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.\n+\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+The *Policies* tab has filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.\n+Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.\n+\n+The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.\n+\n+Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.\n+For example:\n+\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n+\n+There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n+\n+    bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+      --entity-type brokers --describe --entity-default\n+\n+But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.\n+\n+\n+### Client with Different Permissions\n+\n+Let's prepare a configuration for `team-b-client`:\n+\n+```\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+If we look at `team-b-client` client configuration in Keycloak, under `Service Account Roles` we can see that it has `Dev Team B` realm role assigned.\n+Looking in Keycloak Console at the `kafka` client's `Authorization` tab where `Permissions` are listed, we can see the permissions that start with 'Dev Team B ...'.\n+These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with 'b_' on Kafka cluster `my-cluster` (which is the designated cluster name of the demo cluster we brought up), and read access on topics that start with 'x_'.\n+\n+Let's try produce some messages to topic `a_messages` as `team-b-client`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get `Not authorized to access topics: [a_messages]` error as we expected. Let's try to produce to topic `b_messages`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+Message 2\n+Message 3\n+```\n+\n+This should work fine.\n+\n+What about producing to topic `x_messages`. `team-b-client` is only supposed to be able to read from such a topic.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get a `Not authorized to access topics: [x_messages]` error as we expected.\n+Client `team-a-client`, on the other hand, should be able to write to such a topic:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+```\n+\n+However, we again receive `Not authorized to access topics: [x_messages]`. What's going on?\n+The reason for failure is that while `team-a-client` can write to `x_messages` topic, it does not have a permission to create a topic if it does not yet exist.\n+\n+We now need a power user that can create a topic with all the proper settings - like the right number of partitions and replicas.\n+\n+\n+### Power User Can Do Anything\n+\n+Let's create a configuration for user `bob` who has full ability to manage everything on Kafka cluster `my-cluster`.\n+\n+We'll need some helper scripts so we can authenticate to the `keycloak` instance.", "originalCommit": "230db92e0f4d880e8d667eef9353cc2ceaa999f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDIzODM4OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530238388", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Download the following `oauth.sh` and `jwt.sh` tools to `/tmp` dir and make them executable:\n          \n          \n            \n            \n          \n          \n            \n               curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/oauth.sh -s > /tmp/oauth.sh\n          \n          \n            \n               chmod +x /tmp/oauth.sh\n          \n          \n            \n            \n          \n          \n            \n               curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/jwt.sh -s > /tmp/jwt.sh\n          \n          \n            \n               chmod +x /tmp/jwt.sh\n          \n          \n            \n            The following scripts are downloaded to `/tmp` dir and made executable:\n          \n          \n            \n            \n          \n          \n            \n            [source,shell]\n          \n          \n            \n            ----\n          \n          \n            \n            curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/oauth.sh -s > /tmp/oauth.sh\n          \n          \n            \n               chmod +x /tmp/oauth.sh\n          \n          \n            \n            \n          \n          \n            \n            curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/jwt.sh -s > /tmp/jwt.sh\n          \n          \n            \n               chmod +x /tmp/jwt.sh\n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-25T09:48:02Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.\n+\n+Resources define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.\n+\n+For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.\n+\n+When viewing resources from the Keycloak user interface you will see a list of resource definitions.\n+These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.\n+For example, this pattern targets only topics in kafka cluster 'cluster-1' with names starting with 'a_':\n+\n+----\n+kafka-cluster:cluster-1,Topic:a_*  \n+---- \n+\n+If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  'x_':\n+----\n+Group:x_* \n+----\n+\n+\n+The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].\n+\n+*Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+The list of actions mirrors Kafka permissions and is the same for any deployment.\n+\n+Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.\n+\n+You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.\n+\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+The *Policies* tab has filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.\n+Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.\n+\n+The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.\n+\n+Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.\n+For example:\n+\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n+\n+There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n+\n+    bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+      --entity-type brokers --describe --entity-default\n+\n+But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.\n+\n+\n+### Client with Different Permissions\n+\n+Let's prepare a configuration for `team-b-client`:\n+\n+```\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+If we look at `team-b-client` client configuration in Keycloak, under `Service Account Roles` we can see that it has `Dev Team B` realm role assigned.\n+Looking in Keycloak Console at the `kafka` client's `Authorization` tab where `Permissions` are listed, we can see the permissions that start with 'Dev Team B ...'.\n+These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with 'b_' on Kafka cluster `my-cluster` (which is the designated cluster name of the demo cluster we brought up), and read access on topics that start with 'x_'.\n+\n+Let's try produce some messages to topic `a_messages` as `team-b-client`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get `Not authorized to access topics: [a_messages]` error as we expected. Let's try to produce to topic `b_messages`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+Message 2\n+Message 3\n+```\n+\n+This should work fine.\n+\n+What about producing to topic `x_messages`. `team-b-client` is only supposed to be able to read from such a topic.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get a `Not authorized to access topics: [x_messages]` error as we expected.\n+Client `team-a-client`, on the other hand, should be able to write to such a topic:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+```\n+\n+However, we again receive `Not authorized to access topics: [x_messages]`. What's going on?\n+The reason for failure is that while `team-a-client` can write to `x_messages` topic, it does not have a permission to create a topic if it does not yet exist.\n+\n+We now need a power user that can create a topic with all the proper settings - like the right number of partitions and replicas.\n+\n+\n+### Power User Can Do Anything\n+\n+Let's create a configuration for user `bob` who has full ability to manage everything on Kafka cluster `my-cluster`.\n+\n+We'll need some helper scripts so we can authenticate to the `keycloak` instance.\n+\n+Download the following `oauth.sh` and `jwt.sh` tools to `/tmp` dir and make them executable:\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/oauth.sh -s > /tmp/oauth.sh\n+   chmod +x /tmp/oauth.sh\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/jwt.sh -s > /tmp/jwt.sh\n+   chmod +x /tmp/jwt.sh", "originalCommit": "230db92e0f4d880e8d667eef9353cc2ceaa999f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI0MDc2OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530240769", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Now, `bob` will authenticate to Keycloak server with his username and password and get a refresh token.\n          \n          \n            \n            \n          \n          \n            \n               export TOKEN_ENDPOINT=http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\n          \n          \n            \n               REFRESH_TOKEN=$(/tmp/oauth.sh -q bob)\n          \n          \n            \n            User `bob` authenticates to the Keycloak server with his username and password to get a refresh token.\n          \n          \n            \n            \n          \n          \n            \n            [source,shell]\n          \n          \n            \n            ----\n          \n          \n            \n            export TOKEN_ENDPOINT=http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\n          \n          \n            \n            REFRESH_TOKEN=$(/tmp/oauth.sh -q bob)\n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-25T09:51:29Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.\n+\n+Resources define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.\n+\n+For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.\n+\n+When viewing resources from the Keycloak user interface you will see a list of resource definitions.\n+These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.\n+For example, this pattern targets only topics in kafka cluster 'cluster-1' with names starting with 'a_':\n+\n+----\n+kafka-cluster:cluster-1,Topic:a_*  \n+---- \n+\n+If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  'x_':\n+----\n+Group:x_* \n+----\n+\n+\n+The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].\n+\n+*Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+The list of actions mirrors Kafka permissions and is the same for any deployment.\n+\n+Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.\n+\n+You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.\n+\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+The *Policies* tab has filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.\n+Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.\n+\n+The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.\n+\n+Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.\n+For example:\n+\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n+\n+There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n+\n+    bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+      --entity-type brokers --describe --entity-default\n+\n+But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.\n+\n+\n+### Client with Different Permissions\n+\n+Let's prepare a configuration for `team-b-client`:\n+\n+```\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+If we look at `team-b-client` client configuration in Keycloak, under `Service Account Roles` we can see that it has `Dev Team B` realm role assigned.\n+Looking in Keycloak Console at the `kafka` client's `Authorization` tab where `Permissions` are listed, we can see the permissions that start with 'Dev Team B ...'.\n+These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with 'b_' on Kafka cluster `my-cluster` (which is the designated cluster name of the demo cluster we brought up), and read access on topics that start with 'x_'.\n+\n+Let's try produce some messages to topic `a_messages` as `team-b-client`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get `Not authorized to access topics: [a_messages]` error as we expected. Let's try to produce to topic `b_messages`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+Message 2\n+Message 3\n+```\n+\n+This should work fine.\n+\n+What about producing to topic `x_messages`. `team-b-client` is only supposed to be able to read from such a topic.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get a `Not authorized to access topics: [x_messages]` error as we expected.\n+Client `team-a-client`, on the other hand, should be able to write to such a topic:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+```\n+\n+However, we again receive `Not authorized to access topics: [x_messages]`. What's going on?\n+The reason for failure is that while `team-a-client` can write to `x_messages` topic, it does not have a permission to create a topic if it does not yet exist.\n+\n+We now need a power user that can create a topic with all the proper settings - like the right number of partitions and replicas.\n+\n+\n+### Power User Can Do Anything\n+\n+Let's create a configuration for user `bob` who has full ability to manage everything on Kafka cluster `my-cluster`.\n+\n+We'll need some helper scripts so we can authenticate to the `keycloak` instance.\n+\n+Download the following `oauth.sh` and `jwt.sh` tools to `/tmp` dir and make them executable:\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/oauth.sh -s > /tmp/oauth.sh\n+   chmod +x /tmp/oauth.sh\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/jwt.sh -s > /tmp/jwt.sh\n+   chmod +x /tmp/jwt.sh\n+\n+Now, `bob` will authenticate to Keycloak server with his username and password and get a refresh token.\n+\n+   export TOKEN_ENDPOINT=http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\n+   REFRESH_TOKEN=$(/tmp/oauth.sh -q bob)", "originalCommit": "230db92e0f4d880e8d667eef9353cc2ceaa999f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI0ODUzMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530248530", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This will prompt you for a password. Type 'bob-password'.\n          \n          \n            \n            When prompted for a password, 'bob-password' is used.", "author": "PaulRMellor", "createdAt": "2020-11-25T10:02:26Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.\n+\n+Resources define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.\n+\n+For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.\n+\n+When viewing resources from the Keycloak user interface you will see a list of resource definitions.\n+These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.\n+For example, this pattern targets only topics in kafka cluster 'cluster-1' with names starting with 'a_':\n+\n+----\n+kafka-cluster:cluster-1,Topic:a_*  \n+---- \n+\n+If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  'x_':\n+----\n+Group:x_* \n+----\n+\n+\n+The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].\n+\n+*Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+The list of actions mirrors Kafka permissions and is the same for any deployment.\n+\n+Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.\n+\n+You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.\n+\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+The *Policies* tab has filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.\n+Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.\n+\n+The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.\n+\n+Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.\n+For example:\n+\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n+\n+There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n+\n+    bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+      --entity-type brokers --describe --entity-default\n+\n+But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.\n+\n+\n+### Client with Different Permissions\n+\n+Let's prepare a configuration for `team-b-client`:\n+\n+```\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+If we look at `team-b-client` client configuration in Keycloak, under `Service Account Roles` we can see that it has `Dev Team B` realm role assigned.\n+Looking in Keycloak Console at the `kafka` client's `Authorization` tab where `Permissions` are listed, we can see the permissions that start with 'Dev Team B ...'.\n+These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with 'b_' on Kafka cluster `my-cluster` (which is the designated cluster name of the demo cluster we brought up), and read access on topics that start with 'x_'.\n+\n+Let's try produce some messages to topic `a_messages` as `team-b-client`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get `Not authorized to access topics: [a_messages]` error as we expected. Let's try to produce to topic `b_messages`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+Message 2\n+Message 3\n+```\n+\n+This should work fine.\n+\n+What about producing to topic `x_messages`. `team-b-client` is only supposed to be able to read from such a topic.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get a `Not authorized to access topics: [x_messages]` error as we expected.\n+Client `team-a-client`, on the other hand, should be able to write to such a topic:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+```\n+\n+However, we again receive `Not authorized to access topics: [x_messages]`. What's going on?\n+The reason for failure is that while `team-a-client` can write to `x_messages` topic, it does not have a permission to create a topic if it does not yet exist.\n+\n+We now need a power user that can create a topic with all the proper settings - like the right number of partitions and replicas.\n+\n+\n+### Power User Can Do Anything\n+\n+Let's create a configuration for user `bob` who has full ability to manage everything on Kafka cluster `my-cluster`.\n+\n+We'll need some helper scripts so we can authenticate to the `keycloak` instance.\n+\n+Download the following `oauth.sh` and `jwt.sh` tools to `/tmp` dir and make them executable:\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/oauth.sh -s > /tmp/oauth.sh\n+   chmod +x /tmp/oauth.sh\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/jwt.sh -s > /tmp/jwt.sh\n+   chmod +x /tmp/jwt.sh\n+\n+Now, `bob` will authenticate to Keycloak server with his username and password and get a refresh token.\n+\n+   export TOKEN_ENDPOINT=http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\n+   REFRESH_TOKEN=$(/tmp/oauth.sh -q bob)\n+\n+This will prompt you for a password. Type 'bob-password'.", "originalCommit": "230db92e0f4d880e8d667eef9353cc2ceaa999f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI1MDE0MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530250140", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            We can inspect the refresh token:\n          \n          \n            \n            \n          \n          \n            \n               /tmp/jwt.sh $REFRESH_TOKEN\n          \n          \n            \n            \n          \n          \n            \n            By default this is a long-lived refresh token that does not expire.\n          \n          \n            \n            The refresh token is a long-lived token that does not expire:\n          \n          \n            \n            \n          \n          \n            \n            ----\n          \n          \n            \n             /tmp/jwt.sh $REFRESH_TOKEN\n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-25T10:04:47Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.\n+\n+Resources define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.\n+\n+For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.\n+\n+When viewing resources from the Keycloak user interface you will see a list of resource definitions.\n+These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.\n+For example, this pattern targets only topics in kafka cluster 'cluster-1' with names starting with 'a_':\n+\n+----\n+kafka-cluster:cluster-1,Topic:a_*  \n+---- \n+\n+If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  'x_':\n+----\n+Group:x_* \n+----\n+\n+\n+The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].\n+\n+*Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+The list of actions mirrors Kafka permissions and is the same for any deployment.\n+\n+Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.\n+\n+You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.\n+\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+The *Policies* tab has filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.\n+Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.\n+\n+The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.\n+\n+Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.\n+For example:\n+\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n+\n+There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n+\n+    bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+      --entity-type brokers --describe --entity-default\n+\n+But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.\n+\n+\n+### Client with Different Permissions\n+\n+Let's prepare a configuration for `team-b-client`:\n+\n+```\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+If we look at `team-b-client` client configuration in Keycloak, under `Service Account Roles` we can see that it has `Dev Team B` realm role assigned.\n+Looking in Keycloak Console at the `kafka` client's `Authorization` tab where `Permissions` are listed, we can see the permissions that start with 'Dev Team B ...'.\n+These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with 'b_' on Kafka cluster `my-cluster` (which is the designated cluster name of the demo cluster we brought up), and read access on topics that start with 'x_'.\n+\n+Let's try produce some messages to topic `a_messages` as `team-b-client`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get `Not authorized to access topics: [a_messages]` error as we expected. Let's try to produce to topic `b_messages`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+Message 2\n+Message 3\n+```\n+\n+This should work fine.\n+\n+What about producing to topic `x_messages`. `team-b-client` is only supposed to be able to read from such a topic.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get a `Not authorized to access topics: [x_messages]` error as we expected.\n+Client `team-a-client`, on the other hand, should be able to write to such a topic:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+```\n+\n+However, we again receive `Not authorized to access topics: [x_messages]`. What's going on?\n+The reason for failure is that while `team-a-client` can write to `x_messages` topic, it does not have a permission to create a topic if it does not yet exist.\n+\n+We now need a power user that can create a topic with all the proper settings - like the right number of partitions and replicas.\n+\n+\n+### Power User Can Do Anything\n+\n+Let's create a configuration for user `bob` who has full ability to manage everything on Kafka cluster `my-cluster`.\n+\n+We'll need some helper scripts so we can authenticate to the `keycloak` instance.\n+\n+Download the following `oauth.sh` and `jwt.sh` tools to `/tmp` dir and make them executable:\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/oauth.sh -s > /tmp/oauth.sh\n+   chmod +x /tmp/oauth.sh\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/jwt.sh -s > /tmp/jwt.sh\n+   chmod +x /tmp/jwt.sh\n+\n+Now, `bob` will authenticate to Keycloak server with his username and password and get a refresh token.\n+\n+   export TOKEN_ENDPOINT=http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\n+   REFRESH_TOKEN=$(/tmp/oauth.sh -q bob)\n+\n+This will prompt you for a password. Type 'bob-password'.\n+\n+We can inspect the refresh token:\n+\n+   /tmp/jwt.sh $REFRESH_TOKEN\n+\n+By default this is a long-lived refresh token that does not expire.", "originalCommit": "230db92e0f4d880e8d667eef9353cc2ceaa999f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI1MDY2Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530250663", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Now we will create the configuration file for `bob`:\n          \n          \n            \n            \n          \n          \n            \n            ```\n          \n          \n            \n            cat > /tmp/bob.properties << EOF\n          \n          \n            \n            security.protocol=SASL_PLAINTEXT\n          \n          \n            \n            sasl.mechanism=OAUTHBEARER\n          \n          \n            \n            sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n          \n          \n            \n              oauth.refresh.token=\"$REFRESH_TOKEN\" \\\n          \n          \n            \n              oauth.client.id=\"kafka-cli\" \\\n          \n          \n            \n              oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n          \n          \n            \n            sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n          \n          \n            \n            EOF\n          \n          \n            \n            ```\n          \n          \n            \n            A configuration file is created for `bob`:\n          \n          \n            \n            \n          \n          \n            \n            [source,shell]\n          \n          \n            \n            ----\n          \n          \n            \n            cat > /tmp/bob.properties << EOF\n          \n          \n            \n            security.protocol=SASL_PLAINTEXT\n          \n          \n            \n            sasl.mechanism=OAUTHBEARER\n          \n          \n            \n            sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n          \n          \n            \n              oauth.refresh.token=\"$REFRESH_TOKEN\" \\\n          \n          \n            \n              oauth.client.id=\"kafka-cli\" \\\n          \n          \n            \n              oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n          \n          \n            \n            sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n          \n          \n            \n            EOF\n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-25T10:05:34Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.\n+\n+Resources define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.\n+\n+For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.\n+\n+When viewing resources from the Keycloak user interface you will see a list of resource definitions.\n+These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.\n+For example, this pattern targets only topics in kafka cluster 'cluster-1' with names starting with 'a_':\n+\n+----\n+kafka-cluster:cluster-1,Topic:a_*  \n+---- \n+\n+If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  'x_':\n+----\n+Group:x_* \n+----\n+\n+\n+The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].\n+\n+*Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+The list of actions mirrors Kafka permissions and is the same for any deployment.\n+\n+Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.\n+\n+You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.\n+\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+The *Policies* tab has filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.\n+Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.\n+\n+The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.\n+\n+Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.\n+For example:\n+\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n+\n+There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n+\n+    bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+      --entity-type brokers --describe --entity-default\n+\n+But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.\n+\n+\n+### Client with Different Permissions\n+\n+Let's prepare a configuration for `team-b-client`:\n+\n+```\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+If we look at `team-b-client` client configuration in Keycloak, under `Service Account Roles` we can see that it has `Dev Team B` realm role assigned.\n+Looking in Keycloak Console at the `kafka` client's `Authorization` tab where `Permissions` are listed, we can see the permissions that start with 'Dev Team B ...'.\n+These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with 'b_' on Kafka cluster `my-cluster` (which is the designated cluster name of the demo cluster we brought up), and read access on topics that start with 'x_'.\n+\n+Let's try produce some messages to topic `a_messages` as `team-b-client`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get `Not authorized to access topics: [a_messages]` error as we expected. Let's try to produce to topic `b_messages`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+Message 2\n+Message 3\n+```\n+\n+This should work fine.\n+\n+What about producing to topic `x_messages`. `team-b-client` is only supposed to be able to read from such a topic.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get a `Not authorized to access topics: [x_messages]` error as we expected.\n+Client `team-a-client`, on the other hand, should be able to write to such a topic:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+```\n+\n+However, we again receive `Not authorized to access topics: [x_messages]`. What's going on?\n+The reason for failure is that while `team-a-client` can write to `x_messages` topic, it does not have a permission to create a topic if it does not yet exist.\n+\n+We now need a power user that can create a topic with all the proper settings - like the right number of partitions and replicas.\n+\n+\n+### Power User Can Do Anything\n+\n+Let's create a configuration for user `bob` who has full ability to manage everything on Kafka cluster `my-cluster`.\n+\n+We'll need some helper scripts so we can authenticate to the `keycloak` instance.\n+\n+Download the following `oauth.sh` and `jwt.sh` tools to `/tmp` dir and make them executable:\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/oauth.sh -s > /tmp/oauth.sh\n+   chmod +x /tmp/oauth.sh\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/jwt.sh -s > /tmp/jwt.sh\n+   chmod +x /tmp/jwt.sh\n+\n+Now, `bob` will authenticate to Keycloak server with his username and password and get a refresh token.\n+\n+   export TOKEN_ENDPOINT=http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\n+   REFRESH_TOKEN=$(/tmp/oauth.sh -q bob)\n+\n+This will prompt you for a password. Type 'bob-password'.\n+\n+We can inspect the refresh token:\n+\n+   /tmp/jwt.sh $REFRESH_TOKEN\n+\n+By default this is a long-lived refresh token that does not expire.\n+\n+Now we will create the configuration file for `bob`:\n+\n+```\n+cat > /tmp/bob.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.refresh.token=\"$REFRESH_TOKEN\" \\\n+  oauth.client.id=\"kafka-cli\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```", "originalCommit": "230db92e0f4d880e8d667eef9353cc2ceaa999f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI1MzA2MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530253061", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Note that we use the `kafka-cli` public client for the `oauth.client.id` in the `sasl.jaas.config`.\n          \n          \n            \n            Since that is a public client it does not require any secret.\n          \n          \n            \n            We can use this because we authenticate with a token directly (in this case a refresh token is used to request an access token behind the scenes which is then sent to Kafka broker for authentication, and we already did the authentication for the refresh token).\n          \n          \n            \n            The `kafka-cli` public client is used for the `oauth.client.id` in the `sasl.jaas.config`.\n          \n          \n            \n            Since that is a public client it does not require a Secret.\n          \n          \n            \n            We can use this because we authenticate with a token directly. In this case, the refresh token requests an access token behind the scenes, which is then sent to the Kafka broker for authentication. The refresh token has already been authenticated.", "author": "PaulRMellor", "createdAt": "2020-11-25T10:09:22Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.\n+\n+Resources define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.\n+\n+For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.\n+\n+When viewing resources from the Keycloak user interface you will see a list of resource definitions.\n+These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.\n+For example, this pattern targets only topics in kafka cluster 'cluster-1' with names starting with 'a_':\n+\n+----\n+kafka-cluster:cluster-1,Topic:a_*  \n+---- \n+\n+If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  'x_':\n+----\n+Group:x_* \n+----\n+\n+\n+The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].\n+\n+*Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+The list of actions mirrors Kafka permissions and is the same for any deployment.\n+\n+Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.\n+\n+You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.\n+\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+The *Policies* tab has filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.\n+Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.\n+\n+The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.\n+\n+Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.\n+For example:\n+\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n+\n+There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n+\n+    bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+      --entity-type brokers --describe --entity-default\n+\n+But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.\n+\n+\n+### Client with Different Permissions\n+\n+Let's prepare a configuration for `team-b-client`:\n+\n+```\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+If we look at `team-b-client` client configuration in Keycloak, under `Service Account Roles` we can see that it has `Dev Team B` realm role assigned.\n+Looking in Keycloak Console at the `kafka` client's `Authorization` tab where `Permissions` are listed, we can see the permissions that start with 'Dev Team B ...'.\n+These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with 'b_' on Kafka cluster `my-cluster` (which is the designated cluster name of the demo cluster we brought up), and read access on topics that start with 'x_'.\n+\n+Let's try produce some messages to topic `a_messages` as `team-b-client`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get `Not authorized to access topics: [a_messages]` error as we expected. Let's try to produce to topic `b_messages`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+Message 2\n+Message 3\n+```\n+\n+This should work fine.\n+\n+What about producing to topic `x_messages`. `team-b-client` is only supposed to be able to read from such a topic.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get a `Not authorized to access topics: [x_messages]` error as we expected.\n+Client `team-a-client`, on the other hand, should be able to write to such a topic:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+```\n+\n+However, we again receive `Not authorized to access topics: [x_messages]`. What's going on?\n+The reason for failure is that while `team-a-client` can write to `x_messages` topic, it does not have a permission to create a topic if it does not yet exist.\n+\n+We now need a power user that can create a topic with all the proper settings - like the right number of partitions and replicas.\n+\n+\n+### Power User Can Do Anything\n+\n+Let's create a configuration for user `bob` who has full ability to manage everything on Kafka cluster `my-cluster`.\n+\n+We'll need some helper scripts so we can authenticate to the `keycloak` instance.\n+\n+Download the following `oauth.sh` and `jwt.sh` tools to `/tmp` dir and make them executable:\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/oauth.sh -s > /tmp/oauth.sh\n+   chmod +x /tmp/oauth.sh\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/jwt.sh -s > /tmp/jwt.sh\n+   chmod +x /tmp/jwt.sh\n+\n+Now, `bob` will authenticate to Keycloak server with his username and password and get a refresh token.\n+\n+   export TOKEN_ENDPOINT=http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\n+   REFRESH_TOKEN=$(/tmp/oauth.sh -q bob)\n+\n+This will prompt you for a password. Type 'bob-password'.\n+\n+We can inspect the refresh token:\n+\n+   /tmp/jwt.sh $REFRESH_TOKEN\n+\n+By default this is a long-lived refresh token that does not expire.\n+\n+Now we will create the configuration file for `bob`:\n+\n+```\n+cat > /tmp/bob.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.refresh.token=\"$REFRESH_TOKEN\" \\\n+  oauth.client.id=\"kafka-cli\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+Note that we use the `kafka-cli` public client for the `oauth.client.id` in the `sasl.jaas.config`.\n+Since that is a public client it does not require any secret.\n+We can use this because we authenticate with a token directly (in this case a refresh token is used to request an access token behind the scenes which is then sent to Kafka broker for authentication, and we already did the authentication for the refresh token).", "originalCommit": "230db92e0f4d880e8d667eef9353cc2ceaa999f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI1NDIwNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530254204", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Let's now try to create the `x_messages` topic:\n          \n          \n            \n            \n          \n          \n            \n                bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/bob.properties \\\n          \n          \n            \n                  --topic x_messages --create --replication-factor 1 --partitions 1\n          \n          \n            \n            User `bob` has permission to create the `x_messages` topic:\n          \n          \n            \n            \n          \n          \n            \n            [source,shell]\n          \n          \n            \n            ----\n          \n          \n            \n            bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/bob.properties \\\n          \n          \n            \n              --topic x_messages --create --replication-factor 1 --partitions 1\n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-25T10:11:04Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.\n+\n+Resources define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.\n+\n+For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.\n+\n+When viewing resources from the Keycloak user interface you will see a list of resource definitions.\n+These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.\n+For example, this pattern targets only topics in kafka cluster 'cluster-1' with names starting with 'a_':\n+\n+----\n+kafka-cluster:cluster-1,Topic:a_*  \n+---- \n+\n+If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  'x_':\n+----\n+Group:x_* \n+----\n+\n+\n+The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].\n+\n+*Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+The list of actions mirrors Kafka permissions and is the same for any deployment.\n+\n+Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.\n+\n+You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.\n+\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+The *Policies* tab has filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.\n+Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.\n+\n+The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.\n+\n+Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.\n+For example:\n+\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n+\n+There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n+\n+    bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+      --entity-type brokers --describe --entity-default\n+\n+But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.\n+\n+\n+### Client with Different Permissions\n+\n+Let's prepare a configuration for `team-b-client`:\n+\n+```\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+If we look at `team-b-client` client configuration in Keycloak, under `Service Account Roles` we can see that it has `Dev Team B` realm role assigned.\n+Looking in Keycloak Console at the `kafka` client's `Authorization` tab where `Permissions` are listed, we can see the permissions that start with 'Dev Team B ...'.\n+These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with 'b_' on Kafka cluster `my-cluster` (which is the designated cluster name of the demo cluster we brought up), and read access on topics that start with 'x_'.\n+\n+Let's try produce some messages to topic `a_messages` as `team-b-client`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get `Not authorized to access topics: [a_messages]` error as we expected. Let's try to produce to topic `b_messages`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+Message 2\n+Message 3\n+```\n+\n+This should work fine.\n+\n+What about producing to topic `x_messages`. `team-b-client` is only supposed to be able to read from such a topic.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get a `Not authorized to access topics: [x_messages]` error as we expected.\n+Client `team-a-client`, on the other hand, should be able to write to such a topic:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+```\n+\n+However, we again receive `Not authorized to access topics: [x_messages]`. What's going on?\n+The reason for failure is that while `team-a-client` can write to `x_messages` topic, it does not have a permission to create a topic if it does not yet exist.\n+\n+We now need a power user that can create a topic with all the proper settings - like the right number of partitions and replicas.\n+\n+\n+### Power User Can Do Anything\n+\n+Let's create a configuration for user `bob` who has full ability to manage everything on Kafka cluster `my-cluster`.\n+\n+We'll need some helper scripts so we can authenticate to the `keycloak` instance.\n+\n+Download the following `oauth.sh` and `jwt.sh` tools to `/tmp` dir and make them executable:\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/oauth.sh -s > /tmp/oauth.sh\n+   chmod +x /tmp/oauth.sh\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/jwt.sh -s > /tmp/jwt.sh\n+   chmod +x /tmp/jwt.sh\n+\n+Now, `bob` will authenticate to Keycloak server with his username and password and get a refresh token.\n+\n+   export TOKEN_ENDPOINT=http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\n+   REFRESH_TOKEN=$(/tmp/oauth.sh -q bob)\n+\n+This will prompt you for a password. Type 'bob-password'.\n+\n+We can inspect the refresh token:\n+\n+   /tmp/jwt.sh $REFRESH_TOKEN\n+\n+By default this is a long-lived refresh token that does not expire.\n+\n+Now we will create the configuration file for `bob`:\n+\n+```\n+cat > /tmp/bob.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.refresh.token=\"$REFRESH_TOKEN\" \\\n+  oauth.client.id=\"kafka-cli\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+Note that we use the `kafka-cli` public client for the `oauth.client.id` in the `sasl.jaas.config`.\n+Since that is a public client it does not require any secret.\n+We can use this because we authenticate with a token directly (in this case a refresh token is used to request an access token behind the scenes which is then sent to Kafka broker for authentication, and we already did the authentication for the refresh token).\n+\n+\n+Let's now try to create the `x_messages` topic:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/bob.properties \\\n+      --topic x_messages --create --replication-factor 1 --partitions 1", "originalCommit": "230db92e0f4d880e8d667eef9353cc2ceaa999f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI1NjgyNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530256824", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The operation should succeed (you can ignore the warning about periods and underscores).", "author": "PaulRMellor", "createdAt": "2020-11-25T10:14:54Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.\n+\n+Resources define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.\n+\n+For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.\n+\n+When viewing resources from the Keycloak user interface you will see a list of resource definitions.\n+These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.\n+For example, this pattern targets only topics in kafka cluster 'cluster-1' with names starting with 'a_':\n+\n+----\n+kafka-cluster:cluster-1,Topic:a_*  \n+---- \n+\n+If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  'x_':\n+----\n+Group:x_* \n+----\n+\n+\n+The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].\n+\n+*Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+The list of actions mirrors Kafka permissions and is the same for any deployment.\n+\n+Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.\n+\n+You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.\n+\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+The *Policies* tab has filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.\n+Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.\n+\n+The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.\n+\n+Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.\n+For example:\n+\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n+\n+There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n+\n+    bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+      --entity-type brokers --describe --entity-default\n+\n+But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.\n+\n+\n+### Client with Different Permissions\n+\n+Let's prepare a configuration for `team-b-client`:\n+\n+```\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+If we look at `team-b-client` client configuration in Keycloak, under `Service Account Roles` we can see that it has `Dev Team B` realm role assigned.\n+Looking in Keycloak Console at the `kafka` client's `Authorization` tab where `Permissions` are listed, we can see the permissions that start with 'Dev Team B ...'.\n+These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with 'b_' on Kafka cluster `my-cluster` (which is the designated cluster name of the demo cluster we brought up), and read access on topics that start with 'x_'.\n+\n+Let's try produce some messages to topic `a_messages` as `team-b-client`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get `Not authorized to access topics: [a_messages]` error as we expected. Let's try to produce to topic `b_messages`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+Message 2\n+Message 3\n+```\n+\n+This should work fine.\n+\n+What about producing to topic `x_messages`. `team-b-client` is only supposed to be able to read from such a topic.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get a `Not authorized to access topics: [x_messages]` error as we expected.\n+Client `team-a-client`, on the other hand, should be able to write to such a topic:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+```\n+\n+However, we again receive `Not authorized to access topics: [x_messages]`. What's going on?\n+The reason for failure is that while `team-a-client` can write to `x_messages` topic, it does not have a permission to create a topic if it does not yet exist.\n+\n+We now need a power user that can create a topic with all the proper settings - like the right number of partitions and replicas.\n+\n+\n+### Power User Can Do Anything\n+\n+Let's create a configuration for user `bob` who has full ability to manage everything on Kafka cluster `my-cluster`.\n+\n+We'll need some helper scripts so we can authenticate to the `keycloak` instance.\n+\n+Download the following `oauth.sh` and `jwt.sh` tools to `/tmp` dir and make them executable:\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/oauth.sh -s > /tmp/oauth.sh\n+   chmod +x /tmp/oauth.sh\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/jwt.sh -s > /tmp/jwt.sh\n+   chmod +x /tmp/jwt.sh\n+\n+Now, `bob` will authenticate to Keycloak server with his username and password and get a refresh token.\n+\n+   export TOKEN_ENDPOINT=http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\n+   REFRESH_TOKEN=$(/tmp/oauth.sh -q bob)\n+\n+This will prompt you for a password. Type 'bob-password'.\n+\n+We can inspect the refresh token:\n+\n+   /tmp/jwt.sh $REFRESH_TOKEN\n+\n+By default this is a long-lived refresh token that does not expire.\n+\n+Now we will create the configuration file for `bob`:\n+\n+```\n+cat > /tmp/bob.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.refresh.token=\"$REFRESH_TOKEN\" \\\n+  oauth.client.id=\"kafka-cli\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+Note that we use the `kafka-cli` public client for the `oauth.client.id` in the `sasl.jaas.config`.\n+Since that is a public client it does not require any secret.\n+We can use this because we authenticate with a token directly (in this case a refresh token is used to request an access token behind the scenes which is then sent to Kafka broker for authentication, and we already did the authentication for the refresh token).\n+\n+\n+Let's now try to create the `x_messages` topic:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/bob.properties \\\n+      --topic x_messages --create --replication-factor 1 --partitions 1\n+\n+The operation should succeed (you can ignore the warning about periods and underscores).", "originalCommit": "230db92e0f4d880e8d667eef9353cc2ceaa999f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI2MTEyNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530261125", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            We can list the topics:\n          \n          \n            \n            \n          \n          \n            \n                bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/bob.properties --list\n          \n          \n            \n            \n          \n          \n            \n            If we try the same as `team-a-client` or `team-b-client` we will get different responses.\n          \n          \n            \n            \n          \n          \n            \n                bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n          \n          \n            \n                bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-b-client.properties --list\n          \n          \n            \n            User `bob` can list the topic, but `team-a-client` and `team-b-client` cannot.\n          \n          \n            \n            \n          \n          \n            \n            [source,shell]\n          \n          \n            \n            ----\n          \n          \n            \n            bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/bob.properties --list\n          \n          \n            \n            bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n          \n          \n            \n            bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-b-client.properties --list", "author": "PaulRMellor", "createdAt": "2020-11-25T10:21:17Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.\n+\n+Resources define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.\n+\n+For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.\n+\n+When viewing resources from the Keycloak user interface you will see a list of resource definitions.\n+These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.\n+For example, this pattern targets only topics in kafka cluster 'cluster-1' with names starting with 'a_':\n+\n+----\n+kafka-cluster:cluster-1,Topic:a_*  \n+---- \n+\n+If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  'x_':\n+----\n+Group:x_* \n+----\n+\n+\n+The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].\n+\n+*Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+The list of actions mirrors Kafka permissions and is the same for any deployment.\n+\n+Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.\n+\n+You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.\n+\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+The *Policies* tab has filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.\n+Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.\n+\n+The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.\n+\n+Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.\n+For example:\n+\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n+\n+There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n+\n+    bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+      --entity-type brokers --describe --entity-default\n+\n+But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.\n+\n+\n+### Client with Different Permissions\n+\n+Let's prepare a configuration for `team-b-client`:\n+\n+```\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+If we look at `team-b-client` client configuration in Keycloak, under `Service Account Roles` we can see that it has `Dev Team B` realm role assigned.\n+Looking in Keycloak Console at the `kafka` client's `Authorization` tab where `Permissions` are listed, we can see the permissions that start with 'Dev Team B ...'.\n+These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with 'b_' on Kafka cluster `my-cluster` (which is the designated cluster name of the demo cluster we brought up), and read access on topics that start with 'x_'.\n+\n+Let's try produce some messages to topic `a_messages` as `team-b-client`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get `Not authorized to access topics: [a_messages]` error as we expected. Let's try to produce to topic `b_messages`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+Message 2\n+Message 3\n+```\n+\n+This should work fine.\n+\n+What about producing to topic `x_messages`. `team-b-client` is only supposed to be able to read from such a topic.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get a `Not authorized to access topics: [x_messages]` error as we expected.\n+Client `team-a-client`, on the other hand, should be able to write to such a topic:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+```\n+\n+However, we again receive `Not authorized to access topics: [x_messages]`. What's going on?\n+The reason for failure is that while `team-a-client` can write to `x_messages` topic, it does not have a permission to create a topic if it does not yet exist.\n+\n+We now need a power user that can create a topic with all the proper settings - like the right number of partitions and replicas.\n+\n+\n+### Power User Can Do Anything\n+\n+Let's create a configuration for user `bob` who has full ability to manage everything on Kafka cluster `my-cluster`.\n+\n+We'll need some helper scripts so we can authenticate to the `keycloak` instance.\n+\n+Download the following `oauth.sh` and `jwt.sh` tools to `/tmp` dir and make them executable:\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/oauth.sh -s > /tmp/oauth.sh\n+   chmod +x /tmp/oauth.sh\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/jwt.sh -s > /tmp/jwt.sh\n+   chmod +x /tmp/jwt.sh\n+\n+Now, `bob` will authenticate to Keycloak server with his username and password and get a refresh token.\n+\n+   export TOKEN_ENDPOINT=http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\n+   REFRESH_TOKEN=$(/tmp/oauth.sh -q bob)\n+\n+This will prompt you for a password. Type 'bob-password'.\n+\n+We can inspect the refresh token:\n+\n+   /tmp/jwt.sh $REFRESH_TOKEN\n+\n+By default this is a long-lived refresh token that does not expire.\n+\n+Now we will create the configuration file for `bob`:\n+\n+```\n+cat > /tmp/bob.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.refresh.token=\"$REFRESH_TOKEN\" \\\n+  oauth.client.id=\"kafka-cli\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+Note that we use the `kafka-cli` public client for the `oauth.client.id` in the `sasl.jaas.config`.\n+Since that is a public client it does not require any secret.\n+We can use this because we authenticate with a token directly (in this case a refresh token is used to request an access token behind the scenes which is then sent to Kafka broker for authentication, and we already did the authentication for the refresh token).\n+\n+\n+Let's now try to create the `x_messages` topic:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/bob.properties \\\n+      --topic x_messages --create --replication-factor 1 --partitions 1\n+\n+The operation should succeed (you can ignore the warning about periods and underscores).\n+\n+We can list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/bob.properties --list\n+\n+If we try the same as `team-a-client` or `team-b-client` we will get different responses.\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-b-client.properties --list", "originalCommit": "230db92e0f4d880e8d667eef9353cc2ceaa999f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI2MTU5NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530261594", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Roles `Dev Team A`, and `Dev Team B` both have `Describe` permission on topics that start with 'x_', but they cannot see the other team's topics as they do not have `Describe` permissions on them.\n          \n          \n            \n            The `Dev Team A`, and `Dev Team B` roles both have `Describe` permission on topics that start with `x_`, but they cannot see the other team's topics as they do not have `Describe` permissions on them.", "author": "PaulRMellor", "createdAt": "2020-11-25T10:22:02Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.\n+\n+Resources define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.\n+\n+For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.\n+\n+When viewing resources from the Keycloak user interface you will see a list of resource definitions.\n+These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.\n+For example, this pattern targets only topics in kafka cluster 'cluster-1' with names starting with 'a_':\n+\n+----\n+kafka-cluster:cluster-1,Topic:a_*  \n+---- \n+\n+If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  'x_':\n+----\n+Group:x_* \n+----\n+\n+\n+The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].\n+\n+*Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+The list of actions mirrors Kafka permissions and is the same for any deployment.\n+\n+Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.\n+\n+You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.\n+\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+The *Policies* tab has filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.\n+Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.\n+\n+The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.\n+\n+Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.\n+For example:\n+\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n+\n+There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n+\n+    bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+      --entity-type brokers --describe --entity-default\n+\n+But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.\n+\n+\n+### Client with Different Permissions\n+\n+Let's prepare a configuration for `team-b-client`:\n+\n+```\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+If we look at `team-b-client` client configuration in Keycloak, under `Service Account Roles` we can see that it has `Dev Team B` realm role assigned.\n+Looking in Keycloak Console at the `kafka` client's `Authorization` tab where `Permissions` are listed, we can see the permissions that start with 'Dev Team B ...'.\n+These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with 'b_' on Kafka cluster `my-cluster` (which is the designated cluster name of the demo cluster we brought up), and read access on topics that start with 'x_'.\n+\n+Let's try produce some messages to topic `a_messages` as `team-b-client`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get `Not authorized to access topics: [a_messages]` error as we expected. Let's try to produce to topic `b_messages`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+Message 2\n+Message 3\n+```\n+\n+This should work fine.\n+\n+What about producing to topic `x_messages`. `team-b-client` is only supposed to be able to read from such a topic.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get a `Not authorized to access topics: [x_messages]` error as we expected.\n+Client `team-a-client`, on the other hand, should be able to write to such a topic:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+```\n+\n+However, we again receive `Not authorized to access topics: [x_messages]`. What's going on?\n+The reason for failure is that while `team-a-client` can write to `x_messages` topic, it does not have a permission to create a topic if it does not yet exist.\n+\n+We now need a power user that can create a topic with all the proper settings - like the right number of partitions and replicas.\n+\n+\n+### Power User Can Do Anything\n+\n+Let's create a configuration for user `bob` who has full ability to manage everything on Kafka cluster `my-cluster`.\n+\n+We'll need some helper scripts so we can authenticate to the `keycloak` instance.\n+\n+Download the following `oauth.sh` and `jwt.sh` tools to `/tmp` dir and make them executable:\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/oauth.sh -s > /tmp/oauth.sh\n+   chmod +x /tmp/oauth.sh\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/jwt.sh -s > /tmp/jwt.sh\n+   chmod +x /tmp/jwt.sh\n+\n+Now, `bob` will authenticate to Keycloak server with his username and password and get a refresh token.\n+\n+   export TOKEN_ENDPOINT=http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\n+   REFRESH_TOKEN=$(/tmp/oauth.sh -q bob)\n+\n+This will prompt you for a password. Type 'bob-password'.\n+\n+We can inspect the refresh token:\n+\n+   /tmp/jwt.sh $REFRESH_TOKEN\n+\n+By default this is a long-lived refresh token that does not expire.\n+\n+Now we will create the configuration file for `bob`:\n+\n+```\n+cat > /tmp/bob.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.refresh.token=\"$REFRESH_TOKEN\" \\\n+  oauth.client.id=\"kafka-cli\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+Note that we use the `kafka-cli` public client for the `oauth.client.id` in the `sasl.jaas.config`.\n+Since that is a public client it does not require any secret.\n+We can use this because we authenticate with a token directly (in this case a refresh token is used to request an access token behind the scenes which is then sent to Kafka broker for authentication, and we already did the authentication for the refresh token).\n+\n+\n+Let's now try to create the `x_messages` topic:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/bob.properties \\\n+      --topic x_messages --create --replication-factor 1 --partitions 1\n+\n+The operation should succeed (you can ignore the warning about periods and underscores).\n+\n+We can list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/bob.properties --list\n+\n+If we try the same as `team-a-client` or `team-b-client` we will get different responses.\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-b-client.properties --list\n+\n+Roles `Dev Team A`, and `Dev Team B` both have `Describe` permission on topics that start with 'x_', but they cannot see the other team's topics as they do not have `Describe` permissions on them.", "originalCommit": "230db92e0f4d880e8d667eef9353cc2ceaa999f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI2MzA2MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530263061", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            We can now again try to produce to the topic as `team-a-client`.\n          \n          \n            \n            \n          \n          \n            \n            ```\n          \n          \n            \n            bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n          \n          \n            \n              --producer.config /tmp/team-a-client.properties\n          \n          \n            \n            Message 1\n          \n          \n            \n            Message 2\n          \n          \n            \n            Message 3\n          \n          \n            \n            ```\n          \n          \n            \n            \n          \n          \n            \n            This works.\n          \n          \n            \n            The `team-a-client` can now successfully produce to the `x_messages` topic:\n          \n          \n            \n            \n          \n          \n            \n            [source,shell]\n          \n          \n            \n            ----\n          \n          \n            \n            bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n          \n          \n            \n              --producer.config /tmp/team-a-client.properties\n          \n          \n            \n            Message 1\n          \n          \n            \n            Message 2\n          \n          \n            \n            Message 3\n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-25T10:24:20Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.\n+\n+Resources define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.\n+\n+For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.\n+\n+When viewing resources from the Keycloak user interface you will see a list of resource definitions.\n+These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.\n+For example, this pattern targets only topics in kafka cluster 'cluster-1' with names starting with 'a_':\n+\n+----\n+kafka-cluster:cluster-1,Topic:a_*  \n+---- \n+\n+If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  'x_':\n+----\n+Group:x_* \n+----\n+\n+\n+The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].\n+\n+*Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+The list of actions mirrors Kafka permissions and is the same for any deployment.\n+\n+Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.\n+\n+You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.\n+\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+The *Policies* tab has filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.\n+Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.\n+\n+The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.\n+\n+Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.\n+For example:\n+\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n+\n+There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n+\n+    bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+      --entity-type brokers --describe --entity-default\n+\n+But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.\n+\n+\n+### Client with Different Permissions\n+\n+Let's prepare a configuration for `team-b-client`:\n+\n+```\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+If we look at `team-b-client` client configuration in Keycloak, under `Service Account Roles` we can see that it has `Dev Team B` realm role assigned.\n+Looking in Keycloak Console at the `kafka` client's `Authorization` tab where `Permissions` are listed, we can see the permissions that start with 'Dev Team B ...'.\n+These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with 'b_' on Kafka cluster `my-cluster` (which is the designated cluster name of the demo cluster we brought up), and read access on topics that start with 'x_'.\n+\n+Let's try produce some messages to topic `a_messages` as `team-b-client`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get `Not authorized to access topics: [a_messages]` error as we expected. Let's try to produce to topic `b_messages`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+Message 2\n+Message 3\n+```\n+\n+This should work fine.\n+\n+What about producing to topic `x_messages`. `team-b-client` is only supposed to be able to read from such a topic.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get a `Not authorized to access topics: [x_messages]` error as we expected.\n+Client `team-a-client`, on the other hand, should be able to write to such a topic:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+```\n+\n+However, we again receive `Not authorized to access topics: [x_messages]`. What's going on?\n+The reason for failure is that while `team-a-client` can write to `x_messages` topic, it does not have a permission to create a topic if it does not yet exist.\n+\n+We now need a power user that can create a topic with all the proper settings - like the right number of partitions and replicas.\n+\n+\n+### Power User Can Do Anything\n+\n+Let's create a configuration for user `bob` who has full ability to manage everything on Kafka cluster `my-cluster`.\n+\n+We'll need some helper scripts so we can authenticate to the `keycloak` instance.\n+\n+Download the following `oauth.sh` and `jwt.sh` tools to `/tmp` dir and make them executable:\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/oauth.sh -s > /tmp/oauth.sh\n+   chmod +x /tmp/oauth.sh\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/jwt.sh -s > /tmp/jwt.sh\n+   chmod +x /tmp/jwt.sh\n+\n+Now, `bob` will authenticate to Keycloak server with his username and password and get a refresh token.\n+\n+   export TOKEN_ENDPOINT=http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\n+   REFRESH_TOKEN=$(/tmp/oauth.sh -q bob)\n+\n+This will prompt you for a password. Type 'bob-password'.\n+\n+We can inspect the refresh token:\n+\n+   /tmp/jwt.sh $REFRESH_TOKEN\n+\n+By default this is a long-lived refresh token that does not expire.\n+\n+Now we will create the configuration file for `bob`:\n+\n+```\n+cat > /tmp/bob.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.refresh.token=\"$REFRESH_TOKEN\" \\\n+  oauth.client.id=\"kafka-cli\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+Note that we use the `kafka-cli` public client for the `oauth.client.id` in the `sasl.jaas.config`.\n+Since that is a public client it does not require any secret.\n+We can use this because we authenticate with a token directly (in this case a refresh token is used to request an access token behind the scenes which is then sent to Kafka broker for authentication, and we already did the authentication for the refresh token).\n+\n+\n+Let's now try to create the `x_messages` topic:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/bob.properties \\\n+      --topic x_messages --create --replication-factor 1 --partitions 1\n+\n+The operation should succeed (you can ignore the warning about periods and underscores).\n+\n+We can list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/bob.properties --list\n+\n+If we try the same as `team-a-client` or `team-b-client` we will get different responses.\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-b-client.properties --list\n+\n+Roles `Dev Team A`, and `Dev Team B` both have `Describe` permission on topics that start with 'x_', but they cannot see the other team's topics as they do not have `Describe` permissions on them.\n+\n+We can now again try to produce to the topic as `team-a-client`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+Message 2\n+Message 3\n+```\n+\n+This works.", "originalCommit": "230db92e0f4d880e8d667eef9353cc2ceaa999f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI2NDE3Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530264172", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If we try the same as `team-b-client` it should fail.\n          \n          \n            \n            \n          \n          \n            \n            ```\n          \n          \n            \n            bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n          \n          \n            \n              --producer.config /tmp/team-b-client.properties\n          \n          \n            \n            Message 4\n          \n          \n            \n            Message 5\n          \n          \n            \n            ```\n          \n          \n            \n            \n          \n          \n            \n            We get an error - `Not authorized to access topics: [x_messages]`.\n          \n          \n            \n            As expected, `team-b-client` still cannot produce to the `x_messages` topic, and the following operation returns an error:\n          \n          \n            \n            \n          \n          \n            \n            [source,shell]\n          \n          \n            \n            ----\n          \n          \n            \n            bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n          \n          \n            \n              --producer.config /tmp/team-b-client.properties\n          \n          \n            \n            Message 4\n          \n          \n            \n            Message 5\n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-25T10:26:03Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.\n+\n+Resources define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.\n+\n+For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.\n+\n+When viewing resources from the Keycloak user interface you will see a list of resource definitions.\n+These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.\n+For example, this pattern targets only topics in kafka cluster 'cluster-1' with names starting with 'a_':\n+\n+----\n+kafka-cluster:cluster-1,Topic:a_*  \n+---- \n+\n+If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  'x_':\n+----\n+Group:x_* \n+----\n+\n+\n+The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].\n+\n+*Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+The list of actions mirrors Kafka permissions and is the same for any deployment.\n+\n+Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.\n+\n+You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.\n+\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+The *Policies* tab has filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.\n+Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.\n+\n+The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.\n+\n+Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.\n+For example:\n+\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n+\n+There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n+\n+    bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+      --entity-type brokers --describe --entity-default\n+\n+But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.\n+\n+\n+### Client with Different Permissions\n+\n+Let's prepare a configuration for `team-b-client`:\n+\n+```\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+If we look at `team-b-client` client configuration in Keycloak, under `Service Account Roles` we can see that it has `Dev Team B` realm role assigned.\n+Looking in Keycloak Console at the `kafka` client's `Authorization` tab where `Permissions` are listed, we can see the permissions that start with 'Dev Team B ...'.\n+These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with 'b_' on Kafka cluster `my-cluster` (which is the designated cluster name of the demo cluster we brought up), and read access on topics that start with 'x_'.\n+\n+Let's try produce some messages to topic `a_messages` as `team-b-client`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get `Not authorized to access topics: [a_messages]` error as we expected. Let's try to produce to topic `b_messages`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+Message 2\n+Message 3\n+```\n+\n+This should work fine.\n+\n+What about producing to topic `x_messages`. `team-b-client` is only supposed to be able to read from such a topic.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get a `Not authorized to access topics: [x_messages]` error as we expected.\n+Client `team-a-client`, on the other hand, should be able to write to such a topic:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+```\n+\n+However, we again receive `Not authorized to access topics: [x_messages]`. What's going on?\n+The reason for failure is that while `team-a-client` can write to `x_messages` topic, it does not have a permission to create a topic if it does not yet exist.\n+\n+We now need a power user that can create a topic with all the proper settings - like the right number of partitions and replicas.\n+\n+\n+### Power User Can Do Anything\n+\n+Let's create a configuration for user `bob` who has full ability to manage everything on Kafka cluster `my-cluster`.\n+\n+We'll need some helper scripts so we can authenticate to the `keycloak` instance.\n+\n+Download the following `oauth.sh` and `jwt.sh` tools to `/tmp` dir and make them executable:\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/oauth.sh -s > /tmp/oauth.sh\n+   chmod +x /tmp/oauth.sh\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/jwt.sh -s > /tmp/jwt.sh\n+   chmod +x /tmp/jwt.sh\n+\n+Now, `bob` will authenticate to Keycloak server with his username and password and get a refresh token.\n+\n+   export TOKEN_ENDPOINT=http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\n+   REFRESH_TOKEN=$(/tmp/oauth.sh -q bob)\n+\n+This will prompt you for a password. Type 'bob-password'.\n+\n+We can inspect the refresh token:\n+\n+   /tmp/jwt.sh $REFRESH_TOKEN\n+\n+By default this is a long-lived refresh token that does not expire.\n+\n+Now we will create the configuration file for `bob`:\n+\n+```\n+cat > /tmp/bob.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.refresh.token=\"$REFRESH_TOKEN\" \\\n+  oauth.client.id=\"kafka-cli\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+Note that we use the `kafka-cli` public client for the `oauth.client.id` in the `sasl.jaas.config`.\n+Since that is a public client it does not require any secret.\n+We can use this because we authenticate with a token directly (in this case a refresh token is used to request an access token behind the scenes which is then sent to Kafka broker for authentication, and we already did the authentication for the refresh token).\n+\n+\n+Let's now try to create the `x_messages` topic:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/bob.properties \\\n+      --topic x_messages --create --replication-factor 1 --partitions 1\n+\n+The operation should succeed (you can ignore the warning about periods and underscores).\n+\n+We can list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/bob.properties --list\n+\n+If we try the same as `team-a-client` or `team-b-client` we will get different responses.\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-b-client.properties --list\n+\n+Roles `Dev Team A`, and `Dev Team B` both have `Describe` permission on topics that start with 'x_', but they cannot see the other team's topics as they do not have `Describe` permissions on them.\n+\n+We can now again try to produce to the topic as `team-a-client`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+Message 2\n+Message 3\n+```\n+\n+This works.\n+\n+If we try the same as `team-b-client` it should fail.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 4\n+Message 5\n+```\n+\n+We get an error - `Not authorized to access topics: [x_messages]`.", "originalCommit": "230db92e0f4d880e8d667eef9353cc2ceaa999f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI2NTI4Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530265286", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            But `team-b-client` should be able to consume messages from the `x_messages` topic:\n          \n          \n            \n            \n          \n          \n            \n                bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n          \n          \n            \n                  --from-beginning --consumer.config /tmp/team-b-client.properties --group x_consumer_group_b\n          \n          \n            \n            However, due to its Keycloak settings `team-b-client` can consume messages from the `x_messages` topic:\n          \n          \n            \n            \n          \n          \n            \n            [source,shell]\n          \n          \n            \n            ----\n          \n          \n            \n            bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n          \n          \n            \n              --from-beginning --consumer.config /tmp/team-b-client.properties --group x_consumer_group_b\n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-25T10:27:43Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.\n+\n+Resources define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.\n+\n+For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.\n+\n+When viewing resources from the Keycloak user interface you will see a list of resource definitions.\n+These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.\n+For example, this pattern targets only topics in kafka cluster 'cluster-1' with names starting with 'a_':\n+\n+----\n+kafka-cluster:cluster-1,Topic:a_*  \n+---- \n+\n+If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  'x_':\n+----\n+Group:x_* \n+----\n+\n+\n+The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].\n+\n+*Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+The list of actions mirrors Kafka permissions and is the same for any deployment.\n+\n+Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.\n+\n+You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.\n+\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+The *Policies* tab has filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.\n+Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.\n+\n+The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.\n+\n+Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.\n+For example:\n+\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n+\n+There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n+\n+    bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+      --entity-type brokers --describe --entity-default\n+\n+But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.\n+\n+\n+### Client with Different Permissions\n+\n+Let's prepare a configuration for `team-b-client`:\n+\n+```\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+If we look at `team-b-client` client configuration in Keycloak, under `Service Account Roles` we can see that it has `Dev Team B` realm role assigned.\n+Looking in Keycloak Console at the `kafka` client's `Authorization` tab where `Permissions` are listed, we can see the permissions that start with 'Dev Team B ...'.\n+These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with 'b_' on Kafka cluster `my-cluster` (which is the designated cluster name of the demo cluster we brought up), and read access on topics that start with 'x_'.\n+\n+Let's try produce some messages to topic `a_messages` as `team-b-client`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get `Not authorized to access topics: [a_messages]` error as we expected. Let's try to produce to topic `b_messages`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+Message 2\n+Message 3\n+```\n+\n+This should work fine.\n+\n+What about producing to topic `x_messages`. `team-b-client` is only supposed to be able to read from such a topic.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get a `Not authorized to access topics: [x_messages]` error as we expected.\n+Client `team-a-client`, on the other hand, should be able to write to such a topic:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+```\n+\n+However, we again receive `Not authorized to access topics: [x_messages]`. What's going on?\n+The reason for failure is that while `team-a-client` can write to `x_messages` topic, it does not have a permission to create a topic if it does not yet exist.\n+\n+We now need a power user that can create a topic with all the proper settings - like the right number of partitions and replicas.\n+\n+\n+### Power User Can Do Anything\n+\n+Let's create a configuration for user `bob` who has full ability to manage everything on Kafka cluster `my-cluster`.\n+\n+We'll need some helper scripts so we can authenticate to the `keycloak` instance.\n+\n+Download the following `oauth.sh` and `jwt.sh` tools to `/tmp` dir and make them executable:\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/oauth.sh -s > /tmp/oauth.sh\n+   chmod +x /tmp/oauth.sh\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/jwt.sh -s > /tmp/jwt.sh\n+   chmod +x /tmp/jwt.sh\n+\n+Now, `bob` will authenticate to Keycloak server with his username and password and get a refresh token.\n+\n+   export TOKEN_ENDPOINT=http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\n+   REFRESH_TOKEN=$(/tmp/oauth.sh -q bob)\n+\n+This will prompt you for a password. Type 'bob-password'.\n+\n+We can inspect the refresh token:\n+\n+   /tmp/jwt.sh $REFRESH_TOKEN\n+\n+By default this is a long-lived refresh token that does not expire.\n+\n+Now we will create the configuration file for `bob`:\n+\n+```\n+cat > /tmp/bob.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.refresh.token=\"$REFRESH_TOKEN\" \\\n+  oauth.client.id=\"kafka-cli\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+Note that we use the `kafka-cli` public client for the `oauth.client.id` in the `sasl.jaas.config`.\n+Since that is a public client it does not require any secret.\n+We can use this because we authenticate with a token directly (in this case a refresh token is used to request an access token behind the scenes which is then sent to Kafka broker for authentication, and we already did the authentication for the refresh token).\n+\n+\n+Let's now try to create the `x_messages` topic:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/bob.properties \\\n+      --topic x_messages --create --replication-factor 1 --partitions 1\n+\n+The operation should succeed (you can ignore the warning about periods and underscores).\n+\n+We can list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/bob.properties --list\n+\n+If we try the same as `team-a-client` or `team-b-client` we will get different responses.\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-b-client.properties --list\n+\n+Roles `Dev Team A`, and `Dev Team B` both have `Describe` permission on topics that start with 'x_', but they cannot see the other team's topics as they do not have `Describe` permissions on them.\n+\n+We can now again try to produce to the topic as `team-a-client`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+Message 2\n+Message 3\n+```\n+\n+This works.\n+\n+If we try the same as `team-b-client` it should fail.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 4\n+Message 5\n+```\n+\n+We get an error - `Not authorized to access topics: [x_messages]`.\n+\n+But `team-b-client` should be able to consume messages from the `x_messages` topic:\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+      --from-beginning --consumer.config /tmp/team-b-client.properties --group x_consumer_group_b\n+", "originalCommit": "230db92e0f4d880e8d667eef9353cc2ceaa999f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI2NzIwNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530267207", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Whereas `team-a-client` does not have permission to read, even though they can write:\n          \n          \n            \n            \n          \n          \n            \n                bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n          \n          \n            \n                  --from-beginning --consumer.config /tmp/team-a-client.properties --group x_consumer_group_a\n          \n          \n            \n            \n          \n          \n            \n            We get a `Not authorized to access group: x_consumer_group_a` error.\n          \n          \n            \n            Conversely, even though `team-a-client` can write to topic `x_messages`, the following read request returns a `Not authorized to access group: x_consumer_group_a` error:\n          \n          \n            \n            \n          \n          \n            \n            [source,shell]\n          \n          \n            \n            ----\n          \n          \n            \n            bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n          \n          \n            \n              --from-beginning --consumer.config /tmp/team-a-client.properties --group x_consumer_group_a\n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-25T10:30:42Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.\n+\n+Resources define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.\n+\n+For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.\n+\n+When viewing resources from the Keycloak user interface you will see a list of resource definitions.\n+These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.\n+For example, this pattern targets only topics in kafka cluster 'cluster-1' with names starting with 'a_':\n+\n+----\n+kafka-cluster:cluster-1,Topic:a_*  \n+---- \n+\n+If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  'x_':\n+----\n+Group:x_* \n+----\n+\n+\n+The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].\n+\n+*Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+The list of actions mirrors Kafka permissions and is the same for any deployment.\n+\n+Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.\n+\n+You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.\n+\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+The *Policies* tab has filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.\n+Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.\n+\n+The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.\n+\n+Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.\n+For example:\n+\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n+\n+There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n+\n+    bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+      --entity-type brokers --describe --entity-default\n+\n+But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.\n+\n+\n+### Client with Different Permissions\n+\n+Let's prepare a configuration for `team-b-client`:\n+\n+```\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+If we look at `team-b-client` client configuration in Keycloak, under `Service Account Roles` we can see that it has `Dev Team B` realm role assigned.\n+Looking in Keycloak Console at the `kafka` client's `Authorization` tab where `Permissions` are listed, we can see the permissions that start with 'Dev Team B ...'.\n+These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with 'b_' on Kafka cluster `my-cluster` (which is the designated cluster name of the demo cluster we brought up), and read access on topics that start with 'x_'.\n+\n+Let's try produce some messages to topic `a_messages` as `team-b-client`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get `Not authorized to access topics: [a_messages]` error as we expected. Let's try to produce to topic `b_messages`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+Message 2\n+Message 3\n+```\n+\n+This should work fine.\n+\n+What about producing to topic `x_messages`. `team-b-client` is only supposed to be able to read from such a topic.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get a `Not authorized to access topics: [x_messages]` error as we expected.\n+Client `team-a-client`, on the other hand, should be able to write to such a topic:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+```\n+\n+However, we again receive `Not authorized to access topics: [x_messages]`. What's going on?\n+The reason for failure is that while `team-a-client` can write to `x_messages` topic, it does not have a permission to create a topic if it does not yet exist.\n+\n+We now need a power user that can create a topic with all the proper settings - like the right number of partitions and replicas.\n+\n+\n+### Power User Can Do Anything\n+\n+Let's create a configuration for user `bob` who has full ability to manage everything on Kafka cluster `my-cluster`.\n+\n+We'll need some helper scripts so we can authenticate to the `keycloak` instance.\n+\n+Download the following `oauth.sh` and `jwt.sh` tools to `/tmp` dir and make them executable:\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/oauth.sh -s > /tmp/oauth.sh\n+   chmod +x /tmp/oauth.sh\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/jwt.sh -s > /tmp/jwt.sh\n+   chmod +x /tmp/jwt.sh\n+\n+Now, `bob` will authenticate to Keycloak server with his username and password and get a refresh token.\n+\n+   export TOKEN_ENDPOINT=http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\n+   REFRESH_TOKEN=$(/tmp/oauth.sh -q bob)\n+\n+This will prompt you for a password. Type 'bob-password'.\n+\n+We can inspect the refresh token:\n+\n+   /tmp/jwt.sh $REFRESH_TOKEN\n+\n+By default this is a long-lived refresh token that does not expire.\n+\n+Now we will create the configuration file for `bob`:\n+\n+```\n+cat > /tmp/bob.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.refresh.token=\"$REFRESH_TOKEN\" \\\n+  oauth.client.id=\"kafka-cli\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+Note that we use the `kafka-cli` public client for the `oauth.client.id` in the `sasl.jaas.config`.\n+Since that is a public client it does not require any secret.\n+We can use this because we authenticate with a token directly (in this case a refresh token is used to request an access token behind the scenes which is then sent to Kafka broker for authentication, and we already did the authentication for the refresh token).\n+\n+\n+Let's now try to create the `x_messages` topic:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/bob.properties \\\n+      --topic x_messages --create --replication-factor 1 --partitions 1\n+\n+The operation should succeed (you can ignore the warning about periods and underscores).\n+\n+We can list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/bob.properties --list\n+\n+If we try the same as `team-a-client` or `team-b-client` we will get different responses.\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-b-client.properties --list\n+\n+Roles `Dev Team A`, and `Dev Team B` both have `Describe` permission on topics that start with 'x_', but they cannot see the other team's topics as they do not have `Describe` permissions on them.\n+\n+We can now again try to produce to the topic as `team-a-client`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+Message 2\n+Message 3\n+```\n+\n+This works.\n+\n+If we try the same as `team-b-client` it should fail.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 4\n+Message 5\n+```\n+\n+We get an error - `Not authorized to access topics: [x_messages]`.\n+\n+But `team-b-client` should be able to consume messages from the `x_messages` topic:\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+      --from-beginning --consumer.config /tmp/team-b-client.properties --group x_consumer_group_b\n+\n+Whereas `team-a-client` does not have permission to read, even though they can write:\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group x_consumer_group_a\n+\n+We get a `Not authorized to access group: x_consumer_group_a` error.", "originalCommit": "230db92e0f4d880e8d667eef9353cc2ceaa999f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI3NzAzMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530277030", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            What if we try to use a consumer group name that starts with 'a_'?\n          \n          \n            \n            \n          \n          \n            \n                bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n          \n          \n            \n                  --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_a\n          \n          \n            \n            \n          \n          \n            \n            We now get a different error: `Not authorized to access topics: [x_messages]`\n          \n          \n            \n            A consumer group that begins with `a_` is used in the next read request:\n          \n          \n            \n            \n          \n          \n            \n            [source,shell]\n          \n          \n            \n            ----\n          \n          \n            \n            bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n          \n          \n            \n              --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_a\n          \n          \n            \n            ----\n          \n          \n            \n            \n          \n          \n            \n            An error is still returned, but this time it is `Not authorized to access topics: [x_messages]`.", "author": "PaulRMellor", "createdAt": "2020-11-25T10:46:24Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.\n+\n+Resources define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.\n+\n+For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.\n+\n+When viewing resources from the Keycloak user interface you will see a list of resource definitions.\n+These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.\n+For example, this pattern targets only topics in kafka cluster 'cluster-1' with names starting with 'a_':\n+\n+----\n+kafka-cluster:cluster-1,Topic:a_*  \n+---- \n+\n+If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  'x_':\n+----\n+Group:x_* \n+----\n+\n+\n+The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].\n+\n+*Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+The list of actions mirrors Kafka permissions and is the same for any deployment.\n+\n+Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.\n+\n+You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.\n+\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+The *Policies* tab has filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.\n+Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.\n+\n+The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.\n+\n+Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.\n+For example:\n+\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n+\n+There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n+\n+    bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+      --entity-type brokers --describe --entity-default\n+\n+But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.\n+\n+\n+### Client with Different Permissions\n+\n+Let's prepare a configuration for `team-b-client`:\n+\n+```\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+If we look at `team-b-client` client configuration in Keycloak, under `Service Account Roles` we can see that it has `Dev Team B` realm role assigned.\n+Looking in Keycloak Console at the `kafka` client's `Authorization` tab where `Permissions` are listed, we can see the permissions that start with 'Dev Team B ...'.\n+These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with 'b_' on Kafka cluster `my-cluster` (which is the designated cluster name of the demo cluster we brought up), and read access on topics that start with 'x_'.\n+\n+Let's try produce some messages to topic `a_messages` as `team-b-client`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get `Not authorized to access topics: [a_messages]` error as we expected. Let's try to produce to topic `b_messages`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+Message 2\n+Message 3\n+```\n+\n+This should work fine.\n+\n+What about producing to topic `x_messages`. `team-b-client` is only supposed to be able to read from such a topic.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get a `Not authorized to access topics: [x_messages]` error as we expected.\n+Client `team-a-client`, on the other hand, should be able to write to such a topic:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+```\n+\n+However, we again receive `Not authorized to access topics: [x_messages]`. What's going on?\n+The reason for failure is that while `team-a-client` can write to `x_messages` topic, it does not have a permission to create a topic if it does not yet exist.\n+\n+We now need a power user that can create a topic with all the proper settings - like the right number of partitions and replicas.\n+\n+\n+### Power User Can Do Anything\n+\n+Let's create a configuration for user `bob` who has full ability to manage everything on Kafka cluster `my-cluster`.\n+\n+We'll need some helper scripts so we can authenticate to the `keycloak` instance.\n+\n+Download the following `oauth.sh` and `jwt.sh` tools to `/tmp` dir and make them executable:\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/oauth.sh -s > /tmp/oauth.sh\n+   chmod +x /tmp/oauth.sh\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/jwt.sh -s > /tmp/jwt.sh\n+   chmod +x /tmp/jwt.sh\n+\n+Now, `bob` will authenticate to Keycloak server with his username and password and get a refresh token.\n+\n+   export TOKEN_ENDPOINT=http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\n+   REFRESH_TOKEN=$(/tmp/oauth.sh -q bob)\n+\n+This will prompt you for a password. Type 'bob-password'.\n+\n+We can inspect the refresh token:\n+\n+   /tmp/jwt.sh $REFRESH_TOKEN\n+\n+By default this is a long-lived refresh token that does not expire.\n+\n+Now we will create the configuration file for `bob`:\n+\n+```\n+cat > /tmp/bob.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.refresh.token=\"$REFRESH_TOKEN\" \\\n+  oauth.client.id=\"kafka-cli\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+Note that we use the `kafka-cli` public client for the `oauth.client.id` in the `sasl.jaas.config`.\n+Since that is a public client it does not require any secret.\n+We can use this because we authenticate with a token directly (in this case a refresh token is used to request an access token behind the scenes which is then sent to Kafka broker for authentication, and we already did the authentication for the refresh token).\n+\n+\n+Let's now try to create the `x_messages` topic:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/bob.properties \\\n+      --topic x_messages --create --replication-factor 1 --partitions 1\n+\n+The operation should succeed (you can ignore the warning about periods and underscores).\n+\n+We can list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/bob.properties --list\n+\n+If we try the same as `team-a-client` or `team-b-client` we will get different responses.\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-b-client.properties --list\n+\n+Roles `Dev Team A`, and `Dev Team B` both have `Describe` permission on topics that start with 'x_', but they cannot see the other team's topics as they do not have `Describe` permissions on them.\n+\n+We can now again try to produce to the topic as `team-a-client`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+Message 2\n+Message 3\n+```\n+\n+This works.\n+\n+If we try the same as `team-b-client` it should fail.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 4\n+Message 5\n+```\n+\n+We get an error - `Not authorized to access topics: [x_messages]`.\n+\n+But `team-b-client` should be able to consume messages from the `x_messages` topic:\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+      --from-beginning --consumer.config /tmp/team-b-client.properties --group x_consumer_group_b\n+\n+Whereas `team-a-client` does not have permission to read, even though they can write:\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group x_consumer_group_a\n+\n+We get a `Not authorized to access group: x_consumer_group_a` error.\n+\n+What if we try to use a consumer group name that starts with 'a_'?\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_a\n+\n+We now get a different error: `Not authorized to access topics: [x_messages]`", "originalCommit": "230db92e0f4d880e8d667eef9353cc2ceaa999f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI3NzQzOQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530277439", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            It just won't work - `Dev Team A` has no `Read` access on topics that start with 'x_'.\n          \n          \n            \n            `Dev Team A` has no `Read` access on topics that start with 'x_'.", "author": "PaulRMellor", "createdAt": "2020-11-25T10:47:03Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.\n+\n+Resources define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.\n+\n+For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.\n+\n+When viewing resources from the Keycloak user interface you will see a list of resource definitions.\n+These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.\n+For example, this pattern targets only topics in kafka cluster 'cluster-1' with names starting with 'a_':\n+\n+----\n+kafka-cluster:cluster-1,Topic:a_*  \n+---- \n+\n+If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  'x_':\n+----\n+Group:x_* \n+----\n+\n+\n+The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].\n+\n+*Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+The list of actions mirrors Kafka permissions and is the same for any deployment.\n+\n+Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.\n+\n+You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.\n+\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+The *Policies* tab has filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.\n+Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.\n+\n+The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.\n+\n+Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.\n+For example:\n+\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n+\n+There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n+\n+    bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+      --entity-type brokers --describe --entity-default\n+\n+But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.\n+\n+\n+### Client with Different Permissions\n+\n+Let's prepare a configuration for `team-b-client`:\n+\n+```\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+If we look at `team-b-client` client configuration in Keycloak, under `Service Account Roles` we can see that it has `Dev Team B` realm role assigned.\n+Looking in Keycloak Console at the `kafka` client's `Authorization` tab where `Permissions` are listed, we can see the permissions that start with 'Dev Team B ...'.\n+These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with 'b_' on Kafka cluster `my-cluster` (which is the designated cluster name of the demo cluster we brought up), and read access on topics that start with 'x_'.\n+\n+Let's try produce some messages to topic `a_messages` as `team-b-client`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get `Not authorized to access topics: [a_messages]` error as we expected. Let's try to produce to topic `b_messages`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+Message 2\n+Message 3\n+```\n+\n+This should work fine.\n+\n+What about producing to topic `x_messages`. `team-b-client` is only supposed to be able to read from such a topic.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get a `Not authorized to access topics: [x_messages]` error as we expected.\n+Client `team-a-client`, on the other hand, should be able to write to such a topic:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+```\n+\n+However, we again receive `Not authorized to access topics: [x_messages]`. What's going on?\n+The reason for failure is that while `team-a-client` can write to `x_messages` topic, it does not have a permission to create a topic if it does not yet exist.\n+\n+We now need a power user that can create a topic with all the proper settings - like the right number of partitions and replicas.\n+\n+\n+### Power User Can Do Anything\n+\n+Let's create a configuration for user `bob` who has full ability to manage everything on Kafka cluster `my-cluster`.\n+\n+We'll need some helper scripts so we can authenticate to the `keycloak` instance.\n+\n+Download the following `oauth.sh` and `jwt.sh` tools to `/tmp` dir and make them executable:\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/oauth.sh -s > /tmp/oauth.sh\n+   chmod +x /tmp/oauth.sh\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/jwt.sh -s > /tmp/jwt.sh\n+   chmod +x /tmp/jwt.sh\n+\n+Now, `bob` will authenticate to Keycloak server with his username and password and get a refresh token.\n+\n+   export TOKEN_ENDPOINT=http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\n+   REFRESH_TOKEN=$(/tmp/oauth.sh -q bob)\n+\n+This will prompt you for a password. Type 'bob-password'.\n+\n+We can inspect the refresh token:\n+\n+   /tmp/jwt.sh $REFRESH_TOKEN\n+\n+By default this is a long-lived refresh token that does not expire.\n+\n+Now we will create the configuration file for `bob`:\n+\n+```\n+cat > /tmp/bob.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.refresh.token=\"$REFRESH_TOKEN\" \\\n+  oauth.client.id=\"kafka-cli\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+Note that we use the `kafka-cli` public client for the `oauth.client.id` in the `sasl.jaas.config`.\n+Since that is a public client it does not require any secret.\n+We can use this because we authenticate with a token directly (in this case a refresh token is used to request an access token behind the scenes which is then sent to Kafka broker for authentication, and we already did the authentication for the refresh token).\n+\n+\n+Let's now try to create the `x_messages` topic:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/bob.properties \\\n+      --topic x_messages --create --replication-factor 1 --partitions 1\n+\n+The operation should succeed (you can ignore the warning about periods and underscores).\n+\n+We can list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/bob.properties --list\n+\n+If we try the same as `team-a-client` or `team-b-client` we will get different responses.\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-b-client.properties --list\n+\n+Roles `Dev Team A`, and `Dev Team B` both have `Describe` permission on topics that start with 'x_', but they cannot see the other team's topics as they do not have `Describe` permissions on them.\n+\n+We can now again try to produce to the topic as `team-a-client`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+Message 2\n+Message 3\n+```\n+\n+This works.\n+\n+If we try the same as `team-b-client` it should fail.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 4\n+Message 5\n+```\n+\n+We get an error - `Not authorized to access topics: [x_messages]`.\n+\n+But `team-b-client` should be able to consume messages from the `x_messages` topic:\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+      --from-beginning --consumer.config /tmp/team-b-client.properties --group x_consumer_group_b\n+\n+Whereas `team-a-client` does not have permission to read, even though they can write:\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group x_consumer_group_a\n+\n+We get a `Not authorized to access group: x_consumer_group_a` error.\n+\n+What if we try to use a consumer group name that starts with 'a_'?\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_a\n+\n+We now get a different error: `Not authorized to access topics: [x_messages]`\n+\n+It just won't work - `Dev Team A` has no `Read` access on topics that start with 'x_'.", "originalCommit": "230db92e0f4d880e8d667eef9353cc2ceaa999f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI3ODEwOA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530278108", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            User `bob` should have no problem reading from or writing to any topic:\n          \n          \n            \n            \n          \n          \n            \n                bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n          \n          \n            \n                  --from-beginning --consumer.config /tmp/bob.properties\n          \n          \n            \n            User `bob` should can read from or write to any topic:\n          \n          \n            \n            \n          \n          \n            \n            [source,shell]\n          \n          \n            \n            ----\n          \n          \n            \n            bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n          \n          \n            \n              --from-beginning --consumer.config /tmp/bob.properties\n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-25T10:48:04Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,481 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.\n+\n+Resources define _what_ we are protecting from unauthorized access.\n+Each resource can contain a list of authorization scopes - actions that are available on the resource, so that permission on a resource can be granted for one or more actions only.\n+Policies define the groups of users we want to target with permissions. Users can be targeted based on group membership, assigned roles, or individually.\n+Finally, permissions tie together the resources, authorization scopes and policies that specify _users U can perform actions A on resource R_.\n+\n+For more information about Keycloak Authorization Services, see {keycloak-authorization-services}, but note that the Authorization Services documentation is focused primarily on using the Authorization Services to protect web resources rather than access to Kafka.\n+\n+When viewing resources from the Keycloak user interface you will see a list of resource definitions.\n+These are resource specifiers, patterns in a specific format that are used to target policies to specific resources.\n+For example, this pattern targets only topics in kafka cluster 'cluster-1' with names starting with 'a_':\n+\n+----\n+kafka-cluster:cluster-1,Topic:a_*  \n+---- \n+\n+If a cluster is not specified by name ( `kafka-cluster:cluster-1`), the specifier targets any cluster. For example, this pattern targets any cluster with a name starting  'x_':\n+----\n+Group:x_* \n+----\n+\n+\n+The possible resource types, such as `Topic`, `Group` and `Cluster`, mirror the xref:kafka_authorization_model[Kafka authorization model].\n+\n+*Authorization Scopes* lists of all the possible actions (Kafka permissions) that can be granted on specific resources.\n+It requires some understanding of link:https://kafka.apache.org/documentation/#resources_in_kafka[Kafka's permissions model] to know which of these make sense with which resource type.\n+The list of actions mirrors Kafka permissions and is the same for any deployment.\n+\n+Rather than importing authorization scopes manually into every new client, you can use a link:https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/oauth-keycloak-authorizer/etc/authorization-scopes.json[authorization-scopes.json] file.\n+\n+You must make sure that the client is enabled in Keycloak for Authorization Services. After which, you can import a JSON file from the *Authorization* tab. You can see the loaded scopes from the *Authorization Scopes* page.\n+\n+For this example the authorization scopes have already been imported as part of the realm import.\n+\n+The *Policies* tab has filters that match sets of users.\n+Users can be explicitly listed, or they can be matched based on the roles, or groups they are assigned.\n+Policies can even be defined programmatically using JavaScript so the logic considers the context of the client session, such as the IP of a Kafka client.\n+\n+The *Permissions* tab defines role bindings that associate resources, authorization scopes and policies for applying a set of permissions on specific resources for certain users.\n+\n+Use a clear, descriptive name for each permission definition so that it is obvious what kind of access is granted to which users.\n+For example:\n+\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+If we take a closer look at the `Dev Team A can write ...` permission definition, we see that it combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy.\n+If we click on the `Dev Team A` policy, we see that it matches all users that have a realm role called `Dev Team A`.\n+\n+Similarly, the `Dev Team B ...` permissions perform matching using the `Dev Team B` policy which also uses realm role to match allowed users - in this case those with realm role `Dev Team B`.\n+The `Dev Team B ...` permissions grant users `Describe` and `Read` on `Topic:x_*`, and `Group:x_*` resources, effectively giving matching users and clients the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with 'x_'.\n+\n+## Targeting Permissions - Clients and Roles vs. Users and Groups\n+\n+In Keycloak, confidential clients with 'service accounts' enabled can authenticate to the server in their own name using a clientId and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use Group policies, and should instead use Role policies.\n+Or, thinking about it another way, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the Group policies, rather than the Role policies.\n+That's what we see used in `permissions` that start with 'ClusterManager'.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log-in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+Under `Clients` / `kafka` / `Authorization` / `Settings` make sure the `Decision Strategy` is set to `Affirmative`, and NOT to `Unanimous`.\n+Click on other tabs and make sure there are some resources, authorization claims, policies and permissions defined.\n+\n+With configuration now in place, let's create some topics, use a producer, a consumer, and try to perform some management operations using different user and service accounts.\n+\n+First, we run a new interactive pod container using a Strimzi Kafka image which we use to connect to the already running Kafka broker.\n+\n+    kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+\n+The first time you run this, the `kubectl` might timeout waiting on the image to be downloaded, but your subsequent attempts may result in AlreadyExists error.\n+\n+You can attach to the existing pod by running:\n+\n+    kubectl attach -ti kafka-cli\n+\n+Let's try to produce some messages as client `team-a-client`.\n+\n+First, we prepare a Kafka client configuration file with authentication parameters.\n+\n+```\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+In the Keycloak Console you can find which roles are assigned to the `team-a-client` service account, by selecting `team-a-client` in the `Clients` section.\n+and then opening the `Service Account Roles` tab for the client.\n+You should see the `Dev Team A` realm role assigned.\n+\n+We can now use this configuration with Kafka's CLI tools.\n+\n+\n+### Producing the Messages\n+\n+Let's try to produce some messages to topic 'my-topic':\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+```\n+\n+When we press `Enter` to push the first message we receive `Not authorized to access topics: [my-topic]` error.\n+\n+`team-a-client` has a `Dev Team A` role which gives it permissions to do anything on topics that start with 'a_', and only write to topics that start with 'x_'.\n+The topic named `my-topic` matches neither of those.\n+\n+Use CTRL-C to exit the CLI application, and let's try to write to topic `a_messages`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+```\n+\n+Although we can see some unrelated warnings, looking at the Kafka container log there is DEBUG level output saying 'Authorization GRANTED'.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+    kubectl logs my-cluster-kafka-0 -f\n+\n+### Consuming the Messages\n+\n+Let's now try to consume the messages we have produced.\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties\n+\n+This gives us an error like: `Not authorized to access group: console-consumer-55841`.\n+\n+The reason is that we have to override the default consumer group name - `Dev Team A` only has access to consumer groups that have names starting with 'a_'.\n+Let's set custom consumer group name that starts with 'a_'\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+\n+We should now receive all the messages for the 'a_messages' topic, after which the client blocks waiting for more messages.\n+\n+Use CTRL-C to exit.\n+\n+\n+### Using Kafka's CLI Administration Tools\n+\n+Let's now list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+We get one topic listed: `a_messages`.\n+\n+Let's try and list the consumer groups:\n+\n+    bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+\n+Similarly to listing topics, we get one consumer group listed: `a_consumer_group_1`.\n+\n+There are more CLI administrative tools. For example we can try to get the default cluster configuration:\n+\n+    bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+      --entity-type brokers --describe --entity-default\n+\n+But that will fail with `Cluster authorization failed.` error, because this operation requires cluster level permissions which `team-a-client` does not have.\n+\n+\n+### Client with Different Permissions\n+\n+Let's prepare a configuration for `team-b-client`:\n+\n+```\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+If we look at `team-b-client` client configuration in Keycloak, under `Service Account Roles` we can see that it has `Dev Team B` realm role assigned.\n+Looking in Keycloak Console at the `kafka` client's `Authorization` tab where `Permissions` are listed, we can see the permissions that start with 'Dev Team B ...'.\n+These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with 'b_' on Kafka cluster `my-cluster` (which is the designated cluster name of the demo cluster we brought up), and read access on topics that start with 'x_'.\n+\n+Let's try produce some messages to topic `a_messages` as `team-b-client`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get `Not authorized to access topics: [a_messages]` error as we expected. Let's try to produce to topic `b_messages`:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+Message 2\n+Message 3\n+```\n+\n+This should work fine.\n+\n+What about producing to topic `x_messages`. `team-b-client` is only supposed to be able to read from such a topic.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+```\n+\n+We get a `Not authorized to access topics: [x_messages]` error as we expected.\n+Client `team-a-client`, on the other hand, should be able to write to such a topic:\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+```\n+\n+However, we again receive `Not authorized to access topics: [x_messages]`. What's going on?\n+The reason for failure is that while `team-a-client` can write to `x_messages` topic, it does not have a permission to create a topic if it does not yet exist.\n+\n+We now need a power user that can create a topic with all the proper settings - like the right number of partitions and replicas.\n+\n+\n+### Power User Can Do Anything\n+\n+Let's create a configuration for user `bob` who has full ability to manage everything on Kafka cluster `my-cluster`.\n+\n+We'll need some helper scripts so we can authenticate to the `keycloak` instance.\n+\n+Download the following `oauth.sh` and `jwt.sh` tools to `/tmp` dir and make them executable:\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/oauth.sh -s > /tmp/oauth.sh\n+   chmod +x /tmp/oauth.sh\n+\n+   curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/jwt.sh -s > /tmp/jwt.sh\n+   chmod +x /tmp/jwt.sh\n+\n+Now, `bob` will authenticate to Keycloak server with his username and password and get a refresh token.\n+\n+   export TOKEN_ENDPOINT=http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\n+   REFRESH_TOKEN=$(/tmp/oauth.sh -q bob)\n+\n+This will prompt you for a password. Type 'bob-password'.\n+\n+We can inspect the refresh token:\n+\n+   /tmp/jwt.sh $REFRESH_TOKEN\n+\n+By default this is a long-lived refresh token that does not expire.\n+\n+Now we will create the configuration file for `bob`:\n+\n+```\n+cat > /tmp/bob.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.refresh.token=\"$REFRESH_TOKEN\" \\\n+  oauth.client.id=\"kafka-cli\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+```\n+\n+Note that we use the `kafka-cli` public client for the `oauth.client.id` in the `sasl.jaas.config`.\n+Since that is a public client it does not require any secret.\n+We can use this because we authenticate with a token directly (in this case a refresh token is used to request an access token behind the scenes which is then sent to Kafka broker for authentication, and we already did the authentication for the refresh token).\n+\n+\n+Let's now try to create the `x_messages` topic:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/bob.properties \\\n+      --topic x_messages --create --replication-factor 1 --partitions 1\n+\n+The operation should succeed (you can ignore the warning about periods and underscores).\n+\n+We can list the topics:\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/bob.properties --list\n+\n+If we try the same as `team-a-client` or `team-b-client` we will get different responses.\n+\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+    bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-b-client.properties --list\n+\n+Roles `Dev Team A`, and `Dev Team B` both have `Describe` permission on topics that start with 'x_', but they cannot see the other team's topics as they do not have `Describe` permissions on them.\n+\n+We can now again try to produce to the topic as `team-a-client`.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+Message 2\n+Message 3\n+```\n+\n+This works.\n+\n+If we try the same as `team-b-client` it should fail.\n+\n+```\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 4\n+Message 5\n+```\n+\n+We get an error - `Not authorized to access topics: [x_messages]`.\n+\n+But `team-b-client` should be able to consume messages from the `x_messages` topic:\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+      --from-beginning --consumer.config /tmp/team-b-client.properties --group x_consumer_group_b\n+\n+Whereas `team-a-client` does not have permission to read, even though they can write:\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group x_consumer_group_a\n+\n+We get a `Not authorized to access group: x_consumer_group_a` error.\n+\n+What if we try to use a consumer group name that starts with 'a_'?\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+      --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_a\n+\n+We now get a different error: `Not authorized to access topics: [x_messages]`\n+\n+It just won't work - `Dev Team A` has no `Read` access on topics that start with 'x_'.\n+\n+User `bob` should have no problem reading from or writing to any topic:\n+\n+    bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+      --from-beginning --consumer.config /tmp/bob.properties", "originalCommit": "230db92e0f4d880e8d667eef9353cc2ceaa999f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ0NDA0NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530444044", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            By default this is a long-lived refresh token that does not expire.\n          \n          \n            \n            By default this is an offline token which is a long-lived refresh token that does not expire.", "author": "mstruk", "createdAt": "2020-11-25T15:09:30Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,465 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+The default view usually displays the *Master* realm.\n+For this example we are interested in the `kafka-authz` realm, which you can select in the upper left corner.\n+\n+Initially the *Realm Settings* section is selected, but you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources as explained in xref:keycloak_authorization_services_model_for_managing_permissions(one of the previous chapters).\n+\n+Under *Authorization* / *Permissions* of `kafka` client you can see already granted permissions that make use of *Resources* and *Policies* defined under the other tabs:\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+`Dev Team A can write to topics that start with x_ on any cluster` combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team A`.\n+\n+`Dev Team B can read from topics that start with x_ on any cluster` combines `Topic:x_*`, and `Group:x_*` resources, scopes `Describe` and `Read`, and `Dev Team B` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team B`. Matching users and clients have the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with `x_`.\n+\n+== Targeting permissions using group or role policies\n+\n+In Keycloak, confidential clients with service accounts enabled can authenticate to the server in their own name using a client ID and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use group policies, and should instead use role policies.\n+Conversely, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the group policies, rather than the role policies.\n+That is what is used for permissions that start with `ClusterManager`.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case, the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+From menu:Clients[kafka>Authorization>Settings] make sure that *Decision Strategy* is set to *Affirmative*, and NOT to *Unanimous*.\n+Navigate in Keycloak to check that the expected resources, authorization claims, policies and permissions are defined.\n+\n+With the configuration in place, we can check access to Kafka by using a producer and consumer to create topics using different user and service accounts.\n+\n+First, a new interactive pod container is run using a Strimzi Kafka image to connect to a running Kafka broker.\n+\n+[source,shell]\n+----\n+kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+----\n+\n+NOTE: If `kubectl` times out waiting on the image download, subsequent attempts may result in an _AlreadyExists_ error. \n+\n+You can attach to the existing pod by running:\n+\n+[source,shell]\n+----\n+kubectl attach -ti kafka-cli\n+----\n+\n+To produce messages as client `team-a-client`, we prepare a Kafka client configuration file with authentication parameters.\n+\n+[source,shell]\n+----\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+----\n+\n+The roles assigned to a client, such as the `Dev Team A` realm role assigned to the `team-a-client` service account, are presented in Keycloak on the  *Service Account Roles* tab from *Clients*.\n+\n+We can use this configuration from the Kafka CLI to produce and consume messages, and perform other administration tasks.\n+\n+\n+.Producing messages with authorized access\n+\n+The `team-a-client` configuration is used to produce messages to topic `my-topic`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+----\n+\n+A `Not authorized to access topics: [my-topic]` error is returned when trying to push the first message.\n+\n+`team-a-client` has a `Dev Team A` role that gives it permission to perform any supported actions on topics that start with `a_`, but can only write to topics that start with `x_`.\n+The topic named `my-topic` matches neither of those rules.\n+\n+The `team-a-client` configuration is then used to produce messages to topic `a_messages`.\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+----\n+\n+The messages are pushed out successfully, and in the Kafka container log there is DEBUG level output saying `Authorization GRANTED`.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+[source,shell]\n+kubectl logs my-cluster-kafka-0 -f\n+\n+.Consuming messages with authorized access\n+\n+The `team-a-client` configuration is used to consume messages from topic `a_messages`:\n+\n+[source,shell,subs=+quotes]\n+----\n+bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --from-beginning --consumer.config /tmp/team-a-client.properties\n+----\n+\n+An error is returned as the `Dev Team A` role for `team-a-client` only has access to consumer groups that have names starting with `a_`.\n+The `team-a-client` configuration is then used to consume messages when specifying a custom consumer group with a name that starts with `a_`:\n+\n+[source,shell,subs=+quotes]\n+----\n+bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+----\n+\n+This time the consumer receives all the messages from the `a_messages` topic.\n+\n+\n+.Administering Kafka with authorized access\n+\n+The `team-a-client` configuration is used in administrative operations.\n+\n+Listing topics returns the `a_messages` topic.\n+\n+[source,shell]\n+----\n+bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+----    \n+\n+Listing consumer groups returns the `a_consumer_group_1` consumer group.\n+\n+[source,shell]\n+----\n+bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+----\n+\n+Fetching the default cluster configuration fails cluster authorization, because the operation requires cluster level permissions that `team-a-client` does not have.\n+\n+[source,shell]\n+----\n+bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+  --entity-type brokers --describe --entity-default\n+----\n+\n+\n+. Using clients with different permissions\n+\n+As with `team-a-client`, we prepare a Kafka client configuration file with authentication parameters for `team-b-client`.\n+\n+[source,shell]\n+----\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+----\n+\n+The `team-b-client` client configuration includes a `Dev Team B` realm role and permissions that start with `Dev Team B ...`. These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with `b_` on the Kafka cluster `my-cluster`, the name of the designated cluster, and read access on topics that start with `x_`.\n+\n+The `team-b-client` configuration is used to produce messages to topic `a_messages`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+----\n+\n+A `Not authorized to access topics: [a_messages]` error is returned when trying to push the first message, as expected, so we switch to topic `b_messages`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+Message 2\n+Message 3\n+----\n+\n+Producing messages to topic `b_messages` is authorized and successful.\n+\n+We switch again, but this time to topic that `team-b-client` can only read from, topic `x_messages`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+----\n+\n+A `Not authorized to access topics: [x_messages]` error is returned, as expected, so we switch to `team-a-client`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+----\n+\n+A `Not authorized to access topics: [x_messages]` error is returned again. Though `team-a-client` can write to the `x_messages` topic, it it does not have a permission to create a topic if it does not yet exist. \n+\n+Before `team-a-client` can write to the `x_messages` topic, a admin _power user_ must create it with the correct configuration, such as the number of partitions and replicas.\n+\n+\n+.Managing Kafka with an authorized admin\n+\n+Admin user `bob` is created with full access to manage everything on the Kafka cluster `my-cluster`.\n+\n+Helper scripts are used to authenticate to the `keycloak` instance.\n+\n+The following scripts are downloaded to `/tmp` dir and made executable:\n+\n+[source,shell]\n+----\n+curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/oauth.sh -s > /tmp/oauth.sh\n+   chmod +x /tmp/oauth.sh\n+\n+curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/jwt.sh -s > /tmp/jwt.sh\n+   chmod +x /tmp/jwt.sh\n+----\n+\n+User `bob` authenticates to the Keycloak server with his username and password to get a refresh token.\n+\n+[source,shell]\n+----\n+export TOKEN_ENDPOINT=http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\n+REFRESH_TOKEN=$(/tmp/oauth.sh -q bob)\n+----\n+\n+When prompted for a password, 'bob-password' is used.\n+\n+We can inspect the refresh token:\n+\n+   /tmp/jwt.sh $REFRESH_TOKEN\n+\n+By default this is a long-lived refresh token that does not expire.", "originalCommit": "c3ae285eb9cd521a44fe7317e917b16c7018706b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ0NTQ3OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530445479", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The refresh token is a long-lived token that does not expire:\n          \n          \n            \n            The refresh token in this case is an offline token which is a long-lived refresh token that does not expire:", "author": "mstruk", "createdAt": "2020-11-25T15:11:22Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,465 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n+\n+\n+== Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+[source,yaml]\n+----\n+export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+----\n+\n+.Deploy the Postgres database for Keycloak\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+----\n+\n+.Deploy the Keycloak server\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+----\n+\n+If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:\n+\n+[source,yaml]\n+----\n+curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+----\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+[source,yaml]\n+----\n+kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+----\n+\n+\n+== Using the Keycloak Admin Console to configure authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+[source,yaml]\n+----\n+kubectl port-forward keycloak 8080\n+----\n+\n+Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.\n+\n+The default view usually displays the *Master* realm.\n+For this example we are interested in the `kafka-authz` realm, which you can select in the upper left corner.\n+\n+Initially the *Realm Settings* section is selected, but you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.\n+\n+Under *Groups*, you can view groups to mark users as having some permissions.\n+Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.\n+\n+Under *Users*, when viewing all users you will see two users defined: `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.\n+Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.\n+\n+Under *Clients*, you can view the additional client configurations: `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.\n+This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.\n+\n+\n+== Defining Authorization Services for access control\n+\n+Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources as explained in xref:keycloak_authorization_services_model_for_managing_permissions(one of the previous chapters).\n+\n+Under *Authorization* / *Permissions* of `kafka` client you can see already granted permissions that make use of *Resources* and *Policies* defined under the other tabs:\n+----\n+Dev Team A can write to topics that start with x_ on any cluster\n+Dev Team B can read from topics that start with x_ on any cluster\n+Dev Team B can update consumer group offsets that start with x_ on any cluster\n+ClusterManager of my-cluster Group has full access to cluster config on my-cluster\n+ClusterManager of my-cluster Group has full access to consumer groups on my-cluster\n+ClusterManager of my-cluster Group has full access to topics on my-cluster\n+----\n+\n+`Dev Team A can write to topics that start with x_ on any cluster` combines a resource called `Topic:x_*`, scopes `Describe` and `Write`, and `Dev Team A` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team A`.\n+\n+`Dev Team B can read from topics that start with x_ on any cluster` combines `Topic:x_*`, and `Group:x_*` resources, scopes `Describe` and `Read`, and `Dev Team B` policy. The `Dev Team A` policy matches all users that have a realm role called `Dev Team B`. Matching users and clients have the ability to read from topics, and update the consumed offsets for topics and consumer groups that have names starting with `x_`.\n+\n+== Targeting permissions using group or role policies\n+\n+In Keycloak, confidential clients with service accounts enabled can authenticate to the server in their own name using a client ID and a secret.\n+This is convenient for microservices which typically act in their own name, and not as agents of a particular user (like a web site would, for example).\n+Service accounts can have roles assigned like regular users.\n+They cannot, however, have groups assigned.\n+As a consequence, if you want to target permissions to microservices using service accounts, you cannot use group policies, and should instead use role policies.\n+Conversely, if you want to limit certain permissions only to regular user accounts where authentication with username and password is required, you can achieve that as a side effect of using the group policies, rather than the role policies.\n+That is what is used for permissions that start with `ClusterManager`.\n+Performing cluster management is usually done interactively - in person - using CLI tools.\n+It makes sense to require the user to log in, before using the resulting access token to authenticate to the Kafka Broker.\n+In this case, the access token represents the specific user, rather than the client application.\n+\n+\n+== Authorization in Action Using CLI Clients\n+\n+A note of caution - this example uses the latest version of Keycloak, and relies on bugfixes of issues in some older versions.\n+Let's make sure the Authorization rules have been properly imported when the Keycloak was started.\n+\n+From menu:Clients[kafka>Authorization>Settings] make sure that *Decision Strategy* is set to *Affirmative*, and NOT to *Unanimous*.\n+Navigate in Keycloak to check that the expected resources, authorization claims, policies and permissions are defined.\n+\n+With the configuration in place, we can check access to Kafka by using a producer and consumer to create topics using different user and service accounts.\n+\n+First, a new interactive pod container is run using a Strimzi Kafka image to connect to a running Kafka broker.\n+\n+[source,shell]\n+----\n+kubectl run -ti --rm --restart=Never --image=quay.io/strimzi/kafka:latest-kafka-2.6.0 kafka-cli -- /bin/sh\n+----\n+\n+NOTE: If `kubectl` times out waiting on the image download, subsequent attempts may result in an _AlreadyExists_ error. \n+\n+You can attach to the existing pod by running:\n+\n+[source,shell]\n+----\n+kubectl attach -ti kafka-cli\n+----\n+\n+To produce messages as client `team-a-client`, we prepare a Kafka client configuration file with authentication parameters.\n+\n+[source,shell]\n+----\n+cat > /tmp/team-a-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-a-client\" \\\n+  oauth.client.secret=\"team-a-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+----\n+\n+The roles assigned to a client, such as the `Dev Team A` realm role assigned to the `team-a-client` service account, are presented in Keycloak on the  *Service Account Roles* tab from *Clients*.\n+\n+We can use this configuration from the Kafka CLI to produce and consume messages, and perform other administration tasks.\n+\n+\n+.Producing messages with authorized access\n+\n+The `team-a-client` configuration is used to produce messages to topic `my-topic`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic my-topic \\\n+  --producer.config=/tmp/team-a-client.properties\n+First message\n+----\n+\n+A `Not authorized to access topics: [my-topic]` error is returned when trying to push the first message.\n+\n+`team-a-client` has a `Dev Team A` role that gives it permission to perform any supported actions on topics that start with `a_`, but can only write to topics that start with `x_`.\n+The topic named `my-topic` matches neither of those rules.\n+\n+The `team-a-client` configuration is then used to produce messages to topic `a_messages`.\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+First message\n+Second message\n+----\n+\n+The messages are pushed out successfully, and in the Kafka container log there is DEBUG level output saying `Authorization GRANTED`.\n+\n+Use CTRL-C to exit the CLI application.\n+\n+You can see the Kafka container log by running:\n+\n+[source,shell]\n+kubectl logs my-cluster-kafka-0 -f\n+\n+.Consuming messages with authorized access\n+\n+The `team-a-client` configuration is used to consume messages from topic `a_messages`:\n+\n+[source,shell,subs=+quotes]\n+----\n+bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --from-beginning --consumer.config /tmp/team-a-client.properties\n+----\n+\n+An error is returned as the `Dev Team A` role for `team-a-client` only has access to consumer groups that have names starting with `a_`.\n+The `team-a-client` configuration is then used to consume messages when specifying a custom consumer group with a name that starts with `a_`:\n+\n+[source,shell,subs=+quotes]\n+----\n+bin/kafka-console-consumer.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --from-beginning --consumer.config /tmp/team-a-client.properties --group a_consumer_group_1\n+----\n+\n+This time the consumer receives all the messages from the `a_messages` topic.\n+\n+\n+.Administering Kafka with authorized access\n+\n+The `team-a-client` configuration is used in administrative operations.\n+\n+Listing topics returns the `a_messages` topic.\n+\n+[source,shell]\n+----\n+bin/kafka-topics.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+----    \n+\n+Listing consumer groups returns the `a_consumer_group_1` consumer group.\n+\n+[source,shell]\n+----\n+bin/kafka-consumer-groups.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties --list\n+----\n+\n+Fetching the default cluster configuration fails cluster authorization, because the operation requires cluster level permissions that `team-a-client` does not have.\n+\n+[source,shell]\n+----\n+bin/kafka-configs.sh --bootstrap-server my-cluster-kafka-bootstrap:9092 --command-config /tmp/team-a-client.properties \\\n+  --entity-type brokers --describe --entity-default\n+----\n+\n+\n+. Using clients with different permissions\n+\n+As with `team-a-client`, we prepare a Kafka client configuration file with authentication parameters for `team-b-client`.\n+\n+[source,shell]\n+----\n+cat > /tmp/team-b-client.properties << EOF\n+security.protocol=SASL_PLAINTEXT\n+sasl.mechanism=OAUTHBEARER\n+sasl.jaas.config=org.apache.kafka.common.security.oauthbearer.OAuthBearerLoginModule required \\\n+  oauth.client.id=\"team-b-client\" \\\n+  oauth.client.secret=\"team-b-client-secret\" \\\n+  oauth.token.endpoint.uri=\"http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\" ;\n+sasl.login.callback.handler.class=io.strimzi.kafka.oauth.client.JaasClientOauthLoginCallbackHandler\n+EOF\n+----\n+\n+The `team-b-client` client configuration includes a `Dev Team B` realm role and permissions that start with `Dev Team B ...`. These match the users and service accounts that have the `Dev Team B` realm role assigned to them.\n+The `Dev Team B` users have full access to topics beginning with `b_` on the Kafka cluster `my-cluster`, the name of the designated cluster, and read access on topics that start with `x_`.\n+\n+The `team-b-client` configuration is used to produce messages to topic `a_messages`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic a_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+----\n+\n+A `Not authorized to access topics: [a_messages]` error is returned when trying to push the first message, as expected, so we switch to topic `b_messages`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic b_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+Message 2\n+Message 3\n+----\n+\n+Producing messages to topic `b_messages` is authorized and successful.\n+\n+We switch again, but this time to topic that `team-b-client` can only read from, topic `x_messages`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-b-client.properties\n+Message 1\n+----\n+\n+A `Not authorized to access topics: [x_messages]` error is returned, as expected, so we switch to `team-a-client`:\n+\n+[source,shell]\n+----\n+bin/kafka-console-producer.sh --broker-list my-cluster-kafka-bootstrap:9092 --topic x_messages \\\n+  --producer.config /tmp/team-a-client.properties\n+Message 1\n+----\n+\n+A `Not authorized to access topics: [x_messages]` error is returned again. Though `team-a-client` can write to the `x_messages` topic, it it does not have a permission to create a topic if it does not yet exist. \n+\n+Before `team-a-client` can write to the `x_messages` topic, a admin _power user_ must create it with the correct configuration, such as the number of partitions and replicas.\n+\n+\n+.Managing Kafka with an authorized admin\n+\n+Admin user `bob` is created with full access to manage everything on the Kafka cluster `my-cluster`.\n+\n+Helper scripts are used to authenticate to the `keycloak` instance.\n+\n+The following scripts are downloaded to `/tmp` dir and made executable:\n+\n+[source,shell]\n+----\n+curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/oauth.sh -s > /tmp/oauth.sh\n+   chmod +x /tmp/oauth.sh\n+\n+curl https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master/examples/docker/kafka-oauth-strimzi/kafka/jwt.sh -s > /tmp/jwt.sh\n+   chmod +x /tmp/jwt.sh\n+----\n+\n+User `bob` authenticates to the Keycloak server with his username and password to get a refresh token.\n+\n+[source,shell]\n+----\n+export TOKEN_ENDPOINT=http://keycloak:8080/auth/realms/kafka-authz/protocol/openid-connect/token\n+REFRESH_TOKEN=$(/tmp/oauth.sh -q bob)\n+----\n+\n+When prompted for a password, 'bob-password' is used.\n+\n+The refresh token is a long-lived token that does not expire:", "originalCommit": "8acb0f28c4f03ba98dd57bc1db348d8f1afd2c5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b1c7165ac26ebface55034ae2b69cc3d4918fd80", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/b1c7165ac26ebface55034ae2b69cc3d4918fd80", "message": "Address the last TODOs\n\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2020-11-26T12:53:51Z", "type": "forcePushed"}, {"oid": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/16582f6c776ff4ccd240537a7873a8aae60cbda8", "message": "Address the last TODOs\n\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2020-11-26T12:58:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ1MDE5Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531450193", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n          \n          \n            \n            When using `keycloak` authorization, a custom authorizer is configured on the Kafka broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.", "author": "PaulRMellor", "createdAt": "2020-11-27T08:32:20Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,462 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.", "originalCommit": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ1MDM5MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531450391", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.\n          \n          \n            \n            Grants are cached and enforced locally on the Kafka broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.", "author": "PaulRMellor", "createdAt": "2020-11-27T08:32:48Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,462 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using `oauth` authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this, Strimzi Kafka Operator comes with `keycloak` authorization which uses Keycloak Authorization Services to centrally manage permissions.\n+\n+When using `keycloak` authorization a custom authorizer is configured on the Kafka Broker that uses Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.\n+Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.", "originalCommit": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ1MDc0OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r531450749", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            == Token Based Authorization with Keycloak Authorization Services\n          \n          \n            \n            == Token-based authorization with Keycloak Authorization Services", "author": "PaulRMellor", "createdAt": "2020-11-27T08:33:37Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,462 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Example authorization rules configuration using Authorization Services\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+== Token Based Authorization with Keycloak Authorization Services", "originalCommit": "16582f6c776ff4ccd240537a7873a8aae60cbda8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODUzMTIzMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528531231", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            = Manage policies and permissions in Keycloak Authorization Services\n          \n          \n            \n            = Managing policies and permissions in Keycloak Authorization Services", "author": "PaulRMellor", "createdAt": "2020-11-23T08:24:12Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODUzOTM2OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528539368", "bodyText": "Could we introduce this chapter with a line to say what we'll be looking at and why? \"To use Keycloak with Strimzi, the Keycloak Authorization Services model must capture all possible Kafka permissions for resources. This section describes how the Kafka authorization model for resources maps to the Keycloak Authorization Services model for granting permissions.\"  Or similar.", "author": "PaulRMellor", "createdAt": "2020-11-23T08:39:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODUzMTIzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODUzOTU1NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528539555", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            == Kafka Authorization Model\n          \n          \n            \n            == Kafka authorization model for resources", "author": "PaulRMellor", "createdAt": "2020-11-23T08:40:19Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODU2OTAwOA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528569008", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n          \n          \n            \n            The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and the permissions available for each type.", "author": "PaulRMellor", "createdAt": "2020-11-23T09:33:45Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODU2OTU3OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528569579", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n          \n          \n            \n            When an action is performed by a Kafka client on a broker, the broker uses a configured authorizer to check permissions, depending on the action performed and the resource type.", "author": "PaulRMellor", "createdAt": "2020-11-23T09:34:43Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODU3ODIwOA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528578208", "bodyText": "I think I would make this the first sentence. And then the next sentence introduces what we will read next...\nWhen an action is performed by a Kafka client on a broker, the broker uses a configured authorizer to check permissions, depending on the action performed and the resource type. The Kafka authorization model defines resource types, and permissions available for each type.", "author": "PaulRMellor", "createdAt": "2020-11-23T09:48:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODU2OTU3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODU4MDA1NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528580055", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            And these are the different permissions for each resource type:\n          \n          \n            \n            Each resource type has different permissions:", "author": "PaulRMellor", "createdAt": "2020-11-23T09:51:42Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODU4NTA1NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528585054", "bodyText": "Are these the permissions we need to capture in Keycloak Authorization Services? If so, maybe we should say that: Each resource type has different permissions. The permissions listed here for each resource type, based on supported operations, must be captured in the Keycloak Authorization Services Model.", "author": "PaulRMellor", "createdAt": "2020-11-23T09:59:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODU4MDA1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODU5ODY5OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528598699", "bodyText": "How much are we likely to have to update these lists? Would it be accurate to say something like make sure you capture permissions for all the supported operations of each resource?", "author": "PaulRMellor", "createdAt": "2020-11-23T10:22:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODU4MDA1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYwMDYyMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528600622", "bodyText": "I guess we could have all these in the config/code format Topic.", "author": "PaulRMellor", "createdAt": "2020-11-23T10:25:20Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYwMDkxOQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528600919", "bodyText": "additional space", "author": "PaulRMellor", "createdAt": "2020-11-23T10:25:47Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc3OTYyNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528779625", "bodyText": "WDYM? A space too much and should be removed, or another space needs to be added?", "author": "mstruk", "createdAt": "2020-11-23T15:19:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYwMDkxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg5MDY2MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528890661", "bodyText": "Removed one empty line.", "author": "mstruk", "createdAt": "2020-11-23T17:52:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYwMDkxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYwMTg1Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528601852", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n          \n          \n            \n            Kafka has five resource types for controlling access: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.", "author": "PaulRMellor", "createdAt": "2020-11-23T10:27:26Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYwNTI0Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528605246", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n          \n          \n            \n            Keycloak Authorization Services use four concepts to define and grant permissions: _resources_, _authorization scopes_, _policies_, and _permissions_.", "author": "PaulRMellor", "createdAt": "2020-11-23T10:32:57Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYxMzIzMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528613230", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n          \n          \n            \n            For example, a resource can be an individual topic, or it can be a set of all topics with names that start with the same prefix.", "author": "PaulRMellor", "createdAt": "2020-11-23T10:46:42Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYxNTczMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528615732", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `Resources` are a set of resource definitions that are used to match permitted actions.\n          \n          \n            \n            Resources:: Resources are a set of resource definitions that are used to match permitted actions.", "author": "PaulRMellor", "createdAt": "2020-11-23T10:51:22Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYxNjM3MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528616371", "bodyText": "For the four concepts, we could remove the code format (`) and format as description lists, so they look like like this:", "author": "PaulRMellor", "createdAt": "2020-11-23T10:52:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYxNTczMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyMDkxOQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528620919", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n          \n          \n            \n            Authorization scopes: Authorization scopes is simply a set of all available actions on all the different resource types. When defining a new resource,  scopes are added from the set of all scopes.", "author": "PaulRMellor", "createdAt": "2020-11-23T11:00:33Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyNTA2OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528625069", "bodyText": "Assuming descriptions list and no code formatting on concept terms^^", "author": "PaulRMellor", "createdAt": "2020-11-23T11:08:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyMDkxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyMzE1Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528623156", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n          \n          \n            \n            Policies:: Policies are rules that use criteria to match a list of accounts. Policies can match service accounts based on client ID, or user accounts based on username, group, or roles.", "author": "PaulRMellor", "createdAt": "2020-11-23T11:04:39Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyNDYwOA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528624608", "bodyText": "Assuming descriptions list and no code formatting on concept terms^^", "author": "PaulRMellor", "createdAt": "2020-11-23T11:07:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyMzE1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyMzc0MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528623741", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n          \n          \n            \n            Permissions:: Permissions grant a subset of authorization scopes on a specific resource definition to a set of users.", "author": "PaulRMellor", "createdAt": "2020-11-23T11:05:41Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyMzkwNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528623905", "bodyText": "Assuming descriptions list and no code formatting on concept terms^^", "author": "PaulRMellor", "createdAt": "2020-11-23T11:06:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyMzc0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyNTU5Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528625597", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n          \n          \n            \n            The resource definition has a set of available authorization scopes associated with it, which represent a set of all actions that are permitted.", "author": "PaulRMellor", "createdAt": "2020-11-23T11:09:12Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODcyMzg5NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528723894", "bodyText": "In fact the original meaning 'can be permitted' is different than the suggested meaning 'are permitted'. The idea here is not to give permissions by adding the to list, but to compose a list of available permissions for this particular resource instance. Then on the Policies tab the granting of permissions on this particualr resource instance will be limited to 'can be permitted' actions. Maybe:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n          \n          \n            \n            The resource definition has a set of available authorization scopes associated with it, which represent a set of all actions available on the particular resource.", "author": "mstruk", "createdAt": "2020-11-23T14:02:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODYyNTU5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY1NDYzOQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528654639", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            == Keycloak Authorization Services Model\n          \n          \n            \n            == Keycloak Authorization Services model for granting permissions", "author": "PaulRMellor", "createdAt": "2020-11-23T12:03:32Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY5ODU2NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528698564", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n          \n          \n            \n            To be able to grant Kafka permissions to users or service accounts, you must define Authorization Services rules for the OAuth 2.0 client in Keycloak that represents the Kafka broker. Typically, the OAuth 2.0 client has `kafka` as its client ID.", "author": "PaulRMellor", "createdAt": "2020-11-23T13:22:06Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgwMDAxMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528800011", "bodyText": "i wonder if we should introduce this section with what we're describing? To map the Kafka authorization model to Keycloak Authorization Services, you create an OAuth 2.0 client in Keycloak that represents the Kafka broker, then define and enable Authorization Services for the client through scopes, resources, policies and permissions. You can then use the client to grant permissions to users or service accounts. Typically, the OAuth 2.0 client has kafka as its client ID. This section describes some of the best practices for setting up your Authorization Services for the client. Or something.", "author": "PaulRMellor", "createdAt": "2020-11-23T15:45:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODY5ODU2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODczMDMxMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528730310", "bodyText": "A slight improvement - originally missed roles for service account targetting, making it seem as if only user accounts can be targeted with roles.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Policies:: Policies are rules that use criteria to match a list of accounts. Policies can match service accounts based on client id, or user accounts based on username, group, or roles.\n          \n          \n            \n            Policies:: Policies are rules that use criteria to match a list of accounts. Policies can match service accounts based on client id or roles, or user accounts based on username, groups, or roles.", "author": "mstruk", "createdAt": "2020-11-23T14:12:29Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Managing policies and permissions in Keycloak Authorization Services\n+\n+== Kafka authorization model for resources\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and the permissions available for each type.\n+When an action is performed by a Kafka client on a broker, the broker uses a configured authorizer to check permissions, depending on the action performed and the resource type.\n+\n+Kafka has five resource types for controlling access: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+Each resource type has different permissions:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services model for managing permissions\n+\n+Keycloak Authorization Services use four concepts to define and grant permissions: _resources_, _authorization scopes_, _policies_, and _permissions_.\n+\n+Resources:: Resources are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with the same prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+Authorization scopes: Authorization scopes is simply a set of all available actions on all the different resource types. When defining a new resource,  scopes are added from the set of all scopes.\n+\n+Policies:: Policies are rules that use criteria to match a list of accounts. Policies can match service accounts based on client id, or user accounts based on username, group, or roles.", "originalCommit": "b6e0c02ec214b89fdfea5d5c7c268ca126c8cd8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc2ODUwOA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528768508", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This client needs to have `Authorization Enabled` option activated.\n          \n          \n            \n            The OAuth 2.0 client definition must have the _Authorization Enabled_ option activated.", "author": "PaulRMellor", "createdAt": "2020-11-23T15:04:53Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc2OTM5Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528769392", "bodyText": "I guess to be consistent with the rest of the guide, we should use OAUTH 2.0 and upper case ID in this content.", "author": "PaulRMellor", "createdAt": "2020-11-23T15:06:03Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc3ODU0NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528778544", "bodyText": "True, we're using that all over the documentation so let's be consistent ...", "author": "mstruk", "createdAt": "2020-11-23T15:18:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc2OTM5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc4MDMyOA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528780328", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n          \n          \n            \n            When the Kafka client use the _SASL OAUTHBEARER_ mechanism, the Keycloak authorizer (`KeycloakRBACAuthorizer`) retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.", "author": "PaulRMellor", "createdAt": "2020-11-23T15:20:39Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc4Mjg2Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528782862", "bodyText": "We use SASL OAUTHBEARER mechanism elsewhere in the guide. Should we use it here?", "author": "PaulRMellor", "createdAt": "2020-11-23T15:24:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc4MDMyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc4MzczMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528783732", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            .Authorization scopes\n          \n          \n            \n            .Introducing authorization scopes", "author": "PaulRMellor", "createdAt": "2020-11-23T15:25:10Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc4ODUzMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528788532", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n          \n          \n            \n            All permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client IDs they would each have a separate set of permissions even though they are part of the same realm.", "author": "PaulRMellor", "createdAt": "2020-11-23T15:31:16Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgwMTAwMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528801001", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n          \n          \n            \n            Typically, an initial configuration involves uploading the authorization scopes to create a list of all the possible actions that can be performed on all the Kafka resource types.", "author": "PaulRMellor", "createdAt": "2020-11-23T15:47:16Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgwMzEwMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528803103", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n          \n          \n            \n            This step is performed only once, before defining any permissions. Alternatively, you can add authorization scopes manually.", "author": "PaulRMellor", "createdAt": "2020-11-23T15:50:10Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgwMzU1Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528803556", "bodyText": "I think we could say the thing about typos anywhere we talk about config.", "author": "PaulRMellor", "createdAt": "2020-11-23T15:50:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgwMzEwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgwMzc1NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528803755", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:\n          \n          \n            \n            The authorization scopes should contain all the possible Kafka permissions regardless of the resource type:", "author": "PaulRMellor", "createdAt": "2020-11-23T15:50:58Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n+\n+The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgwNTE4Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528805187", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The `resources` use pattern names to be used with pattern matching against the targeted resources when performing the permission check.\n          \n          \n            \n            The resources use pattern names for pattern matching against the targeted resources when performing permission checks.", "author": "PaulRMellor", "createdAt": "2020-11-23T15:52:52Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n+\n+The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* Alter\n+* DescribeConfig\n+* AlterConfig\n+* ClusterAction\n+* IdempotentWrite\n+\n+.Resources\n+\n+The `resources` use pattern names to be used with pattern matching against the targeted resources when performing the permission check.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgwNjI0Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528806242", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            A few examples:\n          \n          \n            \n            .Example patterns for resources", "author": "PaulRMellor", "createdAt": "2020-11-23T15:54:16Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n+\n+The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* Alter\n+* DescribeConfig\n+* AlterConfig\n+* ClusterAction\n+* IdempotentWrite\n+\n+.Resources\n+\n+The `resources` use pattern names to be used with pattern matching against the targeted resources when performing the permission check.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+A few examples:\n+", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgwNjkwNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528806907", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In addition, the general pattern can be prefixed by another one of the format `kafka-cluster:CLUSTER_NAME`, followed by comma, where the cluster name refers to the `metadata.name` in the Kafka CR.\n          \n          \n            \n            In addition, the general pattern can be prefixed by `kafka-cluster:CLUSTER_NAME` followed by a comma, where the cluster name refers to the `metadata.name` in the Kafka custom resource.", "author": "PaulRMellor", "createdAt": "2020-11-23T15:55:08Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n+\n+The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* Alter\n+* DescribeConfig\n+* AlterConfig\n+* ClusterAction\n+* IdempotentWrite\n+\n+.Resources\n+\n+The `resources` use pattern names to be used with pattern matching against the targeted resources when performing the permission check.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+A few examples:\n+\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by another one of the format `kafka-cluster:CLUSTER_NAME`, followed by comma, where the cluster name refers to the `metadata.name` in the Kafka CR.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgwODM5Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528808397", "bodyText": "In addition or alternatively?", "author": "PaulRMellor", "createdAt": "2020-11-23T15:57:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgwNjkwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3ODk0MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528878940", "bodyText": "Is there semantic difference or just a matter of how it sounds?", "author": "mstruk", "createdAt": "2020-11-23T17:33:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgwNjkwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgwODkzNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528808937", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For example:\n          \n          \n            \n            .Example patterns for resources with cluster prefix", "author": "PaulRMellor", "createdAt": "2020-11-23T15:57:44Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n+\n+The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* Alter\n+* DescribeConfig\n+* AlterConfig\n+* ClusterAction\n+* IdempotentWrite\n+\n+.Resources\n+\n+The `resources` use pattern names to be used with pattern matching against the targeted resources when performing the permission check.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+A few examples:\n+\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by another one of the format `kafka-cluster:CLUSTER_NAME`, followed by comma, where the cluster name refers to the `metadata.name` in the Kafka CR.\n+\n+For example:\n+", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgxMTgxOA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528811818", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            When the resource is defined, a list of possible authorization scopes relevant to the resource should be added to the list of scopes.\n          \n          \n            \n            When defining a resource, you can associate a list of possible authorization scopes relevant to the resource.", "author": "PaulRMellor", "createdAt": "2020-11-23T15:59:48Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n+\n+The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* Alter\n+* DescribeConfig\n+* AlterConfig\n+* ClusterAction\n+* IdempotentWrite\n+\n+.Resources\n+\n+The `resources` use pattern names to be used with pattern matching against the targeted resources when performing the permission check.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+A few examples:\n+\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by another one of the format `kafka-cluster:CLUSTER_NAME`, followed by comma, where the cluster name refers to the `metadata.name` in the Kafka CR.\n+\n+For example:\n+\n+    kafka-cluster:my-cluster,Topic:*\n+    kafka-cluster:*,Group:b_*\n+\n+When the `kafka-cluster` prefix is not present it is assumed to be `kafka-cluster:*`.\n+\n+When the resource is defined, a list of possible authorization scopes relevant to the resource should be added to the list of scopes.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgxODEzMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528818131", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            While you may add any `authorization scope` to any `resource`, only the scopes supported by the resource type will ever matter.\n          \n          \n            \n            While you may add any authorization scope to any resource, only the scopes supported by the resource type are considered for access control.", "author": "PaulRMellor", "createdAt": "2020-11-23T16:05:14Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n+\n+The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* Alter\n+* DescribeConfig\n+* AlterConfig\n+* ClusterAction\n+* IdempotentWrite\n+\n+.Resources\n+\n+The `resources` use pattern names to be used with pattern matching against the targeted resources when performing the permission check.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+A few examples:\n+\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by another one of the format `kafka-cluster:CLUSTER_NAME`, followed by comma, where the cluster name refers to the `metadata.name` in the Kafka CR.\n+\n+For example:\n+\n+    kafka-cluster:my-cluster,Topic:*\n+    kafka-cluster:*,Group:b_*\n+\n+When the `kafka-cluster` prefix is not present it is assumed to be `kafka-cluster:*`.\n+\n+When the resource is defined, a list of possible authorization scopes relevant to the resource should be added to the list of scopes.\n+Set whatever actions make sense for the targeted resource type.\n+\n+While you may add any `authorization scope` to any `resource`, only the scopes supported by the resource type will ever matter.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgxOTkwMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528819902", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The `policies` are used to target permissions to one or more accounts.\n          \n          \n            \n            Policies are used to target permissions to one or more accounts.", "author": "PaulRMellor", "createdAt": "2020-11-23T16:07:42Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n+\n+The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* Alter\n+* DescribeConfig\n+* AlterConfig\n+* ClusterAction\n+* IdempotentWrite\n+\n+.Resources\n+\n+The `resources` use pattern names to be used with pattern matching against the targeted resources when performing the permission check.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+A few examples:\n+\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by another one of the format `kafka-cluster:CLUSTER_NAME`, followed by comma, where the cluster name refers to the `metadata.name` in the Kafka CR.\n+\n+For example:\n+\n+    kafka-cluster:my-cluster,Topic:*\n+    kafka-cluster:*,Group:b_*\n+\n+When the `kafka-cluster` prefix is not present it is assumed to be `kafka-cluster:*`.\n+\n+When the resource is defined, a list of possible authorization scopes relevant to the resource should be added to the list of scopes.\n+Set whatever actions make sense for the targeted resource type.\n+\n+While you may add any `authorization scope` to any `resource`, only the scopes supported by the resource type will ever matter.\n+\n+.Policies\n+\n+The `policies` are used to target permissions to one or more accounts.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgyMTAxMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528821013", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The targeting can refer to specific user or service accounts, it can refer to the realm roles or client roles, it can refer to user groups, and it can even use a JS rule and match client's IP address for example.\n          \n          \n            \n            Targeting can refer to:\n          \n          \n            \n            * Specific user or service accounts\n          \n          \n            \n            * Realm roles or client roles\n          \n          \n            \n            * User groups\n          \n          \n            \n            * JS rule to match a client IP address", "author": "PaulRMellor", "createdAt": "2020-11-23T16:09:25Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n+\n+The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* Alter\n+* DescribeConfig\n+* AlterConfig\n+* ClusterAction\n+* IdempotentWrite\n+\n+.Resources\n+\n+The `resources` use pattern names to be used with pattern matching against the targeted resources when performing the permission check.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+A few examples:\n+\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by another one of the format `kafka-cluster:CLUSTER_NAME`, followed by comma, where the cluster name refers to the `metadata.name` in the Kafka CR.\n+\n+For example:\n+\n+    kafka-cluster:my-cluster,Topic:*\n+    kafka-cluster:*,Group:b_*\n+\n+When the `kafka-cluster` prefix is not present it is assumed to be `kafka-cluster:*`.\n+\n+When the resource is defined, a list of possible authorization scopes relevant to the resource should be added to the list of scopes.\n+Set whatever actions make sense for the targeted resource type.\n+\n+While you may add any `authorization scope` to any `resource`, only the scopes supported by the resource type will ever matter.\n+\n+.Policies\n+\n+The `policies` are used to target permissions to one or more accounts.\n+The targeting can refer to specific user or service accounts, it can refer to the realm roles or client roles, it can refer to user groups, and it can even use a JS rule and match client's IP address for example.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgyMTY5NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528821695", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Each policy can be given a name, and can be reused to target multiple permissions to multiple resources.\n          \n          \n            \n            A policy is given a unique name, and can be reused to target multiple permissions to multiple resources.", "author": "PaulRMellor", "createdAt": "2020-11-23T16:10:22Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n+\n+The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* Alter\n+* DescribeConfig\n+* AlterConfig\n+* ClusterAction\n+* IdempotentWrite\n+\n+.Resources\n+\n+The `resources` use pattern names to be used with pattern matching against the targeted resources when performing the permission check.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+A few examples:\n+\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by another one of the format `kafka-cluster:CLUSTER_NAME`, followed by comma, where the cluster name refers to the `metadata.name` in the Kafka CR.\n+\n+For example:\n+\n+    kafka-cluster:my-cluster,Topic:*\n+    kafka-cluster:*,Group:b_*\n+\n+When the `kafka-cluster` prefix is not present it is assumed to be `kafka-cluster:*`.\n+\n+When the resource is defined, a list of possible authorization scopes relevant to the resource should be added to the list of scopes.\n+Set whatever actions make sense for the targeted resource type.\n+\n+While you may add any `authorization scope` to any `resource`, only the scopes supported by the resource type will ever matter.\n+\n+.Policies\n+\n+The `policies` are used to target permissions to one or more accounts.\n+The targeting can refer to specific user or service accounts, it can refer to the realm roles or client roles, it can refer to user groups, and it can even use a JS rule and match client's IP address for example.\n+\n+Each policy can be given a name, and can be reused to target multiple permissions to multiple resources.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgyMjUwOQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528822509", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            .Resources\n          \n          \n            \n            .Defining resource patterns for permission checks", "author": "PaulRMellor", "createdAt": "2020-11-23T16:11:27Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n+\n+The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* Alter\n+* DescribeConfig\n+* AlterConfig\n+* ClusterAction\n+* IdempotentWrite\n+\n+.Resources", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgyMzA0NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528823044", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            .Permissions\n          \n          \n            \n            .Defining permissions based on scopes, resources and policies", "author": "PaulRMellor", "createdAt": "2020-11-23T16:12:09Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n+\n+The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* Alter\n+* DescribeConfig\n+* AlterConfig\n+* ClusterAction\n+* IdempotentWrite\n+\n+.Resources\n+\n+The `resources` use pattern names to be used with pattern matching against the targeted resources when performing the permission check.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+A few examples:\n+\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by another one of the format `kafka-cluster:CLUSTER_NAME`, followed by comma, where the cluster name refers to the `metadata.name` in the Kafka CR.\n+\n+For example:\n+\n+    kafka-cluster:my-cluster,Topic:*\n+    kafka-cluster:*,Group:b_*\n+\n+When the `kafka-cluster` prefix is not present it is assumed to be `kafka-cluster:*`.\n+\n+When the resource is defined, a list of possible authorization scopes relevant to the resource should be added to the list of scopes.\n+Set whatever actions make sense for the targeted resource type.\n+\n+While you may add any `authorization scope` to any `resource`, only the scopes supported by the resource type will ever matter.\n+\n+.Policies\n+\n+The `policies` are used to target permissions to one or more accounts.\n+The targeting can refer to specific user or service accounts, it can refer to the realm roles or client roles, it can refer to user groups, and it can even use a JS rule and match client's IP address for example.\n+\n+Each policy can be given a name, and can be reused to target multiple permissions to multiple resources.\n+\n+.Permissions", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgyNDI0OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528824248", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The `permissions` are the final step where you pull together the `policies`, `resources`, and `authorization scopes` to grant access to one or more users.\n          \n          \n            \n            Use fine-grained permissions to pull together the policies, resources, and authorization scopes that grant access to users.", "author": "PaulRMellor", "createdAt": "2020-11-23T16:13:57Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n+\n+The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* Alter\n+* DescribeConfig\n+* AlterConfig\n+* ClusterAction\n+* IdempotentWrite\n+\n+.Resources\n+\n+The `resources` use pattern names to be used with pattern matching against the targeted resources when performing the permission check.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+A few examples:\n+\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by another one of the format `kafka-cluster:CLUSTER_NAME`, followed by comma, where the cluster name refers to the `metadata.name` in the Kafka CR.\n+\n+For example:\n+\n+    kafka-cluster:my-cluster,Topic:*\n+    kafka-cluster:*,Group:b_*\n+\n+When the `kafka-cluster` prefix is not present it is assumed to be `kafka-cluster:*`.\n+\n+When the resource is defined, a list of possible authorization scopes relevant to the resource should be added to the list of scopes.\n+Set whatever actions make sense for the targeted resource type.\n+\n+While you may add any `authorization scope` to any `resource`, only the scopes supported by the resource type will ever matter.\n+\n+.Policies\n+\n+The `policies` are used to target permissions to one or more accounts.\n+The targeting can refer to specific user or service accounts, it can refer to the realm roles or client roles, it can refer to user groups, and it can even use a JS rule and match client's IP address for example.\n+\n+Each policy can be given a name, and can be reused to target multiple permissions to multiple resources.\n+\n+.Permissions\n+\n+The `permissions` are the final step where you pull together the `policies`, `resources`, and `authorization scopes` to grant access to one or more users.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgyNTYyNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528825624", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Scope permissions should be used to grant fine-grained permissions to users.", "author": "PaulRMellor", "createdAt": "2020-11-23T16:15:46Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n+\n+The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* Alter\n+* DescribeConfig\n+* AlterConfig\n+* ClusterAction\n+* IdempotentWrite\n+\n+.Resources\n+\n+The `resources` use pattern names to be used with pattern matching against the targeted resources when performing the permission check.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+A few examples:\n+\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by another one of the format `kafka-cluster:CLUSTER_NAME`, followed by comma, where the cluster name refers to the `metadata.name` in the Kafka CR.\n+\n+For example:\n+\n+    kafka-cluster:my-cluster,Topic:*\n+    kafka-cluster:*,Group:b_*\n+\n+When the `kafka-cluster` prefix is not present it is assumed to be `kafka-cluster:*`.\n+\n+When the resource is defined, a list of possible authorization scopes relevant to the resource should be added to the list of scopes.\n+Set whatever actions make sense for the targeted resource type.\n+\n+While you may add any `authorization scope` to any `resource`, only the scopes supported by the resource type will ever matter.\n+\n+.Policies\n+\n+The `policies` are used to target permissions to one or more accounts.\n+The targeting can refer to specific user or service accounts, it can refer to the realm roles or client roles, it can refer to user groups, and it can even use a JS rule and match client's IP address for example.\n+\n+Each policy can be given a name, and can be reused to target multiple permissions to multiple resources.\n+\n+.Permissions\n+\n+The `permissions` are the final step where you pull together the `policies`, `resources`, and `authorization scopes` to grant access to one or more users.\n+\n+Scope permissions should be used to grant fine-grained permissions to users.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgyNjI4NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528826285", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Each policy should be descriptively named in order to make it very clear what permissions it grants to which users.\n          \n          \n            \n            The name of the each permission should should clearly define what permissions it grants to which users.", "author": "PaulRMellor", "createdAt": "2020-11-23T16:16:40Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n+\n+The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* Alter\n+* DescribeConfig\n+* AlterConfig\n+* ClusterAction\n+* IdempotentWrite\n+\n+.Resources\n+\n+The `resources` use pattern names to be used with pattern matching against the targeted resources when performing the permission check.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+A few examples:\n+\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by another one of the format `kafka-cluster:CLUSTER_NAME`, followed by comma, where the cluster name refers to the `metadata.name` in the Kafka CR.\n+\n+For example:\n+\n+    kafka-cluster:my-cluster,Topic:*\n+    kafka-cluster:*,Group:b_*\n+\n+When the `kafka-cluster` prefix is not present it is assumed to be `kafka-cluster:*`.\n+\n+When the resource is defined, a list of possible authorization scopes relevant to the resource should be added to the list of scopes.\n+Set whatever actions make sense for the targeted resource type.\n+\n+While you may add any `authorization scope` to any `resource`, only the scopes supported by the resource type will ever matter.\n+\n+.Policies\n+\n+The `policies` are used to target permissions to one or more accounts.\n+The targeting can refer to specific user or service accounts, it can refer to the realm roles or client roles, it can refer to user groups, and it can even use a JS rule and match client's IP address for example.\n+\n+Each policy can be given a name, and can be reused to target multiple permissions to multiple resources.\n+\n+.Permissions\n+\n+The `permissions` are the final step where you pull together the `policies`, `resources`, and `authorization scopes` to grant access to one or more users.\n+\n+Scope permissions should be used to grant fine-grained permissions to users.\n+\n+Each policy should be descriptively named in order to make it very clear what permissions it grants to which users.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODgyNzYyMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528827622", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            See xref:con-oauth-authorization-keycloak-example_str[the authorization example] to get a hands-on understanding of how to configure the permissions through Keycloak Authorization Services.\n          \n          \n            \n            For more information on how to configure permissions through Keycloak Authorization Services, see xref:con-oauth-authorization-keycloak-example_str[the authorization example].", "author": "PaulRMellor", "createdAt": "2020-11-23T16:18:22Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n+\n+The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* Alter\n+* DescribeConfig\n+* AlterConfig\n+* ClusterAction\n+* IdempotentWrite\n+\n+.Resources\n+\n+The `resources` use pattern names to be used with pattern matching against the targeted resources when performing the permission check.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+A few examples:\n+\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by another one of the format `kafka-cluster:CLUSTER_NAME`, followed by comma, where the cluster name refers to the `metadata.name` in the Kafka CR.\n+\n+For example:\n+\n+    kafka-cluster:my-cluster,Topic:*\n+    kafka-cluster:*,Group:b_*\n+\n+When the `kafka-cluster` prefix is not present it is assumed to be `kafka-cluster:*`.\n+\n+When the resource is defined, a list of possible authorization scopes relevant to the resource should be added to the list of scopes.\n+Set whatever actions make sense for the targeted resource type.\n+\n+While you may add any `authorization scope` to any `resource`, only the scopes supported by the resource type will ever matter.\n+\n+.Policies\n+\n+The `policies` are used to target permissions to one or more accounts.\n+The targeting can refer to specific user or service accounts, it can refer to the realm roles or client roles, it can refer to user groups, and it can even use a JS rule and match client's IP address for example.\n+\n+Each policy can be given a name, and can be reused to target multiple permissions to multiple resources.\n+\n+.Permissions\n+\n+The `permissions` are the final step where you pull together the `policies`, `resources`, and `authorization scopes` to grant access to one or more users.\n+\n+Scope permissions should be used to grant fine-grained permissions to users.\n+\n+Each policy should be descriptively named in order to make it very clear what permissions it grants to which users.\n+\n+See xref:con-oauth-authorization-keycloak-example_str[the authorization example] to get a hands-on understanding of how to configure the permissions through Keycloak Authorization Services.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg0NTczNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528845737", "bodyText": "We need some context here. What are describing in this section and how it's relevant to the reader.", "author": "PaulRMellor", "createdAt": "2020-11-23T16:43:25Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n+\n+The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* Alter\n+* DescribeConfig\n+* AlterConfig\n+* ClusterAction\n+* IdempotentWrite\n+\n+.Resources\n+\n+The `resources` use pattern names to be used with pattern matching against the targeted resources when performing the permission check.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+A few examples:\n+\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by another one of the format `kafka-cluster:CLUSTER_NAME`, followed by comma, where the cluster name refers to the `metadata.name` in the Kafka CR.\n+\n+For example:\n+\n+    kafka-cluster:my-cluster,Topic:*\n+    kafka-cluster:*,Group:b_*\n+\n+When the `kafka-cluster` prefix is not present it is assumed to be `kafka-cluster:*`.\n+\n+When the resource is defined, a list of possible authorization scopes relevant to the resource should be added to the list of scopes.\n+Set whatever actions make sense for the targeted resource type.\n+\n+While you may add any `authorization scope` to any `resource`, only the scopes supported by the resource type will ever matter.\n+\n+.Policies\n+\n+The `policies` are used to target permissions to one or more accounts.\n+The targeting can refer to specific user or service accounts, it can refer to the realm roles or client roles, it can refer to user groups, and it can even use a JS rule and match client's IP address for example.\n+\n+Each policy can be given a name, and can be reused to target multiple permissions to multiple resources.\n+\n+.Permissions\n+\n+The `permissions` are the final step where you pull together the `policies`, `resources`, and `authorization scopes` to grant access to one or more users.\n+\n+Scope permissions should be used to grant fine-grained permissions to users.\n+\n+Each policy should be descriptively named in order to make it very clear what permissions it grants to which users.\n+\n+See xref:con-oauth-authorization-keycloak-example_str[the authorization example] to get a hands-on understanding of how to configure the permissions through Keycloak Authorization Services.\n+\n+\n+== Permissions required by operations\n+", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg5NzMzMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528897333", "bodyText": "Added the next line.", "author": "mstruk", "createdAt": "2020-11-23T18:03:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg0NTczNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg0NjM4MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528846381", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In order to create the topic the `Create` permission is required for the specific topic or on `Cluster:kafka-cluster`.\n          \n          \n            \n            To create a topic the `Create` permission is required for the specific topic or `Cluster:kafka-cluster`.", "author": "PaulRMellor", "createdAt": "2020-11-23T16:44:22Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n+\n+The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* Alter\n+* DescribeConfig\n+* AlterConfig\n+* ClusterAction\n+* IdempotentWrite\n+\n+.Resources\n+\n+The `resources` use pattern names to be used with pattern matching against the targeted resources when performing the permission check.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+A few examples:\n+\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by another one of the format `kafka-cluster:CLUSTER_NAME`, followed by comma, where the cluster name refers to the `metadata.name` in the Kafka CR.\n+\n+For example:\n+\n+    kafka-cluster:my-cluster,Topic:*\n+    kafka-cluster:*,Group:b_*\n+\n+When the `kafka-cluster` prefix is not present it is assumed to be `kafka-cluster:*`.\n+\n+When the resource is defined, a list of possible authorization scopes relevant to the resource should be added to the list of scopes.\n+Set whatever actions make sense for the targeted resource type.\n+\n+While you may add any `authorization scope` to any `resource`, only the scopes supported by the resource type will ever matter.\n+\n+.Policies\n+\n+The `policies` are used to target permissions to one or more accounts.\n+The targeting can refer to specific user or service accounts, it can refer to the realm roles or client roles, it can refer to user groups, and it can even use a JS rule and match client's IP address for example.\n+\n+Each policy can be given a name, and can be reused to target multiple permissions to multiple resources.\n+\n+.Permissions\n+\n+The `permissions` are the final step where you pull together the `policies`, `resources`, and `authorization scopes` to grant access to one or more users.\n+\n+Scope permissions should be used to grant fine-grained permissions to users.\n+\n+Each policy should be descriptively named in order to make it very clear what permissions it grants to which users.\n+\n+See xref:con-oauth-authorization-keycloak-example_str[the authorization example] to get a hands-on understanding of how to configure the permissions through Keycloak Authorization Services.\n+\n+\n+== Permissions required by operations\n+\n+.Creating the topic\n+\n+In order to create the topic the `Create` permission is required for the specific topic or on `Cluster:kafka-cluster`.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg0NjcyNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528846724", "bodyText": "Separate sub-section?", "author": "PaulRMellor", "createdAt": "2020-11-23T16:44:52Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n+\n+The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* Alter\n+* DescribeConfig\n+* AlterConfig\n+* ClusterAction\n+* IdempotentWrite\n+\n+.Resources\n+\n+The `resources` use pattern names to be used with pattern matching against the targeted resources when performing the permission check.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+A few examples:\n+\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by another one of the format `kafka-cluster:CLUSTER_NAME`, followed by comma, where the cluster name refers to the `metadata.name` in the Kafka CR.\n+\n+For example:\n+\n+    kafka-cluster:my-cluster,Topic:*\n+    kafka-cluster:*,Group:b_*\n+\n+When the `kafka-cluster` prefix is not present it is assumed to be `kafka-cluster:*`.\n+\n+When the resource is defined, a list of possible authorization scopes relevant to the resource should be added to the list of scopes.\n+Set whatever actions make sense for the targeted resource type.\n+\n+While you may add any `authorization scope` to any `resource`, only the scopes supported by the resource type will ever matter.\n+\n+.Policies\n+\n+The `policies` are used to target permissions to one or more accounts.\n+The targeting can refer to specific user or service accounts, it can refer to the realm roles or client roles, it can refer to user groups, and it can even use a JS rule and match client's IP address for example.\n+\n+Each policy can be given a name, and can be reused to target multiple permissions to multiple resources.\n+\n+.Permissions\n+\n+The `permissions` are the final step where you pull together the `policies`, `resources`, and `authorization scopes` to grant access to one or more users.\n+\n+Scope permissions should be used to grant fine-grained permissions to users.\n+\n+Each policy should be descriptively named in order to make it very clear what permissions it grants to which users.\n+\n+See xref:con-oauth-authorization-keycloak-example_str[the authorization example] to get a hands-on understanding of how to configure the permissions through Keycloak Authorization Services.\n+\n+\n+== Permissions required by operations\n+\n+.Creating the topic\n+\n+In order to create the topic the `Create` permission is required for the specific topic or on `Cluster:kafka-cluster`.\n+To display the details of the created topic the `Describe` permission is required for the specific topic.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkwMjk4Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528902987", "bodyText": "Done.", "author": "mstruk", "createdAt": "2020-11-23T18:13:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg0NjcyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg2MzI1Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528863253", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            .Creating the topic\n          \n          \n            \n            .Creating a topic", "author": "PaulRMellor", "createdAt": "2020-11-23T17:09:00Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n+\n+The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* Alter\n+* DescribeConfig\n+* AlterConfig\n+* ClusterAction\n+* IdempotentWrite\n+\n+.Resources\n+\n+The `resources` use pattern names to be used with pattern matching against the targeted resources when performing the permission check.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+A few examples:\n+\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by another one of the format `kafka-cluster:CLUSTER_NAME`, followed by comma, where the cluster name refers to the `metadata.name` in the Kafka CR.\n+\n+For example:\n+\n+    kafka-cluster:my-cluster,Topic:*\n+    kafka-cluster:*,Group:b_*\n+\n+When the `kafka-cluster` prefix is not present it is assumed to be `kafka-cluster:*`.\n+\n+When the resource is defined, a list of possible authorization scopes relevant to the resource should be added to the list of scopes.\n+Set whatever actions make sense for the targeted resource type.\n+\n+While you may add any `authorization scope` to any `resource`, only the scopes supported by the resource type will ever matter.\n+\n+.Policies\n+\n+The `policies` are used to target permissions to one or more accounts.\n+The targeting can refer to specific user or service accounts, it can refer to the realm roles or client roles, it can refer to user groups, and it can even use a JS rule and match client's IP address for example.\n+\n+Each policy can be given a name, and can be reused to target multiple permissions to multiple resources.\n+\n+.Permissions\n+\n+The `permissions` are the final step where you pull together the `policies`, `resources`, and `authorization scopes` to grant access to one or more users.\n+\n+Scope permissions should be used to grant fine-grained permissions to users.\n+\n+Each policy should be descriptively named in order to make it very clear what permissions it grants to which users.\n+\n+See xref:con-oauth-authorization-keycloak-example_str[the authorization example] to get a hands-on understanding of how to configure the permissions through Keycloak Authorization Services.\n+\n+\n+== Permissions required by operations\n+\n+.Creating the topic", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg2MzYxMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528863613", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In order to produce to the topic the user needs `Describe` and `Write` permissions on the topic.\n          \n          \n            \n            To produce to the topic the user needs `Describe` and `Write` permissions on the topic.", "author": "PaulRMellor", "createdAt": "2020-11-23T17:09:34Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n+\n+The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* Alter\n+* DescribeConfig\n+* AlterConfig\n+* ClusterAction\n+* IdempotentWrite\n+\n+.Resources\n+\n+The `resources` use pattern names to be used with pattern matching against the targeted resources when performing the permission check.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+A few examples:\n+\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by another one of the format `kafka-cluster:CLUSTER_NAME`, followed by comma, where the cluster name refers to the `metadata.name` in the Kafka CR.\n+\n+For example:\n+\n+    kafka-cluster:my-cluster,Topic:*\n+    kafka-cluster:*,Group:b_*\n+\n+When the `kafka-cluster` prefix is not present it is assumed to be `kafka-cluster:*`.\n+\n+When the resource is defined, a list of possible authorization scopes relevant to the resource should be added to the list of scopes.\n+Set whatever actions make sense for the targeted resource type.\n+\n+While you may add any `authorization scope` to any `resource`, only the scopes supported by the resource type will ever matter.\n+\n+.Policies\n+\n+The `policies` are used to target permissions to one or more accounts.\n+The targeting can refer to specific user or service accounts, it can refer to the realm roles or client roles, it can refer to user groups, and it can even use a JS rule and match client's IP address for example.\n+\n+Each policy can be given a name, and can be reused to target multiple permissions to multiple resources.\n+\n+.Permissions\n+\n+The `permissions` are the final step where you pull together the `policies`, `resources`, and `authorization scopes` to grant access to one or more users.\n+\n+Scope permissions should be used to grant fine-grained permissions to users.\n+\n+Each policy should be descriptively named in order to make it very clear what permissions it grants to which users.\n+\n+See xref:con-oauth-authorization-keycloak-example_str[the authorization example] to get a hands-on understanding of how to configure the permissions through Keycloak Authorization Services.\n+\n+\n+== Permissions required by operations\n+\n+.Creating the topic\n+\n+In order to create the topic the `Create` permission is required for the specific topic or on `Cluster:kafka-cluster`.\n+To display the details of the created topic the `Describe` permission is required for the specific topic.\n+\n+.Producing to the topic\n+\n+In order to produce to the topic the user needs `Describe` and `Write` permissions on the topic.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg2NTYyMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528865623", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In order to consume from the topic the user needs `Describe` and `Read` permissions on the topic.\n          \n          \n            \n            To consume from the topic the user needs `Describe` and `Read` permissions on the topic.", "author": "PaulRMellor", "createdAt": "2020-11-23T17:12:27Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n+\n+The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* Alter\n+* DescribeConfig\n+* AlterConfig\n+* ClusterAction\n+* IdempotentWrite\n+\n+.Resources\n+\n+The `resources` use pattern names to be used with pattern matching against the targeted resources when performing the permission check.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+A few examples:\n+\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by another one of the format `kafka-cluster:CLUSTER_NAME`, followed by comma, where the cluster name refers to the `metadata.name` in the Kafka CR.\n+\n+For example:\n+\n+    kafka-cluster:my-cluster,Topic:*\n+    kafka-cluster:*,Group:b_*\n+\n+When the `kafka-cluster` prefix is not present it is assumed to be `kafka-cluster:*`.\n+\n+When the resource is defined, a list of possible authorization scopes relevant to the resource should be added to the list of scopes.\n+Set whatever actions make sense for the targeted resource type.\n+\n+While you may add any `authorization scope` to any `resource`, only the scopes supported by the resource type will ever matter.\n+\n+.Policies\n+\n+The `policies` are used to target permissions to one or more accounts.\n+The targeting can refer to specific user or service accounts, it can refer to the realm roles or client roles, it can refer to user groups, and it can even use a JS rule and match client's IP address for example.\n+\n+Each policy can be given a name, and can be reused to target multiple permissions to multiple resources.\n+\n+.Permissions\n+\n+The `permissions` are the final step where you pull together the `policies`, `resources`, and `authorization scopes` to grant access to one or more users.\n+\n+Scope permissions should be used to grant fine-grained permissions to users.\n+\n+Each policy should be descriptively named in order to make it very clear what permissions it grants to which users.\n+\n+See xref:con-oauth-authorization-keycloak-example_str[the authorization example] to get a hands-on understanding of how to configure the permissions through Keycloak Authorization Services.\n+\n+\n+== Permissions required by operations\n+\n+.Creating the topic\n+\n+In order to create the topic the `Create` permission is required for the specific topic or on `Cluster:kafka-cluster`.\n+To display the details of the created topic the `Describe` permission is required for the specific topic.\n+\n+.Producing to the topic\n+\n+In order to produce to the topic the user needs `Describe` and `Write` permissions on the topic.\n+If topic has not yet been created, and autocreation is enabled, the permissions to create the topic are required.\n+\n+.Consuming from the topic\n+\n+In order to consume from the topic the user needs `Describe` and `Read` permissions on the topic.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg2NTgzNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528865834", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Two `resources` would be needed for matching, for example:\n          \n          \n            \n            Two `resources` are needed for matching. For example:", "author": "PaulRMellor", "createdAt": "2020-11-23T17:12:47Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n+\n+The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* Alter\n+* DescribeConfig\n+* AlterConfig\n+* ClusterAction\n+* IdempotentWrite\n+\n+.Resources\n+\n+The `resources` use pattern names to be used with pattern matching against the targeted resources when performing the permission check.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+A few examples:\n+\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by another one of the format `kafka-cluster:CLUSTER_NAME`, followed by comma, where the cluster name refers to the `metadata.name` in the Kafka CR.\n+\n+For example:\n+\n+    kafka-cluster:my-cluster,Topic:*\n+    kafka-cluster:*,Group:b_*\n+\n+When the `kafka-cluster` prefix is not present it is assumed to be `kafka-cluster:*`.\n+\n+When the resource is defined, a list of possible authorization scopes relevant to the resource should be added to the list of scopes.\n+Set whatever actions make sense for the targeted resource type.\n+\n+While you may add any `authorization scope` to any `resource`, only the scopes supported by the resource type will ever matter.\n+\n+.Policies\n+\n+The `policies` are used to target permissions to one or more accounts.\n+The targeting can refer to specific user or service accounts, it can refer to the realm roles or client roles, it can refer to user groups, and it can even use a JS rule and match client's IP address for example.\n+\n+Each policy can be given a name, and can be reused to target multiple permissions to multiple resources.\n+\n+.Permissions\n+\n+The `permissions` are the final step where you pull together the `policies`, `resources`, and `authorization scopes` to grant access to one or more users.\n+\n+Scope permissions should be used to grant fine-grained permissions to users.\n+\n+Each policy should be descriptively named in order to make it very clear what permissions it grants to which users.\n+\n+See xref:con-oauth-authorization-keycloak-example_str[the authorization example] to get a hands-on understanding of how to configure the permissions through Keycloak Authorization Services.\n+\n+\n+== Permissions required by operations\n+\n+.Creating the topic\n+\n+In order to create the topic the `Create` permission is required for the specific topic or on `Cluster:kafka-cluster`.\n+To display the details of the created topic the `Describe` permission is required for the specific topic.\n+\n+.Producing to the topic\n+\n+In order to produce to the topic the user needs `Describe` and `Write` permissions on the topic.\n+If topic has not yet been created, and autocreation is enabled, the permissions to create the topic are required.\n+\n+.Consuming from the topic\n+\n+In order to consume from the topic the user needs `Describe` and `Read` permissions on the topic.\n+Consuming from the topic normally relies on storing the consumer offsets in a consumer group.\n+That requires additional `Describe` and `Read` permissions on the consumer group.\n+\n+Two `resources` would be needed for matching, for example:", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg2NjE0OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528866149", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Two `resources` would be needed for matching, for example:\n          \n          \n            \n            Two `resources` are needed for matching. For example:", "author": "PaulRMellor", "createdAt": "2020-11-23T17:13:18Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n+\n+The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* Alter\n+* DescribeConfig\n+* AlterConfig\n+* ClusterAction\n+* IdempotentWrite\n+\n+.Resources\n+\n+The `resources` use pattern names to be used with pattern matching against the targeted resources when performing the permission check.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+A few examples:\n+\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by another one of the format `kafka-cluster:CLUSTER_NAME`, followed by comma, where the cluster name refers to the `metadata.name` in the Kafka CR.\n+\n+For example:\n+\n+    kafka-cluster:my-cluster,Topic:*\n+    kafka-cluster:*,Group:b_*\n+\n+When the `kafka-cluster` prefix is not present it is assumed to be `kafka-cluster:*`.\n+\n+When the resource is defined, a list of possible authorization scopes relevant to the resource should be added to the list of scopes.\n+Set whatever actions make sense for the targeted resource type.\n+\n+While you may add any `authorization scope` to any `resource`, only the scopes supported by the resource type will ever matter.\n+\n+.Policies\n+\n+The `policies` are used to target permissions to one or more accounts.\n+The targeting can refer to specific user or service accounts, it can refer to the realm roles or client roles, it can refer to user groups, and it can even use a JS rule and match client's IP address for example.\n+\n+Each policy can be given a name, and can be reused to target multiple permissions to multiple resources.\n+\n+.Permissions\n+\n+The `permissions` are the final step where you pull together the `policies`, `resources`, and `authorization scopes` to grant access to one or more users.\n+\n+Scope permissions should be used to grant fine-grained permissions to users.\n+\n+Each policy should be descriptively named in order to make it very clear what permissions it grants to which users.\n+\n+See xref:con-oauth-authorization-keycloak-example_str[the authorization example] to get a hands-on understanding of how to configure the permissions through Keycloak Authorization Services.\n+\n+\n+== Permissions required by operations\n+\n+.Creating the topic\n+\n+In order to create the topic the `Create` permission is required for the specific topic or on `Cluster:kafka-cluster`.\n+To display the details of the created topic the `Describe` permission is required for the specific topic.\n+\n+.Producing to the topic\n+\n+In order to produce to the topic the user needs `Describe` and `Write` permissions on the topic.\n+If topic has not yet been created, and autocreation is enabled, the permissions to create the topic are required.\n+\n+.Consuming from the topic\n+\n+In order to consume from the topic the user needs `Describe` and `Read` permissions on the topic.\n+Consuming from the topic normally relies on storing the consumer offsets in a consumer group.\n+That requires additional `Describe` and `Read` permissions on the consumer group.\n+\n+Two `resources` would be needed for matching, for example:\n+\n+    Topic:my-topic\n+    Group:my-group-*\n+\n+.Producing to the topic using an idempotent producer\n+\n+Besides needing the permissions for ordinary producing to the topic, an additional `IdempotentWrite` permission is required on the `Cluster` resource.\n+\n+Two `resources` would be needed for matching, for example:", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg2NjY4NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528866685", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            .Listing the topics\n          \n          \n            \n            .Listing topics", "author": "PaulRMellor", "createdAt": "2020-11-23T17:14:12Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n+\n+The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* Alter\n+* DescribeConfig\n+* AlterConfig\n+* ClusterAction\n+* IdempotentWrite\n+\n+.Resources\n+\n+The `resources` use pattern names to be used with pattern matching against the targeted resources when performing the permission check.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+A few examples:\n+\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by another one of the format `kafka-cluster:CLUSTER_NAME`, followed by comma, where the cluster name refers to the `metadata.name` in the Kafka CR.\n+\n+For example:\n+\n+    kafka-cluster:my-cluster,Topic:*\n+    kafka-cluster:*,Group:b_*\n+\n+When the `kafka-cluster` prefix is not present it is assumed to be `kafka-cluster:*`.\n+\n+When the resource is defined, a list of possible authorization scopes relevant to the resource should be added to the list of scopes.\n+Set whatever actions make sense for the targeted resource type.\n+\n+While you may add any `authorization scope` to any `resource`, only the scopes supported by the resource type will ever matter.\n+\n+.Policies\n+\n+The `policies` are used to target permissions to one or more accounts.\n+The targeting can refer to specific user or service accounts, it can refer to the realm roles or client roles, it can refer to user groups, and it can even use a JS rule and match client's IP address for example.\n+\n+Each policy can be given a name, and can be reused to target multiple permissions to multiple resources.\n+\n+.Permissions\n+\n+The `permissions` are the final step where you pull together the `policies`, `resources`, and `authorization scopes` to grant access to one or more users.\n+\n+Scope permissions should be used to grant fine-grained permissions to users.\n+\n+Each policy should be descriptively named in order to make it very clear what permissions it grants to which users.\n+\n+See xref:con-oauth-authorization-keycloak-example_str[the authorization example] to get a hands-on understanding of how to configure the permissions through Keycloak Authorization Services.\n+\n+\n+== Permissions required by operations\n+\n+.Creating the topic\n+\n+In order to create the topic the `Create` permission is required for the specific topic or on `Cluster:kafka-cluster`.\n+To display the details of the created topic the `Describe` permission is required for the specific topic.\n+\n+.Producing to the topic\n+\n+In order to produce to the topic the user needs `Describe` and `Write` permissions on the topic.\n+If topic has not yet been created, and autocreation is enabled, the permissions to create the topic are required.\n+\n+.Consuming from the topic\n+\n+In order to consume from the topic the user needs `Describe` and `Read` permissions on the topic.\n+Consuming from the topic normally relies on storing the consumer offsets in a consumer group.\n+That requires additional `Describe` and `Read` permissions on the consumer group.\n+\n+Two `resources` would be needed for matching, for example:\n+\n+    Topic:my-topic\n+    Group:my-group-*\n+\n+.Producing to the topic using an idempotent producer\n+\n+Besides needing the permissions for ordinary producing to the topic, an additional `IdempotentWrite` permission is required on the `Cluster` resource.\n+\n+Two `resources` would be needed for matching, for example:\n+\n+    Topic:my-topic\n+    Cluster:kafka-cluster\n+\n+.Listing the topics", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg2Njk0NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528866945", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            When listing the topics only the topics on which the user has `Describe` permission are returned.\n          \n          \n            \n            When listing topics, only the topics on which a user has `Describe` permission are returned.", "author": "PaulRMellor", "createdAt": "2020-11-23T17:14:35Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n+\n+The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* Alter\n+* DescribeConfig\n+* AlterConfig\n+* ClusterAction\n+* IdempotentWrite\n+\n+.Resources\n+\n+The `resources` use pattern names to be used with pattern matching against the targeted resources when performing the permission check.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+A few examples:\n+\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by another one of the format `kafka-cluster:CLUSTER_NAME`, followed by comma, where the cluster name refers to the `metadata.name` in the Kafka CR.\n+\n+For example:\n+\n+    kafka-cluster:my-cluster,Topic:*\n+    kafka-cluster:*,Group:b_*\n+\n+When the `kafka-cluster` prefix is not present it is assumed to be `kafka-cluster:*`.\n+\n+When the resource is defined, a list of possible authorization scopes relevant to the resource should be added to the list of scopes.\n+Set whatever actions make sense for the targeted resource type.\n+\n+While you may add any `authorization scope` to any `resource`, only the scopes supported by the resource type will ever matter.\n+\n+.Policies\n+\n+The `policies` are used to target permissions to one or more accounts.\n+The targeting can refer to specific user or service accounts, it can refer to the realm roles or client roles, it can refer to user groups, and it can even use a JS rule and match client's IP address for example.\n+\n+Each policy can be given a name, and can be reused to target multiple permissions to multiple resources.\n+\n+.Permissions\n+\n+The `permissions` are the final step where you pull together the `policies`, `resources`, and `authorization scopes` to grant access to one or more users.\n+\n+Scope permissions should be used to grant fine-grained permissions to users.\n+\n+Each policy should be descriptively named in order to make it very clear what permissions it grants to which users.\n+\n+See xref:con-oauth-authorization-keycloak-example_str[the authorization example] to get a hands-on understanding of how to configure the permissions through Keycloak Authorization Services.\n+\n+\n+== Permissions required by operations\n+\n+.Creating the topic\n+\n+In order to create the topic the `Create` permission is required for the specific topic or on `Cluster:kafka-cluster`.\n+To display the details of the created topic the `Describe` permission is required for the specific topic.\n+\n+.Producing to the topic\n+\n+In order to produce to the topic the user needs `Describe` and `Write` permissions on the topic.\n+If topic has not yet been created, and autocreation is enabled, the permissions to create the topic are required.\n+\n+.Consuming from the topic\n+\n+In order to consume from the topic the user needs `Describe` and `Read` permissions on the topic.\n+Consuming from the topic normally relies on storing the consumer offsets in a consumer group.\n+That requires additional `Describe` and `Read` permissions on the consumer group.\n+\n+Two `resources` would be needed for matching, for example:\n+\n+    Topic:my-topic\n+    Group:my-group-*\n+\n+.Producing to the topic using an idempotent producer\n+\n+Besides needing the permissions for ordinary producing to the topic, an additional `IdempotentWrite` permission is required on the `Cluster` resource.\n+\n+Two `resources` would be needed for matching, for example:\n+\n+    Topic:my-topic\n+    Cluster:kafka-cluster\n+\n+.Listing the topics\n+\n+When listing the topics only the topics on which the user has `Describe` permission are returned.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg2NzUwMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528867500", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The `DescribeConfigs` permission is required on the topic in order to get information like partitions, replicas, leaders ...\n          \n          \n            \n            The `DescribeConfigs` permission is required on the topic to be able to retrieve information on partitions, replicas, and so on.", "author": "PaulRMellor", "createdAt": "2020-11-23T17:15:23Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n+\n+The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* Alter\n+* DescribeConfig\n+* AlterConfig\n+* ClusterAction\n+* IdempotentWrite\n+\n+.Resources\n+\n+The `resources` use pattern names to be used with pattern matching against the targeted resources when performing the permission check.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+A few examples:\n+\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by another one of the format `kafka-cluster:CLUSTER_NAME`, followed by comma, where the cluster name refers to the `metadata.name` in the Kafka CR.\n+\n+For example:\n+\n+    kafka-cluster:my-cluster,Topic:*\n+    kafka-cluster:*,Group:b_*\n+\n+When the `kafka-cluster` prefix is not present it is assumed to be `kafka-cluster:*`.\n+\n+When the resource is defined, a list of possible authorization scopes relevant to the resource should be added to the list of scopes.\n+Set whatever actions make sense for the targeted resource type.\n+\n+While you may add any `authorization scope` to any `resource`, only the scopes supported by the resource type will ever matter.\n+\n+.Policies\n+\n+The `policies` are used to target permissions to one or more accounts.\n+The targeting can refer to specific user or service accounts, it can refer to the realm roles or client roles, it can refer to user groups, and it can even use a JS rule and match client's IP address for example.\n+\n+Each policy can be given a name, and can be reused to target multiple permissions to multiple resources.\n+\n+.Permissions\n+\n+The `permissions` are the final step where you pull together the `policies`, `resources`, and `authorization scopes` to grant access to one or more users.\n+\n+Scope permissions should be used to grant fine-grained permissions to users.\n+\n+Each policy should be descriptively named in order to make it very clear what permissions it grants to which users.\n+\n+See xref:con-oauth-authorization-keycloak-example_str[the authorization example] to get a hands-on understanding of how to configure the permissions through Keycloak Authorization Services.\n+\n+\n+== Permissions required by operations\n+\n+.Creating the topic\n+\n+In order to create the topic the `Create` permission is required for the specific topic or on `Cluster:kafka-cluster`.\n+To display the details of the created topic the `Describe` permission is required for the specific topic.\n+\n+.Producing to the topic\n+\n+In order to produce to the topic the user needs `Describe` and `Write` permissions on the topic.\n+If topic has not yet been created, and autocreation is enabled, the permissions to create the topic are required.\n+\n+.Consuming from the topic\n+\n+In order to consume from the topic the user needs `Describe` and `Read` permissions on the topic.\n+Consuming from the topic normally relies on storing the consumer offsets in a consumer group.\n+That requires additional `Describe` and `Read` permissions on the consumer group.\n+\n+Two `resources` would be needed for matching, for example:\n+\n+    Topic:my-topic\n+    Group:my-group-*\n+\n+.Producing to the topic using an idempotent producer\n+\n+Besides needing the permissions for ordinary producing to the topic, an additional `IdempotentWrite` permission is required on the `Cluster` resource.\n+\n+Two `resources` would be needed for matching, for example:\n+\n+    Topic:my-topic\n+    Cluster:kafka-cluster\n+\n+.Listing the topics\n+\n+When listing the topics only the topics on which the user has `Describe` permission are returned.\n+\n+.Displaying topic details\n+\n+The `DescribeConfigs` permission is required on the topic in order to get information like partitions, replicas, leaders ...", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg2Nzc4Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528867787", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            When listing the consumer groups only the groups on which the user has `Describe` permissions are returned.\n          \n          \n            \n            When listing consumer groups, only the groups on which the user has `Describe` permissions are returned.", "author": "PaulRMellor", "createdAt": "2020-11-23T17:15:49Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n+\n+The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* Alter\n+* DescribeConfig\n+* AlterConfig\n+* ClusterAction\n+* IdempotentWrite\n+\n+.Resources\n+\n+The `resources` use pattern names to be used with pattern matching against the targeted resources when performing the permission check.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+A few examples:\n+\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by another one of the format `kafka-cluster:CLUSTER_NAME`, followed by comma, where the cluster name refers to the `metadata.name` in the Kafka CR.\n+\n+For example:\n+\n+    kafka-cluster:my-cluster,Topic:*\n+    kafka-cluster:*,Group:b_*\n+\n+When the `kafka-cluster` prefix is not present it is assumed to be `kafka-cluster:*`.\n+\n+When the resource is defined, a list of possible authorization scopes relevant to the resource should be added to the list of scopes.\n+Set whatever actions make sense for the targeted resource type.\n+\n+While you may add any `authorization scope` to any `resource`, only the scopes supported by the resource type will ever matter.\n+\n+.Policies\n+\n+The `policies` are used to target permissions to one or more accounts.\n+The targeting can refer to specific user or service accounts, it can refer to the realm roles or client roles, it can refer to user groups, and it can even use a JS rule and match client's IP address for example.\n+\n+Each policy can be given a name, and can be reused to target multiple permissions to multiple resources.\n+\n+.Permissions\n+\n+The `permissions` are the final step where you pull together the `policies`, `resources`, and `authorization scopes` to grant access to one or more users.\n+\n+Scope permissions should be used to grant fine-grained permissions to users.\n+\n+Each policy should be descriptively named in order to make it very clear what permissions it grants to which users.\n+\n+See xref:con-oauth-authorization-keycloak-example_str[the authorization example] to get a hands-on understanding of how to configure the permissions through Keycloak Authorization Services.\n+\n+\n+== Permissions required by operations\n+\n+.Creating the topic\n+\n+In order to create the topic the `Create` permission is required for the specific topic or on `Cluster:kafka-cluster`.\n+To display the details of the created topic the `Describe` permission is required for the specific topic.\n+\n+.Producing to the topic\n+\n+In order to produce to the topic the user needs `Describe` and `Write` permissions on the topic.\n+If topic has not yet been created, and autocreation is enabled, the permissions to create the topic are required.\n+\n+.Consuming from the topic\n+\n+In order to consume from the topic the user needs `Describe` and `Read` permissions on the topic.\n+Consuming from the topic normally relies on storing the consumer offsets in a consumer group.\n+That requires additional `Describe` and `Read` permissions on the consumer group.\n+\n+Two `resources` would be needed for matching, for example:\n+\n+    Topic:my-topic\n+    Group:my-group-*\n+\n+.Producing to the topic using an idempotent producer\n+\n+Besides needing the permissions for ordinary producing to the topic, an additional `IdempotentWrite` permission is required on the `Cluster` resource.\n+\n+Two `resources` would be needed for matching, for example:\n+\n+    Topic:my-topic\n+    Cluster:kafka-cluster\n+\n+.Listing the topics\n+\n+When listing the topics only the topics on which the user has `Describe` permission are returned.\n+\n+.Displaying topic details\n+\n+The `DescribeConfigs` permission is required on the topic in order to get information like partitions, replicas, leaders ...\n+\n+.Listing the consumer groups\n+\n+When listing the consumer groups only the groups on which the user has `Describe` permissions are returned.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg2Nzg2Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528867862", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            .Listing the consumer groups\n          \n          \n            \n            .Listing consumer groups", "author": "PaulRMellor", "createdAt": "2020-11-23T17:15:57Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n+\n+The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* Alter\n+* DescribeConfig\n+* AlterConfig\n+* ClusterAction\n+* IdempotentWrite\n+\n+.Resources\n+\n+The `resources` use pattern names to be used with pattern matching against the targeted resources when performing the permission check.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+A few examples:\n+\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by another one of the format `kafka-cluster:CLUSTER_NAME`, followed by comma, where the cluster name refers to the `metadata.name` in the Kafka CR.\n+\n+For example:\n+\n+    kafka-cluster:my-cluster,Topic:*\n+    kafka-cluster:*,Group:b_*\n+\n+When the `kafka-cluster` prefix is not present it is assumed to be `kafka-cluster:*`.\n+\n+When the resource is defined, a list of possible authorization scopes relevant to the resource should be added to the list of scopes.\n+Set whatever actions make sense for the targeted resource type.\n+\n+While you may add any `authorization scope` to any `resource`, only the scopes supported by the resource type will ever matter.\n+\n+.Policies\n+\n+The `policies` are used to target permissions to one or more accounts.\n+The targeting can refer to specific user or service accounts, it can refer to the realm roles or client roles, it can refer to user groups, and it can even use a JS rule and match client's IP address for example.\n+\n+Each policy can be given a name, and can be reused to target multiple permissions to multiple resources.\n+\n+.Permissions\n+\n+The `permissions` are the final step where you pull together the `policies`, `resources`, and `authorization scopes` to grant access to one or more users.\n+\n+Scope permissions should be used to grant fine-grained permissions to users.\n+\n+Each policy should be descriptively named in order to make it very clear what permissions it grants to which users.\n+\n+See xref:con-oauth-authorization-keycloak-example_str[the authorization example] to get a hands-on understanding of how to configure the permissions through Keycloak Authorization Services.\n+\n+\n+== Permissions required by operations\n+\n+.Creating the topic\n+\n+In order to create the topic the `Create` permission is required for the specific topic or on `Cluster:kafka-cluster`.\n+To display the details of the created topic the `Describe` permission is required for the specific topic.\n+\n+.Producing to the topic\n+\n+In order to produce to the topic the user needs `Describe` and `Write` permissions on the topic.\n+If topic has not yet been created, and autocreation is enabled, the permissions to create the topic are required.\n+\n+.Consuming from the topic\n+\n+In order to consume from the topic the user needs `Describe` and `Read` permissions on the topic.\n+Consuming from the topic normally relies on storing the consumer offsets in a consumer group.\n+That requires additional `Describe` and `Read` permissions on the consumer group.\n+\n+Two `resources` would be needed for matching, for example:\n+\n+    Topic:my-topic\n+    Group:my-group-*\n+\n+.Producing to the topic using an idempotent producer\n+\n+Besides needing the permissions for ordinary producing to the topic, an additional `IdempotentWrite` permission is required on the `Cluster` resource.\n+\n+Two `resources` would be needed for matching, for example:\n+\n+    Topic:my-topic\n+    Cluster:kafka-cluster\n+\n+.Listing the topics\n+\n+When listing the topics only the topics on which the user has `Describe` permission are returned.\n+\n+.Displaying topic details\n+\n+The `DescribeConfigs` permission is required on the topic in order to get information like partitions, replicas, leaders ...\n+\n+.Listing the consumer groups", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg2ODAyNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528868025", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Alternatively, if the user has `Describe` permission on the `Cluster:kafka-cluster` all the consumer groups are returned.\n          \n          \n            \n            Alternatively, if the user has `Describe` permission on the `Cluster:kafka-cluster`, all the consumer groups are returned.", "author": "PaulRMellor", "createdAt": "2020-11-23T17:16:14Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n+\n+The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* Alter\n+* DescribeConfig\n+* AlterConfig\n+* ClusterAction\n+* IdempotentWrite\n+\n+.Resources\n+\n+The `resources` use pattern names to be used with pattern matching against the targeted resources when performing the permission check.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+A few examples:\n+\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by another one of the format `kafka-cluster:CLUSTER_NAME`, followed by comma, where the cluster name refers to the `metadata.name` in the Kafka CR.\n+\n+For example:\n+\n+    kafka-cluster:my-cluster,Topic:*\n+    kafka-cluster:*,Group:b_*\n+\n+When the `kafka-cluster` prefix is not present it is assumed to be `kafka-cluster:*`.\n+\n+When the resource is defined, a list of possible authorization scopes relevant to the resource should be added to the list of scopes.\n+Set whatever actions make sense for the targeted resource type.\n+\n+While you may add any `authorization scope` to any `resource`, only the scopes supported by the resource type will ever matter.\n+\n+.Policies\n+\n+The `policies` are used to target permissions to one or more accounts.\n+The targeting can refer to specific user or service accounts, it can refer to the realm roles or client roles, it can refer to user groups, and it can even use a JS rule and match client's IP address for example.\n+\n+Each policy can be given a name, and can be reused to target multiple permissions to multiple resources.\n+\n+.Permissions\n+\n+The `permissions` are the final step where you pull together the `policies`, `resources`, and `authorization scopes` to grant access to one or more users.\n+\n+Scope permissions should be used to grant fine-grained permissions to users.\n+\n+Each policy should be descriptively named in order to make it very clear what permissions it grants to which users.\n+\n+See xref:con-oauth-authorization-keycloak-example_str[the authorization example] to get a hands-on understanding of how to configure the permissions through Keycloak Authorization Services.\n+\n+\n+== Permissions required by operations\n+\n+.Creating the topic\n+\n+In order to create the topic the `Create` permission is required for the specific topic or on `Cluster:kafka-cluster`.\n+To display the details of the created topic the `Describe` permission is required for the specific topic.\n+\n+.Producing to the topic\n+\n+In order to produce to the topic the user needs `Describe` and `Write` permissions on the topic.\n+If topic has not yet been created, and autocreation is enabled, the permissions to create the topic are required.\n+\n+.Consuming from the topic\n+\n+In order to consume from the topic the user needs `Describe` and `Read` permissions on the topic.\n+Consuming from the topic normally relies on storing the consumer offsets in a consumer group.\n+That requires additional `Describe` and `Read` permissions on the consumer group.\n+\n+Two `resources` would be needed for matching, for example:\n+\n+    Topic:my-topic\n+    Group:my-group-*\n+\n+.Producing to the topic using an idempotent producer\n+\n+Besides needing the permissions for ordinary producing to the topic, an additional `IdempotentWrite` permission is required on the `Cluster` resource.\n+\n+Two `resources` would be needed for matching, for example:\n+\n+    Topic:my-topic\n+    Cluster:kafka-cluster\n+\n+.Listing the topics\n+\n+When listing the topics only the topics on which the user has `Describe` permission are returned.\n+\n+.Displaying topic details\n+\n+The `DescribeConfigs` permission is required on the topic in order to get information like partitions, replicas, leaders ...\n+\n+.Listing the consumer groups\n+\n+When listing the consumer groups only the groups on which the user has `Describe` permissions are returned.\n+Alternatively, if the user has `Describe` permission on the `Cluster:kafka-cluster` all the consumer groups are returned.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg2ODUwNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528868507", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Using `kafka-configs.sh` to get the broker configuration requires `Describe` permission on the `Cluster:kafka-cluster`.\n          \n          \n            \n            To be able to use `kafka-configs.sh` to get the broker configuration, `Describe` permission is required on the `Cluster:kafka-cluster`.", "author": "PaulRMellor", "createdAt": "2020-11-23T17:16:58Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n+\n+The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* Alter\n+* DescribeConfig\n+* AlterConfig\n+* ClusterAction\n+* IdempotentWrite\n+\n+.Resources\n+\n+The `resources` use pattern names to be used with pattern matching against the targeted resources when performing the permission check.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+A few examples:\n+\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by another one of the format `kafka-cluster:CLUSTER_NAME`, followed by comma, where the cluster name refers to the `metadata.name` in the Kafka CR.\n+\n+For example:\n+\n+    kafka-cluster:my-cluster,Topic:*\n+    kafka-cluster:*,Group:b_*\n+\n+When the `kafka-cluster` prefix is not present it is assumed to be `kafka-cluster:*`.\n+\n+When the resource is defined, a list of possible authorization scopes relevant to the resource should be added to the list of scopes.\n+Set whatever actions make sense for the targeted resource type.\n+\n+While you may add any `authorization scope` to any `resource`, only the scopes supported by the resource type will ever matter.\n+\n+.Policies\n+\n+The `policies` are used to target permissions to one or more accounts.\n+The targeting can refer to specific user or service accounts, it can refer to the realm roles or client roles, it can refer to user groups, and it can even use a JS rule and match client's IP address for example.\n+\n+Each policy can be given a name, and can be reused to target multiple permissions to multiple resources.\n+\n+.Permissions\n+\n+The `permissions` are the final step where you pull together the `policies`, `resources`, and `authorization scopes` to grant access to one or more users.\n+\n+Scope permissions should be used to grant fine-grained permissions to users.\n+\n+Each policy should be descriptively named in order to make it very clear what permissions it grants to which users.\n+\n+See xref:con-oauth-authorization-keycloak-example_str[the authorization example] to get a hands-on understanding of how to configure the permissions through Keycloak Authorization Services.\n+\n+\n+== Permissions required by operations\n+\n+.Creating the topic\n+\n+In order to create the topic the `Create` permission is required for the specific topic or on `Cluster:kafka-cluster`.\n+To display the details of the created topic the `Describe` permission is required for the specific topic.\n+\n+.Producing to the topic\n+\n+In order to produce to the topic the user needs `Describe` and `Write` permissions on the topic.\n+If topic has not yet been created, and autocreation is enabled, the permissions to create the topic are required.\n+\n+.Consuming from the topic\n+\n+In order to consume from the topic the user needs `Describe` and `Read` permissions on the topic.\n+Consuming from the topic normally relies on storing the consumer offsets in a consumer group.\n+That requires additional `Describe` and `Read` permissions on the consumer group.\n+\n+Two `resources` would be needed for matching, for example:\n+\n+    Topic:my-topic\n+    Group:my-group-*\n+\n+.Producing to the topic using an idempotent producer\n+\n+Besides needing the permissions for ordinary producing to the topic, an additional `IdempotentWrite` permission is required on the `Cluster` resource.\n+\n+Two `resources` would be needed for matching, for example:\n+\n+    Topic:my-topic\n+    Cluster:kafka-cluster\n+\n+.Listing the topics\n+\n+When listing the topics only the topics on which the user has `Describe` permission are returned.\n+\n+.Displaying topic details\n+\n+The `DescribeConfigs` permission is required on the topic in order to get information like partitions, replicas, leaders ...\n+\n+.Listing the consumer groups\n+\n+When listing the consumer groups only the groups on which the user has `Describe` permissions are returned.\n+Alternatively, if the user has `Describe` permission on the `Cluster:kafka-cluster` all the consumer groups are returned.\n+\n+.Getting the Kafka broker configuration\n+\n+Using `kafka-configs.sh` to get the broker configuration requires `Describe` permission on the `Cluster:kafka-cluster`.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg2ODkxNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528868916", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            .Describing the consumer groups\n          \n          \n            \n            .Describing consumer groups", "author": "PaulRMellor", "createdAt": "2020-11-23T17:17:33Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n+\n+The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* Alter\n+* DescribeConfig\n+* AlterConfig\n+* ClusterAction\n+* IdempotentWrite\n+\n+.Resources\n+\n+The `resources` use pattern names to be used with pattern matching against the targeted resources when performing the permission check.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+A few examples:\n+\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by another one of the format `kafka-cluster:CLUSTER_NAME`, followed by comma, where the cluster name refers to the `metadata.name` in the Kafka CR.\n+\n+For example:\n+\n+    kafka-cluster:my-cluster,Topic:*\n+    kafka-cluster:*,Group:b_*\n+\n+When the `kafka-cluster` prefix is not present it is assumed to be `kafka-cluster:*`.\n+\n+When the resource is defined, a list of possible authorization scopes relevant to the resource should be added to the list of scopes.\n+Set whatever actions make sense for the targeted resource type.\n+\n+While you may add any `authorization scope` to any `resource`, only the scopes supported by the resource type will ever matter.\n+\n+.Policies\n+\n+The `policies` are used to target permissions to one or more accounts.\n+The targeting can refer to specific user or service accounts, it can refer to the realm roles or client roles, it can refer to user groups, and it can even use a JS rule and match client's IP address for example.\n+\n+Each policy can be given a name, and can be reused to target multiple permissions to multiple resources.\n+\n+.Permissions\n+\n+The `permissions` are the final step where you pull together the `policies`, `resources`, and `authorization scopes` to grant access to one or more users.\n+\n+Scope permissions should be used to grant fine-grained permissions to users.\n+\n+Each policy should be descriptively named in order to make it very clear what permissions it grants to which users.\n+\n+See xref:con-oauth-authorization-keycloak-example_str[the authorization example] to get a hands-on understanding of how to configure the permissions through Keycloak Authorization Services.\n+\n+\n+== Permissions required by operations\n+\n+.Creating the topic\n+\n+In order to create the topic the `Create` permission is required for the specific topic or on `Cluster:kafka-cluster`.\n+To display the details of the created topic the `Describe` permission is required for the specific topic.\n+\n+.Producing to the topic\n+\n+In order to produce to the topic the user needs `Describe` and `Write` permissions on the topic.\n+If topic has not yet been created, and autocreation is enabled, the permissions to create the topic are required.\n+\n+.Consuming from the topic\n+\n+In order to consume from the topic the user needs `Describe` and `Read` permissions on the topic.\n+Consuming from the topic normally relies on storing the consumer offsets in a consumer group.\n+That requires additional `Describe` and `Read` permissions on the consumer group.\n+\n+Two `resources` would be needed for matching, for example:\n+\n+    Topic:my-topic\n+    Group:my-group-*\n+\n+.Producing to the topic using an idempotent producer\n+\n+Besides needing the permissions for ordinary producing to the topic, an additional `IdempotentWrite` permission is required on the `Cluster` resource.\n+\n+Two `resources` would be needed for matching, for example:\n+\n+    Topic:my-topic\n+    Cluster:kafka-cluster\n+\n+.Listing the topics\n+\n+When listing the topics only the topics on which the user has `Describe` permission are returned.\n+\n+.Displaying topic details\n+\n+The `DescribeConfigs` permission is required on the topic in order to get information like partitions, replicas, leaders ...\n+\n+.Listing the consumer groups\n+\n+When listing the consumer groups only the groups on which the user has `Describe` permissions are returned.\n+Alternatively, if the user has `Describe` permission on the `Cluster:kafka-cluster` all the consumer groups are returned.\n+\n+.Getting the Kafka broker configuration\n+\n+Using `kafka-configs.sh` to get the broker configuration requires `Describe` permission on the `Cluster:kafka-cluster`.\n+\n+.Describing the consumer groups", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg2OTQyNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528869425", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Using `kafka-consumer-groups.sh` to get the detailed information about all the consumer groups requires `Describe` permission on the `Cluster:kafka-cluster`.\n          \n          \n            \n            To be able to `kafka-consumer-groups.sh` to get detailed information about all consumer groups, `Describe` permission is required on the `Cluster:kafka-cluster`.", "author": "PaulRMellor", "createdAt": "2020-11-23T17:18:24Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,199 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Manage policies and permissions in Keycloak Authorization Services\n+\n+== Kafka Authorization Model\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and permissions available for each type.\n+Whenever some action is performed by the Kafka client, one or more permissions are checked by the broker (depending on the action performed) using the configured authorizer.\n+\n+There are five resource types: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+And these are the different permissions for each resource type:\n+\n+Topic:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* DescribeConfigs\n+* Alter\n+* AlterConfigs\n+\n+Group:\n+\n+* Read\n+* Describe\n+* Delete\n+\n+Cluster:\n+\n+*  Create\n+*  Describe\n+*  Alter\n+*  DescribeConfigs\n+*  AlterConfigs\n+*  IdempotentWrite\n+*  ClusterAction\n+\n+TransactionalId:\n+\n+*  Describe\n+*  Write\n+\n+DelegationToken:\n+\n+* Describe\n+\n+\n+== Keycloak Authorization Services Model\n+\n+There are four concepts used in Keycloak Authorization Services to grant permissions: `resources`, `authorization scopes`, `policies`, and `permissions`.\n+\n+`Resources` are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with some prefix.\n+The resource definition has a set of available `authorization scopes` associated with it. These represent a set of all actions that can be permitted.\n+Often, only a subset of these actions is actually permitted.\n+\n+`Authorization scopes` is simply a set of all available actions on all the different resource types. When defining a new `resource` the `scopes` added there are taken from this set of all scopes.\n+\n+`Policies` are rules that can use various criteria to match a list of accounts. They can match service accounts based on clientId, they can match user accounts based on username, or group, or roles.\n+\n+Finally, `Permissions` are used to grant a subset of `authorization scopes` on the specific `resource` definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+In order to grant Kafka permissions to users or service accounts you have to use the Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker - typically this client has `kafka` as its clientId.\n+\n+This client needs to have `Authorization Enabled` option activated.\n+\n+All the permissions exist within the scope of this OAuth client, which means that if you have different Kafka clusters configured with different OAuth client ids they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client authenticates using `SASL_OAUTHBEARER` the `KeycloakRBACAuthorizer` retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Authorization scopes\n+\n+Typically the initial configuration involves uploading the authorization scopes which creates a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, the authorization scopes can be added manually, but make sure to not introduce typos.\n+\n+The `authorization scopes` should simply contain all the possible Kafka permissions regardless of the resource type:\n+\n+* Create\n+* Write\n+* Read\n+* Delete\n+* Describe\n+* Alter\n+* DescribeConfig\n+* AlterConfig\n+* ClusterAction\n+* IdempotentWrite\n+\n+.Resources\n+\n+The `resources` use pattern names to be used with pattern matching against the targeted resources when performing the permission check.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+A few examples:\n+\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by another one of the format `kafka-cluster:CLUSTER_NAME`, followed by comma, where the cluster name refers to the `metadata.name` in the Kafka CR.\n+\n+For example:\n+\n+    kafka-cluster:my-cluster,Topic:*\n+    kafka-cluster:*,Group:b_*\n+\n+When the `kafka-cluster` prefix is not present it is assumed to be `kafka-cluster:*`.\n+\n+When the resource is defined, a list of possible authorization scopes relevant to the resource should be added to the list of scopes.\n+Set whatever actions make sense for the targeted resource type.\n+\n+While you may add any `authorization scope` to any `resource`, only the scopes supported by the resource type will ever matter.\n+\n+.Policies\n+\n+The `policies` are used to target permissions to one or more accounts.\n+The targeting can refer to specific user or service accounts, it can refer to the realm roles or client roles, it can refer to user groups, and it can even use a JS rule and match client's IP address for example.\n+\n+Each policy can be given a name, and can be reused to target multiple permissions to multiple resources.\n+\n+.Permissions\n+\n+The `permissions` are the final step where you pull together the `policies`, `resources`, and `authorization scopes` to grant access to one or more users.\n+\n+Scope permissions should be used to grant fine-grained permissions to users.\n+\n+Each policy should be descriptively named in order to make it very clear what permissions it grants to which users.\n+\n+See xref:con-oauth-authorization-keycloak-example_str[the authorization example] to get a hands-on understanding of how to configure the permissions through Keycloak Authorization Services.\n+\n+\n+== Permissions required by operations\n+\n+.Creating the topic\n+\n+In order to create the topic the `Create` permission is required for the specific topic or on `Cluster:kafka-cluster`.\n+To display the details of the created topic the `Describe` permission is required for the specific topic.\n+\n+.Producing to the topic\n+\n+In order to produce to the topic the user needs `Describe` and `Write` permissions on the topic.\n+If topic has not yet been created, and autocreation is enabled, the permissions to create the topic are required.\n+\n+.Consuming from the topic\n+\n+In order to consume from the topic the user needs `Describe` and `Read` permissions on the topic.\n+Consuming from the topic normally relies on storing the consumer offsets in a consumer group.\n+That requires additional `Describe` and `Read` permissions on the consumer group.\n+\n+Two `resources` would be needed for matching, for example:\n+\n+    Topic:my-topic\n+    Group:my-group-*\n+\n+.Producing to the topic using an idempotent producer\n+\n+Besides needing the permissions for ordinary producing to the topic, an additional `IdempotentWrite` permission is required on the `Cluster` resource.\n+\n+Two `resources` would be needed for matching, for example:\n+\n+    Topic:my-topic\n+    Cluster:kafka-cluster\n+\n+.Listing the topics\n+\n+When listing the topics only the topics on which the user has `Describe` permission are returned.\n+\n+.Displaying topic details\n+\n+The `DescribeConfigs` permission is required on the topic in order to get information like partitions, replicas, leaders ...\n+\n+.Listing the consumer groups\n+\n+When listing the consumer groups only the groups on which the user has `Describe` permissions are returned.\n+Alternatively, if the user has `Describe` permission on the `Cluster:kafka-cluster` all the consumer groups are returned.\n+\n+.Getting the Kafka broker configuration\n+\n+Using `kafka-configs.sh` to get the broker configuration requires `Describe` permission on the `Cluster:kafka-cluster`.\n+\n+.Describing the consumer groups\n+\n+Using `kafka-consumer-groups.sh` to get the detailed information about all the consumer groups requires `Describe` permission on the `Cluster:kafka-cluster`.", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3MjAwOA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528872008", "bodyText": "Can we introduce what we're trying to achieve with this example? And how each section helps.", "author": "PaulRMellor", "createdAt": "2020-11-23T17:22:09Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example", "originalCommit": "7ea78555314cba3a00a177f43668fd505efd7e3e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkxNjk5MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528916990", "bodyText": "Hmmm ... It's an end to end example that demonstrates how to configure permissions. It's actually the more important addition in terms of helping users to use Keycloak Authorization Services for authorization. It is a 'port' of examples/README-authz.md from Docker to Strimzi and was requested by users. As such it is written in a different style as the regular documentations.\nI don't know how to address the sections part but the introduction could be something like:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            = Keycloak Authorization Services Example\n          \n          \n            \n            = Keycloak Authorization Services Example\n          \n          \n            \n            \n          \n          \n            \n            This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n          \n          \n            \n            The example starts by deploying the Keycloak server with pre-configured realm, requiring no additional configuration.\n          \n          \n            \n            We deploy the Kafka cluster configured to use one of the pre-configured realms.\n          \n          \n            \n            We connect to the Keycloak Admin Console and demonstrate the sections of the UI where authorizations rules are configured.\n          \n          \n            \n            We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.", "author": "mstruk", "createdAt": "2020-11-23T18:38:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3MjAwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI3NDA1Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529274056", "bodyText": "Great. Looks good Marko. Couple of things: with pre-configured realms? And we use user interface rather than UI. \ud83d\udc4d", "author": "PaulRMellor", "createdAt": "2020-11-24T08:06:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3MjAwOA=="}], "type": "inlineReview"}, {"oid": "94f4cf4c1ed9a3680a51bc0936ed473c120bf683", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/94f4cf4c1ed9a3680a51bc0936ed473c120bf683", "message": "Apply suggestions from code review\n\nCo-authored-by: PaulRMellor <47596553+PaulRMellor@users.noreply.github.com>\nSigned-off-by: Marko Strukelj <marko.strukelj@gmail.com>", "committedDate": "2020-11-23T17:41:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkwMDgyNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528900826", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Here are a few examples which permissions are required when performing some operations on Kafka.\n          \n          \n            \n            The following  examples demonstrate the permissions required for performing common operations on Kafka.", "author": "PaulRMellor", "createdAt": "2020-11-23T18:09:26Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,204 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Managing policies and permissions in Keycloak Authorization Services\n+\n+== Kafka authorization model for resources\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and the permissions available for each type.\n+When an action is performed by a Kafka client on a broker, the broker uses a configured authorizer to check permissions, depending on the action performed and the resource type.\n+\n+Kafka has five resource types for controlling access: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+Each resource type has different permissions:\n+\n+Topic:\n+\n+* `Create`\n+* `Write`\n+* `Read`\n+* `Delete`\n+* `Describe`\n+* `DescribeConfigs`\n+* `Alter`\n+* `AlterConfigs`\n+\n+Group:\n+\n+* `Read`\n+* `Describe`\n+* `Delete`\n+\n+Cluster:\n+\n+*  `Create`\n+*  `Describe`\n+*  `Alter`\n+*  `DescribeConfigs`\n+*  `AlterConfigs`\n+*  `IdempotentWrite`\n+*  `ClusterAction`\n+\n+TransactionalId:\n+\n+*  `Describe`\n+*  `Write`\n+\n+DelegationToken:\n+\n+* `Describe`\n+\n+== Keycloak Authorization Services model for managing permissions\n+\n+Keycloak Authorization Services use four concepts to define and grant permissions: _resources_, _authorization scopes_, _policies_, and _permissions_.\n+\n+Resources:: Resources are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with the same prefix.\n+The resource definition has a set of available authorization scopes associated with it, which represent a set of all actions available on the particular resource.\n+Often, only a subset of these actions is actually permitted.\n+\n+Authorization scopes:: Authorization scopes is simply a set of all available actions on all the different resource types. When defining a new resource,  scopes are added from the set of all scopes.\n+\n+Policies:: Policies are rules that use criteria to match a list of accounts. Policies can match service accounts based on client id or roles, or user accounts based on username, groups, or roles.\n+\n+Permissions:: Permissions grant a subset of authorization scopes on a specific resource definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+Use Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker to grant Kafka permissions to users or service accounts. Typically, the OAuth client has `kafka` as its client id.\n+\n+The OAuth 2.0 client definition must have the _Authorization Enabled_ option activated.\n+\n+All permissions exist within the scope of this OAuth 2.0 client, which means that if you have different Kafka clusters configured with different OAuth 2.0 client IDs they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client use the _SASL OAUTHBEARER_ mechanism, the Keycloak authorizer (`KeycloakRBACAuthorizer`) retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Introducing authorization scopes\n+\n+Typically, an initial configuration involves uploading the authorization scopes to create a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, you can add authorization scopes manually.\n+\n+The authorization scopes should contain all the possible Kafka permissions regardless of the resource type:\n+\n+* `Create`\n+* `Write`\n+* `Read`\n+* `Delete`\n+* `Describe`\n+* `Alter`\n+* `DescribeConfig`\n+* `AlterConfig`\n+* `ClusterAction`\n+* `IdempotentWrite`\n+\n+.Defining resource patterns for permission checks\n+\n+The resources use pattern names for pattern matching against the targeted resources when performing permission checks.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+.Example patterns for resources\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by `kafka-cluster:CLUSTER_NAME` followed by a comma, where the cluster name refers to the `metadata.name` in the Kafka custom resource.\n+\n+.Example patterns for resources with cluster prefix\n+    kafka-cluster:my-cluster,Topic:*\n+    kafka-cluster:*,Group:b_*\n+\n+When the `kafka-cluster` prefix is not present it is assumed to be `kafka-cluster:*`.\n+\n+When defining a resource, you can associate a list of possible authorization scopes relevant to the resource.\n+Set whatever actions make sense for the targeted resource type.\n+\n+While you may add any authorization scope to any resource, only the scopes supported by the resource type are considered for access control.\n+\n+.Policies\n+\n+Policies are used to target permissions to one or more accounts.\n+Targeting can refer to:\n+* Specific user or service accounts\n+* Realm roles or client roles\n+* User groups\n+* JS rule to match a client IP address\n+\n+A policy is given a unique name, and can be reused to target multiple permissions to multiple resources.\n+\n+.Defining permissions based on scopes, resources and policies \n+\n+Use fine-grained permissions to pull together the policies, resources, and authorization scopes that grant access to users.\n+\n+\n+The name of the each permission should should clearly define what permissions it grants to which users.\n+\n+For more information on how to configure permissions through Keycloak Authorization Services, see xref:con-oauth-authorization-keycloak-example_str[the authorization example].\n+\n+\n+== Permissions required by operations\n+\n+Here are a few examples which permissions are required when performing some operations on Kafka.", "originalCommit": "aa6bfd6fb3a5ce8e0ccd57f2341af72e4b87786d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkwMTE5NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r528901194", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            == Permissions required by operations\n          \n          \n            \n            == Example permissions required for operations on Kafka", "author": "PaulRMellor", "createdAt": "2020-11-23T18:10:03Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-authorization-services.adoc", "diffHunk": "@@ -0,0 +1,204 @@\n+// Module included in the following module:\n+//\n+// proc-oauth-authorization-broker-config.adoc\n+\n+[id='con-oauth-authorization-keycloak-authorization-services_{context}']\n+= Managing policies and permissions in Keycloak Authorization Services\n+\n+== Kafka authorization model for resources\n+\n+The link:https://kafka.apache.org/documentation/#security_authz_primitives[Kafka authorization model] defines resource types, and the permissions available for each type.\n+When an action is performed by a Kafka client on a broker, the broker uses a configured authorizer to check permissions, depending on the action performed and the resource type.\n+\n+Kafka has five resource types for controlling access: `Topic`, `Group`, `Cluster`, `TransactionalId`, `DelegationToken`.\n+\n+Each resource type has different permissions:\n+\n+Topic:\n+\n+* `Create`\n+* `Write`\n+* `Read`\n+* `Delete`\n+* `Describe`\n+* `DescribeConfigs`\n+* `Alter`\n+* `AlterConfigs`\n+\n+Group:\n+\n+* `Read`\n+* `Describe`\n+* `Delete`\n+\n+Cluster:\n+\n+*  `Create`\n+*  `Describe`\n+*  `Alter`\n+*  `DescribeConfigs`\n+*  `AlterConfigs`\n+*  `IdempotentWrite`\n+*  `ClusterAction`\n+\n+TransactionalId:\n+\n+*  `Describe`\n+*  `Write`\n+\n+DelegationToken:\n+\n+* `Describe`\n+\n+== Keycloak Authorization Services model for managing permissions\n+\n+Keycloak Authorization Services use four concepts to define and grant permissions: _resources_, _authorization scopes_, _policies_, and _permissions_.\n+\n+Resources:: Resources are a set of resource definitions that are used to match permitted actions.\n+For example, a resource can be an individual topic, or it can be a set of all topics with names that start with the same prefix.\n+The resource definition has a set of available authorization scopes associated with it, which represent a set of all actions available on the particular resource.\n+Often, only a subset of these actions is actually permitted.\n+\n+Authorization scopes:: Authorization scopes is simply a set of all available actions on all the different resource types. When defining a new resource,  scopes are added from the set of all scopes.\n+\n+Policies:: Policies are rules that use criteria to match a list of accounts. Policies can match service accounts based on client id or roles, or user accounts based on username, groups, or roles.\n+\n+Permissions:: Permissions grant a subset of authorization scopes on a specific resource definition to a set of users.\n+\n+== Mapping Keycloak Authorization Services to Kafka Model\n+\n+Use Keycloak Authorization Services rules on the OAuth client that represents the Kafka Broker to grant Kafka permissions to users or service accounts. Typically, the OAuth client has `kafka` as its client id.\n+\n+The OAuth 2.0 client definition must have the _Authorization Enabled_ option activated.\n+\n+All permissions exist within the scope of this OAuth 2.0 client, which means that if you have different Kafka clusters configured with different OAuth 2.0 client IDs they would each have a separate set of permissions even though they are part of the same realm.\n+\n+When the Kafka client use the _SASL OAUTHBEARER_ mechanism, the Keycloak authorizer (`KeycloakRBACAuthorizer`) retrieves the list of grants for the current session from the Keycloak server using the access token of the current session.\n+This list of grants is the result of evaluating the Keycloak Authorization Services policies and permissions.\n+\n+.Introducing authorization scopes\n+\n+Typically, an initial configuration involves uploading the authorization scopes to create a list of all the possible actions that can be performed on all the Kafka resource types.\n+This step is performed only once, before defining any permissions. Alternatively, you can add authorization scopes manually.\n+\n+The authorization scopes should contain all the possible Kafka permissions regardless of the resource type:\n+\n+* `Create`\n+* `Write`\n+* `Read`\n+* `Delete`\n+* `Describe`\n+* `Alter`\n+* `DescribeConfig`\n+* `AlterConfig`\n+* `ClusterAction`\n+* `IdempotentWrite`\n+\n+.Defining resource patterns for permission checks\n+\n+The resources use pattern names for pattern matching against the targeted resources when performing permission checks.\n+\n+The general pattern is as follows: `RESOURCE_TYPE:NAME_PATTERN`\n+\n+The resource types mirror the Kafka authorization model.\n+The pattern allows for the two matching options: exact matching (when the pattern does not end with `\\*`), and prefix matching (when the pattern ends with `*`).\n+\n+.Example patterns for resources\n+    Topic:my-topic\n+    Topic:orders-*\n+    Group:orders-*\n+    Cluster:*\n+\n+In addition, the general pattern can be prefixed by `kafka-cluster:CLUSTER_NAME` followed by a comma, where the cluster name refers to the `metadata.name` in the Kafka custom resource.\n+\n+.Example patterns for resources with cluster prefix\n+    kafka-cluster:my-cluster,Topic:*\n+    kafka-cluster:*,Group:b_*\n+\n+When the `kafka-cluster` prefix is not present it is assumed to be `kafka-cluster:*`.\n+\n+When defining a resource, you can associate a list of possible authorization scopes relevant to the resource.\n+Set whatever actions make sense for the targeted resource type.\n+\n+While you may add any authorization scope to any resource, only the scopes supported by the resource type are considered for access control.\n+\n+.Policies\n+\n+Policies are used to target permissions to one or more accounts.\n+Targeting can refer to:\n+* Specific user or service accounts\n+* Realm roles or client roles\n+* User groups\n+* JS rule to match a client IP address\n+\n+A policy is given a unique name, and can be reused to target multiple permissions to multiple resources.\n+\n+.Defining permissions based on scopes, resources and policies \n+\n+Use fine-grained permissions to pull together the policies, resources, and authorization scopes that grant access to users.\n+\n+\n+The name of the each permission should should clearly define what permissions it grants to which users.\n+\n+For more information on how to configure permissions through Keycloak Authorization Services, see xref:con-oauth-authorization-keycloak-example_str[the authorization example].\n+\n+\n+== Permissions required by operations", "originalCommit": "aa6bfd6fb3a5ce8e0ccd57f2341af72e4b87786d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI3NDYzMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529274632", "bodyText": "Are we replacing OAuth with OAuth 2.0?", "author": "PaulRMellor", "createdAt": "2020-11-24T08:07:24Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI3NDg5NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529274895", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n          \n          \n            \n            For this, Strimzi Kafka OAuth supports the use of Keycloak Authorization Services.", "author": "PaulRMellor", "createdAt": "2020-11-24T08:07:49Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI3NTM0OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529275348", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n          \n          \n            \n            A custom authorizer has to be configured on the Kafka Broker to take advantage of the Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.", "author": "PaulRMellor", "createdAt": "2020-11-24T08:08:43Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI3NjAyNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529276025", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n          \n          \n            \n            The list of grants (permissions) is fetched as the first action after an authenticated session is established by the Kafka client, and then regularly refreshed in the background.", "author": "PaulRMellor", "createdAt": "2020-11-24T08:09:50Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI3NzQ5Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529277493", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n          \n          \n            \n            Grants are cached and enforced locally on the Kafka Broker for each user session to provide fast authorization decisions. Because they are refreshed, any changes to the grants on the Keycloak server are detected and enforced.", "author": "PaulRMellor", "createdAt": "2020-11-24T08:12:15Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI4MTg4OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529281889", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            = Keycloak Authorization Services Example\n          \n          \n            \n            = Example authorization rules configuration using Authorization Services", "author": "PaulRMellor", "createdAt": "2020-11-24T08:20:05Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI4MjQyOQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529282429", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ## Token Based Authorization with Keycloak Authorization Services\n          \n          \n            \n            == Token-based authorization with Keycloak Authorization Services", "author": "PaulRMellor", "createdAt": "2020-11-24T08:20:58Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI4MjYyMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529282622", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ## Starting Up the Pods\n          \n          \n            \n            == Starting Up the Pods", "author": "PaulRMellor", "createdAt": "2020-11-24T08:21:16Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI4NDMwOQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529284309", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n          \n          \n            \n            If your default namespace is not `myproject` (for example, `default`), use the following to deploy Keycloak:", "author": "PaulRMellor", "createdAt": "2020-11-24T08:23:56Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI4NzEyMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529287123", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n          \n          \n            \n            [source,shell]\n          \n          \n            \n            ----\n          \n          \n            \n            export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-24T08:28:19Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI4Nzc5OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529287799", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n          \n          \n            \n                kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n          \n          \n            \n            [source,shell]\n          \n          \n            \n            ----\n          \n          \n            \n            kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n          \n          \n            \n            kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-24T08:29:20Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI4OTMwNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529289304", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n          \n          \n            \n                kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n          \n          \n            \n            [source,shell]\n          \n          \n            \n            ----\n          \n          \n            \n            kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n          \n          \n            \n            kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-24T08:31:35Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI4OTY5NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529289694", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n          \n          \n            \n            [source,shell]\n          \n          \n            \n            ----\n          \n          \n            \n            curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-24T08:32:16Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI5MDE0MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529290141", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n          \n          \n            \n            [source,shell]\n          \n          \n            \n            ----\n          \n          \n            \n            kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-24T08:32:59Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI5MDQ0MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529290440", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                kubectl port-forward keycloak 8080\n          \n          \n            \n            [source,shell]\n          \n          \n            \n            ----\n          \n          \n            \n            kubectl port-forward keycloak 8080\n          \n          \n            \n            ----", "author": "PaulRMellor", "createdAt": "2020-11-24T08:33:31Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI5MDY3NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529290675", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ## Using the Keycloak Admin Console to Configure Authorization\n          \n          \n            \n            == Using the Keycloak Admin Console to configure authorization", "author": "PaulRMellor", "createdAt": "2020-11-24T08:33:57Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI5MTIxNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529291214", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            .Deploy the Postgres database for the Keycloak\n          \n          \n            \n            .Deploy the Postgres database for Keycloak", "author": "PaulRMellor", "createdAt": "2020-11-24T08:34:49Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI5MTcwMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529291700", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n          \n          \n            \n            Use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as username and password.", "author": "PaulRMellor", "createdAt": "2020-11-24T08:35:37Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI5MjQ2MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529292460", "bodyText": "I wonder if we're too detailed here, particularly as it's not core Strimzi/Streams content. If the User interface changes, this content might easily fall out of sync.", "author": "PaulRMellor", "createdAt": "2020-11-24T08:36:52Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTM0MjY0NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529342645", "bodyText": "The UI hasn't changed for years so it's unlikely to change soon. It's essential that users have no doubt when following the instructions which due to Keycloak Admin Console UI being very complex is quite likely if not giving them detailed instructions.", "author": "mstruk", "createdAt": "2020-11-24T09:27:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI5MjQ2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI5NDM4NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529294384", "bodyText": "Could we drop the specifics from In the upper left corner...to  ...for the kafka-authz realm. and just say: Locate and open Realm Settings for the kafka-authz realm?", "author": "PaulRMellor", "createdAt": "2020-11-24T08:39:54Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI5NzY1MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529297651", "bodyText": "Highlight ui text with bold (* each side of *\\text*)", "author": "PaulRMellor", "createdAt": "2020-11-24T08:44:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI5NDM4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTM1MjM1Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529352356", "bodyText": "Absolutely.", "author": "mstruk", "createdAt": "2020-11-24T09:34:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI5NDM4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTczMDk0Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529730942", "bodyText": "In fact, it's quite a bit more tricky. Let me think a bit about this.", "author": "mstruk", "createdAt": "2020-11-24T16:56:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI5NDM4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQxMTMxNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r530411317", "bodyText": "I hope I addressed it adequately.", "author": "mstruk", "createdAt": "2020-11-25T14:24:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI5NDM4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI5OTM2OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529299369", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n          \n          \n            \n            From the *Realm Settings* you can navigate to  *Groups*, *Roles*, *Clients* and *Users*.", "author": "PaulRMellor", "createdAt": "2020-11-24T08:47:35Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTMzMDM5MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529330391", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n          \n          \n            \n            Groups are sets of users with a name assigned. Typically, they are used to compartmentalize users into geographical, organizational or departmental units, and so on.", "author": "PaulRMellor", "createdAt": "2020-11-24T09:17:22Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTMzMDgwNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529330805", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The example starts by deploying the Keycloak server with pre-configured realm, requiring no additional configuration.\n          \n          \n            \n            The example starts by deploying the Keycloak server with pre-configured realms, requiring no additional configuration.", "author": "mstruk", "createdAt": "2020-11-24T09:17:42Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,458 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realm, requiring no additional configuration.", "originalCommit": "fd24e6b2bdb26f28174f194f6db86bea974867ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTMzMTIxMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529331211", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            We connect to the Keycloak Admin Console and demonstrate the sections of the UI where authorizations rules are configured.\n          \n          \n            \n            We connect to the Keycloak Admin Console and demonstrate the sections of the user interface where authorizations rules are configured.", "author": "mstruk", "createdAt": "2020-11-24T09:18:02Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,458 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realm, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the UI where authorizations rules are configured.", "originalCommit": "fd24e6b2bdb26f28174f194f6db86bea974867ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTMzMjE1Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529332157", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n          \n          \n            \n            That makes it possible to make a user a member of a group through a custom LDAP server admin user interface, for example, to grant them some permissions on Kafka resources.", "author": "PaulRMellor", "createdAt": "2020-11-24T09:18:52Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTMzMjgyNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529332825", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n          \n          \n            \n            Once the Kafka Broker has obtained an access token by using [Strimzi Kafka OAuth](https://github.com/strimzi/strimzi-kafka-oauth) for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.", "author": "mstruk", "createdAt": "2020-11-24T09:19:26Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,458 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+This is an end-to-end example of using Keycloak Authorization Services to configure authorization rules for use with `keycloak` authorization in Strimzi.\n+The example starts by deploying the Keycloak server with pre-configured realm, requiring no additional configuration.\n+We deploy the Kafka cluster configured to use one of the pre-configured realms.\n+We connect to the Keycloak Admin Console and demonstrate the sections of the UI where authorizations rules are configured.\n+We use Kafka CLI client tools with different personal and service accounts to demonstrate limited access based on the permissions granted to different accounts.\n+\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.", "originalCommit": "fd24e6b2bdb26f28174f194f6db86bea974867ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTMzMzkxNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529333917", "bodyText": "Here I refer to the project ... I made it more clear by turning it into a web link.", "author": "mstruk", "createdAt": "2020-11-24T09:20:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTMzMjgyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTMzMzI4OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529333289", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n          \n          \n            \n            Under *Users*, when viewing all users you will see two users defined: \n          \n          \n            \n            * `alice` \n          \n          \n            \n            * `bob`. \n          \n          \n            \n            \n          \n          \n            \n            `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.", "author": "PaulRMellor", "createdAt": "2020-11-24T09:19:47Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTMzNTEzNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529335136", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n          \n          \n            \n            Under *Groups*, you can view groups to mark users as having some permissions.", "author": "PaulRMellor", "createdAt": "2020-11-24T09:21:18Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTMzNjg0Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529336843", "bodyText": "I wonder if we should have inline headings (.title) for Groups, Users, Roles and Clients in this section.", "author": "PaulRMellor", "createdAt": "2020-11-24T09:22:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTMzNTEzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTMzODM3Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529338376", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n          \n          \n            \n            Under *Roles*, you can view the realm roles to mark users or clients as having some permissions.", "author": "PaulRMellor", "createdAt": "2020-11-24T09:23:50Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTM0MDczNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529340734", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n          \n          \n            \n            Roles are a concept analogous to groups. They are usually used to _tag_ users with organizational roles and have the requisite permissions.", "author": "PaulRMellor", "createdAt": "2020-11-24T09:25:40Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTM0NTgxMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529345811", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n          \n          \n            \n            Roles cannot be stored in an LDAP identity provider. If LDAP is a requirement, you could use groups instead.", "author": "PaulRMellor", "createdAt": "2020-11-24T09:29:38Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTM0Njk4MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529346980", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n          \n          \n            \n            Under *Clients*, you can view the additional client configurations: \n          \n          \n            \n            * `kafka`\n          \n          \n            \n            * `kafka-cli`\n          \n          \n            \n            * `team-a-client`\n          \n          \n            \n            * `team-b-client`.", "author": "PaulRMellor", "createdAt": "2020-11-24T09:30:33Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTM1Mjk2MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529352961", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n          \n          \n            \n            The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth 2.0 communication for access token validation,", "author": "PaulRMellor", "createdAt": "2020-11-24T09:35:19Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTM1NjU4Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529356587", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n          \n          \n            \n            and to authenticate to other Kafka Broker instances using OAuth 2.0 client authentication.", "author": "PaulRMellor", "createdAt": "2020-11-24T09:38:19Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTM1NzIwNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529357207", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n          \n          \n            \n            This client also contains the Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.", "author": "PaulRMellor", "createdAt": "2020-11-24T09:38:48Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTM2MTI4Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529361283", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n          \n          \n            \n            This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n          \n          \n            \n            The authorization configuration is defined in the `kafka` client from the *Authorization* tab, which becomes visible when *Authorization Enabled* is switched on from the *Settings* tab.", "author": "PaulRMellor", "createdAt": "2020-11-24T09:42:04Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTM2MTgzNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529361834", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n          \n          \n            \n            == Defining Authorization Services for access control", "author": "PaulRMellor", "createdAt": "2020-11-24T09:42:28Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTM3NDcwMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529374703", "bodyText": "This section reads like concepts and recommendations rather than part of the example. It seems like we're going over similar ground to Mapping Keycloak Authorization Services to Kafka Model", "author": "PaulRMellor", "createdAt": "2020-11-24T09:52:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTM2MTgzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY0NDk2Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529644967", "bodyText": "That's true. It makes sense for a standalone example / tutorial, but maybe not when it's part of a document that in previous chapter explained all this.", "author": "mstruk", "createdAt": "2020-11-24T15:35:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTM2MTgzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTM3OTU5NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3989#discussion_r529379595", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            `Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.\n          \n          \n            \n            Keycloak Authorization Services use authorization scopes, policies and permissions to define and apply access control to resources.", "author": "PaulRMellor", "createdAt": "2020-11-24T09:56:10Z", "path": "documentation/modules/oauth/con-oauth-authorization-keycloak-example.adoc", "diffHunk": "@@ -0,0 +1,452 @@\n+// Module included in the following module:\n+//\n+// con-oauth-authorization-keycloak-authorization-services.adoc\n+\n+[id='con-oauth-authorization-keycloak-example_{context}']\n+= Keycloak Authorization Services Example\n+\n+## Token Based Authorization with Keycloak Authorization Services\n+\n+Once the Kafka Broker has obtained an access token by using Strimzi Kafka OAuth for authentication, it is possible to use centrally managed authorization rules to enforce access restrictions onto Kafka Clients.\n+For this Strimzi Kafka OAuth supports the use of `Keycloak Authorization Services`.\n+\n+A custom authorizer has to be configured on the Kafka Broker to take advantage of Authorization Services REST endpoints available on Keycloak, which provide a list of granted permissions on resources for authenticated users.\n+The list of grants (permissions) is first fetched during the first action after authenticated session is established by Kafka client, and then regularly refreshed in the background.\n+Grants are cached, and enforced locally on the Kafka Broker for each user session in order to provide fast authorization decisions. Because they are refreshed, any changes at Keycloak side are detected and enforced.\n+\n+\n+## Starting Up the Pods\n+\n+NOTE: TODO: Change the url to: https://github.com/strimzi/strimzi-kafka-oauth/tree/master/examples/kubernetes\n+\n+For this example we're using the kubernetes deployment scripts available at https://github.com/mstruk/strimzi-kafka-oauth/tree/examples/examples/kubernetes\n+\n+NOTE: TODO: Change the url to: https://raw.githubusercontent.com/strimzi/strimzi-kafka-oauth/master\n+\n+    export ROOT=https://raw.githubusercontent.com/mstruk/strimzi-kafka-oauth/examples\n+\n+.Deploy the Postgres database for the Keycloak\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres-pvc.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/postgres.yaml\n+\n+.Deploy the Keycloak server\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-realms-configmap.yaml\n+    kubectl apply -f $ROOT/examples/kubernetes/keycloak-postgres.yaml\n+\n+If your default namespace is not `myproject` but something else (for example, `default`), then use the following to deploy Keycloak:\n+\n+    curl -s $ROOT/examples/kubernetes/keycloak-postgres.yaml | sed -e \"s#myproject#default#\" | kubectl apply -f -\n+\n+.Deploy the minimal Kafka cluster\n+\n+Here we assume that the Strimzi Cluster Operator has already been installed on your Kubernetes cluster.\n+\n+    kubectl apply -f $ROOT/examples/kubernetes/kafka-oauth-single-authz.yaml\n+\n+\n+## Using the Keycloak Admin Console to Configure Authorization\n+\n+You can login to the Keycloak Admin Console by creating a tunnel to the keycloak pod:\n+\n+    kubectl port-forward keycloak 8080\n+\n+Now use your browser to connect to `http://localhost:8080/auth/admin` and use `admin` as both a username, and a password.\n+\n+In the upper left corner under the Keycloak icon you should see `Master` selected as the current realm.\n+Moving the mouse pointer over it should reveal two additional realms - `Demo` and `Kafka-authz`.\n+\n+For this example we are interested in the `kafka-authz` realm.\n+Selecting it will open the `Realm Settings` for the `kafka-authz` realm.\n+Next to the `Realm Settings` there are other sections we are interested in - `Groups`, `Roles`, `Clients` and `Users`.\n+\n+Under `Groups` we can see several groups that can be used to mark users as having some permissions.\n+Groups are sets of users with name assigned. Typically they are used to geographically or organisationally compartmentalize users into organisations, organisational units, departments, and so on.\n+\n+In Keycloak the groups can be stored in an LDAP identity provider.\n+That makes it possible to make some user a member of some group - through a custom LDAP server admin UI for example, which grants them some permissions on Kafka resources.\n+\n+Under `Users`, click on the `View all users` button and you will see two users defined - `alice` and `bob`. `alice` is a member of the `ClusterManager Group`, and `bob` is a member of `ClusterManager-my-cluster Group`.\n+In Keycloak the users can be stored in an LDAP identity provider.\n+\n+Under `Roles` we can see several realm roles which can be used to mark users or clients as having some permissions.\n+Roles are a concept analogous to groups. They are usually used to 'tag' users as playing organisational roles and having permissions that pertain to it.\n+In Keycloak the roles cannot be stored in an LDAP identity provider - if that is your requirement then you should use groups instead.\n+\n+Under `Clients` we can see some additional clients configured - `kafka`, `kafka-cli`, `team-a-client`, `team-b-client`.\n+The client with client id `kafka` is used by Kafka Brokers to perform the necessary OAuth2 communication for access token validation,\n+and to authenticate to other Kafka Broker instances using OAuth2 client authentication.\n+This client also contains Authorization Services resource definitions, policies and authorization scopes used to perform authorization on the Kafka Brokers.\n+\n+The client with client id `kafka-cli` is a public client that can be used by the Kafka command line tools when authenticating with username and password to obtain an access token or a refresh token.\n+\n+Clients `team-a-client`, and `team-b-client` are confidential clients representing services with partial access to certain Kafka topics.\n+\n+The authorization configuration is defined in the `kafka` client under `Authorization` tab.\n+This tab becomes visible when `Authorization Enabled` is turned on under the `Settings` tab.\n+\n+\n+## Authorization Services - Resources, Authorization Scopes, Policies and Permissions\n+\n+`Keycloak Authorization Services` use several concepts that together take part in defining, and applying access control to resources.", "originalCommit": "0bab89961e4af7af74c896083be2f6d4fe0cc74f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}