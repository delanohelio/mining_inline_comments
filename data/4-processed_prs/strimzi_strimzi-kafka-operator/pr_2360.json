{"pr_number": 2360, "pr_title": "Fix NPE when secret does not contain given crt", "pr_createdAt": "2020-01-06T10:01:04Z", "pr_url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2360", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzMwNjI5Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2360#discussion_r363306297", "bodyText": "Could you make this a bit more readable?\nelse {\n    try {", "author": "scholzj", "createdAt": "2020-01-06T14:05:47Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1774,14 +1774,18 @@ public void checkCustomCaSecret(CertificateAuthority ca, Secret certSecret, Secr\n                                 Secret certSecret = result.result();\n \n                                 if (certSecret != null) {\n-                                    try {\n-                                        X509Certificate cert = Ca.cert(certSecret, customCertSecret.getCertificate());\n-                                        byte[] signature = MessageDigest.getInstance(\"SHA-256\").digest(cert.getEncoded());\n-                                        thumbprintPromise.complete(Base64.getEncoder().encodeToString(signature));\n-                                    } catch (CertificateEncodingException | NoSuchAlgorithmException e) {\n-                                        log.warn(\"{}: Failed to get certificate signature of {} from Secret {}.\", reconciliation, customCertSecret.getCertificate(), customCertSecret.getSecretName());\n-                                        thumbprintPromise.fail(new RuntimeException(\"Failed to get certificate signature of \" + customCertSecret.getCertificate() + \" from Secret \" + certSecret.getMetadata().getName(), e));\n-                                    }\n+                                    if (!certSecret.getData().containsKey(customCertSecret.getCertificate())) {\n+                                        thumbprintPromise.fail(\"Secret \" + customCertSecret.getSecretName() + \" does not contain certificate \" + customCertSecret.getCertificate() + \".\");\n+                                    } else if (!certSecret.getData().containsKey(customCertSecret.getKey())) {\n+                                        thumbprintPromise.fail(\"Secret \" + customCertSecret.getSecretName() + \" does not contain key \" + customCertSecret.getKey() + \".\");\n+                                    } else try {", "originalCommit": "1c9c56481b6213286c1f3bcdf199018998e1797b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzMwNjg2Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2360#discussion_r363306863", "bodyText": "Could you add the warn messages as we have them with the other errors to make that consistent? Also, I think the message could you some more clarification ... maybe something like Secret xyz does not contian certificate under the key <tls.crt>.", "author": "scholzj", "createdAt": "2020-01-06T14:07:01Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1774,14 +1774,18 @@ public void checkCustomCaSecret(CertificateAuthority ca, Secret certSecret, Secr\n                                 Secret certSecret = result.result();\n \n                                 if (certSecret != null) {\n-                                    try {\n-                                        X509Certificate cert = Ca.cert(certSecret, customCertSecret.getCertificate());\n-                                        byte[] signature = MessageDigest.getInstance(\"SHA-256\").digest(cert.getEncoded());\n-                                        thumbprintPromise.complete(Base64.getEncoder().encodeToString(signature));\n-                                    } catch (CertificateEncodingException | NoSuchAlgorithmException e) {\n-                                        log.warn(\"{}: Failed to get certificate signature of {} from Secret {}.\", reconciliation, customCertSecret.getCertificate(), customCertSecret.getSecretName());\n-                                        thumbprintPromise.fail(new RuntimeException(\"Failed to get certificate signature of \" + customCertSecret.getCertificate() + \" from Secret \" + certSecret.getMetadata().getName(), e));\n-                                    }\n+                                    if (!certSecret.getData().containsKey(customCertSecret.getCertificate())) {\n+                                        thumbprintPromise.fail(\"Secret \" + customCertSecret.getSecretName() + \" does not contain certificate \" + customCertSecret.getCertificate() + \".\");", "originalCommit": "1c9c56481b6213286c1f3bcdf199018998e1797b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzMwNjkxOQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2360#discussion_r363306919", "bodyText": "Same as above.", "author": "scholzj", "createdAt": "2020-01-06T14:07:09Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1774,14 +1774,18 @@ public void checkCustomCaSecret(CertificateAuthority ca, Secret certSecret, Secr\n                                 Secret certSecret = result.result();\n \n                                 if (certSecret != null) {\n-                                    try {\n-                                        X509Certificate cert = Ca.cert(certSecret, customCertSecret.getCertificate());\n-                                        byte[] signature = MessageDigest.getInstance(\"SHA-256\").digest(cert.getEncoded());\n-                                        thumbprintPromise.complete(Base64.getEncoder().encodeToString(signature));\n-                                    } catch (CertificateEncodingException | NoSuchAlgorithmException e) {\n-                                        log.warn(\"{}: Failed to get certificate signature of {} from Secret {}.\", reconciliation, customCertSecret.getCertificate(), customCertSecret.getSecretName());\n-                                        thumbprintPromise.fail(new RuntimeException(\"Failed to get certificate signature of \" + customCertSecret.getCertificate() + \" from Secret \" + certSecret.getMetadata().getName(), e));\n-                                    }\n+                                    if (!certSecret.getData().containsKey(customCertSecret.getCertificate())) {\n+                                        thumbprintPromise.fail(\"Secret \" + customCertSecret.getSecretName() + \" does not contain certificate \" + customCertSecret.getCertificate() + \".\");\n+                                    } else if (!certSecret.getData().containsKey(customCertSecret.getKey())) {\n+                                        thumbprintPromise.fail(\"Secret \" + customCertSecret.getSecretName() + \" does not contain key \" + customCertSecret.getKey() + \".\");", "originalCommit": "1c9c56481b6213286c1f3bcdf199018998e1797b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzM0NDczOA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2360#discussion_r363344738", "bodyText": "Won't the logging here and the failure of the thumbprintPromise with the same message result in the message being logged twice?", "author": "tombentley", "createdAt": "2020-01-06T15:34:32Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1774,14 +1774,21 @@ public void checkCustomCaSecret(CertificateAuthority ca, Secret certSecret, Secr\n                                 Secret certSecret = result.result();\n \n                                 if (certSecret != null) {\n-                                    try {\n-                                        X509Certificate cert = Ca.cert(certSecret, customCertSecret.getCertificate());\n-                                        byte[] signature = MessageDigest.getInstance(\"SHA-256\").digest(cert.getEncoded());\n-                                        thumbprintPromise.complete(Base64.getEncoder().encodeToString(signature));\n-                                    } catch (CertificateEncodingException | NoSuchAlgorithmException e) {\n-                                        log.warn(\"{}: Failed to get certificate signature of {} from Secret {}.\", reconciliation, customCertSecret.getCertificate(), customCertSecret.getSecretName());\n-                                        thumbprintPromise.fail(new RuntimeException(\"Failed to get certificate signature of \" + customCertSecret.getCertificate() + \" from Secret \" + certSecret.getMetadata().getName(), e));\n-                                    }\n+                                    if (!certSecret.getData().containsKey(customCertSecret.getCertificate())) {\n+                                        log.warn(\"{}: Secret {} does not contain certificate under the key {}.\", reconciliation, customCertSecret.getSecretName(), customCertSecret.getCertificate());", "originalCommit": "2489a964d86a41893305936199bafa296b624f1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzYzMjcxNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2360#discussion_r363632715", "bodyText": "It will: https://pastebin.com/8wpCi6VZ", "author": "sknot-rh", "createdAt": "2020-01-07T08:15:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzM0NDczOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzY0MzQxMw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2360#discussion_r363643413", "bodyText": "Well it's pointless logging such things twice, so I'd drop the log stmts here and let the global handler log it.", "author": "tombentley", "createdAt": "2020-01-07T08:48:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzM0NDczOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzY1MTAwNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2360#discussion_r363651006", "bodyText": "@scholzj ^ What do you think?", "author": "sknot-rh", "createdAt": "2020-01-07T09:08:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzM0NDczOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzkwNjc3Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2360#discussion_r363906772", "bodyText": "Sure, fine with me to remove them.", "author": "scholzj", "createdAt": "2020-01-07T19:16:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzM0NDczOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzM0NzUyMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2360#discussion_r363347522", "bodyText": "I don't think we should use RuntimeException (at least in the case of a CertificateEncodingException, which would indicate that the user didn't create the Secret with a cert in the correct format). Remember that the exception class name gets set in the resource status, so it ought to be something helpful. I guess we could use the existing InvalidResourceException (though I've always thought of that as being about the consumed CR, rather than other resources)? Or Maybe a new exception class.\nThe above errors for missing cert and key should use the same exception type.", "author": "tombentley", "createdAt": "2020-01-06T15:40:32Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1774,14 +1774,21 @@ public void checkCustomCaSecret(CertificateAuthority ca, Secret certSecret, Secr\n                                 Secret certSecret = result.result();\n \n                                 if (certSecret != null) {\n-                                    try {\n-                                        X509Certificate cert = Ca.cert(certSecret, customCertSecret.getCertificate());\n-                                        byte[] signature = MessageDigest.getInstance(\"SHA-256\").digest(cert.getEncoded());\n-                                        thumbprintPromise.complete(Base64.getEncoder().encodeToString(signature));\n-                                    } catch (CertificateEncodingException | NoSuchAlgorithmException e) {\n-                                        log.warn(\"{}: Failed to get certificate signature of {} from Secret {}.\", reconciliation, customCertSecret.getCertificate(), customCertSecret.getSecretName());\n-                                        thumbprintPromise.fail(new RuntimeException(\"Failed to get certificate signature of \" + customCertSecret.getCertificate() + \" from Secret \" + certSecret.getMetadata().getName(), e));\n-                                    }\n+                                    if (!certSecret.getData().containsKey(customCertSecret.getCertificate())) {\n+                                        log.warn(\"{}: Secret {} does not contain certificate under the key {}.\", reconciliation, customCertSecret.getSecretName(), customCertSecret.getCertificate());\n+                                        thumbprintPromise.fail(\"Secret \" + customCertSecret.getSecretName() + \" does not contain certificate under the key \" + customCertSecret.getCertificate() + \".\");\n+                                    } else if (!certSecret.getData().containsKey(customCertSecret.getKey())) {\n+                                        log.warn(\"{}: Secret {} does not contain custom certificate private key under the key {}.\", reconciliation, customCertSecret.getSecretName(), customCertSecret.getKey());\n+                                        thumbprintPromise.fail(\"Secret \" + customCertSecret.getSecretName() + \" does not contain custom certificate private key under the key \" + customCertSecret.getKey() + \".\");\n+                                    } else\n+                                        try {\n+                                            X509Certificate cert = Ca.cert(certSecret, customCertSecret.getCertificate());\n+                                            byte[] signature = MessageDigest.getInstance(\"SHA-256\").digest(cert.getEncoded());\n+                                            thumbprintPromise.complete(Base64.getEncoder().encodeToString(signature));\n+                                        } catch (CertificateEncodingException | NoSuchAlgorithmException e) {\n+                                            log.warn(\"{}: Failed to get certificate signature of {} from Secret {}.\", reconciliation, customCertSecret.getCertificate(), customCertSecret.getSecretName());\n+                                            thumbprintPromise.fail(new RuntimeException(\"Failed to get certificate signature of \" + customCertSecret.getCertificate() + \" from Secret \" + certSecret.getMetadata().getName(), e));", "originalCommit": "2489a964d86a41893305936199bafa296b624f1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzM0ODU3Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2360#discussion_r363348573", "bodyText": "I guess when the keys are missing it is really abotu invalid CR -> the keys listed there are wrong. When they exist but fail to decode it is a bit harder.", "author": "scholzj", "createdAt": "2020-01-06T15:42:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzM0NzUyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA5NDQ1MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2360#discussion_r364094451", "bodyText": "I guess at least this should be a InvalidResourceException as well.", "author": "scholzj", "createdAt": "2020-01-08T07:34:05Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1774,20 +1775,22 @@ public void checkCustomCaSecret(CertificateAuthority ca, Secret certSecret, Secr\n                                 Secret certSecret = result.result();\n \n                                 if (certSecret != null) {\n-                                    try {\n-                                        X509Certificate cert = Ca.cert(certSecret, customCertSecret.getCertificate());\n-                                        byte[] signature = MessageDigest.getInstance(\"SHA-256\").digest(cert.getEncoded());\n-                                        thumbprintPromise.complete(Base64.getEncoder().encodeToString(signature));\n-                                    } catch (CertificateEncodingException | NoSuchAlgorithmException e) {\n-                                        log.warn(\"{}: Failed to get certificate signature of {} from Secret {}.\", reconciliation, customCertSecret.getCertificate(), customCertSecret.getSecretName());\n-                                        thumbprintPromise.fail(new RuntimeException(\"Failed to get certificate signature of \" + customCertSecret.getCertificate() + \" from Secret \" + certSecret.getMetadata().getName(), e));\n-                                    }\n+                                    if (!certSecret.getData().containsKey(customCertSecret.getCertificate())) {\n+                                        thumbprintPromise.fail(new InvalidResourceException(\"Secret \" + customCertSecret.getSecretName() + \" does not contain certificate under the key \" + customCertSecret.getCertificate() + \".\"));\n+                                    } else if (!certSecret.getData().containsKey(customCertSecret.getKey())) {\n+                                        thumbprintPromise.fail(new InvalidResourceException(\"Secret \" + customCertSecret.getSecretName() + \" does not contain custom certificate private key under the key \" + customCertSecret.getKey() + \".\"));\n+                                    } else\n+                                        try {\n+                                            X509Certificate cert = Ca.cert(certSecret, customCertSecret.getCertificate());\n+                                            byte[] signature = MessageDigest.getInstance(\"SHA-256\").digest(cert.getEncoded());\n+                                            thumbprintPromise.complete(Base64.getEncoder().encodeToString(signature));\n+                                        } catch (CertificateEncodingException | NoSuchAlgorithmException e) {\n+                                            thumbprintPromise.fail(new RuntimeException(\"Failed to get certificate signature of \" + customCertSecret.getCertificate() + \" from Secret \" + certSecret.getMetadata().getName(), e));\n+                                        }\n                                 } else {\n-                                    log.warn(\"{}: Secret {} with custom TLS certificate does not exist.\", reconciliation, customCertSecret.getSecretName());\n                                     thumbprintPromise.fail(\"Secret \" + customCertSecret.getSecretName() + \" with custom TLS certificate does not exist.\");", "originalCommit": "4c1dbe0dce5f59e00cae21a0575706ca8ed1ef33", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDEyNDIwNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2360#discussion_r364124206", "bodyText": "We have NoSuchResourceException which you can use here.", "author": "tombentley", "createdAt": "2020-01-08T09:03:03Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -1774,20 +1775,22 @@ public void checkCustomCaSecret(CertificateAuthority ca, Secret certSecret, Secr\n                                 Secret certSecret = result.result();\n \n                                 if (certSecret != null) {\n-                                    try {\n-                                        X509Certificate cert = Ca.cert(certSecret, customCertSecret.getCertificate());\n-                                        byte[] signature = MessageDigest.getInstance(\"SHA-256\").digest(cert.getEncoded());\n-                                        thumbprintPromise.complete(Base64.getEncoder().encodeToString(signature));\n-                                    } catch (CertificateEncodingException | NoSuchAlgorithmException e) {\n-                                        log.warn(\"{}: Failed to get certificate signature of {} from Secret {}.\", reconciliation, customCertSecret.getCertificate(), customCertSecret.getSecretName());\n-                                        thumbprintPromise.fail(new RuntimeException(\"Failed to get certificate signature of \" + customCertSecret.getCertificate() + \" from Secret \" + certSecret.getMetadata().getName(), e));\n-                                    }\n+                                    if (!certSecret.getData().containsKey(customCertSecret.getCertificate())) {\n+                                        thumbprintPromise.fail(new InvalidResourceException(\"Secret \" + customCertSecret.getSecretName() + \" does not contain certificate under the key \" + customCertSecret.getCertificate() + \".\"));\n+                                    } else if (!certSecret.getData().containsKey(customCertSecret.getKey())) {\n+                                        thumbprintPromise.fail(new InvalidResourceException(\"Secret \" + customCertSecret.getSecretName() + \" does not contain custom certificate private key under the key \" + customCertSecret.getKey() + \".\"));\n+                                    } else\n+                                        try {\n+                                            X509Certificate cert = Ca.cert(certSecret, customCertSecret.getCertificate());\n+                                            byte[] signature = MessageDigest.getInstance(\"SHA-256\").digest(cert.getEncoded());\n+                                            thumbprintPromise.complete(Base64.getEncoder().encodeToString(signature));\n+                                        } catch (CertificateEncodingException | NoSuchAlgorithmException e) {\n+                                            thumbprintPromise.fail(new RuntimeException(\"Failed to get certificate signature of \" + customCertSecret.getCertificate() + \" from Secret \" + certSecret.getMetadata().getName(), e));\n+                                        }\n                                 } else {\n-                                    log.warn(\"{}: Secret {} with custom TLS certificate does not exist.\", reconciliation, customCertSecret.getSecretName());\n-                                    thumbprintPromise.fail(\"Secret \" + customCertSecret.getSecretName() + \" with custom TLS certificate does not exist.\");\n+                                    thumbprintPromise.fail(new InvalidResourceException(\"Secret \" + customCertSecret.getSecretName() + \" with custom TLS certificate does not exist.\"));\n                                 }\n                             } else {\n-                                log.warn(\"{}: Failed to get secret {} with custom TLS certificate.\", reconciliation, customCertSecret.getSecretName());\n                                 thumbprintPromise.fail(\"Failed to get secret \" + customCertSecret.getSecretName() + \" with custom TLS certificate.\");", "originalCommit": "53c0748f688f61765678b092274abbe887132342", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d2e9755777de5406b25e4c3053a44eb6625a18ea", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/d2e9755777de5406b25e4c3053a44eb6625a18ea", "message": "Fix NPE when secret does not contain given crt\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-01-08T11:24:38Z", "type": "commit"}, {"oid": "00a41b92ae6dbec413e19a840efcde360fb65737", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/00a41b92ae6dbec413e19a840efcde360fb65737", "message": "better fix NPE when secret does not contain given crt or key\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-01-08T11:24:38Z", "type": "commit"}, {"oid": "c0c983981421200d1f4e6a05c036b4527e1f4040", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/c0c983981421200d1f4e6a05c036b4527e1f4040", "message": "Jakub's suggestion\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-01-08T11:24:38Z", "type": "commit"}, {"oid": "56a12f2973c25fb6178a308475d11c89f0e5dc48", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/56a12f2973c25fb6178a308475d11c89f0e5dc48", "message": "logging\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-01-08T11:24:38Z", "type": "commit"}, {"oid": "d8e89f1a1c7584d7ef20360c50f5359de493d0d9", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/d8e89f1a1c7584d7ef20360c50f5359de493d0d9", "message": "Tom's comments\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-01-08T11:24:38Z", "type": "commit"}, {"oid": "cacbcea5421370a694167ca31437babee496c5a7", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/cacbcea5421370a694167ca31437babee496c5a7", "message": "remove logging\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-01-08T11:24:38Z", "type": "commit"}, {"oid": "9c4414466075da84b2043cc6ca14f2d58b32a9dc", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/9c4414466075da84b2043cc6ca14f2d58b32a9dc", "message": "comment\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-01-08T11:24:38Z", "type": "commit"}, {"oid": "e2356499ff5175060fe110713809f83114c55d1d", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/e2356499ff5175060fe110713809f83114c55d1d", "message": "comment\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-01-08T11:27:24Z", "type": "commit"}, {"oid": "e2356499ff5175060fe110713809f83114c55d1d", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/e2356499ff5175060fe110713809f83114c55d1d", "message": "comment\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-01-08T11:27:24Z", "type": "forcePushed"}]}