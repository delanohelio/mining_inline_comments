{"pr_number": 3721, "pr_title": "Fix KR issues", "pr_createdAt": "2020-09-29T14:40:42Z", "pr_url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3721", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc5NTkzNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3721#discussion_r496795934", "bodyText": "This might suffer from NPEs (especially .getState().getWaiting().getReason()) and also possibly IndexNotFoundException if, for whatever reason the container couldn't be found. Probably better to code it more carefully.", "author": "tombentley", "createdAt": "2020-09-29T15:07:38Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/KafkaRoller.java", "diffHunk": "@@ -362,6 +362,10 @@ private void restartIfNecessary(int podId, RestartContext restartContext)\n         }\n     }\n \n+    private boolean isCrashlooping(Pod pod) {\n+        return \"CrashLoopBackOff\".equals(pod.getStatus().getContainerStatuses().stream().filter(containerStatus -> containerStatus.getName().equals(\"kafka\")).collect(Collectors.toList()).get(0).getState().getWaiting().getReason());", "originalCommit": "4a6d429b44c552c7c555567c6842dcac0f13c3fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "70a75e19a061549843bd93bda939c897da90fb65", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/70a75e19a061549843bd93bda939c897da90fb65", "message": "changes\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-09-30T14:54:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMxOTA4Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3721#discussion_r498319082", "bodyText": "Out of interest why was it necessary to add it here? Just so that we don't spend ~7 minutes before we restart it?", "author": "tombentley", "createdAt": "2020-10-01T15:08:39Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/KafkaRoller.java", "diffHunk": "@@ -318,38 +320,43 @@ private void restartIfNecessary(int podId, RestartContext restartContext)\n         }\n \n         try {\n-            RestartPlan restartPlan = restartPlan(podId, pod, restartContext);\n-            if (restartPlan.needsRestart || restartPlan.needsReconfig) {\n-                if (deferController(podId, restartContext)) {\n-                    log.debug(\"{}: Pod {} is controller and there are other pods to roll\", reconciliation, podId);\n-                    throw new ForceableProblem(\"Pod \" + podName(podId) + \" is currently the controller and there are other pods still to roll\");\n-                } else {\n-                    if (canRoll(podId, 60_000, TimeUnit.MILLISECONDS, false)) {\n-                        // Check for rollability before trying a dynamic update so that if the dynamic update fails we can go to a full restart\n-                        if (!maybeDynamicUpdateBrokerConfig(podId, restartPlan)) {\n-                            log.debug(\"{}: Pod {} can be rolled now\", reconciliation, podId);\n-                            restartAndAwaitReadiness(pod, operationTimeoutMs, TimeUnit.MILLISECONDS);\n+            if (isCrashlooping(pod)) {", "originalCommit": "d48e7aa99288c9c783d4b831568f92a8a6dedeed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUwMTQ3NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3721#discussion_r498501475", "bodyText": "I am not saying it was necessary but without it the timeout was still 20 minutes. And it makes sense. If we want to roll pod which is crashlooping, it is probably not possible to connect to it. So checking it at the beginning of the algorithm seems to be a good idea.", "author": "sknot-rh", "createdAt": "2020-10-01T20:41:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMxOTA4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcwOTM3MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3721#discussion_r498709370", "bodyText": "What if the pod is not crash looping but creating or pending because of some other misconfiguration (missing volumes, badly configured resources, ...)? Does the rolling update work fine in that case even with this check looking just for crash-looping pods?", "author": "scholzj", "createdAt": "2020-10-02T09:18:08Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/KafkaRoller.java", "diffHunk": "@@ -318,38 +320,43 @@ private void restartIfNecessary(int podId, RestartContext restartContext)\n         }\n \n         try {\n-            RestartPlan restartPlan = restartPlan(podId, pod, restartContext);\n-            if (restartPlan.needsRestart || restartPlan.needsReconfig) {\n-                if (deferController(podId, restartContext)) {\n-                    log.debug(\"{}: Pod {} is controller and there are other pods to roll\", reconciliation, podId);\n-                    throw new ForceableProblem(\"Pod \" + podName(podId) + \" is currently the controller and there are other pods still to roll\");\n-                } else {\n-                    if (canRoll(podId, 60_000, TimeUnit.MILLISECONDS, false)) {\n-                        // Check for rollability before trying a dynamic update so that if the dynamic update fails we can go to a full restart\n-                        if (!maybeDynamicUpdateBrokerConfig(podId, restartPlan)) {\n-                            log.debug(\"{}: Pod {} can be rolled now\", reconciliation, podId);\n-                            restartAndAwaitReadiness(pod, operationTimeoutMs, TimeUnit.MILLISECONDS);\n+            if (isCrashlooping(pod)) {", "originalCommit": "d48e7aa99288c9c783d4b831568f92a8a6dedeed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY1MTk3OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3721#discussion_r500651979", "bodyText": "How did you addressed this? This still seems to do something only when the pod is crashlooping but not when it gets stuck in other states such as Pending, ContainerCreating, ImagePullBackoff etc.", "author": "scholzj", "createdAt": "2020-10-06T23:29:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcwOTM3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcxMzMwNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3721#discussion_r498713307", "bodyText": "Does this actually work? Why should it decide to roll the pod? In your test the configuration is up to date so I would not expect it to roll the pod. I think the test should do the following:\n\nDeploy the Kafka cluster with UseParNewGC\nWait for it to crash loop\nRemove UseParNewGC from the config\nWait for it to roll\nWait for it to be ready\n\nWith the test as it is written right now, I would not expect the pods to be rolled at all since there was no change to anything. It should not roll them just because they are crashlooping ... but if it needs to roll them and they are crashlooping it should not wait for a successful connection tot he broker.", "author": "scholzj", "createdAt": "2020-10-02T09:26:10Z", "path": "systemtest/src/test/java/io/strimzi/systemtest/rollingupdate/KafkaRollerST.java", "diffHunk": "@@ -122,6 +125,30 @@ void testKafkaTopicRFLowerThanMinInSyncReplicas() {\n         assertThat(StatefulSetUtils.ssSnapshot(kafkaName), is(not(kafkaPods)));\n     }\n \n+    @Test\n+    void testKafkaPodCrashLooping() throws InterruptedException {", "originalCommit": "d48e7aa99288c9c783d4b831568f92a8a6dedeed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY3OTg3NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3721#discussion_r499679874", "bodyText": "I see your points. Let me retest it properly.", "author": "sknot-rh", "createdAt": "2020-10-05T15:21:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcxMzMwNw=="}], "type": "inlineReview"}, {"oid": "7799f7189c58791fefcf6f1482c88401a7d6a604", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/7799f7189c58791fefcf6f1482c88401a7d6a604", "message": "Fix KR issues\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-10-06T09:00:37Z", "type": "commit"}, {"oid": "c2c30dfda4cd726c746715212d430b6e1098bb50", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/c2c30dfda4cd726c746715212d430b6e1098bb50", "message": "carefully coding\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-10-06T09:00:37Z", "type": "commit"}, {"oid": "90a434a5fcfcf2d67d2ea784d68c4e02ed38fa12", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/90a434a5fcfcf2d67d2ea784d68c4e02ed38fa12", "message": "changes\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-10-06T09:00:37Z", "type": "commit"}, {"oid": "c37c0315b9c2926f458e516ae658b4302cc335c8", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/c37c0315b9c2926f458e516ae658b4302cc335c8", "message": "changes\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-10-06T09:00:37Z", "type": "commit"}, {"oid": "9224dada82182b32cfce95a29cfa1541781656e4", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/9224dada82182b32cfce95a29cfa1541781656e4", "message": "fixes\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-10-06T09:00:37Z", "type": "commit"}, {"oid": "9224dada82182b32cfce95a29cfa1541781656e4", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/9224dada82182b32cfce95a29cfa1541781656e4", "message": "fixes\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-10-06T09:00:37Z", "type": "forcePushed"}, {"oid": "e1d0b8650ef166476a9a1dacf06e3b3bdf24dc32", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/e1d0b8650ef166476a9a1dacf06e3b3bdf24dc32", "message": "another situations\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-10-07T11:14:03Z", "type": "commit"}, {"oid": "74012ed08e7de1a001e0e550ecfaac28dc43602c", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/74012ed08e7de1a001e0e550ecfaac28dc43602c", "message": "fix\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-10-07T12:00:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUxNTg4MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3721#discussion_r501515881", "bodyText": "The body of this catch clause seems to be identical to the catch (ForceableProblem e) above. Can we have just a single catch with the union type catch (ForceableProblem | IllegalArgumentException e)", "author": "tombentley", "createdAt": "2020-10-08T07:50:38Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/KafkaRoller.java", "diffHunk": "@@ -359,7 +362,55 @@ private void restartIfNecessary(int podId, RestartContext restartContext)\n             } else {\n                 throw e;\n             }\n+        } catch (IllegalArgumentException e) {", "originalCommit": "74012ed08e7de1a001e0e550ecfaac28dc43602c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUxNjY0NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3721#discussion_r501516644", "bodyText": "Breaking the long line at filter and collect means it fits on a screen and makes it easier to see the logic.", "author": "tombentley", "createdAt": "2020-10-08T07:51:59Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/KafkaRoller.java", "diffHunk": "@@ -359,7 +362,55 @@ private void restartIfNecessary(int podId, RestartContext restartContext)\n             } else {\n                 throw e;\n             }\n+        } catch (IllegalArgumentException e) {\n+            if (isPodStuck(pod) || restartContext.backOff.done()) {\n+                if (canRoll(podId, 60_000, TimeUnit.MILLISECONDS, true)) {\n+                    log.warn(\"{}: Pod {} will be force-rolled, due to error: {}\", reconciliation, podName(podId), e.getCause() != null ? e.getCause().getMessage() : e.getMessage());\n+                    restartAndAwaitReadiness(pod, operationTimeoutMs, TimeUnit.MILLISECONDS);\n+                } else {\n+                    log.warn(\"{}: Pod {} can't be safely force-rolled; original error: \", reconciliation, podName(podId), e.getCause() != null ? e.getCause().getMessage() : e.getMessage());\n+                    throw e;\n+                }\n+            } else {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    private boolean isCrashLooping(Pod pod) {\n+        return podWaitingBecauseOfReason(pod, \"CrashLoopBackOff\");\n+    }\n+\n+    private boolean isImagePullBackOff(Pod pod) {\n+        return podWaitingBecauseOfReason(pod, \"ImagePullBackOff\");\n+    }\n+\n+    private boolean isCreating(Pod pod) {\n+        return podWaitingBecauseOfReason(pod, \"ContainerCreating\");\n+    }\n+\n+    private boolean podWaitingBecauseOfReason(Pod pod, String reason) {\n+        if (pod != null && pod.getStatus() != null) {\n+            List<ContainerStatus> kafkaContainerStatus = pod.getStatus().getContainerStatuses().stream().filter(containerStatus -> containerStatus.getName().equals(\"kafka\")).collect(Collectors.toList());", "originalCommit": "74012ed08e7de1a001e0e550ecfaac28dc43602c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUxNzI1Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3721#discussion_r501517252", "bodyText": "If you're just interested in getting the first reason you should use findFirst, rather than collecting into a List. But is it correct that the container status we're looking for will always be the first in the list?", "author": "tombentley", "createdAt": "2020-10-08T07:52:57Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/KafkaRoller.java", "diffHunk": "@@ -359,7 +362,55 @@ private void restartIfNecessary(int podId, RestartContext restartContext)\n             } else {\n                 throw e;\n             }\n+        } catch (IllegalArgumentException e) {\n+            if (isPodStuck(pod) || restartContext.backOff.done()) {\n+                if (canRoll(podId, 60_000, TimeUnit.MILLISECONDS, true)) {\n+                    log.warn(\"{}: Pod {} will be force-rolled, due to error: {}\", reconciliation, podName(podId), e.getCause() != null ? e.getCause().getMessage() : e.getMessage());\n+                    restartAndAwaitReadiness(pod, operationTimeoutMs, TimeUnit.MILLISECONDS);\n+                } else {\n+                    log.warn(\"{}: Pod {} can't be safely force-rolled; original error: \", reconciliation, podName(podId), e.getCause() != null ? e.getCause().getMessage() : e.getMessage());\n+                    throw e;\n+                }\n+            } else {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    private boolean isCrashLooping(Pod pod) {\n+        return podWaitingBecauseOfReason(pod, \"CrashLoopBackOff\");\n+    }\n+\n+    private boolean isImagePullBackOff(Pod pod) {\n+        return podWaitingBecauseOfReason(pod, \"ImagePullBackOff\");\n+    }\n+\n+    private boolean isCreating(Pod pod) {\n+        return podWaitingBecauseOfReason(pod, \"ContainerCreating\");\n+    }\n+\n+    private boolean podWaitingBecauseOfReason(Pod pod, String reason) {\n+        if (pod != null && pod.getStatus() != null) {\n+            List<ContainerStatus> kafkaContainerStatus = pod.getStatus().getContainerStatuses().stream().filter(containerStatus -> containerStatus.getName().equals(\"kafka\")).collect(Collectors.toList());\n+            if (kafkaContainerStatus.size() > 0) {", "originalCommit": "74012ed08e7de1a001e0e550ecfaac28dc43602c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUyNjY3Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3721#discussion_r501526676", "bodyText": "from the tests, yes", "author": "sknot-rh", "createdAt": "2020-10-08T08:08:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUxNzI1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU0NDAwMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3721#discussion_r501544002", "bodyText": "That doesn't really mean that there does not exist a real-world circumstance where there's some other status which appears first, just that we've not run into such a circumstance yet.", "author": "tombentley", "createdAt": "2020-10-08T08:36:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUxNzI1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU2NDM0Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3721#discussion_r501564343", "bodyText": "What do you suggest?", "author": "sknot-rh", "createdAt": "2020-10-08T09:08:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUxNzI1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY3NDUwNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3721#discussion_r501674506", "bodyText": "I guess you can go through the list and check if it contains the conditions instead of checking just the first one?", "author": "scholzj", "createdAt": "2020-10-08T12:18:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUxNzI1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUxOTc2OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3721#discussion_r501519769", "bodyText": "In the worst case this will have to traverse the list of container statues 3 times. It would have been better to write a function private boolean podWaitingBecauseAnyOfReasons(Pod pod, Set<String> reasons) which would allow you to traverse the list once. Not that this is going to be hot code, but choosing appropriate algorithms is important.", "author": "tombentley", "createdAt": "2020-10-08T07:57:01Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/resource/KafkaRoller.java", "diffHunk": "@@ -359,7 +362,55 @@ private void restartIfNecessary(int podId, RestartContext restartContext)\n             } else {\n                 throw e;\n             }\n+        } catch (IllegalArgumentException e) {\n+            if (isPodStuck(pod) || restartContext.backOff.done()) {\n+                if (canRoll(podId, 60_000, TimeUnit.MILLISECONDS, true)) {\n+                    log.warn(\"{}: Pod {} will be force-rolled, due to error: {}\", reconciliation, podName(podId), e.getCause() != null ? e.getCause().getMessage() : e.getMessage());\n+                    restartAndAwaitReadiness(pod, operationTimeoutMs, TimeUnit.MILLISECONDS);\n+                } else {\n+                    log.warn(\"{}: Pod {} can't be safely force-rolled; original error: \", reconciliation, podName(podId), e.getCause() != null ? e.getCause().getMessage() : e.getMessage());\n+                    throw e;\n+                }\n+            } else {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    private boolean isCrashLooping(Pod pod) {\n+        return podWaitingBecauseOfReason(pod, \"CrashLoopBackOff\");\n+    }\n+\n+    private boolean isImagePullBackOff(Pod pod) {\n+        return podWaitingBecauseOfReason(pod, \"ImagePullBackOff\");\n+    }\n+\n+    private boolean isCreating(Pod pod) {\n+        return podWaitingBecauseOfReason(pod, \"ContainerCreating\");\n+    }\n+\n+    private boolean podWaitingBecauseOfReason(Pod pod, String reason) {\n+        if (pod != null && pod.getStatus() != null) {\n+            List<ContainerStatus> kafkaContainerStatus = pod.getStatus().getContainerStatuses().stream().filter(containerStatus -> containerStatus.getName().equals(\"kafka\")).collect(Collectors.toList());\n+            if (kafkaContainerStatus.size() > 0) {\n+                ContainerStateWaiting waiting = kafkaContainerStatus.get(0).getState().getWaiting();\n+                if (waiting != null) {\n+                    return reason.equals(waiting.getReason());\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean isPending(Pod pod) {\n+        if (pod != null && pod.getStatus() != null && \"Pending\".equals(pod.getStatus().getPhase())) {\n+            return true;\n         }\n+        return false;\n+    }\n+\n+    private boolean isPodStuck(Pod pod) {\n+        return isPending(pod) || isCrashLooping(pod) || isImagePullBackOff(pod) || isCreating(pod);", "originalCommit": "74012ed08e7de1a001e0e550ecfaac28dc43602c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "eef513c5799ac59f628a2bb9d02073a4a520d650", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/eef513c5799ac59f628a2bb9d02073a4a520d650", "message": "comments\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-10-08T09:00:27Z", "type": "commit"}, {"oid": "7e0f99e42e2d86b8afab064ec382784ef7997ccc", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/7e0f99e42e2d86b8afab064ec382784ef7997ccc", "message": "list to opt\n\nSigned-off-by: Stanislav Knot <sknot@redhat.com>", "committedDate": "2020-10-08T11:29:01Z", "type": "commit"}]}