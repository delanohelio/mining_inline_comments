{"pr_number": 2780, "pr_title": "Context succeeding - Part 7", "pr_createdAt": "2020-04-02T20:14:44Z", "pr_url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2780", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY1MDA1OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2780#discussion_r402650059", "bodyText": "I think some of these will cause lot of conflicts with my changes in #2737. Some things such as the metrics do not work well when you are opening and closing vertx too often. So I actually mmoved most of these to @BeforeAll / @afterall and tied to keep the method names as before and after. Was there any particular reason why moving Vet.x to @beforeeach / @AfterEach?", "author": "scholzj", "createdAt": "2020-04-02T23:17:34Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorCustomCertTest.java", "diffHunk": "@@ -62,17 +66,91 @@\n     private final String clusterName = \"testkafka\";\n     protected static Vertx vertx;\n \n-    @BeforeAll\n-    public static void before() {\n+    private Kafka kafka;\n+    private KafkaCluster kafkaCluster;\n+    private ResourceOperatorSupplier supplier;\n+    private KafkaAssemblyOperator operator;\n+    private ArgumentCaptor<StatefulSet> reconcileStsCaptor;\n+    private ArgumentCaptor<Function<Pod, String>> isPodToRestartFunctionCaptor;\n+\n+    /**\n+     * Mock the KafkaAssemblyOperator and override reconcile to only run through the steps we want to test\n+     */\n+    class MockKafkaAssemblyOperator extends KafkaAssemblyOperator  {\n+        public MockKafkaAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa, CertManager certManager, PasswordGenerator passwordGenerator, ResourceOperatorSupplier supplier, ClusterOperatorConfig config) {\n+            super(vertx, pfa, certManager, passwordGenerator, supplier, config);\n+        }\n+\n+        @Override\n+        Future<Void> reconcile(ReconciliationState reconcileState)  {\n+            return reconcileState.reconcileCas(this::dateSupplier)\n+                    .compose(state -> state.getKafkaClusterDescription())\n+                    .compose(state -> state.customTlsListenerCertificate())\n+                    .compose(state -> state.customExternalListenerCertificate())\n+                    .compose(state -> state.kafkaStatefulSet())\n+                    .compose(state -> state.kafkaRollingUpdate())\n+                    .map((Void) null);\n+        }\n+    }\n+\n+    @BeforeEach\n+    public void before() {", "originalCommit": "6f3992dedb2e5800e5d0777b3380e106d7813068", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1NDA0Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2780#discussion_r402854043", "bodyText": "You're absolutely right, I have changed it to follow your example.", "author": "samuel-hawker", "createdAt": "2020-04-03T08:55:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY1MDA1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY1MDIyMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2780#discussion_r402650221", "bodyText": "I guess this is some rebasing issue? Should it be deleted or uncommented?", "author": "scholzj", "createdAt": "2020-04-02T23:18:04Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorCustomCertTest.java", "diffHunk": "@@ -153,197 +231,207 @@ public Pod getPod(StatefulSet sts) {\n     }\n \n     @Test\n-    public void testWithUnchangedCertificates(VertxTestContext context) throws InterruptedException {\n-        Kafka kafka = getKafkaCrd();\n-        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(false);\n-        KafkaCluster kafkaCluster = KafkaCluster.fromCrd(kafka, VERSIONS, null);\n-\n-        // Mock the Kafka Operator\n-        CrdOperator mockKafkaOps = supplier.kafkaOperator;\n-        when(mockKafkaOps.getAsync(eq(namespace), eq(clusterName))).thenReturn(Future.succeededFuture(getKafkaCrd()));\n-        when(mockKafkaOps.updateStatusAsync(any())).thenReturn(Future.succeededFuture());\n-\n-        // Mock the KafkaSetOperator\n-        KafkaSetOperator mockKafkaSetOps = supplier.kafkaSetOperations;\n-        when(mockKafkaSetOps.getAsync(eq(namespace), eq(KafkaCluster.kafkaClusterName(clusterName)))).thenReturn(Future.succeededFuture(kafkaCluster.generateStatefulSet(false, null, null)));\n-\n-        ArgumentCaptor<StatefulSet> reconcileStsCaptor = ArgumentCaptor.forClass(StatefulSet.class);\n-        when(mockKafkaSetOps.reconcile(eq(namespace), eq(KafkaCluster.kafkaClusterName(clusterName)), reconcileStsCaptor.capture())).then(invocation -> {\n-            return Future.succeededFuture(ReconcileResult.patched(invocation.getArgument(2)));\n-        });\n-\n-        ArgumentCaptor<StatefulSet> maybeRollingUpdateStsCaptor = ArgumentCaptor.forClass(StatefulSet.class);\n-        ArgumentCaptor<Function<Pod, String>> isPodToRestartFunctionCaptor = ArgumentCaptor.forClass(Function.class);\n-        when(mockKafkaSetOps.maybeRollingUpdate(maybeRollingUpdateStsCaptor.capture(), isPodToRestartFunctionCaptor.capture())).thenReturn(Future.succeededFuture());\n-\n-        // Mock the ConfigMapOperator\n-        ConfigMapOperator mockCmOps = supplier.configMapOperations;\n-        when(mockCmOps.getAsync(eq(namespace), eq(clusterName))).thenReturn(Future.succeededFuture(kafkaCluster.generateMetricsAndLogConfigMap(null)));\n-\n-        // Mock the SecretOperator\n-        SecretOperator mockSecretOps = supplier.secretOperations;\n-        when(mockSecretOps.getAsync(eq(namespace), eq(\"my-tls-secret\"))).thenReturn(Future.succeededFuture(getTlsSecret()));\n-        when(mockSecretOps.getAsync(eq(namespace), eq(\"my-external-secret\"))).thenReturn(Future.succeededFuture(getExternalSecret()));\n-        when(mockSecretOps.reconcile(any(), any(), any())).then(invocation -> {\n-            return Future.succeededFuture(ReconcileResult.created(invocation.getArgument(2)));\n-        });\n-\n-        MockKafkaAssemblyOperator kao = new MockKafkaAssemblyOperator(vertx, new PlatformFeaturesAvailability(false, kubernetesVersion),\n-                certManager,\n-                passwordGenerator,\n-                supplier,\n-                config);\n-\n+    public void testPodToRestartFalseWhenCustomCertAnnotationsHaveMatchingThumbprints(VertxTestContext context) {\n         Checkpoint async = context.checkpoint();\n-        kao.createOrUpdate(new Reconciliation(\"test-trigger\", Kafka.RESOURCE_KIND, namespace, clusterName), kafka).setHandler(res -> {\n-            assertThat(res.succeeded(), is(true));\n-\n-            assertThat(reconcileStsCaptor.getAllValues().size(), is(1));\n-\n-            StatefulSet reconcileSts = reconcileStsCaptor.getValue();\n-            assertThat(reconcileSts.getSpec().getTemplate().getMetadata().getAnnotations().getOrDefault(KafkaCluster.ANNO_STRIMZI_CUSTOM_CERT_THUMBPRINT_TLS_LISTENER, \"\"), is(getTlsThumbprint()));\n-            assertThat(reconcileSts.getSpec().getTemplate().getMetadata().getAnnotations().getOrDefault(KafkaCluster.ANNO_STRIMZI_CUSTOM_CERT_THUMBPRINT_EXTERNAL_LISTENER, \"\"), is(getExternalThumbprint()));\n-\n-            assertThat(isPodToRestartFunctionCaptor.getAllValues().size(), is(1));\n-\n-            Function<Pod, String> isPodToRestart = isPodToRestartFunctionCaptor.getValue();\n-            assertThat(isPodToRestart.apply(getPod(reconcileSts)), is(nullValue()));\n-\n-            async.flag();\n-        });\n+        operator.createOrUpdate(new Reconciliation(\"test-trigger\", Kafka.RESOURCE_KIND, namespace, clusterName), kafka)\n+            .setHandler(context.succeeding(v -> context.verify(() -> {\n+                assertThat(reconcileStsCaptor.getAllValues(), hasSize(1));\n+\n+                StatefulSet reconcileSts = reconcileStsCaptor.getValue();\n+                assertThat(reconcileSts.getSpec().getTemplate().getMetadata().getAnnotations(),\n+                        hasEntry(KafkaCluster.ANNO_STRIMZI_CUSTOM_CERT_THUMBPRINT_TLS_LISTENER, getTlsThumbprint()));\n+                assertThat(reconcileSts.getSpec().getTemplate().getMetadata().getAnnotations(),\n+                        hasEntry(KafkaCluster.ANNO_STRIMZI_CUSTOM_CERT_THUMBPRINT_EXTERNAL_LISTENER, getExternalThumbprint()));\n+\n+                assertThat(isPodToRestartFunctionCaptor.getAllValues(), hasSize(1));\n+                Function<Pod, String> isPodToRestart = isPodToRestartFunctionCaptor.getValue();\n+                assertThat(isPodToRestart.apply(getPod(reconcileSts)), is(nullValue()));\n+\n+                async.flag();\n+            })));\n     }\n \n-    @Test\n-    public void testWithChangedTlsCertificate(VertxTestContext context) throws InterruptedException {\n-        Kafka kafka = getKafkaCrd();\n-        ResourceOperatorSupplier supplier = ResourceUtils.supplierWithMocks(false);\n-        KafkaCluster kafkaCluster = KafkaCluster.fromCrd(kafka, VERSIONS, null);\n-\n-        // Mock the Kafka Operator\n-        CrdOperator mockKafkaOps = supplier.kafkaOperator;\n-        when(mockKafkaOps.getAsync(eq(namespace), eq(clusterName))).thenReturn(Future.succeededFuture(getKafkaCrd()));\n-        when(mockKafkaOps.updateStatusAsync(any())).thenReturn(Future.succeededFuture());\n-\n-        // Mock the KafkaSetOperator\n-        KafkaSetOperator mockKafkaSetOps = supplier.kafkaSetOperations;\n-        when(mockKafkaSetOps.getAsync(eq(namespace), eq(KafkaCluster.kafkaClusterName(clusterName)))).thenReturn(Future.succeededFuture(kafkaCluster.generateStatefulSet(false, null, null)));\n-\n-        ArgumentCaptor<StatefulSet> reconcileStsCaptor = ArgumentCaptor.forClass(StatefulSet.class);\n-        when(mockKafkaSetOps.reconcile(eq(namespace), eq(KafkaCluster.kafkaClusterName(clusterName)), reconcileStsCaptor.capture())).then(invocation -> {\n-            return Future.succeededFuture(ReconcileResult.patched(invocation.getArgument(2)));\n-        });\n-\n-        ArgumentCaptor<StatefulSet> maybeRollingUpdateStsCaptor = ArgumentCaptor.forClass(StatefulSet.class);\n-        ArgumentCaptor<Function<Pod, String>> isPodToRestartFunctionCaptor = ArgumentCaptor.forClass(Function.class);\n-        when(mockKafkaSetOps.maybeRollingUpdate(maybeRollingUpdateStsCaptor.capture(), isPodToRestartFunctionCaptor.capture())).thenReturn(Future.succeededFuture());\n-\n-        // Mock the ConfigMapOperator\n-        ConfigMapOperator mockCmOps = supplier.configMapOperations;\n-        when(mockCmOps.get(eq(namespace), eq(clusterName))).thenReturn(kafkaCluster.generateMetricsAndLogConfigMap(null));\n-\n-        // Mock the SecretOperator\n-        SecretOperator mockSecretOps = supplier.secretOperations;\n-        when(mockSecretOps.getAsync(eq(namespace), eq(\"my-tls-secret\"))).thenReturn(Future.succeededFuture(getTlsSecret()));\n-        when(mockSecretOps.getAsync(eq(namespace), eq(\"my-external-secret\"))).thenReturn(Future.succeededFuture(getExternalSecret()));\n-        when(mockSecretOps.reconcile(any(), any(), any())).then(invocation -> {\n-            return Future.succeededFuture(ReconcileResult.created(invocation.getArgument(2)));\n-        });\n-\n-        MockKafkaAssemblyOperator kao = new MockKafkaAssemblyOperator(vertx, new PlatformFeaturesAvailability(false, kubernetesVersion),\n-                certManager,\n-                passwordGenerator,\n-                supplier,\n-                config);\n+//<<<<<<<HEAD", "originalCommit": "6f3992dedb2e5800e5d0777b3380e106d7813068", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1NDE4Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2780#discussion_r402854182", "bodyText": "Woops! Deleted", "author": "samuel-hawker", "createdAt": "2020-04-03T08:55:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY1MDIyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY1MDc2Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2780#discussion_r402650767", "bodyText": "In #2737 I tended to use before and after which seemed to be used most often as method names. I do not have strong preference, but we should try to use the same everywhere.", "author": "scholzj", "createdAt": "2020-04-02T23:19:41Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperatorMockTest.java", "diffHunk": "@@ -195,19 +204,35 @@ public void setFields(KafkaAssemblyOperatorMockTest.Params params) {\n         this.kafkaStorage = params.kafkaStorage;\n \n         this.resources = params.resources;\n-        this.before();\n     }\n \n-    private Vertx vertx;\n     private Kafka cluster;\n \n-    public void before() {\n-        this.cluster = new KafkaBuilder()\n-                .withMetadata(new ObjectMetaBuilder()\n-                        .withName(CLUSTER_NAME)\n-                        .withNamespace(NAMESPACE)\n-                        .withLabels(TestUtils.map(\"foo\", \"bar\"))\n-                        .build())\n+    @BeforeAll\n+    static void setup() {", "originalCommit": "6f3992dedb2e5800e5d0777b3380e106d7813068", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "203b16fe0a0e6f513eac901e10ffc02e0b832a0b", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/203b16fe0a0e6f513eac901e10ffc02e0b832a0b", "message": "feat: Context succeeding - Part 7\n\nFor this Pull request I have continued the context\nsucceeding work, and taken the opportunity to remove\nunneeded concurrency based dependencies.\nminor test renames, hamcrest additions and variable\nrenames to improve clarity.\n\nPart 7 : cluster-operator\nTest refactoring removing test exceptions\nMove repeated code to BeforeEach methods\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-04-03T12:10:36Z", "type": "commit"}, {"oid": "a31ba339ad69198d1896896fa5c824844d28753c", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/a31ba339ad69198d1896896fa5c824844d28753c", "message": "feat: Assembly operator refactor\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-04-03T12:12:38Z", "type": "commit"}, {"oid": "6a711b1ffff35bbdf5ccada87bfd330c50610975", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/6a711b1ffff35bbdf5ccada87bfd330c50610975", "message": "chore: address review comments\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-04-03T12:12:38Z", "type": "commit"}, {"oid": "8547520469076007b869e39c653fe22eec4edc60", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/8547520469076007b869e39c653fe22eec4edc60", "message": "feat: Merge conflict\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-04-03T12:58:06Z", "type": "commit"}, {"oid": "8547520469076007b869e39c653fe22eec4edc60", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/8547520469076007b869e39c653fe22eec4edc60", "message": "feat: Merge conflict\n\nSigned-off-by: Samuel Hawker <samuel.hawker@ibm.com>", "committedDate": "2020-04-03T12:58:06Z", "type": "forcePushed"}]}